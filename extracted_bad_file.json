[["3f75c5788ea80f1ea8de77ed565a3281", {"code_string": "def test_delitem_keyerror(self):\n    e = EntryBase(req_()\n    del e['missing_key']\n", "code_toks_joined": "def test_delitem_keyerror ( self ) : <NEWLINE> <INDENT> e = EntryBase ( req_ ( ) <NEWLINE> del e [ <STRING> ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'missing_key'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["999066dadabc7f66d374c02985ccca4b", {"code_string": "def retranslateUi(self, SettingsDialog_base):\n    SettingsDialog_base.setWindowTitle(QtGui.QApplication.translate(\"SettingsDialog_base\", \"HP Device Manager - Settings\", None, QtGui.QApplication.UnicodeUTF8))\n    self.textLabel3_2_2.setText(QtGui.QApplication.translate(\"SettingsDialog_base\", \"<html><head><meta name=\\\"qrichtext\\\" content=\\\"1\\\" /><style type=\\\"text/css\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , SettingsDialog_base ) : <NEWLINE> <INDENT> SettingsDialog_base . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . textLabel3_2_2 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"SettingsDialog_base\"", "\"HP Device Manager - Settings\"", "\"SettingsDialog_base\"", "\"<html><head><meta name=\\\"qrichtext\\\" content=\\\"1\\\" /><style type=\\\"text/css\\\">\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["f28bacdd960e75252c5d01442a9cce0b", {"code_string": "def process(fn, mergefile = None, lazy = False):\n    if lazy and mergefile and os.stat(fn).st_mtime < os.stat(mergefile).st_mtime:\n    return\n    print(mergefile)\n    gen = Gen()\n    directives.execute(directives.load(fn), gen)\n    result = gen.generate()\n    if mergefile is None:\n        print(result)\n    else:\n    print('Merging %s into %s' %(fn, mergefile))\n        result = merge(mergefile, result)\n", "code_toks_joined": "def process ( fn , mergefile = None , lazy = False ) : <NEWLINE> <INDENT> if lazy and mergefile and os . stat ( fn ) . st_mtime < os . stat ( mergefile ) . st_mtime : <NEWLINE> return <NEWLINE> print ( mergefile ) <NEWLINE> gen = Gen ( ) <NEWLINE> directives . execute ( directives . load ( fn ) , gen ) <NEWLINE> result = gen . generate ( ) <NEWLINE> if mergefile is None : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> else : <NEWLINE> print ( <STRING> % ( fn , mergefile ) ) <NEWLINE> <INDENT> result = merge ( mergefile , result ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Merging %s into %s'"]}, "err_obj": {"msg": "expected an indented block"}}], ["c38788ef6d867090c5c1876e48466901", {"code_string": "def samePath(path1, path2):\n    '''Returns true if two given pathes path1 and path2 point to the same location'''\n    if os.path.abspath(path1) == os.path.abspath(path2):\n    return True\n    else:\n    return False\n", "code_toks_joined": "def samePath ( path1 , path2 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if os . path . abspath ( path1 ) == os . path . abspath ( path2 ) : <NEWLINE> return True <NEWLINE> else : <NEWLINE> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Returns true if two given pathes path1 and path2 point to the same location'''"]}, "err_obj": {"msg": "expected an indented block"}}], ["53bb12b19a4b0c8087a44c55bd7995c8", {"code_string": "def output_to_file(filename, mode = 'w'):\n    with contextlib.closing(open(filename, mode)) as port:\n    with CURRENT_OUTPUT_PORT.let(port):\n        yield\n", "code_toks_joined": "def output_to_file ( filename , mode = <STRING> ) : <NEWLINE> <INDENT> with contextlib . closing ( open ( filename , mode ) ) as port : <NEWLINE> with CURRENT_OUTPUT_PORT . let ( port ) : <NEWLINE> <INDENT> yield <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'w'"]}, "err_obj": {"msg": "expected an indented block"}}], ["1aef782c2e82fc988b7f2f8a7f371393", {"code_string": "def create(self, req, body = None):\n    \"\"\"Return a list of certificates.\"\"\"\n    context = req.environ['nova.context']\n    authorize(context)\n    pk, cert = rpc.call(context, FLAGS.cert_topic,\n        {\"method\": \"generate_x509_cert\",\n            \"args\": {\"user_id\": context.user_id,\n                \"project_id\": context.project_id})\n    context = req.environ['nova.context']\n    return{'certificate': _translate_certificate_view(cert, pk)}\n", "code_toks_joined": "def create ( self , req , body = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> context = req . environ [ <STRING> ] <NEWLINE> authorize ( context ) <NEWLINE> pk , cert = rpc . call ( context , FLAGS . cert_topic , <NEWLINE> <INDENT> { <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : { <STRING> : context . user_id , <NEWLINE> <INDENT> <STRING> : context . project_id } ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> context = req . environ [ <STRING> ] <NEWLINE> return { <STRING> : _translate_certificate_view ( cert , pk ) } <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return a list of certificates.\"\"\"", "'nova.context'", "\"method\"", "\"generate_x509_cert\"", "\"args\"", "\"user_id\"", "\"project_id\"", "'nova.context'", "'certificate'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["7f066de7ac400e7b32b18b271fdab496", {"code_string": "def get_mimetype(res, filename):\n    if res in(\n        'application/x-download',\n        'application/x-application',\n        'application/binary',\n        'application/octet-stream',\n        ):\n        guessed_type, _ = mimetypes.guess_type(filename)\n        if guessed_type:\n        res = guessed_type\n    return res\n", "code_toks_joined": "def get_mimetype ( res , filename ) : <NEWLINE> <INDENT> if res in ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> ) : <NEWLINE> guessed_type , _ = mimetypes . guess_type ( filename ) <NEWLINE> if guessed_type : <NEWLINE> res = guessed_type <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'application/x-download'", "'application/x-application'", "'application/binary'", "'application/octet-stream'"]}, "err_obj": {"msg": "expected an indented block"}}], ["07e4ecb86091f3ffbcdf30894f3ef6c5", {"code_string": "def _GenApiConfigCallback(args, api_func = GenApiConfig):\n    \"\"\"Generate an api file.\"\"\"\n    service_configs = api_func(args.service\n        hostname = args.hostname,\n        application_path = args.application)\n    for api_name_version, config in service_configs.iteritems():\n        _WriteFile(args.output, api_name_version + '.api', config)\n", "code_toks_joined": "def _GenApiConfigCallback ( args , api_func = GenApiConfig ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> service_configs = api_func ( args . service <NEWLINE> <INDENT> hostname = args . hostname , <NEWLINE> application_path = args . application ) <NEWLINE> <DEDENT> for api_name_version , config in service_configs . iteritems ( ) : <NEWLINE> <INDENT> _WriteFile ( args . output , api_name_version + <STRING> , config ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Generate an api file.\"\"\"", "'.api'"]}, "err_obj": {"msg": "invalid syntax"}}], ["d41e86c190acc5c2b1542f43fee899a3", {"code_string": "def expand_light_count(dimmed_rgb count):\n    dmx_channels = []\n    for light in range(count):\n        dmx_channels.extend(dimmed_rgb)\n    return dmx_channels\n", "code_toks_joined": "def expand_light_count ( dimmed_rgb count ) : <NEWLINE> <INDENT> dmx_channels = [ ] <NEWLINE> for light in range ( count ) : <NEWLINE> <INDENT> dmx_channels . extend ( dimmed_rgb ) <NEWLINE> <DEDENT> return dmx_channels <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["7306beb5ac9e44d446d0613840256977", {"code_string": "def setupUi(self, ManitaeMainWindow):\n    ManitaeMainWindow.setObjectName(_fromUtf8(\"ManitaeMainWindow\"))\n    ManitaeMainWindow.resize(1305, 666)\n    ManitaeMainWindow.setWindowTitle(QtGui.QApplication.translate(\"ManitaeMainWindow\", \"Manitae\", None, QtGui.QApplication.UnicodeUTF8))\n    self.centralWidget = QtGui.QWidget(ManitaeMainWindow)\n    self.centralWidget.setObjectName(_fromUtf8(\"centralWidget\"))\n    self.gridLayout_2 = QtGui.QGridLayout(self.centralWidget)\n    self.gridLayout_2.setObjectName(_fromUtf8(\"gridLayout_2\"))\n    self.tabWidget = QtGui.QTabWidget(self.centralWidget)\n    self.tabWidget.setObjectName(_fromUtf8(\"tabWidget\"))\n    self.tab = QtGui.QWidget()\n    self.tab.setObjectName(_fromUtf8(\"tab\"))\n    self.gridLayout = QtGui.QGridLayout(self.tab)\n    self.gridLayout.setObjectName(_fromUtf8(\"gridLayout\"))\n    self.widget = ManitaeSummary(self.tab)\n    self.widget.setObjectName(_fromUtf8(\"widget\"))\n    self.gridLayout.addWidget(self.widget, 0, 0, 1, 1)\n    self.tabWidget.addTab(self.tab, _fromUtf8(\"\"))\n    self.tab_2 = QtGui.QWidget()\n    self.tab_2.setObjectName(_fromUtf8(\"tab_2\"))\n    self.gridLayout_3 = QtGui.QGridLayout(self.tab_2)\n    self.gridLayout_3.setObjectName(_fromUtf8(\"gridLayout_3\"))\n    self.peopleTabWidget = QtGui.QTabWidget(self.tab_2)\n    self.peopleTabWidget.setObjectName(_fromUtf8(\"peopleTabWidget\"))\n    self.gridLayout_3.addWidget(self.peopleTabWidget, 0, 0, 1, 1)\n    self.tabWidget.addTab(self.tab_2, _fromUtf8(\"\"))\n    self.tab_3 = QtGui.QWidget()\n    self.tab_3.setObjectName(_fromUtf8(\"tab_3\"))\n    self.gridLayout_7 = QtGui.QGridLayout(self.tab_3)\n    self.gridLayout_7.setObjectName(_fromUtf8(\"gridLayout_7\"))\n    self.mapTabWidget = QtGui.QWidget(self.tab_3)\n    self.mapTabWidget.setObjectName(_fromUtf8(\"mapTabWidget\"))\n    self.verticalLayout = QtGui.QVBoxLayout(self.mapTabWidget)\n    self.verticalLayout.setMargin(0)\n    self.verticalLayout.setObjectName(_fromUtf8(\"verticalLayout\"))\n    self.mapView = QtDeclarative.QDeclarativeView(self.mapTabWidget)\n    self.mapView.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)\n    self.mapView.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)\n    self.mapView.setResizeMode(QtDeclarative.QDeclarativeView.SizeViewToRootObject)\n    self.mapView.setObjectName(_fromUtf8(\"mapView\"))\n    self.verticalLayout.addWidget(self.mapView)\n    self.verticalLayout_2 = QtGui.QVBoxLayout()\n    self.verticalLayout_2.setObjectName(_fromUtf8(\"verticalLayout_2\"))\n    self.groupBox = QtGui.QGroupBox(self.mapTabWidget)\n    self.groupBox.setTitle(QtGui.QApplication.translate(\"ManitaeMainWindow\", \"On This Square\", None, QtGui.QApplication.UnicodeUTF8))\n    self.groupBox.setObjectName(_fromUtf8(\"groupBox\"))\n    self.formLayout_2 = QtGui.QFormLayout(self.groupBox)\n    self.formLayout_2.setFieldGrowthPolicy(QtGui.QFormLayout.ExpandingFieldsGrow)\n    self.formLayout_2.setObjectName(_fromUtf8(\"formLayout_2\"))\n    self.label = QtGui.QLabel(self.groupBox)\n    self.label.setText(QtGui.QApplication.translate(\"ManitaeMainWindow\", \"Position\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label.setObjectName(_fromUtf8(\"label\"))\n    self.formLayout_2.setWidget(0, QtGui.QFormLayout.LabelRole, self.label)\n    self.positionLineEdit = QtGui.QLineEdit(self.groupBox)\n    self.positionLineEdit.setReadOnly(True)\n    self.positionLineEdit.setObjectName(_fromUtf8(\"positionLineEdit\"))\n    self.formLayout_2.setWidget(0, QtGui.QFormLayout.FieldRole, self.positionLineEdit)\n    self.label_2 = QtGui.QLabel(self.groupBox)\n    self.label_2.setText(QtGui.QApplication.translate(\"ManitaeMainWindow\", \"Object\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_2.setObjectName(_fromUtf8(\"label_2\"))\n    self.formLayout_2.setWidget(1, QtGui.QFormLayout.LabelRole, self.label_2)\n    self.tileOccupantLineEdit = QtGui.QLineEdit(self.groupBox)\n    self.tileOccupantLineEdit.setReadOnly(True)\n    self.tileOccupantLineEdit.setObjectName(_fromUtf8(\"tileOccupantLineEdit\"))\n    self.formLayout_2.setWidget(1, QtGui.QFormLayout.FieldRole, self.tileOccupantLineEdit)\n    self.verticalLayout_2.addWidget(self.groupBox)\n    self.groupBox_2 = QtGui.QGroupBox(self.mapTabWidget)\n    self.groupBox_2.setTitle(QtGui.QApplication.translate(\"ManitaeMainWindow\", \"Actions\", None, QtGui.QApplication.UnicodeUTF8))\n    self.groupBox_2.setObjectName(_fromUtf8(\"groupBox_2\"))\n    self.gridLayout_6 = QtGui.QGridLayout(self.groupBox_2)\n    self.gridLayout_6.setObjectName(_fromUtf8(\"gridLayout_6\"))\n    self.buildPushButton = QtGui.QPushButton(self.groupBox_2)\n    self.buildPushButton.setEnabled(False)\n    self.buildPushButton.setText(QtGui.QApplication.translate(\"ManitaeMainWindow\", \"Build\", None, QtGui.QApplication.UnicodeUTF8))\n    self.buildPushButton.setObjectName(_fromUtf8(\"buildPushButton\"))\n    self.gridLayout_6.addWidget(self.buildPushButton, 0, 1, 1, 1)\n    self.buildComboBox = QtGui.QComboBox(self.groupBox_2)\n    self.buildComboBox.setObjectName(_fromUtf8(\"buildComboBox\"))\n    self.gridLayout_6.addWidget(self.buildComboBox, 0, 0, 1, 1)\n    self.pushButton_2 = QtGui.QPushButton(self.groupBox_2)\n    self.pushButton_2.setEnabled(False)\n    self.pushButton_2.setText(QtGui.QApplication.translate(\"ManitaeMainWindow\", \"Destroy\", None, QtGui.QApplication.UnicodeUTF8))\n    self.pushButton_2.setObjectName(_fromUtf8(\"pushButton_2\"))\n    self.gridLayout_6.addWidget(self.pushButton_2, 1, 1, 1, 1)\n    self.goToTabPushButton = QtGui.QPushButton(self.groupBox_2)\n    self.goToTabPushButton.setEnabled(False)\n    self.goToTabPushButton.setText(QtGui.QApplication.translate(\"ManitaeMainWindow\", \"Go to Unit\\'s tab\", None, QtGui.QApplication.UnicodeUTF8))\n    self.goToTabPushButton.setObjectName(_fromUtf8(\"goToTabPushButton\"))\n    self.gridLayout_6.addWidget(self.goToTabPushButton, 1, 0, 1, 1)\n    self.verticalLayout_2.addWidget(self.groupBox_2)\n    self.verticalLayout.addLayout(self.verticalLayout_2)\n    self.gridLayout_7.addWidget(self.mapTabWidget, 0, 0, 1, 1)\n    self.tabWidget.addTab(self.tab_3, _fromUtf8(\"\"))\n    self.gridLayout_2.addWidget(self.tabWidget, 0, 0, 1, 1)\n    ManitaeMainWindow.setCentralWidget(self.centralWidget)\n    self.menuBar = QtGui.QMenuBar(ManitaeMainWindow)\n    self.menuBar.setGeometry(QtCore.QRect(0, 0, 1305, 21))\n    self.menuBar.setObjectName(_fromUtf8(\"menuBar\"))\n    self.menuGame = QtGui.QMenu(self.menuBar)\n    self.menuGame.setTitle(QtGui.QApplication.translate(\"ManitaeMainWindow\", \"Game\", None, QtGui.QApplication.UnicodeUTF8))\n    self.menuGame.setObjectName(_fromUtf8(\"menuGame\"))\n    self.menuStats = QtGui.QMenu(self.menuBar)\n    self.menuStats.setTitle(QtGui.QApplication.translate(\"ManitaeMainWindow\", \"Stats\", None, QtGui.QApplication.UnicodeUTF8))\n    self.menuStats.setObjectName(_fromUtf8(\"menuStats\"))\n    self.menuHelp = QtGui.QMenu(self.menuBar)\n    self.menuHelp.setTitle(QtGui.QApplication.translate(\"ManitaeMainWindow\", \"Help\", None, QtGui.QApplication.UnicodeUTF8))\n    self.menuHelp.setObjectName(_fromUtf8(\"menuHelp\"))\n    ManitaeMainWindow.setMenuBar(self.menuBar)\n    self.mainToolBar = QtGui.QToolBar(ManitaeMainWindow)\n    self.mainToolBar.setMovable(False)\n    self.mainToolBar.setFloatable(False)\n    self.mainToolBar.setObjectName(_fromUtf8(\"mainToolBar\"))\n    ManitaeMainWindow.addToolBar(QtCore.Qt.TopToolBarArea, self.mainToolBar)\n    self.statusBar = QtGui.QStatusBar(ManitaeMainWindow)\n    self.statusBar.setObjectName(_fromUtf8(\"statusBar\"))\n    ManitaeMainWindow.setStatusBar(self.statusBar)\n    self.dockWidget = QtGui.QDockWidget(ManitaeMainWindow)\n    self.dockWidget.setWindowTitle(QtGui.QApplication.translate(\"ManitaeMainWindow\", \"Notices\", None, QtGui.QApplication.UnicodeUTF8))\n    self.dockWidget.setObjectName(_fromUtf8(\"dockWidget\"))\n    self.dockWidgetContents = QtGui.QWidget()\n    self.dockWidgetContents.setObjectName(_fromUtf8(\"dockWidgetContents\"))\n    self.gridLayout_4 = QtGui.QGridLayout(self.dockWidgetContents)\n    self.gridLayout_4.setObjectName(_fromUtf8(\"gridLayout_4\"))\n    self.noticeLog = QtGui.QTextEdit(self.dockWidgetContents)\n    self.noticeLog.setEnabled(True)\n    self.noticeLog.setReadOnly(True)\n    self.noticeLog.setHtml(QtGui.QApplication.translate(\"ManitaeMainWindow\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def setupUi ( self , ManitaeMainWindow ) : <NEWLINE> <INDENT> ManitaeMainWindow . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> ManitaeMainWindow . resize ( 1305 , 666 ) <NEWLINE> ManitaeMainWindow . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . centralWidget = QtGui . QWidget ( ManitaeMainWindow ) <NEWLINE> self . centralWidget . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_2 = QtGui . QGridLayout ( self . centralWidget ) <NEWLINE> self . gridLayout_2 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . tabWidget = QtGui . QTabWidget ( self . centralWidget ) <NEWLINE> self . tabWidget . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . tab = QtGui . QWidget ( ) <NEWLINE> self . tab . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout = QtGui . QGridLayout ( self . tab ) <NEWLINE> self . gridLayout . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . widget = ManitaeSummary ( self . tab ) <NEWLINE> self . widget . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout . addWidget ( self . widget , 0 , 0 , 1 , 1 ) <NEWLINE> self . tabWidget . addTab ( self . tab , _fromUtf8 ( <STRING> ) ) <NEWLINE> self . tab_2 = QtGui . QWidget ( ) <NEWLINE> self . tab_2 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_3 = QtGui . QGridLayout ( self . tab_2 ) <NEWLINE> self . gridLayout_3 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . peopleTabWidget = QtGui . QTabWidget ( self . tab_2 ) <NEWLINE> self . peopleTabWidget . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_3 . addWidget ( self . peopleTabWidget , 0 , 0 , 1 , 1 ) <NEWLINE> self . tabWidget . addTab ( self . tab_2 , _fromUtf8 ( <STRING> ) ) <NEWLINE> self . tab_3 = QtGui . QWidget ( ) <NEWLINE> self . tab_3 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_7 = QtGui . QGridLayout ( self . tab_3 ) <NEWLINE> self . gridLayout_7 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . mapTabWidget = QtGui . QWidget ( self . tab_3 ) <NEWLINE> self . mapTabWidget . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . verticalLayout = QtGui . QVBoxLayout ( self . mapTabWidget ) <NEWLINE> self . verticalLayout . setMargin ( 0 ) <NEWLINE> self . verticalLayout . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . mapView = QtDeclarative . QDeclarativeView ( self . mapTabWidget ) <NEWLINE> self . mapView . setVerticalScrollBarPolicy ( QtCore . Qt . ScrollBarAsNeeded ) <NEWLINE> self . mapView . setHorizontalScrollBarPolicy ( QtCore . Qt . ScrollBarAsNeeded ) <NEWLINE> self . mapView . setResizeMode ( QtDeclarative . QDeclarativeView . SizeViewToRootObject ) <NEWLINE> self . mapView . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . verticalLayout . addWidget ( self . mapView ) <NEWLINE> self . verticalLayout_2 = QtGui . QVBoxLayout ( ) <NEWLINE> self . verticalLayout_2 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . groupBox = QtGui . QGroupBox ( self . mapTabWidget ) <NEWLINE> self . groupBox . setTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . groupBox . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . formLayout_2 = QtGui . QFormLayout ( self . groupBox ) <NEWLINE> self . formLayout_2 . setFieldGrowthPolicy ( QtGui . QFormLayout . ExpandingFieldsGrow ) <NEWLINE> self . formLayout_2 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label = QtGui . QLabel ( self . groupBox ) <NEWLINE> self . label . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . formLayout_2 . setWidget ( 0 , QtGui . QFormLayout . LabelRole , self . label ) <NEWLINE> self . positionLineEdit = QtGui . QLineEdit ( self . groupBox ) <NEWLINE> self . positionLineEdit . setReadOnly ( True ) <NEWLINE> self . positionLineEdit . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . formLayout_2 . setWidget ( 0 , QtGui . QFormLayout . FieldRole , self . positionLineEdit ) <NEWLINE> self . label_2 = QtGui . QLabel ( self . groupBox ) <NEWLINE> self . label_2 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_2 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . formLayout_2 . setWidget ( 1 , QtGui . QFormLayout . LabelRole , self . label_2 ) <NEWLINE> self . tileOccupantLineEdit = QtGui . QLineEdit ( self . groupBox ) <NEWLINE> self . tileOccupantLineEdit . setReadOnly ( True ) <NEWLINE> self . tileOccupantLineEdit . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . formLayout_2 . setWidget ( 1 , QtGui . QFormLayout . FieldRole , self . tileOccupantLineEdit ) <NEWLINE> self . verticalLayout_2 . addWidget ( self . groupBox ) <NEWLINE> self . groupBox_2 = QtGui . QGroupBox ( self . mapTabWidget ) <NEWLINE> self . groupBox_2 . setTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . groupBox_2 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_6 = QtGui . QGridLayout ( self . groupBox_2 ) <NEWLINE> self . gridLayout_6 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . buildPushButton = QtGui . QPushButton ( self . groupBox_2 ) <NEWLINE> self . buildPushButton . setEnabled ( False ) <NEWLINE> self . buildPushButton . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . buildPushButton . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_6 . addWidget ( self . buildPushButton , 0 , 1 , 1 , 1 ) <NEWLINE> self . buildComboBox = QtGui . QComboBox ( self . groupBox_2 ) <NEWLINE> self . buildComboBox . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_6 . addWidget ( self . buildComboBox , 0 , 0 , 1 , 1 ) <NEWLINE> self . pushButton_2 = QtGui . QPushButton ( self . groupBox_2 ) <NEWLINE> self . pushButton_2 . setEnabled ( False ) <NEWLINE> self . pushButton_2 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . pushButton_2 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_6 . addWidget ( self . pushButton_2 , 1 , 1 , 1 , 1 ) <NEWLINE> self . goToTabPushButton = QtGui . QPushButton ( self . groupBox_2 ) <NEWLINE> self . goToTabPushButton . setEnabled ( False ) <NEWLINE> self . goToTabPushButton . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . goToTabPushButton . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_6 . addWidget ( self . goToTabPushButton , 1 , 0 , 1 , 1 ) <NEWLINE> self . verticalLayout_2 . addWidget ( self . groupBox_2 ) <NEWLINE> self . verticalLayout . addLayout ( self . verticalLayout_2 ) <NEWLINE> self . gridLayout_7 . addWidget ( self . mapTabWidget , 0 , 0 , 1 , 1 ) <NEWLINE> self . tabWidget . addTab ( self . tab_3 , _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_2 . addWidget ( self . tabWidget , 0 , 0 , 1 , 1 ) <NEWLINE> ManitaeMainWindow . setCentralWidget ( self . centralWidget ) <NEWLINE> self . menuBar = QtGui . QMenuBar ( ManitaeMainWindow ) <NEWLINE> self . menuBar . setGeometry ( QtCore . QRect ( 0 , 0 , 1305 , 21 ) ) <NEWLINE> self . menuBar . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . menuGame = QtGui . QMenu ( self . menuBar ) <NEWLINE> self . menuGame . setTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . menuGame . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . menuStats = QtGui . QMenu ( self . menuBar ) <NEWLINE> self . menuStats . setTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . menuStats . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . menuHelp = QtGui . QMenu ( self . menuBar ) <NEWLINE> self . menuHelp . setTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . menuHelp . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> ManitaeMainWindow . setMenuBar ( self . menuBar ) <NEWLINE> self . mainToolBar = QtGui . QToolBar ( ManitaeMainWindow ) <NEWLINE> self . mainToolBar . setMovable ( False ) <NEWLINE> self . mainToolBar . setFloatable ( False ) <NEWLINE> self . mainToolBar . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> ManitaeMainWindow . addToolBar ( QtCore . Qt . TopToolBarArea , self . mainToolBar ) <NEWLINE> self . statusBar = QtGui . QStatusBar ( ManitaeMainWindow ) <NEWLINE> self . statusBar . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> ManitaeMainWindow . setStatusBar ( self . statusBar ) <NEWLINE> self . dockWidget = QtGui . QDockWidget ( ManitaeMainWindow ) <NEWLINE> self . dockWidget . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . dockWidget . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . dockWidgetContents = QtGui . QWidget ( ) <NEWLINE> self . dockWidgetContents . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_4 = QtGui . QGridLayout ( self . dockWidgetContents ) <NEWLINE> self . gridLayout_4 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . noticeLog = QtGui . QTextEdit ( self . dockWidgetContents ) <NEWLINE> self . noticeLog . setEnabled ( True ) <NEWLINE> self . noticeLog . setReadOnly ( True ) <NEWLINE> self . noticeLog . setHtml ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"ManitaeMainWindow\"", "\"ManitaeMainWindow\"", "\"Manitae\"", "\"centralWidget\"", "\"gridLayout_2\"", "\"tabWidget\"", "\"tab\"", "\"gridLayout\"", "\"widget\"", "\"\"", "\"tab_2\"", "\"gridLayout_3\"", "\"peopleTabWidget\"", "\"\"", "\"tab_3\"", "\"gridLayout_7\"", "\"mapTabWidget\"", "\"verticalLayout\"", "\"mapView\"", "\"verticalLayout_2\"", "\"ManitaeMainWindow\"", "\"On This Square\"", "\"groupBox\"", "\"formLayout_2\"", "\"ManitaeMainWindow\"", "\"Position\"", "\"label\"", "\"positionLineEdit\"", "\"ManitaeMainWindow\"", "\"Object\"", "\"label_2\"", "\"tileOccupantLineEdit\"", "\"ManitaeMainWindow\"", "\"Actions\"", "\"groupBox_2\"", "\"gridLayout_6\"", "\"ManitaeMainWindow\"", "\"Build\"", "\"buildPushButton\"", "\"buildComboBox\"", "\"ManitaeMainWindow\"", "\"Destroy\"", "\"pushButton_2\"", "\"ManitaeMainWindow\"", "\"Go to Unit\\'s tab\"", "\"goToTabPushButton\"", "\"\"", "\"menuBar\"", "\"ManitaeMainWindow\"", "\"Game\"", "\"menuGame\"", "\"ManitaeMainWindow\"", "\"Stats\"", "\"menuStats\"", "\"ManitaeMainWindow\"", "\"Help\"", "\"menuHelp\"", "\"mainToolBar\"", "\"statusBar\"", "\"ManitaeMainWindow\"", "\"Notices\"", "\"dockWidget\"", "\"dockWidgetContents\"", "\"gridLayout_4\"", "\"ManitaeMainWindow\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "window_span": [1754, 1766], "err_obj": {"msg": "unbalanced (){}[]"}}], ["a2964df37b833ce79d7f1f9ad0f5e862", {"code_string": "def read_xyz(filename):\n    \"\"\"Read filename in XYZ format and return lists of atoms and coordinates.\"\"\"\n    atoms = []\n    coordinates = []\n    xyz = open(filename)\n    n_atoms = int(xyz.readline())\n    title = xyz.readline()\n    for line in xyz:\n        atom, x, y, z = line.split()\n        atoms.append(atom)\n        coordinates.append([float(x), float(y), float(z)])\n    xyz.close()\n    if n_atoms != len(coordinates):\n        raise ValueError(\"File says %d atoms but read %d points.\" %(n_atoms, len(coordinates))\n    return atoms, coordinates\n", "code_toks_joined": "def read_xyz ( filename ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> atoms = [ ] <NEWLINE> coordinates = [ ] <NEWLINE> xyz = open ( filename ) <NEWLINE> n_atoms = int ( xyz . readline ( ) ) <NEWLINE> title = xyz . readline ( ) <NEWLINE> for line in xyz : <NEWLINE> <INDENT> atom , x , y , z = line . split ( ) <NEWLINE> atoms . append ( atom ) <NEWLINE> coordinates . append ( [ float ( x ) , float ( y ) , float ( z ) ] ) <NEWLINE> <DEDENT> xyz . close ( ) <NEWLINE> if n_atoms != len ( coordinates ) : <NEWLINE> <INDENT> raise ValueError ( <STRING> % ( n_atoms , len ( coordinates ) ) <NEWLINE> <DEDENT> return atoms , coordinates <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Read filename in XYZ format and return lists of atoms and coordinates.\"\"\"", "\"File says %d atoms but read %d points.\""]}, "window_span": [115, 134], "err_obj": {"msg": "unbalanced (){}[]"}}], ["1a6d56e65904a65712d699cc83d99a30", {"code_string": "def read_file(self, tmp_file):\n    self.getLogger().debug(\"Inside to read_file()\")\n    ts = time.time()\n    self._logger.debug(ts)\n    with open(tmp_file, 'r') as stateFile:\n        fileJsonState = json.load(stateFile)\n        if fileJsonState is not None:\n        self.jsonState = fileJsonState\n    stateFile.close()\n    self.createWindowExercises()\n", "code_toks_joined": "def read_file ( self , tmp_file ) : <NEWLINE> <INDENT> self . getLogger ( ) . debug ( <STRING> ) <NEWLINE> ts = time . time ( ) <NEWLINE> self . _logger . debug ( ts ) <NEWLINE> with open ( tmp_file , <STRING> ) as stateFile : <NEWLINE> <INDENT> fileJsonState = json . load ( stateFile ) <NEWLINE> if fileJsonState is not None : <NEWLINE> self . jsonState = fileJsonState <NEWLINE> <DEDENT> stateFile . close ( ) <NEWLINE> self . createWindowExercises ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Inside to read_file()\"", "'r'"]}, "err_obj": {"msg": "expected an indented block"}}], ["2a4110588d2b88fc592c3fad11109cd6", {"code_string": "class UserNotice(types.Sequence):\n    components = (\n        types.Component(NOTICE_REF, NoticeReference, optional = True),\n        types.Component(EXPLICIT_TEXT, DisplayText, optional = True)\n", "code_toks_joined": "class UserNotice ( types . Sequence ) : <NEWLINE> <INDENT> components = ( <NEWLINE> <INDENT> types . Component ( NOTICE_REF , NoticeReference , optional = True ) , <NEWLINE> types . Component ( EXPLICIT_TEXT , DisplayText , optional = True ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["687160977e62992273505469e6f9a4e8", {"code_string": "class DBVistrail(_DBVistrail):\n    def __init__(self, * args, ** kwargs):\n    _DBVistrail.__init__(self, * args, ** kwargs)\n        self.idScope = IdScope()\n        self.idScope.setBeginId('action', 1)\n", "code_toks_joined": "class DBVistrail ( _DBVistrail ) : <NEWLINE> <INDENT> def __init__ ( self , * args , ** kwargs ) : <NEWLINE> _DBVistrail . __init__ ( self , * args , ** kwargs ) <NEWLINE> <INDENT> self . idScope = IdScope ( ) <NEWLINE> self . idScope . setBeginId ( <STRING> , 1 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'action'"]}, "err_obj": {"msg": "expected an indented block"}}], ["3496bdf91e39556fd75dce4f9281c1e2", {"code_string": "def _wait(timeout, cloud, server, action):\n    \"\"\"Wait for the server to reach the desired state for the given action.\"\"\"\n    for count in shade._utils._iterate_timeout(\n        timeout,\n        \"Timeout waiting for server to complete %s\" % action):\n        try:\n        server = cloud.get_server(server.id)\n        except Exception:\n        continue\n        if server.status == _action_map[action]:\n        return\n        if server.status == 'ERROR':\n        module.fail_json(msg = \"Server reached ERROR state while attempting to %s\" % action)\n", "code_toks_joined": "def _wait ( timeout , cloud , server , action ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for count in shade . _utils . _iterate_timeout ( <NEWLINE> <INDENT> timeout , <NEWLINE> <STRING> % action ) : <NEWLINE> try : <NEWLINE> server = cloud . get_server ( server . id ) <NEWLINE> except Exception : <NEWLINE> continue <NEWLINE> if server . status == _action_map [ action ] : <NEWLINE> return <NEWLINE> if server . status == <STRING> : <NEWLINE> module . fail_json ( msg = <STRING> % action ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Wait for the server to reach the desired state for the given action.\"\"\"", "\"Timeout waiting for server to complete %s\"", "'ERROR'", "\"Server reached ERROR state while attempting to %s\""]}, "err_obj": {"msg": "expected an indented block"}}], ["368066bc842680c0d83ac5fabb60eab5", {"code_string": "class Comment(models.Model):\n    comment_title = models.ForeignKey('Blog')\n    comment_body = models.TextField()\n    comment_author = models.CharField(max_length = 60)\n    comment_created = models.DateField()\n    comment_updated = models.DateField()\n    def body_first_sixty(self):\n        return self.title[: 60]\n            def __unicode__(self):\n        return self.comment_author\n", "code_toks_joined": "class Comment ( models . Model ) : <NEWLINE> <INDENT> comment_title = models . ForeignKey ( <STRING> ) <NEWLINE> comment_body = models . TextField ( ) <NEWLINE> comment_author = models . CharField ( max_length = 60 ) <NEWLINE> comment_created = models . DateField ( ) <NEWLINE> comment_updated = models . DateField ( ) <NEWLINE> def body_first_sixty ( self ) : <NEWLINE> <INDENT> return self . title [ : 60 ] <NEWLINE> <INDENT> def __unicode__ ( self ) : <NEWLINE> <DEDENT> return self . comment_author <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Blog'"]}, "err_obj": {"msg": "unexpected indent"}}], ["a43ae92935227359f9c0caee237f6df6", {"code_string": "class _ListSetter:\n    def __init__(self, L):\n        self.L = L\n    def setitem(self, (item, value)):\n        diff = item - len(self.L) + 1\n        if diff > 0:\n            self.L.extend([None] * diff)\n        self.L[item] = value\n", "code_toks_joined": "class _ListSetter : <NEWLINE> <INDENT> def __init__ ( self , L ) : <NEWLINE> <INDENT> self . L = L <NEWLINE> <DEDENT> def setitem ( self , ( item , value ) ) : <NEWLINE> <INDENT> diff = item - len ( self . L ) + 1 <NEWLINE> if diff > 0 : <NEWLINE> <INDENT> self . L . extend ( [ None ] * diff ) <NEWLINE> <DEDENT> self . L [ item ] = value <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["5d6b0004abda0173f12ce2dab1d43e87", {"code_string": "def load_processing_settings(settings):\n    \"\"\"Load processing specific settings.\"\"\"\n    processing_settings_path = settings['processing_settings_path']\n    with open(processing_settings_path, 'r') as f:\n        settings.update(yaml.load(f.read())))\n", "code_toks_joined": "def load_processing_settings ( settings ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> processing_settings_path = settings [ <STRING> ] <NEWLINE> with open ( processing_settings_path , <STRING> ) as f : <NEWLINE> <INDENT> settings . update ( yaml . load ( f . read ( ) ) ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Load processing specific settings.\"\"\"", "'processing_settings_path'", "'r'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e1c2a102fab90556551112bc430e415d", {"code_string": "def raise_object(self, name):\n    \"\"\"Raise the named object to the top of the stacking order.\"\"\"\n        try: avatar = self.avatars[name]\n        except: self.debug('No avatar called %s' % name)\n        else:\n            self.sprites.above(avatar)\n            self.redraw(avatar.rect)\n", "code_toks_joined": "def raise_object ( self , name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> try : avatar = self . avatars [ name ] <NEWLINE> except : self . debug ( <STRING> % name ) <NEWLINE> else : <NEWLINE> <INDENT> self . sprites . above ( avatar ) <NEWLINE> self . redraw ( avatar . rect ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Raise the named object to the top of the stacking order.\"\"\"", "'No avatar called %s'"]}, "err_obj": {"msg": "unexpected indent"}}], ["877e82e8b276296a6904bac6a20f980e", {"code_string": "from django.views import generic\nfrom viewflow import views as flow_views\nclass CreateRequestView(flow_views.StartViewMixin,\n    generic.UpdateView):\n    fields = [\"text\"]\n    def get_object(self):\n    return self.activation.process\nclass ApproveRequestView(flow_views.TaskViewMixin,\n    generic.UpdateView):\n    fields = [\"approved\"]\n    def get_object(self):\n    return self.activation.process\n", "code_toks_joined": "from django . views import generic <NEWLINE> from viewflow import views as flow_views <NEWLINE> class CreateRequestView ( flow_views . StartViewMixin , <NEWLINE> <INDENT> generic . UpdateView ) : <NEWLINE> fields = [ <STRING> ] <NEWLINE> def get_object ( self ) : <NEWLINE> return self . activation . process <NEWLINE> <DEDENT> class ApproveRequestView ( flow_views . TaskViewMixin , <NEWLINE> <INDENT> generic . UpdateView ) : <NEWLINE> fields = [ <STRING> ] <NEWLINE> def get_object ( self ) : <NEWLINE> return self . activation . process <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"text\"", "\"approved\""]}, "err_obj": {"msg": "expected an indented block"}}], ["75c2161edaf5f7bc51103de33f77af12", {"code_string": "def test_monitor_ac_usage_leave_on(fake_events, arduino):\n    old_event = fake_events.timestamp\n    monitor_ac_usage()\n    new_event = Event.last_event()\n    old_event = Event.query.filter(Event.timestamp == old_event).first()\n    assert naturally_equivalent(old_event new_event)\n    assert new_event.event == EventType.on\n    assert new_event.event_description is None\n", "code_toks_joined": "def test_monitor_ac_usage_leave_on ( fake_events , arduino ) : <NEWLINE> <INDENT> old_event = fake_events . timestamp <NEWLINE> monitor_ac_usage ( ) <NEWLINE> new_event = Event . last_event ( ) <NEWLINE> old_event = Event . query . filter ( Event . timestamp == old_event ) . first ( ) <NEWLINE> assert naturally_equivalent ( old_event new_event ) <NEWLINE> assert new_event . event == EventType . on <NEWLINE> assert new_event . event_description is None <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["bec696ac046e67702a4f532ee1a39f87", {"code_string": "def prevent_l3_port_deletion(self, context, port_id):\n    \"\"\"Checks to make sure a port is allowed to be deleted.\"\"\"\n    port_db = self._core_plugin._get_port(context, port_id)\n    if port_db['device_owner'] in[DEVICE_OWNER_ROUTER_INTF,\n        DEVICE_OWNER_ROUTER_GW,\n        DEVICE_OWNER_FLOATINGIP]:\n        fixed_ips = port_db['fixed_ips']\n        if fixed_ips:\n        raise l3.L3PortInUse(port_id = port_id,\n        device_owner = port_db['device_owner'])\n        else:\n        LOG.debug(_(\"Port %(port_id)s has owner %(port_owner)s, but \"\n        \"no IP address, so it can be deleted\"),\n        {'port_id': port_db['id'],\n        'port_owner': port_db['device_owner']})\n", "code_toks_joined": "def prevent_l3_port_deletion ( self , context , port_id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> port_db = self . _core_plugin . _get_port ( context , port_id ) <NEWLINE> if port_db [ <STRING> ] in [ DEVICE_OWNER_ROUTER_INTF , <NEWLINE> <INDENT> DEVICE_OWNER_ROUTER_GW , <NEWLINE> DEVICE_OWNER_FLOATINGIP ] : <NEWLINE> fixed_ips = port_db [ <STRING> ] <NEWLINE> if fixed_ips : <NEWLINE> raise l3 . L3PortInUse ( port_id = port_id , <NEWLINE> device_owner = port_db [ <STRING> ] ) <NEWLINE> else : <NEWLINE> LOG . debug ( _ ( <STRING> <NEWLINE> <STRING> ) , <NEWLINE> { <STRING> : port_db [ <STRING> ] , <NEWLINE> <STRING> : port_db [ <STRING> ] } ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Checks to make sure a port is allowed to be deleted.\"\"\"", "'device_owner'", "'fixed_ips'", "'device_owner'", "\"Port %(port_id)s has owner %(port_owner)s, but \"", "\"no IP address, so it can be deleted\"", "'port_id'", "'id'", "'port_owner'", "'device_owner'"]}, "err_obj": {"msg": "expected an indented block"}}], ["36611a81cf5036df4bf84ae1067d343e", {"code_string": "def _BecomePager(pager):\n    a, b, c = select.select([0], [], [0])\n    os.environ['LESS'] = 'FRSX'\n    try:\n        os.execvp(pager, [pager])\n    except OSError, e:\n        os.execv('/bin/sh', ['sh', '-c', pager])\n", "code_toks_joined": "def _BecomePager ( pager ) : <NEWLINE> <INDENT> a , b , c = select . select ( [ 0 ] , [ ] , [ 0 ] ) <NEWLINE> os . environ [ <STRING> ] = <STRING> <NEWLINE> try : <NEWLINE> <INDENT> os . execvp ( pager , [ pager ] ) <NEWLINE> <DEDENT> except OSError , e : <NEWLINE> <INDENT> os . execv ( <STRING> , [ <STRING> , <STRING> , pager ] ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'LESS'", "'FRSX'", "'/bin/sh'", "'sh'", "'-c'"]}, "err_obj": {"msg": "invalid syntax"}}], ["3a424adb7010371c7f7d75dc4a77d06a", {"code_string": "def test_get_with_unpopulated_report(self):\n    report = models.SectorsReport.objects.create(soc_codes = '3114,5330')\n    with patch('sectors.models.SectorsReport.is_populated',\n        new_callable = PropertyMock) as mock_is_populated:\n        mock_is_populated.return_value = False\n        response = self.client.get(\n        reverse(\n            'sectors:report',\n            kwargs = {\n                'report_id': report.pk\n            }\n            )\n            )\n            self.assertEqual(response.status_code, 202)\n            self.assertTemplateUsed(response, \"sectors/report_pending.html\")\n", "code_toks_joined": "def test_get_with_unpopulated_report ( self ) : <NEWLINE> <INDENT> report = models . SectorsReport . objects . create ( soc_codes = <STRING> ) <NEWLINE> with patch ( <STRING> , <NEWLINE> <INDENT> new_callable = PropertyMock ) as mock_is_populated : <NEWLINE> mock_is_populated . return_value = False <NEWLINE> response = self . client . get ( <NEWLINE> reverse ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> kwargs = { <NEWLINE> <INDENT> <STRING> : report . pk <NEWLINE> <DEDENT> } <NEWLINE> ) <NEWLINE> ) <NEWLINE> self . assertEqual ( response . status_code , 202 ) <NEWLINE> self . assertTemplateUsed ( response , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'3114,5330'", "'sectors.models.SectorsReport.is_populated'", "'sectors:report'", "'report_id'", "\"sectors/report_pending.html\""]}, "err_obj": {"msg": "unexpected indent"}}], ["3dc84a14b41fdfb5e5d88223dadd0b54", {"code_string": "def usage():\n    print((\"usage: {0}<maps-entry-line>\").format(sys.argv[0]))\n    print((\"  maps-entry-line: comes from a /proc/pid/maps file\")\n    sys.exit(1)\n", "code_toks_joined": "def usage ( ) : <NEWLINE> <INDENT> print ( ( <STRING> ) . format ( sys . argv [ 0 ] ) ) <NEWLINE> print ( ( <STRING> ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"usage: {0}<maps-entry-line>\"", "\"  maps-entry-line: comes from a /proc/pid/maps file\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["ccc7326698c419da0d36d61332f00f50", {"code_string": "def get_bitstring(integer, length):\n    bitString = bin(integer)\n    resultString = \"\"\n    if length < 1:\n        return None\n    bitStringLength = len(bitString)\n    if bitStringLength > length:\n        position = 1\n        while position <= length:\n            resultString = bitString[(bitStringLength - position): ((bitStringLength - position) + 1)] + resultString\n            position += 1\n    else:\n        resultString = bitString\n        while(len(resultString) < length):\n        resultString = \"0\" + resultString\n    return resultString\n", "code_toks_joined": "def get_bitstring ( integer , length ) : <NEWLINE> <INDENT> bitString = bin ( integer ) <NEWLINE> resultString = <STRING> <NEWLINE> if length < 1 : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> bitStringLength = len ( bitString ) <NEWLINE> if bitStringLength > length : <NEWLINE> <INDENT> position = 1 <NEWLINE> while position <= length : <NEWLINE> <INDENT> resultString = bitString [ ( bitStringLength - position ) : ( ( bitStringLength - position ) + 1 ) ] + resultString <NEWLINE> position += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> resultString = bitString <NEWLINE> while ( len ( resultString ) < length ) : <NEWLINE> resultString = <STRING> + resultString <NEWLINE> <DEDENT> return resultString <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"", "\"0\""]}, "err_obj": {"msg": "expected an indented block"}}], ["c7d7573566135a15a02684127923e08c", {"code_string": "def test_story_with_pre_tags(self):\n    text = '<pre>A\\n</pre>' '<pre>B\\n</pre>' '<pre>C\\n</pre>' '<pre>D\\n</pre>' item = {'body_html': text}\n    res, diff = preserve(item)\n    self.assertEqual(item['body_html'], '<pre>A\\nB\\nC\\nD\\n</pre>')\n", "code_toks_joined": "def test_story_with_pre_tags ( self ) : <NEWLINE> <INDENT> text = <STRING> <STRING> <STRING> <STRING> item = { <STRING> : text } <NEWLINE> res , diff = preserve ( item ) <NEWLINE> self . assertEqual ( item [ <STRING> ] , <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'<pre>A\\n</pre>'", "'<pre>B\\n</pre>'", "'<pre>C\\n</pre>'", "'<pre>D\\n</pre>'", "'body_html'", "'body_html'", "'<pre>A\\nB\\nC\\nD\\n</pre>'"]}, "err_obj": {"msg": "invalid syntax"}}], ["3c4d77416e267376b4e2a6e59e820333", {"code_string": "def PrintFailureHeader(self, test):\n    if test.IsNegative():\n        negative_marker = '[negative] '\n    else:\n        negative_marker = ''\n    print(\"=== %(label)s %(negative)s===\" %{\n        'label': test.GetLabel(),\n        'negative': negative_marker\n    }\n    print(\"Path: %s\" % \"/\".join(test.path))\n", "code_toks_joined": "def PrintFailureHeader ( self , test ) : <NEWLINE> <INDENT> if test . IsNegative ( ) : <NEWLINE> <INDENT> negative_marker = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> negative_marker = <STRING> <NEWLINE> <DEDENT> print ( <STRING> % { <NEWLINE> <INDENT> <STRING> : test . GetLabel ( ) , <NEWLINE> <STRING> : negative_marker <NEWLINE> <DEDENT> } <NEWLINE> print ( <STRING> % <STRING> . join ( test . path ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'[negative] '", "''", "\"=== %(label)s %(negative)s===\"", "'label'", "'negative'", "\"Path: %s\"", "\"/\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["0c1c26e8b5a180ecb42e6097a016a56c", {"code_string": "def is_django_dir(path):\n    path = validations.is_local_dir_exists(path)\n    manage = os.path.join(path, \"manage.py\")\n    try:\n        validations.is_local_file_exists(manage)\n    except:\n        raise ValueError, _(\"Directory doesn't look like a Django based project.\")\n    return path\n", "code_toks_joined": "def is_django_dir ( path ) : <NEWLINE> <INDENT> path = validations . is_local_dir_exists ( path ) <NEWLINE> manage = os . path . join ( path , <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> validations . is_local_file_exists ( manage ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> raise ValueError , _ ( <STRING> ) <NEWLINE> <DEDENT> return path <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"manage.py\"", "\"Directory doesn't look like a Django based project.\""]}, "err_obj": {"msg": "invalid syntax"}}], ["954cb00c77bcc5890ac0b0258aab4e3c", {"code_string": "def _putline(self, line):\n    if self._debugging > 1:\n        print '*put*', repr(line)\n    self.sock.sendall('%s%s' %(line, CRLF))\n", "code_toks_joined": "def _putline ( self , line ) : <NEWLINE> <INDENT> if self . _debugging > 1 : <NEWLINE> <INDENT> print <STRING> , repr ( line ) <NEWLINE> <DEDENT> self . sock . sendall ( <STRING> % ( line , CRLF ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'*put*'", "'%s%s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["3aea742324652b92ae284e4e4dfad829", {"code_string": "def setup_module(module):\n    for variable in('LANG', 'LANGUAGE',\n        'LC_ALL', 'LC_MESSAGES', 'LC_COLLATE'):\n        if variable in os.environ:\n        del os.environ[variable]\n    run.external = outer is None\n    import tempfile\n    run.work = tempfile.mktemp()\n", "code_toks_joined": "def setup_module ( module ) : <NEWLINE> <INDENT> for variable in ( <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> ) : <NEWLINE> if variable in os . environ : <NEWLINE> del os . environ [ variable ] <NEWLINE> <DEDENT> run . external = outer is None <NEWLINE> import tempfile <NEWLINE> run . work = tempfile . mktemp ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'LANG'", "'LANGUAGE'", "'LC_ALL'", "'LC_MESSAGES'", "'LC_COLLATE'"]}, "err_obj": {"msg": "expected an indented block"}}], ["bee2361c041cde19449a1136e2e667ed", {"code_string": "from settings import *\nDEBUG = False\nTEMPLATE_DEBUG = DEBUG\nTHUMBNAIL_DEBUG = DEBUG\n} BASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.postgresql_psycopg2',\n        'NAME': 'repylia',\n        'USER': 'repylia',\n        'PASSWORD': 'tyranosaure',\n        'HOST': 'localhost',\n    }\n}\nEMAIL_HOST = 'localhost'\nEMAIL_PORT = 25\n", "code_toks_joined": "from settings import * <NEWLINE> DEBUG = False <NEWLINE> TEMPLATE_DEBUG = DEBUG <NEWLINE> THUMBNAIL_DEBUG = DEBUG <NEWLINE> } BASES = { <NEWLINE> <INDENT> <STRING> : { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> EMAIL_HOST = <STRING> <NEWLINE> EMAIL_PORT = 25 <NEWLINE>", "anonymize_dict": {"<STRING>": ["'default'", "'ENGINE'", "'django.db.backends.postgresql_psycopg2'", "'NAME'", "'repylia'", "'USER'", "'repylia'", "'PASSWORD'", "'tyranosaure'", "'HOST'", "'localhost'", "'localhost'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["68d6ca1d30c5778da17309b3e7dc87e7", {"code_string": "def get_logo(size):\n    \"\"\"Returns a deluge logo pixbuf based on the size parameter.\"\"\"\n    if deluge.common.windows_check() or deluge.common.osx_check():\n        return gtk.gdk.pixbuf_new_from_file_at_size(deluge.common.get_pixmap(\"deluge.png\"), size, size)\n    else:\n        try:\n            return gtk.gdk.pixbuf_new_from_file_at_size(deluge.common.get_pixmap(\"deluge.svg\"), size, size)\n        except Exception, e:\n            log.warning(e)\n", "code_toks_joined": "def get_logo ( size ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if deluge . common . windows_check ( ) or deluge . common . osx_check ( ) : <NEWLINE> <INDENT> return gtk . gdk . pixbuf_new_from_file_at_size ( deluge . common . get_pixmap ( <STRING> ) , size , size ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return gtk . gdk . pixbuf_new_from_file_at_size ( deluge . common . get_pixmap ( <STRING> ) , size , size ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> log . warning ( e ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns a deluge logo pixbuf based on the size parameter.\"\"\"", "\"deluge.png\"", "\"deluge.svg\""]}, "err_obj": {"msg": "invalid syntax"}}], ["e087ab520b754b6b984885ea5973147a", {"code_string": "def TestRapiInstanceFailover(instance):\n    \"\"\"Test failing over instance via RAPI\"\"\"\n    if not IsFailoverSupported(instance):\n        print(qa_utils.FormatInfo(\"Instance doesn't support failover, skipping\")\n            \" test\")\n        return\n    _WaitForRapiJob(_rapi_client.FailoverInstance(instance.name))\n    qa_utils.RunInstanceCheck(instance, True)\n    _WaitForRapiJob(_rapi_client.FailoverInstance(instance.name))\n", "code_toks_joined": "def TestRapiInstanceFailover ( instance ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not IsFailoverSupported ( instance ) : <NEWLINE> <INDENT> print ( qa_utils . FormatInfo ( <STRING> ) <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> _WaitForRapiJob ( _rapi_client . FailoverInstance ( instance . name ) ) <NEWLINE> qa_utils . RunInstanceCheck ( instance , True ) <NEWLINE> _WaitForRapiJob ( _rapi_client . FailoverInstance ( instance . name ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Test failing over instance via RAPI\"\"\"", "\"Instance doesn't support failover, skipping\"", "\" test\""]}, "err_obj": {"msg": "invalid syntax"}}], ["1caeb6e93b6823b74a8db4fede73fd5d", {"code_string": "class UpdateReplace(Exception):\n    '''Raised when resource update requires replacement'''\n    _message = _(\"The Resource %s requires replacement.\")\n    def __init__(self, resource_name = 'Unknown',\n        message = _(\"The Resource %s requires replacement.\")):\n        try:\n        msg = message % resource_name\n        except TypeError:\n        msg = message\n        super(Exception, self).__init__(msg)\n", "code_toks_joined": "class UpdateReplace ( Exception ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> _message = _ ( <STRING> ) <NEWLINE> def __init__ ( self , resource_name = <STRING> , <NEWLINE> <INDENT> message = _ ( <STRING> ) ) : <NEWLINE> try : <NEWLINE> msg = message % resource_name <NEWLINE> except TypeError : <NEWLINE> msg = message <NEWLINE> super ( Exception , self ) . __init__ ( msg ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Raised when resource update requires replacement'''", "\"The Resource %s requires replacement.\"", "'Unknown'", "\"The Resource %s requires replacement.\""]}, "err_obj": {"msg": "expected an indented block"}}], ["bfb32ef7ee5a376c120f4f5c25992bfe", {"code_string": "def await_completion(self):\n    update = self.visible_updates.take()\n    try:\n        if update.exception:\n            t, v, tb = update.exc_info\n            raise t, v, tb\n    finally:\n        self.executor_service.shutdown()\n", "code_toks_joined": "def await_completion ( self ) : <NEWLINE> <INDENT> update = self . visible_updates . take ( ) <NEWLINE> try : <NEWLINE> <INDENT> if update . exception : <NEWLINE> <INDENT> t , v , tb = update . exc_info <NEWLINE> raise t , v , tb <NEWLINE> <DEDENT> <DEDENT> finally : <NEWLINE> <INDENT> self . executor_service . shutdown ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["a10d2ac1a0a9bd37f063d185c3b2c54c", {"code_string": "def test_upload__others_invalid(self, _):\n    self.reddit.read_only = False\n    with self.recorder.use_cassette(\n        'TestSubredditStylesheet.test_upload__others_invalid'):\n        for method in['upload_header', 'upload_mobile_header',\n            'upload_mobile_icon']:\n        with pytest.raises(APIException) as excinfo:\n            getattr(self.subreddit.stylesheet, method)(\n                self.image_path('invalid.jpg'))\n        assert excinfo.value.error_type == 'IMAGE_ERROR'\n", "code_toks_joined": "def test_upload__others_invalid ( self , _ ) : <NEWLINE> <INDENT> self . reddit . read_only = False <NEWLINE> with self . recorder . use_cassette ( <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> for method in [ <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ] : <NEWLINE> <DEDENT> with pytest . raises ( APIException ) as excinfo : <NEWLINE> <INDENT> getattr ( self . subreddit . stylesheet , method ) ( <NEWLINE> <INDENT> self . image_path ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> assert excinfo . value . error_type == <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'TestSubredditStylesheet.test_upload__others_invalid'", "'upload_header'", "'upload_mobile_header'", "'upload_mobile_icon'", "'invalid.jpg'", "'IMAGE_ERROR'"]}, "err_obj": {"msg": "expected an indented block"}}], ["77f037106c6b8bbf30cf18d6971d404b", {"code_string": "class Limiter(object):\n    limit = timedelta(seconds = 1)\n    last = datetime.now()\n    def wait(self):\n        \"\"\"Blocks until self.limit has passed since last call.\"\"\"\n        now = datetime.now()\n        dt = now - self.last\n        if dt < self.limit:\n            sleep_time = (self.limit - dt).seconds\n                + float(0.000001) *(self.limit - dt).microseconds\n            sleep(sleep_time)\n        self.last = datetime.now()\n        return dt\n", "code_toks_joined": "class Limiter ( object ) : <NEWLINE> <INDENT> limit = timedelta ( seconds = 1 ) <NEWLINE> last = datetime . now ( ) <NEWLINE> def wait ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> now = datetime . now ( ) <NEWLINE> dt = now - self . last <NEWLINE> if dt < self . limit : <NEWLINE> <INDENT> sleep_time = ( self . limit - dt ) . seconds <NEWLINE> <INDENT> + float ( 0.000001 ) * ( self . limit - dt ) . microseconds <NEWLINE> <DEDENT> sleep ( sleep_time ) <NEWLINE> <DEDENT> self . last = datetime . now ( ) <NEWLINE> return dt <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Blocks until self.limit has passed since last call.\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["a4165b9bbb26f7076c49cc7655169b18", {"code_string": "class FipRulePriorityAllocator(ItemAllocator):\n    \"\"\"Manages allocation of floating ips rule priorities.\"\"\"\n    def __init__(self, data_store_path, priority_rule_start,\n        priority_rule_end):\n        \"\"\"Create the necessary pool and create the item allocator\"\"\"\n        pool = set(FipPriority(str(s)) for s in range(priority_rule_start,\n            priority_rule_end))\n            super(FipRulePriorityAllocator, self).__init__(data_store_path,\n                FipPriority,\n                pool)\n", "code_toks_joined": "class FipRulePriorityAllocator ( ItemAllocator ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , data_store_path , priority_rule_start , <NEWLINE> <INDENT> priority_rule_end ) : <NEWLINE> <STRING> <NEWLINE> pool = set ( FipPriority ( str ( s ) ) for s in range ( priority_rule_start , <NEWLINE> <INDENT> priority_rule_end ) ) <NEWLINE> super ( FipRulePriorityAllocator , self ) . __init__ ( data_store_path , <NEWLINE> <INDENT> FipPriority , <NEWLINE> pool ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Manages allocation of floating ips rule priorities.\"\"\"", "\"\"\"Create the necessary pool and create the item allocator\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["2e5ecb2dcfc2a2d69673c26ba82e2b90", {"code_string": "def sum(lst):\n    tmp = 0\n    for i in range(len(lst):\n        tmp = tmp + lst[i]\n    return tmp\n", "code_toks_joined": "def sum ( lst ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for i in range ( len ( lst ) : <NEWLINE> <INDENT> tmp = tmp + lst [ i ] <NEWLINE> <DEDENT> return tmp <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["21106669872505ce334e2dbcadb54b33", {"code_string": "def _find_existing_gist_by_name(self, gist_args, nb_filename, py_filename):\n    match_counter = 0\n    matchID = None\n    for gist in gist_args:\n        gist_files = gist.get(\"files\", None)\n        if(gist_files is not None and nb_filename in gist_files and\n            py_filename in gist_files):\n            match_counter += 1\n            if \"id\" in gist:\n            matchID = gist[\"id\"]\n    if match_counter > 1:\n        raise_error(\"You had multiple gists with the same name as this \"\n            \"notebook. Aborting.\")\n    return matchID\n", "code_toks_joined": "def _find_existing_gist_by_name ( self , gist_args , nb_filename , py_filename ) : <NEWLINE> <INDENT> match_counter = 0 <NEWLINE> matchID = None <NEWLINE> for gist in gist_args : <NEWLINE> <INDENT> gist_files = gist . get ( <STRING> , None ) <NEWLINE> if ( gist_files is not None and nb_filename in gist_files and <NEWLINE> <INDENT> py_filename in gist_files ) : <NEWLINE> match_counter += 1 <NEWLINE> if <STRING> in gist : <NEWLINE> matchID = gist [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT> if match_counter > 1 : <NEWLINE> <INDENT> raise_error ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return matchID <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"files\"", "\"id\"", "\"id\"", "\"You had multiple gists with the same name as this \"", "\"notebook. Aborting.\""]}, "err_obj": {"msg": "expected an indented block"}}], ["3a66e6fadee2730c8c59f2ec85afa981", {"code_string": "def check_adoptions():\n    log.debug(\"Checking proposals for successful adoption...\")\n    for proposal in Proposal.all():\n        if(not proposal.adopted and proposal.is_adopt_polling()\n            and proposal.adopt_poll.is_stable()):\n            log.info(\"Proposal %s is now ADOPTED. Thanks for playing.\" %\n                proposal.title)\n                proposal.adopt()\n                meta.Session.commit()\n", "code_toks_joined": "def check_adoptions ( ) : <NEWLINE> <INDENT> log . debug ( <STRING> ) <NEWLINE> for proposal in Proposal . all ( ) : <NEWLINE> <INDENT> if ( not proposal . adopted and proposal . is_adopt_polling ( ) <NEWLINE> <INDENT> and proposal . adopt_poll . is_stable ( ) ) : <NEWLINE> log . info ( <STRING> % <NEWLINE> <INDENT> proposal . title ) <NEWLINE> proposal . adopt ( ) <NEWLINE> meta . Session . commit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Checking proposals for successful adoption...\"", "\"Proposal %s is now ADOPTED. Thanks for playing.\""]}, "err_obj": {"msg": "unexpected indent"}}], ["9e6fc34ffb6d1304cfa55cd749e7045b", {"code_string": "def mmPrettyPrintSequenceCellRepresentations(self, sortby = \"Column\"):\n    \"\"\"Pretty print the cell representations for sequences in the history.\"\"\"\n    self._mmComputeTransitionTraces()\n    table = PrettyTable([\"Pattern\", \"Column\", \"predicted=>active cells\"])\n    for sequenceLabel, predictedActiveCells in(\n        self._mmData[\"predictedActiveCellsForSequence\"].iteritems()):\n        cellsForColumn = self.mapCellsToColumns(predictedActiveCells)\n        for column, cells in cellsForColumn.iteritems():\n        table.add_row([sequenceLabel, column, list(cells)])\n    return table.get_string(sortby = sortby).encode(\"utf-8\")\n", "code_toks_joined": "def mmPrettyPrintSequenceCellRepresentations ( self , sortby = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . _mmComputeTransitionTraces ( ) <NEWLINE> table = PrettyTable ( [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> for sequenceLabel , predictedActiveCells in ( <NEWLINE> <INDENT> self . _mmData [ <STRING> ] . iteritems ( ) ) : <NEWLINE> cellsForColumn = self . mapCellsToColumns ( predictedActiveCells ) <NEWLINE> for column , cells in cellsForColumn . iteritems ( ) : <NEWLINE> table . add_row ( [ sequenceLabel , column , list ( cells ) ] ) <NEWLINE> <DEDENT> return table . get_string ( sortby = sortby ) . encode ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Column\"", "\"\"\"Pretty print the cell representations for sequences in the history.\"\"\"", "\"Pattern\"", "\"Column\"", "\"predicted=>active cells\"", "\"predictedActiveCellsForSequence\"", "\"utf-8\""]}, "err_obj": {"msg": "expected an indented block"}}], ["5220123175d43c090e0d3aba1ce755eb", {"code_string": "def test_check_equal(self):\n    task_api = self.compute_api.compute_task_api\n    tests = set()\n    for(name, value) in inspect.getmembers(self inspect.ismethod):\n        if name.startswith('test_') and name != 'test_check_equal':\n            tests.add(name[5: ])\n    if tests != set(task_api.cells_compatible):\n        self.fail(\"Testcases not equivalent to cells_compatible list\")\n", "code_toks_joined": "def test_check_equal ( self ) : <NEWLINE> <INDENT> task_api = self . compute_api . compute_task_api <NEWLINE> tests = set ( ) <NEWLINE> for ( name , value ) in inspect . getmembers ( self inspect . ismethod ) : <NEWLINE> <INDENT> if name . startswith ( <STRING> ) and name != <STRING> : <NEWLINE> <INDENT> tests . add ( name [ 5 : ] ) <NEWLINE> <DEDENT> <DEDENT> if tests != set ( task_api . cells_compatible ) : <NEWLINE> <INDENT> self . fail ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'test_'", "'test_check_equal'", "\"Testcases not equivalent to cells_compatible list\""]}, "err_obj": {"msg": "invalid syntax"}}], ["04e9125c1d212ce56b1fd7c5cc3eacbc", {"code_string": "def __init__(self, local_endpoint, autobind = True, timeout = 0.5, bind_single = False, debug = 0):\n    super(PacketSocket, self).__init__(socket.AF_INET, socket.SOCK_DGRAM)\n    self.debug = debug\n    self.local_endpoint = local_endpoint\n    self.recvfrom_timeout = timeout\n    self.settimeout(self.recvfrom_timeout)\n    self.bbind_single = bind_single\n    self.autobind = autobind\n    if self.debug > 0:\n        print \"Set socket timeout to %s\" %(self.recvfrom_timeout)\n    if self.autobind:\n        self.packet_bind()\n", "code_toks_joined": "def __init__ ( self , local_endpoint , autobind = True , timeout = 0.5 , bind_single = False , debug = 0 ) : <NEWLINE> <INDENT> super ( PacketSocket , self ) . __init__ ( socket . AF_INET , socket . SOCK_DGRAM ) <NEWLINE> self . debug = debug <NEWLINE> self . local_endpoint = local_endpoint <NEWLINE> self . recvfrom_timeout = timeout <NEWLINE> self . settimeout ( self . recvfrom_timeout ) <NEWLINE> self . bbind_single = bind_single <NEWLINE> self . autobind = autobind <NEWLINE> if self . debug > 0 : <NEWLINE> <INDENT> print <STRING> % ( self . recvfrom_timeout ) <NEWLINE> <DEDENT> if self . autobind : <NEWLINE> <INDENT> self . packet_bind ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Set socket timeout to %s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["e8e3c03ffa79722ffb4afd5ac2bd88b0", {"code_string": "def parse_result(step, result):\n    parsed = '%s:' % step\n    keyless = parsed\n    for key in['AuthCode', 'RespCode', 'AVSRespCode', 'CVV2RespCode',\n        'TxRefNum', 'ApprovalStatus', 'TraceNumber',\n        'CustomerRefNum']:\n        if key in result:\n        parsed = '%s %s:%s' %(parsed, key, result[key])\n    if parsed == keyless:\n        parsed = '%s raw:%s' %(parsed, result)\n    return parsed\n", "code_toks_joined": "def parse_result ( step , result ) : <NEWLINE> <INDENT> parsed = <STRING> % step <NEWLINE> keyless = parsed <NEWLINE> for key in [ <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> ] : <NEWLINE> if key in result : <NEWLINE> parsed = <STRING> % ( parsed , key , result [ key ] ) <NEWLINE> <DEDENT> if parsed == keyless : <NEWLINE> <INDENT> parsed = <STRING> % ( parsed , result ) <NEWLINE> <DEDENT> return parsed <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'%s:'", "'AuthCode'", "'RespCode'", "'AVSRespCode'", "'CVV2RespCode'", "'TxRefNum'", "'ApprovalStatus'", "'TraceNumber'", "'CustomerRefNum'", "'%s %s:%s'", "'%s raw:%s'"]}, "err_obj": {"msg": "expected an indented block"}}], ["817b3f3c218c91a4be2daa9c3059bc04", {"code_string": "def test_get_regions_all_regions(self):\n    args = Namespace(all_regions = True)\n    supported_regions = {'ap-southeast-1', 'ap-southeast-2',\n        'us-west-2', 'us-east-1', 'us-west-1',\n        ,\n        'sa-east-1', 'ap-northeast-1', 'eu-west-1'}\n    all_regions = set(get_regions(args, None))\n    self.assertTrue(all_regions.issuperset(supported_regions))\n", "code_toks_joined": "def test_get_regions_all_regions ( self ) : <NEWLINE> <INDENT> args = Namespace ( all_regions = True ) <NEWLINE> supported_regions = { <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <NEWLINE> , <NEWLINE> <STRING> , <STRING> , <STRING> } <NEWLINE> <DEDENT> all_regions = set ( get_regions ( args , None ) ) <NEWLINE> self . assertTrue ( all_regions . issuperset ( supported_regions ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'ap-southeast-1'", "'ap-southeast-2'", "'us-west-2'", "'us-east-1'", "'us-west-1'", "'sa-east-1'", "'ap-northeast-1'", "'eu-west-1'"]}, "err_obj": {"msg": "invalid syntax"}}], ["0509548f6172d8ccc9ff583a57fa2898", {"code_string": "def get_wsdl(self url):\n    \"\"\"Simple accessor method that caches the wsdl of the application, once\"\"\"\n    if self.__wsdl is None:\n        return self.__build_wsdl(url)\n    else:\n        return self.__wsdl\n", "code_toks_joined": "def get_wsdl ( self url ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . __wsdl is None : <NEWLINE> <INDENT> return self . __build_wsdl ( url ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . __wsdl <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Simple accessor method that caches the wsdl of the application, once\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["44fd31135ad6ad77fc14d3dd16c49c09", {"code_string": "def collide(self, rect, propname):\n    '''Find all objects the rect is touching that have the indicated'''\n    r = []\n    for object in self.get_in_region(rect.left, rect.top, rect.right,\n        rect.bottom):\n        if propname in object or propname in self.properties:\n        r.append(object)\n    return r\n", "code_toks_joined": "def collide ( self , rect , propname ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> r = [ ] <NEWLINE> for object in self . get_in_region ( rect . left , rect . top , rect . right , <NEWLINE> <INDENT> rect . bottom ) : <NEWLINE> if propname in object or propname in self . properties : <NEWLINE> r . append ( object ) <NEWLINE> <DEDENT> return r <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Find all objects the rect is touching that have the indicated'''"]}, "err_obj": {"msg": "expected an indented block"}}], ["1713d0cea468ffe2d09643980890d8e9", {"code_string": "def androidManifest(topDomain, domain, appName, workingDir):\n    print('--------------------------------   G e n e r a t i n g   M a n i f e s t \\n')\n    manifestName = \"AndroidManifest.xml\"\n    outStr = '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n' '<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\\n' '    package=\"' + topDomain + '.' + domain + '.' + appName + '\">\\n' '    <application android:label=\"' + appName + '\">\\n' '        <activity android:name=\"' + appName + '\">\\n' '            <intent-filter>\\n' '                <action android:name=\"android.intent.action.MAIN\" />\\n' + '                <category android:name=\"android.intent.category.LAUNCHER\" />\\n' '            </intent-filter>\\n' '        </activity>\\n' '    </application>\\n' '</manifest>\\n' fo = open(workingDir + os.sep + manifestName, 'w')\n    fo.write(outStr)\n    fo.close()\n", "code_toks_joined": "def androidManifest ( topDomain , domain , appName , workingDir ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> manifestName = <STRING> <NEWLINE> outStr = <STRING> <STRING> <STRING> + topDomain + <STRING> + domain + <STRING> + appName + <STRING> <STRING> + appName + <STRING> <STRING> + appName + <STRING> <STRING> <STRING> + <STRING> <STRING> <STRING> <STRING> <STRING> fo = open ( workingDir + os . sep + manifestName , <STRING> ) <NEWLINE> fo . write ( outStr ) <NEWLINE> fo . close ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'--------------------------------   G e n e r a t i n g   M a n i f e s t \\n'", "\"AndroidManifest.xml\"", "'<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n'", "'<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\\n'", "'    package=\"'", "'.'", "'.'", "'\">\\n'", "'    <application android:label=\"'", "'\">\\n'", "'        <activity android:name=\"'", "'\">\\n'", "'            <intent-filter>\\n'", "'                <action android:name=\"android.intent.action.MAIN\" />\\n'", "'                <category android:name=\"android.intent.category.LAUNCHER\" />\\n'", "'            </intent-filter>\\n'", "'        </activity>\\n'", "'    </application>\\n'", "'</manifest>\\n'", "'w'"]}, "err_obj": {"msg": "invalid syntax"}}], ["44cda087b8f4d98d78d9aa6a5602a747", {"code_string": "def OnAutoscale(self, event):\n    state = self.autoscale_button.GetValue()\n        if state:\n            self.autoscale_button.SetLabel(\"   Vm plot  \")\n            self.autoscale_button.SetForegroundColour('red')\n            self.plot_type = 'Vm'\n        else:\n            self.autoscale_button.SetLabel(\"generic plot\")\n            self.autoscale_button.SetForegroundColour('blue')\n            self.plot_type = 'generic'\n        self.set_plot_type()\n", "code_toks_joined": "def OnAutoscale ( self , event ) : <NEWLINE> <INDENT> state = self . autoscale_button . GetValue ( ) <NEWLINE> <INDENT> if state : <NEWLINE> <INDENT> self . autoscale_button . SetLabel ( <STRING> ) <NEWLINE> self . autoscale_button . SetForegroundColour ( <STRING> ) <NEWLINE> self . plot_type = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . autoscale_button . SetLabel ( <STRING> ) <NEWLINE> self . autoscale_button . SetForegroundColour ( <STRING> ) <NEWLINE> self . plot_type = <STRING> <NEWLINE> <DEDENT> self . set_plot_type ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"   Vm plot  \"", "'red'", "'Vm'", "\"generic plot\"", "'blue'", "'generic'"]}, "err_obj": {"msg": "unexpected indent"}}], ["a54d2c78e2ece8b41453b566ddf7388c", {"code_string": "def TestInstanceConvertDiskToPlain(instance, inodes):\n    \"\"\"gnt-instance modify -t\"\"\"\n    name = instance.name\n    template = instance.disk_template\n    if template != constants.DT_DRBD8:\n        print(qa_utils.FormatInfo(\"Unsupported template %s, skipping conversion\")\n            \" test\" % template)\n        return\n    assert len(inodes) == 2\n    AssertCommand([\"gnt-instance\", \"modify\", \"-t\", constants.DT_PLAIN, name])\n    AssertCommand([\"gnt-instance\", \"modify\", \"-t\", constants.DT_DRBD8,\n        \"-n\", inodes[1].primary, name])\n", "code_toks_joined": "def TestInstanceConvertDiskToPlain ( instance , inodes ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> name = instance . name <NEWLINE> template = instance . disk_template <NEWLINE> if template != constants . DT_DRBD8 : <NEWLINE> <INDENT> print ( qa_utils . FormatInfo ( <STRING> ) <NEWLINE> <INDENT> <STRING> % template ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> assert len ( inodes ) == 2 <NEWLINE> AssertCommand ( [ <STRING> , <STRING> , <STRING> , constants . DT_PLAIN , name ] ) <NEWLINE> AssertCommand ( [ <STRING> , <STRING> , <STRING> , constants . DT_DRBD8 , <NEWLINE> <INDENT> <STRING> , inodes [ 1 ] . primary , name ] ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"gnt-instance modify -t\"\"\"", "\"Unsupported template %s, skipping conversion\"", "\" test\"", "\"gnt-instance\"", "\"modify\"", "\"-t\"", "\"gnt-instance\"", "\"modify\"", "\"-t\"", "\"-n\""]}, "err_obj": {"msg": "invalid syntax"}}], ["38041cb414e33c188378c8fd65afbf37", {"code_string": "def get_drive_info(drive, os_list_position):\n    osVersion = []\n    for new_releases in drive['releases']:\n        osVersion +=[new_releases]\n    osVersion_str = osVersion[os_list_position]\n    dev_type_str = drive['releases'][osVersion_str]['devicetype']\n    major_str = drive['releases'][osVersion_str]['major']\n    minor_str = drive['releases'][osVersion_str] '[minor']\n    firmware_str = drive['releases'][osVersion_str]['firmware']\n    model_str = drive['model']\n    drive_info = DiskDrive(osVersion_str, dev_type_str, major_str, minor_str, firmware_str, model_str)\n    return drive_info\n", "code_toks_joined": "def get_drive_info ( drive , os_list_position ) : <NEWLINE> <INDENT> osVersion = [ ] <NEWLINE> for new_releases in drive [ <STRING> ] : <NEWLINE> <INDENT> osVersion += [ new_releases ] <NEWLINE> <DEDENT> osVersion_str = osVersion [ os_list_position ] <NEWLINE> dev_type_str = drive [ <STRING> ] [ osVersion_str ] [ <STRING> ] <NEWLINE> major_str = drive [ <STRING> ] [ osVersion_str ] [ <STRING> ] <NEWLINE> minor_str = drive [ <STRING> ] [ osVersion_str ] <STRING> ] <NEWLINE> firmware_str = drive [ <STRING> ] [ osVersion_str ] [ <STRING> ] <NEWLINE> model_str = drive [ <STRING> ] <NEWLINE> drive_info = DiskDrive ( osVersion_str , dev_type_str , major_str , minor_str , firmware_str , model_str ) <NEWLINE> return drive_info <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'releases'", "'releases'", "'devicetype'", "'releases'", "'major'", "'releases'", "'[minor'", "'releases'", "'firmware'", "'model'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["bdf88629b7b9f91d89ee7430c73ace4e", {"code_string": "def parse(text, execsnippet):\n    result = None\n    toparse = text\n    try:\n        exec execsnippet\n        return result\n    except:\n        return None\n", "code_toks_joined": "def parse ( text , execsnippet ) : <NEWLINE> <INDENT> result = None <NEWLINE> toparse = text <NEWLINE> try : <NEWLINE> <INDENT> exec execsnippet <NEWLINE> return result <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["e41b401e14bfc7c6f8e91885b7e17edf", {"code_string": "def test_duplicate_global_local(self):\n    try:\n        exec 'def f(a): global a; a = 1'\n        self.fail(\"variable is global and local\")\n    except SyntaxError:\n        pass\n", "code_toks_joined": "def test_duplicate_global_local ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> exec <STRING> <NEWLINE> self . fail ( <STRING> ) <NEWLINE> <DEDENT> except SyntaxError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'def f(a): global a; a = 1'", "\"variable is global and local\""]}, "err_obj": {"msg": "invalid syntax"}}], ["39f2c9168bcbe4819cb2af397b70f681", {"code_string": "def routes(self, waypoints, travelMode = 'Driving', version = 'v1', * args, ** kargs):\n    for count in xrange(0, len(waypoints)):\n        kargs['wp.%d' % count] = waypoints[count]\n    return bind_api(\n    path = '/REST/{version}/Routes/{travelMode}',\n    allowed_param = ['avoid', 'distanceBeforeFirstTurn', 'heading', 'optimize',\n        'routePathOutput', 'tolerances', 'distanceUnit', 'dateTime',\n        'timeType', 'maxSolutions', 'suppressStatus', 'jsonp', 'output',\n        'jsonso', 'culture', 'mapView', 'userLocation', 'userIp'] +[\"wp.%d\" % x for x in xrange(0, 25)]\n", "code_toks_joined": "def routes ( self , waypoints , travelMode = <STRING> , version = <STRING> , * args , ** kargs ) : <NEWLINE> <INDENT> for count in xrange ( 0 , len ( waypoints ) ) : <NEWLINE> <INDENT> kargs [ <STRING> % count ] = waypoints [ count ] <NEWLINE> <DEDENT> return bind_api ( <NEWLINE> path = <STRING> , <NEWLINE> allowed_param = [ <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] + [ <STRING> % x for x in xrange ( 0 , 25 ) ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Driving'", "'v1'", "'wp.%d'", "'/REST/{version}/Routes/{travelMode}'", "'avoid'", "'distanceBeforeFirstTurn'", "'heading'", "'optimize'", "'routePathOutput'", "'tolerances'", "'distanceUnit'", "'dateTime'", "'timeType'", "'maxSolutions'", "'suppressStatus'", "'jsonp'", "'output'", "'jsonso'", "'culture'", "'mapView'", "'userLocation'", "'userIp'", "\"wp.%d\""]}, "window_span": [54, 122], "err_obj": {"msg": "unbalanced (){}[]"}}], ["de8156123d8c2c0e06643e1614b3a3e3", {"code_string": "def list_releases_scenario(runner):\n    runner.request(\n        method = 'GET'\n        path = '/projects/%s/%s/releases/' %(\n            runner.org.slug, runner.default_project.slug)\n    )\n", "code_toks_joined": "def list_releases_scenario ( runner ) : <NEWLINE> <INDENT> runner . request ( <NEWLINE> <INDENT> method = <STRING> <NEWLINE> path = <STRING> % ( <NEWLINE> <INDENT> runner . org . slug , runner . default_project . slug ) <NEWLINE> <DEDENT> <DEDENT> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'GET'", "'/projects/%s/%s/releases/'"]}, "err_obj": {"msg": "invalid syntax"}}], ["18cf05e0f7794ad591e6beb956d90e7e", {"code_string": "def check_paired_end_read_consistency(reads):\n    \"\"\"Check that a set of reads are consistent with their fragment lengths,\"\"\"\n    pe_reads = reads[: , 0]\n    frag_lens = reads[: , 1]\n    num_reads = len(pe_reads)\n    print(\"Checking read consistency for %d reads...\" %(num_reads))\n    print(reads)\n    is_consistent = False\n    is_consistent = all(frag_lens[nonzero(pe_reads == 1)] != - Inf)\n    if not is_consistent:\n    return is_consistent\n    is_consistent = all(frag_lens[nonzero(pe_reads == 0)] == - Inf)\n    return is_consistent\n", "code_toks_joined": "def check_paired_end_read_consistency ( reads ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> pe_reads = reads [ : , 0 ] <NEWLINE> frag_lens = reads [ : , 1 ] <NEWLINE> num_reads = len ( pe_reads ) <NEWLINE> print ( <STRING> % ( num_reads ) ) <NEWLINE> print ( reads ) <NEWLINE> is_consistent = False <NEWLINE> is_consistent = all ( frag_lens [ nonzero ( pe_reads == 1 ) ] != - Inf ) <NEWLINE> if not is_consistent : <NEWLINE> return is_consistent <NEWLINE> is_consistent = all ( frag_lens [ nonzero ( pe_reads == 0 ) ] == - Inf ) <NEWLINE> return is_consistent <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Check that a set of reads are consistent with their fragment lengths,\"\"\"", "\"Checking read consistency for %d reads...\""]}, "err_obj": {"msg": "expected an indented block"}}], ["a54889bcfbf62df08232896268f47604", {"code_string": "def import_text(filename, separator):\n    for line in csv.reader(open(filename), delimiter = separator,\n        skipinitialspace = True):\n        if line:\n        yield line\n", "code_toks_joined": "def import_text ( filename , separator ) : <NEWLINE> <INDENT> for line in csv . reader ( open ( filename ) , delimiter = separator , <NEWLINE> <INDENT> skipinitialspace = True ) : <NEWLINE> if line : <NEWLINE> yield line <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["fd98eec5f879f391d8c37e63987cec1b", {"code_string": "def test(self):\n    for exchange in self.exchanges:\n        for ticker in self.Tickers[exchange]:\n        print(exchange, ticker)\n        try:\n            print(self.Ticker(exchange, ticker))\n            except BTCEError as e:\n            print(\"Error: %s\" % e.value)\n            continue\n            except:\n            continue\n", "code_toks_joined": "def test ( self ) : <NEWLINE> <INDENT> for exchange in self . exchanges : <NEWLINE> <INDENT> for ticker in self . Tickers [ exchange ] : <NEWLINE> print ( exchange , ticker ) <NEWLINE> try : <NEWLINE> <INDENT> print ( self . Ticker ( exchange , ticker ) ) <NEWLINE> except BTCEError as e : <NEWLINE> print ( <STRING> % e . value ) <NEWLINE> continue <NEWLINE> except : <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Error: %s\""]}, "err_obj": {"msg": "expected an indented block"}}], ["3c8a029a2705367f4115d6549fe9527b", {"code_string": "def prepend(elem, l):\n    if l is None or l == \"\":\n        tail = []\n    else:\n        tail = l\n    if elem is None:\n    return tail\n    return[elem] + tail\n", "code_toks_joined": "def prepend ( elem , l ) : <NEWLINE> <INDENT> if l is None or l == <STRING> : <NEWLINE> <INDENT> tail = [ ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tail = l <NEWLINE> <DEDENT> if elem is None : <NEWLINE> return tail <NEWLINE> return [ elem ] + tail <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["218fd837d2761723d18569f925bcd5c5", {"code_string": "def test_original_excepthook(self):\n    savestderr = sys.stderr\n    err = cStringIO.StringIO()\n    sys.stderr = err\n    eh = sys.__excepthook__\n    self.assertRaises(TypeError, eh)\n    try:\n        raise ValueError(42)\n    except ValueError, exc:\n        eh(* sys.exc_info())\n    sys.stderr = savestderr\n    self.assert_(err.getvalue().endswith(\"ValueError: 42\\n\"))\n", "code_toks_joined": "def test_original_excepthook ( self ) : <NEWLINE> <INDENT> savestderr = sys . stderr <NEWLINE> err = cStringIO . StringIO ( ) <NEWLINE> sys . stderr = err <NEWLINE> eh = sys . __excepthook__ <NEWLINE> self . assertRaises ( TypeError , eh ) <NEWLINE> try : <NEWLINE> <INDENT> raise ValueError ( 42 ) <NEWLINE> <DEDENT> except ValueError , exc : <NEWLINE> <INDENT> eh ( * sys . exc_info ( ) ) <NEWLINE> <DEDENT> sys . stderr = savestderr <NEWLINE> self . assert_ ( err . getvalue ( ) . endswith ( <STRING> ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"ValueError: 42\\n\""]}, "err_obj": {"msg": "invalid syntax"}}], ["2c176a75152d0feae5b0985565992534", {"code_string": "def policies(self, objectId = '', status = 'draft'):\n    '''List the policy xmls uploaded''' policy\n    return self.actions('policies', objectId, status)\n", "code_toks_joined": "def policies ( self , objectId = <STRING> , status = <STRING> ) : <NEWLINE> <INDENT> <STRING> policy <NEWLINE> return self . actions ( <STRING> , objectId , status ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "'draft'", "'''List the policy xmls uploaded'''", "'policies'"]}, "err_obj": {"msg": "invalid syntax"}}], ["bda754c6d1dcf8a024c0e227df465759", {"code_string": "def get_location_as_dict(location):\n    tmp_dict = location.__dict__\n    tmp_dict['latitude'] = tmp_dict['loc'].coords[0]\n    tmp_dict['longitude'] = tmp_dict['loc'].coords[1]\n    del tmp_dict['loc']\n    del tmp_dict['_state']\n    tmp_dict['category'] = Category.objects.get(pk = tmp_dict['category_id']).name\n    del tmp_dict['category_id']\n    if '_category_cache' in tmp_dict:\n    del tmp_dict['_category_cache']\n    if 'distance' in tmp_dict:\n    tmp_dict['distance'] = tmp_dict['distance'].m\n    return tmp_dict\n", "code_toks_joined": "def get_location_as_dict ( location ) : <NEWLINE> <INDENT> tmp_dict = location . __dict__ <NEWLINE> tmp_dict [ <STRING> ] = tmp_dict [ <STRING> ] . coords [ 0 ] <NEWLINE> tmp_dict [ <STRING> ] = tmp_dict [ <STRING> ] . coords [ 1 ] <NEWLINE> del tmp_dict [ <STRING> ] <NEWLINE> del tmp_dict [ <STRING> ] <NEWLINE> tmp_dict [ <STRING> ] = Category . objects . get ( pk = tmp_dict [ <STRING> ] ) . name <NEWLINE> del tmp_dict [ <STRING> ] <NEWLINE> if <STRING> in tmp_dict : <NEWLINE> del tmp_dict [ <STRING> ] <NEWLINE> if <STRING> in tmp_dict : <NEWLINE> tmp_dict [ <STRING> ] = tmp_dict [ <STRING> ] . m <NEWLINE> return tmp_dict <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'latitude'", "'loc'", "'longitude'", "'loc'", "'loc'", "'_state'", "'category'", "'category_id'", "'category_id'", "'_category_cache'", "'_category_cache'", "'distance'", "'distance'", "'distance'"]}, "err_obj": {"msg": "expected an indented block"}}], ["20cd258721ebc721eb5ca9fb7eeae88f", {"code_string": "def opened_w_error(filename, mode = \"r\"):\n    \"\"\"This context ensures the file is closed.\"\"\"\n    try:\n        f = codecs.open(filename, encoding = 'utf8', mode = mode)\n    except IOError, err:\n        yield None, err\n    else:\n        try:\n            yield f, None\n        finally:\n            f.close()\n", "code_toks_joined": "def opened_w_error ( filename , mode = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> f = codecs . open ( filename , encoding = <STRING> , mode = mode ) <NEWLINE> <DEDENT> except IOError , err : <NEWLINE> <INDENT> yield None , err <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> yield f , None <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> f . close ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"r\"", "\"\"\"This context ensures the file is closed.\"\"\"", "'utf8'"]}, "err_obj": {"msg": "invalid syntax"}}], ["d8a36970484186931d3043f603c8a2c6", {"code_string": "def to_utf8_optional_iterator(x):\n    \"\"\"Raise TypeError if x is a str or if x is an iterable which\"\"\"\n    if isinstance(x, basestring):\n        return to_utf8(x)\n    try:\n        l = list(x)\n    except TypeError, e:\n        assert 'is not iterable' in str(e)\n        return x\n    else:\n        return[to_utf8_if_string(e) for e in l]\n", "code_toks_joined": "def to_utf8_optional_iterator ( x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if isinstance ( x , basestring ) : <NEWLINE> <INDENT> return to_utf8 ( x ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> l = list ( x ) <NEWLINE> <DEDENT> except TypeError , e : <NEWLINE> <INDENT> assert <STRING> in str ( e ) <NEWLINE> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ to_utf8_if_string ( e ) for e in l ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Raise TypeError if x is a str or if x is an iterable which\"\"\"", "'is not iterable'"]}, "err_obj": {"msg": "invalid syntax"}}], ["c33dc1da8aa4380297150f7d82d96bab", {"code_string": "def sample_crash_data(n, path, folder):\n    df = read_crash_csv(os.path.join(path, 'crashdata.csv'))\n    logging.basicConfig(filename = os.path.join(path, 'sample.log'), level = logging.DEBUG)\n    df_new = df\n    if n != - 1:\n        start = dt.date.today()\n        logging.info('As for %s raw data set contains %s records ...' %(dt.datetime.strftime(start, \"%m/%d/%Y %H:%M:%S\")\n", "code_toks_joined": "def sample_crash_data ( n , path , folder ) : <NEWLINE> <INDENT> df = read_crash_csv ( os . path . join ( path , <STRING> ) ) <NEWLINE> logging . basicConfig ( filename = os . path . join ( path , <STRING> ) , level = logging . DEBUG ) <NEWLINE> df_new = df <NEWLINE> if n != - 1 : <NEWLINE> <INDENT> start = dt . date . today ( ) <NEWLINE> logging . info ( <STRING> % ( dt . datetime . strftime ( start , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'crashdata.csv'", "'sample.log'", "'As for %s raw data set contains %s records ...'", "\"%m/%d/%Y %H:%M:%S\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["d5507ba703380d0ead9347a756c53b1e", {"code_string": "class hotmail:\n    def ataque(self, user, password):\n        print('[INFO] Email: {0} - Contrase\u00f1a: {1}'.format(user, password))\n        try:\n            serverSMTP = smtplib.SMTP('smtp.live.com:587')\n            serverSMTP.starttls()\n            serverSMTP.login(user, password)\n            serverSMTP.quit()\n            table_datas = [\n            [\"ATAQUE EXITOSO\"],\n            [\"\"\"Target: Microsoft\"\"\".format(user, password)]\n", "code_toks_joined": "class hotmail : <NEWLINE> <INDENT> def ataque ( self , user , password ) : <NEWLINE> <INDENT> print ( <STRING> . format ( user , password ) ) <NEWLINE> try : <NEWLINE> <INDENT> serverSMTP = smtplib . SMTP ( <STRING> ) <NEWLINE> serverSMTP . starttls ( ) <NEWLINE> serverSMTP . login ( user , password ) <NEWLINE> serverSMTP . quit ( ) <NEWLINE> table_datas = [ <NEWLINE> [ <STRING> ] , <NEWLINE> [ <STRING> . format ( user , password ) ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'[INFO] Email: {0} - Contrase\u00f1a: {1}'", "'smtp.live.com:587'", "\"ATAQUE EXITOSO\"", "\"\"\"Target: Microsoft\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c8f81917a078761e44f3b4a7966bc5a4", {"code_string": "def getopts(argv):\n    opts = {}\n    while argv:\n    if argv[0][0] == '-':\n        opts[argv[0]] = argv[1]\n        argv = argv[2: ]\n        else:\n        argv = argv[1: ]\n    return opts\n", "code_toks_joined": "def getopts ( argv ) : <NEWLINE> <INDENT> opts = { } <NEWLINE> while argv : <NEWLINE> if argv [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> opts [ argv [ 0 ] ] = argv [ 1 ] <NEWLINE> argv = argv [ 2 : ] <NEWLINE> else : <NEWLINE> argv = argv [ 1 : ] <NEWLINE> <DEDENT> return opts <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'-'"]}, "err_obj": {"msg": "expected an indented block"}}], ["9ee87491316d4f4bd118000a578c62f9", {"code_string": "def shape(arr):\n    i = ndim(arr)\n    shape_val = [0] * i\n    j = 0\n    while j < i:\n        shape_val[j] = native rtl_dsize(arr, j)\n        j += 1\n    return shape_val\n", "code_toks_joined": "def shape ( arr ) : <NEWLINE> <INDENT> i = ndim ( arr ) <NEWLINE> shape_val = [ 0 ] * i <NEWLINE> j = 0 <NEWLINE> while j < i : <NEWLINE> <INDENT> shape_val [ j ] = native rtl_dsize ( arr , j ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> return shape_val <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["03e10c8b359522be1d3917841fce7f87", {"code_string": "def get_links(self, network = None):\n    return[]\n        return PGv2Link.get_links(self.xml)\n", "code_toks_joined": "def get_links ( self , network = None ) : <NEWLINE> <INDENT> return [ ] <NEWLINE> <INDENT> return PGv2Link . get_links ( self . xml ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["ff4f3f26bf8fbc8f8656653e8655503f", {"code_string": "def test_attribute_failed(self):\n    rsrc = self.create_firewall_policy()\n    self.m.ReplayAll()\n    scheduler.TaskRunner(rsrc.create)()\n    error = self.assertRaises(exception.InvalidTemplateAttribute,\n        rsrc.FnGetAtt, 'subnet_id')\n    self.assertEqual(\n        'The Referenced Attribute(firewall_policy subnet_id)is '\n        'incorrect.', six.text_type(error)\n    self.m.VerifyAll()\n", "code_toks_joined": "def test_attribute_failed ( self ) : <NEWLINE> <INDENT> rsrc = self . create_firewall_policy ( ) <NEWLINE> self . m . ReplayAll ( ) <NEWLINE> scheduler . TaskRunner ( rsrc . create ) ( ) <NEWLINE> error = self . assertRaises ( exception . InvalidTemplateAttribute , <NEWLINE> <INDENT> rsrc . FnGetAtt , <STRING> ) <NEWLINE> <DEDENT> self . assertEqual ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> , six . text_type ( error ) <NEWLINE> <DEDENT> self . m . VerifyAll ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'subnet_id'", "'The Referenced Attribute(firewall_policy subnet_id)is '", "'incorrect.'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["2979fa62141144fd98605b2cc49d4b1c", {"code_string": "DOCUMENTATION = \"\"\"module: consul_acl\"\"\"\nEXAMPLES = '''- name: create an acl token with rules'''\nimport sys\nimport urllib2\ntry:\n    import consul\n    from requests.exceptions import ConnectionError\n    python_consul_installed = True\nexcept ImportError, e:\n    python_consul_installed = False\ntry:\n    import hcl\n    pyhcl_installed = True\nexcept ImportError:\n    pyhcl_installed = False\nfrom requests.exceptions import ConnectionError\n", "code_toks_joined": "DOCUMENTATION = <STRING> <NEWLINE> EXAMPLES = <STRING> <NEWLINE> import sys <NEWLINE> import urllib2 <NEWLINE> try : <NEWLINE> <INDENT> import consul <NEWLINE> from requests . exceptions import ConnectionError <NEWLINE> python_consul_installed = True <NEWLINE> <DEDENT> except ImportError , e : <NEWLINE> <INDENT> python_consul_installed = False <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> import hcl <NEWLINE> pyhcl_installed = True <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> pyhcl_installed = False <NEWLINE> <DEDENT> from requests . exceptions import ConnectionError <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"\"\"module: consul_acl\"\"\"", "'''- name: create an acl token with rules'''"]}, "err_obj": {"msg": "invalid syntax"}}], ["5352f59e82b23f517459654d36713bfa", {"code_string": "def should_call_set_folder(self, folder_info, instance, auth, node_settings):\n    if(folder_info and not(\n        instance and getattr(instance, 'folder_id', False) and(\n            instance.folder_id == folder_info or(hasattr(folder_info, 'get') and instance.folder_id == folder_info.get('id', False))\n        ))):\n        if auth.user._id != node_settings.user_settings.owner._id:\n        raise exceptions.PermissionDenied('Requested action requires addon ownership.')\n        return True\n    return False\n", "code_toks_joined": "def should_call_set_folder ( self , folder_info , instance , auth , node_settings ) : <NEWLINE> <INDENT> if ( folder_info and not ( <NEWLINE> <INDENT> instance and getattr ( instance , <STRING> , False ) and ( <NEWLINE> <INDENT> instance . folder_id == folder_info or ( hasattr ( folder_info , <STRING> ) and instance . folder_id == folder_info . get ( <STRING> , False ) ) <NEWLINE> <DEDENT> ) ) ) : <NEWLINE> if auth . user . _id != node_settings . user_settings . owner . _id : <NEWLINE> raise exceptions . PermissionDenied ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'folder_id'", "'get'", "'id'", "'Requested action requires addon ownership.'"]}, "err_obj": {"msg": "expected an indented block"}}], ["8ffa2bf74307a6a52c15ba1129d565f3", {"code_string": "def get_language_by_extension(problem_instance, ext):\n    for lang, extension_list in get_allowed_languages_dict(\n        problem_instance).items():\n        if ext in extension_list:\n        return lang\n    return None\n", "code_toks_joined": "def get_language_by_extension ( problem_instance , ext ) : <NEWLINE> <INDENT> for lang , extension_list in get_allowed_languages_dict ( <NEWLINE> <INDENT> problem_instance ) . items ( ) : <NEWLINE> if ext in extension_list : <NEWLINE> return lang <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["b2083e26b8f63470ea4d917c71ccd6ae", {"code_string": "\"\"\"Syncthing-GTK - 1st run wizard\"\"\"\nfrom __future__ import unicode_literals\nfrom gi.repository import Gtk, Gdk, GLib\nfrom syncthing_gtk import Configuration, DaemonProcess\nfrom syncthing_gtk import DaemonOutputDialog, StDownloader\nfrom syncthing_gtk.tools import get_config_dir, IS_WINDOWS\nfrom syncthing_gtk.tools import can_upgrade_binary, compare_version\nimport os, sys, socket, random, string\nimport logging, traceback, platform\nfrom xml.dom import minidom\n_ = lambda(a): a\nlog = logging.getLogger(\"Wizard\")\nDEFAULT_PORT = 8080\nMAX_PORT = 8100\n", "code_toks_joined": "<STRING> <NEWLINE> from __future__ import unicode_literals <NEWLINE> from gi . repository import Gtk , Gdk , GLib <NEWLINE> from syncthing_gtk import Configuration , DaemonProcess <NEWLINE> from syncthing_gtk import DaemonOutputDialog , StDownloader <NEWLINE> from syncthing_gtk . tools import get_config_dir , IS_WINDOWS <NEWLINE> from syncthing_gtk . tools import can_upgrade_binary , compare_version <NEWLINE> import os , sys , socket , random , string <NEWLINE> import logging , traceback , platform <NEWLINE> from xml . dom import minidom <NEWLINE> _ = lambda ( a ) : a <NEWLINE> log = logging . getLogger ( <STRING> ) <NEWLINE> DEFAULT_PORT = 8080 <NEWLINE> MAX_PORT = 8100 <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"\"\"Syncthing-GTK - 1st run wizard\"\"\"", "\"Wizard\""]}, "err_obj": {"msg": "invalid syntax"}}], ["b0438e3057b9a1e50b5ab13998ef5e44", {"code_string": "def default_source_layer(self):\n    \"\"\"Returns the default source_layer setting for this ComponentSpec.\"\"\"\n    for network, default_layer in[('FeedForwardNetwork', 'layer_0'),\n        ('LayerNormBasicLSTMNetwork', 'state_h_0'),\n        ('LSTMNetwork', 'layer_0'),\n        ('IdentityNetwork', 'input_embeddings')]:\n        if self.spec.network_unit.registered_name.endswith(network):\n        return default_layer\n    raise ValueError('No default source for network unit: %s' %\n        self.spec.network_unit)\n", "code_toks_joined": "def default_source_layer ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for network , default_layer in [ ( <STRING> , <STRING> ) , <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) ] : <NEWLINE> if self . spec . network_unit . registered_name . endswith ( network ) : <NEWLINE> return default_layer <NEWLINE> <DEDENT> raise ValueError ( <STRING> % <NEWLINE> <INDENT> self . spec . network_unit ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns the default source_layer setting for this ComponentSpec.\"\"\"", "'FeedForwardNetwork'", "'layer_0'", "'LayerNormBasicLSTMNetwork'", "'state_h_0'", "'LSTMNetwork'", "'layer_0'", "'IdentityNetwork'", "'input_embeddings'", "'No default source for network unit: %s'"]}, "err_obj": {"msg": "expected an indented block"}}], ["dda8290c3bbb7c6f0060340bcae9a2af", {"code_string": "def find(item_in, list_search):\n    try:\n    return list_search.index(item_in) != None\n    except ValueError:\n    return False\n", "code_toks_joined": "def find ( item_in , list_search ) : <NEWLINE> <INDENT> try : <NEWLINE> return list_search . index ( item_in ) != None <NEWLINE> except ValueError : <NEWLINE> return False <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["f541495ae339f640337c8f217e6f0765", {"code_string": "def verify_default_url(self, actual_url, expected_pixels):\n    \"\"\"Verify correct url structure for a default profile image.\"\"\"\n    self.assertEqual(\n        actual_url\n        '/static/default_{size}.png'.format(size = expected_pixels)\n    )\n", "code_toks_joined": "def verify_default_url ( self , actual_url , expected_pixels ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . assertEqual ( <NEWLINE> <INDENT> actual_url <NEWLINE> <STRING> . format ( size = expected_pixels ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Verify correct url structure for a default profile image.\"\"\"", "'/static/default_{size}.png'"]}, "err_obj": {"msg": "invalid syntax"}}], ["9c376b0a57e5691c19ad1b503d203306", {"code_string": "import codecs\nimport os\nimport re\nfrom setuptools import setup, find_packages\nwith codecs.open(os.path.join(os.path.abspath(os.path.dirname(\n    __file__)), 'elasticine', '__init__.py'), 'r', 'latin1') as fp:\n    try:\n    version = re.findall(r\"^__version__ = '([^']+)'\\r?$\",\n        fp.read(), re.M)[0]\n        except IndexError:\n    raise RuntimeError('Unable to determine version.')\ninstall_requires = ['elasticsearch', 'pyyaml', 'jinja2']\ntests_require = install_requires +['nose']\n", "code_toks_joined": "import codecs <NEWLINE> import os <NEWLINE> import re <NEWLINE> from setuptools import setup , find_packages <NEWLINE> with codecs . open ( os . path . join ( os . path . abspath ( os . path . dirname ( <NEWLINE> <INDENT> __file__ ) ) , <STRING> , <STRING> ) , <STRING> , <STRING> ) as fp : <NEWLINE> try : <NEWLINE> version = re . findall ( <STRING> , <NEWLINE> <INDENT> fp . read ( ) , re . M ) [ 0 ] <NEWLINE> except IndexError : <NEWLINE> <DEDENT> raise RuntimeError ( <STRING> ) <NEWLINE> <DEDENT> install_requires = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> tests_require = install_requires + [ <STRING> ] <NEWLINE>", "anonymize_dict": {"<STRING>": ["'elasticine'", "'__init__.py'", "'r'", "'latin1'", "r\"^__version__ = '([^']+)'\\r?$\"", "'Unable to determine version.'", "'elasticsearch'", "'pyyaml'", "'jinja2'", "'nose'"]}, "err_obj": {"msg": "expected an indented block"}}], ["2a443b5d19fa839b6c04750220d2d14b", {"code_string": "class Music:\n    def play(self):\n        name = \"assets/modules/sugar.mp3\"\n            self.player = subprocess.Popen([\"mplayer\", name, \"-ss\", \"30\"], stdin = subprocess.PIPE, stdout = subprocess.PIPE, stderr = subprocess.PIPE)\n        return \"Playing music\"\n    def stop(self):\n        self.player.stdin.write(\"q\")\n", "code_toks_joined": "class Music : <NEWLINE> <INDENT> def play ( self ) : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> <INDENT> self . player = subprocess . Popen ( [ <STRING> , name , <STRING> , <STRING> ] , stdin = subprocess . PIPE , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <DEDENT> def stop ( self ) : <NEWLINE> <INDENT> self . player . stdin . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"assets/modules/sugar.mp3\"", "\"mplayer\"", "\"-ss\"", "\"30\"", "\"Playing music\"", "\"q\""]}, "err_obj": {"msg": "unexpected indent"}}], ["06864418c93536da1a70ceff642bc5d9", {"code_string": "class HTTPSConnection(HTTPConnection):\n    protocol = 'https'\n    default_port = HTTPS_PORT\n    def __init__(self, host, port = None, key_file = None, cert_file = None,\n        strict = None):\n        if key_file is not None or cert_file is not None:\n        raise NotImplemented(\n            \"key_file and cert_file arguments are not implemented\")\n            super(HTTPSConnection, self).__init__(\n        host, port = port, strict = strict)\n", "code_toks_joined": "class HTTPSConnection ( HTTPConnection ) : <NEWLINE> <INDENT> protocol = <STRING> <NEWLINE> default_port = HTTPS_PORT <NEWLINE> def __init__ ( self , host , port = None , key_file = None , cert_file = None , <NEWLINE> <INDENT> strict = None ) : <NEWLINE> if key_file is not None or cert_file is not None : <NEWLINE> raise NotImplemented ( <NEWLINE> <INDENT> <STRING> ) <NEWLINE> super ( HTTPSConnection , self ) . __init__ ( <NEWLINE> <DEDENT> host , port = port , strict = strict ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'https'", "\"key_file and cert_file arguments are not implemented\""]}, "err_obj": {"msg": "expected an indented block"}}], ["7530f4097f6bce1f0ac9742ed865cd5a", {"code_string": "def get(self, action):\n    if action == \"dashboard\":\n        self.initializeDashboard()\n    elif action == \"logout\":\n        self.logout()\n    elif action == \"timeIsUp\":\n        self.endExercise()\n    elif action == \"askStats\":\n        self.sendStats()\n    else:\n    self.renderLoginPage()\n", "code_toks_joined": "def get ( self , action ) : <NEWLINE> <INDENT> if action == <STRING> : <NEWLINE> <INDENT> self . initializeDashboard ( ) <NEWLINE> <DEDENT> elif action == <STRING> : <NEWLINE> <INDENT> self . logout ( ) <NEWLINE> <DEDENT> elif action == <STRING> : <NEWLINE> <INDENT> self . endExercise ( ) <NEWLINE> <DEDENT> elif action == <STRING> : <NEWLINE> <INDENT> self . sendStats ( ) <NEWLINE> <DEDENT> else : <NEWLINE> self . renderLoginPage ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"dashboard\"", "\"logout\"", "\"timeIsUp\"", "\"askStats\""]}, "err_obj": {"msg": "expected an indented block"}}], ["7b9de8548a2710b515a5a6d7768984f5", {"code_string": "def _set_win32_java_home(self):\n    if 'JAVA_HOME' in self.buildozer.environ:\n        return\n    import _winreg\n    with _winreg.OpenKey(\n        _winreg.HKEY_LOCAL_MACHINE,\n        r\"SOFTWARE\\JavaSoft\\Java Development Kit\") as jdk:\n        current_version, _type = _winreg.QueryValueEx(\n        jdk, \"CurrentVersion\")\n        with _winreg.OpenKey(jdk,\n            current_version) as cv:\n        java_home, _type = _winreg.QueryValueEx(\n            cv, \"JavaHome\")\n            self.buildozer.environ['JAVA_HOME'] = java_home\n", "code_toks_joined": "def _set_win32_java_home ( self ) : <NEWLINE> <INDENT> if <STRING> in self . buildozer . environ : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> import _winreg <NEWLINE> with _winreg . OpenKey ( <NEWLINE> <INDENT> _winreg . HKEY_LOCAL_MACHINE , <NEWLINE> <STRING> ) as jdk : <NEWLINE> current_version , _type = _winreg . QueryValueEx ( <NEWLINE> jdk , <STRING> ) <NEWLINE> with _winreg . OpenKey ( jdk , <NEWLINE> <INDENT> current_version ) as cv : <NEWLINE> <DEDENT> java_home , _type = _winreg . QueryValueEx ( <NEWLINE> <INDENT> cv , <STRING> ) <NEWLINE> self . buildozer . environ [ <STRING> ] = java_home <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'JAVA_HOME'", "r\"SOFTWARE\\JavaSoft\\Java Development Kit\"", "\"CurrentVersion\"", "\"JavaHome\"", "'JAVA_HOME'"]}, "err_obj": {"msg": "expected an indented block"}}], ["85fa7a15315db36ff7f37bea2984d818", {"code_string": "def set_cmd_args(self, mesg):\n    cmd = self.base_cmd_args(mesg)\n    if mesg == 'enabled':\n    cmd.append('/sys/devices/platform/sh-sci.' + str(self.sci_id) + '/tty/ttySC' + str(self.sci_id) + '/power/wakeup')\n    elif mesg == 'mem':\n        cmd.append('/sys/power/state')\n        elif mesg == 'probe':\n        cmd.append('/dev/null')\n        elif mesg == 'wakeup':\n        cmd.append('/dev/null')\n        else:\n            print('Unknown this command')\n    return cmd\n", "code_toks_joined": "def set_cmd_args ( self , mesg ) : <NEWLINE> <INDENT> cmd = self . base_cmd_args ( mesg ) <NEWLINE> if mesg == <STRING> : <NEWLINE> cmd . append ( <STRING> + str ( self . sci_id ) + <STRING> + str ( self . sci_id ) + <STRING> ) <NEWLINE> elif mesg == <STRING> : <NEWLINE> <INDENT> cmd . append ( <STRING> ) <NEWLINE> elif mesg == <STRING> : <NEWLINE> cmd . append ( <STRING> ) <NEWLINE> elif mesg == <STRING> : <NEWLINE> cmd . append ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return cmd <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'enabled'", "'/sys/devices/platform/sh-sci.'", "'/tty/ttySC'", "'/power/wakeup'", "'mem'", "'/sys/power/state'", "'probe'", "'/dev/null'", "'wakeup'", "'/dev/null'", "'Unknown this command'"]}, "err_obj": {"msg": "expected an indented block"}}], ["44a261d6539ad18f15d79d334eaf8756", {"code_string": "def __getitem__(self, index):\n    if index < 0: index = self.length + index\n    let vec: float32x4 = self[...][index // 4]\n    lane = index % 4\n    if lane == 0: return vec.x\n    elif lane == 1: return vec.y\n    elif lane == 2: return vec.z\n    elif lane == 3: return vec.w\n", "code_toks_joined": "def __getitem__ ( self , index ) : <NEWLINE> <INDENT> if index < 0 : index = self . length + index <NEWLINE> let vec : float32x4 = self [ ... ] [ index // 4 ] <NEWLINE> lane = index % 4 <NEWLINE> if lane == 0 : return vec . x <NEWLINE> elif lane == 1 : return vec . y <NEWLINE> elif lane == 2 : return vec . z <NEWLINE> elif lane == 3 : return vec . w <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["4efb244a962af31794f48de54c493f1d", {"code_string": "class Translate(Collection):\n    def __init__(self, parts, x, y, z):\n    self.parts = parts\n    self.where = x, y, z\n    def apply(self):\n    glPushMatrix()\n    glTranslatef(* self.where)\n    def unapply(self):\n    glPopMatrix()\n", "code_toks_joined": "class Translate ( Collection ) : <NEWLINE> <INDENT> def __init__ ( self , parts , x , y , z ) : <NEWLINE> self . parts = parts <NEWLINE> self . where = x , y , z <NEWLINE> def apply ( self ) : <NEWLINE> glPushMatrix ( ) <NEWLINE> glTranslatef ( * self . where ) <NEWLINE> def unapply ( self ) : <NEWLINE> glPopMatrix ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["8232308a7d4c610e7db9d5307282e981", {"code_string": "def ck_stringz_2(self):\n    return self.DFilterCount(pkt_tftp,\n        'tftp.type == \"junk\"', 0)\n            def ck_contains_1(self):\n    return self.DFilterCount(pkt_http,\n        'http.request.method contains \"E\"', 1)\n", "code_toks_joined": "def ck_stringz_2 ( self ) : <NEWLINE> <INDENT> return self . DFilterCount ( pkt_tftp , <NEWLINE> <INDENT> <STRING> , 0 ) <NEWLINE> <INDENT> def ck_contains_1 ( self ) : <NEWLINE> <DEDENT> <DEDENT> return self . DFilterCount ( pkt_http , <NEWLINE> <INDENT> <STRING> , 1 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'tftp.type == \"junk\"'", "'http.request.method contains \"E\"'"]}, "err_obj": {"msg": "unexpected indent"}}], ["a46d47dbf3a6648d1ab537dd66e69ae4", {"code_string": "from django.db import models\nclass Reporter(models.Model)\n    email = models.EmailField()\n", "code_toks_joined": "from django . db import models <NEWLINE> class Reporter ( models . Model ) <NEWLINE> <INDENT> email = models . EmailField ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["1b81adf1939c6fd289f0f515fb9c77c7", {"code_string": "def cross_correl(VX, VY, klag):\n    Np = len(VX)\n    if Np != len(VY):\n        print 'barakuda_stat.cross_correl: ERROR in size! => ', Np, len(VY)\n    if klag >= 0:\n        Rxyl = correl(VX[: Np - klag], VY[klag: ])\n    else:\n        Rxyl = correl(VX[- klag: ], VY[: Np + klag])\n    return Rxyl\n", "code_toks_joined": "def cross_correl ( VX , VY , klag ) : <NEWLINE> <INDENT> Np = len ( VX ) <NEWLINE> if Np != len ( VY ) : <NEWLINE> <INDENT> print <STRING> , Np , len ( VY ) <NEWLINE> <DEDENT> if klag >= 0 : <NEWLINE> <INDENT> Rxyl = correl ( VX [ : Np - klag ] , VY [ klag : ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Rxyl = correl ( VX [ - klag : ] , VY [ : Np + klag ] ) <NEWLINE> <DEDENT> return Rxyl <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'barakuda_stat.cross_correl: ERROR in size! => '"]}, "err_obj": {"msg": "invalid syntax"}}], ["108de9b65a405a835d86d70524cf0b49", {"code_string": "def setupUi(self, MetadataDialog):\n    MetadataDialog.setObjectName(\"MetadataDialog\")\n    MetadataDialog.resize(640, 480)\n    self.gridLayout = QtWidgets.QGridLayout(MetadataDialog)\n    self.gridLayout.setObjectName(\"gridLayout\")\n    self.label = QtWidgets.QLabel(MetadataDialog)\n    self.label.setObjectName(\"label\")\n    self.gridLayout.addWidget(self.label, 0, 0, 1, 1)\n    self.label_2 = QtWidgets.QLabel(MetadataDialog)\n    self.label_2.setObjectName(\"label_2\")\n    self.gridLayout.addWidget(self.label_2, 2, 0, 1, 1)\n    self.buttonBox = QtWidgets.QDialogButtonBox(MetadataDialog)\n    self.buttonBox.setOrientation(QtCore.Qt.Horizontal)\n    self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.Close | QtWidgets.QDialogButtonBox.Save)\n    self.buttonBox.setObjectName(\"buttonBox\")\n    self.gridLayout.addWidget(self.buttonBox, 4, 0, 1, 1)\n    self.metadataEdit = QtWidgets.QTextBrowser(MetadataDialog)\n    font = QtGui.QFont()\n    font.setFamily(\"Droid Sans\")\n    font.setPointSize(10)\n    self.metadataEdit.setFont(font)\n    self.metadataEdit.setStyleSheet(\"QTextBrowser {\\n\"\n", "code_toks_joined": "def setupUi ( self , MetadataDialog ) : <NEWLINE> <INDENT> MetadataDialog . setObjectName ( <STRING> ) <NEWLINE> MetadataDialog . resize ( 640 , 480 ) <NEWLINE> self . gridLayout = QtWidgets . QGridLayout ( MetadataDialog ) <NEWLINE> self . gridLayout . setObjectName ( <STRING> ) <NEWLINE> self . label = QtWidgets . QLabel ( MetadataDialog ) <NEWLINE> self . label . setObjectName ( <STRING> ) <NEWLINE> self . gridLayout . addWidget ( self . label , 0 , 0 , 1 , 1 ) <NEWLINE> self . label_2 = QtWidgets . QLabel ( MetadataDialog ) <NEWLINE> self . label_2 . setObjectName ( <STRING> ) <NEWLINE> self . gridLayout . addWidget ( self . label_2 , 2 , 0 , 1 , 1 ) <NEWLINE> self . buttonBox = QtWidgets . QDialogButtonBox ( MetadataDialog ) <NEWLINE> self . buttonBox . setOrientation ( QtCore . Qt . Horizontal ) <NEWLINE> self . buttonBox . setStandardButtons ( QtWidgets . QDialogButtonBox . Close | QtWidgets . QDialogButtonBox . Save ) <NEWLINE> self . buttonBox . setObjectName ( <STRING> ) <NEWLINE> self . gridLayout . addWidget ( self . buttonBox , 4 , 0 , 1 , 1 ) <NEWLINE> self . metadataEdit = QtWidgets . QTextBrowser ( MetadataDialog ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setFamily ( <STRING> ) <NEWLINE> font . setPointSize ( 10 ) <NEWLINE> self . metadataEdit . setFont ( font ) <NEWLINE> self . metadataEdit . setStyleSheet ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"MetadataDialog\"", "\"gridLayout\"", "\"label\"", "\"label_2\"", "\"buttonBox\"", "\"Droid Sans\"", "\"QTextBrowser {\\n\""]}, "window_span": [242, 246], "err_obj": {"msg": "unbalanced (){}[]"}}], ["9871bf83c1e03197f34a60c83db1f92b", {"code_string": "def external_gateway_removed(self, ri, ext_gw_port):\n    if self._is_global_router(ri):\n        self._remove_sub_interface(ext_gw_port)\n    else:\n        ex_gw_ip = ext_gw_port['subnets'][0]['gateway_ip']\n        if(ex_gw_ip and\n            ext_gw_port['device_owner'] == DEVICE_OWNER_ROUTER_GW):\n            if self._is_port_v6(ext_gw_port):\n            self._remove_default_route_v6(ri, ex_gw_ip, ext_gw_port)\n            else:\n            self._set_nat_pool(ri, ext_gw_port, True)\n            self._remove_default_route(ri, ext_gw_port)\n", "code_toks_joined": "def external_gateway_removed ( self , ri , ext_gw_port ) : <NEWLINE> <INDENT> if self . _is_global_router ( ri ) : <NEWLINE> <INDENT> self . _remove_sub_interface ( ext_gw_port ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ex_gw_ip = ext_gw_port [ <STRING> ] [ 0 ] [ <STRING> ] <NEWLINE> if ( ex_gw_ip and <NEWLINE> <INDENT> ext_gw_port [ <STRING> ] == DEVICE_OWNER_ROUTER_GW ) : <NEWLINE> if self . _is_port_v6 ( ext_gw_port ) : <NEWLINE> self . _remove_default_route_v6 ( ri , ex_gw_ip , ext_gw_port ) <NEWLINE> else : <NEWLINE> self . _set_nat_pool ( ri , ext_gw_port , True ) <NEWLINE> self . _remove_default_route ( ri , ext_gw_port ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'subnets'", "'gateway_ip'", "'device_owner'"]}, "err_obj": {"msg": "expected an indented block"}}], ["8ae6ce246a7626ea0e66612dee928401", {"code_string": "def _InitializePropertyToDefault(self, prop, dst):\n    \"\"\"Initialize a model.Property to its default value inside an object.\"\"\"\n    c = Code()\n    underlying_type = self._type_helper.FollowRef(prop.type_)\n    if(underlying_type.property_type == PropertyType.ENUM and\n        prop.optional):\n        namespace_prefix = ('%s::' % underlying_type.namespace.unix_name\n            if underlying_type.namespace != self._namespace\n            else '')\n            c.Append('%s->%s = %s%s;' %(\n        dst,\n        prop.unix_name,\n        namespace_prefix,\n        self._type_helper.GetEnumNoneValue(prop.type_)))\n    return c\n", "code_toks_joined": "def _InitializePropertyToDefault ( self , prop , dst ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> c = Code ( ) <NEWLINE> underlying_type = self . _type_helper . FollowRef ( prop . type_ ) <NEWLINE> if ( underlying_type . property_type == PropertyType . ENUM and <NEWLINE> <INDENT> prop . optional ) : <NEWLINE> namespace_prefix = ( <STRING> % underlying_type . namespace . unix_name <NEWLINE> <INDENT> if underlying_type . namespace != self . _namespace <NEWLINE> else <STRING> ) <NEWLINE> c . Append ( <STRING> % ( <NEWLINE> <DEDENT> dst , <NEWLINE> prop . unix_name , <NEWLINE> namespace_prefix , <NEWLINE> self . _type_helper . GetEnumNoneValue ( prop . type_ ) ) ) <NEWLINE> <DEDENT> return c <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Initialize a model.Property to its default value inside an object.\"\"\"", "'%s::'", "''", "'%s->%s = %s%s;'"]}, "err_obj": {"msg": "unexpected indent"}}], ["d78423fbbf91f336c5782bae57c4750d", {"code_string": "def _after_authenticate(user, password):\n    for(confirmed, factory_method) in((True, _confirmed_logins),\n        (False, _unconfirmed_logins)):\n        logins = factory_method(user)\n        db_logins = set(\n        [pd.login for pd in PartialDigest.objects.filter(user = user,\n            confirmed = confirmed)])\n            if db_logins != logins:\n            _prepare_partial_digests(user, password)\n            _persist_partial_digests(user)\n            return\n", "code_toks_joined": "def _after_authenticate ( user , password ) : <NEWLINE> <INDENT> for ( confirmed , factory_method ) in ( ( True , _confirmed_logins ) , <NEWLINE> <INDENT> ( False , _unconfirmed_logins ) ) : <NEWLINE> logins = factory_method ( user ) <NEWLINE> db_logins = set ( <NEWLINE> [ pd . login for pd in PartialDigest . objects . filter ( user = user , <NEWLINE> <INDENT> confirmed = confirmed ) ] ) <NEWLINE> if db_logins != logins : <NEWLINE> _prepare_partial_digests ( user , password ) <NEWLINE> _persist_partial_digests ( user ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["99818835718ebef89807e8e87f0dfb43", {"code_string": "def convertTemp(temperature, t_in = 'F', t_out = 'C'):\n    if t_in == 'C' and t_out == 'F':\n        return float(9) / 5) * temperature + 32\n        elif t_in == 'F' and t_out == 'C':\n        return float(5) / 9) *(temperature - 32)\n        else:\n        raise ValueError(\"Incorrect Arguments for function convertTemp(temperature, t_in='F', t_out='C'\")\n", "code_toks_joined": "def convertTemp ( temperature , t_in = <STRING> , t_out = <STRING> ) : <NEWLINE> <INDENT> if t_in == <STRING> and t_out == <STRING> : <NEWLINE> <INDENT> return float ( 9 ) / 5 ) * temperature + 32 <NEWLINE> elif t_in == <STRING> and t_out == <STRING> : <NEWLINE> return float ( 5 ) / 9 ) * ( temperature - 32 ) <NEWLINE> else : <NEWLINE> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'F'", "'C'", "'C'", "'F'", "'F'", "'C'", "\"Incorrect Arguments for function convertTemp(temperature, t_in='F', t_out='C'\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["08e93cc4efa905e515734a0274456047", {"code_string": "def _format_row(self, (slug, title, visits, num_unreviewed)):\n    needs_review = int(num_unreviewed > 0)\n    status, view_name, dummy = REVIEW_STATUSES[needs_review]\n    return dict(title = title,\n        url = reverse('wiki.document', args = [slug],\n            locale = self.locale),\n        visits = visits,\n        status = status,\n        status_url = reverse(view_name, args = [slug],\n            locale = self.locale)\n        if view_name else '')\n", "code_toks_joined": "def _format_row ( self , ( slug , title , visits , num_unreviewed ) ) : <NEWLINE> <INDENT> needs_review = int ( num_unreviewed > 0 ) <NEWLINE> status , view_name , dummy = REVIEW_STATUSES [ needs_review ] <NEWLINE> return dict ( title = title , <NEWLINE> <INDENT> url = reverse ( <STRING> , args = [ slug ] , <NEWLINE> <INDENT> locale = self . locale ) , <NEWLINE> <DEDENT> visits = visits , <NEWLINE> status = status , <NEWLINE> status_url = reverse ( view_name , args = [ slug ] , <NEWLINE> <INDENT> locale = self . locale ) <NEWLINE> <DEDENT> if view_name else <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'wiki.document'", "''"]}, "err_obj": {"msg": "invalid syntax"}}], ["eed69903c1569e48d64ae6786a5160a7", {"code_string": "def put_group_psa(self, group, psa_id, token = None):\n    url = self.base_URL + 'groups/' + group + '/PSA/'\n    data = {}\n        if token is not None:\n            data['token'] = token\n    data['psa_id'] = psa_id\n    return put(url, data = json.dumps(data), headers = self.headers)\n", "code_toks_joined": "def put_group_psa ( self , group , psa_id , token = None ) : <NEWLINE> <INDENT> url = self . base_URL + <STRING> + group + <STRING> <NEWLINE> data = { } <NEWLINE> <INDENT> if token is not None : <NEWLINE> <INDENT> data [ <STRING> ] = token <NEWLINE> <DEDENT> <DEDENT> data [ <STRING> ] = psa_id <NEWLINE> return put ( url , data = json . dumps ( data ) , headers = self . headers ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'groups/'", "'/PSA/'", "'token'", "'psa_id'"]}, "err_obj": {"msg": "unexpected indent"}}], ["4a189944d0866fca040f8b5cb1b22e25", {"code_string": "def _chooseargmax(self, state):\n    self.vstate2 = state\n    self.temp = - 10000\n    self.vQ\n    self.action\n    for a in range(self.actions):\n        self.vQ = self.QL[state[0], state[1], a]\n        if self.vQ > self.temp:\n        self.temp = self.vQ\n        self.action = a\n            return self.action\n", "code_toks_joined": "def _chooseargmax ( self , state ) : <NEWLINE> <INDENT> self . vstate2 = state <NEWLINE> self . temp = - 10000 <NEWLINE> self . vQ <NEWLINE> self . action <NEWLINE> for a in range ( self . actions ) : <NEWLINE> <INDENT> self . vQ = self . QL [ state [ 0 ] , state [ 1 ] , a ] <NEWLINE> if self . vQ > self . temp : <NEWLINE> self . temp = self . vQ <NEWLINE> self . action = a <NEWLINE> <INDENT> return self . action <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["648a455b953fef069a7185cd76882cb8", {"code_string": "import datetime\nimport errno\nimport os\nimport sqlite3\nimport stat\nimport sys\nimport unicodedata\nfrom types import *\ntry:\n    import _find_fuse_parts\nexcept ImportError:\n    pass\nimport fuse\nfrom fuse import Fuse\nif not hasattr(fuse, '__version__'):\n    raise RuntimeError, \"your fuse-py doesn't know of fuse.__version__, probably it's too old.\"\nfuse.fuse_python_api = (0, 2)\nDEFAULT_SHOTWELL_DB = os.environ['HOME'] + '/.local/share/shotwell/data/photo.db'\nTAGS_ROOT = 'tags'\nEVENTS_ROOT = 'events'\nDEFAULT_MIN_EVENT_RATING = 0\n", "code_toks_joined": "import datetime <NEWLINE> import errno <NEWLINE> import os <NEWLINE> import sqlite3 <NEWLINE> import stat <NEWLINE> import sys <NEWLINE> import unicodedata <NEWLINE> from types import * <NEWLINE> try : <NEWLINE> <INDENT> import _find_fuse_parts <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> import fuse <NEWLINE> from fuse import Fuse <NEWLINE> if not hasattr ( fuse , <STRING> ) : <NEWLINE> <INDENT> raise RuntimeError , <STRING> <NEWLINE> <DEDENT> fuse . fuse_python_api = ( 0 , 2 ) <NEWLINE> DEFAULT_SHOTWELL_DB = os . environ [ <STRING> ] + <STRING> <NEWLINE> TAGS_ROOT = <STRING> <NEWLINE> EVENTS_ROOT = <STRING> <NEWLINE> DEFAULT_MIN_EVENT_RATING = 0 <NEWLINE>", "anonymize_dict": {"<STRING>": ["'__version__'", "\"your fuse-py doesn't know of fuse.__version__, probably it's too old.\"", "'HOME'", "'/.local/share/shotwell/data/photo.db'", "'tags'", "'events'"]}, "err_obj": {"msg": "invalid syntax"}}], ["1bfcfcbee64eca801be31d1a5b09a825", {"code_string": "def translate_scancode(scancode):\n    if autosense:\n    scancode = check_auto(scancode)\n    if scancode:\n        if foundxt: return translate_xt(scancode)\n        else: return translate_at(scancode)\n", "code_toks_joined": "def translate_scancode ( scancode ) : <NEWLINE> <INDENT> if autosense : <NEWLINE> scancode = check_auto ( scancode ) <NEWLINE> if scancode : <NEWLINE> <INDENT> if foundxt : return translate_xt ( scancode ) <NEWLINE> else : return translate_at ( scancode ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["b6f851f19c8003a77d6aa3123bf0d2e4", {"code_string": "def is_uwsgi_cfg(filename):\n    filename = validations.is_local_file_exists(filename)\n    for k in UWSGI_DEFAULT_CONFS:\n    if filename.endswith(k):\n    return filename\n    for k in UWSGI_MAGIC_CONFS:\n    if filename.endswith(k):\n    return filename\n    return filename\n", "code_toks_joined": "def is_uwsgi_cfg ( filename ) : <NEWLINE> <INDENT> filename = validations . is_local_file_exists ( filename ) <NEWLINE> for k in UWSGI_DEFAULT_CONFS : <NEWLINE> if filename . endswith ( k ) : <NEWLINE> return filename <NEWLINE> for k in UWSGI_MAGIC_CONFS : <NEWLINE> if filename . endswith ( k ) : <NEWLINE> return filename <NEWLINE> return filename <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["0a7db377be291dc2e7213fc9b559dacd", {"code_string": "def test_blacklist_regex_with_comments_and_regex(self):\n    with io.StringIO() as blacklist_file:\n        for i in range(4):\n            blacklist_file.write(u'fake_regex_%s # Comments\\n' % i)\n        blacklist_file.seek(0)\n        with mock.patch('six.moves.builtins.open',\n            return_value = blacklist_file):\n            result = os_testr.construct_regex('fake_path', None,\n                'fake_regex', False)\n                expected_regex = (\n                \"^((?!fake_regex_3|fake_regex_2|fake_regex_1|\"\n                \"fake_regex_0).)*$fake_regex\")\n                self.assertEqual(result, expected_regex)\n", "code_toks_joined": "def test_blacklist_regex_with_comments_and_regex ( self ) : <NEWLINE> <INDENT> with io . StringIO ( ) as blacklist_file : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> blacklist_file . write ( <STRING> % i ) <NEWLINE> <DEDENT> blacklist_file . seek ( 0 ) <NEWLINE> with mock . patch ( <STRING> , <NEWLINE> <INDENT> return_value = blacklist_file ) : <NEWLINE> result = os_testr . construct_regex ( <STRING> , None , <NEWLINE> <INDENT> <STRING> , False ) <NEWLINE> expected_regex = ( <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> self . assertEqual ( result , expected_regex ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["u'fake_regex_%s # Comments\\n'", "'six.moves.builtins.open'", "'fake_path'", "'fake_regex'", "\"^((?!fake_regex_3|fake_regex_2|fake_regex_1|\"", "\"fake_regex_0).)*$fake_regex\""]}, "err_obj": {"msg": "unexpected indent"}}], ["2453cb0650296ef233a130ca93219e1c", {"code_string": "def __init__(self, options):\n    self.options = options\n    self.seed = FuzzResultFactory.from_options(options)\n    self.baseline = FuzzResultFactory.from_baseline(self.seed)\n    self.dictio = self.get_dictio()\n    self.stats = FuzzStats.from_requestGenerator(self)\n    self._allvar_gen = None\n    if self.seed.history.wf_allvars is not None:\n    self._allvar_gen = self.__allvars_gen(self.dictio)\n", "code_toks_joined": "def __init__ ( self , options ) : <NEWLINE> <INDENT> self . options = options <NEWLINE> self . seed = FuzzResultFactory . from_options ( options ) <NEWLINE> self . baseline = FuzzResultFactory . from_baseline ( self . seed ) <NEWLINE> self . dictio = self . get_dictio ( ) <NEWLINE> self . stats = FuzzStats . from_requestGenerator ( self ) <NEWLINE> self . _allvar_gen = None <NEWLINE> if self . seed . history . wf_allvars is not None : <NEWLINE> self . _allvar_gen = self . __allvars_gen ( self . dictio ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["1bb42d0ba5010434c2b7b1c4d55a193b", {"code_string": "def filter_rooms(self room_ids):\n    \"\"\"Apply the 'rooms' filter to a given list of rooms.\"\"\"\n    room_ids = set(room_ids)\n    disallowed_rooms = set(self.filter_json.get(\"not_rooms\", []))\n    room_ids -= disallowed_rooms\n    allowed_rooms = self.filter_json.get(\"rooms\", None)\n    if allowed_rooms is not None:\n        room_ids &= set(allowed_rooms)\n    return room_ids\n", "code_toks_joined": "def filter_rooms ( self room_ids ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> room_ids = set ( room_ids ) <NEWLINE> disallowed_rooms = set ( self . filter_json . get ( <STRING> , [ ] ) ) <NEWLINE> room_ids -= disallowed_rooms <NEWLINE> allowed_rooms = self . filter_json . get ( <STRING> , None ) <NEWLINE> if allowed_rooms is not None : <NEWLINE> <INDENT> room_ids &= set ( allowed_rooms ) <NEWLINE> <DEDENT> return room_ids <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Apply the 'rooms' filter to a given list of rooms.\"\"\"", "\"not_rooms\"", "\"rooms\""]}, "err_obj": {"msg": "invalid syntax"}}], ["6d8212aff013cccb2cb273060915b15b", {"code_string": "def _append_root_row(self, root_info, parent):\n    \"\"\"Append a new row to the store representing a root share.\"\"\"\n    info = sorted(root_info.iteritems(),\n        key = lambda(name, data): (data.kind, name))\n    for child_name, child_info in info:\n        if child_info.kind == queue_content.KIND_DIR:\n            self._append_folder_row(child_name, child_info, parent)\n        else:\n            self._append_file_row(child_name, child_info, parent)\n", "code_toks_joined": "def _append_root_row ( self , root_info , parent ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> info = sorted ( root_info . iteritems ( ) , <NEWLINE> <INDENT> key = lambda ( name , data ) : ( data . kind , name ) ) <NEWLINE> <DEDENT> for child_name , child_info in info : <NEWLINE> <INDENT> if child_info . kind == queue_content . KIND_DIR : <NEWLINE> <INDENT> self . _append_folder_row ( child_name , child_info , parent ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . _append_file_row ( child_name , child_info , parent ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Append a new row to the store representing a root share.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["36c538bcda99fac2fbf4c0da1f15bada", {"code_string": "class ConditionOr(Automation):\n    \"\"\"Automation for OR condition.\"\"\"\n    def __init__(self, params):\n        self.out = core.GsSldConditionOr(params[\"c0\"][\"class\"](params[\"c0\"])(), params[\"c1\"][\"class\"](params[\"c1\"])()\n", "code_toks_joined": "class ConditionOr ( Automation ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , params ) : <NEWLINE> <INDENT> self . out = core . GsSldConditionOr ( params [ <STRING> ] [ <STRING> ] ( params [ <STRING> ] ) ( ) , params [ <STRING> ] [ <STRING> ] ( params [ <STRING> ] ) ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Automation for OR condition.\"\"\"", "\"c0\"", "\"class\"", "\"c0\"", "\"c1\"", "\"class\"", "\"c1\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["ca386e36064e9c91242d6ac641ce8598", {"code_string": "def avg_temp(P, varname = 'O_temp'):\n    \"\"\"Example function to create avg ocean temperature from expers\"\"\"\n    for c in P.expers.values()[0].axes:\n        exec c.name + ' = c'\n    for k in P.expers.keys():\n        if varname in P.expers[k].vars:\n            mTEMP = P.expers[k].vars[varname] /(X * Y * Z)\n            P.expers[k].insert(mTEMP, name = 'avg_temp')\n", "code_toks_joined": "def avg_temp ( P , varname = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for c in P . expers . values ( ) [ 0 ] . axes : <NEWLINE> <INDENT> exec c . name + <STRING> <NEWLINE> <DEDENT> for k in P . expers . keys ( ) : <NEWLINE> <INDENT> if varname in P . expers [ k ] . vars : <NEWLINE> <INDENT> mTEMP = P . expers [ k ] . vars [ varname ] / ( X * Y * Z ) <NEWLINE> P . expers [ k ] . insert ( mTEMP , name = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'O_temp'", "\"\"\"Example function to create avg ocean temperature from expers\"\"\"", "' = c'", "'avg_temp'"]}, "err_obj": {"msg": "invalid syntax"}}], ["8bf1e4ad10b22ac9a086f3a3f2bda3e2", {"code_string": "def set_center_abs(self, (x, y)):\n    self.rect.center = (x, y)\n    x_center_percent = self.page.x_px2pc(x)\n    y_center_percent = self.page.y_px2pc(y)\n    self.x_percent = x_center_percent -(self.width_percent / 2.0)\n    self.y_percent = y_center_percent -(self.height_percent / 2.0)\n", "code_toks_joined": "def set_center_abs ( self , ( x , y ) ) : <NEWLINE> <INDENT> self . rect . center = ( x , y ) <NEWLINE> x_center_percent = self . page . x_px2pc ( x ) <NEWLINE> y_center_percent = self . page . y_px2pc ( y ) <NEWLINE> self . x_percent = x_center_percent - ( self . width_percent / 2.0 ) <NEWLINE> self . y_percent = y_center_percent - ( self . height_percent / 2.0 ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["4f6e46450eeaec3f56961b5fddc76e82", {"code_string": "def find_module(self, fullname, path = None):\n    path = path or self.path_entry\n    print('\\nlooking for \"%s\"\\n  in %s' %(fullname, path))\n    with contextlib.closing(shelve.open(self.path_entry, 'r')\n        ) as db:\n        key_name = _get_key_name(fullname, db)\n        if key_name:\n        print('  found it as %s' % key_name)\n        return ShelveLoader(path)\n    print('  not found')\n    return None\n", "code_toks_joined": "def find_module ( self , fullname , path = None ) : <NEWLINE> <INDENT> path = path or self . path_entry <NEWLINE> print ( <STRING> % ( fullname , path ) ) <NEWLINE> with contextlib . closing ( shelve . open ( self . path_entry , <STRING> ) <NEWLINE> <INDENT> ) as db : <NEWLINE> key_name = _get_key_name ( fullname , db ) <NEWLINE> if key_name : <NEWLINE> print ( <STRING> % key_name ) <NEWLINE> return ShelveLoader ( path ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> return None <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'\\nlooking for \"%s\"\\n  in %s'", "'r'", "'  found it as %s'", "'  not found'"]}, "err_obj": {"msg": "expected an indented block"}}], ["a7591deb7ec97898d466d62b476da386", {"code_string": "def wrapper(a: int, c: chan int):\n    result = 100\n    c < - result\n", "code_toks_joined": "def wrapper ( a : int , c : chan int ) : <NEWLINE> <INDENT> result = 100 <NEWLINE> c < - result <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["4cdc478c9eeab98039e9fa30c4f6407b", {"code_string": "def phenotype_mutants(self):\n    dpm = defaultdict(set)\n    for mutant, phenotypes in[(mutant, self.mutant_phenotypes(mutant))\n        for mutant in self.mutants()]:\n        for phenotype in phenotypes:\n        dpm[phenotype].add(mutant)\n    return dpm\n", "code_toks_joined": "def phenotype_mutants ( self ) : <NEWLINE> <INDENT> dpm = defaultdict ( set ) <NEWLINE> for mutant , phenotypes in [ ( mutant , self . mutant_phenotypes ( mutant ) ) <NEWLINE> <INDENT> for mutant in self . mutants ( ) ] : <NEWLINE> for phenotype in phenotypes : <NEWLINE> dpm [ phenotype ] . add ( mutant ) <NEWLINE> <DEDENT> return dpm <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["cefdf98e06d36c89d5a538a07d104f90", {"code_string": "def cleanup(self):\n    for user, tenant_id in utils.iterate_per_tenants(\n        self.context[\"users\"]):\n        with logging.ExceptionLogger(\n            LOG, _(\"Unable to delete secgroup: %s.\") %\n            user[\"secgroup\"][\"name\"]):\n        clients = osclients.Clients(user[\"endpoint\"])\n        clients.nova().security_groups.get(\n            user[\"secgroup\"][\"id\"]).delete()\n", "code_toks_joined": "def cleanup ( self ) : <NEWLINE> <INDENT> for user , tenant_id in utils . iterate_per_tenants ( <NEWLINE> <INDENT> self . context [ <STRING> ] ) : <NEWLINE> with logging . ExceptionLogger ( <NEWLINE> <INDENT> LOG , _ ( <STRING> ) % <NEWLINE> user [ <STRING> ] [ <STRING> ] ) : <NEWLINE> <DEDENT> clients = osclients . Clients ( user [ <STRING> ] ) <NEWLINE> clients . nova ( ) . security_groups . get ( <NEWLINE> <INDENT> user [ <STRING> ] [ <STRING> ] ) . delete ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"users\"", "\"Unable to delete secgroup: %s.\"", "\"secgroup\"", "\"name\"", "\"endpoint\"", "\"secgroup\"", "\"id\""]}, "err_obj": {"msg": "expected an indented block"}}], ["5430b449e72c46e9fd5585eb14a80ed1", {"code_string": "def retranslateUi(self, BandwidthDialog):\n    BandwidthDialog.setWindowTitle(_translate(\"BandwidthDialog\", \"Dialog\", None))\n    self.button1.setText(_translate(\"BandwidthDialog\", \"64KB/s \\n\"\n", "code_toks_joined": "def retranslateUi ( self , BandwidthDialog ) : <NEWLINE> <INDENT> BandwidthDialog . setWindowTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . button1 . setText ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"BandwidthDialog\"", "\"Dialog\"", "\"BandwidthDialog\"", "\"64KB/s \\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["39fcf95686bc79b78ab4e796636862ff", {"code_string": "class MathTestCase(unittest.TestCase):\n    def testInt2b128(self):\n        funkylist = range(0, 100) + range(1000, 1100) + range(1000000, 1000100) +[1024 ** 10 l]\n        for i in funkylist:\n            x = StringIO.StringIO()\n            banana.int2b128(i, x.write)\n            v = x.getvalue()\n            y = banana.b1282int(v)\n            assert y == i, \"y = %s; i = %s\" %(y, i)\n", "code_toks_joined": "class MathTestCase ( unittest . TestCase ) : <NEWLINE> <INDENT> def testInt2b128 ( self ) : <NEWLINE> <INDENT> funkylist = range ( 0 , 100 ) + range ( 1000 , 1100 ) + range ( 1000000 , 1000100 ) + [ 1024 ** 10 l ] <NEWLINE> for i in funkylist : <NEWLINE> <INDENT> x = StringIO . StringIO ( ) <NEWLINE> banana . int2b128 ( i , x . write ) <NEWLINE> v = x . getvalue ( ) <NEWLINE> y = banana . b1282int ( v ) <NEWLINE> assert y == i , <STRING> % ( y , i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"y = %s; i = %s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["3f7a89432e0c275621edc639d3b2b9bf", {"code_string": "def _check_args(self, target, * args):\n    \"\"\"Check the arguments passed to start() and raise if they're wrong.\"\"\"\n    if not isinstance(target, Target):\n        raise TypeError(\"Target {} is no Target member!\".format(target))\n    if target in(Target.userscript, Target.spawn, Target.run,\n        Target.fill):\n        if not args:\n        raise cmdexc.CommandError(\n        \"'args' is required with target userscript/spawn/run/\"\n        \"fill.\")\n    else:\n        if args:\n            raise cmdexc.CommandError(\n                \"'args' is only allowed with target userscript/spawn.\")\n", "code_toks_joined": "def _check_args ( self , target , * args ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not isinstance ( target , Target ) : <NEWLINE> <INDENT> raise TypeError ( <STRING> . format ( target ) ) <NEWLINE> <DEDENT> if target in ( Target . userscript , Target . spawn , Target . run , <NEWLINE> <INDENT> Target . fill ) : <NEWLINE> if not args : <NEWLINE> raise cmdexc . CommandError ( <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if args : <NEWLINE> <INDENT> raise cmdexc . CommandError ( <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Check the arguments passed to start() and raise if they're wrong.\"\"\"", "\"Target {} is no Target member!\"", "\"'args' is required with target userscript/spawn/run/\"", "\"fill.\"", "\"'args' is only allowed with target userscript/spawn.\""]}, "err_obj": {"msg": "expected an indented block"}}], ["cb6784277e2e3021771ed5d8263119cd", {"code_string": "def load_hpo():\n    if not mongo['HPO'].find_one():\n        hpo_file = open('/'.join([settings.RESOURCES_PATH, 'hpo2gene.json']))\n            hpo = json.loads(hpo_file.read())\n            payload = []\n            for key, val in hpo.iteritems():\n                payload.append({'hpo_term': key, 'genes': val})\n            mongo['HPO'].insert(payload)\n", "code_toks_joined": "def load_hpo ( ) : <NEWLINE> <INDENT> if not mongo [ <STRING> ] . find_one ( ) : <NEWLINE> <INDENT> hpo_file = open ( <STRING> . join ( [ settings . RESOURCES_PATH , <STRING> ] ) ) <NEWLINE> <INDENT> hpo = json . loads ( hpo_file . read ( ) ) <NEWLINE> payload = [ ] <NEWLINE> for key , val in hpo . iteritems ( ) : <NEWLINE> <INDENT> payload . append ( { <STRING> : key , <STRING> : val } ) <NEWLINE> <DEDENT> mongo [ <STRING> ] . insert ( payload ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'HPO'", "'/'", "'hpo2gene.json'", "'hpo_term'", "'genes'", "'HPO'"]}, "err_obj": {"msg": "unexpected indent"}}], ["eb6a5613599898aa4b8c224e75632ec7", {"code_string": "def __getstate__(self) -> Dict[str, Any]:\n    state = thor.events.EventEmitter.__getstate__(self)\n    for key in[\n        '_md5_processor',\n        '_md5_post_processor',\n        '_gzip_processor',\n        'add_note']:\n        if key in state:\n        del state[key]\n    return state\n", "code_toks_joined": "def __getstate__ ( self ) -> Dict [ str , Any ] : <NEWLINE> <INDENT> state = thor . events . EventEmitter . __getstate__ ( self ) <NEWLINE> for key in [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ] : <NEWLINE> if key in state : <NEWLINE> del state [ key ] <NEWLINE> <DEDENT> return state <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'_md5_processor'", "'_md5_post_processor'", "'_gzip_processor'", "'add_note'"]}, "err_obj": {"msg": "expected an indented block"}}], ["b452860c79ce28c1643cf16131d0bf3a", {"code_string": "def handle_premium(self, pyfile):\n    self.html = json_loads(self.load(\"http://fastix.ru/api_v2/\",\n        get = {'apikey': self.account.get_data('apikey'),\n            'sub': \"getdirectlink\",\n            'link': pyfile.url})\n    data = self.html)\n    self.log_debug(\"Json data\", data)\n    if \"error\\\":true\" in self.html:\n        self.offline()\n    else:\n        self.link = data['downloadlink']\n", "code_toks_joined": "def handle_premium ( self , pyfile ) : <NEWLINE> <INDENT> self . html = json_loads ( self . load ( <STRING> , <NEWLINE> <INDENT> get = { <STRING> : self . account . get_data ( <STRING> ) , <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : pyfile . url } ) <NEWLINE> <DEDENT> <DEDENT> data = self . html ) <NEWLINE> self . log_debug ( <STRING> , data ) <NEWLINE> if <STRING> in self . html : <NEWLINE> <INDENT> self . offline ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . link = data [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"http://fastix.ru/api_v2/\"", "'apikey'", "'apikey'", "'sub'", "\"getdirectlink\"", "'link'", "\"Json data\"", "\"error\\\":true\"", "'downloadlink'"]}, "err_obj": {"msg": "invalid syntax"}}], ["a25adbdef9d286317796459bbdb03eb7", {"code_string": "class WSSimpleEcho(HTTPWebSocketsHandler):\n    def on_ws_message(self, message):\n        if message is None:\n            message = ''\n        self.send_message(message)\n        self.log_message('websocket received ' % s '', str(message))\n    def on_ws_connected(self):\n        self.log_message('%s', 'websocket connected')\n    def on_ws_closed(self):\n        self.log_message('%s', 'websocket closed')\n", "code_toks_joined": "class WSSimpleEcho ( HTTPWebSocketsHandler ) : <NEWLINE> <INDENT> def on_ws_message ( self , message ) : <NEWLINE> <INDENT> if message is None : <NEWLINE> <INDENT> message = <STRING> <NEWLINE> <DEDENT> self . send_message ( message ) <NEWLINE> self . log_message ( <STRING> % s <STRING> , str ( message ) ) <NEWLINE> <DEDENT> def on_ws_connected ( self ) : <NEWLINE> <INDENT> self . log_message ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> def on_ws_closed ( self ) : <NEWLINE> <INDENT> self . log_message ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "'websocket received '", "''", "'%s'", "'websocket connected'", "'%s'", "'websocket closed'"]}, "err_obj": {"msg": "invalid syntax"}}], ["3c5a6f4fd4e4c6eb325995da2a6b7a92", {"code_string": "def test_onethousand_scenarios(self):\n    _args = [\n        '--ai',\n        'rvo2dAI',\n        '--skipInsert',\n        '-c',\n        '--numScenarios',\n        '1000'\n        ]\n    options = getOptions(_args)\n    steerStats = SteerStats(options)\n    results = steerStats.RunStats()\n    self.assertEqual(1000, len(results)\n", "code_toks_joined": "def test_onethousand_scenarios ( self ) : <NEWLINE> <INDENT> _args = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> <NEWLINE> ] <NEWLINE> <DEDENT> options = getOptions ( _args ) <NEWLINE> steerStats = SteerStats ( options ) <NEWLINE> results = steerStats . RunStats ( ) <NEWLINE> self . assertEqual ( 1000 , len ( results ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'--ai'", "'rvo2dAI'", "'--skipInsert'", "'-c'", "'--numScenarios'", "'1000'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["2707a495101e0d2c2a36c45497447f2c", {"code_string": "def remove_devices(self, dev_list):\n    \"\"\" Remove all device listeners \"\"\"\n    for d in dev_list:\n        if d.name_has_listener(self.setup_devices):\n        d.remove_name_listener(self.setup_devices)\n        if self._parent._can_have_nested_devices and d.can_have_chains:\n        if d.chains_has_listener(self.setup_devices):\n            d.remove_chains_listener(self.setup_devices)\n            for c in d.chains:\n            if c.devices_has_listener(self.setup_devices):\n        c.remove_devices_listener(self.setup_devices)\n            self.remove_devices(c.devices)\n", "code_toks_joined": "def remove_devices ( self , dev_list ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for d in dev_list : <NEWLINE> <INDENT> if d . name_has_listener ( self . setup_devices ) : <NEWLINE> d . remove_name_listener ( self . setup_devices ) <NEWLINE> if self . _parent . _can_have_nested_devices and d . can_have_chains : <NEWLINE> if d . chains_has_listener ( self . setup_devices ) : <NEWLINE> <INDENT> d . remove_chains_listener ( self . setup_devices ) <NEWLINE> for c in d . chains : <NEWLINE> if c . devices_has_listener ( self . setup_devices ) : <NEWLINE> <DEDENT> c . remove_devices_listener ( self . setup_devices ) <NEWLINE> <INDENT> self . remove_devices ( c . devices ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Remove all device listeners \"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["f1ddfe023ec34bf8d51f6f792f1ad342", {"code_string": "def nltk_stemming(vectorizer_type):\n    english_stemmer = nltk.stem.SnowballStemmer('english')\n    class StemmedVectorizer(vectorizer_type):\n        def build_analyzer(self):\n            analyser = super(StemmedVectorizer, self).build_analyzer()\n            return lambda doc: (english_stemmer.stem(w) for w in analyser(doc)\n    return StemmedVectorizer\n", "code_toks_joined": "def nltk_stemming ( vectorizer_type ) : <NEWLINE> <INDENT> english_stemmer = nltk . stem . SnowballStemmer ( <STRING> ) <NEWLINE> class StemmedVectorizer ( vectorizer_type ) : <NEWLINE> <INDENT> def build_analyzer ( self ) : <NEWLINE> <INDENT> analyser = super ( StemmedVectorizer , self ) . build_analyzer ( ) <NEWLINE> return lambda doc : ( english_stemmer . stem ( w ) for w in analyser ( doc ) <NEWLINE> <DEDENT> <DEDENT> return StemmedVectorizer <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'english'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["6a59c140222f7dfdf457cbed99313363", {"code_string": "def __init__(self, input_iter):\n    \"\"\"TarBlockIter initializer\"\"\"\n    self.input_iter = input_iter\n    self.offset = 0 l\n    self.process_waiting = False\n    self.process_next_vol_number = None\n    self.previous_index = None\n    self.previous_block = None\n    self.remember_next = False\n    self.remember_value = None\n    self.remember_block = None\n    self.queued_data = None\n", "code_toks_joined": "def __init__ ( self , input_iter ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . input_iter = input_iter <NEWLINE> self . offset = 0 l <NEWLINE> self . process_waiting = False <NEWLINE> self . process_next_vol_number = None <NEWLINE> self . previous_index = None <NEWLINE> self . previous_block = None <NEWLINE> self . remember_next = False <NEWLINE> self . remember_value = None <NEWLINE> self . remember_block = None <NEWLINE> self . queued_data = None <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"TarBlockIter initializer\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["3f97bbece7bfff398b99ec2b2607f9d1", {"code_string": "def __setitem__(self, (channel, id), v):\n    if channel not in self.channels:\n        self.channels[channel] = self.IdDict()\n    self.channels[channel][id] = v\n", "code_toks_joined": "def __setitem__ ( self , ( channel , id ) , v ) : <NEWLINE> <INDENT> if channel not in self . channels : <NEWLINE> <INDENT> self . channels [ channel ] = self . IdDict ( ) <NEWLINE> <DEDENT> self . channels [ channel ] [ id ] = v <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["217b578e7fb1322ada0a101e35893ff4", {"code_string": "def repair_software_only(self):\n    \"\"\"perform software repairs only\"\"\"\n    while True:\n        try:\n            self.repair_filesystem_only()\n            break\n        except(error.AutoservSshPingHostError, error.AutoservSSHTimeout,\n            error.AutoservSshPermissionDeniedError,\n            error.AutoservDiskFullHostError), err:\n            logging.exception('verify failed')\n            logging.info('Trying to reinstall the machine')\n            self._call_repair_func(err, self.machine_install)\n", "code_toks_joined": "def repair_software_only ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . repair_filesystem_only ( ) <NEWLINE> break <NEWLINE> <DEDENT> except ( error . AutoservSshPingHostError , error . AutoservSSHTimeout , <NEWLINE> <INDENT> error . AutoservSshPermissionDeniedError , <NEWLINE> error . AutoservDiskFullHostError ) , err : <NEWLINE> logging . exception ( <STRING> ) <NEWLINE> logging . info ( <STRING> ) <NEWLINE> self . _call_repair_func ( err , self . machine_install ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"perform software repairs only\"\"\"", "'verify failed'", "'Trying to reinstall the machine'"]}, "err_obj": {"msg": "invalid syntax"}}], ["9cfa16f450968e6c95f3fdc20c306355", {"code_string": "class AuthnQueryResponse(AuthnResponse):\n    msgtype = \"authn_query_response\"\n    def __init__(self, sec_context, attribute_converters, entity_id,\n        return_addrs = None, timeslack = 0, asynchop = False, test = False):\n        AuthnResponse.__init__(self, sec_context, attribute_converters,\n            entity_id, return_addrs, timeslack = timeslack,\n            asynchop = asynchop, test = test)\n            self.entity_id = entity_id\n            self.attribute_converters = attribute_converters\n            self.assertion = None\n            self.context = \"AuthnQuery\"\n    def condition_ok(self, lax = False):\n        return True\n", "code_toks_joined": "class AuthnQueryResponse ( AuthnResponse ) : <NEWLINE> <INDENT> msgtype = <STRING> <NEWLINE> def __init__ ( self , sec_context , attribute_converters , entity_id , <NEWLINE> <INDENT> return_addrs = None , timeslack = 0 , asynchop = False , test = False ) : <NEWLINE> AuthnResponse . __init__ ( self , sec_context , attribute_converters , <NEWLINE> <INDENT> entity_id , return_addrs , timeslack = timeslack , <NEWLINE> asynchop = asynchop , test = test ) <NEWLINE> self . entity_id = entity_id <NEWLINE> self . attribute_converters = attribute_converters <NEWLINE> self . assertion = None <NEWLINE> self . context = <STRING> <NEWLINE> <DEDENT> <DEDENT> def condition_ok ( self , lax = False ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"authn_query_response\"", "\"AuthnQuery\""]}, "err_obj": {"msg": "unexpected indent"}}], ["b088199d3b7247ab5acaaa46fdf0fe95", {"code_string": "def _caesar(self, plaintext, shift):\n    lower = string.ascii_lowercase\n    lower_trans = lower[shift: ] + lower[: shift]\n    alphabet = lower + lower.upper()\n    shifted = lower_trans + lower_trans.upper()\n    return plaintext.translate(string.maketrans(alphabet, shifted)\n", "code_toks_joined": "def _caesar ( self , plaintext , shift ) : <NEWLINE> <INDENT> lower = string . ascii_lowercase <NEWLINE> lower_trans = lower [ shift : ] + lower [ : shift ] <NEWLINE> alphabet = lower + lower . upper ( ) <NEWLINE> shifted = lower_trans + lower_trans . upper ( ) <NEWLINE> return plaintext . translate ( string . maketrans ( alphabet , shifted ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["82b0d755849c7d17b17c3d8f995e6ddb", {"code_string": "def test_active(self):\n    \"\"\"Manager has method to return active keys only.\"\"\"\n    self.F.ApiKeyFactory.create(active = False)\n    k = self.F.ApiKeyFactory.create(active = True)\n    self.assertEqual(list(self.model.ApiKey.objects.active(), [k])\n", "code_toks_joined": "def test_active ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . F . ApiKeyFactory . create ( active = False ) <NEWLINE> k = self . F . ApiKeyFactory . create ( active = True ) <NEWLINE> self . assertEqual ( list ( self . model . ApiKey . objects . active ( ) , [ k ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Manager has method to return active keys only.\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["b91cd22302f1982a342432c75854f211", {"code_string": "def get_initial_image(self, node, top):\n    for e in top.elements:\n        if isinstance(e, topdl.Computer):\n        if node == e.name:\n            if e.os and len(e.os) == 1:\n        return e.os[0].get_attribute(\n            'emulab_access:initial_image')\n    return None\n", "code_toks_joined": "def get_initial_image ( self , node , top ) : <NEWLINE> <INDENT> for e in top . elements : <NEWLINE> <INDENT> if isinstance ( e , topdl . Computer ) : <NEWLINE> if node == e . name : <NEWLINE> <INDENT> if e . os and len ( e . os ) == 1 : <NEWLINE> <DEDENT> return e . os [ 0 ] . get_attribute ( <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return None <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'emulab_access:initial_image'"]}, "err_obj": {"msg": "expected an indented block"}}], ["fd7acf7fe98839a104f4433f19c0c4ab", {"code_string": "def print_spanning(G):\n    \"\"\"Compute MST and print the result.\"\"\"\n    print('size of G: {}'.format(G.size(weight = 'weight')))\n    T = nx.minimum_spanning_tree(G)\n    print('size of MST: {}'.format(T.size(weight = 'weight'))\n    print('spanning edges: ')\n    for i in sorted(T.edges(data = True)):\n        print(i)\n", "code_toks_joined": "def print_spanning ( G ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> . format ( G . size ( weight = <STRING> ) ) ) <NEWLINE> T = nx . minimum_spanning_tree ( G ) <NEWLINE> print ( <STRING> . format ( T . size ( weight = <STRING> ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> for i in sorted ( T . edges ( data = True ) ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Compute MST and print the result.\"\"\"", "'size of G: {}'", "'weight'", "'size of MST: {}'", "'weight'", "'spanning edges: '"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["0e6afec062097cadc9f71ce5824f8393", {"code_string": "def get_documents_for_today(self):\n    '''get list of documents that will be triggered today'''\n    docs = []\n    diff_days = self.days_in_advance\n    if self.event == \"Days After\":\n        diff_days = - diff_days\n    for name in frappe.db.sql_list(\"\"\"select name from `tab{0}` where\"\"\".format(self.document_type,\n        self.date_changed), (nowdate(), diff_days or 0)):\n        doc = frappe.get_doc(self.document_type, name)\n        if self.condition and not eval(self.condition, get_context(doc)):\n        continue\n        docs.append(doc)\n    return docs\n", "code_toks_joined": "def get_documents_for_today ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> docs = [ ] <NEWLINE> diff_days = self . days_in_advance <NEWLINE> if self . event == <STRING> : <NEWLINE> <INDENT> diff_days = - diff_days <NEWLINE> <DEDENT> for name in frappe . db . sql_list ( <STRING> . format ( self . document_type , <NEWLINE> <INDENT> self . date_changed ) , ( nowdate ( ) , diff_days or 0 ) ) : <NEWLINE> doc = frappe . get_doc ( self . document_type , name ) <NEWLINE> if self . condition and not eval ( self . condition , get_context ( doc ) ) : <NEWLINE> continue <NEWLINE> docs . append ( doc ) <NEWLINE> <DEDENT> return docs <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''get list of documents that will be triggered today'''", "\"Days After\"", "\"\"\"select name from `tab{0}` where\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["ff0e7f01cdf3216cc00eed21c017adc5", {"code_string": "def retranslateUi(self, SyntaxCheckerDialog):\n    _translate = QtCore.QCoreApplication.translate\n    SyntaxCheckerDialog.setWindowTitle(_translate(\"SyntaxCheckerDialog\", \"Syntax Check Result\"))\n    SyntaxCheckerDialog.setWhatsThis(_translate(\"SyntaxCheckerDialog\", \"<b>Syntax Check Results</b>\\n\"\n", "code_toks_joined": "def retranslateUi ( self , SyntaxCheckerDialog ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> SyntaxCheckerDialog . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> SyntaxCheckerDialog . setWhatsThis ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"SyntaxCheckerDialog\"", "\"Syntax Check Result\"", "\"SyntaxCheckerDialog\"", "\"<b>Syntax Check Results</b>\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["73bab6f0199327661ba20870e40b8e35", {"code_string": "class Stormwaterdrainsetup:\n    def __init__(self, numberofStormwaterpipes, starting_value_i, ** Stormwaterpipeattributes):\n        self.numberofStormwaterpipes = numberofStormwaterpipes\n        self.Stormwaterpipeattributelist = []\n        self.Stormwaterpipenodelist = []\n        for i in range(numberofStormwaterpipes + starting_value_i)[starting_value_i: ]:\n            exec 'self.Stormwaterpipeattributelist.append({\"Stormwaterpipe_' + str(i) + '\" : Stormwaterpipeattributes})'\n            exec '''self.line1='\\\\t\\\\t\\\\t<node id=\"Stormwaterdrain_'+str(i)+'\" class=\"Stormwaterdrain\"/> \\\\n' '''\n            alllines = ''\n            for n in range(1):\n                exec 'alllines += self.line' + str(n + 1)\n            self.Stormwaterpipenodelist.append(alllines)\n        print(str(numberofStormwaterpipes) + ' Stormwaterdrains have been created!')\n        return\n", "code_toks_joined": "class Stormwaterdrainsetup : <NEWLINE> <INDENT> def __init__ ( self , numberofStormwaterpipes , starting_value_i , ** Stormwaterpipeattributes ) : <NEWLINE> <INDENT> self . numberofStormwaterpipes = numberofStormwaterpipes <NEWLINE> self . Stormwaterpipeattributelist = [ ] <NEWLINE> self . Stormwaterpipenodelist = [ ] <NEWLINE> for i in range ( numberofStormwaterpipes + starting_value_i ) [ starting_value_i : ] : <NEWLINE> <INDENT> exec <STRING> + str ( i ) + <STRING> <NEWLINE> exec <STRING> <NEWLINE> alllines = <STRING> <NEWLINE> for n in range ( 1 ) : <NEWLINE> <INDENT> exec <STRING> + str ( n + 1 ) <NEWLINE> <DEDENT> self . Stormwaterpipenodelist . append ( alllines ) <NEWLINE> <DEDENT> print ( str ( numberofStormwaterpipes ) + <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'self.Stormwaterpipeattributelist.append({\"Stormwaterpipe_'", "'\" : Stormwaterpipeattributes})'", "'''self.line1='\\\\t\\\\t\\\\t<node id=\"Stormwaterdrain_'+str(i)+'\" class=\"Stormwaterdrain\"/> \\\\n' '''", "''", "'alllines += self.line'", "' Stormwaterdrains have been created!'"]}, "err_obj": {"msg": "invalid syntax"}}], ["76f45913dd3458239f11f991963f78d7", {"code_string": "def process(self, timeout = None):\n    if DEBUG:\n        print 'Read cbs: ', self._callback_map.keys()\n    if DEBUG:\n        print 'Write cbs: ', self._callback_write_map.keys()\n    pass\n", "code_toks_joined": "def process ( self , timeout = None ) : <NEWLINE> <INDENT> if DEBUG : <NEWLINE> <INDENT> print <STRING> , self . _callback_map . keys ( ) <NEWLINE> <DEDENT> if DEBUG : <NEWLINE> <INDENT> print <STRING> , self . _callback_write_map . keys ( ) <NEWLINE> <DEDENT> pass <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Read cbs: '", "'Write cbs: '"]}, "err_obj": {"msg": "invalid syntax"}}], ["1ed5fbba04650fdd0875379b64354e0d", {"code_string": "def testNegativeLong(self):\n    self.enc.sendEncoded(- 1015 l)\n    self.enc.dataReceived(self.io.getvalue())\n    assert self.result == - 1015 l, \"should be -1015l, got %s\" % self.result\n", "code_toks_joined": "def testNegativeLong ( self ) : <NEWLINE> <INDENT> self . enc . sendEncoded ( - 1015 l ) <NEWLINE> self . enc . dataReceived ( self . io . getvalue ( ) ) <NEWLINE> assert self . result == - 1015 l , <STRING> % self . result <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"should be -1015l, got %s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["c1836a2976b999f03a3ccbade39e60fa", {"code_string": "def getReward(state, minAltitude, scale):\n    if(state[0][2]) < minAltitude:\n        return - 1.\n    else\n        return 1. / np.sqrt(np.sum(np.square(state[0][0: 2] / scale)))\n", "code_toks_joined": "def getReward ( state , minAltitude , scale ) : <NEWLINE> <INDENT> if ( state [ 0 ] [ 2 ] ) < minAltitude : <NEWLINE> <INDENT> return - 1. <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> return 1. / np . sqrt ( np . sum ( np . square ( state [ 0 ] [ 0 : 2 ] / scale ) ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["ff4e6e8ed4b12731d2e5959873ecd008", {"code_string": "class TestDataPlugin(unittest.TestCase):\n    def test_run(self):\n        vodka.data.data_types.instantiate_from_config(\n        [{\n            \"type\": \"data_test\",\n            \"handlers\": [\n                {\n                    \"type\": \"store\",\n                    \"container\": \"list\",\n                    \"limit\": 10\n                }\n                ]\n        }]\n", "code_toks_joined": "class TestDataPlugin ( unittest . TestCase ) : <NEWLINE> <INDENT> def test_run ( self ) : <NEWLINE> <INDENT> vodka . data . data_types . instantiate_from_config ( <NEWLINE> [ { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : [ <NEWLINE> <INDENT> { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : 10 <NEWLINE> <DEDENT> } <NEWLINE> ] <NEWLINE> <DEDENT> <DEDENT> } ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"type\"", "\"data_test\"", "\"handlers\"", "\"type\"", "\"store\"", "\"container\"", "\"list\"", "\"limit\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["7c8ab31ce6d70dd9f8422ddbf6f75090", {"code_string": "def __main__():\n    options, args = doc_optparse.parse(__doc__)\n    try:\n        refindex = int(args[0])\n    except:\n        doc_optparse.exit()\n    maf_reader = maf.Reader(sys.stdin)\n    for m in maf_reader:\n    c = m.components[refindex].src\n    print(c[c.rfind(\"chr\") + 3: ])\n", "code_toks_joined": "def __main__ ( ) : <NEWLINE> <INDENT> options , args = doc_optparse . parse ( __doc__ ) <NEWLINE> try : <NEWLINE> <INDENT> refindex = int ( args [ 0 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> doc_optparse . exit ( ) <NEWLINE> <DEDENT> maf_reader = maf . Reader ( sys . stdin ) <NEWLINE> for m in maf_reader : <NEWLINE> c = m . components [ refindex ] . src <NEWLINE> print ( c [ c . rfind ( <STRING> ) + 3 : ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"chr\""]}, "err_obj": {"msg": "expected an indented block"}}], ["ff5459558998a2d6d3936c63e0a7e89c", {"code_string": "def run_command(cmd):\n    print(\"The command used: \" + cmd)\n    pipe = subprocess.Popen(cmd, shell = True, stderr = subprocess.PIPE)\n        pipe.wait()\n    ret = pipe.returncode\n    if ret:\n        print(\"command died: \" + str(ret))\n            print(pipe.stderr.readlines())\n            sys.exit(1)\n    else:\n        return\n", "code_toks_joined": "def run_command ( cmd ) : <NEWLINE> <INDENT> print ( <STRING> + cmd ) <NEWLINE> pipe = subprocess . Popen ( cmd , shell = True , stderr = subprocess . PIPE ) <NEWLINE> <INDENT> pipe . wait ( ) <NEWLINE> <DEDENT> ret = pipe . returncode <NEWLINE> if ret : <NEWLINE> <INDENT> print ( <STRING> + str ( ret ) ) <NEWLINE> <INDENT> print ( pipe . stderr . readlines ( ) ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"The command used: \"", "\"command died: \""]}, "err_obj": {"msg": "unexpected indent"}}], ["188e72c23fde2a6a2745432e1be5ded2", {"code_string": "def test_streaming_fetchall(self):\n    try:\n        count = 100\n        do_write(count)\n        master_conn = get_master_connection()\n        stream_cursor = cursor.StreamCursor(master_conn)\n        stream_cursor.execute(\"select * from vt_insert_test\", {})\n        rows = stream_cursor.fetchall()\n        rowcount = 0\n        for r in rows:\n            rowcount += 1\n        self.assertEqual(rowcount, count)\n        stream_cursor.close()\n    except Exception, e:\n        self.fail(\"Failed with error %s %s\" %(str(e), traceback.print_exc()))\n", "code_toks_joined": "def test_streaming_fetchall ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> count = 100 <NEWLINE> do_write ( count ) <NEWLINE> master_conn = get_master_connection ( ) <NEWLINE> stream_cursor = cursor . StreamCursor ( master_conn ) <NEWLINE> stream_cursor . execute ( <STRING> , { } ) <NEWLINE> rows = stream_cursor . fetchall ( ) <NEWLINE> rowcount = 0 <NEWLINE> for r in rows : <NEWLINE> <INDENT> rowcount += 1 <NEWLINE> <DEDENT> self . assertEqual ( rowcount , count ) <NEWLINE> stream_cursor . close ( ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> self . fail ( <STRING> % ( str ( e ) , traceback . print_exc ( ) ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"select * from vt_insert_test\"", "\"Failed with error %s %s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["c536c9fb1b057e68c3a64821ce2c0ec2", {"code_string": "def reduce_time_left(self, time_left):\n    \"\"\"Update the time left for generating events. This is typically\"\"\"\n    with self._lock:\n        if time_left >= 0 and(self._time_left < 0\n            or self._time_left > time_left):\n            self._time_left = time_left\n            if self._time_left == 0 and self.handler is not None:\n            m = getattr(\n            getattr(\n            self.handler, \"im_self\", getattr(\n            self.handler, \"__self__\"\n            )\n            ),\n            \"resume\", None\n            )\n            if m is not None and ismethod(m):\n            m()\n", "code_toks_joined": "def reduce_time_left ( self , time_left ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with self . _lock : <NEWLINE> <INDENT> if time_left >= 0 and ( self . _time_left < 0 <NEWLINE> <INDENT> or self . _time_left > time_left ) : <NEWLINE> self . _time_left = time_left <NEWLINE> if self . _time_left == 0 and self . handler is not None : <NEWLINE> m = getattr ( <NEWLINE> getattr ( <NEWLINE> self . handler , <STRING> , getattr ( <NEWLINE> self . handler , <STRING> <NEWLINE> ) <NEWLINE> ) , <NEWLINE> <STRING> , None <NEWLINE> ) <NEWLINE> if m is not None and ismethod ( m ) : <NEWLINE> m ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Update the time left for generating events. This is typically\"\"\"", "\"im_self\"", "\"__self__\"", "\"resume\""]}, "err_obj": {"msg": "expected an indented block"}}], ["8659c1842aa6bf1cd99e4937d3a69abb", {"code_string": "def __setstate__(self, (children, doctype, root)):\n    FtNode.__setstate__(self, children)\n    self.__dict__['__doctype'] = doctype\n    self.__dict__['__documentElement'] = root\n    return\n", "code_toks_joined": "def __setstate__ ( self , ( children , doctype , root ) ) : <NEWLINE> <INDENT> FtNode . __setstate__ ( self , children ) <NEWLINE> self . __dict__ [ <STRING> ] = doctype <NEWLINE> self . __dict__ [ <STRING> ] = root <NEWLINE> return <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'__doctype'", "'__documentElement'"]}, "err_obj": {"msg": "invalid syntax"}}], ["66837e942ff0e63c76d82a6cfe646b74", {"code_string": "def request(url, method = 'GET', data = None):\n    \"\"\"Sends a request to the Targetprocess API\"\"\"\n        self = TargetProcess()\n        if not self._api_key or self._username:\n            raise TypeError('Either basic or API key credentials must be given.')\n", "code_toks_joined": "def request ( url , method = <STRING> , data = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> self = TargetProcess ( ) <NEWLINE> if not self . _api_key or self . _username : <NEWLINE> <INDENT> raise TypeError ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'GET'", "\"\"\"Sends a request to the Targetprocess API\"\"\"", "'Either basic or API key credentials must be given.'"]}, "err_obj": {"msg": "unexpected indent"}}], ["5c80a552aed4d0af6f5d323017683d80", {"code_string": "def OnAddQuit(self, event):\n    while not self.Add(event):\n    True\n    self.OnCancel(event)\n", "code_toks_joined": "def OnAddQuit ( self , event ) : <NEWLINE> <INDENT> while not self . Add ( event ) : <NEWLINE> True <NEWLINE> self . OnCancel ( event ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["fccd79f6ffa079abdd90e9b3f5c007fa", {"code_string": "def extractTextFromTxt(f):\n    'plain txt files.'\n        from tempfile import NamedTemporaryFile\n        destination = NamedTemporaryFile()\n        destination.write(f.read())\n        import codecs\n        str = codecs.open(destination.name, 'r', 'utf-8', 'ignore')\n        return str.read()\n", "code_toks_joined": "def extractTextFromTxt ( f ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> from tempfile import NamedTemporaryFile <NEWLINE> destination = NamedTemporaryFile ( ) <NEWLINE> destination . write ( f . read ( ) ) <NEWLINE> import codecs <NEWLINE> str = codecs . open ( destination . name , <STRING> , <STRING> , <STRING> ) <NEWLINE> return str . read ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'plain txt files.'", "'r'", "'utf-8'", "'ignore'"]}, "err_obj": {"msg": "unexpected indent"}}], ["ef80d55a86a2e3c82e62eb3b821ffe3e", {"code_string": "def _modules_to_main(modList):\n    \"\"\"Force every module in modList to be placed into main\"\"\"\n    if not modList:\n        return\n    main = sys.modules['__main__']\n    for modname in modList:\n        if type(modname) is str:\n            try:\n                mod = __import__(modname)\n            except Exception, i:\n                sys.stderr.write('warning: could not import %s\\n.  Your function may unexpectedly error due to this import failing;  A version mismatch is likely.  Specific error was:\\n' % modname)\n                print_exec(sys.stderr)\n            else:\n                setattr(main, mod.__name__, mod)\n        else:\n            setattr(main, modname.__name__, modname)\n", "code_toks_joined": "def _modules_to_main ( modList ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not modList : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> main = sys . modules [ <STRING> ] <NEWLINE> for modname in modList : <NEWLINE> <INDENT> if type ( modname ) is str : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> mod = __import__ ( modname ) <NEWLINE> <DEDENT> except Exception , i : <NEWLINE> <INDENT> sys . stderr . write ( <STRING> % modname ) <NEWLINE> print_exec ( sys . stderr ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> setattr ( main , mod . __name__ , mod ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> setattr ( main , modname . __name__ , modname ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Force every module in modList to be placed into main\"\"\"", "'__main__'", "'warning: could not import %s\\n.  Your function may unexpectedly error due to this import failing;  A version mismatch is likely.  Specific error was:\\n'"]}, "err_obj": {"msg": "invalid syntax"}}], ["e71d309d82113179941b0ffa4e3ff7c3", {"code_string": "def _loadmodule(module):\n    if module not in sys.modules:\n        modules = module.split(\".\")\n        s = \"\"\n        for i in range(len(modules)):\n            s = \".\".join(modules[: i + 1])\n            exec \"import \" + s\n    return sys.modules[module]\n", "code_toks_joined": "def _loadmodule ( module ) : <NEWLINE> <INDENT> if module not in sys . modules : <NEWLINE> <INDENT> modules = module . split ( <STRING> ) <NEWLINE> s = <STRING> <NEWLINE> for i in range ( len ( modules ) ) : <NEWLINE> <INDENT> s = <STRING> . join ( modules [ : i + 1 ] ) <NEWLINE> exec <STRING> + s <NEWLINE> <DEDENT> <DEDENT> return sys . modules [ module ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\".\"", "\"\"", "\".\"", "\"import \""]}, "err_obj": {"msg": "invalid syntax"}}], ["68b9d22a853618c749d3e974f8dae0a5", {"code_string": "def setupUi(self, MnemonicGenerated):\n    MnemonicGenerated.setObjectName(_fromUtf8(\"MnemonicGenerated\"))\n    MnemonicGenerated.resize(831, 353)\n    palette = QtGui.QPalette()\n    brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(127, 127, 127))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(170, 170, 170))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(127, 127, 127))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(170, 170, 170))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(127, 127, 127))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(127, 127, 127))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(170, 170, 170))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(127, 127, 127))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(127, 127, 127))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipText, brush)\n    MnemonicGenerated.setPalette(palette)\n    self.label_3 = QtGui.QLabel(MnemonicGenerated)\n    self.label_3.setGeometry(QtCore.QRect(50, 10, 131, 61))\n    self.label_3.setText(_fromUtf8(\"\"))\n    self.label_3.setPixmap(QtGui.QPixmap(_fromUtf8(\":/resources/storj-logo-horizontal.png\")))\n    self.label_3.setScaledContents(True)\n    self.label_3.setObjectName(_fromUtf8(\"label_3\"))\n    self.file_name = QtGui.QLabel(MnemonicGenerated)\n    self.file_name.setGeometry(QtCore.QRect(210, 10, 591, 61))\n    font = QtGui.QFont()\n    font.setFamily(_fromUtf8(\"Lato\"))\n    font.setPointSize(11)\n    font.setBold(True)\n    font.setWeight(75)\n    self.file_name.setFont(font)\n    self.file_name.setStyleSheet(_fromUtf8(\"QLabel{\\n\"\n", "code_toks_joined": "def setupUi ( self , MnemonicGenerated ) : <NEWLINE> <INDENT> MnemonicGenerated . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> MnemonicGenerated . resize ( 831 , 353 ) <NEWLINE> palette = QtGui . QPalette ( ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 0 , 0 , 0 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . WindowText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Button , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Light , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Midlight , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 127 , 127 , 127 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Dark , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 170 , 170 , 170 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Mid , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 0 , 0 , 0 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Text , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . BrightText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 0 , 0 , 0 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . ButtonText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Base , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Window , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 0 , 0 , 0 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Shadow , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . AlternateBase , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 220 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . ToolTipBase , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 0 , 0 , 0 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . ToolTipText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 0 , 0 , 0 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . WindowText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Button , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Light , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Midlight , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 127 , 127 , 127 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Dark , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 170 , 170 , 170 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Mid , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 0 , 0 , 0 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Text , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . BrightText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 0 , 0 , 0 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . ButtonText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Base , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Window , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 0 , 0 , 0 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Shadow , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . AlternateBase , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 220 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . ToolTipBase , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 0 , 0 , 0 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . ToolTipText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 127 , 127 , 127 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . WindowText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Button , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Light , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Midlight , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 127 , 127 , 127 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Dark , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 170 , 170 , 170 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Mid , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 127 , 127 , 127 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Text , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . BrightText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 127 , 127 , 127 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . ButtonText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Base , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Window , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 0 , 0 , 0 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Shadow , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . AlternateBase , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 220 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . ToolTipBase , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 0 , 0 , 0 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . ToolTipText , brush ) <NEWLINE> MnemonicGenerated . setPalette ( palette ) <NEWLINE> self . label_3 = QtGui . QLabel ( MnemonicGenerated ) <NEWLINE> self . label_3 . setGeometry ( QtCore . QRect ( 50 , 10 , 131 , 61 ) ) <NEWLINE> self . label_3 . setText ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label_3 . setPixmap ( QtGui . QPixmap ( _fromUtf8 ( <STRING> ) ) ) <NEWLINE> self . label_3 . setScaledContents ( True ) <NEWLINE> self . label_3 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . file_name = QtGui . QLabel ( MnemonicGenerated ) <NEWLINE> self . file_name . setGeometry ( QtCore . QRect ( 210 , 10 , 591 , 61 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setFamily ( _fromUtf8 ( <STRING> ) ) <NEWLINE> font . setPointSize ( 11 ) <NEWLINE> font . setBold ( True ) <NEWLINE> font . setWeight ( 75 ) <NEWLINE> self . file_name . setFont ( font ) <NEWLINE> self . file_name . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"MnemonicGenerated\"", "\"\"", "\":/resources/storj-logo-horizontal.png\"", "\"label_3\"", "\"Lato\"", "\"QLabel{\\n\""]}, "window_span": [2369, 2375], "err_obj": {"msg": "unbalanced (){}[]"}}], ["f673d968edf44a20a03f9ca2b7c3b137", {"code_string": "def __init__(self, debug = False, dataSxtr = None, logger = None):\n    super(Ds9DisplayThread, self).__init__()\n    self.debug = debug\n    self.dataSxtr = dataSxtr\n    self.logger = logger\n    self.stoprequest = threading.Event()\n    self.display = None\n    try:\n        self.display = ds9()\n    except Exception, e:\n        self.logger.warn('__init__: forking ds9 failed:\\n{0}'.format(e))\n", "code_toks_joined": "def __init__ ( self , debug = False , dataSxtr = None , logger = None ) : <NEWLINE> <INDENT> super ( Ds9DisplayThread , self ) . __init__ ( ) <NEWLINE> self . debug = debug <NEWLINE> self . dataSxtr = dataSxtr <NEWLINE> self . logger = logger <NEWLINE> self . stoprequest = threading . Event ( ) <NEWLINE> self . display = None <NEWLINE> try : <NEWLINE> <INDENT> self . display = ds9 ( ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> self . logger . warn ( <STRING> . format ( e ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'__init__: forking ds9 failed:\\n{0}'"]}, "err_obj": {"msg": "invalid syntax"}}], ["4072076a7925229d02464dfe07bafc15", {"code_string": "class AddAmbienceConfirmationDialog(QDialog):\n    def __init__(self, filenames, filepaths, cutnames):\n        QDialog.__init__(self)\n        self.filenames = filenames\n        self.filepaths = filepaths\n        self.cutnames = cutnames\n        self.resize(593, 398)\n        self.setStyleSheet(_fromUtf8(\"background-color:#212526;\"))\n        self.filesListView = QtGui.QListWidget(self)\n        self.filesListView.setGeometry(QtCore.QRect(20, 70, 261, 261))\n        self.filesListView.setStyleSheet(_fromUtf8(\"color: #98A6A8;\\n\"\n", "code_toks_joined": "class AddAmbienceConfirmationDialog ( QDialog ) : <NEWLINE> <INDENT> def __init__ ( self , filenames , filepaths , cutnames ) : <NEWLINE> <INDENT> QDialog . __init__ ( self ) <NEWLINE> self . filenames = filenames <NEWLINE> self . filepaths = filepaths <NEWLINE> self . cutnames = cutnames <NEWLINE> self . resize ( 593 , 398 ) <NEWLINE> self . setStyleSheet ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . filesListView = QtGui . QListWidget ( self ) <NEWLINE> self . filesListView . setGeometry ( QtCore . QRect ( 20 , 70 , 261 , 261 ) ) <NEWLINE> self . filesListView . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"background-color:#212526;\"", "\"color: #98A6A8;\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["76921cdec1eac83d8aa10a321ba8bff9", {"code_string": "def test_positive_create_with_lastname(self):\n    \"\"\"Create User for all variations of Last Name\"\"\"\n    for lastname in generate_strings_list(\n        exclude_types = ['html'], max_length = 50):\n        with self.subTest(lastname):\n        user = entities.User(lastname = lastname).create()\n        self.assertEqual(user.lastname, lastname)\n", "code_toks_joined": "def test_positive_create_with_lastname ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for lastname in generate_strings_list ( <NEWLINE> <INDENT> exclude_types = [ <STRING> ] , max_length = 50 ) : <NEWLINE> with self . subTest ( lastname ) : <NEWLINE> user = entities . User ( lastname = lastname ) . create ( ) <NEWLINE> self . assertEqual ( user . lastname , lastname ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Create User for all variations of Last Name\"\"\"", "'html'"]}, "err_obj": {"msg": "expected an indented block"}}], ["d670750020202d25781b4c797adc138c", {"code_string": "def is_batch_topic_distribution_created(path):\n    \"\"\"Checks existence and reads the batch topic distribution id from the\"\"\"\n    batch_topic_distribution_id = None\n    try:\n        with open(\"%s%sbatch_topic_distribution\"\n            %(path, os.sep)) as batch_prediction_file:\n            batch_topic_distribution_id = batch_prediction_file.readline().strip()\n            try:\n            batch_topic_distribution_id = bigml.api.get_batch_topic_distribution_id(batch_topic_distribution_id)\n            return True, batch_topic_distribution_id\n            except ValueError:\n            return False, None\n    except IOError:\n        return False, None\n", "code_toks_joined": "def is_batch_topic_distribution_created ( path ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> batch_topic_distribution_id = None <NEWLINE> try : <NEWLINE> <INDENT> with open ( <STRING> <NEWLINE> <INDENT> % ( path , os . sep ) ) as batch_prediction_file : <NEWLINE> batch_topic_distribution_id = batch_prediction_file . readline ( ) . strip ( ) <NEWLINE> try : <NEWLINE> batch_topic_distribution_id = bigml . api . get_batch_topic_distribution_id ( batch_topic_distribution_id ) <NEWLINE> return True , batch_topic_distribution_id <NEWLINE> except ValueError : <NEWLINE> return False , None <NEWLINE> <DEDENT> <DEDENT> except IOError : <NEWLINE> <INDENT> return False , None <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Checks existence and reads the batch topic distribution id from the\"\"\"", "\"%s%sbatch_topic_distribution\""]}, "err_obj": {"msg": "expected an indented block"}}], ["ce4d657e5502d28403f55a4e3437455a", {"code_string": "def test_abort(self req):\n    reply = networkreply.FixedDataNetworkReply(req, b'foo', 'test/foo')\n    reply.abort()\n    assert reply.readAll() == b'foo'\n", "code_toks_joined": "def test_abort ( self req ) : <NEWLINE> <INDENT> reply = networkreply . FixedDataNetworkReply ( req , <STRING> , <STRING> ) <NEWLINE> reply . abort ( ) <NEWLINE> assert reply . readAll ( ) == <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["b'foo'", "'test/foo'", "b'foo'"]}, "err_obj": {"msg": "invalid syntax"}}], ["0f52dfe850c4bafbfe160ce112d71856", {"code_string": "def talkToGit(refs):\n    didFetch = False\n    chunk = sys.stdin.read()\n    if chunk == = 'capabilities\\n':\n        sys.stdout.write('fetch\\n')\n    else if chunk == = 'list\\n':\n        for i in refs:\n            sys.stdout.write(\"%s %s\\n\" %(refs[i], i))\n        sys.stdout.write('\\n')\n    else if chunk and re.search(r\"^fetch\", chunk) != = None):\n        didFetch = True\n        for line in chunk.splitlines():\n            if line == = '':\n                return\n            line = line.split()\n            getHashInfo(line[1], line[2])\n    else if chunk and chunk != = '' and chunk != = '\\n':\n        sys.stderr.write(\"\"\"unhandled command: \"%s\\\"\"\"\" % chunk)\n    if chunk == = '\\n':\n        sys.stdout.write('\\n')\n        if not didFetch:\n            quit()\n        return\n", "code_toks_joined": "def talkToGit ( refs ) : <NEWLINE> <INDENT> didFetch = False <NEWLINE> chunk = sys . stdin . read ( ) <NEWLINE> if chunk == = <STRING> : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> else if chunk == = <STRING> : <NEWLINE> <INDENT> for i in refs : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> % ( refs [ i ] , i ) ) <NEWLINE> <DEDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> else if chunk and re . search ( <STRING> , chunk ) != = None ) : <NEWLINE> <INDENT> didFetch = True <NEWLINE> for line in chunk . splitlines ( ) : <NEWLINE> <INDENT> if line == = <STRING> : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> line = line . split ( ) <NEWLINE> getHashInfo ( line [ 1 ] , line [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> else if chunk and chunk != = <STRING> and chunk != = <STRING> : <NEWLINE> <INDENT> sys . stderr . write ( <STRING> % chunk ) <NEWLINE> <DEDENT> if chunk == = <STRING> : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> if not didFetch : <NEWLINE> <INDENT> quit ( ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'capabilities\\n'", "'fetch\\n'", "'list\\n'", "\"%s %s\\n\"", "'\\n'", "r\"^fetch\"", "''", "''", "'\\n'", "\"\"\"unhandled command: \"%s\\\"\"\"\"", "'\\n'", "'\\n'"]}, "window_span": [84, 103], "err_obj": {"msg": "unbalanced (){}[]"}}], ["133452780ba8646caf91310808038c7f", {"code_string": "def main():\n    input = \"Components.h\"\n    output = SHORT + \"gen.py\"\n    defsoutput = TOOLBOXDIR + LONG + \".py\"\n    scanner = MyScanner(input, output, defsoutput)\n    scanner.scan()\n    scanner.close()\n    print(\"=== Testing definitions output code ===\")\n    execfile(defsoutput, {}, {})\n    print(\"=== Done scanning and generating, now importing the generated code... ===\")\n    exec \"import \" + SHORT + \"support\"\n    print(\"=== Done.  It's up to you to compile it now! ===\")\n", "code_toks_joined": "def main ( ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = SHORT + <STRING> <NEWLINE> defsoutput = TOOLBOXDIR + LONG + <STRING> <NEWLINE> scanner = MyScanner ( input , output , defsoutput ) <NEWLINE> scanner . scan ( ) <NEWLINE> scanner . close ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> execfile ( defsoutput , { } , { } ) <NEWLINE> print ( <STRING> ) <NEWLINE> exec <STRING> + SHORT + <STRING> <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Components.h\"", "\"gen.py\"", "\".py\"", "\"=== Testing definitions output code ===\"", "\"=== Done scanning and generating, now importing the generated code... ===\"", "\"import \"", "\"support\"", "\"=== Done.  It's up to you to compile it now! ===\""]}, "err_obj": {"msg": "invalid syntax"}}], ["50736c28b849219592f31362818b26e0", {"code_string": "def show_section_vehicle_type_template(self, pif, sect):\n    flago = mflags.FlagList()\n    sect['entry'] = [self.get_vt_model_table(pif, self.mdict[mod], flago) for mod in sect['model_ids']]\n        return sect\n", "code_toks_joined": "def show_section_vehicle_type_template ( self , pif , sect ) : <NEWLINE> <INDENT> flago = mflags . FlagList ( ) <NEWLINE> sect [ <STRING> ] = [ self . get_vt_model_table ( pif , self . mdict [ mod ] , flago ) for mod in sect [ <STRING> ] ] <NEWLINE> <INDENT> return sect <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'entry'", "'model_ids'"]}, "err_obj": {"msg": "unexpected indent"}}], ["9c2e04b09c8a8240fd14d192473569fa", {"code_string": "def _iteritems(self):\n    \"\"\"For backwards-compatibility with dict-based objects.\"\"\"\n    for name in self._obj.obj_fields:\n        if(self._obj.obj_attr_is_set(name) or\n            name in self._obj.obj_extra_fields):\n            if name == 'id':\n            yield name, self.id\n            elif name == 'host':\n            yield name, self.host\n            else:\n            yield name, getattr(self._obj, name)\n", "code_toks_joined": "def _iteritems ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for name in self . _obj . obj_fields : <NEWLINE> <INDENT> if ( self . _obj . obj_attr_is_set ( name ) or <NEWLINE> <INDENT> name in self . _obj . obj_extra_fields ) : <NEWLINE> if name == <STRING> : <NEWLINE> yield name , self . id <NEWLINE> elif name == <STRING> : <NEWLINE> yield name , self . host <NEWLINE> else : <NEWLINE> yield name , getattr ( self . _obj , name ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"For backwards-compatibility with dict-based objects.\"\"\"", "'id'", "'host'"]}, "err_obj": {"msg": "expected an indented block"}}], ["5d5c9b6c830d7f2abdab79dc538cb766", {"code_string": "def define_tables(cls metadata):\n    cls.define_reflected_tables(metadata, None)\n    if testing.requires.schemas.enabled:\n        cls.define_reflected_tables(metadata, testing.config.test_schema)\n", "code_toks_joined": "def define_tables ( cls metadata ) : <NEWLINE> <INDENT> cls . define_reflected_tables ( metadata , None ) <NEWLINE> if testing . requires . schemas . enabled : <NEWLINE> <INDENT> cls . define_reflected_tables ( metadata , testing . config . test_schema ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["1a6eda516e59898472b5913d636f531d", {"code_string": "def send_data(A: chan Sender < int >, B: chan Sender < int >, X: int, Y: int):\n    while True:\n        print('sending data..')\n        A < - X\n        B < - Y\n", "code_toks_joined": "def send_data ( A : chan Sender < int > , B : chan Sender < int > , X : int , Y : int ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> A < - X <NEWLINE> B < - Y <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'sending data..'"]}, "err_obj": {"msg": "invalid syntax"}}], ["d475fda952887dedf96fb6a56b34ad93", {"code_string": "def server_names_and_ips_loop(server_variable):\n    serverList = []\n    while server_variable > 0:\n    serverName = raw_input('What is the server name? ')\n    serverIP = raw_input('What is the server IP? ')\n    serverName = str(serverName)\n    serverIP = str(serverIP)\n    serverList.append(serverName)\n    serverList.append(serverIP)\n    server_variable -= 1\n    return serverList\n", "code_toks_joined": "def server_names_and_ips_loop ( server_variable ) : <NEWLINE> <INDENT> serverList = [ ] <NEWLINE> while server_variable > 0 : <NEWLINE> serverName = raw_input ( <STRING> ) <NEWLINE> serverIP = raw_input ( <STRING> ) <NEWLINE> serverName = str ( serverName ) <NEWLINE> serverIP = str ( serverIP ) <NEWLINE> serverList . append ( serverName ) <NEWLINE> serverList . append ( serverIP ) <NEWLINE> server_variable -= 1 <NEWLINE> return serverList <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'What is the server name? '", "'What is the server IP? '"]}, "err_obj": {"msg": "expected an indented block"}}], ["a8e841d3ac39c55652f998cc9a9d1926", {"code_string": "def usage(status)\n    print(__doc__ % globals())\n    sys.exit(status)\n", "code_toks_joined": "def usage ( status ) <NEWLINE> <INDENT> print ( __doc__ % globals ( ) ) <NEWLINE> sys . exit ( status ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["328a8b38095e33c2e8ed72891c13c8ce", {"code_string": "class ZulipDummyBackend(ZulipAuthMixin):\n    \"\"\"Used when we want to log you in but we don't know which backend to use.\"\"\"\n    def authenticate(self, username = None, realm_subdomain = None, use_dummy_backend = False,\n        return_data = None):\n        if use_dummy_backend:\n        user_profile = common_get_active_user_by_email(username)\n        if user_profile is None:\n        return None\n        if not check_subdomain(realm_subdomain, user_profile.realm.subdomain):\n        return_data[\"invalid_subdomain\"] = True\n        return None\n        return user_profile\n        return None\n", "code_toks_joined": "class ZulipDummyBackend ( ZulipAuthMixin ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def authenticate ( self , username = None , realm_subdomain = None , use_dummy_backend = False , <NEWLINE> <INDENT> return_data = None ) : <NEWLINE> if use_dummy_backend : <NEWLINE> user_profile = common_get_active_user_by_email ( username ) <NEWLINE> if user_profile is None : <NEWLINE> return None <NEWLINE> if not check_subdomain ( realm_subdomain , user_profile . realm . subdomain ) : <NEWLINE> return_data [ <STRING> ] = True <NEWLINE> return None <NEWLINE> return user_profile <NEWLINE> return None <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Used when we want to log you in but we don't know which backend to use.\"\"\"", "\"invalid_subdomain\""]}, "err_obj": {"msg": "expected an indented block"}}], ["22e62f46a1e974481d4704db831d6a24", {"code_string": "def cb_init_hook(option, optname, value, parser):\n    \"\"\"exec arbitrary code to set sys.path for instance\"\"\"\n    exec value\n", "code_toks_joined": "def cb_init_hook ( option , optname , value , parser ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> exec value <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"exec arbitrary code to set sys.path for instance\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["caec4502be227e2ecc7154f810fbcc4b", {"code_string": "def flush(self):\n    data = ''.join(self.buff)\n    del self.buff[: ]\n    self.buff_len = 0\n    if debug_write:\n        print \"write(%s)\" %(repr(data), )\n    while data:\n        self._wait()\n        data = data[self._write(data): ]\n", "code_toks_joined": "def flush ( self ) : <NEWLINE> <INDENT> data = <STRING> . join ( self . buff ) <NEWLINE> del self . buff [ : ] <NEWLINE> self . buff_len = 0 <NEWLINE> if debug_write : <NEWLINE> <INDENT> print <STRING> % ( repr ( data ) , ) <NEWLINE> <DEDENT> while data : <NEWLINE> <INDENT> self . _wait ( ) <NEWLINE> data = data [ self . _write ( data ) : ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "\"write(%s)\""]}, "err_obj": {"msg": "invalid syntax"}}], ["038bae45e3613d3efb694097bb21fec8", {"code_string": "def reg(self, identity, password):\n    salt = os.urandom(64)\n    x = bin_str_to_big_int(sha256(salt, password)\n    verifier = mod_exp(self.config.g, x, self.config.N)\n    self.server.reg(identity, salt, verifier)\n", "code_toks_joined": "def reg ( self , identity , password ) : <NEWLINE> <INDENT> salt = os . urandom ( 64 ) <NEWLINE> x = bin_str_to_big_int ( sha256 ( salt , password ) <NEWLINE> verifier = mod_exp ( self . config . g , x , self . config . N ) <NEWLINE> self . server . reg ( identity , salt , verifier ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["947ac5910e714869029b8d0e351a1b6c", {"code_string": "def getDataPath():\n    import os\n    data_path = None\n    for testpath in['/mnt/crashanalysis/rkaiser/',\n        '/home/rkaiser/reports/',\n        '/mnt/mozilla/projects/socorro/']:\n        if os.path.exists(testpath) and os.path.isdir(testpath):\n        data_path = testpath\n        break\n    return data_path\n", "code_toks_joined": "def getDataPath ( ) : <NEWLINE> <INDENT> import os <NEWLINE> data_path = None <NEWLINE> for testpath in [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ] : <NEWLINE> if os . path . exists ( testpath ) and os . path . isdir ( testpath ) : <NEWLINE> data_path = testpath <NEWLINE> break <NEWLINE> <DEDENT> return data_path <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'/mnt/crashanalysis/rkaiser/'", "'/home/rkaiser/reports/'", "'/mnt/mozilla/projects/socorro/'"]}, "err_obj": {"msg": "expected an indented block"}}], ["da7a2ebb058017d9e1dc36215b629c3c", {"code_string": "def test_modified_module(self):\n    import clr\n    test_name = \"test_modified_module.py\"\n    try:\n        with open(test_name, \"w\") as f:\n            f.writelines('''A=1\n            with path_modifier('.') as p:\n                with stdout_trapper() as output:\n                    new_module = clr.Use(test_name.split(\".py\")[0])\n            self.assertEqual(output.messages, [\"First Run\"])\n            self.assertEqual(new_module.A, 1)\n            with open(test_name, \"w\") as f:\n                f.writelines(''' A = 2\n        with path_modifier('.') as p:\n            with stdout_trapper() as output:\n                new_module = clr.Use(test_name.split(\".py\")[0])\n        self.assertEqual(output.messages, [])\n        self.assertEqual(new_module.A, 1)\n    finally:\n        try:\n            os.remove(test_name)\n        except: pass\n", "code_toks_joined": "def test_modified_module ( self ) : <NEWLINE> <INDENT> import clr <NEWLINE> test_name = <STRING> <NEWLINE> try : <NEWLINE> <INDENT> with open ( test_name , <STRING> ) as f : <NEWLINE> <INDENT> f . writelines ( <STRING> A = 2 <NEWLINE> <DEDENT> with path_modifier ( <STRING> ) as p : <NEWLINE> <INDENT> with stdout_trapper ( ) as output : <NEWLINE> <INDENT> new_module = clr . Use ( test_name . split ( <STRING> ) [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> self . assertEqual ( output . messages , [ ] ) <NEWLINE> self . assertEqual ( new_module . A , 1 ) <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> os . remove ( test_name ) <NEWLINE> <DEDENT> except : pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"test_modified_module.py\"", "\"w\"", "'''A=1\n            with path_modifier('.') as p:\n                with stdout_trapper() as output:\n                    new_module = clr.Use(test_name.split(\".py\")[0])\n            self.assertEqual(output.messages, [\"First Run\"])\n            self.assertEqual(new_module.A, 1)\n            with open(test_name, \"w\") as f:\n                f.writelines('''", "'.'", "\".py\""]}, "window_span": [34, 125], "err_obj": {"msg": "unbalanced (){}[]"}}], ["57bbdf48dee1e994df5c8083a405a68e", {"code_string": "def update_docs_pull(record = False, force = False):\n    \"\"\"A high-level interface that will update all of the projects.\"\"\"\n    for version in Version.objects.filter(built = True):\n        try:\n            update_docs(\n                pk = version.project.pk, version_pk = version.pk, record = record)\n        except Exception, e:\n            log.error(\"update_docs_pull failed\", exc_info = True)\n", "code_toks_joined": "def update_docs_pull ( record = False , force = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for version in Version . objects . filter ( built = True ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> update_docs ( <NEWLINE> <INDENT> pk = version . project . pk , version_pk = version . pk , record = record ) <NEWLINE> <DEDENT> <DEDENT> except Exception , e : <NEWLINE> <INDENT> log . error ( <STRING> , exc_info = True ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"A high-level interface that will update all of the projects.\"\"\"", "\"update_docs_pull failed\""]}, "err_obj": {"msg": "invalid syntax"}}], ["9ca0772c9317f2faa51cd7f0e6204704", {"code_string": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nnamespace Feed\n{\n    public class CurrentData\n    {\n        public Info Info = new Info();\n        public List < Item > Items = new List < Item >();\n    }\n}\n", "code_toks_joined": "using System ; <NEWLINE> using System . Collections . Generic ; <NEWLINE> using System . Linq ; <NEWLINE> using System . Text ; <NEWLINE> namespace Feed <NEWLINE> { <NEWLINE> <INDENT> public class CurrentData <NEWLINE> { <NEWLINE> <INDENT> public Info Info = new Info ( ) ; <NEWLINE> public List < Item > Items = new List < Item > ( ) ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["27a917c06fa17395bf8f8fedeb13dda4", {"code_string": "class MenuCascade(MenuEntry):\n    def __init__(self, text, entries, ** kw):\n    self.entries = entries\n    self.label = text\n    self.submenu = None\n    self.kwargs = kw\n    def AddToMenu(self, menu):\n    if menu:\n        self.submenu = apply(UpdatedMenu, (menu, self.entries), self.kwargs)\n        menu.add('cascade', label = self.label, menu = self.submenu.menu)\n        self.menu = menu\n", "code_toks_joined": "class MenuCascade ( MenuEntry ) : <NEWLINE> <INDENT> def __init__ ( self , text , entries , ** kw ) : <NEWLINE> self . entries = entries <NEWLINE> self . label = text <NEWLINE> self . submenu = None <NEWLINE> self . kwargs = kw <NEWLINE> def AddToMenu ( self , menu ) : <NEWLINE> if menu : <NEWLINE> <INDENT> self . submenu = apply ( UpdatedMenu , ( menu , self . entries ) , self . kwargs ) <NEWLINE> menu . add ( <STRING> , label = self . label , menu = self . submenu . menu ) <NEWLINE> self . menu = menu <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'cascade'"]}, "err_obj": {"msg": "expected an indented block"}}], ["4b373f406a16d38f464dd95b01e51b8e", {"code_string": "def resnet_v2_block(scope, base_depth, num_units, stride):\n    \"\"\"Helper function for creating a resnet_v2 bottleneck block.\"\"\"\n    return resnet_utils.Block(scope, bottleneck, [{\n        'depth': base_depth * 4,\n        'depth_bottleneck': base_depth,\n        'stride': 1\n    }] *(num_units - 1) +[{\n        'depth': base_depth * 4,\n        'depth_bottleneck': base_depth\n        'stride': stride\n    }])\n", "code_toks_joined": "def resnet_v2_block ( scope , base_depth , num_units , stride ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return resnet_utils . Block ( scope , bottleneck , [ { <NEWLINE> <INDENT> <STRING> : base_depth * 4 , <NEWLINE> <STRING> : base_depth , <NEWLINE> <STRING> : 1 <NEWLINE> <DEDENT> } ] * ( num_units - 1 ) + [ { <NEWLINE> <INDENT> <STRING> : base_depth * 4 , <NEWLINE> <STRING> : base_depth <NEWLINE> <STRING> : stride <NEWLINE> <DEDENT> } ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Helper function for creating a resnet_v2 bottleneck block.\"\"\"", "'depth'", "'depth_bottleneck'", "'stride'", "'depth'", "'depth_bottleneck'", "'stride'"]}, "err_obj": {"msg": "invalid syntax"}}], ["59fa6d5aca586be91047c4d6a39c20d2", {"code_string": "def launch_about_dialog():\n    \"\"\"Launches the Help -> About dialog\"\"\"\n    view = AboutView(qtutils.active_window())\n    view.set_version(version.version()\n    view.show()\n", "code_toks_joined": "def launch_about_dialog ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> view = AboutView ( qtutils . active_window ( ) ) <NEWLINE> view . set_version ( version . version ( ) <NEWLINE> view . show ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Launches the Help -> About dialog\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["997d9f592e2963540d58e33e154530eb", {"code_string": "def _dcommit_calls_bypassed(cls):\n    return[\n        ((['git', 'config', 'branch.working.rietveldissue'], ), '12345'),\n        ((['git', 'config', 'branch.working.rietveldserver'], ),\n            'codereview.example.com'),\n        (('GitClHooksBypassedCommit',\n            'Issue https://codereview.example.com/12345 bypassed hook when '\n", "code_toks_joined": "def _dcommit_calls_bypassed ( cls ) : <NEWLINE> <INDENT> return [ <NEWLINE> <INDENT> ( ( [ <STRING> , <STRING> , <STRING> ] , ) , <STRING> ) , <NEWLINE> ( ( [ <STRING> , <STRING> , <STRING> ] , ) , <NEWLINE> <INDENT> <STRING> ) , <NEWLINE> <DEDENT> ( ( <STRING> , <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'git'", "'config'", "'branch.working.rietveldissue'", "'12345'", "'git'", "'config'", "'branch.working.rietveldserver'", "'codereview.example.com'", "'GitClHooksBypassedCommit'", "'Issue https://codereview.example.com/12345 bypassed hook when '"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["a043a6b64d47b7c2d600ba2419215d7c", {"code_string": "def test_page_creation_rev_doc():\n    extractor = Extractor(mwapi.Session(\"foobar\"))\n    page_creation_rev_doc = PageCreationRevDoc(ro.revision.page, extractor)\n    hash(page_creation_rev_doc)\n    eq_(pickle.loads(pickle.dumps(page_creation_rev_doc),\n        page_creation_rev_doc)\n", "code_toks_joined": "def test_page_creation_rev_doc ( ) : <NEWLINE> <INDENT> extractor = Extractor ( mwapi . Session ( <STRING> ) ) <NEWLINE> page_creation_rev_doc = PageCreationRevDoc ( ro . revision . page , extractor ) <NEWLINE> hash ( page_creation_rev_doc ) <NEWLINE> eq_ ( pickle . loads ( pickle . dumps ( page_creation_rev_doc ) , <NEWLINE> <INDENT> page_creation_rev_doc ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"foobar\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["01673748edff3497353cbf4830d118ba", {"code_string": "class Anca:\n    event died(when)\n    def kill(self, time):\n        return self.died(time)\n", "code_toks_joined": "class Anca : <NEWLINE> <INDENT> event died ( when ) <NEWLINE> def kill ( self , time ) : <NEWLINE> <INDENT> return self . died ( time ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["e5a8cfea91a0815d9e85fc9c405f0e22", {"code_string": "def create(self, block_code, block_level = False):\n    \"\"\"Function to retrieve or create a question block\"\"\"\n        return_var = None\n    logger.info(\"\"\"def create():\"\"\" + str(block_code) + \"\"\"block_level=\"\"\" + str(block_level) + \"\"\"\"\"\")\n        try:\n            return_var = self.get_by_block_code(block_code = block_code)\n        except QuestionBlock.DoesNotExist:\n            if block_code and block_level:\n                QuestionBlock_obj = QuestionBlock()\n                QuestionBlock_obj.block_code = block_code\n                QuestionBlock_obj.block_level = block_level\n                QuestionBlock_obj.save()\n                return_var = QuestionBlock_obj\n        return return_var\n", "code_toks_joined": "def create ( self , block_code , block_level = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> return_var = None <NEWLINE> <DEDENT> logger . info ( <STRING> + str ( block_code ) + <STRING> + str ( block_level ) + <STRING> ) <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return_var = self . get_by_block_code ( block_code = block_code ) <NEWLINE> <DEDENT> except QuestionBlock . DoesNotExist : <NEWLINE> <INDENT> if block_code and block_level : <NEWLINE> <INDENT> QuestionBlock_obj = QuestionBlock ( ) <NEWLINE> QuestionBlock_obj . block_code = block_code <NEWLINE> QuestionBlock_obj . block_level = block_level <NEWLINE> QuestionBlock_obj . save ( ) <NEWLINE> return_var = QuestionBlock_obj <NEWLINE> <DEDENT> <DEDENT> return return_var <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Function to retrieve or create a question block\"\"\"", "\"\"\"def create():\"\"\"", "\"\"\"block_level=\"\"\"", "\"\"\"\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["de0bb836b7dcaae8b8b92952e925fd98", {"code_string": "def test_update_endpoint_enabled_str_random(self):\n    \"\"\"Call ``PATCH /endpoints/{endpoint_id}`` with enabled: 'kitties'.\"\"\"\n    self.patch(\n        '/endpoints/%(endpoint_id)s' %{\n            'endpoint_id': self.endpoint_id},\n        body = {'endpoint': {'enabled': 'kitties'},\n        expected_status = http_client.BAD_REQUEST)\n", "code_toks_joined": "def test_update_endpoint_enabled_str_random ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . patch ( <NEWLINE> <INDENT> <STRING> % { <NEWLINE> <INDENT> <STRING> : self . endpoint_id } , <NEWLINE> <DEDENT> body = { <STRING> : { <STRING> : <STRING> } , <NEWLINE> expected_status = http_client . BAD_REQUEST ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Call ``PATCH /endpoints/{endpoint_id}`` with enabled: 'kitties'.\"\"\"", "'/endpoints/%(endpoint_id)s'", "'endpoint_id'", "'endpoint'", "'enabled'", "'kitties'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["875f29ad02e41347ed465969caa36472", {"code_string": "from.command import RbxComponentSetCommandAction\nfrom.volume import RbxComponentSetVolumeAction\nfrom.image import RbxComponentSetImageAction\nfrom.port import RbxComponentSetPortAction\nclass RbxComponentSetAction(RbxComponentSetPortAction,\n    RbxComponentSetVolumeAction,\n    RbxComponentSetCommandAction,\n    RbxComponentSetImageAction):\n    def do_action_set(self):\n    getattr(self, 'do_set_{0}'.format(self.params.configurator))()\n", "code_toks_joined": "from . command import RbxComponentSetCommandAction <NEWLINE> from . volume import RbxComponentSetVolumeAction <NEWLINE> from . image import RbxComponentSetImageAction <NEWLINE> from . port import RbxComponentSetPortAction <NEWLINE> class RbxComponentSetAction ( RbxComponentSetPortAction , <NEWLINE> <INDENT> RbxComponentSetVolumeAction , <NEWLINE> RbxComponentSetCommandAction , <NEWLINE> RbxComponentSetImageAction ) : <NEWLINE> def do_action_set ( self ) : <NEWLINE> getattr ( self , <STRING> . format ( self . params . configurator ) ) ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'do_set_{0}'"]}, "err_obj": {"msg": "expected an indented block"}}], ["a4462827ae06d8ad03ae22372c09095e", {"code_string": "def strip_bom(data):\n    \"\"\"Strip the BOM (byte order mark) from byte string `data`.\"\"\"\n    for bom in(codecs.BOM_UTF32_BE,\n        codecs.BOM_UTF32_LE,\n        codecs.BOM_UTF16_BE,\n        codecs.BOM_UTF16_LE,\n        codecs.BOM_UTF8):\n        if data.startswith(bom):\n        data = data[len(bom): ]\n        break\n    return data\n", "code_toks_joined": "def strip_bom ( data ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for bom in ( codecs . BOM_UTF32_BE , <NEWLINE> <INDENT> codecs . BOM_UTF32_LE , <NEWLINE> codecs . BOM_UTF16_BE , <NEWLINE> codecs . BOM_UTF16_LE , <NEWLINE> codecs . BOM_UTF8 ) : <NEWLINE> if data . startswith ( bom ) : <NEWLINE> data = data [ len ( bom ) : ] <NEWLINE> break <NEWLINE> <DEDENT> return data <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Strip the BOM (byte order mark) from byte string `data`.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["047e00ce1825a203ecffe0487be50602", {"code_string": "def create_voucher(self, ** kw):\n    \"\"\"Create an instance of this Journal's voucher model (:meth:`get_doc_model`).\"\"\"\n    cl = self.get_doc_model()\n    kw.update(journal = self)\n    try:\n        doc = cl()\n        for k, v in kw.items():\n            setattr(doc, k, v)\n    except TypeError, e:\n        raise\n    doc.on_create(None)\n    return doc\n", "code_toks_joined": "def create_voucher ( self , ** kw ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> cl = self . get_doc_model ( ) <NEWLINE> kw . update ( journal = self ) <NEWLINE> try : <NEWLINE> <INDENT> doc = cl ( ) <NEWLINE> for k , v in kw . items ( ) : <NEWLINE> <INDENT> setattr ( doc , k , v ) <NEWLINE> <DEDENT> <DEDENT> except TypeError , e : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> doc . on_create ( None ) <NEWLINE> return doc <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Create an instance of this Journal's voucher model (:meth:`get_doc_model`).\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["b0d3ad2da253416f3bfb34c6ffb724c4", {"code_string": "def open(self, pathobj):\n    \"\"\"Opens the remote file and returns a file-like object HTTPResponse\"\"\"\n    url = str(pathobj)\n    raw, code = self.rest_get_stream(url, auth = pathobj.auth, verify = pathobj.verify\n        cert = pathobj.cert)\n    if not code == 200:\n        raise RuntimeError(\"%d\" % code)\n    return raw\n", "code_toks_joined": "def open ( self , pathobj ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> url = str ( pathobj ) <NEWLINE> raw , code = self . rest_get_stream ( url , auth = pathobj . auth , verify = pathobj . verify <NEWLINE> <INDENT> cert = pathobj . cert ) <NEWLINE> <DEDENT> if not code == 200 : <NEWLINE> <INDENT> raise RuntimeError ( <STRING> % code ) <NEWLINE> <DEDENT> return raw <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Opens the remote file and returns a file-like object HTTPResponse\"\"\"", "\"%d\""]}, "err_obj": {"msg": "invalid syntax"}}], ["569a92853084d6dac315bee9b076e99f", {"code_string": "def retranslateUi(self, MainWindow):\n    MainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\", None))\n    self.widgetFrameOuter.setProperty(\"class\", _translate(\"MainWindow\", \"PeripheralCollection\", None))\n    self.resistanceInductor.setToolTip(_translate(\"MainWindow\", \"The Voltage drop measured across the inductor is a function of\\n\"\n", "code_toks_joined": "def retranslateUi ( self , MainWindow ) : <NEWLINE> <INDENT> MainWindow . setWindowTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . widgetFrameOuter . setProperty ( <STRING> , _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . resistanceInductor . setToolTip ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"MainWindow\"", "\"MainWindow\"", "\"class\"", "\"MainWindow\"", "\"PeripheralCollection\"", "\"MainWindow\"", "\"The Voltage drop measured across the inductor is a function of\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["03b6be2510646423d1afb5bad5fb705a", {"code_string": "def IsActiveOn(self, date, date_object = None):\n    \"\"\"Test if this service period is active on a date.\"\"\"\n    if date in self.date_exceptions:\n        exception_type, _ = self.date_exceptions[date]\n        if exception_type == self._EXCEPTION_TYPE_ADD:\n            return True\n        else:\n            return False\n    if(self.start_date and self.end_date and self.start_date <= date and\n        date <= self.end_date):\n        if date_object is None:\n        date_object = util.DateStringToDateObject(date)\n        return self.day_of_week[date_object.weekday()]\n    return False\n", "code_toks_joined": "def IsActiveOn ( self , date , date_object = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if date in self . date_exceptions : <NEWLINE> <INDENT> exception_type , _ = self . date_exceptions [ date ] <NEWLINE> if exception_type == self . _EXCEPTION_TYPE_ADD : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> if ( self . start_date and self . end_date and self . start_date <= date and <NEWLINE> <INDENT> date <= self . end_date ) : <NEWLINE> if date_object is None : <NEWLINE> date_object = util . DateStringToDateObject ( date ) <NEWLINE> return self . day_of_week [ date_object . weekday ( ) ] <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Test if this service period is active on a date.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["812dc8ea3ddd5cd7566f6ab9ae40d43d", {"code_string": "def dash_sidebar_modules(request):\n    signals_call = signals.dash_modules_detect()\n    if signals_call:\n        if signals_call[0][1]['type'] == \"dash\":\n            return{'modules': [module[1] for module in signals_call]\n                'request': request}\n    else:\n        return{}\n", "code_toks_joined": "def dash_sidebar_modules ( request ) : <NEWLINE> <INDENT> signals_call = signals . dash_modules_detect ( ) <NEWLINE> if signals_call : <NEWLINE> <INDENT> if signals_call [ 0 ] [ 1 ] [ <STRING> ] == <STRING> : <NEWLINE> <INDENT> return { <STRING> : [ module [ 1 ] for module in signals_call ] <NEWLINE> <INDENT> <STRING> : request } <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return { } <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'type'", "\"dash\"", "'modules'", "'request'"]}, "err_obj": {"msg": "invalid syntax"}}], ["38c0327a5ff9d8a8e659b1502f40bdfb", {"code_string": "def testFormatPretty(self):\n    with mock.patch.object(oauth2l, '_FetchCredentials',\n        return_value = self.credentials,\n        autospec = True) as mock_credentials:\n        output = _GetCommandOutput('fetch', self._Args('pretty'))\n        expecteds = ['oauth2client.client.AccessTokenCredentials',\n        self.access_token]\n        for expected in expecteds:\n        self.assertIn(expected, output)\n        self.assertEqual(1, mock_credentials.call_count)\n", "code_toks_joined": "def testFormatPretty ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( oauth2l , <STRING> , <NEWLINE> <INDENT> return_value = self . credentials , <NEWLINE> autospec = True ) as mock_credentials : <NEWLINE> output = _GetCommandOutput ( <STRING> , self . _Args ( <STRING> ) ) <NEWLINE> expecteds = [ <STRING> , <NEWLINE> self . access_token ] <NEWLINE> for expected in expecteds : <NEWLINE> self . assertIn ( expected , output ) <NEWLINE> self . assertEqual ( 1 , mock_credentials . call_count ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'_FetchCredentials'", "'fetch'", "'pretty'", "'oauth2client.client.AccessTokenCredentials'"]}, "err_obj": {"msg": "expected an indented block"}}], ["e9e42aaa62a2b85200c543bff8e534a8", {"code_string": "def onPaint(self, evt):\n    dc = self.__getClientDC()\n        self.doPaint(dc)\n        evt.Skip()\n", "code_toks_joined": "def onPaint ( self , evt ) : <NEWLINE> <INDENT> dc = self . __getClientDC ( ) <NEWLINE> <INDENT> self . doPaint ( dc ) <NEWLINE> evt . Skip ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["2df230b5e662cc61e5b2b2748c60c427", {"code_string": "from django.conf.urls import patterns, include, url\nfrom django.contrib import admin\nadmin.autodiscover()\nurlpatterns = patterns('',\n    url(r'^admin/', include(admin.site.urls),\n)\n", "code_toks_joined": "from django . conf . urls import patterns , include , url <NEWLINE> from django . contrib import admin <NEWLINE> admin . autodiscover ( ) <NEWLINE> urlpatterns = patterns ( <STRING> , <NEWLINE> <INDENT> url ( <STRING> , include ( admin . site . urls ) , <NEWLINE> <DEDENT> ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["''", "r'^admin/'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["9dcbae8961850ea8f2147fa82f540ccd", {"code_string": "def ucsdJsonParser(text):\n    jsondict = None\n    if text:\n        try:\n        jsondict = json.loads(text)\n        except: pass\n        try:\n        jsondict = yaml.loads(text)\n        except: pass\n        try:\n        jsondict = demjson.decode(text)\n        except: pass\n    return jsondict\n", "code_toks_joined": "def ucsdJsonParser ( text ) : <NEWLINE> <INDENT> jsondict = None <NEWLINE> if text : <NEWLINE> <INDENT> try : <NEWLINE> jsondict = json . loads ( text ) <NEWLINE> except : pass <NEWLINE> try : <NEWLINE> jsondict = yaml . loads ( text ) <NEWLINE> except : pass <NEWLINE> try : <NEWLINE> jsondict = demjson . decode ( text ) <NEWLINE> except : pass <NEWLINE> <DEDENT> return jsondict <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["8d68e479c9df1691d1ca9650afa85d92", {"code_string": "def hostname_contains(pattern):\n    hostname = socket.gethostbyaddr(socket.gethostname()[0]\n    if re.search(pattern, hostname) == None:\n        return False\n    else:\n        return True\n", "code_toks_joined": "def hostname_contains ( pattern ) : <NEWLINE> <INDENT> hostname = socket . gethostbyaddr ( socket . gethostname ( ) [ 0 ] <NEWLINE> if re . search ( pattern , hostname ) == None : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["74902f2e2853f50ecea7bc4e9caa914b", {"code_string": "import os\nimport sys\nimport shutil\nimport os.path\nroot = r\"IGNORE_NYU\"\ncache = \"Cache\"\nfor dir, subdirs, files in os.walk(root, topdown = False):\n    if dir is not root:\n        continue\n    file_names = files\nfor file_name in file_names:\n    if '914' not in file_name:\n        continue;\n    file_name_no_ext = file_name.strip('\\n').replace('.pcd', '')\n    i_name = os.path.join(root, file_name_no_ext)\n    o_name = os.path.join(root, cache, file_name_no_ext)\n    commands = [\n    for cmd in commands:\n        print(cmd)\n        ret = os.system(cmd)\n        if ret != 0:\n            print('\\nFailed:' + cmd)\n            break\n", "code_toks_joined": "import os <NEWLINE> import sys <NEWLINE> import shutil <NEWLINE> import os . path <NEWLINE> root = <STRING> <NEWLINE> cache = <STRING> <NEWLINE> for dir , subdirs , files in os . walk ( root , topdown = False ) : <NEWLINE> <INDENT> if dir is not root : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> file_names = files <NEWLINE> <DEDENT> for file_name in file_names : <NEWLINE> <INDENT> if <STRING> not in file_name : <NEWLINE> <INDENT> continue ; <NEWLINE> <DEDENT> file_name_no_ext = file_name . strip ( <STRING> ) . replace ( <STRING> , <STRING> ) <NEWLINE> i_name = os . path . join ( root , file_name_no_ext ) <NEWLINE> o_name = os . path . join ( root , cache , file_name_no_ext ) <NEWLINE> commands = [ <NEWLINE> for cmd in commands : <NEWLINE> <INDENT> print ( cmd ) <NEWLINE> ret = os . system ( cmd ) <NEWLINE> if ret != 0 : <NEWLINE> <INDENT> print ( <STRING> + cmd ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["r\"IGNORE_NYU\"", "\"Cache\"", "'914'", "'\\n'", "'.pcd'", "''", "'\\nFailed:'"]}, "window_span": [123, 165], "err_obj": {"msg": "unbalanced (){}[]"}}], ["df04c94d8faf524d694359b31e404627", {"code_string": "def getProcess():\n    fullsc = ImageGrab.grab()\n    saveProcess = fullsc.crop(Pcbox).save(wokingp + 'Process.jpg', 'JPEG')\n    picPc = open(wokingp + 'Process.jpg', 'rb')\n    Pmd5 = hashlib.md5(picPc.read()).hexdigest().upper()\n    picPc.close()\n    if Pmd5 != Pcmd5:\n    click(655, 770)\n    cNp()\n", "code_toks_joined": "def getProcess ( ) : <NEWLINE> <INDENT> fullsc = ImageGrab . grab ( ) <NEWLINE> saveProcess = fullsc . crop ( Pcbox ) . save ( wokingp + <STRING> , <STRING> ) <NEWLINE> picPc = open ( wokingp + <STRING> , <STRING> ) <NEWLINE> Pmd5 = hashlib . md5 ( picPc . read ( ) ) . hexdigest ( ) . upper ( ) <NEWLINE> picPc . close ( ) <NEWLINE> if Pmd5 != Pcmd5 : <NEWLINE> click ( 655 , 770 ) <NEWLINE> cNp ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Process.jpg'", "'JPEG'", "'Process.jpg'", "'rb'"]}, "err_obj": {"msg": "expected an indented block"}}], ["386a99569a8136bdc466b7c5e92e88e4", {"code_string": "class ChromeHistoryFileDownloadedEvent(time_events.TimestampEvent):\n    \"\"\"Convenience class for a Chrome History file downloaded event.\"\"\"\n    DATA_TYPE = u'chrome:history:file_downloaded'\n    def __init__(\n        self, timestamp, row_id, url, full_path, received_bytes, total_bytes):\n        \"\"\"Initializes the event object.\"\"\"\n        super(ChromeHistoryFileDownloadedEvent, self).__init__(\n            timestamp, eventdata.EventTimestamp.FILE_DOWNLOADED)\n            self.offset = row_id\n            self.url = url\n            self.full_path = full_path\n            self.received_bytes = received_bytes\n            self.total_bytes = total_bytes\n", "code_toks_joined": "class ChromeHistoryFileDownloadedEvent ( time_events . TimestampEvent ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> DATA_TYPE = <STRING> <NEWLINE> def __init__ ( <NEWLINE> <INDENT> self , timestamp , row_id , url , full_path , received_bytes , total_bytes ) : <NEWLINE> <STRING> <NEWLINE> super ( ChromeHistoryFileDownloadedEvent , self ) . __init__ ( <NEWLINE> <INDENT> timestamp , eventdata . EventTimestamp . FILE_DOWNLOADED ) <NEWLINE> self . offset = row_id <NEWLINE> self . url = url <NEWLINE> self . full_path = full_path <NEWLINE> self . received_bytes = received_bytes <NEWLINE> self . total_bytes = total_bytes <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Convenience class for a Chrome History file downloaded event.\"\"\"", "u'chrome:history:file_downloaded'", "\"\"\"Initializes the event object.\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["20360c1f77a6233c056267217cdbc3ef", {"code_string": "def get(self, id):\n    {resource} _query = {Resources}.query.get_or_404(id)\n    result = schema.dump({resource} _query).data\n    return result\n", "code_toks_joined": "def get ( self , id ) : <NEWLINE> <INDENT> { resource } _query = { Resources } . query . get_or_404 ( id ) <NEWLINE> result = schema . dump ( { resource } _query ) . data <NEWLINE> return result <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["cb92168de9ce11a203cd8e441a3af4e3", {"code_string": "def skip_checks(cls):\n    super(TestGettingAddress, cls).skip_checks()\n    if not(CONF.network_feature_enabled.ipv6\n        and CONF.network_feature_enabled.ipv6_subnet_attributes):\n        raise cls.skipException('IPv6 or its attributes not supported')\n    if not(CONF.network.tenant_networks_reachable\n        or CONF.network.public_network_id):\n        msg = ('Either tenant_networks_reachable must be \"true\", or '\n            'public_network_id must be defined.')\n            raise cls.skipException(msg)\n    if CONF.baremetal.driver_enabled:\n        msg = ('Baremetal does not currently support network isolation')\n        raise cls.skipException(msg)\n", "code_toks_joined": "def skip_checks ( cls ) : <NEWLINE> <INDENT> super ( TestGettingAddress , cls ) . skip_checks ( ) <NEWLINE> if not ( CONF . network_feature_enabled . ipv6 <NEWLINE> <INDENT> and CONF . network_feature_enabled . ipv6_subnet_attributes ) : <NEWLINE> raise cls . skipException ( <STRING> ) <NEWLINE> <DEDENT> if not ( CONF . network . tenant_networks_reachable <NEWLINE> <INDENT> or CONF . network . public_network_id ) : <NEWLINE> msg = ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> raise cls . skipException ( msg ) <NEWLINE> <DEDENT> <DEDENT> if CONF . baremetal . driver_enabled : <NEWLINE> <INDENT> msg = ( <STRING> ) <NEWLINE> raise cls . skipException ( msg ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'IPv6 or its attributes not supported'", "'Either tenant_networks_reachable must be \"true\", or '", "'public_network_id must be defined.'", "'Baremetal does not currently support network isolation'"]}, "err_obj": {"msg": "unexpected indent"}}], ["406910f3b93fb1ec0162a86dc3ba0606", {"code_string": "def retranslateUi(self, Dialog):\n    Dialog.setWindowTitle(_translate(\"Dialog\", \"About FlacTag\", None))\n    self.flactagBrowser.setHtml(_translate(\"Dialog\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , Dialog ) : <NEWLINE> <INDENT> Dialog . setWindowTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . flactagBrowser . setHtml ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Dialog\"", "\"About FlacTag\"", "\"Dialog\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["069283220f5ca1d554daff305788a213", {"code_string": "class Field:\n    def __init__(self, (x, y, z), radius):\n        self.coords = (x, y, z)\n        self.radius = radius\n", "code_toks_joined": "class Field : <NEWLINE> <INDENT> def __init__ ( self , ( x , y , z ) , radius ) : <NEWLINE> <INDENT> self . coords = ( x , y , z ) <NEWLINE> self . radius = radius <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["aa6aaaf3db0d00c99449440d6b883618", {"code_string": "def build_bound_meth(ctx, name, sig):\n    def method(self, * args, ** kw):\n        adom, bdom = sig.dom[0], sig.dom[1: ]\n        saturated = len(bdom) == len(args)\n        if saturated:\n            outsig = instantiate(ctx, sig)\n            return Proxy(outsig)\n        else:\n            raise TypeError, '%s, expected %i arguments, got %i' %(name, len(sig.dom), len(args) + 1)\n    return method\n", "code_toks_joined": "def build_bound_meth ( ctx , name , sig ) : <NEWLINE> <INDENT> def method ( self , * args , ** kw ) : <NEWLINE> <INDENT> adom , bdom = sig . dom [ 0 ] , sig . dom [ 1 : ] <NEWLINE> saturated = len ( bdom ) == len ( args ) <NEWLINE> if saturated : <NEWLINE> <INDENT> outsig = instantiate ( ctx , sig ) <NEWLINE> return Proxy ( outsig ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise TypeError , <STRING> % ( name , len ( sig . dom ) , len ( args ) + 1 ) <NEWLINE> <DEDENT> <DEDENT> return method <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'%s, expected %i arguments, got %i'"]}, "err_obj": {"msg": "invalid syntax"}}], ["a04265f5b488f31c09576b83b298ffe6", {"code_string": "def onClose(self, widget, action, data):\n    self.hide()\n        def onHighlightMenu(self, widget, action, data):\n            self.eventPopup.show()\n", "code_toks_joined": "def onClose ( self , widget , action , data ) : <NEWLINE> <INDENT> self . hide ( ) <NEWLINE> <INDENT> def onHighlightMenu ( self , widget , action , data ) : <NEWLINE> <INDENT> self . eventPopup . show ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["7b87e1399fed500d2a28a9339ebcc1df", {"code_string": "def get_current_user():\n    try:\n        return jsonify({\"id\": session['athlete_id']\n            \"name\": session['athlete_name']})\n    except KeyError:\n        abort(404)\n", "code_toks_joined": "def get_current_user ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return jsonify ( { <STRING> : session [ <STRING> ] <NEWLINE> <INDENT> <STRING> : session [ <STRING> ] } ) <NEWLINE> <DEDENT> <DEDENT> except KeyError : <NEWLINE> <INDENT> abort ( 404 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"id\"", "'athlete_id'", "\"name\"", "'athlete_name'"]}, "err_obj": {"msg": "invalid syntax"}}], ["7ff14d3b34c95f62b4f9ac8d3891613e", {"code_string": "def Ungroup(self):\n    objects = []\n    for obj in self.objects:\n        if obj.__class__ is BlendInterpolation:\n        objects.append(obj.AsGroup())\n        else:\n        objects.append(obj)\n    return objects\n", "code_toks_joined": "def Ungroup ( self ) : <NEWLINE> <INDENT> objects = [ ] <NEWLINE> for obj in self . objects : <NEWLINE> <INDENT> if obj . __class__ is BlendInterpolation : <NEWLINE> objects . append ( obj . AsGroup ( ) ) <NEWLINE> else : <NEWLINE> objects . append ( obj ) <NEWLINE> <DEDENT> return objects <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["759920dec6993b34b12cfa3e0a21f69c", {"code_string": "def load_bytecode(self, f):\n    \"\"\"Loads bytecode from a file or file like object.\"\"\"\n    magic = f.read(len(bc_magic)\n    if magic != bc_magic:\n        self.reset()\n        return\n    checksum = pickle.load(f)\n    if self.checksum != checksum:\n        self.reset()\n        return\n    self.code = marshal_load(f)\n", "code_toks_joined": "def load_bytecode ( self , f ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> magic = f . read ( len ( bc_magic ) <NEWLINE> if magic != bc_magic : <NEWLINE> <INDENT> self . reset ( ) <NEWLINE> return <NEWLINE> <DEDENT> checksum = pickle . load ( f ) <NEWLINE> if self . checksum != checksum : <NEWLINE> <INDENT> self . reset ( ) <NEWLINE> return <NEWLINE> <DEDENT> self . code = marshal_load ( f ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Loads bytecode from a file or file like object.\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["0cb16785a25ae9c22ee575795bc521a6", {"code_string": "def import_credential(self, file = None, data = None):\n    if data:\n        if self.context.load_id_chunk(data) != ABAC.ABAC_CERT_SUCCESS:\n        return self.context.load_attribute_chunk(data) == ABAC.ABAC_CERT_SUCCESS\n        else:\n        return True\n    elif file:\n        if self.context.load_id_file(file) != ABAC.ABAC_CERT_SUCCESS:\n        return self.context.load_attribute_file(file) == ABAC.ABAC_CERT_SUCCESS\n        else:\n        return True\n    else:\n        return False\n", "code_toks_joined": "def import_credential ( self , file = None , data = None ) : <NEWLINE> <INDENT> if data : <NEWLINE> <INDENT> if self . context . load_id_chunk ( data ) != ABAC . ABAC_CERT_SUCCESS : <NEWLINE> return self . context . load_attribute_chunk ( data ) == ABAC . ABAC_CERT_SUCCESS <NEWLINE> else : <NEWLINE> return True <NEWLINE> <DEDENT> elif file : <NEWLINE> <INDENT> if self . context . load_id_file ( file ) != ABAC . ABAC_CERT_SUCCESS : <NEWLINE> return self . context . load_attribute_file ( file ) == ABAC . ABAC_CERT_SUCCESS <NEWLINE> else : <NEWLINE> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["acc65c8df88a4be57cbecb60ad69dc20", {"code_string": "def rax_find_volume(module, rax_module, name):\n    \"\"\"Find a Block storage volume by ID or name\"\"\"\n    cbs = rax_module.cloud_blockstorage\n    try:\n        UUID(name)\n        volume = cbs.get(name)\n    except ValueError:\n        try:\n            volume = cbs.find(name = name)\n        except rax_module.exc.NotFound:\n            volume = None\n        except Exception, e:\n            module.fail_json(msg = '%s' % e)\n    return volume\n", "code_toks_joined": "def rax_find_volume ( module , rax_module , name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> cbs = rax_module . cloud_blockstorage <NEWLINE> try : <NEWLINE> <INDENT> UUID ( name ) <NEWLINE> volume = cbs . get ( name ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> volume = cbs . find ( name = name ) <NEWLINE> <DEDENT> except rax_module . exc . NotFound : <NEWLINE> <INDENT> volume = None <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> module . fail_json ( msg = <STRING> % e ) <NEWLINE> <DEDENT> <DEDENT> return volume <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Find a Block storage volume by ID or name\"\"\"", "'%s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["d22179accde3d63f0d932a5a53a816ad", {"code_string": "def parse_BL(self, indent):\n    i = 0\n    while self.parse_BI_helper(indent): i = i + 1\n    if i == 0: print \"Error\", sys.exit(1)\n    self.reduce(BL, i, indent)\n", "code_toks_joined": "def parse_BL ( self , indent ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> while self . parse_BI_helper ( indent ) : i = i + 1 <NEWLINE> if i == 0 : print <STRING> , sys . exit ( 1 ) <NEWLINE> self . reduce ( BL , i , indent ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Error\""]}, "err_obj": {"msg": "invalid syntax"}}], ["8fee9e8641cd6c7bcf1919e653b0f40c", {"code_string": "def pomfremember(inp, chan = None, nick = None, say = None, db = None, adminonly = True):\n    \"pomfremember <word> <url> -- Downloads file, uploads it and adds it to the dictionary\"\n        word, url = inp.split(None, 1)\n    pomfurl = upload(url)\n    strsave = \"{} {}\".format(word, pomfurl)\n    hashtags.remember(strsave, nick, db)\n    return(formatting.output('pomf', ['{} remembered as {}'.format(word, pomfurl)]))\n", "code_toks_joined": "def pomfremember ( inp , chan = None , nick = None , say = None , db = None , adminonly = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> word , url = inp . split ( None , 1 ) <NEWLINE> <DEDENT> pomfurl = upload ( url ) <NEWLINE> strsave = <STRING> . format ( word , pomfurl ) <NEWLINE> hashtags . remember ( strsave , nick , db ) <NEWLINE> return ( formatting . output ( <STRING> , [ <STRING> . format ( word , pomfurl ) ] ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"pomfremember <word> <url> -- Downloads file, uploads it and adds it to the dictionary\"", "\"{} {}\"", "'pomf'", "'{} remembered as {}'"]}, "err_obj": {"msg": "unexpected indent"}}], ["23ce30de437d7391567cd1329db68a34", {"code_string": "class Solution(object):\n    def bulbSwitch(self, n):\n        \"\"\":type n: int\"\"\"\n        return int(math.sqrt(n)\n", "code_toks_joined": "class Solution ( object ) : <NEWLINE> <INDENT> def bulbSwitch ( self , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return int ( math . sqrt ( n ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\":type n: int\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["06b62db3d9cb941f9409a26914bdfb36", {"code_string": "def cumulative_sma(cls, a_bar, series, prevma):\n    \"\"\"Returns the cumulative or unweighted simple moving average.\"\"\"\n    if a_bar[0] <= 0:\n    return series[0]\n    else:\n    return prevma +((series[a_bar[0]] - prevma) /(a_bar[0] + 1.0))\n", "code_toks_joined": "def cumulative_sma ( cls , a_bar , series , prevma ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if a_bar [ 0 ] <= 0 : <NEWLINE> return series [ 0 ] <NEWLINE> else : <NEWLINE> return prevma + ( ( series [ a_bar [ 0 ] ] - prevma ) / ( a_bar [ 0 ] + 1.0 ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns the cumulative or unweighted simple moving average.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["a3268918713af72762e88c70afe4025b", {"code_string": "def startElementNS(self, name, qname, attr):\n    print(\"QNAME: \", qname)\n    print(\"NAME: \", name)\n    uri, elem = name\n    if(elem == \"bot\"): print \"name: \", attr.getValueByQName(\"name\"), \"a'ite?\"\n    self.startElement(elem, attr)\n    pass\n", "code_toks_joined": "def startElementNS ( self , name , qname , attr ) : <NEWLINE> <INDENT> print ( <STRING> , qname ) <NEWLINE> print ( <STRING> , name ) <NEWLINE> uri , elem = name <NEWLINE> if ( elem == <STRING> ) : print <STRING> , attr . getValueByQName ( <STRING> ) , <STRING> <NEWLINE> self . startElement ( elem , attr ) <NEWLINE> pass <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"QNAME: \"", "\"NAME: \"", "\"bot\"", "\"name: \"", "\"name\"", "\"a'ite?\""]}, "err_obj": {"msg": "invalid syntax"}}], ["0cd5e4a5137c10c6d707a853fe248d0b", {"code_string": "def IndentLevel(by = 1):\n    \"\"\"Increment the indentation level by one.\"\"\"\n    global _Level\n    if _Level + by < 0:\n        raise Error, \"indentation underflow (internal error)\"\n    _Level = _Level + by\n", "code_toks_joined": "def IndentLevel ( by = 1 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> global _Level <NEWLINE> if _Level + by < 0 : <NEWLINE> <INDENT> raise Error , <STRING> <NEWLINE> <DEDENT> _Level = _Level + by <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Increment the indentation level by one.\"\"\"", "\"indentation underflow (internal error)\""]}, "err_obj": {"msg": "invalid syntax"}}], ["105e397cc8a2322a2a66779f082effc0", {"code_string": "class Label(Widget):\n    def setText(self, text):\n    self.w.labelText(text)\n    def __init__(self, text):\n    self.w = _snack.label(text)\n", "code_toks_joined": "class Label ( Widget ) : <NEWLINE> <INDENT> def setText ( self , text ) : <NEWLINE> self . w . labelText ( text ) <NEWLINE> def __init__ ( self , text ) : <NEWLINE> self . w = _snack . label ( text ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["f20c03000521f9ae20981312e6e688ce", {"code_string": "def get_nodes_with_slivers(xml, filter = {}):\n    xpath = '//rspec/network/node'\n        node_elems = xml.xpath(xpath)\n    if not node_elems:\n        node_elems = xml.xpath('//RSpec/network/node')\n            return OcfVtNode.get_node_objs(node_elems)\n", "code_toks_joined": "def get_nodes_with_slivers ( xml , filter = { } ) : <NEWLINE> <INDENT> xpath = <STRING> <NEWLINE> <INDENT> node_elems = xml . xpath ( xpath ) <NEWLINE> <DEDENT> if not node_elems : <NEWLINE> <INDENT> node_elems = xml . xpath ( <STRING> ) <NEWLINE> <INDENT> return OcfVtNode . get_node_objs ( node_elems ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'//rspec/network/node'", "'//RSpec/network/node'"]}, "err_obj": {"msg": "unexpected indent"}}], ["b7dcb7ca54243f2a21d5781d932667fc", {"code_string": "def test_monary_count1(self):\n    with self.assertRaisesRegexp(\n        monary.monary.MonaryError,\n        \"Invalid ns\"):\n        with monary.Monary() as m:\n        m.query(\"\", \"collection\", {},\n            [\"x1\", \"x2\", \"x3\", \"x4\", \"x5\"], [\"float64\"] * 5)\n", "code_toks_joined": "def test_monary_count1 ( self ) : <NEWLINE> <INDENT> with self . assertRaisesRegexp ( <NEWLINE> <INDENT> monary . monary . MonaryError , <NEWLINE> <STRING> ) : <NEWLINE> with monary . Monary ( ) as m : <NEWLINE> m . query ( <STRING> , <STRING> , { } , <NEWLINE> <INDENT> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , [ <STRING> ] * 5 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Invalid ns\"", "\"\"", "\"collection\"", "\"x1\"", "\"x2\"", "\"x3\"", "\"x4\"", "\"x5\"", "\"float64\""]}, "err_obj": {"msg": "expected an indented block"}}], ["9772a22fa832bdcb66c57bcf1f2d2c22", {"code_string": "def autocomplete_light_data_attributes(attributes, prefix = ''):\n    html = []\n    for key, value in attributes.items()\n        html.append('data-%s%s=\"%s\"' %(prefix, key.replace('_', '-'), value))\n    return safestring.mark_safe(u' '.join(html))\n", "code_toks_joined": "def autocomplete_light_data_attributes ( attributes , prefix = <STRING> ) : <NEWLINE> <INDENT> html = [ ] <NEWLINE> for key , value in attributes . items ( ) <NEWLINE> <INDENT> html . append ( <STRING> % ( prefix , key . replace ( <STRING> , <STRING> ) , value ) ) <NEWLINE> <DEDENT> return safestring . mark_safe ( <STRING> . join ( html ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "'data-%s%s=\"%s\"'", "'_'", "'-'", "u' '"]}, "err_obj": {"msg": "invalid syntax"}}], ["25823cce580daf7992c2143a43ee30f2", {"code_string": "def identifies(id, schema, table, alias)\n    return id == alias or id == table or(\n        schema and(id == schema + '.' + table))\n", "code_toks_joined": "def identifies ( id , schema , table , alias ) <NEWLINE> <INDENT> return id == alias or id == table or ( <NEWLINE> <INDENT> schema and ( id == schema + <STRING> + table ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'.'"]}, "err_obj": {"msg": "invalid syntax"}}], ["a16cab66cb509a9709fc14e3bf8ebe1a", {"code_string": "def save_connections(self, output_dir):\n    \"\"\"Saves generated connections to output directory\"\"\"\n    for conn_grp in self.connection_groups.itervalues():\n        if isinstance(conn_grp.synapse_type\n            pyNN.standardmodels.synapses.ElectricalSynapse):\n            attributes = 'weight'\n        else:\n            attributes = 'all'\n        conn_grp.save(attributes, os.path.join(\n            output_dir, conn_grp.label + '.proj'), format = 'list',\n            gather = True)\n", "code_toks_joined": "def save_connections ( self , output_dir ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for conn_grp in self . connection_groups . itervalues ( ) : <NEWLINE> <INDENT> if isinstance ( conn_grp . synapse_type <NEWLINE> <INDENT> pyNN . standardmodels . synapses . ElectricalSynapse ) : <NEWLINE> attributes = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> attributes = <STRING> <NEWLINE> <DEDENT> conn_grp . save ( attributes , os . path . join ( <NEWLINE> <INDENT> output_dir , conn_grp . label + <STRING> ) , format = <STRING> , <NEWLINE> gather = True ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Saves generated connections to output directory\"\"\"", "'weight'", "'all'", "'.proj'", "'list'"]}, "err_obj": {"msg": "invalid syntax"}}], ["be49d8f9f077cf585737eb75c0e745ee", {"code_string": "def checkParameter(self, Id, (class_id, parameter_id)):\n    \"\"\"verifica che il parametro (class_id,parameter_id) sia presente per il pv Id\"\"\"\n    for p in self.session.query(rel_pv_par).filter_by(pv_id = Id).filter_by(tc_clpar_id = class_id).filter_by(tc_par_id = parameter_id):\n        return True\n    return False\n", "code_toks_joined": "def checkParameter ( self , Id , ( class_id , parameter_id ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for p in self . session . query ( rel_pv_par ) . filter_by ( pv_id = Id ) . filter_by ( tc_clpar_id = class_id ) . filter_by ( tc_par_id = parameter_id ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"verifica che il parametro (class_id,parameter_id) sia presente per il pv Id\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["e700b5575260cd1f5f61a497629ff34e", {"code_string": "def usage():\n    print(\"Options:\")\n        print(\"    -h                Show help\")\n        print(\"    -d                Dump mode, don't plot\")\n        print(\"    -i <input_file>   Input file\")\n        print(\"    -t <seconds>      Step time (default 0.1)\")\n        print(\"    -l <number>       Iterations to show (default 10)\")\n        print(\"Syntax: $ python2 plot-orca.py -i <input-file>\")\n        sys.exit(1)\n", "code_toks_joined": "def usage ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Options:\"", "\"    -h                Show help\"", "\"    -d                Dump mode, don't plot\"", "\"    -i <input_file>   Input file\"", "\"    -t <seconds>      Step time (default 0.1)\"", "\"    -l <number>       Iterations to show (default 10)\"", "\"Syntax: $ python2 plot-orca.py -i <input-file>\""]}, "err_obj": {"msg": "unexpected indent"}}], ["b3a974d4009f949669852fc88a480c7a", {"code_string": "def _handle_process_end(pid, condition, (myself, stderr)):\n    myself._running = False\n    if os.WIFEXITED(condition) and os.WEXITSTATUS(condition) == 0:\n        myself.emit('process-management-finished')\n    else:\n        myself._notify_error(stderr)\n", "code_toks_joined": "def _handle_process_end ( pid , condition , ( myself , stderr ) ) : <NEWLINE> <INDENT> myself . _running = False <NEWLINE> if os . WIFEXITED ( condition ) and os . WEXITSTATUS ( condition ) == 0 : <NEWLINE> <INDENT> myself . emit ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> myself . _notify_error ( stderr ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'process-management-finished'"]}, "err_obj": {"msg": "invalid syntax"}}], ["ea7c59071b1f4533b8708e6795410024", {"code_string": "def get_repos(path):\n    \"\"\"Returns list of found branches.\"\"\"\n    p = str(path)\n    ret = []\n    if not os.path.exists(p):\n        return ret\n    for d in os.listdir(p):\n        pd = os.path.join(p, d)\n        if os.path.exists(pd) and is_repo(pd):\n            ret.append(Local(pd)\n    return ret\n", "code_toks_joined": "def get_repos ( path ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> p = str ( path ) <NEWLINE> ret = [ ] <NEWLINE> if not os . path . exists ( p ) : <NEWLINE> <INDENT> return ret <NEWLINE> <DEDENT> for d in os . listdir ( p ) : <NEWLINE> <INDENT> pd = os . path . join ( p , d ) <NEWLINE> if os . path . exists ( pd ) and is_repo ( pd ) : <NEWLINE> <INDENT> ret . append ( Local ( pd ) <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns list of found branches.\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["61ac1f24bf7dd6d6a834020205dbe928", {"code_string": "def IsHighStaff(user):\n    if conf[\"HighStaffPermID\"] == \"0\":\n        HighStaff = config[\"HighStaff\"].split(\",\")\n    else:\n        HighStaff = GetHighStaff()\n    if user in HighStaff:\n    return True\n    else:\n    return False\n", "code_toks_joined": "def IsHighStaff ( user ) : <NEWLINE> <INDENT> if conf [ <STRING> ] == <STRING> : <NEWLINE> <INDENT> HighStaff = config [ <STRING> ] . split ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> HighStaff = GetHighStaff ( ) <NEWLINE> <DEDENT> if user in HighStaff : <NEWLINE> return True <NEWLINE> else : <NEWLINE> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"HighStaffPermID\"", "\"0\"", "\"HighStaff\"", "\",\""]}, "err_obj": {"msg": "expected an indented block"}}], ["bdbb16182351b45f135a70eee857b802", {"code_string": "def load_game(filepath):\n    global gamedata\n    if gamedata._game is not None:\n        from gui.prompts import QuitPrompt\n        prompt = QuitPrompt((\"\"\"There is already a game in progress.\\nDo you wish to load a new game?\\n(Your progress will not be saved.)\"\"\")\n        if prompt.get_input() == True:\n            _do_loading_stuff(filepath)\n    else: _do_loading_stuff(filepath)\n", "code_toks_joined": "def load_game ( filepath ) : <NEWLINE> <INDENT> global gamedata <NEWLINE> if gamedata . _game is not None : <NEWLINE> <INDENT> from gui . prompts import QuitPrompt <NEWLINE> prompt = QuitPrompt ( ( <STRING> ) <NEWLINE> if prompt . get_input ( ) == True : <NEWLINE> <INDENT> _do_loading_stuff ( filepath ) <NEWLINE> <DEDENT> <DEDENT> else : _do_loading_stuff ( filepath ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"There is already a game in progress.\\nDo you wish to load a new game?\\n(Your progress will not be saved.)\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["fff712439f63ed93cca8fa5000e2f730", {"code_string": "def draw_rubberband(self, event, x0, y0, x1, y1):\n    height = self.canvas.figure.bbox.height\n    y1 = height - y1\n    y0 = height - y0\n    w = abs(x1 - x0)\n    h = abs(y1 - y0)\n    rect = [int(val) for val in min(x0, x1), min(y0, y1), w, h]\n    self.canvas.drawRectangle(rect)\n", "code_toks_joined": "def draw_rubberband ( self , event , x0 , y0 , x1 , y1 ) : <NEWLINE> <INDENT> height = self . canvas . figure . bbox . height <NEWLINE> y1 = height - y1 <NEWLINE> y0 = height - y0 <NEWLINE> w = abs ( x1 - x0 ) <NEWLINE> h = abs ( y1 - y0 ) <NEWLINE> rect = [ int ( val ) for val in min ( x0 , x1 ) , min ( y0 , y1 ) , w , h ] <NEWLINE> self . canvas . drawRectangle ( rect ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["e13851d2eaae2cd2ab616eef9392ac63", {"code_string": "def build_crop_image_directory(self, custom_crop_directory_name = None):\n    \"\"\"Function to build crop image directory\"\"\"\n    crop_image_directory = settings.MEDIA_ROOT + \"/\" + APP_BASE_DIRECTORY + CROPPED_IMG_DIRECTORY + custom_crop_directory_name + \"/\"\n        logger.debug(\"crop_image_directory: \" + str(crop_image_directory))\n    return crop_image_directory\n", "code_toks_joined": "def build_crop_image_directory ( self , custom_crop_directory_name = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> crop_image_directory = settings . MEDIA_ROOT + <STRING> + APP_BASE_DIRECTORY + CROPPED_IMG_DIRECTORY + custom_crop_directory_name + <STRING> <NEWLINE> <INDENT> logger . debug ( <STRING> + str ( crop_image_directory ) ) <NEWLINE> <DEDENT> return crop_image_directory <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Function to build crop image directory\"\"\"", "\"/\"", "\"/\"", "\"crop_image_directory: \""]}, "err_obj": {"msg": "unexpected indent"}}], ["594538aa33ae04fb6b2a9a682e5c55ba", {"code_string": "def status(self, args):\n    try:\n        self.connection.request('GET', route['status'][args])\n    except:\n        return(msg['-1'] %(host, port)\n    response = self.connection.getresponse()\n    return response.read()\n", "code_toks_joined": "def status ( self , args ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . connection . request ( <STRING> , route [ <STRING> ] [ args ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> return ( msg [ <STRING> ] % ( host , port ) <NEWLINE> <DEDENT> response = self . connection . getresponse ( ) <NEWLINE> return response . read ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'GET'", "'status'", "'-1'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["cfc4b0902e24df31d0005609712e2f22", {"code_string": "def test_save_config(self):\n    with mock.patch('neutron_lbaas.drivers.haproxy.'\n        'jinja_cfg.render_loadbalancer_obj') as r_t, mock.patch('neutron_lib.utils.file.replace_file') as replace:\n        r_t.return_value = 'fake_rendered_template'\n        lb = mock.Mock()\n        jinja_cfg.save_config('test_conf_path', lb, 'test_sock_path',\n            'nogroup',\n            'fake_state_path')\n            r_t.assert_called_once_with(lb,\n                'nogroup',\n                'test_sock_path',\n                'fake_state_path')\n                replace.assert_called_once_with('test_conf_path',\n                    'fake_rendered_template')\n", "code_toks_joined": "def test_save_config ( self ) : <NEWLINE> <INDENT> with mock . patch ( <STRING> <NEWLINE> <INDENT> <STRING> ) as r_t , mock . patch ( <STRING> ) as replace : <NEWLINE> r_t . return_value = <STRING> <NEWLINE> lb = mock . Mock ( ) <NEWLINE> jinja_cfg . save_config ( <STRING> , lb , <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ) <NEWLINE> r_t . assert_called_once_with ( lb , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ) <NEWLINE> replace . assert_called_once_with ( <STRING> , <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'neutron_lbaas.drivers.haproxy.'", "'jinja_cfg.render_loadbalancer_obj'", "'neutron_lib.utils.file.replace_file'", "'fake_rendered_template'", "'test_conf_path'", "'test_sock_path'", "'nogroup'", "'fake_state_path'", "'nogroup'", "'test_sock_path'", "'fake_state_path'", "'test_conf_path'", "'fake_rendered_template'"]}, "err_obj": {"msg": "unexpected indent"}}], ["e33eb71b8fcdd3aa9ffbaa5a552b144c", {"code_string": "def getInterestingBuildSteps(self, builder_name, build):\n    if(not self.good_revision_steps or\n        (builder_name in self.good_revision_steps and\n            not self.good_revision_steps[builder_name])):\n            if self.use_getname:\n        return[step.getName() for step in build.getSteps()]\n        else:\n        return[step.getText()[0] for step in build.getSteps()]\n    return self.good_revision_steps[builder_name]\n", "code_toks_joined": "def getInterestingBuildSteps ( self , builder_name , build ) : <NEWLINE> <INDENT> if ( not self . good_revision_steps or <NEWLINE> <INDENT> ( builder_name in self . good_revision_steps and <NEWLINE> <INDENT> not self . good_revision_steps [ builder_name ] ) ) : <NEWLINE> if self . use_getname : <NEWLINE> <DEDENT> return [ step . getName ( ) for step in build . getSteps ( ) ] <NEWLINE> else : <NEWLINE> return [ step . getText ( ) [ 0 ] for step in build . getSteps ( ) ] <NEWLINE> <DEDENT> return self . good_revision_steps [ builder_name ] <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unindent does not match any outer indentation level"}}], ["eed0f51f4a11aa5e20db79221396c058", {"code_string": "def check_store_validity(user_stores_controller, user_identifier, store_id):\n    for i in range(0, 15):\n        connected_store = user_stores_controller.user_stores_get_single_store(user_identifier, store_id);\n        if(connected_store is not None and(connected_store.result.scrape_status == \"Done\" or connected_store.result.scrape_status == \"DoneWithWarning\" or connected_store.result.scrape_status == \"Scraping\")):\n            if(connected_store.result.credentials_status == \"Verified\"):\n                return True\n            else\n                return False\n        time.sleep(3)\n    return False\n", "code_toks_joined": "def check_store_validity ( user_stores_controller , user_identifier , store_id ) : <NEWLINE> <INDENT> for i in range ( 0 , 15 ) : <NEWLINE> <INDENT> connected_store = user_stores_controller . user_stores_get_single_store ( user_identifier , store_id ) ; <NEWLINE> if ( connected_store is not None and ( connected_store . result . scrape_status == <STRING> or connected_store . result . scrape_status == <STRING> or connected_store . result . scrape_status == <STRING> ) ) : <NEWLINE> <INDENT> if ( connected_store . result . credentials_status == <STRING> ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> time . sleep ( 3 ) <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Done\"", "\"DoneWithWarning\"", "\"Scraping\"", "\"Verified\""]}, "err_obj": {"msg": "invalid syntax"}}], ["470ddc91b4a3bd3b2784cb10ca7765ac", {"code_string": "def test_effective_message(self update):\n    eff_message = update.effective_message\n    if not(update.inline_query is not None\n        or update.chosen_inline_result is not None\n        or(update.callback_query is not None\n            and update.callback_query.message is None)\n        or update.shipping_query is not None\n        or update.pre_checkout_query is not None):\n        assert eff_message.message_id == message.message_id\n    else:\n        assert eff_message is None\n", "code_toks_joined": "def test_effective_message ( self update ) : <NEWLINE> <INDENT> eff_message = update . effective_message <NEWLINE> if not ( update . inline_query is not None <NEWLINE> <INDENT> or update . chosen_inline_result is not None <NEWLINE> or ( update . callback_query is not None <NEWLINE> <INDENT> and update . callback_query . message is None ) <NEWLINE> <DEDENT> or update . shipping_query is not None <NEWLINE> or update . pre_checkout_query is not None ) : <NEWLINE> assert eff_message . message_id == message . message_id <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> assert eff_message is None <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["7b5a99e4a225a1c620e511010e23f5f4", {"code_string": "def _read_fmt_chunk(self, chunk):\n    wFormatTag, self._nchannels, self._framerate, dwAvgBytesPerSec, wBlockAlign = struct.unpack('<HHLLH', chunk.read(14))\n    if wFormatTag == WAVE_FORMAT_PCM:\n        sampwidth = struct.unpack('<H', chunk.read(2))[0]\n        self._sampwidth = (sampwidth + 7) // 8\n    else:\n        raise Error, 'unknown format: %r' %(wFormatTag, )\n    self._framesize = self._nchannels * self._sampwidth\n    self._comptype = 'NONE'\n    self._compname = 'not compressed'\n", "code_toks_joined": "def _read_fmt_chunk ( self , chunk ) : <NEWLINE> <INDENT> wFormatTag , self . _nchannels , self . _framerate , dwAvgBytesPerSec , wBlockAlign = struct . unpack ( <STRING> , chunk . read ( 14 ) ) <NEWLINE> if wFormatTag == WAVE_FORMAT_PCM : <NEWLINE> <INDENT> sampwidth = struct . unpack ( <STRING> , chunk . read ( 2 ) ) [ 0 ] <NEWLINE> self . _sampwidth = ( sampwidth + 7 ) // 8 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Error , <STRING> % ( wFormatTag , ) <NEWLINE> <DEDENT> self . _framesize = self . _nchannels * self . _sampwidth <NEWLINE> self . _comptype = <STRING> <NEWLINE> self . _compname = <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'<HHLLH'", "'<H'", "'unknown format: %r'", "'NONE'", "'not compressed'"]}, "err_obj": {"msg": "invalid syntax"}}], ["2332ba07ccc17ae61d19a73f69bbd1e0", {"code_string": "def convert(value):\n    if value.startswith('~'):\n    return value.strip('~')\n    if not value:\n    value = '0'\n    return float(value)\n", "code_toks_joined": "def convert ( value ) : <NEWLINE> <INDENT> if value . startswith ( <STRING> ) : <NEWLINE> return value . strip ( <STRING> ) <NEWLINE> if not value : <NEWLINE> value = <STRING> <NEWLINE> return float ( value ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'~'", "'~'", "'0'"]}, "err_obj": {"msg": "expected an indented block"}}], ["001f6440b533edd7f4790a24596bc930", {"code_string": "def testFlagMatrixNotFound(self):\n    self.mock_flags.benchmarks = ['netperf']\n    self.mock_flags.flag_matrix = 'bad_flag_matrix_name'\n    with patch('perfkitbenchmarker.configs.GetUserConfig',\n        return_value = yaml.load(USER_CONFIG)):\n        with self.assertRaises(benchmark_sets.FlagMatrixNotFoundException):\n        benchmark_sets.GetBenchmarksFromFlags()\n", "code_toks_joined": "def testFlagMatrixNotFound ( self ) : <NEWLINE> <INDENT> self . mock_flags . benchmarks = [ <STRING> ] <NEWLINE> self . mock_flags . flag_matrix = <STRING> <NEWLINE> with patch ( <STRING> , <NEWLINE> <INDENT> return_value = yaml . load ( USER_CONFIG ) ) : <NEWLINE> with self . assertRaises ( benchmark_sets . FlagMatrixNotFoundException ) : <NEWLINE> benchmark_sets . GetBenchmarksFromFlags ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'netperf'", "'bad_flag_matrix_name'", "'perfkitbenchmarker.configs.GetUserConfig'"]}, "err_obj": {"msg": "expected an indented block"}}], ["cdadaf0c08011450c4ae6a693aeb483a", {"code_string": "def update_properties(self):\n    \"\"\"Callback on data change for the registered node/value pair.\"\"\"\n    for value in self._node.get_values(\n        class_id = zwave.const.COMMAND_CLASS_SWITCH_MULTILEVEL).values():\n        if value.command_class == zwave.const.COMMAND_CLASS_SWITCH_MULTILEVEL and value.label == 'Level':\n        self._current_position = value.data\n", "code_toks_joined": "def update_properties ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for value in self . _node . get_values ( <NEWLINE> <INDENT> class_id = zwave . const . COMMAND_CLASS_SWITCH_MULTILEVEL ) . values ( ) : <NEWLINE> if value . command_class == zwave . const . COMMAND_CLASS_SWITCH_MULTILEVEL and value . label == <STRING> : <NEWLINE> self . _current_position = value . data <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Callback on data change for the registered node/value pair.\"\"\"", "'Level'"]}, "err_obj": {"msg": "expected an indented block"}}], ["f3c34221ca8729693d2f2322972cefe6", {"code_string": "import serial\nser = serial.Serial('/dev/ttyUSB0', 9600)\nwhile(1)\n    a = ser.printline()\n    b = a.split()[0]\n    print(b)\n    print(type(b))\n", "code_toks_joined": "import serial <NEWLINE> ser = serial . Serial ( <STRING> , 9600 ) <NEWLINE> while ( 1 ) <NEWLINE> <INDENT> a = ser . printline ( ) <NEWLINE> b = a . split ( ) [ 0 ] <NEWLINE> print ( b ) <NEWLINE> print ( type ( b ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'/dev/ttyUSB0'"]}, "err_obj": {"msg": "invalid syntax"}}], ["df523543b29eac1da6fd30af3b452524", {"code_string": "class qspn_chunk:\n    def __init__(self, link_id, rem_):\n    self.linkid = link_id\n        self.rem = rem_\n        def print_qspn_ch(self):\n        print(\"linkid:\", self.linkid)\n        print(\"rem:\", )\n        self.rem.print_rem()\n", "code_toks_joined": "class qspn_chunk : <NEWLINE> <INDENT> def __init__ ( self , link_id , rem_ ) : <NEWLINE> self . linkid = link_id <NEWLINE> <INDENT> self . rem = rem_ <NEWLINE> def print_qspn_ch ( self ) : <NEWLINE> print ( <STRING> , self . linkid ) <NEWLINE> print ( <STRING> , ) <NEWLINE> self . rem . print_rem ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"linkid:\"", "\"rem:\""]}, "err_obj": {"msg": "expected an indented block"}}], ["f203d396a7e9aa17c35ccb93c2ef0a52", {"code_string": "def get_absolute_url(self):\n    return \"http://%s%s\" %(\n        settings.SERVER_URL,\n        reverse(\"phage_hunters_detail\", args = [self.pk])\n", "code_toks_joined": "def get_absolute_url ( self ) : <NEWLINE> <INDENT> return <STRING> % ( <NEWLINE> <INDENT> settings . SERVER_URL , <NEWLINE> reverse ( <STRING> , args = [ self . pk ] ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"http://%s%s\"", "\"phage_hunters_detail\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["fb004ddb80949c33b6c81545cbadf83d", {"code_string": "def delete(self):\n    \"\"\":calls: `DELETE /repos/:owner/:repo/keys/:id <http://developer.github.com/v3/repos/keys>`_\"\"\"\n    headers, data = self._requester.requestJsonAndCheck(\n        \"DELETE\"\n        self.__customUrl\n    )\n", "code_toks_joined": "def delete ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> headers , data = self . _requester . requestJsonAndCheck ( <NEWLINE> <INDENT> <STRING> <NEWLINE> self . __customUrl <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\":calls: `DELETE /repos/:owner/:repo/keys/:id <http://developer.github.com/v3/repos/keys>`_\"\"\"", "\"DELETE\""]}, "err_obj": {"msg": "invalid syntax"}}], ["3e6ab281ee4c579585e0f40820b73525", {"code_string": "def match_string(list_string, mapping, substring_len):\n    matches = []\n    for i in range(min(substring_len, len(list_string)))):\n        for j in range(len(list_string) - i):\n            substr = \" \".join(list_string[j: (j + i + 1)])\n            if substr in mapping:\n                matches.append(substr)\n    return matches\n", "code_toks_joined": "def match_string ( list_string , mapping , substring_len ) : <NEWLINE> <INDENT> matches = [ ] <NEWLINE> for i in range ( min ( substring_len , len ( list_string ) ) ) ) : <NEWLINE> <INDENT> for j in range ( len ( list_string ) - i ) : <NEWLINE> <INDENT> substr = <STRING> . join ( list_string [ j : ( j + i + 1 ) ] ) <NEWLINE> if substr in mapping : <NEWLINE> <INDENT> matches . append ( substr ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return matches <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\" \""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["7e04e3f540a08e2a9c119a965610c273", {"code_string": "def get(dictionary, key):\n    try:\n        return dictionary.get(key)\n    except TypeError as e:\n        logger.error(\n            'Invalid arguments: dictionary=%s key=%s %s', dictionary, key e)\n        return None\n", "code_toks_joined": "def get ( dictionary , key ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return dictionary . get ( key ) <NEWLINE> <DEDENT> except TypeError as e : <NEWLINE> <INDENT> logger . error ( <NEWLINE> <INDENT> <STRING> , dictionary , key e ) <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Invalid arguments: dictionary=%s key=%s %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["c9e07af3f48fc5e277c62e88a1dde35e", {"code_string": "from numpy import empty, array, save\nN = 14645083\nD = empty((7, N))\nf = open(\"data.txt\")\ni = 0\nfor line in f:\n    if line.startswith(\"%\"): continue\n    D[: , i] = array([float(x) for x in line.split()])\n    i += 1\n    if i % 100000 == 0:\n        print \"%.3f%%\" %(100. * i / N)\nprint(\"Saving...\")\nsave(\"data.npy\", D)\nprint(\"Done.\")\n", "code_toks_joined": "from numpy import empty , array , save <NEWLINE> N = 14645083 <NEWLINE> D = empty ( ( 7 , N ) ) <NEWLINE> f = open ( <STRING> ) <NEWLINE> i = 0 <NEWLINE> for line in f : <NEWLINE> <INDENT> if line . startswith ( <STRING> ) : continue <NEWLINE> D [ : , i ] = array ( [ float ( x ) for x in line . split ( ) ] ) <NEWLINE> i += 1 <NEWLINE> if i % 100000 == 0 : <NEWLINE> <INDENT> print <STRING> % ( 100. * i / N ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> save ( <STRING> , D ) <NEWLINE> print ( <STRING> ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"data.txt\"", "\"%\"", "\"%.3f%%\"", "\"Saving...\"", "\"data.npy\"", "\"Done.\""]}, "err_obj": {"msg": "invalid syntax"}}], ["cf8999696c1c4923256608e9b8a6badf", {"code_string": "from sympy import collect, Function, solve, asin\nfrom pydy import *\nN = NewtonianReferenceFrame('N')\nparams = N.declare_parameters('rr rrt rf rft lr ls lf l1 l2 l3 l4 mcd mef IC22 ICD11 ICD22 ICD33 ICD13 IEF11 IEF22 IEF33 IEF13 IF22 g')\nq, qd = N.declare_coords('q', 11)\nu, ud = N.declare_speeds('u', 6)\nrr, rrt, rf, rft, lr, ls, lf, l1, l2, l3, l4, mcd, mef, IC22, ICD11, ICD22, ICD33, ICD13, IEF11, IEF22, IEF33, IEF13, IF22, g = params\nq1, q2, q3, q4, q5, q6, q7, q8, q9, q10, q11 = q\nq1d, q2d, q3d, q4d, q5d, q6d, q7d, q8d, q9d, q10d, q11d = qd\nu1, u2, u3, u4, u5, u6 = u\nu1d, u2d, u3d, u4d, u5d, u6d = ud\ntan_lean = {sin(q2) / cos(q2): tan(q2)}\ng31 = Function('g31')(t)\ng33 = Function('g33')(t)\ng31_s, g33_s = symbols('g31 g33')\ng31d_s, g33d_s = symbols('g31d g33d')\n\"\"\"s1, s2, s3, s4, s5, s6, c1, c2, c3, c4, c5, c6, t2 = symbols('s1  s2 s3 s4 s5 s6 c1 c2 c3 c4 c5 c6 t2')\"\"\"\nA = N.rotate('A', 3, q1)\nB = A.rotate('B', 1, q2)\nD = B.rotate('D', 2, q3, I = (ICD11, ICD22, ICD33, 0, 0, ICD13))\nC = D.rotate('C', 2, q4, I = (0, IC22, 0, 0, 0, 0), I_frame = D)\nE = D.rotate('E', 3, q5, I = (IEF11, IEF22, IEF33, 0, 0, IEF13))\nF = E.rotate('F', 2, q6, I = (0, IF22, 0, 0, 0, 0), I_frame = E)\nH = A.rotate('H', 3, q9)\nG = H.rotate('G', 1, q10)\nE2 = G.rotate('E', 2, q11)\ng3_num = Vector(N[3] - dot(E[2], N[3]) * E[2]).express(E)\ng3_den = sqrt(g3_num.dict[E[1]] ** 2 + g3_num.dict[E[3]] ** 2)\ng3 = Vector({E[1]: g3_num.dict[E[1]] / g3_den, E[3]: g3_num.dict[E[3]] / g3_den})\ng1 = cross(E[2], g3)\n\"\"\"sq9 = dot(g1, A[2]).expand()\"\"\"\ng31_expr = dot(g3, E[1])\ng33_expr = dot(g3, E[3])\nnum1 = g3_num.dict[E[1]]\nnum2 = g3_num.dict[E[3]]\nden = g3_den\ng31_expr_dt = (num1.diff(t) * den - num1 * den.diff(t)) / den ** 2\ng33_expr_dt = (num2.diff(t) * den - num2 * den.diff(t)) / den ** 2\ng3_dict = {g31: g31_expr, g33: g33_expr, g31.diff(t): g31_expr_dt,\n    g33.diff(t): g33_expr_dt}\ng3_symbol_dict = {g31: g31_s, g33: g33_s, g31.diff(t): g31d_s, g33.diff(t):\n    g33d_s}\nfo_fn = Vector({E[1]: rf * g31, E[3]: rf * g33, N[3]: rft})\nCO = N.O.locate('CO', - rrt * N[3] - rr * B[3], C)\nCDO = CO.locate('CDO', l1 * D[1] + l2 * D[3], D, mass = mcd)\nDE = CO.locate('DE', lr * D[1], D)\nFO = DE.locate('FO', lf * E[1] + ls * E[3], E)\nEFO = FO.locate('EFO', l3 * E[1] + l4 * E[3], E, mass = mef)\nFN = FO.locate('FN', fo_fn, F)\nN1 = CO.locate('N1', rr * B[3] + rrt * N[3] - q7 * N[1] - q8 * N[2])\nu_rhs = [dot(D.ang_vel(N), D[1]),\n    dot(D.ang_vel(N), D[2]),\n    dot(D.ang_vel(N), D[3]),\n    dot(C.ang_vel(N), D[2]),\n    dot(E.ang_vel(N), D[3]),\n    dot(F.ang_vel(N), E[2])]\nqd_to_u = coefficient_matrix(u_rhs, qd[: 6])\nu_steady = qd_to_u * Matrix([q1d, 0, 0, q4d, 0, q6d])\nu_to_qd = qd_to_u.inverse_ADJ().expand().subs(N.csqrd_dict).expand().subs(tan_lean)\nvco1 = dt(CO.rel(N1), N)\nvco2 = cross(C.ang_vel(N), CO.rel(N.O))\neq1 = dot(vco1 - vco2, N[1]).expand().subs(N.csqrd_dict).expand()\neq2 = dot(vco1 - vco2, N[2]).expand().subs(N.csqrd_dict).expand()\nxy_rates = solve([eq1, eq2], qd[6: ])\nkindiff_rhs = u_to_qd * Matrix(u)\n    Eq(qd[7], xy_rates[q8d])]\nfunc_params = (q1, q2, q4, q5)\nds = \"\"\" Linear mapping from generalized speeds to time derivatives of coordinates.\"\"\"\noutput_string = \"from __future__ import division\\n\"\noutput_string += \"from math import sin, cos, tan\\n\\n\"\noutput_string = generate_function(\"kindiffs\", kindiff_eqns, func_params,\n    docstring = ds)\nD.abs_ang_vel = Vector(u1 * D[1] + u2 * D[2] + u3 * D[3])\nC.abs_ang_vel = Vector(u1 * D[1] + u4 * D[2] + u3 * D[3])\nE.abs_ang_vel = Vector(u1 * D[1] + u2 * D[2] + u5 * D[3])\nF.abs_ang_vel = (E.abs_ang_vel - E.abs_ang_vel.dot(E[2]) * E[2] +\n    Vector(u6 * E[2])).express(E)\nCDO.abs_vel = express(cross(C.ang_vel(N), CO.rel(N.O)) + cross(D.ang_vel(N), CDO.rel(CO)), D)\nEFO.abs_vel = express(cross(F.ang_vel(N), FO.rel(FN)) + cross(E.ang_vel(N), EFO.rel(FO)), E)\nvfn = cross(C.ang_vel(N), CO.rel(N.O)) + cross(D.ang_vel(N), DE.rel(CO)) + cross(E.ang_vel(N), FO.rel(DE)) + cross(F.ang_vel(N), FN.rel(FO))\nmotion_constraint_eqs = [dot(vfn, D[i]).expand().subs(N.csqrd_dict).expand() for i in(1, 2, 3)]\nB_con = coefficient_matrix(motion_constraint_eqs, u)\nB_con[0, 1] = B_con[0, 1].subs({cos(q5) ** 2: 1 - sin(q5) ** 2}).expand()\nB_con[1, 0] = B_con[1, 0].subs({sin(q5) ** 2: 1 - cos(q5) ** 2}).expand()\nB_con[0, 4] = B_con[0, 4].subs({sin(q5) ** 2: 1 - cos(q5) ** 2}).expand()\nB_con[1, 4] = B_con[1, 4].subs({sin(q5) ** 2: 1 - cos(q5) ** 2}).expand()\n\"\"\"B_con_s = B_con.subs(N.trig_subs_dict).subs(N.symbol_dict).subs(g3_symbol_dict).expand()\"\"\"\nu_indep = [u1, u4, u6]\nu_dep = [u2, u3, u5]\nBd_inv, Bi, B_dict = transform_matrix(B_con, u, u_dep, subs_dict = True,\n    time = True)\nT = Bd_inv * Bi\nstop\nB_subs_dict_time = {}\nB_subs_dict_time_rev = {}\nB_subs_dict_derivs = {}\nB_subs_dict_dt_rhs = {}\nfor k, v in B_subs_dict.items():\n    tv = Function(\"_\" + str(k.name))(t)\n    B_subs_dict_time[k] = tv\n    B_subs_dict_time_rev[tv] = k\n    tvd = Symbol(\"_\" + str(k.name) + \"d\")\n    B_subs_dict_derivs[tv.diff(t)] = tvd\n    B_subs_dict_dt_rhs[tvd] = B_subs_dict[k].diff(t).subs({e1c.diff(t):\n        Symbol('e1cd'), e3c.diff(t): Symbol('e3cd')})\nT_ud = - Bd_inv * Bi\nprint(T_ud)\nstop\n\"\"\"T_ud_dt = zeros((3,3))\"\"\"\ndep_speed_eqns = [Eq(u_d, u_d_r) for u_d, u_d_r in zip(u_dep, u_dep_rhs)]\nfunc_params = params[: 9] +(q1, q3, q4)\nfw_terms = {e1c_s: e1c_expr, e3c_s: e3c_expr}\nfor k, v in B_subs_dict.items():\n    B_subs_dict[k] = v.subs({e1c: e1c_s, e3c: e3c_s})\nnt = [fw_terms, B_subs_dict]\nds = \"\"\" Linear mapping from independent generalized speeds to dependent generalized\"\"\"\noutput_string += generate_function(\"speed_transform\", dep_speed_eqns, u_indep,\n    func_params, nested_terms = nt, docstring = ds)\nfor k, v in B_subs_dict.items():\n    B_subs_dict[k] = v.subs({e1c_s: e1c, e3c_s: e3c})\nT_con_dict, T_con_dt_dict = N.set_motion_constraint_matrix(T_ud, T_ud_dt,\n    u_dep, u_indep, dep_ci, indep_ci)\nC.abs_ang_acc = dt(C.ang_vel(), D) + cross(D.ang_vel(), C.ang_vel())\nD.abs_ang_acc = dt(D.ang_vel(), D)\nE.abs_ang_acc = dt(E.ang_vel(), E)\nF.abs_ang_acc = dt(F.ang_vel(), E) + cross(E.ang_vel(), F.ang_vel())\nCDO.abs_acc = dt(CDO.vel(), D) + cross(D.ang_vel(), CDO.vel())\nEFO.abs_acc = dt(EFO.vel(), E) + cross(E.ang_vel(), EFO.vel())\nN.gravity(g * N[3])\nfo_fn_subs = {e3c: e3c_s, e1c: e1c_s}\nkanes_eqns = N.form_kanes_equations()\nkanes_eqns_new = []\nfor i, ke in enumerate(kanes_eqns):\n    lhs = ke.lhs.subs(fo_fn_subs)\n    rhs = ke.rhs.subs(fo_fn_subs)\n    kanes_eqns_new.append(Eq(lhs, rhs))\nN.set_kanes_equations(kanes_eqns_new)\nfw_terms[Symbol('e1cd')] = e1c_expr_dt\nfw_terms[Symbol('e3cd')] = e3c_expr_dt\ndyndiffs, mass_matrix_dict = N.solve_kanes_equations(dummy_mass_matrix = True)\nfor k, v in B_subs_dict.items():\n    B_subs_dict[k] = v.subs(fo_fn_subs)\nfor k, v in B_subs_dict_dt_rhs.items():\n    B_subs_dict_dt_rhs[k] = v.subs(fo_fn_subs)\nfor k, v in mass_matrix_dict.items():\n    mass_matrix_dict[k] = v.subs(fo_fn_subs)\nu_dep_dict = eqn_list_to_dict(dep_speed_eqns)\nnt = [fw_terms, B_subs_dict, u_dep_dict, B_subs_dict_dt_rhs, T_con_dict, T_con_dt_dict,\n    mass_matrix_dict]\nds = \"\"\" Equations of motion for a benchmark bicycle.\"\"\"\noutput_string += generate_function(\"eoms\", kindiff_eqns + dyndiffs, q + u_indep, params,\n    nested_terms = nt, docstring = ds, time = True)\noutput_string += 'mj_params = {\"w\": 1.02, \"c\": 0.08, \"lambda\": pi/10., \"g\": 9.81, \"rr\": 0.3, \"mr\": 2.0, \"IRxx\": 0.0603, \"IRyy\": 0.12, \"xb\": 0.3, \"zb\": -0.9, \"mb\": 85.0, \"IBxx\": 9.2, \"IBxz\": 2.4, \"IByy\": 11.0, \"IBzz\": 2.8, \"xh\": 0.9, \"zh\": -0.7, \"mh\": 4.0, \"IHxx\": 0.05892, \"IHxz\": -0.00756, \"IHyy\": 0.06, \"IHzz\": 0.00708, \"rf\": 0.35, \"mf\": 3.0, \"IFxx\": 0.1405, \"IFyy\": 0.28}\\n'\nfh = open('bicycle_lib.py', 'w')\nfh.write(output_string)\nfh.close()\n", "code_toks_joined": "from sympy import collect , Function , solve , asin <NEWLINE> from pydy import * <NEWLINE> N = NewtonianReferenceFrame ( <STRING> ) <NEWLINE> params = N . declare_parameters ( <STRING> ) <NEWLINE> q , qd = N . declare_coords ( <STRING> , 11 ) <NEWLINE> u , ud = N . declare_speeds ( <STRING> , 6 ) <NEWLINE> rr , rrt , rf , rft , lr , ls , lf , l1 , l2 , l3 , l4 , mcd , mef , IC22 , ICD11 , ICD22 , ICD33 , ICD13 , IEF11 , IEF22 , IEF33 , IEF13 , IF22 , g = params <NEWLINE> q1 , q2 , q3 , q4 , q5 , q6 , q7 , q8 , q9 , q10 , q11 = q <NEWLINE> q1d , q2d , q3d , q4d , q5d , q6d , q7d , q8d , q9d , q10d , q11d = qd <NEWLINE> u1 , u2 , u3 , u4 , u5 , u6 = u <NEWLINE> u1d , u2d , u3d , u4d , u5d , u6d = ud <NEWLINE> tan_lean = { sin ( q2 ) / cos ( q2 ) : tan ( q2 ) } <NEWLINE> g31 = Function ( <STRING> ) ( t ) <NEWLINE> g33 = Function ( <STRING> ) ( t ) <NEWLINE> g31_s , g33_s = symbols ( <STRING> ) <NEWLINE> g31d_s , g33d_s = symbols ( <STRING> ) <NEWLINE> <STRING> <NEWLINE> A = N . rotate ( <STRING> , 3 , q1 ) <NEWLINE> B = A . rotate ( <STRING> , 1 , q2 ) <NEWLINE> D = B . rotate ( <STRING> , 2 , q3 , I = ( ICD11 , ICD22 , ICD33 , 0 , 0 , ICD13 ) ) <NEWLINE> C = D . rotate ( <STRING> , 2 , q4 , I = ( 0 , IC22 , 0 , 0 , 0 , 0 ) , I_frame = D ) <NEWLINE> E = D . rotate ( <STRING> , 3 , q5 , I = ( IEF11 , IEF22 , IEF33 , 0 , 0 , IEF13 ) ) <NEWLINE> F = E . rotate ( <STRING> , 2 , q6 , I = ( 0 , IF22 , 0 , 0 , 0 , 0 ) , I_frame = E ) <NEWLINE> H = A . rotate ( <STRING> , 3 , q9 ) <NEWLINE> G = H . rotate ( <STRING> , 1 , q10 ) <NEWLINE> E2 = G . rotate ( <STRING> , 2 , q11 ) <NEWLINE> g3_num = Vector ( N [ 3 ] - dot ( E [ 2 ] , N [ 3 ] ) * E [ 2 ] ) . express ( E ) <NEWLINE> g3_den = sqrt ( g3_num . dict [ E [ 1 ] ] ** 2 + g3_num . dict [ E [ 3 ] ] ** 2 ) <NEWLINE> g3 = Vector ( { E [ 1 ] : g3_num . dict [ E [ 1 ] ] / g3_den , E [ 3 ] : g3_num . dict [ E [ 3 ] ] / g3_den } ) <NEWLINE> g1 = cross ( E [ 2 ] , g3 ) <NEWLINE> <STRING> <NEWLINE> g31_expr = dot ( g3 , E [ 1 ] ) <NEWLINE> g33_expr = dot ( g3 , E [ 3 ] ) <NEWLINE> num1 = g3_num . dict [ E [ 1 ] ] <NEWLINE> num2 = g3_num . dict [ E [ 3 ] ] <NEWLINE> den = g3_den <NEWLINE> g31_expr_dt = ( num1 . diff ( t ) * den - num1 * den . diff ( t ) ) / den ** 2 <NEWLINE> g33_expr_dt = ( num2 . diff ( t ) * den - num2 * den . diff ( t ) ) / den ** 2 <NEWLINE> g3_dict = { g31 : g31_expr , g33 : g33_expr , g31 . diff ( t ) : g31_expr_dt , <NEWLINE> <INDENT> g33 . diff ( t ) : g33_expr_dt } <NEWLINE> <DEDENT> g3_symbol_dict = { g31 : g31_s , g33 : g33_s , g31 . diff ( t ) : g31d_s , g33 . diff ( t ) : <NEWLINE> <INDENT> g33d_s } <NEWLINE> <DEDENT> fo_fn = Vector ( { E [ 1 ] : rf * g31 , E [ 3 ] : rf * g33 , N [ 3 ] : rft } ) <NEWLINE> CO = N . O . locate ( <STRING> , - rrt * N [ 3 ] - rr * B [ 3 ] , C ) <NEWLINE> CDO = CO . locate ( <STRING> , l1 * D [ 1 ] + l2 * D [ 3 ] , D , mass = mcd ) <NEWLINE> DE = CO . locate ( <STRING> , lr * D [ 1 ] , D ) <NEWLINE> FO = DE . locate ( <STRING> , lf * E [ 1 ] + ls * E [ 3 ] , E ) <NEWLINE> EFO = FO . locate ( <STRING> , l3 * E [ 1 ] + l4 * E [ 3 ] , E , mass = mef ) <NEWLINE> FN = FO . locate ( <STRING> , fo_fn , F ) <NEWLINE> N1 = CO . locate ( <STRING> , rr * B [ 3 ] + rrt * N [ 3 ] - q7 * N [ 1 ] - q8 * N [ 2 ] ) <NEWLINE> u_rhs = [ dot ( D . ang_vel ( N ) , D [ 1 ] ) , <NEWLINE> <INDENT> dot ( D . ang_vel ( N ) , D [ 2 ] ) , <NEWLINE> dot ( D . ang_vel ( N ) , D [ 3 ] ) , <NEWLINE> dot ( C . ang_vel ( N ) , D [ 2 ] ) , <NEWLINE> dot ( E . ang_vel ( N ) , D [ 3 ] ) , <NEWLINE> dot ( F . ang_vel ( N ) , E [ 2 ] ) ] <NEWLINE> <DEDENT> qd_to_u = coefficient_matrix ( u_rhs , qd [ : 6 ] ) <NEWLINE> u_steady = qd_to_u * Matrix ( [ q1d , 0 , 0 , q4d , 0 , q6d ] ) <NEWLINE> u_to_qd = qd_to_u . inverse_ADJ ( ) . expand ( ) . subs ( N . csqrd_dict ) . expand ( ) . subs ( tan_lean ) <NEWLINE> vco1 = dt ( CO . rel ( N1 ) , N ) <NEWLINE> vco2 = cross ( C . ang_vel ( N ) , CO . rel ( N . O ) ) <NEWLINE> eq1 = dot ( vco1 - vco2 , N [ 1 ] ) . expand ( ) . subs ( N . csqrd_dict ) . expand ( ) <NEWLINE> eq2 = dot ( vco1 - vco2 , N [ 2 ] ) . expand ( ) . subs ( N . csqrd_dict ) . expand ( ) <NEWLINE> xy_rates = solve ( [ eq1 , eq2 ] , qd [ 6 : ] ) <NEWLINE> kindiff_rhs = u_to_qd * Matrix ( u ) <NEWLINE> <INDENT> Eq ( qd [ 7 ] , xy_rates [ q8d ] ) ] <NEWLINE> <DEDENT> func_params = ( q1 , q2 , q4 , q5 ) <NEWLINE> ds = <STRING> <NEWLINE> output_string = <STRING> <NEWLINE> output_string += <STRING> <NEWLINE> output_string = generate_function ( <STRING> , kindiff_eqns , func_params , <NEWLINE> <INDENT> docstring = ds ) <NEWLINE> <DEDENT> D . abs_ang_vel = Vector ( u1 * D [ 1 ] + u2 * D [ 2 ] + u3 * D [ 3 ] ) <NEWLINE> C . abs_ang_vel = Vector ( u1 * D [ 1 ] + u4 * D [ 2 ] + u3 * D [ 3 ] ) <NEWLINE> E . abs_ang_vel = Vector ( u1 * D [ 1 ] + u2 * D [ 2 ] + u5 * D [ 3 ] ) <NEWLINE> F . abs_ang_vel = ( E . abs_ang_vel - E . abs_ang_vel . dot ( E [ 2 ] ) * E [ 2 ] + <NEWLINE> <INDENT> Vector ( u6 * E [ 2 ] ) ) . express ( E ) <NEWLINE> <DEDENT> CDO . abs_vel = express ( cross ( C . ang_vel ( N ) , CO . rel ( N . O ) ) + cross ( D . ang_vel ( N ) , CDO . rel ( CO ) ) , D ) <NEWLINE> EFO . abs_vel = express ( cross ( F . ang_vel ( N ) , FO . rel ( FN ) ) + cross ( E . ang_vel ( N ) , EFO . rel ( FO ) ) , E ) <NEWLINE> vfn = cross ( C . ang_vel ( N ) , CO . rel ( N . O ) ) + cross ( D . ang_vel ( N ) , DE . rel ( CO ) ) + cross ( E . ang_vel ( N ) , FO . rel ( DE ) ) + cross ( F . ang_vel ( N ) , FN . rel ( FO ) ) <NEWLINE> motion_constraint_eqs = [ dot ( vfn , D [ i ] ) . expand ( ) . subs ( N . csqrd_dict ) . expand ( ) for i in ( 1 , 2 , 3 ) ] <NEWLINE> B_con = coefficient_matrix ( motion_constraint_eqs , u ) <NEWLINE> B_con [ 0 , 1 ] = B_con [ 0 , 1 ] . subs ( { cos ( q5 ) ** 2 : 1 - sin ( q5 ) ** 2 } ) . expand ( ) <NEWLINE> B_con [ 1 , 0 ] = B_con [ 1 , 0 ] . subs ( { sin ( q5 ) ** 2 : 1 - cos ( q5 ) ** 2 } ) . expand ( ) <NEWLINE> B_con [ 0 , 4 ] = B_con [ 0 , 4 ] . subs ( { sin ( q5 ) ** 2 : 1 - cos ( q5 ) ** 2 } ) . expand ( ) <NEWLINE> B_con [ 1 , 4 ] = B_con [ 1 , 4 ] . subs ( { sin ( q5 ) ** 2 : 1 - cos ( q5 ) ** 2 } ) . expand ( ) <NEWLINE> <STRING> <NEWLINE> u_indep = [ u1 , u4 , u6 ] <NEWLINE> u_dep = [ u2 , u3 , u5 ] <NEWLINE> Bd_inv , Bi , B_dict = transform_matrix ( B_con , u , u_dep , subs_dict = True , <NEWLINE> <INDENT> time = True ) <NEWLINE> <DEDENT> T = Bd_inv * Bi <NEWLINE> stop <NEWLINE> B_subs_dict_time = { } <NEWLINE> B_subs_dict_time_rev = { } <NEWLINE> B_subs_dict_derivs = { } <NEWLINE> B_subs_dict_dt_rhs = { } <NEWLINE> for k , v in B_subs_dict . items ( ) : <NEWLINE> <INDENT> tv = Function ( <STRING> + str ( k . name ) ) ( t ) <NEWLINE> B_subs_dict_time [ k ] = tv <NEWLINE> B_subs_dict_time_rev [ tv ] = k <NEWLINE> tvd = Symbol ( <STRING> + str ( k . name ) + <STRING> ) <NEWLINE> B_subs_dict_derivs [ tv . diff ( t ) ] = tvd <NEWLINE> B_subs_dict_dt_rhs [ tvd ] = B_subs_dict [ k ] . diff ( t ) . subs ( { e1c . diff ( t ) : <NEWLINE> <INDENT> Symbol ( <STRING> ) , e3c . diff ( t ) : Symbol ( <STRING> ) } ) <NEWLINE> <DEDENT> <DEDENT> T_ud = - Bd_inv * Bi <NEWLINE> print ( T_ud ) <NEWLINE> stop <NEWLINE> <STRING> <NEWLINE> dep_speed_eqns = [ Eq ( u_d , u_d_r ) for u_d , u_d_r in zip ( u_dep , u_dep_rhs ) ] <NEWLINE> func_params = params [ : 9 ] + ( q1 , q3 , q4 ) <NEWLINE> fw_terms = { e1c_s : e1c_expr , e3c_s : e3c_expr } <NEWLINE> for k , v in B_subs_dict . items ( ) : <NEWLINE> <INDENT> B_subs_dict [ k ] = v . subs ( { e1c : e1c_s , e3c : e3c_s } ) <NEWLINE> <DEDENT> nt = [ fw_terms , B_subs_dict ] <NEWLINE> ds = <STRING> <NEWLINE> output_string += generate_function ( <STRING> , dep_speed_eqns , u_indep , <NEWLINE> <INDENT> func_params , nested_terms = nt , docstring = ds ) <NEWLINE> <DEDENT> for k , v in B_subs_dict . items ( ) : <NEWLINE> <INDENT> B_subs_dict [ k ] = v . subs ( { e1c_s : e1c , e3c_s : e3c } ) <NEWLINE> <DEDENT> T_con_dict , T_con_dt_dict = N . set_motion_constraint_matrix ( T_ud , T_ud_dt , <NEWLINE> <INDENT> u_dep , u_indep , dep_ci , indep_ci ) <NEWLINE> <DEDENT> C . abs_ang_acc = dt ( C . ang_vel ( ) , D ) + cross ( D . ang_vel ( ) , C . ang_vel ( ) ) <NEWLINE> D . abs_ang_acc = dt ( D . ang_vel ( ) , D ) <NEWLINE> E . abs_ang_acc = dt ( E . ang_vel ( ) , E ) <NEWLINE> F . abs_ang_acc = dt ( F . ang_vel ( ) , E ) + cross ( E . ang_vel ( ) , F . ang_vel ( ) ) <NEWLINE> CDO . abs_acc = dt ( CDO . vel ( ) , D ) + cross ( D . ang_vel ( ) , CDO . vel ( ) ) <NEWLINE> EFO . abs_acc = dt ( EFO . vel ( ) , E ) + cross ( E . ang_vel ( ) , EFO . vel ( ) ) <NEWLINE> N . gravity ( g * N [ 3 ] ) <NEWLINE> fo_fn_subs = { e3c : e3c_s , e1c : e1c_s } <NEWLINE> kanes_eqns = N . form_kanes_equations ( ) <NEWLINE> kanes_eqns_new = [ ] <NEWLINE> for i , ke in enumerate ( kanes_eqns ) : <NEWLINE> <INDENT> lhs = ke . lhs . subs ( fo_fn_subs ) <NEWLINE> rhs = ke . rhs . subs ( fo_fn_subs ) <NEWLINE> kanes_eqns_new . append ( Eq ( lhs , rhs ) ) <NEWLINE> <DEDENT> N . set_kanes_equations ( kanes_eqns_new ) <NEWLINE> fw_terms [ Symbol ( <STRING> ) ] = e1c_expr_dt <NEWLINE> fw_terms [ Symbol ( <STRING> ) ] = e3c_expr_dt <NEWLINE> dyndiffs , mass_matrix_dict = N . solve_kanes_equations ( dummy_mass_matrix = True ) <NEWLINE> for k , v in B_subs_dict . items ( ) : <NEWLINE> <INDENT> B_subs_dict [ k ] = v . subs ( fo_fn_subs ) <NEWLINE> <DEDENT> for k , v in B_subs_dict_dt_rhs . items ( ) : <NEWLINE> <INDENT> B_subs_dict_dt_rhs [ k ] = v . subs ( fo_fn_subs ) <NEWLINE> <DEDENT> for k , v in mass_matrix_dict . items ( ) : <NEWLINE> <INDENT> mass_matrix_dict [ k ] = v . subs ( fo_fn_subs ) <NEWLINE> <DEDENT> u_dep_dict = eqn_list_to_dict ( dep_speed_eqns ) <NEWLINE> nt = [ fw_terms , B_subs_dict , u_dep_dict , B_subs_dict_dt_rhs , T_con_dict , T_con_dt_dict , <NEWLINE> <INDENT> mass_matrix_dict ] <NEWLINE> <DEDENT> ds = <STRING> <NEWLINE> output_string += generate_function ( <STRING> , kindiff_eqns + dyndiffs , q + u_indep , params , <NEWLINE> <INDENT> nested_terms = nt , docstring = ds , time = True ) <NEWLINE> <DEDENT> output_string += <STRING> <NEWLINE> fh = open ( <STRING> , <STRING> ) <NEWLINE> fh . write ( output_string ) <NEWLINE> fh . close ( ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["'N'", "'rr rrt rf rft lr ls lf l1 l2 l3 l4 mcd mef IC22 ICD11 ICD22 ICD33 ICD13 IEF11 IEF22 IEF33 IEF13 IF22 g'", "'q'", "'u'", "'g31'", "'g33'", "'g31 g33'", "'g31d g33d'", "\"\"\"s1, s2, s3, s4, s5, s6, c1, c2, c3, c4, c5, c6, t2 = symbols('s1  s2 s3 s4 s5 s6 c1 c2 c3 c4 c5 c6 t2')\"\"\"", "'A'", "'B'", "'D'", "'C'", "'E'", "'F'", "'H'", "'G'", "'E'", "\"\"\"sq9 = dot(g1, A[2]).expand()\"\"\"", "'CO'", "'CDO'", "'DE'", "'FO'", "'EFO'", "'FN'", "'N1'", "\"\"\" Linear mapping from generalized speeds to time derivatives of coordinates.\"\"\"", "\"from __future__ import division\\n\"", "\"from math import sin, cos, tan\\n\\n\"", "\"kindiffs\"", "\"\"\"B_con_s = B_con.subs(N.trig_subs_dict).subs(N.symbol_dict).subs(g3_symbol_dict).expand()\"\"\"", "\"_\"", "\"_\"", "\"d\"", "'e1cd'", "'e3cd'", "\"\"\"T_ud_dt = zeros((3,3))\"\"\"", "\"\"\" Linear mapping from independent generalized speeds to dependent generalized\"\"\"", "\"speed_transform\"", "'e1cd'", "'e3cd'", "\"\"\" Equations of motion for a benchmark bicycle.\"\"\"", "\"eoms\"", "'mj_params = {\"w\": 1.02, \"c\": 0.08, \"lambda\": pi/10., \"g\": 9.81, \"rr\": 0.3, \"mr\": 2.0, \"IRxx\": 0.0603, \"IRyy\": 0.12, \"xb\": 0.3, \"zb\": -0.9, \"mb\": 85.0, \"IBxx\": 9.2, \"IBxz\": 2.4, \"IByy\": 11.0, \"IBzz\": 2.8, \"xh\": 0.9, \"zh\": -0.7, \"mh\": 4.0, \"IHxx\": 0.05892, \"IHxz\": -0.00756, \"IHyy\": 0.06, \"IHzz\": 0.00708, \"rf\": 0.35, \"mf\": 3.0, \"IFxx\": 0.1405, \"IFyy\": 0.28}\\n'", "'bicycle_lib.py'", "'w'"]}, "window_span": [1212, 1227], "err_obj": {"msg": "unbalanced (){}[]"}}], ["d5cf0cd1d68458c86300e16ed98427d0", {"code_string": "def cmp_gauged(xs, ys, gauges):\n    for gauge in gauges:\n    gx = sum_gauge(gauge, xs)\n    gy = sum_gauge(gauge, ys)\n    c = cmp(gx, gy)\n    if c:\n        return c\n    return 0\n", "code_toks_joined": "def cmp_gauged ( xs , ys , gauges ) : <NEWLINE> <INDENT> for gauge in gauges : <NEWLINE> gx = sum_gauge ( gauge , xs ) <NEWLINE> gy = sum_gauge ( gauge , ys ) <NEWLINE> c = cmp ( gx , gy ) <NEWLINE> if c : <NEWLINE> <INDENT> return c <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["6cfb541396cfdd65e90a2380a4a9b2d0", {"code_string": "import subprocess\nimport requests\n'''for x in range(9):'''\nf = open('workfile', 'r')\nt = open('output', 'w')\nl = f.read().splitlines()\nfor each in l:\n    try:\n    r = requests.get(each)\n    if(r.status_code == 200):\n        print(r.url)\n        t.write(r.url + \"\\n\")\n        except:\n    pass\nt.close()\n", "code_toks_joined": "import subprocess <NEWLINE> import requests <NEWLINE> <STRING> <NEWLINE> f = open ( <STRING> , <STRING> ) <NEWLINE> t = open ( <STRING> , <STRING> ) <NEWLINE> l = f . read ( ) . splitlines ( ) <NEWLINE> for each in l : <NEWLINE> <INDENT> try : <NEWLINE> r = requests . get ( each ) <NEWLINE> if ( r . status_code == 200 ) : <NEWLINE> <INDENT> print ( r . url ) <NEWLINE> t . write ( r . url + <STRING> ) <NEWLINE> except : <NEWLINE> <DEDENT> pass <NEWLINE> <DEDENT> t . close ( ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["'''for x in range(9):'''", "'workfile'", "'r'", "'output'", "'w'", "\"\\n\""]}, "err_obj": {"msg": "expected an indented block"}}], ["35076e1fcf686f8fd4d7feb50a5ae10d", {"code_string": "def __getattr__(self, name):\n    try:\n        index = name.rfind('_')\n        id, lang = name[: index], name[index + 1: ]\n        property = self._local_properties[id]\n    except:\n        raise AttributeError, \"%s instance has no attribute '%s'\" %(self.__class__.__name__, name)\n    return self.getLocalAttribute(id, lang)\n", "code_toks_joined": "def __getattr__ ( self , name ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> index = name . rfind ( <STRING> ) <NEWLINE> id , lang = name [ : index ] , name [ index + 1 : ] <NEWLINE> property = self . _local_properties [ id ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> raise AttributeError , <STRING> % ( self . __class__ . __name__ , name ) <NEWLINE> <DEDENT> return self . getLocalAttribute ( id , lang ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'_'", "\"%s instance has no attribute '%s'\""]}, "err_obj": {"msg": "invalid syntax"}}], ["b1d2c29f853dbbb71aea202aa399bd2e", {"code_string": "from{{cookiecutter.package_name}}.cli import main\nif __name__ == '__main__':\n    main()\n", "code_toks_joined": "from { { cookiecutter . package_name } } . cli import main <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'__main__'"]}, "err_obj": {"msg": "invalid syntax"}}], ["adbe63f40be79b15bf14a5296bf05ebf", {"code_string": "def predict(self, face):\n    \"\"\" Given a face image, predicts the AUs present in the image\"\"\"\n    if self.isTrained:\n        face4d = face.reshape([1, self.image_size, self.image_size, 1])\n        prediction = self.session.run(self.output, feed_dict = {self.x: face4d, self.keep_prob: 1.0}) logging.info(\"Predicted: \" + str(prediction))\n        return prediction\n    return None\n", "code_toks_joined": "def predict ( self , face ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . isTrained : <NEWLINE> <INDENT> face4d = face . reshape ( [ 1 , self . image_size , self . image_size , 1 ] ) <NEWLINE> prediction = self . session . run ( self . output , feed_dict = { self . x : face4d , self . keep_prob : 1.0 } ) logging . info ( <STRING> + str ( prediction ) ) <NEWLINE> return prediction <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Given a face image, predicts the AUs present in the image\"\"\"", "\"Predicted: \""]}, "err_obj": {"msg": "invalid syntax"}}], ["5fcbdaecccd259e34710c6bf63d58d1b", {"code_string": "def password_wrapper():\n    '''Func to get password. Either from environment var or commandline'''\n    return(os.environ.get('EVILUSER'), os.environ.get('EVILPASS') or(get_input(\"Username for Evilzone Wiki: \"), getpass(\"Password for Evilzone Wiki: \"))\n", "code_toks_joined": "def password_wrapper ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return ( os . environ . get ( <STRING> ) , os . environ . get ( <STRING> ) or ( get_input ( <STRING> ) , getpass ( <STRING> ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Func to get password. Either from environment var or commandline'''", "'EVILUSER'", "'EVILPASS'", "\"Username for Evilzone Wiki: \"", "\"Password for Evilzone Wiki: \""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["67bd358eef5215de41a7875b8769b970", {"code_string": "def _recursion(object):\n    return(\"<Recursion on %s with id=%s>\"\n        %(_type(object).__name__, _id(object))\n", "code_toks_joined": "def _recursion ( object ) : <NEWLINE> <INDENT> return ( <STRING> <NEWLINE> <INDENT> % ( _type ( object ) . __name__ , _id ( object ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"<Recursion on %s with id=%s>\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["431b1c567b7a757023dab2486be88610", {"code_string": "def __repr__(self):\n    s = ''\n    for(k, v) in sorted(self.varmap.items(), key = lambda(k, v): v):\n        s += 'c %5d is \"%s\"\\n' %(v, k)\n    s += '\\np cnf %d %d\\n' %(len(self.varmap), len(self.clsset))\n    for c in self.clsset:\n        for v in c: s += str(v) + ' '\n        s += '0\\n'\n    return s\n", "code_toks_joined": "def __repr__ ( self ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> for ( k , v ) in sorted ( self . varmap . items ( ) , key = lambda ( k , v ) : v ) : <NEWLINE> <INDENT> s += <STRING> % ( v , k ) <NEWLINE> <DEDENT> s += <STRING> % ( len ( self . varmap ) , len ( self . clsset ) ) <NEWLINE> for c in self . clsset : <NEWLINE> <INDENT> for v in c : s += str ( v ) + <STRING> <NEWLINE> s += <STRING> <NEWLINE> <DEDENT> return s <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "'c %5d is \"%s\"\\n'", "'\\np cnf %d %d\\n'", "' '", "'0\\n'"]}, "err_obj": {"msg": "invalid syntax"}}], ["4317c5dbe5bcb73061df0d425c0e1b19", {"code_string": "def _check_missing(output):\n    for i, line in enumerate(output.split('\\n')):\n        for msg in('no package found for', 'no packages found for',\n            'missing dependency', 'error:'):\n            if msg in line.lower():\n            raise BuildError('\\n'.join(output.split('\\n')[i: ]))\n", "code_toks_joined": "def _check_missing ( output ) : <NEWLINE> <INDENT> for i , line in enumerate ( output . split ( <STRING> ) ) : <NEWLINE> <INDENT> for msg in ( <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> ) : <NEWLINE> if msg in line . lower ( ) : <NEWLINE> raise BuildError ( <STRING> . join ( output . split ( <STRING> ) [ i : ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'\\n'", "'no package found for'", "'no packages found for'", "'missing dependency'", "'error:'", "'\\n'", "'\\n'"]}, "err_obj": {"msg": "expected an indented block"}}], ["b0c66aaa6775f9d8e05ee0166a89b0e6", {"code_string": "def _construct(cls, kwargs):\n    params = {}\n    for attr in('verify', 'cacert', 'cert', 'key', 'insecure',\n        'timeout', 'session', 'original_ip', 'user_agent'):\n        try:\n        params[attr] = kwargs.pop(attr)\n        except KeyError:\n        pass\n    return cls._make(** params)\n", "code_toks_joined": "def _construct ( cls , kwargs ) : <NEWLINE> <INDENT> params = { } <NEWLINE> for attr in ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> try : <NEWLINE> params [ attr ] = kwargs . pop ( attr ) <NEWLINE> except KeyError : <NEWLINE> pass <NEWLINE> <DEDENT> return cls . _make ( ** params ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'verify'", "'cacert'", "'cert'", "'key'", "'insecure'", "'timeout'", "'session'", "'original_ip'", "'user_agent'"]}, "err_obj": {"msg": "expected an indented block"}}], ["a67728275d0aa9d14094e6e5a76bdf2b", {"code_string": "def __iter__(self):\n    for row in range(self.num_rows):\n        for col in range(self.num_cols):\n            if row, col in self:\n                yield self[row, col]\n", "code_toks_joined": "def __iter__ ( self ) : <NEWLINE> <INDENT> for row in range ( self . num_rows ) : <NEWLINE> <INDENT> for col in range ( self . num_cols ) : <NEWLINE> <INDENT> if row , col in self : <NEWLINE> <INDENT> yield self [ row , col ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["34dbf4b23ab57d9b0f2656faba3ae0ab", {"code_string": "def run_gui():\n    \"\"\" Start Graphical User Interface \"\"\"\n    main_gui = Proximate_GUI()\n    for modulename in['community_gui', 'messaging_gui',\n        'notification_gui', 'filesharing_gui',\n        'messageboard_gui', 'filetransfergui',\n        'radar', 'keymanagement_gui', 'settings_gui']:\n        module = __import__(modulename)\n        try:\n        module.init_ui(main_gui)\n        except TypeError:\n        die('GUI module %s init() called with invalid arguments\\n' %(modulename))\n    proximatestate.load_external_plugins(ui = main_gui)\n    main_gui.run()\n", "code_toks_joined": "def run_gui ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> main_gui = Proximate_GUI ( ) <NEWLINE> for modulename in [ <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <STRING> ] : <NEWLINE> module = __import__ ( modulename ) <NEWLINE> try : <NEWLINE> module . init_ui ( main_gui ) <NEWLINE> except TypeError : <NEWLINE> die ( <STRING> % ( modulename ) ) <NEWLINE> <DEDENT> proximatestate . load_external_plugins ( ui = main_gui ) <NEWLINE> main_gui . run ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Start Graphical User Interface \"\"\"", "'community_gui'", "'messaging_gui'", "'notification_gui'", "'filesharing_gui'", "'messageboard_gui'", "'filetransfergui'", "'radar'", "'keymanagement_gui'", "'settings_gui'", "'GUI module %s init() called with invalid arguments\\n'"]}, "err_obj": {"msg": "expected an indented block"}}], ["92e4e182868051138d61acea26939d78", {"code_string": "def select(self query):\n    self.execute(query)\n    return self.fetchall()\n", "code_toks_joined": "def select ( self query ) : <NEWLINE> <INDENT> self . execute ( query ) <NEWLINE> return self . fetchall ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["e25bdd7284a31e36f06afd15bfda6e3d", {"code_string": "def retranslateUi(self, MainWindow):\n    MainWindow.setWindowTitle(_translate(\"MainWindow\", \"Orbis Map Alignment\", None))\n    self.gr_input.setTitle(_translate(\"MainWindow\", \"Input:\", None))\n    self.lb_run.setText(_translate(\"MainWindow\", \"Run\", None))\n    self.pb_run.setText(_translate(\"MainWindow\", \"choose run\", None))\n    self.lb_map.setText(_translate(\"MainWindow\", \"Map\", None))\n    self.pb_map.setText(_translate(\"MainWindow\", \"choose map\", None))\n    self.gr_stage.setTitle(_translate(\"MainWindow\", \"Stage Alignment:\", None))\n    self.tb_align.setTabText(self.tb_align.indexOf(self.tab_print), _translate(\"MainWindow\", \"Print\", None))\n    self.tb_align.setTabText(self.tb_align.indexOf(self.tab_wafer), _translate(\"MainWindow\", \"Wafer\", None))\n    self.lb_stagcoord.setText(_translate(\"MainWindow\", \"Use stage x, y, z from Orbis Vision.\", None))\n    item = self.tw_stage.verticalHeaderItem(0)\n    item.setText(_translate(\"MainWindow\", \"A\", None))\n    item = self.tw_stage.verticalHeaderItem(1)\n    item.setText(_translate(\"MainWindow\", \"B\", None))\n    item = self.tw_stage.verticalHeaderItem(2)\n    item.setText(_translate(\"MainWindow\", \"C\", None))\n    item = self.tw_stage.horizontalHeaderItem(0)\n    item.setText(_translate(\"MainWindow\", \"Sample *\", None))\n    item = self.tw_stage.horizontalHeaderItem(1)\n    item.setText(_translate(\"MainWindow\", \"StagX\", None))\n    item = self.tw_stage.horizontalHeaderItem(2)\n    item.setText(_translate(\"MainWindow\", \"StagY\", None))\n    __sortingEnabled = self.tw_stage.isSortingEnabled()\n    self.tw_stage.setSortingEnabled(False)\n    self.tw_stage.setSortingEnabled(__sortingEnabled)\n    self.lb_stagz.setText(_translate(\"MainWindow\", \"StagZ \", None))\n    self.cb_rotonly.setText(_translate(\"MainWindow\", \"Rot. only**\", None))\n    self.le_waferignore.setText(_translate(\"MainWindow\", \"<html><head/><body><p><span style=\\\" font-size:7pt;\\\">*Sample column ignored for wafer.</span></p></body></html>\", None))\n    self.lb_rotonly.setText(_translate(\"MainWindow\", \"<html><head/><body><p><span style=\\\" font-size:7pt;\\\">**Use </span><span style=\\\" font-size:7pt; text-decoration: overline;\\\">BC</span><span style=\\\" font-size:7pt;\\\"> for rotation only, no skew.</span></p></body></html>\", None))\n    self.gr_filter.setTitle(_translate(\"MainWindow\", \"Filters:\", None))\n    self.lb_keepcode.setText(_translate(\"MainWindow\", \"keep codes \", None))\n    self.lb_omitch.setText(_translate(\"MainWindow\", \"omit Ch\\'s \", None))\n    self.gr_platecoord.setTitle(_translate(\"MainWindow\", \"Platemap Coordinate Limits:\", None))\n    self.lb_xmin.setText(_translate(\"MainWindow\", \"x_min \", None))\n    self.lb_xmax.setText(_translate(\"MainWindow\", \"x_max \", None))\n    self.lb_ymin.setText(_translate(\"MainWindow\", \"y_min \", None))\n    self.lb_ymax.setText(_translate(\"MainWindow\", \"y_max \", None))\n    self.gr_skip.setTitle(_translate(\"MainWindow\", \"Skip Every:\", None))\n    self.lb_sampleskip.setText(_translate(\"MainWindow\", \" samples\", None))\n    self.lb_colskip.setText(_translate(\"MainWindow\", \" columns\", None))\n    self.lb_rowskip.setText(_translate(\"MainWindow\", \" rows\", None))\n    self.lb_atskip.setText(_translate(\"MainWindow\", \" at.%\", None))\n    self.gr_sample.setTitle(_translate(\"MainWindow\", \"Override Sample List:\", None))\n    self.lb_samplemin.setText(_translate(\"MainWindow\", \"sample_min \", None))\n    self.lb_samplemax.setText(_translate(\"MainWindow\", \"sample_max \", None))\n    self.pb_preview.setText(_translate(\"MainWindow\", \"Preview output (rotation/skew/points)\", None))\n    self.pb_alignsave.setText(_translate(\"MainWindow\", \"Generate stage and sample list\", None))\n    self.br_outputlog.setHtml(_translate(\"MainWindow\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , MainWindow ) : <NEWLINE> <INDENT> MainWindow . setWindowTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . gr_input . setTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . lb_run . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . pb_run . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . lb_map . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . pb_map . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . gr_stage . setTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . tb_align . setTabText ( self . tb_align . indexOf ( self . tab_print ) , _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . tb_align . setTabText ( self . tb_align . indexOf ( self . tab_wafer ) , _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . lb_stagcoord . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> item = self . tw_stage . verticalHeaderItem ( 0 ) <NEWLINE> item . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> item = self . tw_stage . verticalHeaderItem ( 1 ) <NEWLINE> item . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> item = self . tw_stage . verticalHeaderItem ( 2 ) <NEWLINE> item . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> item = self . tw_stage . horizontalHeaderItem ( 0 ) <NEWLINE> item . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> item = self . tw_stage . horizontalHeaderItem ( 1 ) <NEWLINE> item . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> item = self . tw_stage . horizontalHeaderItem ( 2 ) <NEWLINE> item . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> __sortingEnabled = self . tw_stage . isSortingEnabled ( ) <NEWLINE> self . tw_stage . setSortingEnabled ( False ) <NEWLINE> self . tw_stage . setSortingEnabled ( __sortingEnabled ) <NEWLINE> self . lb_stagz . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . cb_rotonly . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . le_waferignore . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . lb_rotonly . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . gr_filter . setTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . lb_keepcode . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . lb_omitch . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . gr_platecoord . setTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . lb_xmin . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . lb_xmax . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . lb_ymin . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . lb_ymax . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . gr_skip . setTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . lb_sampleskip . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . lb_colskip . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . lb_rowskip . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . lb_atskip . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . gr_sample . setTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . lb_samplemin . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . lb_samplemax . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . pb_preview . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . pb_alignsave . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . br_outputlog . setHtml ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"MainWindow\"", "\"Orbis Map Alignment\"", "\"MainWindow\"", "\"Input:\"", "\"MainWindow\"", "\"Run\"", "\"MainWindow\"", "\"choose run\"", "\"MainWindow\"", "\"Map\"", "\"MainWindow\"", "\"choose map\"", "\"MainWindow\"", "\"Stage Alignment:\"", "\"MainWindow\"", "\"Print\"", "\"MainWindow\"", "\"Wafer\"", "\"MainWindow\"", "\"Use stage x, y, z from Orbis Vision.\"", "\"MainWindow\"", "\"A\"", "\"MainWindow\"", "\"B\"", "\"MainWindow\"", "\"C\"", "\"MainWindow\"", "\"Sample *\"", "\"MainWindow\"", "\"StagX\"", "\"MainWindow\"", "\"StagY\"", "\"MainWindow\"", "\"StagZ \"", "\"MainWindow\"", "\"Rot. only**\"", "\"MainWindow\"", "\"<html><head/><body><p><span style=\\\" font-size:7pt;\\\">*Sample column ignored for wafer.</span></p></body></html>\"", "\"MainWindow\"", "\"<html><head/><body><p><span style=\\\" font-size:7pt;\\\">**Use </span><span style=\\\" font-size:7pt; text-decoration: overline;\\\">BC</span><span style=\\\" font-size:7pt;\\\"> for rotation only, no skew.</span></p></body></html>\"", "\"MainWindow\"", "\"Filters:\"", "\"MainWindow\"", "\"keep codes \"", "\"MainWindow\"", "\"omit Ch\\'s \"", "\"MainWindow\"", "\"Platemap Coordinate Limits:\"", "\"MainWindow\"", "\"x_min \"", "\"MainWindow\"", "\"x_max \"", "\"MainWindow\"", "\"y_min \"", "\"MainWindow\"", "\"y_max \"", "\"MainWindow\"", "\"Skip Every:\"", "\"MainWindow\"", "\" samples\"", "\"MainWindow\"", "\" columns\"", "\"MainWindow\"", "\" rows\"", "\"MainWindow\"", "\" at.%\"", "\"MainWindow\"", "\"Override Sample List:\"", "\"MainWindow\"", "\"sample_min \"", "\"MainWindow\"", "\"sample_max \"", "\"MainWindow\"", "\"Preview output (rotation/skew/points)\"", "\"MainWindow\"", "\"Generate stage and sample list\"", "\"MainWindow\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "window_span": [725, 733], "err_obj": {"msg": "unbalanced (){}[]"}}], ["10d09219c26b0441b183dc56ef06960e", {"code_string": "def test_ordering(self):\n    with original_warnings.catch_warnings(record = True,\n        module = self.module) as w:\n        self.module.resetwarnings()\n        self.module.filterwarnings(\"ignore\", category = UserWarning)\n        self.module.filterwarnings(\"error\", category = UserWarning,\n            append = True)\n            del w[: ]\n            try:\n        self.module.warn(\"FilterTests.test_ordering\", UserWarning)\n        except UserWarning:\n        self.fail(\"order handling for actions failed\")\n        self.assertEqual(len(w), 0)\n", "code_toks_joined": "def test_ordering ( self ) : <NEWLINE> <INDENT> with original_warnings . catch_warnings ( record = True , <NEWLINE> <INDENT> module = self . module ) as w : <NEWLINE> self . module . resetwarnings ( ) <NEWLINE> self . module . filterwarnings ( <STRING> , category = UserWarning ) <NEWLINE> self . module . filterwarnings ( <STRING> , category = UserWarning , <NEWLINE> <INDENT> append = True ) <NEWLINE> del w [ : ] <NEWLINE> try : <NEWLINE> <DEDENT> self . module . warn ( <STRING> , UserWarning ) <NEWLINE> except UserWarning : <NEWLINE> self . fail ( <STRING> ) <NEWLINE> self . assertEqual ( len ( w ) , 0 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"ignore\"", "\"error\"", "\"FilterTests.test_ordering\"", "\"order handling for actions failed\""]}, "err_obj": {"msg": "unexpected indent"}}], ["c4e1977369f40ef6a1d757a76046ca11", {"code_string": "def retranslateUi(self, DockWidget):\n    DockWidget.setWindowTitle(QtGui.QApplication.translate(\"DockWidget\", \"Messages\", None, QtGui.QApplication.UnicodeUTF8))\n    self.textEdit.setHtml(QtGui.QApplication.translate(\"DockWidget\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , DockWidget ) : <NEWLINE> <INDENT> DockWidget . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . textEdit . setHtml ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"DockWidget\"", "\"Messages\"", "\"DockWidget\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["435922b6e99c5c39feeed123649cfdba", {"code_string": "def create_gs_file(cls, file_name, csv):\n    \"\"\"Create a file.\"\"\"\n    bucket_name = app_identity.get_default_gcs_bucket_name()\n    bucket = '/' + bucket_name\n    filename = bucket + '/' + file_name\n    write_retry_params = gcs.RetryParams(backoff_factor = 1.1)\n    gcs_file = gcs.open(filename,\n        'w',\n        ,\n        content_type = 'text/csv',\n        retry_params = write_retry_params)\n    gcs_file.write(csv)\n    gcs_file.close()\n", "code_toks_joined": "def create_gs_file ( cls , file_name , csv ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> bucket_name = app_identity . get_default_gcs_bucket_name ( ) <NEWLINE> bucket = <STRING> + bucket_name <NEWLINE> filename = bucket + <STRING> + file_name <NEWLINE> write_retry_params = gcs . RetryParams ( backoff_factor = 1.1 ) <NEWLINE> gcs_file = gcs . open ( filename , <NEWLINE> <INDENT> <STRING> , <NEWLINE> , <NEWLINE> content_type = <STRING> , <NEWLINE> retry_params = write_retry_params ) <NEWLINE> <DEDENT> gcs_file . write ( csv ) <NEWLINE> gcs_file . close ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Create a file.\"\"\"", "'/'", "'/'", "'w'", "'text/csv'"]}, "err_obj": {"msg": "invalid syntax"}}], ["5e9bf536c900d8d5dac4109c9a018120", {"code_string": "def work_around_knc_module_bug(self):\n    \"\"\"Hack to unload the knc module before calling qsub in order to work\"\"\"\n    if self.knc:\n    unload_knc_proc = subprocess.Popen(\n        ['modulecmd', 'python', 'unload', 'craype-intel-knc'],\n        stdout = subprocess.PIPE\n        )\n        stdout, stderr = unload_knc_proc.communicate()\n        exec stdout\n", "code_toks_joined": "def work_around_knc_module_bug ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . knc : <NEWLINE> unload_knc_proc = subprocess . Popen ( <NEWLINE> <INDENT> [ <STRING> , <STRING> , <STRING> , <STRING> ] , <NEWLINE> stdout = subprocess . PIPE <NEWLINE> ) <NEWLINE> stdout , stderr = unload_knc_proc . communicate ( ) <NEWLINE> exec stdout <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Hack to unload the knc module before calling qsub in order to work\"\"\"", "'modulecmd'", "'python'", "'unload'", "'craype-intel-knc'"]}, "err_obj": {"msg": "expected an indented block"}}], ["3bd224f7dcdb948095c0f70b8da5c3a4", {"code_string": "def find_page(xml, index_line, page_number):\n    \"\"\"Find the FR page that includes the indexed line\"\"\"\n    for prtpage in takewhile(lambda p: p.sourceline < index_line,\n        xml.xpath('//PRTPAGE')):\n        if prtpage.get('P'):\n        page_number = int(prtpage.get('P'))\n    return page_number\n", "code_toks_joined": "def find_page ( xml , index_line , page_number ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for prtpage in takewhile ( lambda p : p . sourceline < index_line , <NEWLINE> <INDENT> xml . xpath ( <STRING> ) ) : <NEWLINE> if prtpage . get ( <STRING> ) : <NEWLINE> page_number = int ( prtpage . get ( <STRING> ) ) <NEWLINE> <DEDENT> return page_number <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Find the FR page that includes the indexed line\"\"\"", "'//PRTPAGE'", "'P'", "'P'"]}, "err_obj": {"msg": "expected an indented block"}}], ["acf4c7173055f20e7b6bdefc5dfbc1c3", {"code_string": "def getProducts(Id):\n    \"\"\"Get the properties for the associated group/contract combination\"\"\"\n        property_parameters = {\"contractId\": Id['contract']}\n        product_result = getResult('/papi/v0/products', property_parameters)\n        product_items = product_result['products']['items']\n", "code_toks_joined": "def getProducts ( Id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> property_parameters = { <STRING> : Id [ <STRING> ] } <NEWLINE> product_result = getResult ( <STRING> , property_parameters ) <NEWLINE> product_items = product_result [ <STRING> ] [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get the properties for the associated group/contract combination\"\"\"", "\"contractId\"", "'contract'", "'/papi/v0/products'", "'products'", "'items'"]}, "err_obj": {"msg": "unexpected indent"}}], ["3ffa5d92d90d4dabe6c8d5bca1809890", {"code_string": "class HouseCategorySelector(object):\n    def selectDice(self, dices):\n        mergedResult = TwoKinds(dices, 3, 2)\n            return mergedResult\n", "code_toks_joined": "class HouseCategorySelector ( object ) : <NEWLINE> <INDENT> def selectDice ( self , dices ) : <NEWLINE> <INDENT> mergedResult = TwoKinds ( dices , 3 , 2 ) <NEWLINE> <INDENT> return mergedResult <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["275176290b08548180e865d04ffacc0c", {"code_string": "def find(self, typ):\n    \"\"\"Returns a VLCObject for the given child.\"\"\"\n        t = self._o.find_object(typ)\n        if t is not None:\n            return VLCObject(t.info()['object-id'])\n        else:\n            return None\n", "code_toks_joined": "def find ( self , typ ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> t = self . _o . find_object ( typ ) <NEWLINE> if t is not None : <NEWLINE> <INDENT> return VLCObject ( t . info ( ) [ <STRING> ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns a VLCObject for the given child.\"\"\"", "'object-id'"]}, "err_obj": {"msg": "unexpected indent"}}], ["03cb30deb469d159c95c94d573458d85", {"code_string": "def help_download(self):\n    print(_(\"The download command fetches the given packages\\n\")\n        \"to the local filesystem.\")\n    print\n    print(_(\"Usage: download <pkgname> ...\"))\n", "code_toks_joined": "def help_download ( self ) : <NEWLINE> <INDENT> print ( _ ( <STRING> ) <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> print <NEWLINE> print ( _ ( <STRING> ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"The download command fetches the given packages\\n\"", "\"to the local filesystem.\"", "\"Usage: download <pkgname> ...\""]}, "err_obj": {"msg": "invalid syntax"}}], ["4c1c5bbe4933eb95f0ce56e1d573bfaf", {"code_string": "def retranslateUi(self, create_new_project):\n    _translate = QtCore.QCoreApplication.translate\n    create_new_project.setWindowTitle(_translate(\"create_new_project\", \"Create New Project\"))\n    self.newp_p1_title.setText(_translate(\"create_new_project\", \"New Safety Project\"))\n    self.newp_projectname_label.setText(_translate(\"create_new_project\", \"Project Name\"))\n    self.newp_add_server_title.setText(_translate(\"create_new_project\", \"Add server address\"))\n    self.newp_p2_add_server_description.setText(_translate(\"create_new_project\", \"Browse and select a server address to run processing.\\n\"\n", "code_toks_joined": "def retranslateUi ( self , create_new_project ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> create_new_project . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . newp_p1_title . setText ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . newp_projectname_label . setText ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . newp_add_server_title . setText ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . newp_p2_add_server_description . setText ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"create_new_project\"", "\"Create New Project\"", "\"create_new_project\"", "\"New Safety Project\"", "\"create_new_project\"", "\"Project Name\"", "\"create_new_project\"", "\"Add server address\"", "\"create_new_project\"", "\"Browse and select a server address to run processing.\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["bf6da40eece9c349995911c660662c9f", {"code_string": "def loadCode(self):\n    if len(self.getBody()):\n        exec self.getBody()\n        if vars().has_key(self.getType()):\n            self.main_class_obj = vars()[self.getType()]\n        else:\n            raise TypeError('Can not find class ' + self.getType() + ' in the module created from the body of the module ' + self.getOrigin())\n    else:\n        raise TypeError('The body of the Module ' + self.getType() + ' seems empty')\n    return self.main_class_obj\n", "code_toks_joined": "def loadCode ( self ) : <NEWLINE> <INDENT> if len ( self . getBody ( ) ) : <NEWLINE> <INDENT> exec self . getBody ( ) <NEWLINE> if vars ( ) . has_key ( self . getType ( ) ) : <NEWLINE> <INDENT> self . main_class_obj = vars ( ) [ self . getType ( ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise TypeError ( <STRING> + self . getType ( ) + <STRING> + self . getOrigin ( ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> raise TypeError ( <STRING> + self . getType ( ) + <STRING> ) <NEWLINE> <DEDENT> return self . main_class_obj <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Can not find class '", "' in the module created from the body of the module '", "'The body of the Module '", "' seems empty'"]}, "err_obj": {"msg": "invalid syntax"}}], ["a33f76cac7475ee23e51efe694165efc", {"code_string": "def deleteRelation(request, meetingob):\n    if request.method == 'GET':\n        relation_ajax_id = request.GET['relation_ajax_id']\n    relation = Relation.objects.filter(id = relation_ajax_id)\n    if relation:\n    relation.delete()\n    j = System.objects.get(id = meetingob);\n    t = get_template('gstudio/addrelnform_refresh.html')\n    html = t.render(Context({'meetingob': j}))\n    return HttpResponse(html)\n", "code_toks_joined": "def deleteRelation ( request , meetingob ) : <NEWLINE> <INDENT> if request . method == <STRING> : <NEWLINE> <INDENT> relation_ajax_id = request . GET [ <STRING> ] <NEWLINE> <DEDENT> relation = Relation . objects . filter ( id = relation_ajax_id ) <NEWLINE> if relation : <NEWLINE> relation . delete ( ) <NEWLINE> j = System . objects . get ( id = meetingob ) ; <NEWLINE> t = get_template ( <STRING> ) <NEWLINE> html = t . render ( Context ( { <STRING> : j } ) ) <NEWLINE> return HttpResponse ( html ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'GET'", "'relation_ajax_id'", "'gstudio/addrelnform_refresh.html'", "'meetingob'"]}, "err_obj": {"msg": "expected an indented block"}}], ["665ccdc336cfa073cd2cdc8f667b7d6f", {"code_string": "def _update_vm_widget_states(self):\n    page = self.widget(\"console-pages\").get_current_page()\n    if self.vm.is_runable():\n        self._show_vm_status_unavailable()\n    elif(page == _CONSOLE_PAGE_UNAVAILABLE or\n        page == _CONSOLE_PAGE_VIEWER):\n        if self._viewer and self._viewer.console_is_open():\n            self._activate_viewer_page()\n            else:\n            self._init_viewer()\n    self._refresh_widget_states()\n", "code_toks_joined": "def _update_vm_widget_states ( self ) : <NEWLINE> <INDENT> page = self . widget ( <STRING> ) . get_current_page ( ) <NEWLINE> if self . vm . is_runable ( ) : <NEWLINE> <INDENT> self . _show_vm_status_unavailable ( ) <NEWLINE> <DEDENT> elif ( page == _CONSOLE_PAGE_UNAVAILABLE or <NEWLINE> <INDENT> page == _CONSOLE_PAGE_VIEWER ) : <NEWLINE> if self . _viewer and self . _viewer . console_is_open ( ) : <NEWLINE> <INDENT> self . _activate_viewer_page ( ) <NEWLINE> else : <NEWLINE> self . _init_viewer ( ) <NEWLINE> <DEDENT> <DEDENT> self . _refresh_widget_states ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"console-pages\""]}, "err_obj": {"msg": "invalid syntax"}}], ["123ba4bf0ff0bef7876cdd4dd24164e5", {"code_string": "def runPackedApp(pathname):\n    runner = AppRunner()\n    runner.gotWindow = True\n    try:\n        runner.setP3DFilename(pathname, tokens = [], argv = [],\n            instanceId = 0, interactiveConsole = False)\n    except ArgumentError, e:\n        print(e.args[0])\n        sys.exit(1)\n", "code_toks_joined": "def runPackedApp ( pathname ) : <NEWLINE> <INDENT> runner = AppRunner ( ) <NEWLINE> runner . gotWindow = True <NEWLINE> try : <NEWLINE> <INDENT> runner . setP3DFilename ( pathname , tokens = [ ] , argv = [ ] , <NEWLINE> <INDENT> instanceId = 0 , interactiveConsole = False ) <NEWLINE> <DEDENT> <DEDENT> except ArgumentError , e : <NEWLINE> <INDENT> print ( e . args [ 0 ] ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["bcd99a3aa45b8b3bccffb050bd55508f", {"code_string": "def _recall_at_threshold(labels, predictions, weights, threshold, name = None):\n    with ops.name_scope(\n        name, 'recall_at_%s' % threshold,\n        (predictions, labels, weights, threshold)) as scope:\n        precision_tensor, update_op = metrics_lib.recall_at_thresholds(\n            labels = labels, predictions = predictions, thresholds = (threshold, ),\n            weights = weights, name = scope)\n            return array_ops.squeeze(precision_tensor), array_ops.squeeze(update_op)\n", "code_toks_joined": "def _recall_at_threshold ( labels , predictions , weights , threshold , name = None ) : <NEWLINE> <INDENT> with ops . name_scope ( <NEWLINE> <INDENT> name , <STRING> % threshold , <NEWLINE> ( predictions , labels , weights , threshold ) ) as scope : <NEWLINE> precision_tensor , update_op = metrics_lib . recall_at_thresholds ( <NEWLINE> <INDENT> labels = labels , predictions = predictions , thresholds = ( threshold , ) , <NEWLINE> weights = weights , name = scope ) <NEWLINE> return array_ops . squeeze ( precision_tensor ) , array_ops . squeeze ( update_op ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'recall_at_%s'"]}, "err_obj": {"msg": "unexpected indent"}}], ["30e5db7bc055e7f9a1cb30d349c0ce9c", {"code_string": "def retranslateUi(self, wizardStep1Dialog):\n    wizardStep1Dialog.setWindowTitle(QtGui.QApplication.translate(\"wizardStep1Dialog\", \"Project Wizard\", None, QtGui.QApplication.UnicodeUTF8))\n    self.nextWizButton.setText(QtGui.QApplication.translate(\"wizardStep1Dialog\", \"Next >>\", None, QtGui.QApplication.UnicodeUTF8))\n    self.cancelWizButton.setText(QtGui.QApplication.translate(\"wizardStep1Dialog\", \"Cancel\", None, QtGui.QApplication.UnicodeUTF8))\n    self.newWizGroupBox.setTitle(QtGui.QApplication.translate(\"wizardStep1Dialog\", \"New Project\", None, QtGui.QApplication.UnicodeUTF8))\n    self.nameLabel.setText(QtGui.QApplication.translate(\"wizardStep1Dialog\", \"Name\", None, QtGui.QApplication.UnicodeUTF8))\n    self.namePromptLabel.setText(QtGui.QApplication.translate(\"wizardStep1Dialog\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , wizardStep1Dialog ) : <NEWLINE> <INDENT> wizardStep1Dialog . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . nextWizButton . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . cancelWizButton . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . newWizGroupBox . setTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . nameLabel . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . namePromptLabel . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"wizardStep1Dialog\"", "\"Project Wizard\"", "\"wizardStep1Dialog\"", "\"Next >>\"", "\"wizardStep1Dialog\"", "\"Cancel\"", "\"wizardStep1Dialog\"", "\"New Project\"", "\"wizardStep1Dialog\"", "\"Name\"", "\"wizardStep1Dialog\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "window_span": [143, 155], "err_obj": {"msg": "unbalanced (){}[]"}}], ["1168a1337f2206d6e458e6db0660c8d4", {"code_string": "def tearDown(self)\n    logging.info('Terminating connection to remote inspector...')\n    self._remote_inspector_client.Stop()\n    logging.info('Connection to remote inspector terminated.')\n    perf.BasePerfTest.tearDown(self)\n", "code_toks_joined": "def tearDown ( self ) <NEWLINE> <INDENT> logging . info ( <STRING> ) <NEWLINE> self . _remote_inspector_client . Stop ( ) <NEWLINE> logging . info ( <STRING> ) <NEWLINE> perf . BasePerfTest . tearDown ( self ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Terminating connection to remote inspector...'", "'Connection to remote inspector terminated.'"]}, "err_obj": {"msg": "invalid syntax"}}], ["edda2897ec4dcbf1d8a637e2aee14ebd", {"code_string": "def doBluemixV1Auth(self):\n    log.debug(\"Connecting to Bluemix V1 swift at: {}\".format(self.swift_url))\n    authEncoded = base64.b64encode(bytes('{}:{}'.format(self.swift_user, self.swift_pw), \"utf-8\"))\n    authEncoded = \"Basic \" + authEncoded.decode(\"utf-8\")\n    response = requests.get(self.swift_url,\n    headers = {\"Authorization\": authEncoded})\n    log.debug(response.headers['x-auth-token'])\n    log.debug(response.headers['x-storage-url'])\n    self.conn = client.Connection(\n        preauthtoken = response.headers['x-auth-token'],\n        preauthurl = response.headers['x-storage-url']\n", "code_toks_joined": "def doBluemixV1Auth ( self ) : <NEWLINE> <INDENT> log . debug ( <STRING> . format ( self . swift_url ) ) <NEWLINE> authEncoded = base64 . b64encode ( bytes ( <STRING> . format ( self . swift_user , self . swift_pw ) , <STRING> ) ) <NEWLINE> authEncoded = <STRING> + authEncoded . decode ( <STRING> ) <NEWLINE> response = requests . get ( self . swift_url , <NEWLINE> headers = { <STRING> : authEncoded } ) <NEWLINE> log . debug ( response . headers [ <STRING> ] ) <NEWLINE> log . debug ( response . headers [ <STRING> ] ) <NEWLINE> self . conn = client . Connection ( <NEWLINE> <INDENT> preauthtoken = response . headers [ <STRING> ] , <NEWLINE> preauthurl = response . headers [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Connecting to Bluemix V1 swift at: {}\"", "'{}:{}'", "\"utf-8\"", "\"Basic \"", "\"utf-8\"", "\"Authorization\"", "'x-auth-token'", "'x-storage-url'", "'x-auth-token'", "'x-storage-url'"]}, "window_span": [109, 133], "err_obj": {"msg": "unbalanced (){}[]"}}], ["a807522aa2be9cb335a2b1ea59720c2d", {"code_string": "class ResourceExtension(object):\n    \"\"\"Add top level resources to the OpenStack API in <project_name>.\"\"\"\n    def __init__(self, collection, controller, parent = None,\n        collection_actions = None, member_actions = None,\n        custom_routes_fn = None):\n        if not collection_actions:\n        collection_actions = {}\n        if not member_actions:\n        member_actions = {}\n        self.collection = collection\n        self.controller = controller\n        self.parent = parent\n        self.collection_actions = collection_actions\n        self.member_actions = member_actions\n        self.custom_routes_fn = custom_routes_fn\n", "code_toks_joined": "class ResourceExtension ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , collection , controller , parent = None , <NEWLINE> <INDENT> collection_actions = None , member_actions = None , <NEWLINE> custom_routes_fn = None ) : <NEWLINE> if not collection_actions : <NEWLINE> collection_actions = { } <NEWLINE> if not member_actions : <NEWLINE> member_actions = { } <NEWLINE> self . collection = collection <NEWLINE> self . controller = controller <NEWLINE> self . parent = parent <NEWLINE> self . collection_actions = collection_actions <NEWLINE> self . member_actions = member_actions <NEWLINE> self . custom_routes_fn = custom_routes_fn <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Add top level resources to the OpenStack API in <project_name>.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["a804f2b264b0046cea7591c52dd63b81", {"code_string": "def list_instance_notes(self):\n    instance_notes = []\n    for vs in self._conn.Msvm_VirtualSystemSettingData(\n        ['ElementName', 'Notes'],\n        SettingType = self._VIRTUAL_SYSTEM_CURRENT_SETTINGS):\n        if vs.Notes is not None:\n        instance_notes.append(\n            (vs.ElementName, [v for v in vs.Notes.split('\\n') if v]))\n    return instance_notes\n", "code_toks_joined": "def list_instance_notes ( self ) : <NEWLINE> <INDENT> instance_notes = [ ] <NEWLINE> for vs in self . _conn . Msvm_VirtualSystemSettingData ( <NEWLINE> <INDENT> [ <STRING> , <STRING> ] , <NEWLINE> SettingType = self . _VIRTUAL_SYSTEM_CURRENT_SETTINGS ) : <NEWLINE> if vs . Notes is not None : <NEWLINE> instance_notes . append ( <NEWLINE> <INDENT> ( vs . ElementName , [ v for v in vs . Notes . split ( <STRING> ) if v ] ) ) <NEWLINE> <DEDENT> <DEDENT> return instance_notes <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'ElementName'", "'Notes'", "'\\n'"]}, "err_obj": {"msg": "expected an indented block"}}], ["59142aecfa2b520f578ed09a3c078da8", {"code_string": "def documents(self):\n    \"\"\"Retorna una llista de documents adjunts\"\"\"\n    data = []\n    obj = getattr(self.obj, self.header)\n    if(hasattr(obj, 'RegistrosDocumento') and\n        hasattr(obj.RegistrosDocumento, 'RegistroDoc')):\n        for d in obj.RegistrosDocumento.RegistroDoc:\n        data.append(C1.RegistroDoc(d))\n    return data\n", "code_toks_joined": "def documents ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> data = [ ] <NEWLINE> obj = getattr ( self . obj , self . header ) <NEWLINE> if ( hasattr ( obj , <STRING> ) and <NEWLINE> <INDENT> hasattr ( obj . RegistrosDocumento , <STRING> ) ) : <NEWLINE> for d in obj . RegistrosDocumento . RegistroDoc : <NEWLINE> data . append ( C1 . RegistroDoc ( d ) ) <NEWLINE> <DEDENT> return data <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Retorna una llista de documents adjunts\"\"\"", "'RegistrosDocumento'", "'RegistroDoc'"]}, "err_obj": {"msg": "expected an indented block"}}], ["3269995c859be1f51d3f30a385fbf6be", {"code_string": "def _checkParameterValuesBeforeExecuting(self):\n    for param in self.parameters:\n        if isinstance(param, (ParameterRaster, ParameterVector,\n            ParameterMultipleInput)):\n            if param.value:\n            if isinstance(param, ParameterMultipleInput):\n            inputlayers = param.value.split(';')\n            else:\n            inputlayers = [param.value]\n            for inputlayer in inputlayers:\n            obj = dataobjects.getObject(inputlayer)\n            if obj is None:\n            return \"Wrong parameter value: \" + param.value\n    return self.checkParameterValuesBeforeExecuting()\n", "code_toks_joined": "def _checkParameterValuesBeforeExecuting ( self ) : <NEWLINE> <INDENT> for param in self . parameters : <NEWLINE> <INDENT> if isinstance ( param , ( ParameterRaster , ParameterVector , <NEWLINE> <INDENT> ParameterMultipleInput ) ) : <NEWLINE> if param . value : <NEWLINE> if isinstance ( param , ParameterMultipleInput ) : <NEWLINE> inputlayers = param . value . split ( <STRING> ) <NEWLINE> else : <NEWLINE> inputlayers = [ param . value ] <NEWLINE> for inputlayer in inputlayers : <NEWLINE> obj = dataobjects . getObject ( inputlayer ) <NEWLINE> if obj is None : <NEWLINE> return <STRING> + param . value <NEWLINE> <DEDENT> <DEDENT> return self . checkParameterValuesBeforeExecuting ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["';'", "\"Wrong parameter value: \""]}, "err_obj": {"msg": "expected an indented block"}}], ["1f9869072a0459dd2acf431dd0ccd723", {"code_string": "class DatasetKFold(DatasetCV):\n    \"\"\"K-fold cross-validation.\"\"\"\n    def __init__(self, dataset, n_folds = 3, shuffle = False, random_state = None,\n        ** kwargs):\n        n = dataset.X.shape[0]\n        cv = KFold(n, n_folds = n_folds, shuffle = shuffle,\n            random_state = random_state)\n            super(DatasetKFold, self).__init__(dataset, cv, ** kwargs)\n", "code_toks_joined": "class DatasetKFold ( DatasetCV ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , dataset , n_folds = 3 , shuffle = False , random_state = None , <NEWLINE> <INDENT> ** kwargs ) : <NEWLINE> n = dataset . X . shape [ 0 ] <NEWLINE> cv = KFold ( n , n_folds = n_folds , shuffle = shuffle , <NEWLINE> <INDENT> random_state = random_state ) <NEWLINE> super ( DatasetKFold , self ) . __init__ ( dataset , cv , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"K-fold cross-validation.\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["4913f2d1941184233b0b1e0c3446dfc4", {"code_string": "def _get_exception_log_path():\n    \"\"\"Return the normalized path for the connection log, raising an\"\"\"\n    app = sys.argv[0].split('/')[- 1]\n    for exception_log in['/var/log/%s.errors' % app,\n        '/var/tmp/%s.errors' % app,\n        '/tmp/%s.errors' % app]:\n        if os.access(path.dirname(exception_log), os.W_OK):\n        return exception_log\n    return None\n", "code_toks_joined": "def _get_exception_log_path ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> app = sys . argv [ 0 ] . split ( <STRING> ) [ - 1 ] <NEWLINE> for exception_log in [ <STRING> % app , <NEWLINE> <INDENT> <STRING> % app , <NEWLINE> <STRING> % app ] : <NEWLINE> if os . access ( path . dirname ( exception_log ) , os . W_OK ) : <NEWLINE> return exception_log <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return the normalized path for the connection log, raising an\"\"\"", "'/'", "'/var/log/%s.errors'", "'/var/tmp/%s.errors'", "'/tmp/%s.errors'"]}, "err_obj": {"msg": "expected an indented block"}}], ["baacf97304ae9935967355edfecf74f2", {"code_string": "def _async(self, name, params):\n    task_ref = create_task(name)\n    task = _db_content['task'][task_ref]\n    func = name[len('Async.'): ]\n    try:\n        task['result'] = self.xenapi_request(func, params[1: ])\n        task['status'] = 'success'\n    except Failure, exc:\n        task['error_info'] = exc.details\n        task['status'] = 'failed'\n    task['finished'] = datetime.datetime.now()\n    return task_ref\n", "code_toks_joined": "def _async ( self , name , params ) : <NEWLINE> <INDENT> task_ref = create_task ( name ) <NEWLINE> task = _db_content [ <STRING> ] [ task_ref ] <NEWLINE> func = name [ len ( <STRING> ) : ] <NEWLINE> try : <NEWLINE> <INDENT> task [ <STRING> ] = self . xenapi_request ( func , params [ 1 : ] ) <NEWLINE> task [ <STRING> ] = <STRING> <NEWLINE> <DEDENT> except Failure , exc : <NEWLINE> <INDENT> task [ <STRING> ] = exc . details <NEWLINE> task [ <STRING> ] = <STRING> <NEWLINE> <DEDENT> task [ <STRING> ] = datetime . datetime . now ( ) <NEWLINE> return task_ref <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'task'", "'Async.'", "'result'", "'status'", "'success'", "'error_info'", "'status'", "'failed'", "'finished'"]}, "err_obj": {"msg": "invalid syntax"}}], ["a5253fec971821f10425f893208b97b2", {"code_string": "def get_Y(params, kd, n):\n    \"\"\"Description:Calculates the output timepath\"\"\"\n    alpha, A = params\n    if kd.ndim == 1:\n    Y = (kd ** alpha) *((A * n) **(1 - alpha))\n    elif kd.ndim == 2:\n    Y = (kd ** alpha) *(np.einsum(\"i,is->is\", A, n) **(1 - alpha))\n    return Y\n", "code_toks_joined": "def get_Y ( params , kd , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> alpha , A = params <NEWLINE> if kd . ndim == 1 : <NEWLINE> Y = ( kd ** alpha ) * ( ( A * n ) ** ( 1 - alpha ) ) <NEWLINE> elif kd . ndim == 2 : <NEWLINE> Y = ( kd ** alpha ) * ( np . einsum ( <STRING> , A , n ) ** ( 1 - alpha ) ) <NEWLINE> return Y <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Description:Calculates the output timepath\"\"\"", "\"i,is->is\""]}, "err_obj": {"msg": "expected an indented block"}}], ["35da7363cb0ab9de95e364878f8dc806", {"code_string": "def AListDir(path):\n    fd = os.Open(localPath(path))\n    with defer fd.Close():\n        vec = fd.Readdir(- 1)\n        z = [(i.Name(), i.IsDir(), i.Size(), i.ModTime().Unix()) for i in vec]\n        return z\n", "code_toks_joined": "def AListDir ( path ) : <NEWLINE> <INDENT> fd = os . Open ( localPath ( path ) ) <NEWLINE> with defer fd . Close ( ) : <NEWLINE> <INDENT> vec = fd . Readdir ( - 1 ) <NEWLINE> z = [ ( i . Name ( ) , i . IsDir ( ) , i . Size ( ) , i . ModTime ( ) . Unix ( ) ) for i in vec ] <NEWLINE> return z <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["97a260b81d06e2ac53535e5b54163269", {"code_string": "def kill_ie():\n    \"\"\"kill ie\"\"\"\n    return render_template('utils/kill-ie.html', blog_name = Setting.get_setting('blog_name', 'Plog')\n", "code_toks_joined": "def kill_ie ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return render_template ( <STRING> , blog_name = Setting . get_setting ( <STRING> , <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"kill ie\"\"\"", "'utils/kill-ie.html'", "'blog_name'", "'Plog'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c75c53fb1c1606d3f40024c09e53d73a", {"code_string": "def update_point(slug, point_type, point_id):\n    \"\"\"Update specific point by id.\"\"\"\n    timestamp = None\n    str_timestamp = request.values.get('timestamp', None)\n    if str_timestamp:\n        timestamp = datetime.strptime(str_timestamp, \"%Y-%m-%dT%H:%M:%S.%fZ\")\n    else:\n        timestamp = datetime.now()\n    try:\n        update = {\n            'set__points__S__title': request.values.get('title', None),\n            'set__points__S__desc': request.values.get('desc', None),\n            'set__points__S__altitude': request.values.get('altitude', None),\n            'set__points__S__speed': request.values.get('speed', None),\n            'set__points__S__direction': request.values.get('direction', None),\n            'set__points__S__latitude': SFLOAT(request.values.get('latitude', None)),\n            'set__points__S__longitude': SFLOAT(request.values.get('longitude', None)),\n            'set__points__S__resource': request.values.get('resource', None),\n            'set__points__S__point_type': point_type,\n            'set__points__S__timestamp': timestamp,\n            'set__points__S__delorme_id': SINT(request.values.get('delorme_id', None)),\n            'set__points__S__aio_id': SINT(request.values.get('aio_id', None)),\n            'set__points__S__instagram_id': request.values.get('instagram_id', None),\n            'set__points__S__hide': SBOOL(request.values.get('hide', None)),\n            'set__points__S__thumb': request.values.get('thumb', None),\n            'set__points__S__photo': request.values.get('photo', None),\n            'set__points__S__video': request.values.get('video', None),\n            'set__points__S__battery': SFLOAT(request.values.get('battery', None)),\n            'set__points__S__source': request.values.get('source', None)\n        }\n        updated_items = Adventure.objects(\n        if updated_items < 1:\n            return jsonify(error = 'point not found.'), 400\n        return jsonify(status = 'ok')\n    except TypeError as err:\n        logging.error(err)\n        abort(400)\n    except BadRequest as err:\n        logging.error(err)\n        abort(400)\n    return\n", "code_toks_joined": "def update_point ( slug , point_type , point_id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> timestamp = None <NEWLINE> str_timestamp = request . values . get ( <STRING> , None ) <NEWLINE> if str_timestamp : <NEWLINE> <INDENT> timestamp = datetime . strptime ( str_timestamp , <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> timestamp = datetime . now ( ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> update = { <NEWLINE> <INDENT> <STRING> : request . values . get ( <STRING> , None ) , <NEWLINE> <STRING> : request . values . get ( <STRING> , None ) , <NEWLINE> <STRING> : request . values . get ( <STRING> , None ) , <NEWLINE> <STRING> : request . values . get ( <STRING> , None ) , <NEWLINE> <STRING> : request . values . get ( <STRING> , None ) , <NEWLINE> <STRING> : SFLOAT ( request . values . get ( <STRING> , None ) ) , <NEWLINE> <STRING> : SFLOAT ( request . values . get ( <STRING> , None ) ) , <NEWLINE> <STRING> : request . values . get ( <STRING> , None ) , <NEWLINE> <STRING> : point_type , <NEWLINE> <STRING> : timestamp , <NEWLINE> <STRING> : SINT ( request . values . get ( <STRING> , None ) ) , <NEWLINE> <STRING> : SINT ( request . values . get ( <STRING> , None ) ) , <NEWLINE> <STRING> : request . values . get ( <STRING> , None ) , <NEWLINE> <STRING> : SBOOL ( request . values . get ( <STRING> , None ) ) , <NEWLINE> <STRING> : request . values . get ( <STRING> , None ) , <NEWLINE> <STRING> : request . values . get ( <STRING> , None ) , <NEWLINE> <STRING> : request . values . get ( <STRING> , None ) , <NEWLINE> <STRING> : SFLOAT ( request . values . get ( <STRING> , None ) ) , <NEWLINE> <STRING> : request . values . get ( <STRING> , None ) <NEWLINE> <DEDENT> } <NEWLINE> updated_items = Adventure . objects ( <NEWLINE> if updated_items < 1 : <NEWLINE> <INDENT> return jsonify ( error = <STRING> ) , 400 <NEWLINE> <DEDENT> return jsonify ( status = <STRING> ) <NEWLINE> <DEDENT> except TypeError as err : <NEWLINE> <INDENT> logging . error ( err ) <NEWLINE> abort ( 400 ) <NEWLINE> <DEDENT> except BadRequest as err : <NEWLINE> <INDENT> logging . error ( err ) <NEWLINE> abort ( 400 ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Update specific point by id.\"\"\"", "'timestamp'", "\"%Y-%m-%dT%H:%M:%S.%fZ\"", "'set__points__S__title'", "'title'", "'set__points__S__desc'", "'desc'", "'set__points__S__altitude'", "'altitude'", "'set__points__S__speed'", "'speed'", "'set__points__S__direction'", "'direction'", "'set__points__S__latitude'", "'latitude'", "'set__points__S__longitude'", "'longitude'", "'set__points__S__resource'", "'resource'", "'set__points__S__point_type'", "'set__points__S__timestamp'", "'set__points__S__delorme_id'", "'delorme_id'", "'set__points__S__aio_id'", "'aio_id'", "'set__points__S__instagram_id'", "'instagram_id'", "'set__points__S__hide'", "'hide'", "'set__points__S__thumb'", "'thumb'", "'set__points__S__photo'", "'photo'", "'set__points__S__video'", "'video'", "'set__points__S__battery'", "'battery'", "'set__points__S__source'", "'source'", "'point not found.'", "'ok'"]}, "window_span": [343, 415], "err_obj": {"msg": "unbalanced (){}[]"}}], ["ea41583cfc747b1e2619890a67647af7", {"code_string": "def maximize(points: [] Point) -> Point:\n    nxt = points[0]\n    slice = points[1: ]\n    for p in slice:\n        nxt = nxt.maximize(p)\n    return nxt\n", "code_toks_joined": "def maximize ( points : [ ] Point ) -> Point : <NEWLINE> <INDENT> nxt = points [ 0 ] <NEWLINE> slice = points [ 1 : ] <NEWLINE> for p in slice : <NEWLINE> <INDENT> nxt = nxt . maximize ( p ) <NEWLINE> <DEDENT> return nxt <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["04f1309693ddc4a2da96f594df379769", {"code_string": "def test_ping(request):\n    hostname = request.GET.get('host')\n        target = request.GET.get('target')\n    ping_reply = []\n    return HttpResponse(\"test1\")\n", "code_toks_joined": "def test_ping ( request ) : <NEWLINE> <INDENT> hostname = request . GET . get ( <STRING> ) <NEWLINE> <INDENT> target = request . GET . get ( <STRING> ) <NEWLINE> <DEDENT> ping_reply = [ ] <NEWLINE> return HttpResponse ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'host'", "'target'", "\"test1\""]}, "err_obj": {"msg": "unexpected indent"}}], ["46152675a147afae0562aba2d03b8cea", {"code_string": "class AnalyseSCFTask(AnalyseOptimizersTask):\n    def __init__(self, taskname, runs,\n        labels = None, tag = None, steps = 100, precision = 3, tunit = 'min'):\n        \"\"\"Analyse SCF runs.  \"\"\"\n        AnalyseOptimizersTask.__init__(self, taskname, runs,\n            labels, tag, steps, precision, tunit)\n            self.key_summary = 'energy'\n            self.key_plot = 'calculator steps'\n            self.plot_label = 'Summary of runs'\n            self.plot_xlabel = 'run'\n            self.plot_ylabel = self.key_plot\n", "code_toks_joined": "class AnalyseSCFTask ( AnalyseOptimizersTask ) : <NEWLINE> <INDENT> def __init__ ( self , taskname , runs , <NEWLINE> <INDENT> labels = None , tag = None , steps = 100 , precision = 3 , tunit = <STRING> ) : <NEWLINE> <STRING> <NEWLINE> AnalyseOptimizersTask . __init__ ( self , taskname , runs , <NEWLINE> <INDENT> labels , tag , steps , precision , tunit ) <NEWLINE> self . key_summary = <STRING> <NEWLINE> self . key_plot = <STRING> <NEWLINE> self . plot_label = <STRING> <NEWLINE> self . plot_xlabel = <STRING> <NEWLINE> self . plot_ylabel = self . key_plot <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'min'", "\"\"\"Analyse SCF runs.  \"\"\"", "'energy'", "'calculator steps'", "'Summary of runs'", "'run'"]}, "err_obj": {"msg": "unexpected indent"}}], ["05ce6ce9b54a6d1494275ec63800c4bc", {"code_string": "class tiempo(object):\n    \"\"\"docstring for .\"\"\"\n    def __init__(self, id_registro, fecha_hora_entrada):\n        self.id_registro = int(id_registro)\n        self.fecha_hora_entrada = fecha_hora_entrada\n    def obten_entradas(self):\n        \"\"\"Obtiene el maximo de entradas\"\"\"\n        if self.usuario is None:\n            raise ValueError(\"self.usuario no ha sido definido, primero llama  a self.set_usuario\")\n        if self.usuario is 'admin':\n            entradas = db_sql.session.query(Registro).filter and_(\n                Registro.fecha_hora_entrada <= '2017-03-10',\n                Registro.fecha_hora_entrada >= '2017-03-10')\n            return entradas\n", "code_toks_joined": "class tiempo ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , id_registro , fecha_hora_entrada ) : <NEWLINE> <INDENT> self . id_registro = int ( id_registro ) <NEWLINE> self . fecha_hora_entrada = fecha_hora_entrada <NEWLINE> <DEDENT> def obten_entradas ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . usuario is None : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> if self . usuario is <STRING> : <NEWLINE> <INDENT> entradas = db_sql . session . query ( Registro ) . filter and_ ( <NEWLINE> <INDENT> Registro . fecha_hora_entrada <= <STRING> , <NEWLINE> Registro . fecha_hora_entrada >= <STRING> ) <NEWLINE> <DEDENT> return entradas <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"docstring for .\"\"\"", "\"\"\"Obtiene el maximo de entradas\"\"\"", "\"self.usuario no ha sido definido, primero llama  a self.set_usuario\"", "'admin'", "'2017-03-10'", "'2017-03-10'"]}, "err_obj": {"msg": "invalid syntax"}}], ["c9205e66f809c74359bd664ae4a49c64", {"code_string": "def grammar_parse_query():\n    while True:\n        grammarQuery = raw_input('Would you like to do a grammar check? y/n: ')\n        if grammarQuery.lower() == 'y':\n    return True\n    break\n    elif grammarQuery.lower() == 'n':\n    return False\n    break\n", "code_toks_joined": "def grammar_parse_query ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> grammarQuery = raw_input ( <STRING> ) <NEWLINE> if grammarQuery . lower ( ) == <STRING> : <NEWLINE> <DEDENT> return True <NEWLINE> break <NEWLINE> elif grammarQuery . lower ( ) == <STRING> : <NEWLINE> return False <NEWLINE> break <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Would you like to do a grammar check? y/n: '", "'y'", "'n'"]}, "err_obj": {"msg": "expected an indented block"}}], ["5c90413636a21ae40ce11c83ace4a6ea", {"code_string": "class ConnectionUserAndKey(ConnectionKey):\n    \"\"\"Base connection class which accepts a ``user_id`` and ``key`` argument.\"\"\"\n    user_id = None\n    def __init__(self, user_id, key, secure = True, host = None, port = None,\n        url = None, timeout = None, proxy_url = None,\n        backoff = None, retry_delay = None):\n        super(ConnectionUserAndKey, self).__init__(key, secure = secure,\n            host = host, port = port,\n            url = url, timeout = timeout,\n            backoff = backoff,\n            retry_delay = retry_delay,\n            proxy_url = proxy_url)\n            self.user_id = user_id\n", "code_toks_joined": "class ConnectionUserAndKey ( ConnectionKey ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> user_id = None <NEWLINE> def __init__ ( self , user_id , key , secure = True , host = None , port = None , <NEWLINE> <INDENT> url = None , timeout = None , proxy_url = None , <NEWLINE> backoff = None , retry_delay = None ) : <NEWLINE> super ( ConnectionUserAndKey , self ) . __init__ ( key , secure = secure , <NEWLINE> <INDENT> host = host , port = port , <NEWLINE> url = url , timeout = timeout , <NEWLINE> backoff = backoff , <NEWLINE> retry_delay = retry_delay , <NEWLINE> proxy_url = proxy_url ) <NEWLINE> self . user_id = user_id <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Base connection class which accepts a ``user_id`` and ``key`` argument.\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["9ba4fd4c0a4b7ee736cca737a304f22f", {"code_string": "class BernoulliWithSigmoidProbs(Bernoulli):\n    \"\"\"Bernoulli with `probs = nn.sigmoid(logits)`.\"\"\"\n    def __init__(self,\n        logits = None,\n        dtype = dtypes.int32,\n        validate_args = False,\n        allow_nan_stats = True,\n        name = \"BernoulliWithSigmoidProbs\"):\n        parameters = locals()\n        with ops.name_scope(name):\n        super(BernoulliWithSigmoidProbs, self).__init__(\n        probs = nn.sigmoid(logits, name = \"sigmoid_probs\"),\n        dtype = dtype,\n        validate_args = validate_args,\n        allow_nan_stats = allow_nan_stats,\n        name = name)\n        self._parameters = parameters\n", "code_toks_joined": "class BernoulliWithSigmoidProbs ( Bernoulli ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , <NEWLINE> <INDENT> logits = None , <NEWLINE> dtype = dtypes . int32 , <NEWLINE> validate_args = False , <NEWLINE> allow_nan_stats = True , <NEWLINE> name = <STRING> ) : <NEWLINE> parameters = locals ( ) <NEWLINE> with ops . name_scope ( name ) : <NEWLINE> super ( BernoulliWithSigmoidProbs , self ) . __init__ ( <NEWLINE> probs = nn . sigmoid ( logits , name = <STRING> ) , <NEWLINE> dtype = dtype , <NEWLINE> validate_args = validate_args , <NEWLINE> allow_nan_stats = allow_nan_stats , <NEWLINE> name = name ) <NEWLINE> self . _parameters = parameters <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Bernoulli with `probs = nn.sigmoid(logits)`.\"\"\"", "\"BernoulliWithSigmoidProbs\"", "\"sigmoid_probs\""]}, "err_obj": {"msg": "expected an indented block"}}], ["2c0b6f17cf8ec66d89d8cae71b82473d", {"code_string": "def test_get_token(self):\n    with mock.patch.object(auth, \"get_token\", return_value = \"token123\"\n        ) as get_token:\n        response = self.app.post('/get_token',\n            data = {'user': 'test_user',\n                'password': 'test_pass'})\n                self.assertEqual(response.status_code, 200)\n                self.assertEqual(json.loads(response.data),\n                {'token': 'token123'})\n                get_token.assert_called_with('test_user', 'test_pass')\n", "code_toks_joined": "def test_get_token ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( auth , <STRING> , return_value = <STRING> <NEWLINE> <INDENT> ) as get_token : <NEWLINE> response = self . app . post ( <STRING> , <NEWLINE> <INDENT> data = { <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> } ) <NEWLINE> self . assertEqual ( response . status_code , 200 ) <NEWLINE> self . assertEqual ( json . loads ( response . data ) , <NEWLINE> { <STRING> : <STRING> } ) <NEWLINE> get_token . assert_called_with ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"get_token\"", "\"token123\"", "'/get_token'", "'user'", "'test_user'", "'password'", "'test_pass'", "'token'", "'token123'", "'test_user'", "'test_pass'"]}, "err_obj": {"msg": "unexpected indent"}}], ["6d0e84616be01d70055604232c4c0225", {"code_string": "class ForkingWSGIServer(ForkingMixIn, BaseWSGIServer):\n    \"\"\"A WSGI server that does forking.\"\"\"\n    multiprocess = True\n    def __init__(self, host, port, app, processes = 40, handler = None,\n        passthrough_errors = False, ssl_context = None):\n        BaseWSGIServer.__init__(self, host, port, app, handler,\n            passthrough_errors, ssl_context)\n            self.max_children = processes\n", "code_toks_joined": "class ForkingWSGIServer ( ForkingMixIn , BaseWSGIServer ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> multiprocess = True <NEWLINE> def __init__ ( self , host , port , app , processes = 40 , handler = None , <NEWLINE> <INDENT> passthrough_errors = False , ssl_context = None ) : <NEWLINE> BaseWSGIServer . __init__ ( self , host , port , app , handler , <NEWLINE> <INDENT> passthrough_errors , ssl_context ) <NEWLINE> self . max_children = processes <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"A WSGI server that does forking.\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["777ccf7508fc8512d280552f33d43e84", {"code_string": "def make_pipeline():\n    pipeline = [\n        {'$match': {'country': {'$exists': 1}}},\n        {'$unwind': '$isPartOf'},\n        {'$group': {'_id': {'country': '$country',\n            'regions': '$isPartOf',\n            },\n            'avg': {'$avg': '$population'}}},\n        {'$group': {'_id': '$_id.country',\n            'avgRegionalPopulation': {'$avg': '$avg'}}}\n    return pipeline\n", "code_toks_joined": "def make_pipeline ( ) : <NEWLINE> <INDENT> pipeline = [ <NEWLINE> <INDENT> { <STRING> : { <STRING> : { <STRING> : 1 } } } , <NEWLINE> { <STRING> : <STRING> } , <NEWLINE> { <STRING> : { <STRING> : { <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> } , <NEWLINE> <STRING> : { <STRING> : <STRING> } } } , <NEWLINE> <DEDENT> { <STRING> : { <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : { <STRING> : <STRING> } } } <NEWLINE> <DEDENT> <DEDENT> return pipeline <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'$match'", "'country'", "'$exists'", "'$unwind'", "'$isPartOf'", "'$group'", "'_id'", "'country'", "'$country'", "'regions'", "'$isPartOf'", "'avg'", "'$avg'", "'$population'", "'$group'", "'_id'", "'$_id.country'", "'avgRegionalPopulation'", "'$avg'", "'$avg'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["652ef2716e42299368a075cd2b41c56c", {"code_string": "def visit_address(self, node):\n    raise NotImplementedError, node.astext()\n    self.visit_docinfo_item(node, 'address', meta = None)\n", "code_toks_joined": "def visit_address ( self , node ) : <NEWLINE> <INDENT> raise NotImplementedError , node . astext ( ) <NEWLINE> self . visit_docinfo_item ( node , <STRING> , meta = None ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'address'"]}, "err_obj": {"msg": "invalid syntax"}}], ["3f635bfe9c649d1cca610648be76fc6b", {"code_string": "def iter_nbhs(board, (row, col)):\n    for dx, dy in NBCOORD:\n        nbx, nby = row + dx, col + dy\n        if 0 <= nbx < board.side and 0 <= nby < board.side:\n            yield nbx, nby\n", "code_toks_joined": "def iter_nbhs ( board , ( row , col ) ) : <NEWLINE> <INDENT> for dx , dy in NBCOORD : <NEWLINE> <INDENT> nbx , nby = row + dx , col + dy <NEWLINE> if 0 <= nbx < board . side and 0 <= nby < board . side : <NEWLINE> <INDENT> yield nbx , nby <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["7bf86a7331f3ff4d2567a75d899d200c", {"code_string": "def formatRequire(name, flags, evr):\n    s = name\n    if flags:\n        if flags &(rpm.RPMSENSE_LESS | rpm.RPMSENSE_GREATER |\n            rpm.RPMSENSE_EQUAL):\n            s = s + \" \"\n            if flags & rpm.RPMSENSE_LESS:\n            s = s + \"<\"\n            if flags & rpm.RPMSENSE_GREATER:\n            s = s + \">\"\n            if flags & rpm.RPMSENSE_EQUAL:\n            s = s + \"=\"\n            s = \"%s %s\" %(s, versionToString(evr))\n    return s\n", "code_toks_joined": "def formatRequire ( name , flags , evr ) : <NEWLINE> <INDENT> s = name <NEWLINE> if flags : <NEWLINE> <INDENT> if flags & ( rpm . RPMSENSE_LESS | rpm . RPMSENSE_GREATER | <NEWLINE> <INDENT> rpm . RPMSENSE_EQUAL ) : <NEWLINE> s = s + <STRING> <NEWLINE> if flags & rpm . RPMSENSE_LESS : <NEWLINE> s = s + <STRING> <NEWLINE> if flags & rpm . RPMSENSE_GREATER : <NEWLINE> s = s + <STRING> <NEWLINE> if flags & rpm . RPMSENSE_EQUAL : <NEWLINE> s = s + <STRING> <NEWLINE> s = <STRING> % ( s , versionToString ( evr ) ) <NEWLINE> <DEDENT> <DEDENT> return s <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\" \"", "\"<\"", "\">\"", "\"=\"", "\"%s %s\""]}, "err_obj": {"msg": "expected an indented block"}}], ["7416c1e73de4586920a4538b4d1d0a80", {"code_string": "class AutoRestRFC1123DateTimeTestServiceConfiguration(Configuration):\n    \"\"\"Configuration for AutoRestRFC1123DateTimeTestService\"\"\"\n    def __init__(\n        self, base_url = None):\n        if not base_url:\n        base_url = 'https://localhost'\n        super(AutoRestRFC1123DateTimeTestServiceConfiguration, self).__init__(base_url)\n        self.add_user_agent('autorestrfc1123datetimetestservice/{}'.format(VERSION))\n", "code_toks_joined": "class AutoRestRFC1123DateTimeTestServiceConfiguration ( Configuration ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( <NEWLINE> <INDENT> self , base_url = None ) : <NEWLINE> if not base_url : <NEWLINE> base_url = <STRING> <NEWLINE> super ( AutoRestRFC1123DateTimeTestServiceConfiguration , self ) . __init__ ( base_url ) <NEWLINE> self . add_user_agent ( <STRING> . format ( VERSION ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Configuration for AutoRestRFC1123DateTimeTestService\"\"\"", "'https://localhost'", "'autorestrfc1123datetimetestservice/{}'"]}, "err_obj": {"msg": "expected an indented block"}}], ["2da45c95e2c85326e976a79abd8cef74", {"code_string": "def test_docker_image_create_vm(admin_client, docker_context):\n    uuid = TEST_IMAGE_UUID\n    container = admin_client.create_container(name = 'test',\n        imageUuid = uuid,\n        startOnCreate = False)\n    container = wait_success(admin_client, container)\n    assert container.state == 'stopped'\n    admin_client.delete(container)\n    try:\n        admin_client.create_virtual_machine(name = 'test',\n            imageUuid = uuid)\n    except ApiError, e:\n        assert e.error.code == 'InvalidImageInstanceKind'\n", "code_toks_joined": "def test_docker_image_create_vm ( admin_client , docker_context ) : <NEWLINE> <INDENT> uuid = TEST_IMAGE_UUID <NEWLINE> container = admin_client . create_container ( name = <STRING> , <NEWLINE> <INDENT> imageUuid = uuid , <NEWLINE> startOnCreate = False ) <NEWLINE> <DEDENT> container = wait_success ( admin_client , container ) <NEWLINE> assert container . state == <STRING> <NEWLINE> admin_client . delete ( container ) <NEWLINE> try : <NEWLINE> <INDENT> admin_client . create_virtual_machine ( name = <STRING> , <NEWLINE> <INDENT> imageUuid = uuid ) <NEWLINE> <DEDENT> <DEDENT> except ApiError , e : <NEWLINE> <INDENT> assert e . error . code == <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'test'", "'stopped'", "'test'", "'InvalidImageInstanceKind'"]}, "err_obj": {"msg": "invalid syntax"}}], ["c02b296e1805827d79467c6c2b42c520", {"code_string": "def printTreeInorder(tree):\n    \"\"\"inorder traversing: contents appear in the order of left tree, root, and then the right tree\"\"\"\n    if tree == None: return\n    print('(',\n    printTreeInorder(tree.left)\n    print('(', tree.cargo, ')', )\n    printTreeInorder(tree.right)\n", "code_toks_joined": "def printTreeInorder ( tree ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if tree == None : return <NEWLINE> print ( <STRING> , <NEWLINE> printTreeInorder ( tree . left ) <NEWLINE> print ( <STRING> , tree . cargo , <STRING> , ) <NEWLINE> printTreeInorder ( tree . right ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"inorder traversing: contents appear in the order of left tree, root, and then the right tree\"\"\"", "'('", "'('", "')'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c44136342b38502cf8be7743a8500449", {"code_string": "def preview_clickHandler(self, x, y):\n    d.selections.append(PlacementClick(x, y)\n    if len(d.selections) == 3:\n        return 'createDimension: %s' % findUnusedObjectName('bendNote')\n", "code_toks_joined": "def preview_clickHandler ( self , x , y ) : <NEWLINE> <INDENT> d . selections . append ( PlacementClick ( x , y ) <NEWLINE> if len ( d . selections ) == 3 : <NEWLINE> <INDENT> return <STRING> % findUnusedObjectName ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'createDimension: %s'", "'bendNote'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["4bd978bcc0b531f028023624e461a676", {"code_string": "def close(self):\n    logging.debug('SSHChannelAdapter.close called')\n    for func in[self.proc.stdin.close, self.proc.stdout.close,\n        self.proc.wait]:\n        try:\n        func()\n        except OSError:\n        pass\n", "code_toks_joined": "def close ( self ) : <NEWLINE> <INDENT> logging . debug ( <STRING> ) <NEWLINE> for func in [ self . proc . stdin . close , self . proc . stdout . close , <NEWLINE> <INDENT> self . proc . wait ] : <NEWLINE> try : <NEWLINE> func ( ) <NEWLINE> except OSError : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'SSHChannelAdapter.close called'"]}, "err_obj": {"msg": "expected an indented block"}}], ["0950b28aac60d5fe694084ca2f076a1e", {"code_string": "def load_messages():\n    for filename in listdir(\"game/data\"):\n        with open(path.join(\"game/data\", filename) as fp:\n            messages.append(yaml.load(fp.read()))\n", "code_toks_joined": "def load_messages ( ) : <NEWLINE> <INDENT> for filename in listdir ( <STRING> ) : <NEWLINE> <INDENT> with open ( path . join ( <STRING> , filename ) as fp : <NEWLINE> <INDENT> messages . append ( yaml . load ( fp . read ( ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"game/data\"", "\"game/data\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["89aa8ee4032b75640ca6d2b9b9e4064d", {"code_string": "class EDNS0TLV(Packet):\n    name = \"DNS EDNS0 TLV\"\n    fields_desc = [ShortEnumField(\"optcode\", 0, {0: \"Reserved\", 1: \"LLQ\", 2: \"UL\", 3: \"NSID\", 4: \"Reserved\", 5: \"PING\"}),\n        FieldLenField(\"optlen\", None, \"optdata\", fmt = \"H\"),\n        StrLenField(\"optdata\", \"\", length_from = lambda pkt: pkt.optlen)]\n    def extract_padding(self, p):\n    return \"\", p\n", "code_toks_joined": "class EDNS0TLV ( Packet ) : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> fields_desc = [ ShortEnumField ( <STRING> , 0 , { 0 : <STRING> , 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> } ) , <NEWLINE> <INDENT> FieldLenField ( <STRING> , None , <STRING> , fmt = <STRING> ) , <NEWLINE> StrLenField ( <STRING> , <STRING> , length_from = lambda pkt : pkt . optlen ) ] <NEWLINE> <DEDENT> def extract_padding ( self , p ) : <NEWLINE> return <STRING> , p <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"DNS EDNS0 TLV\"", "\"optcode\"", "\"Reserved\"", "\"LLQ\"", "\"UL\"", "\"NSID\"", "\"Reserved\"", "\"PING\"", "\"optlen\"", "\"optdata\"", "\"H\"", "\"optdata\"", "\"\"", "\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["8753a0de691a2c20b60ea8d39834501d", {"code_string": "def checkGetCodePathsFrom(self, vw, fva, cbva):\n    graph = viv_graph.buildFunctionGraph(vw, fva)\n    paths = [path for path in viv_graph.getCodePathsFrom(graph, cbva)]\n    self.codepathsfrom = paths\n    self.assertGreater(len(self.codepaths), 150)\n    paths = [path for path in graph.getHierPathsFrom, ((cbva, ))]\n    self.hierpathsfrom = paths\n    self.assertGreater(len(self.codepaths), len(self.hierpathsfrom))\n", "code_toks_joined": "def checkGetCodePathsFrom ( self , vw , fva , cbva ) : <NEWLINE> <INDENT> graph = viv_graph . buildFunctionGraph ( vw , fva ) <NEWLINE> paths = [ path for path in viv_graph . getCodePathsFrom ( graph , cbva ) ] <NEWLINE> self . codepathsfrom = paths <NEWLINE> self . assertGreater ( len ( self . codepaths ) , 150 ) <NEWLINE> paths = [ path for path in graph . getHierPathsFrom , ( ( cbva , ) ) ] <NEWLINE> self . hierpathsfrom = paths <NEWLINE> self . assertGreater ( len ( self . codepaths ) , len ( self . hierpathsfrom ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["8008772ca93393d0908765effec4e7f0", {"code_string": "def test_proxy_with_xframe_options():\n    with CleanupEtcdFolders(\n        ['/upstreams/test-proxy-xframe-options',\n            '/hosts/test-proxy-xframe-options.abc.com']):\n            with MockHttpServer(handler = XFrameOptionsHttpHandler) as node1:\n        _add_node('test-proxy-xframe-options', 'node1', node1)\n        _add_location('test-proxy-xframe-options.abc.com',\n            'test-proxy-xframe-options')\n        sleep(PROXY_REFRESH_TIME)\n        for protocol in['http', 'https']:\n            resp = _request_proxy('test-proxy-xframe-options.abc.com',\n                protocol = protocol)\n            assert_equals(resp.status_code, 200)\n            assert_equals(resp.headers['X-Frame-Options'],\n                'SAMEORIGIN')\n", "code_toks_joined": "def test_proxy_with_xframe_options ( ) : <NEWLINE> <INDENT> with CleanupEtcdFolders ( <NEWLINE> <INDENT> [ <STRING> , <NEWLINE> <INDENT> <STRING> ] ) : <NEWLINE> with MockHttpServer ( handler = XFrameOptionsHttpHandler ) as node1 : <NEWLINE> <DEDENT> _add_node ( <STRING> , <STRING> , node1 ) <NEWLINE> _add_location ( <STRING> , <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> sleep ( PROXY_REFRESH_TIME ) <NEWLINE> for protocol in [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> resp = _request_proxy ( <STRING> , <NEWLINE> <INDENT> protocol = protocol ) <NEWLINE> <DEDENT> assert_equals ( resp . status_code , 200 ) <NEWLINE> assert_equals ( resp . headers [ <STRING> ] , <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'/upstreams/test-proxy-xframe-options'", "'/hosts/test-proxy-xframe-options.abc.com'", "'test-proxy-xframe-options'", "'node1'", "'test-proxy-xframe-options.abc.com'", "'test-proxy-xframe-options'", "'http'", "'https'", "'test-proxy-xframe-options.abc.com'", "'X-Frame-Options'", "'SAMEORIGIN'"]}, "err_obj": {"msg": "unindent does not match any outer indentation level"}}], ["9e88f12e225173c021f5d977f9038e11", {"code_string": "def ip_search(search):\n    global title\n    db = MySQLdb.connect(\"192.168.1.105\", \"d\", \"d\", \"cmdb\")\n    cursor = db.cursor()\n    if search:\n        sql = \"select * from server   where id=(select id from server where ip=\\\"%s\\\" order by  id  desc limit 1)\" % search\n        if cursor.execute(sql) == 0:\n            sql = \"select * from server  order by  id  desc limit 1\"\n            title = \"\u7ed3\u679c\u4e0d\u5b58\u5728\uff0c\u8fd4\u56de\u6700\u540e\u4e00\u884c\u8bb0\u5f55\"\n            else:\n            title = \"%s\" %(search)\n    else:\n        sql = \"select * from server order by  id  desc limit 1\"\n        title = \"\u8f93\u5165\u4e3a\u7a7a\uff0c\u8fd4\u56de\u6700\u540e\u4e00\u884c\u8bb0\u5f55\"\n    cursor.execute(sql)\n    all = cursor.fetchall()\n    db.close()\n    return all\n", "code_toks_joined": "def ip_search ( search ) : <NEWLINE> <INDENT> global title <NEWLINE> db = MySQLdb . connect ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> cursor = db . cursor ( ) <NEWLINE> if search : <NEWLINE> <INDENT> sql = <STRING> % search <NEWLINE> if cursor . execute ( sql ) == 0 : <NEWLINE> <INDENT> sql = <STRING> <NEWLINE> title = <STRING> <NEWLINE> else : <NEWLINE> title = <STRING> % ( search ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> sql = <STRING> <NEWLINE> title = <STRING> <NEWLINE> <DEDENT> cursor . execute ( sql ) <NEWLINE> all = cursor . fetchall ( ) <NEWLINE> db . close ( ) <NEWLINE> return all <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"192.168.1.105\"", "\"d\"", "\"d\"", "\"cmdb\"", "\"select * from server   where id=(select id from server where ip=\\\"%s\\\" order by  id  desc limit 1)\"", "\"select * from server  order by  id  desc limit 1\"", "\"\u7ed3\u679c\u4e0d\u5b58\u5728\uff0c\u8fd4\u56de\u6700\u540e\u4e00\u884c\u8bb0\u5f55\"", "\"%s\"", "\"select * from server order by  id  desc limit 1\"", "\"\u8f93\u5165\u4e3a\u7a7a\uff0c\u8fd4\u56de\u6700\u540e\u4e00\u884c\u8bb0\u5f55\""]}, "err_obj": {"msg": "invalid syntax"}}], ["4ca4f79728966ffd79ec60804edc03db", {"code_string": "def communicate(self, in_line):\n    \"\"\"Return output and error of the decoder for the given input.\"\"\"\n    err = []\n    output = \"\"\n    logging.info(\"Decoder_Deterministic:|\" + in_line + \"|\")\n    if in_line in self.source_hash:\n    logging.info(\"Match:|\" + in_line + \"|\")\n    output = self.target_list[self.source_hash[in_line]]\n    else:\n    logging.info(\"NO Match:|\" + in_line + \"|\")\n    return output, err\n", "code_toks_joined": "def communicate ( self , in_line ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> err = [ ] <NEWLINE> output = <STRING> <NEWLINE> logging . info ( <STRING> + in_line + <STRING> ) <NEWLINE> if in_line in self . source_hash : <NEWLINE> logging . info ( <STRING> + in_line + <STRING> ) <NEWLINE> output = self . target_list [ self . source_hash [ in_line ] ] <NEWLINE> else : <NEWLINE> logging . info ( <STRING> + in_line + <STRING> ) <NEWLINE> return output , err <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return output and error of the decoder for the given input.\"\"\"", "\"\"", "\"Decoder_Deterministic:|\"", "\"|\"", "\"Match:|\"", "\"|\"", "\"NO Match:|\"", "\"|\""]}, "err_obj": {"msg": "expected an indented block"}}], ["c53aa963da42e12e7f7d0aae1aff96cc", {"code_string": "def is_alarm_deleted(alarm_id):\n    conn = g_dbPool.connection()\n    cur = conn.cursor(MySQLdb.cursors.DictCursor)\n    try:\n        cur.execute(\"select * from alarm where id=%s and is_deleted=1\", (alarm_id, ))\n        rows = cur.fetchall()\n        if(len(rows) < 1):\n            return False\n        else:\n            return True\n    except MySQLdb.Error, e:\n        return False\n    finally:\n        cur.close()\n", "code_toks_joined": "def is_alarm_deleted ( alarm_id ) : <NEWLINE> <INDENT> conn = g_dbPool . connection ( ) <NEWLINE> cur = conn . cursor ( MySQLdb . cursors . DictCursor ) <NEWLINE> try : <NEWLINE> <INDENT> cur . execute ( <STRING> , ( alarm_id , ) ) <NEWLINE> rows = cur . fetchall ( ) <NEWLINE> if ( len ( rows ) < 1 ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> except MySQLdb . Error , e : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> cur . close ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"select * from alarm where id=%s and is_deleted=1\""]}, "err_obj": {"msg": "invalid syntax"}}], ["27883b9127b98b05ecd35271d72afdc7", {"code_string": "def categorias():\n    addDir('TV AO VIVO', '-', 7, 'http://goo.gl/PumvSm')\n    addDir('FILMES ON DEMAND', '-', 12, 'http://goo.gl/ZiWMZU')\n        addDir('SERIES ON DEMAND', '-', 5, 'http://goo.gl/KyoeaS')\n        addDir('FUTEBOL AO VIVO', '-', 13, 'http://goo.gl/S4C9LD')\n        addDir('SERIES 24HRS', url_base + '0BxN0DzFjIeCaY2Nlc1NqNFJDajQ', 4, 'http://goo.gl/VIlrvY')\n        addDir('DESENHOS 24HRS', url_base + '0BxN0DzFjIeCaVldOcVpJaFp1SW8', 4, 'http://goo.gl/rBsS8A')\n    addDir('RADIOS', url_base + '0BxN0DzFjIeCaWkxvUS1ZeHh3OWc', 4, 'http://goo.gl/pMM1Bg')\n", "code_toks_joined": "def categorias ( ) : <NEWLINE> <INDENT> addDir ( <STRING> , <STRING> , 7 , <STRING> ) <NEWLINE> addDir ( <STRING> , <STRING> , 12 , <STRING> ) <NEWLINE> <INDENT> addDir ( <STRING> , <STRING> , 5 , <STRING> ) <NEWLINE> addDir ( <STRING> , <STRING> , 13 , <STRING> ) <NEWLINE> addDir ( <STRING> , url_base + <STRING> , 4 , <STRING> ) <NEWLINE> addDir ( <STRING> , url_base + <STRING> , 4 , <STRING> ) <NEWLINE> <DEDENT> addDir ( <STRING> , url_base + <STRING> , 4 , <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'TV AO VIVO'", "'-'", "'http://goo.gl/PumvSm'", "'FILMES ON DEMAND'", "'-'", "'http://goo.gl/ZiWMZU'", "'SERIES ON DEMAND'", "'-'", "'http://goo.gl/KyoeaS'", "'FUTEBOL AO VIVO'", "'-'", "'http://goo.gl/S4C9LD'", "'SERIES 24HRS'", "'0BxN0DzFjIeCaY2Nlc1NqNFJDajQ'", "'http://goo.gl/VIlrvY'", "'DESENHOS 24HRS'", "'0BxN0DzFjIeCaVldOcVpJaFp1SW8'", "'http://goo.gl/rBsS8A'", "'RADIOS'", "'0BxN0DzFjIeCaWkxvUS1ZeHh3OWc'", "'http://goo.gl/pMM1Bg'"]}, "err_obj": {"msg": "unexpected indent"}}], ["5af1b05eaf50cda6a05f2560771fb71c", {"code_string": "def EnsurePageCacheTemperature(page, browser, previous_page = None):\n    temperature = page.cache_temperature\n    logging.info('PageCacheTemperature: %s', temperature)\n    for c in[AnyCacheManipulator, ColdCacheManipulator, WarmCacheManipulator,\n        HotCacheManipulator]:\n        if temperature == c.TEMPERATURE:\n        c.PrepareCache(page, browser, previous_page)\n        return\n    raise NotImplementedError('Unrecognized cache temperature: %s' % temperature)\n", "code_toks_joined": "def EnsurePageCacheTemperature ( page , browser , previous_page = None ) : <NEWLINE> <INDENT> temperature = page . cache_temperature <NEWLINE> logging . info ( <STRING> , temperature ) <NEWLINE> for c in [ AnyCacheManipulator , ColdCacheManipulator , WarmCacheManipulator , <NEWLINE> <INDENT> HotCacheManipulator ] : <NEWLINE> if temperature == c . TEMPERATURE : <NEWLINE> c . PrepareCache ( page , browser , previous_page ) <NEWLINE> return <NEWLINE> <DEDENT> raise NotImplementedError ( <STRING> % temperature ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'PageCacheTemperature: %s'", "'Unrecognized cache temperature: %s'"]}, "err_obj": {"msg": "expected an indented block"}}], ["20630b5ed07f5373ade5a5166203f491", {"code_string": "def cmos_checksum(rtc):\n    sum = 0\n    for i in range(0x10, 0x2e):\n    sum = sum + nvram_read(rtc, i)\n    nvram_write(rtc, 0x2e, (sum >> 8) & 0xff)\n    nvram_write(rtc, 0x2f, sum & 0xff)\n", "code_toks_joined": "def cmos_checksum ( rtc ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for i in range ( 0x10 , 0x2e ) : <NEWLINE> sum = sum + nvram_read ( rtc , i ) <NEWLINE> nvram_write ( rtc , 0x2e , ( sum >> 8 ) & 0xff ) <NEWLINE> nvram_write ( rtc , 0x2f , sum & 0xff ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["10ae7475812fc6c2897e42304bb11d5e", {"code_string": "def equals(self, other):\n    \"\"\"Determines if two Index objects contain the same elements.\"\"\"\n    if self.is_(other):\n        return True\n    if(not hasattr(other, 'inferred_type') or\n        other.inferred_type != 'timedelta64'):\n        try:\n        other = TimedeltaIndex(other)\n        except:\n        return False\n    return np.array_equal(self.asi8, other.asi8)\n", "code_toks_joined": "def equals ( self , other ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . is_ ( other ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if ( not hasattr ( other , <STRING> ) or <NEWLINE> <INDENT> other . inferred_type != <STRING> ) : <NEWLINE> try : <NEWLINE> other = TimedeltaIndex ( other ) <NEWLINE> except : <NEWLINE> return False <NEWLINE> <DEDENT> return np . array_equal ( self . asi8 , other . asi8 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Determines if two Index objects contain the same elements.\"\"\"", "'inferred_type'", "'timedelta64'"]}, "err_obj": {"msg": "expected an indented block"}}], ["5a2f6afe2d10a8e1944164d81a87b064", {"code_string": "def get_tests(self, ext):\n    \"\"\"Yield `CommandTest`s found under the self.path_to_test_specs dir.\"\"\"\n    specs = glob.glob(os.path.join(self.path_to_test_specs, ext + \"-solo\"))\n    if specs:\n        specs = specs[0: 1]\n    else:\n        specs = glob.glob(os.path.join(self.path_to_test_specs, ext)\n    return specs\n", "code_toks_joined": "def get_tests ( self , ext ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> specs = glob . glob ( os . path . join ( self . path_to_test_specs , ext + <STRING> ) ) <NEWLINE> if specs : <NEWLINE> <INDENT> specs = specs [ 0 : 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> specs = glob . glob ( os . path . join ( self . path_to_test_specs , ext ) <NEWLINE> <DEDENT> return specs <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Yield `CommandTest`s found under the self.path_to_test_specs dir.\"\"\"", "\"-solo\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["78fda80d160ff94a9ad6ad1149b6f37b", {"code_string": "def updateDigIfaceControl(self, a0):\n    sender = self.sender()\n    state = a0\n    if a0 > 0:\n        state += 1\n    log.debug(\"set %s to %d\" %(\n        self.DigIfaceControls[sender][0], state))\n        self.hw.setDiscrete(self.DigIfaceControls[sender][0], state)\n", "code_toks_joined": "def updateDigIfaceControl ( self , a0 ) : <NEWLINE> <INDENT> sender = self . sender ( ) <NEWLINE> state = a0 <NEWLINE> if a0 > 0 : <NEWLINE> <INDENT> state += 1 <NEWLINE> <DEDENT> log . debug ( <STRING> % ( <NEWLINE> <INDENT> self . DigIfaceControls [ sender ] [ 0 ] , state ) ) <NEWLINE> self . hw . setDiscrete ( self . DigIfaceControls [ sender ] [ 0 ] , state ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"set %s to %d\""]}, "err_obj": {"msg": "unexpected indent"}}], ["e53c7358e796a0f2687dbad8446f9e79", {"code_string": "def uniqidgen(ilist):\n    sha512h = hashlib.new('sha512')\n        \"function accepts a list; generates a SHA512 hash based on input from list (64char hex output)\"\n    for i in ilist:\n        sha512h.update(str(i))\n    return sha512h.hexdigest()\n", "code_toks_joined": "def uniqidgen ( ilist ) : <NEWLINE> <INDENT> sha512h = hashlib . new ( <STRING> ) <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> for i in ilist : <NEWLINE> <INDENT> sha512h . update ( str ( i ) ) <NEWLINE> <DEDENT> return sha512h . hexdigest ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'sha512'", "\"function accepts a list; generates a SHA512 hash based on input from list (64char hex output)\""]}, "err_obj": {"msg": "unexpected indent"}}], ["44db37288c5650003f5ab0160743ff09", {"code_string": "class ITest(unittest.TestCase):\n    def test_hello_word_get(self):\n        target = uri(\"http: //localhost: 8080/hello/tutu\")\n        response = request(target)\n        assert_that(response.status_code, is_(200)\n", "code_toks_joined": "class ITest ( unittest . TestCase ) : <NEWLINE> <INDENT> def test_hello_word_get ( self ) : <NEWLINE> <INDENT> target = uri ( <STRING> ) <NEWLINE> response = request ( target ) <NEWLINE> assert_that ( response . status_code , is_ ( 200 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"http: //localhost: 8080/hello/tutu\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e4464d9896212ea451e0161f810aed0a", {"code_string": "def mock_treat_devices_added(self, details, port, func_name):\n    \"\"\":param details: the details to return for the device\"\"\"\n    with mock.patch.object(self.agent.plugin_rpc, 'get_device_details',\n        return_value = details):\n        with mock.patch.object(self.agent.int_br, 'get_vif_port_by_id',\n            return_value = port):\n            with mock.patch.object(self.agent, func_name) as func:\n            self.assertFalse(self.agent.treat_devices_added([{}]))\n    return func.called\n", "code_toks_joined": "def mock_treat_devices_added ( self , details , port , func_name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with mock . patch . object ( self . agent . plugin_rpc , <STRING> , <NEWLINE> <INDENT> return_value = details ) : <NEWLINE> with mock . patch . object ( self . agent . int_br , <STRING> , <NEWLINE> <INDENT> return_value = port ) : <NEWLINE> with mock . patch . object ( self . agent , func_name ) as func : <NEWLINE> self . assertFalse ( self . agent . treat_devices_added ( [ { } ] ) ) <NEWLINE> <DEDENT> <DEDENT> return func . called <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\":param details: the details to return for the device\"\"\"", "'get_device_details'", "'get_vif_port_by_id'"]}, "err_obj": {"msg": "expected an indented block"}}], ["2f731c4f1323916cac83717c12326166", {"code_string": "def test_invaliddict(self):\n    for i in[\"<key><true/>k</key><string>compound key</string>\",\n        \"<key>single key</key>\",\n        \"<string>missing key</string>\",\n        \"<key>k1</key><string>v1</string><real>5.3</real>\"\n        \"<key>k1</key><key>k2</key><string>double key</string>\"]:\n        self.assertRaises(ValueError, plistlib.readPlistFromBytes,\n            (\"<plist><dict>%s</dict></plist>\" % i).encode())\n            self.assertRaises(ValueError, plistlib.readPlistFromBytes,\n            (\"<plist><array><dict>%s</dict></array></plist>\" % i).encode())\n", "code_toks_joined": "def test_invaliddict ( self ) : <NEWLINE> <INDENT> for i in [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> <NEWLINE> <STRING> ] : <NEWLINE> self . assertRaises ( ValueError , plistlib . readPlistFromBytes , <NEWLINE> <INDENT> ( <STRING> % i ) . encode ( ) ) <NEWLINE> self . assertRaises ( ValueError , plistlib . readPlistFromBytes , <NEWLINE> ( <STRING> % i ) . encode ( ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"<key><true/>k</key><string>compound key</string>\"", "\"<key>single key</key>\"", "\"<string>missing key</string>\"", "\"<key>k1</key><string>v1</string><real>5.3</real>\"", "\"<key>k1</key><key>k2</key><string>double key</string>\"", "\"<plist><dict>%s</dict></plist>\"", "\"<plist><array><dict>%s</dict></array></plist>\""]}, "err_obj": {"msg": "unexpected indent"}}], ["0b9352c2528129c4f8756f521376fd82", {"code_string": "def get_connection(self):\n    if self.__connection__ is None:\n        raise ConnectionlessObjectError, self\n    return self.__connection__\n", "code_toks_joined": "def get_connection ( self ) : <NEWLINE> <INDENT> if self . __connection__ is None : <NEWLINE> <INDENT> raise ConnectionlessObjectError , self <NEWLINE> <DEDENT> return self . __connection__ <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["a81a582665c0a6f742bd7a4126af1fec", {"code_string": "def with_hook():\n    hook = FileFinder.path_hook((MyLoader, ['.py']))\n    sys.path_hooks.insert(0 hook)\n    sys.path_importer_cache.clear()\n    invalidate_caches()\n    try:\n        yield\n    finally:\n        sys.path_hooks.remove(hook)\n", "code_toks_joined": "def with_hook ( ) : <NEWLINE> <INDENT> hook = FileFinder . path_hook ( ( MyLoader , [ <STRING> ] ) ) <NEWLINE> sys . path_hooks . insert ( 0 hook ) <NEWLINE> sys . path_importer_cache . clear ( ) <NEWLINE> invalidate_caches ( ) <NEWLINE> try : <NEWLINE> <INDENT> yield <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> sys . path_hooks . remove ( hook ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'.py'"]}, "err_obj": {"msg": "invalid syntax"}}], ["486692ecba00e95ea9b143175ebfa29d", {"code_string": "def assertHasattr(self, obj, attr, ignore):\n    ''' succeed iff hasattr(obj, attr)or attr in ignore.'''\n    if attr in ignore: return\n    if not hasattr(obj, attr): print \"???\", attr\n    self.failUnless(hasattr(obj, attr),\n        'expected hasattr(%r, %r)' %(obj, attr))\n", "code_toks_joined": "def assertHasattr ( self , obj , attr , ignore ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if attr in ignore : return <NEWLINE> if not hasattr ( obj , attr ) : print <STRING> , attr <NEWLINE> self . failUnless ( hasattr ( obj , attr ) , <NEWLINE> <INDENT> <STRING> % ( obj , attr ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''' succeed iff hasattr(obj, attr)or attr in ignore.'''", "\"???\"", "'expected hasattr(%r, %r)'"]}, "err_obj": {"msg": "invalid syntax"}}], ["88819a433d6b110ff4b062a01c2d44e1", {"code_string": "def main(argv):\n    flag.Parse()\n    say port\n    say '%d' % int(port)\n", "code_toks_joined": "def main ( argv ) : <NEWLINE> <INDENT> flag . Parse ( ) <NEWLINE> say port <NEWLINE> say <STRING> % int ( port ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'%d'"]}, "err_obj": {"msg": "invalid syntax"}}], ["3f38e3fe7d93f3d449a775a80deb1b7c", {"code_string": "def update(inp bot = None):\n    repo = Repo()\n    git = repo.git\n    try:\n        pull = git.pull()\n    except Exception as e:\n        return e\n    if \"\\n\" in pull:\n        return web.haste(pull)\n    else:\n        return pull\n", "code_toks_joined": "def update ( inp bot = None ) : <NEWLINE> <INDENT> repo = Repo ( ) <NEWLINE> git = repo . git <NEWLINE> try : <NEWLINE> <INDENT> pull = git . pull ( ) <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> <INDENT> return e <NEWLINE> <DEDENT> if <STRING> in pull : <NEWLINE> <INDENT> return web . haste ( pull ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return pull <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\\n\""]}, "err_obj": {"msg": "invalid syntax"}}], ["7ebc84b18b44e2ef4fdb576e6b420c28", {"code_string": "def authorize(self):\n    logging.info('%r: acquiring user request token' %(self, ))\n    assert(self.token)\n    tdata = self.request(parameters = {'ha_method': 'auth.accesstoken',\n        'strict_oauth_spec_response': 'true'})\n        self.token = oauth.OAuthToken.from_string(tdata)\n", "code_toks_joined": "def authorize ( self ) : <NEWLINE> <INDENT> logging . info ( <STRING> % ( self , ) ) <NEWLINE> assert ( self . token ) <NEWLINE> tdata = self . request ( parameters = { <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> } ) <NEWLINE> self . token = oauth . OAuthToken . from_string ( tdata ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'%r: acquiring user request token'", "'ha_method'", "'auth.accesstoken'", "'strict_oauth_spec_response'", "'true'"]}, "err_obj": {"msg": "unexpected indent"}}], ["da9e7edc09094dad034957c3fed463a8", {"code_string": "def aesctr_crypt(key1, key2, data):\n    key1 = SHA256HMAC(key1, data)\n    if len(key1) == 32 and len(key2) == 16:\n    crypto = AES.new(key1, AES.MODE_CTR, counter = lambda: key2)\n    encrypted = crypto.encrypt(data)\n    return encrypted\n    else:\n    return 'key length is not correct '\n", "code_toks_joined": "def aesctr_crypt ( key1 , key2 , data ) : <NEWLINE> <INDENT> key1 = SHA256HMAC ( key1 , data ) <NEWLINE> if len ( key1 ) == 32 and len ( key2 ) == 16 : <NEWLINE> crypto = AES . new ( key1 , AES . MODE_CTR , counter = lambda : key2 ) <NEWLINE> encrypted = crypto . encrypt ( data ) <NEWLINE> return encrypted <NEWLINE> else : <NEWLINE> return <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'key length is not correct '"]}, "err_obj": {"msg": "expected an indented block"}}], ["924ddb9d50e59dfd613523127bbf1ce6", {"code_string": "def do_times(self, line, user_called = True):\n    \"\"\"do_times\"\"\"\n    task_times = {}\n    print_out = \"\"\n    for task in self._tasks.values():\n        task_times[task.name] = self._format_timers(task)\n    for task, details in sorted(task_times.items(),\n        key = lambda x: x[1]):\n        for detail in details:\n        print_out += detail + \"\\n\"\n        print_out += \"\\n\"\n    if user_called:\n        print(print_out)\n    else:\n        return print_out\n", "code_toks_joined": "def do_times ( self , line , user_called = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> task_times = { } <NEWLINE> print_out = <STRING> <NEWLINE> for task in self . _tasks . values ( ) : <NEWLINE> <INDENT> task_times [ task . name ] = self . _format_timers ( task ) <NEWLINE> <DEDENT> for task , details in sorted ( task_times . items ( ) , <NEWLINE> <INDENT> key = lambda x : x [ 1 ] ) : <NEWLINE> for detail in details : <NEWLINE> print_out += detail + <STRING> <NEWLINE> print_out += <STRING> <NEWLINE> <DEDENT> if user_called : <NEWLINE> <INDENT> print ( print_out ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return print_out <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"do_times\"\"\"", "\"\"", "\"\\n\"", "\"\\n\""]}, "err_obj": {"msg": "expected an indented block"}}], ["6d295145c56ebdddf6b31dd0e5a9e8aa", {"code_string": "def _get_tracking_refs(self, cr, uid, picking, context = None):\n    tracking_refs = []\n    for pack in self._get_packages_from_picking(\n        self, cr, uid, picking, context = context):\n        if pack.parcel_tracking:\n        tracking_refs.append(pack.parcel_tracking)\n    return tracking_refs\n", "code_toks_joined": "def _get_tracking_refs ( self , cr , uid , picking , context = None ) : <NEWLINE> <INDENT> tracking_refs = [ ] <NEWLINE> for pack in self . _get_packages_from_picking ( <NEWLINE> <INDENT> self , cr , uid , picking , context = context ) : <NEWLINE> if pack . parcel_tracking : <NEWLINE> tracking_refs . append ( pack . parcel_tracking ) <NEWLINE> <DEDENT> return tracking_refs <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["3d1be1f1bb295c6f7dcee6055e712f1e", {"code_string": "def __setitem__(self, k, v):\n    if(isinstance(v, dict) and v[\"type\"] == \"controller\" and\n        self.host_filter in get_ip_addresses(v[\"host\"])):\n        v[\"command\"] = v[\"command\"].format(name = k,\n            bind = self.host_filter,\n            port = v[\"port\"])\n            self.queue.put_nowait((\"set\", (k, v)))\n            self.active_or_queued.add(k)\n", "code_toks_joined": "def __setitem__ ( self , k , v ) : <NEWLINE> <INDENT> if ( isinstance ( v , dict ) and v [ <STRING> ] == <STRING> and <NEWLINE> <INDENT> self . host_filter in get_ip_addresses ( v [ <STRING> ] ) ) : <NEWLINE> v [ <STRING> ] = v [ <STRING> ] . format ( name = k , <NEWLINE> <INDENT> bind = self . host_filter , <NEWLINE> port = v [ <STRING> ] ) <NEWLINE> self . queue . put_nowait ( ( <STRING> , ( k , v ) ) ) <NEWLINE> self . active_or_queued . add ( k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"type\"", "\"controller\"", "\"host\"", "\"command\"", "\"command\"", "\"port\"", "\"set\""]}, "err_obj": {"msg": "unexpected indent"}}], ["4f0a63c0db0e13907e120363a4c823db", {"code_string": "def checkJobAdded(self, jobId):\n    t0 = self.stubDir + 'added_%s.edb' % jobId\n    print('Execution DB checking if job added: %s' % t0)\n    if os.path.exists(t0): print '...job exists'\n    else: print '...job does not exist(yet?)'\n    return os.path.exists(t0)\n", "code_toks_joined": "def checkJobAdded ( self , jobId ) : <NEWLINE> <INDENT> t0 = self . stubDir + <STRING> % jobId <NEWLINE> print ( <STRING> % t0 ) <NEWLINE> if os . path . exists ( t0 ) : print <STRING> <NEWLINE> else : print <STRING> <NEWLINE> return os . path . exists ( t0 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'added_%s.edb'", "'Execution DB checking if job added: %s'", "'...job exists'", "'...job does not exist(yet?)'"]}, "err_obj": {"msg": "invalid syntax"}}], ["15abd4cf726218db5a652544a0469ed9", {"code_string": "def track_list_to_string(self, track_list):\n    \"\"\" Convert list of tracks to a string of track names or None if no tracks. This is used for debugging. \"\"\"\n    result = 'None'\n    if track_list:\n        result = '['\n        for track in track_list:\n        result += track.name + ', '\n        result = result[: len(result) - 2]\n    return result + ']'\n", "code_toks_joined": "def track_list_to_string ( self , track_list ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> result = <STRING> <NEWLINE> if track_list : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> for track in track_list : <NEWLINE> result += track . name + <STRING> <NEWLINE> result = result [ : len ( result ) - 2 ] <NEWLINE> <DEDENT> return result + <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Convert list of tracks to a string of track names or None if no tracks. This is used for debugging. \"\"\"", "'None'", "'['", "', '", "']'"]}, "err_obj": {"msg": "expected an indented block"}}], ["e3af5fbea866305b88da2be16d07f267", {"code_string": "s = '7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450'\nx = 0\nfor i in range(0, len(s):\n    p = 1\n    for n in s[i: i + 5]:\n        p *= int(n)\n    if p > x:\n        x = p\nprint(x)\n", "code_toks_joined": "s = <STRING> <NEWLINE> x = 0 <NEWLINE> for i in range ( 0 , len ( s ) : <NEWLINE> <INDENT> p = 1 <NEWLINE> for n in s [ i : i + 5 ] : <NEWLINE> <INDENT> p *= int ( n ) <NEWLINE> <DEDENT> if p > x : <NEWLINE> <INDENT> x = p <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["'7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["ea4945e45e233c9ce25557104cde07ae", {"code_string": "class JsGameBench(multi_page_benchmark.MultiPageBenchmark):\n    def MeasurePage(self, _, tab, results):\n        tab.runtime.Execute('UI.call({}, \"perftest\")')\n        js_is_done = 'document.getElementById(\"perfscore0\")!= null'\n        def _IsDone():\n            return bool(tab.runtime.Evaluate(js_is_done))\n        util.WaitFor(_IsDone, 1200)\n        js_get_results = 'document.getElementById(\"perfscore0\").innerHTML'\n        result = int(tab.runtime.Evaluate(js_get_results)\n        results.Add('Score', 'score(bigger is better)', result)\n", "code_toks_joined": "class JsGameBench ( multi_page_benchmark . MultiPageBenchmark ) : <NEWLINE> <INDENT> def MeasurePage ( self , _ , tab , results ) : <NEWLINE> <INDENT> tab . runtime . Execute ( <STRING> ) <NEWLINE> js_is_done = <STRING> <NEWLINE> def _IsDone ( ) : <NEWLINE> <INDENT> return bool ( tab . runtime . Evaluate ( js_is_done ) ) <NEWLINE> <DEDENT> util . WaitFor ( _IsDone , 1200 ) <NEWLINE> js_get_results = <STRING> <NEWLINE> result = int ( tab . runtime . Evaluate ( js_get_results ) <NEWLINE> results . Add ( <STRING> , <STRING> , result ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'UI.call({}, \"perftest\")'", "'document.getElementById(\"perfscore0\")!= null'", "'document.getElementById(\"perfscore0\").innerHTML'", "'Score'", "'score(bigger is better)'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["8b0979ea1a1e7f5175bd1b0cb632be77", {"code_string": "import ConfigParser\nconfig = ConfigParser.ConfigParser()\nconfig.read('configs/CONFIG.ini')\ntop_k_results = int(config.get('default', 'top_k'))\ndata_set_limit = int(config.get('default', 'data_set_limit')))\nfast_search = int(config.get('default', 'fast_search'))\n", "code_toks_joined": "import ConfigParser <NEWLINE> config = ConfigParser . ConfigParser ( ) <NEWLINE> config . read ( <STRING> ) <NEWLINE> top_k_results = int ( config . get ( <STRING> , <STRING> ) ) <NEWLINE> data_set_limit = int ( config . get ( <STRING> , <STRING> ) ) ) <NEWLINE> fast_search = int ( config . get ( <STRING> , <STRING> ) ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["'configs/CONFIG.ini'", "'default'", "'top_k'", "'default'", "'data_set_limit'", "'default'", "'fast_search'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["4c8486c04db0abfa35eb2d082dc06e74", {"code_string": "def set_freq(self, target_freq):\n    \"\"\"Set the center frequency we're interested in.\"\"\"\n    r = self.u.tune(0, self.subdev, target_freq)\n    if r:\n        self.myform['freq'].set_value(target_freq)\n        if self.show_debug_info:\n            self.myform['baseband'].set_value(r.baseband_freq)\n            self.myform['ddc'].set_value(r.dxc_freq)\n            if not self.options.waterfall and not self.options.oscilloscope:\n            self.scope.win.set_baseband_freq(target_freq)\n            return True\n    return False\n", "code_toks_joined": "def set_freq ( self , target_freq ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> r = self . u . tune ( 0 , self . subdev , target_freq ) <NEWLINE> if r : <NEWLINE> <INDENT> self . myform [ <STRING> ] . set_value ( target_freq ) <NEWLINE> if self . show_debug_info : <NEWLINE> <INDENT> self . myform [ <STRING> ] . set_value ( r . baseband_freq ) <NEWLINE> self . myform [ <STRING> ] . set_value ( r . dxc_freq ) <NEWLINE> if not self . options . waterfall and not self . options . oscilloscope : <NEWLINE> self . scope . win . set_baseband_freq ( target_freq ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Set the center frequency we're interested in.\"\"\"", "'freq'", "'baseband'", "'ddc'"]}, "err_obj": {"msg": "expected an indented block"}}], ["d4c7724d2b87eacc4ecc9f1a4ac89977", {"code_string": "def import_submodules(module):\n    \"\"\"Import all submodules and make them available in a dict.\"\"\"\n    submodules = {}\n    for loader, name, ispkg in pkgutil.iter_modules(module.__path__,\n        module.__name__ + '.'):\n        try:\n        submodule = import_module(name)\n        except ImportError as e:\n        logging.warning(\"Error importing %s\" % name)\n        logging.exception(e)\n        else:\n        parent, child = name.rsplit('.', 1)\n        submodules[child] = submodule\n    return submodules\n", "code_toks_joined": "def import_submodules ( module ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> submodules = { } <NEWLINE> for loader , name , ispkg in pkgutil . iter_modules ( module . __path__ , <NEWLINE> <INDENT> module . __name__ + <STRING> ) : <NEWLINE> try : <NEWLINE> submodule = import_module ( name ) <NEWLINE> except ImportError as e : <NEWLINE> logging . warning ( <STRING> % name ) <NEWLINE> logging . exception ( e ) <NEWLINE> else : <NEWLINE> parent , child = name . rsplit ( <STRING> , 1 ) <NEWLINE> submodules [ child ] = submodule <NEWLINE> <DEDENT> return submodules <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Import all submodules and make them available in a dict.\"\"\"", "'.'", "\"Error importing %s\"", "'.'"]}, "err_obj": {"msg": "expected an indented block"}}], ["ad9866ac500aa4a8b9d52d584c10b305", {"code_string": "def wordsplit(line):\n    list = []\n    word = \"\"\n    for c in line:\n    if c.isspace():\n        if len(word) > 0:\n    list.append(word)\n        word = \"\"\n        else:\n        word += c\n    if len(word) > 0:\n    list.append(word)\n    return list\n", "code_toks_joined": "def wordsplit ( line ) : <NEWLINE> <INDENT> list = [ ] <NEWLINE> word = <STRING> <NEWLINE> for c in line : <NEWLINE> if c . isspace ( ) : <NEWLINE> <INDENT> if len ( word ) > 0 : <NEWLINE> <DEDENT> list . append ( word ) <NEWLINE> <INDENT> word = <STRING> <NEWLINE> else : <NEWLINE> word += c <NEWLINE> <DEDENT> if len ( word ) > 0 : <NEWLINE> list . append ( word ) <NEWLINE> return list <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"", "\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["afeddba89ab6d5e6fd428627ae65bb08", {"code_string": "def complete(name, imports):\n    \"\"\"Complete TEXT in NAMESPACE and print a Lisp list of completions.\"\"\"\n    import __main__, keyword\n    def class_members(object):\n        names = dir(object)\n        if hasattr(object, '__bases__'):\n            for super in object.__bases__:\n                names = class_members(super)\n        return names\n    names = set([])\n    base = None\n    try:\n        dict = __main__.__dict__.copy()\n        if imports: exec imports in dict\n        l = len(name)\n        if not \".\" in name:\n            for src in[dir(__builtins__), keyword.kwlist, dict.keys()]:\n                for elt in src:\n                    if elt[: l] == name: names.add(elt)\n        else:\n            base = name[: name.rfind('.')]\n            name = name[name.rfind('.') + 1: ]\n            try:\n                object = eval(base, dict)\n                names = set(dir(object))\n                if hasattr(object, '__class__'):\n                    names.add('__class__')\n                    names.update(class_members(object))\n            except: names = all_names(dict)\n    except:\n        print(sys.exc_info())\n        names = []\n    l = len(name)\n    print('_emacs_out (',\n    for n in names:\n        if name == n[: l]:\n            if base: print '\"%s.%s\"' %(base, n),\n            else: print '\"%s\"' % n,\n    print(')')\n", "code_toks_joined": "def complete ( name , imports ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import __main__ , keyword <NEWLINE> def class_members ( object ) : <NEWLINE> <INDENT> names = dir ( object ) <NEWLINE> if hasattr ( object , <STRING> ) : <NEWLINE> <INDENT> for super in object . __bases__ : <NEWLINE> <INDENT> names = class_members ( super ) <NEWLINE> <DEDENT> <DEDENT> return names <NEWLINE> <DEDENT> names = set ( [ ] ) <NEWLINE> base = None <NEWLINE> try : <NEWLINE> <INDENT> dict = __main__ . __dict__ . copy ( ) <NEWLINE> if imports : exec imports in dict <NEWLINE> l = len ( name ) <NEWLINE> if not <STRING> in name : <NEWLINE> <INDENT> for src in [ dir ( __builtins__ ) , keyword . kwlist , dict . keys ( ) ] : <NEWLINE> <INDENT> for elt in src : <NEWLINE> <INDENT> if elt [ : l ] == name : names . add ( elt ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> base = name [ : name . rfind ( <STRING> ) ] <NEWLINE> name = name [ name . rfind ( <STRING> ) + 1 : ] <NEWLINE> try : <NEWLINE> <INDENT> object = eval ( base , dict ) <NEWLINE> names = set ( dir ( object ) ) <NEWLINE> if hasattr ( object , <STRING> ) : <NEWLINE> <INDENT> names . add ( <STRING> ) <NEWLINE> names . update ( class_members ( object ) ) <NEWLINE> <DEDENT> <DEDENT> except : names = all_names ( dict ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> print ( sys . exc_info ( ) ) <NEWLINE> names = [ ] <NEWLINE> <DEDENT> l = len ( name ) <NEWLINE> print ( <STRING> , <NEWLINE> for n in names : <NEWLINE> <INDENT> if name == n [ : l ] : <NEWLINE> <INDENT> if base : print <STRING> % ( base , n ) , <NEWLINE> else : print <STRING> % n , <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Complete TEXT in NAMESPACE and print a Lisp list of completions.\"\"\"", "'__bases__'", "\".\"", "'.'", "'.'", "'__class__'", "'__class__'", "'_emacs_out ('", "'\"%s.%s\"'", "'\"%s\"'", "')'"]}, "window_span": [283, 334], "err_obj": {"msg": "unbalanced (){}[]"}}], ["74a694cdae7d607f312a0d035fb7c5fc", {"code_string": "def letMove():\n    if mode == 'normal':\n    vImposed = [0, - 1, 0]\n    if O.iter < 25 and O.iter > 14:\n        vImposed = [0, 1, 0]\n    if mode == 'tangential':\n    vImposed = [1, 0, 0]\n    upperSphere.state.vel = vImposed\n    upperSphere.state.pos = upperSphere.state.pos + upperSphere.state.vel * O.dt\n", "code_toks_joined": "def letMove ( ) : <NEWLINE> <INDENT> if mode == <STRING> : <NEWLINE> vImposed = [ 0 , - 1 , 0 ] <NEWLINE> if O . iter < 25 and O . iter > 14 : <NEWLINE> <INDENT> vImposed = [ 0 , 1 , 0 ] <NEWLINE> <DEDENT> if mode == <STRING> : <NEWLINE> vImposed = [ 1 , 0 , 0 ] <NEWLINE> upperSphere . state . vel = vImposed <NEWLINE> upperSphere . state . pos = upperSphere . state . pos + upperSphere . state . vel * O . dt <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'normal'", "'tangential'"]}, "err_obj": {"msg": "expected an indented block"}}], ["6b32a8a9608330f680377e6e6e0411a0", {"code_string": "def headers(self):\n    headers = DataTablesHeader(\n        DataTablesColumn(\"Name\", span = 3),\n        DataTablesColumn(\"Organization\", span = 2),\n        DataTablesColumn(\"Category\", span = 2),\n        DataTablesColumn(\"Copies\", span = 2),\n        DataTablesColumn(\"License\", span = 2),\n        DataTablesColumn(\"Last Modified\", span = 3, sort_type = DTSortType.NUMERIC)\n    )\n    headers.custom_sort = [[1, 'asc']\n    return headers\n", "code_toks_joined": "def headers ( self ) : <NEWLINE> <INDENT> headers = DataTablesHeader ( <NEWLINE> <INDENT> DataTablesColumn ( <STRING> , span = 3 ) , <NEWLINE> DataTablesColumn ( <STRING> , span = 2 ) , <NEWLINE> DataTablesColumn ( <STRING> , span = 2 ) , <NEWLINE> DataTablesColumn ( <STRING> , span = 2 ) , <NEWLINE> DataTablesColumn ( <STRING> , span = 2 ) , <NEWLINE> DataTablesColumn ( <STRING> , span = 3 , sort_type = DTSortType . NUMERIC ) <NEWLINE> <DEDENT> ) <NEWLINE> headers . custom_sort = [ [ 1 , <STRING> ] <NEWLINE> return headers <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Name\"", "\"Organization\"", "\"Category\"", "\"Copies\"", "\"License\"", "\"Last Modified\"", "'asc'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["df37bbe75d94d5dbbfe05269b1b90b5d", {"code_string": "__author__ = 'Mike Portanova'\nimport csv\nimport pprint\nimport json\nimport urllib2\nimport sys\nimport pandas as pd\n\"\"\"pass either articles or places as a command line argument to pull data and dump\"\"\"\nif sys.argv[1] == \"articles\":\n    URL = \"https://dataclips.heroku.com/wzskvliqdvaythtknaesjdtctlyn-articles-by-pub-date.json\"\nelse:\n    URL = \"https://dataclips.heroku.com/nqstqsrwkmxprgiqfxabkicreawt-places-by-pub-date.json\"\ndef createDataFrame(URL)\n    response = json.loads(urllib2.urlopen(URL).read())\n    df = pd.DataFrame(response['values'])\n", "code_toks_joined": "__author__ = <STRING> <NEWLINE> import csv <NEWLINE> import pprint <NEWLINE> import json <NEWLINE> import urllib2 <NEWLINE> import sys <NEWLINE> import pandas as pd <NEWLINE> <STRING> <NEWLINE> if sys . argv [ 1 ] == <STRING> : <NEWLINE> <INDENT> URL = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> URL = <STRING> <NEWLINE> <DEDENT> def createDataFrame ( URL ) <NEWLINE> <INDENT> response = json . loads ( urllib2 . urlopen ( URL ) . read ( ) ) <NEWLINE> df = pd . DataFrame ( response [ <STRING> ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Mike Portanova'", "\"\"\"pass either articles or places as a command line argument to pull data and dump\"\"\"", "\"articles\"", "\"https://dataclips.heroku.com/wzskvliqdvaythtknaesjdtctlyn-articles-by-pub-date.json\"", "\"https://dataclips.heroku.com/nqstqsrwkmxprgiqfxabkicreawt-places-by-pub-date.json\"", "'values'"]}, "err_obj": {"msg": "invalid syntax"}}], ["1e28955408428e8691c5eec2e42d17e8", {"code_string": "def triangle_wave():\n    scope = m3t.M3Scope2(xwidth = 100, yrange = None)\n    des = []\n    cc = 1.0\n    scale = 5000\n    for i in range(10):\n    des.append(cc)\n    cc = cc * - 1.0\n    print('Enable power. Hit enter to continue')\n    raw_input()\n    for ii in range(len(des)):\n    print(ii, 'Des: ', des[ii])\n    ramp_to_torque(des[ii] * scale, scope)\n", "code_toks_joined": "def triangle_wave ( ) : <NEWLINE> <INDENT> scope = m3t . M3Scope2 ( xwidth = 100 , yrange = None ) <NEWLINE> des = [ ] <NEWLINE> cc = 1.0 <NEWLINE> scale = 5000 <NEWLINE> for i in range ( 10 ) : <NEWLINE> des . append ( cc ) <NEWLINE> cc = cc * - 1.0 <NEWLINE> print ( <STRING> ) <NEWLINE> raw_input ( ) <NEWLINE> for ii in range ( len ( des ) ) : <NEWLINE> print ( ii , <STRING> , des [ ii ] ) <NEWLINE> ramp_to_torque ( des [ ii ] * scale , scope ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Enable power. Hit enter to continue'", "'Des: '"]}, "err_obj": {"msg": "expected an indented block"}}], ["c91b3f460d2f621b248a391747ca94fc", {"code_string": "def test_requires_non_coroutine(self):\n    with unittest.mock.patch(\n        \"asyncio.iscoroutinefunction\") as iscoroutinefunction:\n        iscoroutinefunction.return_value = True\n        with self.assertRaisesRegex(\n            TypeError,\n            \"must not be a coroutine function\"):\n        self.decorator(unittest.mock.sentinel.cb)\n    iscoroutinefunction.assert_called_with(\n        unittest.mock.sentinel.cb,\n    )\n", "code_toks_joined": "def test_requires_non_coroutine ( self ) : <NEWLINE> <INDENT> with unittest . mock . patch ( <NEWLINE> <INDENT> <STRING> ) as iscoroutinefunction : <NEWLINE> iscoroutinefunction . return_value = True <NEWLINE> with self . assertRaisesRegex ( <NEWLINE> <INDENT> TypeError , <NEWLINE> <STRING> ) : <NEWLINE> <DEDENT> self . decorator ( unittest . mock . sentinel . cb ) <NEWLINE> <DEDENT> iscoroutinefunction . assert_called_with ( <NEWLINE> <INDENT> unittest . mock . sentinel . cb , <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"asyncio.iscoroutinefunction\"", "\"must not be a coroutine function\""]}, "err_obj": {"msg": "expected an indented block"}}], ["f44282953d3ac6d20e1f69829062f8fa", {"code_string": "class FakeCiscoFCSanLookupService(object):\n    def get_device_mapping_from_network(self,\n        initiator_wwn_list,\n        target_wwn_list):\n        device_map = {}\n        initiators = []\n        targets = []\n        for i in initiator_wwn_list:\n        if(i in _initiator_ns_map[_fabric_wwn]):\n        initiators.append(i)\n        for t in target_wwn_list:\n        if(t in _target_ns_map[_fabric_wwn]):\n        targets.append(t)\n        device_map[_fabric_wwn] = {\n        'initiator_port_wwn_list': initiators,\n        'target_port_wwn_list': targets}\n        return device_map\n", "code_toks_joined": "class FakeCiscoFCSanLookupService ( object ) : <NEWLINE> <INDENT> def get_device_mapping_from_network ( self , <NEWLINE> <INDENT> initiator_wwn_list , <NEWLINE> target_wwn_list ) : <NEWLINE> device_map = { } <NEWLINE> initiators = [ ] <NEWLINE> targets = [ ] <NEWLINE> for i in initiator_wwn_list : <NEWLINE> if ( i in _initiator_ns_map [ _fabric_wwn ] ) : <NEWLINE> initiators . append ( i ) <NEWLINE> for t in target_wwn_list : <NEWLINE> if ( t in _target_ns_map [ _fabric_wwn ] ) : <NEWLINE> targets . append ( t ) <NEWLINE> device_map [ _fabric_wwn ] = { <NEWLINE> <STRING> : initiators , <NEWLINE> <STRING> : targets } <NEWLINE> return device_map <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'initiator_port_wwn_list'", "'target_port_wwn_list'"]}, "err_obj": {"msg": "expected an indented block"}}], ["8c9911e5ef8960572189d5bcb65ffa0d", {"code_string": "def localtrace_trace_and_count(self, frame, why, arg):\n    if why == \"line\":\n        filename = frame.f_code.co_filename\n        lineno = frame.f_lineno\n        key = filename, lineno\n        self.counts[key] = self.counts.get(key, 0) + 1\n        if self.start_time:\n            print('%.2f' %(time.time() - self.start_time), )\n        bname = os.path.basename(filename)\n        print(\"%s(%d): %s\" %(bname, lineno,\n            linecache.getline(filename, lineno)),\n    return self.localtrace\n", "code_toks_joined": "def localtrace_trace_and_count ( self , frame , why , arg ) : <NEWLINE> <INDENT> if why == <STRING> : <NEWLINE> <INDENT> filename = frame . f_code . co_filename <NEWLINE> lineno = frame . f_lineno <NEWLINE> key = filename , lineno <NEWLINE> self . counts [ key ] = self . counts . get ( key , 0 ) + 1 <NEWLINE> if self . start_time : <NEWLINE> <INDENT> print ( <STRING> % ( time . time ( ) - self . start_time ) , ) <NEWLINE> <DEDENT> bname = os . path . basename ( filename ) <NEWLINE> print ( <STRING> % ( bname , lineno , <NEWLINE> <INDENT> linecache . getline ( filename , lineno ) ) , <NEWLINE> <DEDENT> <DEDENT> return self . localtrace <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"line\"", "'%.2f'", "\"%s(%d): %s\""]}, "window_span": [99, 128], "err_obj": {"msg": "unbalanced (){}[]"}}], ["296b2e5ca18d5a10c24bdfe4ebcd3d26", {"code_string": "def proposition_consistent(formula, atom):\n    \"\"\"Checks if a proposition is consistent with the formulas of an atom.\"\"\"\n    print(\"it is a proposition\")\n    if formula.is_proposition() and(\n        formula.get_values() in formula.get_proposition_rules().keys()):\n        no_consistent_propositions = formula.get_consistent_propositions()\n        for no_consistent_proposition in no_consistent_propositions:\n        if is_in_atom(no_consistent_proposition, atom):\n        print(\"by\", no_consistent_proposition)\n        return False\n        print(\"There are no inconsistencies, then it is consistent\")\n        return True\n    return False\n", "code_toks_joined": "def proposition_consistent ( formula , atom ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> ) <NEWLINE> if formula . is_proposition ( ) and ( <NEWLINE> <INDENT> formula . get_values ( ) in formula . get_proposition_rules ( ) . keys ( ) ) : <NEWLINE> no_consistent_propositions = formula . get_consistent_propositions ( ) <NEWLINE> for no_consistent_proposition in no_consistent_propositions : <NEWLINE> if is_in_atom ( no_consistent_proposition , atom ) : <NEWLINE> print ( <STRING> , no_consistent_proposition ) <NEWLINE> return False <NEWLINE> print ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Checks if a proposition is consistent with the formulas of an atom.\"\"\"", "\"it is a proposition\"", "\"by\"", "\"There are no inconsistencies, then it is consistent\""]}, "err_obj": {"msg": "expected an indented block"}}], ["5d14589a083a5311306096e9e8f5d3fb", {"code_string": "def createNoiseSpectrum(numin = 700., numax = 1800., nchan = 100., sigma = 0.01, freq = False):\n    try:\n        len(freq)\n        nu = freq\n    except TypeError:\n        nu = createFrequency(numin, numax, nchan)\n            sig = sigma * np.random.standard_normal(nu.shape)\n            return nu, sig\n", "code_toks_joined": "def createNoiseSpectrum ( numin = 700. , numax = 1800. , nchan = 100. , sigma = 0.01 , freq = False ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> len ( freq ) <NEWLINE> nu = freq <NEWLINE> <DEDENT> except TypeError : <NEWLINE> <INDENT> nu = createFrequency ( numin , numax , nchan ) <NEWLINE> <INDENT> sig = sigma * np . random . standard_normal ( nu . shape ) <NEWLINE> return nu , sig <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["a8cc8b77bd151f8289f40c8b01ab6049", {"code_string": "def test():\n    import doctest, sys\n        sys.path.insert(1, '../../../')\n        sys.path.insert(1, '../../../openbci/')\n    doctest.testmod(sys.modules[__name__])\n        print(\"Tests succeeded!\")\n", "code_toks_joined": "def test ( ) : <NEWLINE> <INDENT> import doctest , sys <NEWLINE> <INDENT> sys . path . insert ( 1 , <STRING> ) <NEWLINE> sys . path . insert ( 1 , <STRING> ) <NEWLINE> <DEDENT> doctest . testmod ( sys . modules [ __name__ ] ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'../../../'", "'../../../openbci/'", "\"Tests succeeded!\""]}, "err_obj": {"msg": "unexpected indent"}}], ["8db86b18e3585840b19b50e49ccb5a4a", {"code_string": "def tstamp(task):\n    return '<div title=\"{0}\">{1}</div>'.format(\n        escape(str(task.tstamp)), escape(naturaldate(task.tstamp))),\n    )\n", "code_toks_joined": "def tstamp ( task ) : <NEWLINE> <INDENT> return <STRING> . format ( <NEWLINE> <INDENT> escape ( str ( task . tstamp ) ) , escape ( naturaldate ( task . tstamp ) ) ) , <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'<div title=\"{0}\">{1}</div>'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["97de45031a5c023d21cc265330003065", {"code_string": "def completeStage(id):\n    print('in complete stage')\n        con = mdb.connect(DB_SERVER, DB_USER, DB_PASSWORD, DB_NAME);\n        cur = con.cursor(mdb.cursors.DictCursor)\n        cur.execute(\"UPDATE surprise_stages SET completed=NOW() WHERE id=\" + str(id))\n        cur.close()\n        con.close()\n", "code_toks_joined": "def completeStage ( id ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> con = mdb . connect ( DB_SERVER , DB_USER , DB_PASSWORD , DB_NAME ) ; <NEWLINE> cur = con . cursor ( mdb . cursors . DictCursor ) <NEWLINE> cur . execute ( <STRING> + str ( id ) ) <NEWLINE> cur . close ( ) <NEWLINE> con . close ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'in complete stage'", "\"UPDATE surprise_stages SET completed=NOW() WHERE id=\""]}, "err_obj": {"msg": "unexpected indent"}}], ["5c7b16d346426b8a96c964ed1da63cfd", {"code_string": "def _generate_metadata_args(self, metadata):\n    result = []\n    if metadata:\n        for k, v in sorted(metadata.iteritems(), key = lambda(k, _): k):\n            field = self._get_metadata_field(k)\n            param = (field) if v is None else('%s:%s' %(field, v))\n            result +=['-h', param]\n    return result\n", "code_toks_joined": "def _generate_metadata_args ( self , metadata ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> if metadata : <NEWLINE> <INDENT> for k , v in sorted ( metadata . iteritems ( ) , key = lambda ( k , _ ) : k ) : <NEWLINE> <INDENT> field = self . _get_metadata_field ( k ) <NEWLINE> param = ( field ) if v is None else ( <STRING> % ( field , v ) ) <NEWLINE> result += [ <STRING> , param ] <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'%s:%s'", "'-h'"]}, "err_obj": {"msg": "invalid syntax"}}], ["fff535b30a9c26309c0334662e353c6d", {"code_string": "def convlon(coord):\n    \"\"\"Convert longitude from decimal degrees to ddd mm.mmm\"\"\"\n    if coord < 0:\n    return 'W' + convcoord(- coord)\n    else:\n    return 'E' + convcoord(coord)\n", "code_toks_joined": "def convlon ( coord ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if coord < 0 : <NEWLINE> return <STRING> + convcoord ( - coord ) <NEWLINE> else : <NEWLINE> return <STRING> + convcoord ( coord ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Convert longitude from decimal degrees to ddd mm.mmm\"\"\"", "'W'", "'E'"]}, "err_obj": {"msg": "expected an indented block"}}], ["11047b2d043043c83ffdad0bc596ca01", {"code_string": "def next(self):\n    if self.index[1] >= self.n\n        raise StopIteration\n    else:\n        if self.index[1] >= self.m:\n            self.index[0] += 1\n            self.index[1] = 0\n        return self.data[self.index[0], self.index[1]]\n", "code_toks_joined": "def next ( self ) : <NEWLINE> <INDENT> if self . index [ 1 ] >= self . n <NEWLINE> <INDENT> raise StopIteration <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if self . index [ 1 ] >= self . m : <NEWLINE> <INDENT> self . index [ 0 ] += 1 <NEWLINE> self . index [ 1 ] = 0 <NEWLINE> <DEDENT> return self . data [ self . index [ 0 ] , self . index [ 1 ] ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["253d2cb70f9fe673ea49870582021307", {"code_string": "def getDeviceModel(ip):\n    output = commands.getstatusoutput(\"snmpwalk -v 1 -c public %s %s\" %(ip, ids.currentdevice[\"model\"]))\n    outputlist = output[1].split(\"\\n\")\n    for line in outputlist:\n    if \"STRING:\" in line:\n        modeldevice = parser.OutputToString(line)\n        if len(modeldevice) > 5:\n            return modeldevice\n", "code_toks_joined": "def getDeviceModel ( ip ) : <NEWLINE> <INDENT> output = commands . getstatusoutput ( <STRING> % ( ip , ids . currentdevice [ <STRING> ] ) ) <NEWLINE> outputlist = output [ 1 ] . split ( <STRING> ) <NEWLINE> for line in outputlist : <NEWLINE> if <STRING> in line : <NEWLINE> <INDENT> modeldevice = parser . OutputToString ( line ) <NEWLINE> if len ( modeldevice ) > 5 : <NEWLINE> <INDENT> return modeldevice <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"snmpwalk -v 1 -c public %s %s\"", "\"model\"", "\"\\n\"", "\"STRING:\""]}, "err_obj": {"msg": "expected an indented block"}}], ["28e53337d60d3983ac462975d7c16adc", {"code_string": "def fetch():\n    with lcd(os.path.join(os.path.dirname(os.path.dirname(__file__)), '..',\n        'benckmark_results')):\n        with cd(env.run_at):\n        get('*')\n", "code_toks_joined": "def fetch ( ) : <NEWLINE> <INDENT> with lcd ( os . path . join ( os . path . dirname ( os . path . dirname ( __file__ ) ) , <STRING> , <NEWLINE> <INDENT> <STRING> ) ) : <NEWLINE> with cd ( env . run_at ) : <NEWLINE> get ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'..'", "'benckmark_results'", "'*'"]}, "err_obj": {"msg": "expected an indented block"}}], ["6cf7bcefa0177bfd2c34ab8bcd80c69c", {"code_string": "class MyCheckBox:\n    def __init__(self,\n        PlaceWidget,\n        PlaceLayout,\n        StringToShow,\n        LogicalToSet):\n        self.CheckBox = QtGui.QCheckBox(StringToShow, PlaceWidget)\n        PlaceLayout.addWidget(self.CheckBox)\n        if LogicalToSet:\n        self.CheckBox.setCheckState(QtCore.Qt.Checked)\n    def checkStateSet(self):\n        return(self.CheckBox.checkStateSet())\n", "code_toks_joined": "class MyCheckBox : <NEWLINE> <INDENT> def __init__ ( self , <NEWLINE> <INDENT> PlaceWidget , <NEWLINE> PlaceLayout , <NEWLINE> StringToShow , <NEWLINE> LogicalToSet ) : <NEWLINE> self . CheckBox = QtGui . QCheckBox ( StringToShow , PlaceWidget ) <NEWLINE> PlaceLayout . addWidget ( self . CheckBox ) <NEWLINE> if LogicalToSet : <NEWLINE> self . CheckBox . setCheckState ( QtCore . Qt . Checked ) <NEWLINE> <DEDENT> def checkStateSet ( self ) : <NEWLINE> <INDENT> return ( self . CheckBox . checkStateSet ( ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["6726f39a4926893a65aecc8393913ecf", {"code_string": "def test_raises_if_rank_is_not_integer_dynamic(self):\n    with self.test_session():\n        tensor = tf.constant([1, 2], dtype = tf.float32, name = \"my_tensor\")\n        rank_tensor = tf.placeholder(tf.float32, name = \"rank_tensor\")\n        with self.assertRaisesRegexp(TypeError,\n            \"must be of type <dtype: 'int32'>\"):\n            with tf.control_dependencies([tf.assert_rank(tensor, rank_tensor)]):\n            tf.identity(tensor).eval(feed_dict = {rank_tensor: .5})\n", "code_toks_joined": "def test_raises_if_rank_is_not_integer_dynamic ( self ) : <NEWLINE> <INDENT> with self . test_session ( ) : <NEWLINE> <INDENT> tensor = tf . constant ( [ 1 , 2 ] , dtype = tf . float32 , name = <STRING> ) <NEWLINE> rank_tensor = tf . placeholder ( tf . float32 , name = <STRING> ) <NEWLINE> with self . assertRaisesRegexp ( TypeError , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> with tf . control_dependencies ( [ tf . assert_rank ( tensor , rank_tensor ) ] ) : <NEWLINE> tf . identity ( tensor ) . eval ( feed_dict = { rank_tensor : .5 } ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"my_tensor\"", "\"rank_tensor\"", "\"must be of type <dtype: 'int32'>\""]}, "err_obj": {"msg": "expected an indented block"}}], ["bad097c4177836d4accb2c6dc1ce86a3", {"code_string": "def print_hierarchy(model, out = sys.stdout, show_ports = False, max_depth = - 1, size = 20):\n    print(\"\\n\" + string_size(getattr(model, 'name'), 10) + \" of type \"\n        + string_size(model.class_name, 10), file = out)\n    print_hierarchy_helper(model, out, show_ports, \"  \", 0, max_depth, size\n", "code_toks_joined": "def print_hierarchy ( model , out = sys . stdout , show_ports = False , max_depth = - 1 , size = 20 ) : <NEWLINE> <INDENT> print ( <STRING> + string_size ( getattr ( model , <STRING> ) , 10 ) + <STRING> <NEWLINE> <INDENT> + string_size ( model . class_name , 10 ) , file = out ) <NEWLINE> <DEDENT> print_hierarchy_helper ( model , out , show_ports , <STRING> , 0 , max_depth , size <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\\n\"", "'name'", "\" of type \"", "\"  \""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["7e3b4803501d905ed2b4ca2e0d9ff045", {"code_string": "class GrabFiles:\n    def setdirectory(self, value): self.data = value\n    def display(self): print self.data\n    def searchdirectory(self, search_term):\n        files = getDirectoryFiles(self.data, search_term)\n        if len(files) < 1: print 'files not found'\n        return files\n    def returndirectory(self):\n        dir_list = getAllDirectoryFiles(self.data)\n        return dir_list\n", "code_toks_joined": "class GrabFiles : <NEWLINE> <INDENT> def setdirectory ( self , value ) : self . data = value <NEWLINE> def display ( self ) : print self . data <NEWLINE> def searchdirectory ( self , search_term ) : <NEWLINE> <INDENT> files = getDirectoryFiles ( self . data , search_term ) <NEWLINE> if len ( files ) < 1 : print <STRING> <NEWLINE> return files <NEWLINE> <DEDENT> def returndirectory ( self ) : <NEWLINE> <INDENT> dir_list = getAllDirectoryFiles ( self . data ) <NEWLINE> return dir_list <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'files not found'"]}, "err_obj": {"msg": "invalid syntax"}}], ["da56f03d94b8f6e9b493e69c03b42705", {"code_string": "def test_create_custom_variable(self):\n    \"\"\" Test creation of a variable with custom settings. \"\"\"\n        var = IneqSys.Variable('x', lower = 5, upper = 10)\n        self.assertEquals(var.lower, 5)\n        self.assertEquals(var.upper, 10)\n        self.assertEquals(var.upper, var._candidate)\n        self.assertEquals(var._status, _VariableStatus.valid)\n", "code_toks_joined": "def test_create_custom_variable ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> var = IneqSys . Variable ( <STRING> , lower = 5 , upper = 10 ) <NEWLINE> self . assertEquals ( var . lower , 5 ) <NEWLINE> self . assertEquals ( var . upper , 10 ) <NEWLINE> self . assertEquals ( var . upper , var . _candidate ) <NEWLINE> self . assertEquals ( var . _status , _VariableStatus . valid ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Test creation of a variable with custom settings. \"\"\"", "'x'"]}, "err_obj": {"msg": "unexpected indent"}}], ["bc3a4d385db4dafb54db58163bb14af9", {"code_string": "def getAnotationOfString(string_txt, suffix):\n    anotationRegex = constructAnotationRegex(suffix)\n    anotationString = ''\n    try:\n        anotationMatch = re.search(anotationRegex, unicode(string_txt))\n        if anotationMatch:\n        match = re.search(AnotationRegexPrefix, anotationMatch.group(0))\n        if match:\n            anotationString = match.group(0)\n    except Exception as e:\n        print('Exception:')\n        print(e)\n    return anotationString\n", "code_toks_joined": "def getAnotationOfString ( string_txt , suffix ) : <NEWLINE> <INDENT> anotationRegex = constructAnotationRegex ( suffix ) <NEWLINE> anotationString = <STRING> <NEWLINE> try : <NEWLINE> <INDENT> anotationMatch = re . search ( anotationRegex , unicode ( string_txt ) ) <NEWLINE> if anotationMatch : <NEWLINE> match = re . search ( AnotationRegexPrefix , anotationMatch . group ( 0 ) ) <NEWLINE> if match : <NEWLINE> <INDENT> anotationString = match . group ( 0 ) <NEWLINE> <DEDENT> <DEDENT> except Exception as e : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( e ) <NEWLINE> <DEDENT> return anotationString <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "'Exception:'"]}, "err_obj": {"msg": "expected an indented block"}}], ["420f68cbf89565ef945176401af2b966", {"code_string": "\"\"\"A module to read LOFAR antenna field files.\"\"\"\nimport sys\nimport numpy as np\nimport os\nfrom os.path import dirname\nimport argparse\nANTENNAFIELDDIR = dirname(__file__) + '/../share/AntennaFields/'\nCOMMENT_CHAR = '#'\ndef _getAntennaFieldFile(stationName, antenna_field_dir = ANTENNAFIELDDIR,\n    AFfileNameType = 2):\n    if AFfileNameType == 2:\n    basename = stationName + '-' + 'AntennaField' + '.conf'\n    else:\n    basename = 'AntennaField' + stationName + '.conf'\n    filepath = antenna_field_dir + '/' + basename\n    return filepath\n", "code_toks_joined": "<STRING> <NEWLINE> import sys <NEWLINE> import numpy as np <NEWLINE> import os <NEWLINE> from os . path import dirname <NEWLINE> import argparse <NEWLINE> ANTENNAFIELDDIR = dirname ( __file__ ) + <STRING> <NEWLINE> COMMENT_CHAR = <STRING> <NEWLINE> def _getAntennaFieldFile ( stationName , antenna_field_dir = ANTENNAFIELDDIR , <NEWLINE> <INDENT> AFfileNameType = 2 ) : <NEWLINE> if AFfileNameType == 2 : <NEWLINE> basename = stationName + <STRING> + <STRING> + <STRING> <NEWLINE> else : <NEWLINE> basename = <STRING> + stationName + <STRING> <NEWLINE> filepath = antenna_field_dir + <STRING> + basename <NEWLINE> return filepath <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"A module to read LOFAR antenna field files.\"\"\"", "'/../share/AntennaFields/'", "'#'", "'-'", "'AntennaField'", "'.conf'", "'AntennaField'", "'.conf'", "'/'"]}, "err_obj": {"msg": "expected an indented block"}}], ["03852e69096d876298d271e0c736bcbd", {"code_string": "def setupUi(self, srwrSpecDesDialog):\n    srwrSpecDesDialog.setObjectName(_fromUtf8(\"srwrSpecDesDialog\"))\n    srwrSpecDesDialog.setWindowModality(QtCore.Qt.NonModal)\n    srwrSpecDesDialog.resize(372, 567)\n    self.gridLayout = QtGui.QGridLayout(srwrSpecDesDialog)\n    self.gridLayout.setObjectName(_fromUtf8(\"gridLayout\"))\n    self.groupBox = QtGui.QGroupBox(srwrSpecDesDialog)\n    self.groupBox.setTitle(_fromUtf8(\"\"))\n    self.groupBox.setObjectName(_fromUtf8(\"groupBox\"))\n    self.gridLayout_3 = QtGui.QGridLayout(self.groupBox)\n    self.gridLayout_3.setObjectName(_fromUtf8(\"gridLayout_3\"))\n    self.gridLayout_9 = QtGui.QGridLayout()\n    self.gridLayout_9.setObjectName(_fromUtf8(\"gridLayout_9\"))\n    self.locationLabel = QtGui.QLabel(self.groupBox)\n    self.locationLabel.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)\n    self.locationLabel.setObjectName(_fromUtf8(\"locationLabel\"))\n    self.gridLayout_9.addWidget(self.locationLabel, 1, 0, 1, 1)\n    self.horizontalLayout = QtGui.QHBoxLayout()\n    self.horizontalLayout.setObjectName(_fromUtf8(\"horizontalLayout\"))\n    self.locationTextEdit = QtGui.QTextEdit(self.groupBox)\n    self.locationTextEdit.setStyleSheet(_fromUtf8(\"border-width:0.5px;\\n\"\n", "code_toks_joined": "def setupUi ( self , srwrSpecDesDialog ) : <NEWLINE> <INDENT> srwrSpecDesDialog . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> srwrSpecDesDialog . setWindowModality ( QtCore . Qt . NonModal ) <NEWLINE> srwrSpecDesDialog . resize ( 372 , 567 ) <NEWLINE> self . gridLayout = QtGui . QGridLayout ( srwrSpecDesDialog ) <NEWLINE> self . gridLayout . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . groupBox = QtGui . QGroupBox ( srwrSpecDesDialog ) <NEWLINE> self . groupBox . setTitle ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . groupBox . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_3 = QtGui . QGridLayout ( self . groupBox ) <NEWLINE> self . gridLayout_3 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_9 = QtGui . QGridLayout ( ) <NEWLINE> self . gridLayout_9 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . locationLabel = QtGui . QLabel ( self . groupBox ) <NEWLINE> self . locationLabel . setAlignment ( QtCore . Qt . AlignRight | QtCore . Qt . AlignTrailing | QtCore . Qt . AlignVCenter ) <NEWLINE> self . locationLabel . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_9 . addWidget ( self . locationLabel , 1 , 0 , 1 , 1 ) <NEWLINE> self . horizontalLayout = QtGui . QHBoxLayout ( ) <NEWLINE> self . horizontalLayout . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . locationTextEdit = QtGui . QTextEdit ( self . groupBox ) <NEWLINE> self . locationTextEdit . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"srwrSpecDesDialog\"", "\"gridLayout\"", "\"\"", "\"groupBox\"", "\"gridLayout_3\"", "\"gridLayout_9\"", "\"locationLabel\"", "\"horizontalLayout\"", "\"border-width:0.5px;\\n\""]}, "window_span": [254, 260], "err_obj": {"msg": "unbalanced (){}[]"}}], ["c238a6f31c572770833ab70cecf9c933", {"code_string": "def __add__(self, other):\n    if self.rows != other.rows or self.cols != other.cols:\n        raise ValueError, \"Matrices must be of equal dimensions to add\"\n    else:\n        res = Matrix.zero(self.rows, self.cols)\n        for i in range(self.rows):\n            for j in range(self.cols):\n                res.value[i][j] = self.value[i][j] ^ other.value[i][j]\n        return res\n", "code_toks_joined": "def __add__ ( self , other ) : <NEWLINE> <INDENT> if self . rows != other . rows or self . cols != other . cols : <NEWLINE> <INDENT> raise ValueError , <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = Matrix . zero ( self . rows , self . cols ) <NEWLINE> for i in range ( self . rows ) : <NEWLINE> <INDENT> for j in range ( self . cols ) : <NEWLINE> <INDENT> res . value [ i ] [ j ] = self . value [ i ] [ j ] ^ other . value [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Matrices must be of equal dimensions to add\""]}, "err_obj": {"msg": "invalid syntax"}}], ["f70f00c599be97d5e2383207816ecde3", {"code_string": "def test_claim_bucket(self):\n    a = self.o.claim_bucket()\n    self.assertTrue(self.o.exists(a)\n", "code_toks_joined": "def test_claim_bucket ( self ) : <NEWLINE> <INDENT> a = self . o . claim_bucket ( ) <NEWLINE> self . assertTrue ( self . o . exists ( a ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["db522c10083888f1a047e1c6e6622c6b", {"code_string": "def rename(self, src, dst):\n    try:\n        self.refresh_dircache(dirname(src), dirname(dst))\n        self.ftp.rename(_encode(src), _encode(dst))\n    except error_perm, exception:\n        code, message = str(exception).split(' ', 1)\n        if code == \"550\":\n            if not self.exists(dirname(dst)):\n                raise ParentDirectoryMissingError(dst)\n        raise\n    except error_reply:\n        pass\n", "code_toks_joined": "def rename ( self , src , dst ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . refresh_dircache ( dirname ( src ) , dirname ( dst ) ) <NEWLINE> self . ftp . rename ( _encode ( src ) , _encode ( dst ) ) <NEWLINE> <DEDENT> except error_perm , exception : <NEWLINE> <INDENT> code , message = str ( exception ) . split ( <STRING> , 1 ) <NEWLINE> if code == <STRING> : <NEWLINE> <INDENT> if not self . exists ( dirname ( dst ) ) : <NEWLINE> <INDENT> raise ParentDirectoryMissingError ( dst ) <NEWLINE> <DEDENT> <DEDENT> raise <NEWLINE> <DEDENT> except error_reply : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["' '", "\"550\""]}, "err_obj": {"msg": "invalid syntax"}}], ["65a935c3088365a9fab40670d041b53a", {"code_string": "import pygame\npygame.joystick.init()\npygame.display.init()\nj = pygame.joystick.Joystick(0)\nj.init()\nif j.get_init() == 1: print \"Joystick is initialized\"\nwhile 1:\n    for e in event.get():\n        if e.type != QUIT:\n            print('%s: %s' %(event.event_name(e.type), e.dict))\n", "code_toks_joined": "import pygame <NEWLINE> pygame . joystick . init ( ) <NEWLINE> pygame . display . init ( ) <NEWLINE> j = pygame . joystick . Joystick ( 0 ) <NEWLINE> j . init ( ) <NEWLINE> if j . get_init ( ) == 1 : print <STRING> <NEWLINE> while 1 : <NEWLINE> <INDENT> for e in event . get ( ) : <NEWLINE> <INDENT> if e . type != QUIT : <NEWLINE> <INDENT> print ( <STRING> % ( event . event_name ( e . type ) , e . dict ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Joystick is initialized\"", "'%s: %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["3e7002e3e2e21bacfe47cc82f210e405", {"code_string": "def write_duplicate_questions_validation_file(self):\n    with codecs.open(self.VALIDATION_FILE, 'w',\n        'utf-8') as dupe_val_file:\n        dupe_val_file.write(\"\\\"1\\\",\\\"7\\\",\\\"8\\\",\\\"question1\\\",\"\n            \"\\\"question2 question8\\\",\\\"0\\\"\\n\")\n            dupe_val_file.write(\"\\\"2\\\",\\\"9\\\",\\\"10\\\",\\\"question9\\\",\"\n            \"\\\"question10\\\",\\\"1\\\"\\n\")\n            dupe_val_file.write(\"\\\"3\\\",\\\"11\\\",\\\"12\\\",\\\"question6\\\",\"\n            \"\\\"question7 question11 question12\\\",\"\n            \"\\\"0\\\"\\n\")\n", "code_toks_joined": "def write_duplicate_questions_validation_file ( self ) : <NEWLINE> <INDENT> with codecs . open ( self . VALIDATION_FILE , <STRING> , <NEWLINE> <INDENT> <STRING> ) as dupe_val_file : <NEWLINE> dupe_val_file . write ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> dupe_val_file . write ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> dupe_val_file . write ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'w'", "'utf-8'", "\"\\\"1\\\",\\\"7\\\",\\\"8\\\",\\\"question1\\\",\"", "\"\\\"question2 question8\\\",\\\"0\\\"\\n\"", "\"\\\"2\\\",\\\"9\\\",\\\"10\\\",\\\"question9\\\",\"", "\"\\\"question10\\\",\\\"1\\\"\\n\"", "\"\\\"3\\\",\\\"11\\\",\\\"12\\\",\\\"question6\\\",\"", "\"\\\"question7 question11 question12\\\",\"", "\"\\\"0\\\"\\n\""]}, "err_obj": {"msg": "unexpected indent"}}], ["644c472eedb4c273f067d06367f0e473", {"code_string": "def getresult(self):\n    print(\"*\" * 20)\n    print(\"url is: %s\" % self._basicurl)\n        print(\"start time is:%s\" % self._stattime)\n        print(\"end time is %s\" % self._endtime)\n        print(\"first url use time is:%s\" % self._basictime)\n    print(\"sencond url use time MAX is %s\" % self._senMAXurl)\n    print(\"second url max use time is %s\" % self._sencodusetime)\n    print(\"total USE TIME is %s\" % self._totusetime)\n    print(\"total get url is %s\" % self._toturl)\n    print(\"*\" * 20)\n", "code_toks_joined": "def getresult ( self ) : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> print ( <STRING> % self . _basicurl ) <NEWLINE> <INDENT> print ( <STRING> % self . _stattime ) <NEWLINE> print ( <STRING> % self . _endtime ) <NEWLINE> print ( <STRING> % self . _basictime ) <NEWLINE> <DEDENT> print ( <STRING> % self . _senMAXurl ) <NEWLINE> print ( <STRING> % self . _sencodusetime ) <NEWLINE> print ( <STRING> % self . _totusetime ) <NEWLINE> print ( <STRING> % self . _toturl ) <NEWLINE> print ( <STRING> * 20 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"*\"", "\"url is: %s\"", "\"start time is:%s\"", "\"end time is %s\"", "\"first url use time is:%s\"", "\"sencond url use time MAX is %s\"", "\"second url max use time is %s\"", "\"total USE TIME is %s\"", "\"total get url is %s\"", "\"*\""]}, "err_obj": {"msg": "unexpected indent"}}], ["6d50f64d0b3caa30fe4be5b5c7b612f2", {"code_string": "class parseThread(Thread):\n    def __init__(self, tip):\n    self.testip = tip\n    super(parseThread, self).__init__()\n    self.stoprequest = Event()\n    def run(self):\n    try:\n        callParse(self.testip)\n    except Exception:\n        sys.exit()\n    def stahp(self, timeout = None):\n    global pParse\n    pParse = 1\n", "code_toks_joined": "class parseThread ( Thread ) : <NEWLINE> <INDENT> def __init__ ( self , tip ) : <NEWLINE> self . testip = tip <NEWLINE> super ( parseThread , self ) . __init__ ( ) <NEWLINE> self . stoprequest = Event ( ) <NEWLINE> def run ( self ) : <NEWLINE> try : <NEWLINE> <INDENT> callParse ( self . testip ) <NEWLINE> <DEDENT> except Exception : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <DEDENT> def stahp ( self , timeout = None ) : <NEWLINE> global pParse <NEWLINE> pParse = 1 <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["2711c80214b642d24b8c6fd167060c60", {"code_string": "def load_module(self, module):\n    \"\"\"Load a single module defined by _module_. The name of the module is\"\"\"\n    try:\n        n_mod = self.__load_module_by_name(module[\"name\"])\n        n_mod[\"instance\"].start()\n        self.loaded_modules.append(n_mod)\n        return True\n    except Exception, ex:\n        syslog.syslog(syslog.LOG_ERR, 'failed to load module: ' + module[\"name\"] + \" (%s)\" % str(ex))\n        return False\n", "code_toks_joined": "def load_module ( self , module ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> n_mod = self . __load_module_by_name ( module [ <STRING> ] ) <NEWLINE> n_mod [ <STRING> ] . start ( ) <NEWLINE> self . loaded_modules . append ( n_mod ) <NEWLINE> return True <NEWLINE> <DEDENT> except Exception , ex : <NEWLINE> <INDENT> syslog . syslog ( syslog . LOG_ERR , <STRING> + module [ <STRING> ] + <STRING> % str ( ex ) ) <NEWLINE> return False <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Load a single module defined by _module_. The name of the module is\"\"\"", "\"name\"", "\"instance\"", "'failed to load module: '", "\"name\"", "\" (%s)\""]}, "err_obj": {"msg": "invalid syntax"}}], ["50e1d804369dcc35a2db6db1b492e99f", {"code_string": "def makeEntity((name, num, description)):\n    e = Entity(name, num, description)\n    __by_number[types.IntType(num)] = e\n    globals()[name] = e\n", "code_toks_joined": "def makeEntity ( ( name , num , description ) ) : <NEWLINE> <INDENT> e = Entity ( name , num , description ) <NEWLINE> __by_number [ types . IntType ( num ) ] = e <NEWLINE> globals ( ) [ name ] = e <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["4a665242d1149f1c88f24fd1bbfa55cc", {"code_string": "def request(self, method, url, settings = None):\n    if settings is None:\n        settings = {}\n    if 'timeout' not in settings:\n        settings['timeout'] = conf.REQUEST_TIMEOUT\n    for i in range(3):\n        try:\n            response = self._Session.request(method, url, ** settings)\n            return response\n        except requests.Timeout:\n            continue\n        except Exception, e:\n            return False\n    return False\n", "code_toks_joined": "def request ( self , method , url , settings = None ) : <NEWLINE> <INDENT> if settings is None : <NEWLINE> <INDENT> settings = { } <NEWLINE> <DEDENT> if <STRING> not in settings : <NEWLINE> <INDENT> settings [ <STRING> ] = conf . REQUEST_TIMEOUT <NEWLINE> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> response = self . _Session . request ( method , url , ** settings ) <NEWLINE> return response <NEWLINE> <DEDENT> except requests . Timeout : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'timeout'", "'timeout'"]}, "err_obj": {"msg": "invalid syntax"}}], ["69873a7ccd32b6b1b23664996b341584", {"code_string": "def schaffer(individual):\n    \"\"\"Schaffer test objective function.\"\"\"\n    return sum((x ** 2 + x1 ** 2) ** 0.25 *((sin(50 *(x ** 2 + x1 ** 2) ** 0.1)) ** 2 + 1.0)\n", "code_toks_joined": "def schaffer ( individual ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return sum ( ( x ** 2 + x1 ** 2 ) ** 0.25 * ( ( sin ( 50 * ( x ** 2 + x1 ** 2 ) ** 0.1 ) ) ** 2 + 1.0 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Schaffer test objective function.\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["0af0fbafca0534d9c2492823810f7aef", {"code_string": "def start(self, interval, now = True):\n    \"\"\"Start running function every interval seconds.\"\"\"\n    assert not self.running, (\"Tried to start an already running \"\n        \"LoopingCall.\")\n    if interval < 0:\n        raise ValueError, \"interval must be >= 0\"\n    self.running = True\n    d = self.deferred = defer.Deferred()\n    self.starttime = self._seconds()\n    self.count = 0\n    self.interval = interval\n    if now:\n        self()\n    else:\n        self._reschedule()\n    return d\n", "code_toks_joined": "def start ( self , interval , now = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> assert not self . running , ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> if interval < 0 : <NEWLINE> <INDENT> raise ValueError , <STRING> <NEWLINE> <DEDENT> self . running = True <NEWLINE> d = self . deferred = defer . Deferred ( ) <NEWLINE> self . starttime = self . _seconds ( ) <NEWLINE> self . count = 0 <NEWLINE> self . interval = interval <NEWLINE> if now : <NEWLINE> <INDENT> self ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . _reschedule ( ) <NEWLINE> <DEDENT> return d <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Start running function every interval seconds.\"\"\"", "\"Tried to start an already running \"", "\"LoopingCall.\"", "\"interval must be >= 0\""]}, "err_obj": {"msg": "invalid syntax"}}], ["7766d19c125950d9c760785d6fa416c2", {"code_string": "def __init__(self):\n    self.registers = {}\n    for register in registers\n        self.registers[register] = []\n    self.addresses = {}\n", "code_toks_joined": "def __init__ ( self ) : <NEWLINE> <INDENT> self . registers = { } <NEWLINE> for register in registers <NEWLINE> <INDENT> self . registers [ register ] = [ ] <NEWLINE> <DEDENT> self . addresses = { } <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["5a83fff58d876ef3de3c9338d9ea670c", {"code_string": "def format_element(bfo, param1, param2 = 'default value'):\n    \"\"\"Prints test\"\"\"\n    unloadable element\n    return \"test\"\n", "code_toks_joined": "def format_element ( bfo , param1 , param2 = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> unloadable element <NEWLINE> return <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'default value'", "\"\"\"Prints test\"\"\"", "\"test\""]}, "err_obj": {"msg": "invalid syntax"}}], ["38ab5b55a5ce723fd9654910cb107df1", {"code_string": "def map_action(entry name):\n    try:\n        bact = entry.bact\n        bactsig = entry.bactsig\n    except AttributeError:\n        return None\n    return '%s [%s]' %(bactsig, bact)\n", "code_toks_joined": "def map_action ( entry name ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> bact = entry . bact <NEWLINE> bactsig = entry . bactsig <NEWLINE> <DEDENT> except AttributeError : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> return <STRING> % ( bactsig , bact ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'%s [%s]'"]}, "err_obj": {"msg": "invalid syntax"}}], ["9cd963156124c1d54421715d68f8b017", {"code_string": "self.description = \"Install two packages with a conflicting file\"\np1 = pmpkg(\"dummy\")\np1.files = [\"bin/dummy\",\n    \"usr/man/man1/dummy.1\",\n    \"usr/common\"]\np2 = pmpkg(\"foobar\")\np2.files = [\"bin/foobar\",\n    \"usr/man/man1/foobar.1\",\n    \"usr/common\"]\nfor p in p1, p2:\n    self.addpkg(p)\nself.args = \"-A %s\" % \" \".join([p.filename() for p in p1, p2])\nself.addrule(\"PACMAN_RETCODE=1\")\nself.addrule(\"!PKG_EXIST=dummy\")\nself.addrule(\"!PKG_EXIST=foobar\")\n", "code_toks_joined": "self . description = <STRING> <NEWLINE> p1 = pmpkg ( <STRING> ) <NEWLINE> p1 . files = [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ] <NEWLINE> <DEDENT> p2 = pmpkg ( <STRING> ) <NEWLINE> p2 . files = [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ] <NEWLINE> <DEDENT> for p in p1 , p2 : <NEWLINE> <INDENT> self . addpkg ( p ) <NEWLINE> <DEDENT> self . args = <STRING> % <STRING> . join ( [ p . filename ( ) for p in p1 , p2 ] ) <NEWLINE> self . addrule ( <STRING> ) <NEWLINE> self . addrule ( <STRING> ) <NEWLINE> self . addrule ( <STRING> ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"Install two packages with a conflicting file\"", "\"dummy\"", "\"bin/dummy\"", "\"usr/man/man1/dummy.1\"", "\"usr/common\"", "\"foobar\"", "\"bin/foobar\"", "\"usr/man/man1/foobar.1\"", "\"usr/common\"", "\"-A %s\"", "\" \"", "\"PACMAN_RETCODE=1\"", "\"!PKG_EXIST=dummy\"", "\"!PKG_EXIST=foobar\""]}, "err_obj": {"msg": "invalid syntax"}}], ["a1144e5ba8d0eafcb55568ac6959abc3", {"code_string": "def create_mashup_dict(image_meta):\n    \"\"\"Returns a dictionary-like mashup of the image core properties\"\"\"\n    def get_items():\n        for key, value in six.iteritems(image_meta):\n            if isinstance(value, dict):\n                for subkey, subvalue in six.iteritems(\n                    create_mashup_dict(value)):\n                    if subkey not in image_meta:\n                    yield subkey, subvalue\n            else:\n                yield key, value\n    return dict(get_items())\n", "code_toks_joined": "def create_mashup_dict ( image_meta ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def get_items ( ) : <NEWLINE> <INDENT> for key , value in six . iteritems ( image_meta ) : <NEWLINE> <INDENT> if isinstance ( value , dict ) : <NEWLINE> <INDENT> for subkey , subvalue in six . iteritems ( <NEWLINE> <INDENT> create_mashup_dict ( value ) ) : <NEWLINE> if subkey not in image_meta : <NEWLINE> yield subkey , subvalue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> yield key , value <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dict ( get_items ( ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns a dictionary-like mashup of the image core properties\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["1d5587eac1e6deade3b1b3bf64bc5aa5", {"code_string": "def detect_encoding():\n    import locale\n    try:\n        try:\n            locale.setlocale(locale.LC_ALL, \"\")\n        except locale.Error:\n            pass\n        return locale.getlocale()[1] or \"\"\n    except ValueError, e:\n        if e.args and e.args[0].startswith(\"unknown locale\"):\n            return \"\"\n        else:\n            raise\n", "code_toks_joined": "def detect_encoding ( ) : <NEWLINE> <INDENT> import locale <NEWLINE> try : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> locale . setlocale ( locale . LC_ALL , <STRING> ) <NEWLINE> <DEDENT> except locale . Error : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> return locale . getlocale ( ) [ 1 ] or <STRING> <NEWLINE> <DEDENT> except ValueError , e : <NEWLINE> <INDENT> if e . args and e . args [ 0 ] . startswith ( <STRING> ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"", "\"\"", "\"unknown locale\"", "\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["7a328569c8fb98fedf110d36b867a7fd", {"code_string": "def load_tiles(tiles):\n    data = []\n    for t in tiles:\n    t = t.replace('truth', '')\n        f = hdf.File(data_dir + 'Aardvark_v1.0c_truth_des_rotated.' + t + '.hdf5', 'r')\n        dset = f[f.keys()[0]]\n        data.append(dset)\n    return data\n", "code_toks_joined": "def load_tiles ( tiles ) : <NEWLINE> <INDENT> data = [ ] <NEWLINE> for t in tiles : <NEWLINE> t = t . replace ( <STRING> , <STRING> ) <NEWLINE> <INDENT> f = hdf . File ( data_dir + <STRING> + t + <STRING> , <STRING> ) <NEWLINE> dset = f [ f . keys ( ) [ 0 ] ] <NEWLINE> data . append ( dset ) <NEWLINE> <DEDENT> return data <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'truth'", "''", "'Aardvark_v1.0c_truth_des_rotated.'", "'.hdf5'", "'r'"]}, "err_obj": {"msg": "expected an indented block"}}], ["1c2b330a0e77e402ff5bbca640d1df5f", {"code_string": "def teardown_module(module):\n    try:\n    except AttributeError:\n        pass\n    try:\n    except AttributeError:\n        pass\n", "code_toks_joined": "def teardown_module ( module ) : <NEWLINE> <INDENT> try : <NEWLINE> except AttributeError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> try : <NEWLINE> except AttributeError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["42ced2b8b322d8dfc8917241550b988f", {"code_string": "def print_user(self, i, user):\n    checked = 'x' if user.name in self.sel_users else ' '\n    print('%s%2d)%s [%s] %s%-20s%s \"%s <%s>\"' %(self.BOLD, i, self.NC, checked, )\n        self.BOLD, user.name, self.NC,\n        user.realname, user.email)\n", "code_toks_joined": "def print_user ( self , i , user ) : <NEWLINE> <INDENT> checked = <STRING> if user . name in self . sel_users else <STRING> <NEWLINE> print ( <STRING> % ( self . BOLD , i , self . NC , checked , ) <NEWLINE> <INDENT> self . BOLD , user . name , self . NC , <NEWLINE> user . realname , user . email ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'x'", "' '", "'%s%2d)%s [%s] %s%-20s%s \"%s <%s>\"'"]}, "err_obj": {"msg": "invalid syntax"}}], ["2c4fdb453119668c796c6f58d988a2f0", {"code_string": "def main():\n    decoder = Decoder(KEYCONF)\n        decoder.start_utt()\n        while True:\n            l, buf = INPUT.read()\n            if l:\n                decoder.process_raw(buf, False, False)\n            if decoder.hyp() != None:\n                decoder.end_utt()\n                result = decode_audio()\n                switch(result)\n                decoder.start_utt()\n", "code_toks_joined": "def main ( ) : <NEWLINE> <INDENT> decoder = Decoder ( KEYCONF ) <NEWLINE> <INDENT> decoder . start_utt ( ) <NEWLINE> while True : <NEWLINE> <INDENT> l , buf = INPUT . read ( ) <NEWLINE> if l : <NEWLINE> <INDENT> decoder . process_raw ( buf , False , False ) <NEWLINE> <DEDENT> if decoder . hyp ( ) != None : <NEWLINE> <INDENT> decoder . end_utt ( ) <NEWLINE> result = decode_audio ( ) <NEWLINE> switch ( result ) <NEWLINE> decoder . start_utt ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["0fbdc3f91a5d4e4e22a6f7e2629b2020", {"code_string": "def onMountpointAdded(mountpoint):\n    global searchPaths\n    try:\n        path = os.path.join(mountpoint, 'picon') + '/'\n        if os.path.isdir(path) and path not in searchPaths:\n            for fn in os.listdir(path):\n                if fn.endswith('.png'):\n                    print(\"[Picon] adding path:\", path)\n                    searchPaths.append(path)\n                    break\n    except Exception, ex:\n        print(\"[Picon] Failed to investigate %s:\" % mountpoint, ex)\n", "code_toks_joined": "def onMountpointAdded ( mountpoint ) : <NEWLINE> <INDENT> global searchPaths <NEWLINE> try : <NEWLINE> <INDENT> path = os . path . join ( mountpoint , <STRING> ) + <STRING> <NEWLINE> if os . path . isdir ( path ) and path not in searchPaths : <NEWLINE> <INDENT> for fn in os . listdir ( path ) : <NEWLINE> <INDENT> if fn . endswith ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> , path ) <NEWLINE> searchPaths . append ( path ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> except Exception , ex : <NEWLINE> <INDENT> print ( <STRING> % mountpoint , ex ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'picon'", "'/'", "'.png'", "\"[Picon] adding path:\"", "\"[Picon] Failed to investigate %s:\""]}, "err_obj": {"msg": "invalid syntax"}}], ["7fd3b3b15079d3921b700c89e6b53a10", {"code_string": "def send_unsent(self):\n    sent_count = 0\n    for unsent in Sendable.objects.filter(\n        sent_date__isnull = True).filter(send_failed = False):\n        if unsent.send_email():\n        sent_count += 1\n    return sent_count\n", "code_toks_joined": "def send_unsent ( self ) : <NEWLINE> <INDENT> sent_count = 0 <NEWLINE> for unsent in Sendable . objects . filter ( <NEWLINE> <INDENT> sent_date__isnull = True ) . filter ( send_failed = False ) : <NEWLINE> if unsent . send_email ( ) : <NEWLINE> sent_count += 1 <NEWLINE> <DEDENT> return sent_count <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["bec3592596c3d36991880508971b8aa2", {"code_string": "def simplify_section_result(section_result):\n    \"\"\"Takes in a section's result from ``execute_section`` and simplifies it\"\"\"\n    section_yielded_result = section_result[0]\n    results_for_section = []\n    for value in chain(section_result[1].values(),\n        section_result[2].values()):\n        if value is None:\n        continue\n        for result in value:\n        results_for_section.append(result)\n    section_yielded_unfixed_results = len(results_for_section) > 0\n    return(section_yielded_result,\n        section_yielded_unfixed_results,\n        results_for_section)\n", "code_toks_joined": "def simplify_section_result ( section_result ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> section_yielded_result = section_result [ 0 ] <NEWLINE> results_for_section = [ ] <NEWLINE> for value in chain ( section_result [ 1 ] . values ( ) , <NEWLINE> <INDENT> section_result [ 2 ] . values ( ) ) : <NEWLINE> if value is None : <NEWLINE> continue <NEWLINE> for result in value : <NEWLINE> results_for_section . append ( result ) <NEWLINE> <DEDENT> section_yielded_unfixed_results = len ( results_for_section ) > 0 <NEWLINE> return ( section_yielded_result , <NEWLINE> <INDENT> section_yielded_unfixed_results , <NEWLINE> results_for_section ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Takes in a section's result from ``execute_section`` and simplifies it\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["79f520f0710684227fcaecc9a3bf87b6", {"code_string": "def __init__(self, parent):\n    MainGui.MipFrame.__init__(self, parent)\n        self.m_textCtrlSmoothUrl.SetValue('http://www.iis.net/media/experiencesmoothstreaming')\n    self.mipproxy = MipProxy(frame = self, function = self.OnMipProxy)\n        self.m_textCtrlProxyUrl.SetValue('http://127.0.0.1:8888')\n        self.m_textCtrlMipPort.SetValue(str(MipProxy.PORT))\n        self.m_checkBoxOnlyLocalConnections.SetValue(True)\n        self.m_checkBoxBrowserCaching.SetValue(True)\n", "code_toks_joined": "def __init__ ( self , parent ) : <NEWLINE> <INDENT> MainGui . MipFrame . __init__ ( self , parent ) <NEWLINE> <INDENT> self . m_textCtrlSmoothUrl . SetValue ( <STRING> ) <NEWLINE> <DEDENT> self . mipproxy = MipProxy ( frame = self , function = self . OnMipProxy ) <NEWLINE> <INDENT> self . m_textCtrlProxyUrl . SetValue ( <STRING> ) <NEWLINE> self . m_textCtrlMipPort . SetValue ( str ( MipProxy . PORT ) ) <NEWLINE> self . m_checkBoxOnlyLocalConnections . SetValue ( True ) <NEWLINE> self . m_checkBoxBrowserCaching . SetValue ( True ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'http://www.iis.net/media/experiencesmoothstreaming'", "'http://127.0.0.1:8888'"]}, "err_obj": {"msg": "unexpected indent"}}], ["16108a8a2f2cb5d3d3f2f355eab9d398", {"code_string": "def stat(self):\n    \"\"\"Get mailbox status.\"\"\"\n    retval = self._shortcmd('STAT')\n    rets = retval.split()\n    if self._debugging: print '*stat*', repr(rets)\n    numMessages = int(rets[1])\n    sizeMessages = int(rets[2])\n    return(numMessages, sizeMessages)\n", "code_toks_joined": "def stat ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> retval = self . _shortcmd ( <STRING> ) <NEWLINE> rets = retval . split ( ) <NEWLINE> if self . _debugging : print <STRING> , repr ( rets ) <NEWLINE> numMessages = int ( rets [ 1 ] ) <NEWLINE> sizeMessages = int ( rets [ 2 ] ) <NEWLINE> return ( numMessages , sizeMessages ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get mailbox status.\"\"\"", "'STAT'", "'*stat*'"]}, "err_obj": {"msg": "invalid syntax"}}], ["f8e8e317e9a04a4c40683461ac020acf", {"code_string": "def evaluate(line, time, backrefs):\n    code = backrefs[1].strip()\n    print(code)\n    if len(code) == 0:\n        return\n    try:\n        exec code\n    except:\n        pass\n", "code_toks_joined": "def evaluate ( line , time , backrefs ) : <NEWLINE> <INDENT> code = backrefs [ 1 ] . strip ( ) <NEWLINE> print ( code ) <NEWLINE> if len ( code ) == 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> exec code <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["47978f7d68690f3b0576e945fcf0cf24", {"code_string": "def _format_mem(mem):\n    \"\"\"Return pretty string for printing memory contents.\"\"\"\n    return 'memory:\\n{mem}\\n'.format(\n        mem = '\\n'.join('{i}: {v}'.format(i = i v = v)\n            for i, v in enumerate(mem)))\n", "code_toks_joined": "def _format_mem ( mem ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return <STRING> . format ( <NEWLINE> <INDENT> mem = <STRING> . join ( <STRING> . format ( i = i v = v ) <NEWLINE> <INDENT> for i , v in enumerate ( mem ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return pretty string for printing memory contents.\"\"\"", "'memory:\\n{mem}\\n'", "'\\n'", "'{i}: {v}'"]}, "err_obj": {"msg": "invalid syntax"}}], ["c0b9ed5ba98df48913fd5415b4fdb9ff", {"code_string": "'''Some tests for the sequence and contig statistics calculations.'''\nimport unittest\nfrom StringIO import StringIO\nimport os, random, tempfile\nfrom franklin.statistics import(CachedArray, histogram, create_distribution,\n    draw_boxplot, draw_histogram\n    draw_stacked_columns, IntsStats)\nimport franklin\nTEST_DATA_DIR = os.path.join(os.path.split(franklin.__path__[0])[0], 'data')\n", "code_toks_joined": "<STRING> <NEWLINE> import unittest <NEWLINE> from StringIO import StringIO <NEWLINE> import os , random , tempfile <NEWLINE> from franklin . statistics import ( CachedArray , histogram , create_distribution , <NEWLINE> <INDENT> draw_boxplot , draw_histogram <NEWLINE> draw_stacked_columns , IntsStats ) <NEWLINE> <DEDENT> import franklin <NEWLINE> TEST_DATA_DIR = os . path . join ( os . path . split ( franklin . __path__ [ 0 ] ) [ 0 ] , <STRING> ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["'''Some tests for the sequence and contig statistics calculations.'''", "'data'"]}, "err_obj": {"msg": "invalid syntax"}}], ["d11eb7f263fcaef94e024eb13c63fa1f", {"code_string": "def get_spamhaus_active_entries()\n    \"\"\"Endpoint dedicated to retrieve active spamhaus entries.\"\"\"\n    return _retrieve_entries(True)\n", "code_toks_joined": "def get_spamhaus_active_entries ( ) <NEWLINE> <INDENT> <STRING> <NEWLINE> return _retrieve_entries ( True ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Endpoint dedicated to retrieve active spamhaus entries.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["1c5055d68c480d573a44886ce7c5b7c4", {"code_string": "def create_firewall(self, apply_list, firewall):\n    LOG.debug(_('Creating firewall and associating rule: %(rule_id)s)'),\n        {'rule_id': firewall['position']})\n        return self.update_firewall(apply_list, firewall)\n", "code_toks_joined": "def create_firewall ( self , apply_list , firewall ) : <NEWLINE> <INDENT> LOG . debug ( _ ( <STRING> ) , <NEWLINE> <INDENT> { <STRING> : firewall [ <STRING> ] } ) <NEWLINE> return self . update_firewall ( apply_list , firewall ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Creating firewall and associating rule: %(rule_id)s)'", "'rule_id'", "'position'"]}, "err_obj": {"msg": "unexpected indent"}}], ["8a82093037e742dd058c0ff4a6dec9c6", {"code_string": "def set_flag(self, pointer, flag_number, value):\n    \"\"\"Set a flag of the given block to be True / False.\"\"\"\n    if CHECK_ALLOCATED and not self._bf.get_flag(pointer, ALLOCATED):\n        raise StorageAllocatorException(\"illegal access to a free block\")\n    if flag_number < RESERVED_FLAGS:\n        raise StorageAllocatorException(\n            \"flag{} is reserved for StorageAllocator\".format(flag_number)\n    self._bf.set_flag(pointer, flag_number, value)\n", "code_toks_joined": "def set_flag ( self , pointer , flag_number , value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if CHECK_ALLOCATED and not self . _bf . get_flag ( pointer , ALLOCATED ) : <NEWLINE> <INDENT> raise StorageAllocatorException ( <STRING> ) <NEWLINE> <DEDENT> if flag_number < RESERVED_FLAGS : <NEWLINE> <INDENT> raise StorageAllocatorException ( <NEWLINE> <INDENT> <STRING> . format ( flag_number ) <NEWLINE> <DEDENT> <DEDENT> self . _bf . set_flag ( pointer , flag_number , value ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Set a flag of the given block to be True / False.\"\"\"", "\"illegal access to a free block\"", "\"flag{} is reserved for StorageAllocator\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["906fb39e7dde2897348c1789c37e94b5", {"code_string": "def test_wrappers(self):\n    self.o.ind = 4\n    self.n.ind = 5\n    self.assertEqual(6 .__index__(), 6)\n    self.assertEqual(- 7 .__index__(), - 7)\n    self.assertEqual(self.o.__index__(), 4)\n    self.assertEqual(self.n.__index__(), 5)\n    self.assertEqual(True.__index__(), 1)\n    self.assertEqual(False.__index__(), 0)\n", "code_toks_joined": "def test_wrappers ( self ) : <NEWLINE> <INDENT> self . o . ind = 4 <NEWLINE> self . n . ind = 5 <NEWLINE> self . assertEqual ( 6 . __index__ ( ) , 6 ) <NEWLINE> self . assertEqual ( - 7 . __index__ ( ) , - 7 ) <NEWLINE> self . assertEqual ( self . o . __index__ ( ) , 4 ) <NEWLINE> self . assertEqual ( self . n . __index__ ( ) , 5 ) <NEWLINE> self . assertEqual ( True . __index__ ( ) , 1 ) <NEWLINE> self . assertEqual ( False . __index__ ( ) , 0 ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["1d59f41ed1690681ab2aeb3451bb05c7", {"code_string": "def lowerhorizontal(self, direction = 0):\n    self.power = 0.4\n    dy = \"0\"\n    if direction == 0:\n        dx = \"30\"\n            self.ll()\n            else:\n            dx = \"-30\"\n            self.lr()\n            self.laser(dx, dy)\n            self.command = \"G90\"\n            if direction == 0:\n            dx = \"-30\"\n            self.lr()\n            else:\n            dx = \"30\"\n            self.ll()\n            self.laser(dx, dy)\n", "code_toks_joined": "def lowerhorizontal ( self , direction = 0 ) : <NEWLINE> <INDENT> self . power = 0.4 <NEWLINE> dy = <STRING> <NEWLINE> if direction == 0 : <NEWLINE> <INDENT> dx = <STRING> <NEWLINE> <INDENT> self . ll ( ) <NEWLINE> else : <NEWLINE> dx = <STRING> <NEWLINE> self . lr ( ) <NEWLINE> self . laser ( dx , dy ) <NEWLINE> self . command = <STRING> <NEWLINE> if direction == 0 : <NEWLINE> dx = <STRING> <NEWLINE> self . lr ( ) <NEWLINE> else : <NEWLINE> dx = <STRING> <NEWLINE> self . ll ( ) <NEWLINE> self . laser ( dx , dy ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"0\"", "\"30\"", "\"-30\"", "\"G90\"", "\"-30\"", "\"30\""]}, "err_obj": {"msg": "unexpected indent"}}], ["437227e41ad5d4a1bba274786b0ace44", {"code_string": "class Chip_PIC18F2321dip28(microchip8_18f2221family):\n    hasEEPROM = True\n        writeBufferSize = 8\n        eraseBufferSize = 64\n        def __init__(self):\n            microchip8_18f2221family.__init__(self,\n        chipPackage = \"DIP28\",\n        chipPinVCC = 20,\n        chipPinsVPP = 1,\n        chipPinGND = 19,\n        signature = \"\\x22\\x21\",\n        flashPageSize = 0x2000,\n        flashPages = 1,\n        eepromPageSize = 0x100,\n        eepromPages = 1,\n        fuseBytes = 14\n        )\n", "code_toks_joined": "class Chip_PIC18F2321dip28 ( microchip8_18f2221family ) : <NEWLINE> <INDENT> hasEEPROM = True <NEWLINE> <INDENT> writeBufferSize = 8 <NEWLINE> eraseBufferSize = 64 <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> microchip8_18f2221family . __init__ ( self , <NEWLINE> <DEDENT> chipPackage = <STRING> , <NEWLINE> chipPinVCC = 20 , <NEWLINE> chipPinsVPP = 1 , <NEWLINE> chipPinGND = 19 , <NEWLINE> signature = <STRING> , <NEWLINE> flashPageSize = 0x2000 , <NEWLINE> flashPages = 1 , <NEWLINE> eepromPageSize = 0x100 , <NEWLINE> eepromPages = 1 , <NEWLINE> fuseBytes = 14 <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"DIP28\"", "\"\\x22\\x21\""]}, "err_obj": {"msg": "unexpected indent"}}], ["1adf0fd79e00d97a564b4d958025bfd7", {"code_string": "def promote_read_replica(self, instance_name, ** params):\n    try:\n        result = self.connection.promote_read_replica(instance_name, ** params)['PromoteReadReplicaResponse']['PromoteReadReplicaResult']['DBInstance']\n        return RDS2DBInstance(result)\n    except boto.exception.BotoServerError, e:\n        raise RDSException(e)\n", "code_toks_joined": "def promote_read_replica ( self , instance_name , ** params ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> result = self . connection . promote_read_replica ( instance_name , ** params ) [ <STRING> ] [ <STRING> ] [ <STRING> ] <NEWLINE> return RDS2DBInstance ( result ) <NEWLINE> <DEDENT> except boto . exception . BotoServerError , e : <NEWLINE> <INDENT> raise RDSException ( e ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'PromoteReadReplicaResponse'", "'PromoteReadReplicaResult'", "'DBInstance'"]}, "err_obj": {"msg": "invalid syntax"}}], ["8d9cc54887520332feca963052586050", {"code_string": "def page(self):\n    warnings.warn(\n        \"Don't use the page attribute on CMSPlugins! CMSPlugins are not \"\n        \"guaranteed to have a page associated with them!\"\n        DontUsePageAttributeWarning)\n    return self.placeholder.page if self.placeholder_id else None\n", "code_toks_joined": "def page ( self ) : <NEWLINE> <INDENT> warnings . warn ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> DontUsePageAttributeWarning ) <NEWLINE> <DEDENT> return self . placeholder . page if self . placeholder_id else None <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Don't use the page attribute on CMSPlugins! CMSPlugins are not \"", "\"guaranteed to have a page associated with them!\""]}, "err_obj": {"msg": "invalid syntax"}}], ["eb199e6f2f680c5565258e38a357f319", {"code_string": "def setvalue(self, text):\n    list = string.split(text, ':')\n    if len(list) != 3:\n    raise ValueError, 'invalid value: ' + text\n    self._hour = string.atoi(list[0])\n    self._minute = string.atoi(list[1])\n    self._second = string.atoi(list[2])\n    self._setHMS()\n", "code_toks_joined": "def setvalue ( self , text ) : <NEWLINE> <INDENT> list = string . split ( text , <STRING> ) <NEWLINE> if len ( list ) != 3 : <NEWLINE> raise ValueError , <STRING> + text <NEWLINE> self . _hour = string . atoi ( list [ 0 ] ) <NEWLINE> self . _minute = string . atoi ( list [ 1 ] ) <NEWLINE> self . _second = string . atoi ( list [ 2 ] ) <NEWLINE> self . _setHMS ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["':'", "'invalid value: '"]}, "err_obj": {"msg": "expected an indented block"}}], ["6d014dffff5143cc98aa926ab4db4afc", {"code_string": "def Intersect_Grid_Square(gpos, (a, b)):\n    (x, y) = gpos\n    x -= 0.5\n    y -= 0.5\n    for(c, d) in[((x, y), (x + 1, y + 1)), ((x + 1, y), (x, y + 1))]:\n        if(intersect.Intersect((a, b), (c, d)) != None):\n            return True\n    return False\n", "code_toks_joined": "def Intersect_Grid_Square ( gpos , ( a , b ) ) : <NEWLINE> <INDENT> ( x , y ) = gpos <NEWLINE> x -= 0.5 <NEWLINE> y -= 0.5 <NEWLINE> for ( c , d ) in [ ( ( x , y ) , ( x + 1 , y + 1 ) ) , ( ( x + 1 , y ) , ( x , y + 1 ) ) ] : <NEWLINE> <INDENT> if ( intersect . Intersect ( ( a , b ) , ( c , d ) ) != None ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["fc573488f05eead81510fdfe3d967ba0", {"code_string": "categories = [\"addition\",\n    \"subtraction\",\n    \"multiplication\",\n    \"division\",\n    \"change_sign\",\n    \"round\",\n    \"partial_remainder\",\n    \"square_root\"]\nmicrocode = ''''''\nfor category in categories:\n    exec \"import %s as cat\" % category\n    microcode += cat.microcode\n", "code_toks_joined": "categories = [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ] <NEWLINE> <DEDENT> microcode = <STRING> <NEWLINE> for category in categories : <NEWLINE> <INDENT> exec <STRING> % category <NEWLINE> microcode += cat . microcode <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"addition\"", "\"subtraction\"", "\"multiplication\"", "\"division\"", "\"change_sign\"", "\"round\"", "\"partial_remainder\"", "\"square_root\"", "''''''", "\"import %s as cat\""]}, "err_obj": {"msg": "invalid syntax"}}], ["300445750c4b04cde35bdc74836431d9", {"code_string": "def testSuccessfulUnaryRequestUnaryResponse(self):\n    for(group, method), test_messages_sequence in(\n        self._digest.unary_unary_messages_sequences.iteritems()):\n        for test_messages in test_messages_sequence:\n        request = test_messages.request()\n        response, call = self._invoker.blocking(group, method)(\n            request, test_constants.LONG_TIMEOUT, with_call = True)\n        test_messages.verify(request, response, self)\n", "code_toks_joined": "def testSuccessfulUnaryRequestUnaryResponse ( self ) : <NEWLINE> <INDENT> for ( group , method ) , test_messages_sequence in ( <NEWLINE> <INDENT> self . _digest . unary_unary_messages_sequences . iteritems ( ) ) : <NEWLINE> for test_messages in test_messages_sequence : <NEWLINE> request = test_messages . request ( ) <NEWLINE> response , call = self . _invoker . blocking ( group , method ) ( <NEWLINE> <INDENT> request , test_constants . LONG_TIMEOUT , with_call = True ) <NEWLINE> <DEDENT> test_messages . verify ( request , response , self ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["88275cdce61d4cbe484952327a232171", {"code_string": "def setupUi(self, Dialog):\n    Dialog.setObjectName(_fromUtf8(\"Dialog\"))\n    Dialog.resize(600, 500)\n    sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(Dialog.sizePolicy().hasHeightForWidth())\n    Dialog.setSizePolicy(sizePolicy)\n    Dialog.setMinimumSize(QtCore.QSize(600, 500))\n    Dialog.setMaximumSize(QtCore.QSize(600, 500))\n    font = QtGui.QFont()\n    font.setBold(False)\n    font.setWeight(50)\n    Dialog.setFont(font)\n    Dialog.setToolTip(_fromUtf8(\"\"))\n    Dialog.setStatusTip(_fromUtf8(\"\"))\n    Dialog.setWhatsThis(_fromUtf8(\"\"))\n    Dialog.setAccessibleName(_fromUtf8(\"\"))\n    Dialog.setAccessibleDescription(_fromUtf8(\"\"))\n    self.onglets = QtGui.QTabWidget(Dialog)\n    self.onglets.setEnabled(True)\n    self.onglets.setGeometry(QtCore.QRect(0, 0, 600, 500))\n    sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Expanding)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(self.onglets.sizePolicy().hasHeightForWidth())\n    self.onglets.setSizePolicy(sizePolicy)\n    self.onglets.setToolTip(_fromUtf8(\"\"))\n    self.onglets.setStatusTip(_fromUtf8(\"\"))\n    self.onglets.setWhatsThis(_fromUtf8(\"\"))\n    self.onglets.setAccessibleName(_fromUtf8(\"\"))\n    self.onglets.setAccessibleDescription(_fromUtf8(\"\"))\n    self.onglets.setStyleSheet(_fromUtf8(\"background-color: rgb(245, 245, 245);\"))\n    self.onglets.setDocumentMode(False)\n    self.onglets.setObjectName(_fromUtf8(\"onglets\"))\n    self.tab_lot = QtGui.QWidget()\n    sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Maximum, QtGui.QSizePolicy.Preferred)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(self.tab_lot.sizePolicy().hasHeightForWidth())\n    self.tab_lot.setSizePolicy(sizePolicy)\n    self.tab_lot.setMaximumSize(QtCore.QSize(600, 16777215))\n    font = QtGui.QFont()\n    font.setBold(False)\n    font.setWeight(50)\n    self.tab_lot.setFont(font)\n    self.tab_lot.setToolTip(_fromUtf8(\"\"))\n    self.tab_lot.setStatusTip(_fromUtf8(\"\"))\n    self.tab_lot.setWhatsThis(_fromUtf8(\"\"))\n    self.tab_lot.setAccessibleName(_fromUtf8(\"\"))\n    self.tab_lot.setAccessibleDescription(_fromUtf8(\"\"))\n    self.tab_lot.setAutoFillBackground(False)\n    self.tab_lot.setObjectName(_fromUtf8(\"tab_lot\"))\n    self.commandLinkButton = QtGui.QCommandLinkButton(self.tab_lot)\n    self.commandLinkButton.setGeometry(QtCore.QRect(60, 360, 172, 41))\n    self.commandLinkButton.setAccessibleName(_fromUtf8(\"\"))\n    self.commandLinkButton.setAccessibleDescription(_fromUtf8(\"\"))\n    self.commandLinkButton.setAutoFillBackground(False)\n    self.commandLinkButton.setText(_fromUtf8(\"Selectionner les fichiers\"))\n    self.commandLinkButton.setDescription(_fromUtf8(\"\"))\n    self.commandLinkButton.setObjectName(_fromUtf8(\"commandLinkButton\"))\n    self.line = QtGui.QFrame(self.tab_lot)\n    self.line.setGeometry(QtCore.QRect(0, 440, 591, 16))\n    self.line.setFrameShape(QtGui.QFrame.HLine)\n    self.line.setFrameShadow(QtGui.QFrame.Sunken)\n    self.line.setObjectName(_fromUtf8(\"line\"))\n    self.label_nb = QtGui.QLabel(self.tab_lot)\n    self.label_nb.setGeometry(QtCore.QRect(180, 450, 231, 16))\n    self.label_nb.setText(_fromUtf8(\"Aucun fichier s\u00e9lectionn\u00e9\"))\n    self.label_nb.setAlignment(QtCore.Qt.AlignCenter)\n    self.label_nb.setObjectName(_fromUtf8(\"label_nb\"))\n    self.groupBox = QtGui.QGroupBox(self.tab_lot)\n    self.groupBox.setEnabled(True)\n    self.groupBox.setGeometry(QtCore.QRect(0, 10, 591, 71))\n    font = QtGui.QFont()\n    font.setBold(True)\n    font.setWeight(75)\n    self.groupBox.setFont(font)\n    self.groupBox.setToolTip(_fromUtf8(\"R\u00e9duit toutes les images de l\\'epub\"))\n    self.groupBox.setStatusTip(_fromUtf8(\"\"))\n    self.groupBox.setWhatsThis(_fromUtf8(\"\"))\n    self.groupBox.setAccessibleName(_fromUtf8(\"\"))\n    self.groupBox.setAccessibleDescription(_fromUtf8(\"\"))\n    self.groupBox.setAutoFillBackground(False)\n    self.groupBox.setTitle(_fromUtf8(\"Images\"))\n    self.groupBox.setAlignment(QtCore.Qt.AlignJustify | QtCore.Qt.AlignVCenter)\n    self.groupBox.setCheckable(False)\n    self.groupBox.setChecked(False)\n    self.groupBox.setObjectName(_fromUtf8(\"groupBox\"))\n    self.label_taille = QtGui.QLabel(self.groupBox)\n    self.label_taille.setGeometry(QtCore.QRect(190, 20, 41, 16))\n    self.label_taille.setStyleSheet(_fromUtf8(\"font-weight:normal\"))\n    self.label_taille.setText(_fromUtf8(\"Taille :\"))\n    self.label_taille.setObjectName(_fromUtf8(\"label_taille\"))\n    self.comboBox_taille = QtGui.QComboBox(self.groupBox)\n    self.comboBox_taille.setGeometry(QtCore.QRect(230, 20, 84, 18))\n    sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Fixed)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(self.comboBox_taille.sizePolicy().hasHeightForWidth())\n    self.comboBox_taille.setSizePolicy(sizePolicy)\n    self.comboBox_taille.setToolTip(_fromUtf8(\"S\u00e9lectionnez votre format d\\'affichage\"))\n    self.comboBox_taille.setStatusTip(_fromUtf8(\"\"))\n    self.comboBox_taille.setWhatsThis(_fromUtf8(\"\"))\n    self.comboBox_taille.setAccessibleName(_fromUtf8(\"\"))\n    self.comboBox_taille.setAccessibleDescription(_fromUtf8(\"\"))\n    self.comboBox_taille.setStyleSheet(_fromUtf8(\"background-color: rgb(255, 255, 255);\"))\n    self.comboBox_taille.setInputMethodHints(QtCore.Qt.ImhNone)\n    self.comboBox_taille.setEditable(True)\n    self.comboBox_taille.setSizeAdjustPolicy(QtGui.QComboBox.AdjustToContents)\n    self.comboBox_taille.setObjectName(_fromUtf8(\"comboBox_taille\"))\n    self.comboBox_taille.addItem(_fromUtf8(\"\"))\n    self.comboBox_taille.setItemText(0, _fromUtf8(\"\"))\n    self.comboBox_taille.addItem(_fromUtf8(\"\"))\n    self.comboBox_taille.setItemText(1, _fromUtf8(\"480 x 320\"))\n    self.comboBox_taille.addItem(_fromUtf8(\"\"))\n    self.comboBox_taille.setItemText(2, _fromUtf8(\"800 x 600\"))\n    self.comboBox_taille.addItem(_fromUtf8(\"\"))\n    self.comboBox_taille.setItemText(3, _fromUtf8(\"960 x 640\"))\n    self.comboBox_taille.addItem(_fromUtf8(\"\"))\n    self.comboBox_taille.setItemText(4, _fromUtf8(\"1024 x 768\"))\n    self.comboBox_taille.addItem(_fromUtf8(\"\"))\n    self.comboBox_taille.setItemText(5, _fromUtf8(\"1136 x 640\"))\n    self.comboBox_taille.addItem(_fromUtf8(\"\"))\n    self.comboBox_taille.setItemText(6, _fromUtf8(\"1280 x 800\"))\n    self.horizontalSlider_quality = QtGui.QSlider(self.groupBox)\n    self.horizontalSlider_quality.setGeometry(QtCore.QRect(410, 30, 160, 19))\n    sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(self.horizontalSlider_quality.sizePolicy().hasHeightForWidth())\n    self.horizontalSlider_quality.setSizePolicy(sizePolicy)\n    self.horizontalSlider_quality.setMouseTracking(True)\n    self.horizontalSlider_quality.setToolTip(_fromUtf8(\"Ajustez la compression jpg\"))\n    self.horizontalSlider_quality.setStatusTip(_fromUtf8(\"\"))\n    self.horizontalSlider_quality.setWhatsThis(_fromUtf8(\"\"))\n    self.horizontalSlider_quality.setAccessibleName(_fromUtf8(\"\"))\n    self.horizontalSlider_quality.setAccessibleDescription(_fromUtf8(\"\"))\n    self.horizontalSlider_quality.setMaximum(100)\n    self.horizontalSlider_quality.setSliderPosition(85)\n    self.horizontalSlider_quality.setOrientation(QtCore.Qt.Horizontal)\n    self.horizontalSlider_quality.setTickPosition(QtGui.QSlider.TicksBelow)\n    self.horizontalSlider_quality.setTickInterval(10)\n    self.horizontalSlider_quality.setObjectName(_fromUtf8(\"horizontalSlider_quality\"))\n    self.label_quality = QtGui.QLabel(self.groupBox)\n    self.label_quality.setGeometry(QtCore.QRect(330, 30, 71, 16))\n    self.label_quality.setToolTip(_fromUtf8(\"Utilisable seulement sur les JPG\"))\n    self.label_quality.setWhatsThis(_fromUtf8(\"\"))\n    self.label_quality.setAccessibleName(_fromUtf8(\"\"))\n    self.label_quality.setAccessibleDescription(_fromUtf8(\"\"))\n    self.label_quality.setStyleSheet(_fromUtf8(\"font-weight:normal\"))\n    self.label_quality.setText(_fromUtf8(\"Qualit\u00e9 JPG :\"))\n    self.label_quality.setObjectName(_fromUtf8(\"label_quality\"))\n    self.label_basse = QtGui.QLabel(self.groupBox)\n    self.label_basse.setGeometry(QtCore.QRect(400, 10, 31, 20))\n    self.label_basse.setStyleSheet(_fromUtf8(\"font-weight:normal\"))\n    self.label_basse.setText(_fromUtf8(\"Basse\"))\n    self.label_basse.setObjectName(_fromUtf8(\"label_basse\"))\n    self.label = QtGui.QLabel(self.groupBox)\n    self.label.setGeometry(QtCore.QRect(470, 10, 46, 13))\n    self.label.setToolTip(_fromUtf8(\"\"))\n    self.label.setStatusTip(_fromUtf8(\"\"))\n    self.label.setWhatsThis(_fromUtf8(\"\"))\n    self.label.setAccessibleName(_fromUtf8(\"\"))\n    self.label.setAccessibleDescription(_fromUtf8(\"\"))\n    self.label.setStyleSheet(_fromUtf8(\"font-weight:normal\"))\n    self.label.setText(_fromUtf8(\"textquality\"))\n    self.label.setObjectName(_fromUtf8(\"label\"))\n    self.label_elevee = QtGui.QLabel(self.groupBox)\n    self.label_elevee.setGeometry(QtCore.QRect(550, 10, 41, 16))\n    self.label_elevee.setStyleSheet(_fromUtf8(\"font-weight:normal\"))\n    self.label_elevee.setText(_fromUtf8(\"Elev\u00e9e\"))\n    self.label_elevee.setObjectName(_fromUtf8(\"label_elevee\"))\n    self.checkBox_4 = QtGui.QCheckBox(self.groupBox)\n    self.checkBox_4.setEnabled(True)\n    self.checkBox_4.setGeometry(QtCore.QRect(10, 40, 161, 17))\n    self.checkBox_4.setStyleSheet(_fromUtf8(\"font-weight:normal\"))\n    self.checkBox_4.setObjectName(_fromUtf8(\"checkBox_4\"))\n    self.checkBox_5 = QtGui.QCheckBox(self.groupBox)\n    self.checkBox_5.setGeometry(QtCore.QRect(10, 20, 161, 17))\n    self.checkBox_5.setStyleSheet(_fromUtf8(\"font-weight:normal\"))\n    self.checkBox_5.setObjectName(_fromUtf8(\"checkBox_5\"))\n    self.groupBox_css = QtGui.QGroupBox(self.tab_lot)\n    self.groupBox_css.setGeometry(QtCore.QRect(0, 80, 271, 91))\n    font = QtGui.QFont()\n    font.setBold(True)\n    font.setWeight(75)\n    self.groupBox_css.setFont(font)\n    self.groupBox_css.setWhatsThis(_fromUtf8(\"\"))\n    self.groupBox_css.setAccessibleName(_fromUtf8(\"\"))\n    self.groupBox_css.setAccessibleDescription(_fromUtf8(\"\"))\n    self.groupBox_css.setStyleSheet(_fromUtf8(\"\"))\n    self.groupBox_css.setTitle(_fromUtf8(\"CSS\"))\n    self.groupBox_css.setCheckable(True)\n    self.groupBox_css.setChecked(False)\n    self.groupBox_css.setObjectName(_fromUtf8(\"groupBox_css\"))\n    self.Expos = QtGui.QCheckBox(self.groupBox_css)\n    self.Expos.setGeometry(QtCore.QRect(70, 20, 131, 17))\n    self.Expos.setToolTip(_fromUtf8(\"\u00c9vite que les exposants et appels de note ne d\u00e9calent l\\'interligne\"))\n    self.Expos.setStatusTip(_fromUtf8(\"\"))\n    self.Expos.setWhatsThis(_fromUtf8(\"\"))\n    self.Expos.setStyleSheet(_fromUtf8(\"font-weight:normal\"))\n    self.Expos.setText(_fromUtf8(\"Corriger les exposants\"))\n    self.Expos.setChecked(False)\n    self.Expos.setObjectName(_fromUtf8(\"Expos\"))\n    self.checkBox_fonts = QtGui.QCheckBox(self.groupBox_css)\n    self.checkBox_fonts.setGeometry(QtCore.QRect(70, 40, 141, 17))\n    self.checkBox_fonts.setToolTip(_fromUtf8(\"Ne garde que les caract\u00e8res utiles de chaque police, supprime les autres.\\n\"\n", "code_toks_joined": "def setupUi ( self , Dialog ) : <NEWLINE> <INDENT> Dialog . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> Dialog . resize ( 600 , 500 ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Fixed , QtGui . QSizePolicy . Fixed ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( Dialog . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> Dialog . setSizePolicy ( sizePolicy ) <NEWLINE> Dialog . setMinimumSize ( QtCore . QSize ( 600 , 500 ) ) <NEWLINE> Dialog . setMaximumSize ( QtCore . QSize ( 600 , 500 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setBold ( False ) <NEWLINE> font . setWeight ( 50 ) <NEWLINE> Dialog . setFont ( font ) <NEWLINE> Dialog . setToolTip ( _fromUtf8 ( <STRING> ) ) <NEWLINE> Dialog . setStatusTip ( _fromUtf8 ( <STRING> ) ) <NEWLINE> Dialog . setWhatsThis ( _fromUtf8 ( <STRING> ) ) <NEWLINE> Dialog . setAccessibleName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> Dialog . setAccessibleDescription ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . onglets = QtGui . QTabWidget ( Dialog ) <NEWLINE> self . onglets . setEnabled ( True ) <NEWLINE> self . onglets . setGeometry ( QtCore . QRect ( 0 , 0 , 600 , 500 ) ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Fixed , QtGui . QSizePolicy . Expanding ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( self . onglets . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> self . onglets . setSizePolicy ( sizePolicy ) <NEWLINE> self . onglets . setToolTip ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . onglets . setStatusTip ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . onglets . setWhatsThis ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . onglets . setAccessibleName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . onglets . setAccessibleDescription ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . onglets . setStyleSheet ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . onglets . setDocumentMode ( False ) <NEWLINE> self . onglets . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . tab_lot = QtGui . QWidget ( ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Maximum , QtGui . QSizePolicy . Preferred ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( self . tab_lot . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> self . tab_lot . setSizePolicy ( sizePolicy ) <NEWLINE> self . tab_lot . setMaximumSize ( QtCore . QSize ( 600 , 16777215 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setBold ( False ) <NEWLINE> font . setWeight ( 50 ) <NEWLINE> self . tab_lot . setFont ( font ) <NEWLINE> self . tab_lot . setToolTip ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . tab_lot . setStatusTip ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . tab_lot . setWhatsThis ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . tab_lot . setAccessibleName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . tab_lot . setAccessibleDescription ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . tab_lot . setAutoFillBackground ( False ) <NEWLINE> self . tab_lot . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . commandLinkButton = QtGui . QCommandLinkButton ( self . tab_lot ) <NEWLINE> self . commandLinkButton . setGeometry ( QtCore . QRect ( 60 , 360 , 172 , 41 ) ) <NEWLINE> self . commandLinkButton . setAccessibleName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . commandLinkButton . setAccessibleDescription ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . commandLinkButton . setAutoFillBackground ( False ) <NEWLINE> self . commandLinkButton . setText ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . commandLinkButton . setDescription ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . commandLinkButton . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . line = QtGui . QFrame ( self . tab_lot ) <NEWLINE> self . line . setGeometry ( QtCore . QRect ( 0 , 440 , 591 , 16 ) ) <NEWLINE> self . line . setFrameShape ( QtGui . QFrame . HLine ) <NEWLINE> self . line . setFrameShadow ( QtGui . QFrame . Sunken ) <NEWLINE> self . line . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label_nb = QtGui . QLabel ( self . tab_lot ) <NEWLINE> self . label_nb . setGeometry ( QtCore . QRect ( 180 , 450 , 231 , 16 ) ) <NEWLINE> self . label_nb . setText ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label_nb . setAlignment ( QtCore . Qt . AlignCenter ) <NEWLINE> self . label_nb . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . groupBox = QtGui . QGroupBox ( self . tab_lot ) <NEWLINE> self . groupBox . setEnabled ( True ) <NEWLINE> self . groupBox . setGeometry ( QtCore . QRect ( 0 , 10 , 591 , 71 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setBold ( True ) <NEWLINE> font . setWeight ( 75 ) <NEWLINE> self . groupBox . setFont ( font ) <NEWLINE> self . groupBox . setToolTip ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . groupBox . setStatusTip ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . groupBox . setWhatsThis ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . groupBox . setAccessibleName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . groupBox . setAccessibleDescription ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . groupBox . setAutoFillBackground ( False ) <NEWLINE> self . groupBox . setTitle ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . groupBox . setAlignment ( QtCore . Qt . AlignJustify | QtCore . Qt . AlignVCenter ) <NEWLINE> self . groupBox . setCheckable ( False ) <NEWLINE> self . groupBox . setChecked ( False ) <NEWLINE> self . groupBox . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label_taille = QtGui . QLabel ( self . groupBox ) <NEWLINE> self . label_taille . setGeometry ( QtCore . QRect ( 190 , 20 , 41 , 16 ) ) <NEWLINE> self . label_taille . setStyleSheet ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label_taille . setText ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label_taille . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . comboBox_taille = QtGui . QComboBox ( self . groupBox ) <NEWLINE> self . comboBox_taille . setGeometry ( QtCore . QRect ( 230 , 20 , 84 , 18 ) ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Expanding , QtGui . QSizePolicy . Fixed ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( self . comboBox_taille . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> self . comboBox_taille . setSizePolicy ( sizePolicy ) <NEWLINE> self . comboBox_taille . setToolTip ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . comboBox_taille . setStatusTip ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . comboBox_taille . setWhatsThis ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . comboBox_taille . setAccessibleName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . comboBox_taille . setAccessibleDescription ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . comboBox_taille . setStyleSheet ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . comboBox_taille . setInputMethodHints ( QtCore . Qt . ImhNone ) <NEWLINE> self . comboBox_taille . setEditable ( True ) <NEWLINE> self . comboBox_taille . setSizeAdjustPolicy ( QtGui . QComboBox . AdjustToContents ) <NEWLINE> self . comboBox_taille . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . comboBox_taille . addItem ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . comboBox_taille . setItemText ( 0 , _fromUtf8 ( <STRING> ) ) <NEWLINE> self . comboBox_taille . addItem ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . comboBox_taille . setItemText ( 1 , _fromUtf8 ( <STRING> ) ) <NEWLINE> self . comboBox_taille . addItem ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . comboBox_taille . setItemText ( 2 , _fromUtf8 ( <STRING> ) ) <NEWLINE> self . comboBox_taille . addItem ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . comboBox_taille . setItemText ( 3 , _fromUtf8 ( <STRING> ) ) <NEWLINE> self . comboBox_taille . addItem ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . comboBox_taille . setItemText ( 4 , _fromUtf8 ( <STRING> ) ) <NEWLINE> self . comboBox_taille . addItem ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . comboBox_taille . setItemText ( 5 , _fromUtf8 ( <STRING> ) ) <NEWLINE> self . comboBox_taille . addItem ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . comboBox_taille . setItemText ( 6 , _fromUtf8 ( <STRING> ) ) <NEWLINE> self . horizontalSlider_quality = QtGui . QSlider ( self . groupBox ) <NEWLINE> self . horizontalSlider_quality . setGeometry ( QtCore . QRect ( 410 , 30 , 160 , 19 ) ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Fixed , QtGui . QSizePolicy . Fixed ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( self . horizontalSlider_quality . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> self . horizontalSlider_quality . setSizePolicy ( sizePolicy ) <NEWLINE> self . horizontalSlider_quality . setMouseTracking ( True ) <NEWLINE> self . horizontalSlider_quality . setToolTip ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . horizontalSlider_quality . setStatusTip ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . horizontalSlider_quality . setWhatsThis ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . horizontalSlider_quality . setAccessibleName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . horizontalSlider_quality . setAccessibleDescription ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . horizontalSlider_quality . setMaximum ( 100 ) <NEWLINE> self . horizontalSlider_quality . setSliderPosition ( 85 ) <NEWLINE> self . horizontalSlider_quality . setOrientation ( QtCore . Qt . Horizontal ) <NEWLINE> self . horizontalSlider_quality . setTickPosition ( QtGui . QSlider . TicksBelow ) <NEWLINE> self . horizontalSlider_quality . setTickInterval ( 10 ) <NEWLINE> self . horizontalSlider_quality . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label_quality = QtGui . QLabel ( self . groupBox ) <NEWLINE> self . label_quality . setGeometry ( QtCore . QRect ( 330 , 30 , 71 , 16 ) ) <NEWLINE> self . label_quality . setToolTip ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label_quality . setWhatsThis ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label_quality . setAccessibleName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label_quality . setAccessibleDescription ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label_quality . setStyleSheet ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label_quality . setText ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label_quality . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label_basse = QtGui . QLabel ( self . groupBox ) <NEWLINE> self . label_basse . setGeometry ( QtCore . QRect ( 400 , 10 , 31 , 20 ) ) <NEWLINE> self . label_basse . setStyleSheet ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label_basse . setText ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label_basse . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label = QtGui . QLabel ( self . groupBox ) <NEWLINE> self . label . setGeometry ( QtCore . QRect ( 470 , 10 , 46 , 13 ) ) <NEWLINE> self . label . setToolTip ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label . setStatusTip ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label . setWhatsThis ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label . setAccessibleName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label . setAccessibleDescription ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label . setStyleSheet ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label . setText ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label_elevee = QtGui . QLabel ( self . groupBox ) <NEWLINE> self . label_elevee . setGeometry ( QtCore . QRect ( 550 , 10 , 41 , 16 ) ) <NEWLINE> self . label_elevee . setStyleSheet ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label_elevee . setText ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label_elevee . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . checkBox_4 = QtGui . QCheckBox ( self . groupBox ) <NEWLINE> self . checkBox_4 . setEnabled ( True ) <NEWLINE> self . checkBox_4 . setGeometry ( QtCore . QRect ( 10 , 40 , 161 , 17 ) ) <NEWLINE> self . checkBox_4 . setStyleSheet ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . checkBox_4 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . checkBox_5 = QtGui . QCheckBox ( self . groupBox ) <NEWLINE> self . checkBox_5 . setGeometry ( QtCore . QRect ( 10 , 20 , 161 , 17 ) ) <NEWLINE> self . checkBox_5 . setStyleSheet ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . checkBox_5 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . groupBox_css = QtGui . QGroupBox ( self . tab_lot ) <NEWLINE> self . groupBox_css . setGeometry ( QtCore . QRect ( 0 , 80 , 271 , 91 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setBold ( True ) <NEWLINE> font . setWeight ( 75 ) <NEWLINE> self . groupBox_css . setFont ( font ) <NEWLINE> self . groupBox_css . setWhatsThis ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . groupBox_css . setAccessibleName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . groupBox_css . setAccessibleDescription ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . groupBox_css . setStyleSheet ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . groupBox_css . setTitle ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . groupBox_css . setCheckable ( True ) <NEWLINE> self . groupBox_css . setChecked ( False ) <NEWLINE> self . groupBox_css . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . Expos = QtGui . QCheckBox ( self . groupBox_css ) <NEWLINE> self . Expos . setGeometry ( QtCore . QRect ( 70 , 20 , 131 , 17 ) ) <NEWLINE> self . Expos . setToolTip ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . Expos . setStatusTip ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . Expos . setWhatsThis ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . Expos . setStyleSheet ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . Expos . setText ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . Expos . setChecked ( False ) <NEWLINE> self . Expos . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . checkBox_fonts = QtGui . QCheckBox ( self . groupBox_css ) <NEWLINE> self . checkBox_fonts . setGeometry ( QtCore . QRect ( 70 , 40 , 141 , 17 ) ) <NEWLINE> self . checkBox_fonts . setToolTip ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Dialog\"", "\"\"", "\"\"", "\"\"", "\"\"", "\"\"", "\"\"", "\"\"", "\"\"", "\"\"", "\"\"", "\"background-color: rgb(245, 245, 245);\"", "\"onglets\"", "\"\"", "\"\"", "\"\"", "\"\"", "\"\"", "\"tab_lot\"", "\"\"", "\"\"", "\"Selectionner les fichiers\"", "\"\"", "\"commandLinkButton\"", "\"line\"", "\"Aucun fichier s\u00e9lectionn\u00e9\"", "\"label_nb\"", "\"R\u00e9duit toutes les images de l\\'epub\"", "\"\"", "\"\"", "\"\"", "\"\"", "\"Images\"", "\"groupBox\"", "\"font-weight:normal\"", "\"Taille :\"", "\"label_taille\"", "\"S\u00e9lectionnez votre format d\\'affichage\"", "\"\"", "\"\"", "\"\"", "\"\"", "\"background-color: rgb(255, 255, 255);\"", "\"comboBox_taille\"", "\"\"", "\"\"", "\"\"", "\"480 x 320\"", "\"\"", "\"800 x 600\"", "\"\"", "\"960 x 640\"", "\"\"", "\"1024 x 768\"", "\"\"", "\"1136 x 640\"", "\"\"", "\"1280 x 800\"", "\"Ajustez la compression jpg\"", "\"\"", "\"\"", "\"\"", "\"\"", "\"horizontalSlider_quality\"", "\"Utilisable seulement sur les JPG\"", "\"\"", "\"\"", "\"\"", "\"font-weight:normal\"", "\"Qualit\u00e9 JPG :\"", "\"label_quality\"", "\"font-weight:normal\"", "\"Basse\"", "\"label_basse\"", "\"\"", "\"\"", "\"\"", "\"\"", "\"\"", "\"font-weight:normal\"", "\"textquality\"", "\"label\"", "\"font-weight:normal\"", "\"Elev\u00e9e\"", "\"label_elevee\"", "\"font-weight:normal\"", "\"checkBox_4\"", "\"font-weight:normal\"", "\"checkBox_5\"", "\"\"", "\"\"", "\"\"", "\"\"", "\"CSS\"", "\"groupBox_css\"", "\"\u00c9vite que les exposants et appels de note ne d\u00e9calent l\\'interligne\"", "\"\"", "\"\"", "\"font-weight:normal\"", "\"Corriger les exposants\"", "\"Expos\"", "\"Ne garde que les caract\u00e8res utiles de chaque police, supprime les autres.\\n\""]}, "window_span": [2527, 2533], "err_obj": {"msg": "unbalanced (){}[]"}}], ["61c09401021971c92e02bb33076b07c2", {"code_string": "def update(climate_data, sched_data):\n    counter = 0\n    for line in climate_data:\n        counter += 1\n    if(counter < 8761):\n        print(\"This is not a complete climate file, it has less than 8760 entries.\")\n        exit()\n    sys.stdout.write(climate_data[0])\n    for i in range(1, counter):\n    if(float(sched_data[i - 1]) > 0.0):\n        sys.stdout.write(climate_data[i])\n", "code_toks_joined": "def update ( climate_data , sched_data ) : <NEWLINE> <INDENT> counter = 0 <NEWLINE> for line in climate_data : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> if ( counter < 8761 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> sys . stdout . write ( climate_data [ 0 ] ) <NEWLINE> for i in range ( 1 , counter ) : <NEWLINE> if ( float ( sched_data [ i - 1 ] ) > 0.0 ) : <NEWLINE> <INDENT> sys . stdout . write ( climate_data [ i ] ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"This is not a complete climate file, it has less than 8760 entries.\""]}, "err_obj": {"msg": "expected an indented block"}}], ["561dfa0aeccac66738838abe590e89d4", {"code_string": "def assert_web_ui_redaction(self, query_id, unredacted_value, redacted_value):\n    '''Asserts that the 'unredacted_value' is not present but the 'redacted_value' is.'''\n    impala_service = self.create_impala_service()\n    for page in('queries', 'query_stmt', 'query_plan_text', 'query_summary',\n        'query_profile', 'query_plan'):\n        for response_format in('html', 'json'):\n        url = page + '?query_id=' + query_id + \"&\" + response_format\n        results = self.grep_file(impala_service.open_debug_webpage(url), unredacted_value)\n        assert not results, \"Web page %s should not contain '%s' but does\" %(url, unredacted_value)\n    self.assert_web_ui_contains(query_id, redacted_value)\n", "code_toks_joined": "def assert_web_ui_redaction ( self , query_id , unredacted_value , redacted_value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> impala_service = self . create_impala_service ( ) <NEWLINE> for page in ( <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> ) : <NEWLINE> for response_format in ( <STRING> , <STRING> ) : <NEWLINE> url = page + <STRING> + query_id + <STRING> + response_format <NEWLINE> results = self . grep_file ( impala_service . open_debug_webpage ( url ) , unredacted_value ) <NEWLINE> assert not results , <STRING> % ( url , unredacted_value ) <NEWLINE> <DEDENT> self . assert_web_ui_contains ( query_id , redacted_value ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Asserts that the 'unredacted_value' is not present but the 'redacted_value' is.'''", "'queries'", "'query_stmt'", "'query_plan_text'", "'query_summary'", "'query_profile'", "'query_plan'", "'html'", "'json'", "'?query_id='", "\"&\"", "\"Web page %s should not contain '%s' but does\""]}, "err_obj": {"msg": "expected an indented block"}}], ["6ae3d5fddf31b6b8372464efcecf086c", {"code_string": "def test_empty_path_hooks(self):\n    path_entry = 'bogus_path'\n    with util.import_state(path_importer_cache = {}, path_hooks = [],\n        path = [path_entry]):\n        with warnings.catch_warnings(record = True) as w:\n        warnings.simplefilter('always')\n        self.assertIsNone(self.machinery.PathFinder.find_module('os'))\n        self.assertIsNone(sys.path_importer_cache[path_entry])\n        self.assertEqual(len(w), 1)\n        self.assertTrue(issubclass(w[- 1].category, ImportWarning))\n", "code_toks_joined": "def test_empty_path_hooks ( self ) : <NEWLINE> <INDENT> path_entry = <STRING> <NEWLINE> with util . import_state ( path_importer_cache = { } , path_hooks = [ ] , <NEWLINE> <INDENT> path = [ path_entry ] ) : <NEWLINE> with warnings . catch_warnings ( record = True ) as w : <NEWLINE> warnings . simplefilter ( <STRING> ) <NEWLINE> self . assertIsNone ( self . machinery . PathFinder . find_module ( <STRING> ) ) <NEWLINE> self . assertIsNone ( sys . path_importer_cache [ path_entry ] ) <NEWLINE> self . assertEqual ( len ( w ) , 1 ) <NEWLINE> self . assertTrue ( issubclass ( w [ - 1 ] . category , ImportWarning ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'bogus_path'", "'always'", "'os'"]}, "err_obj": {"msg": "expected an indented block"}}], ["0eb5292549584bd093bfc154aae17470", {"code_string": "class Ui_DialogAskDelete(object):\n    def setupUi(self, DialogAskDelete):\n        DialogAskDelete.setObjectName(\"DialogAsDelete\")\n        DialogAskDelete.resize(400, 108)\n        icon = QtGui.QIcon()\n        icon.addPixmap(QtGui.QPixmap(\"img/logo-djtango.png\"), QtGui.QIcon.Normal, QtGui.QIcon.Off)\n        DialogAskDelete.setWindowIcon(icon)\n        DialogAskDelete.setStyleSheet(\"QDialog{\\n\"\n", "code_toks_joined": "class Ui_DialogAskDelete ( object ) : <NEWLINE> <INDENT> def setupUi ( self , DialogAskDelete ) : <NEWLINE> <INDENT> DialogAskDelete . setObjectName ( <STRING> ) <NEWLINE> DialogAskDelete . resize ( 400 , 108 ) <NEWLINE> icon = QtGui . QIcon ( ) <NEWLINE> icon . addPixmap ( QtGui . QPixmap ( <STRING> ) , QtGui . QIcon . Normal , QtGui . QIcon . Off ) <NEWLINE> DialogAskDelete . setWindowIcon ( icon ) <NEWLINE> DialogAskDelete . setStyleSheet ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"DialogAsDelete\"", "\"img/logo-djtango.png\"", "\"QDialog{\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["f6c1f0ff8f6a560528967849053b3f10", {"code_string": "def getAnswer(self, key):\n    \"\"\"Retrieves a dictionary representing the answer associated with a given answer key, if it exists or None if it doesn't.\"\"\"\n        return self.db[\"answer\"].find({\"key\": key}) if key is not None else self.db[\"answer\"].find()\n", "code_toks_joined": "def getAnswer ( self , key ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> return self . db [ <STRING> ] . find ( { <STRING> : key } ) if key is not None else self . db [ <STRING> ] . find ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Retrieves a dictionary representing the answer associated with a given answer key, if it exists or None if it doesn't.\"\"\"", "\"answer\"", "\"key\"", "\"answer\""]}, "err_obj": {"msg": "unexpected indent"}}], ["60541cdc86b4455c89a39b7b45f03dca", {"code_string": "class Error(Exception):\n    \"\"\"Base class for exceptions in this module.\"\"\"\n    def __init__(self, msg):\n        self.msg = msg\n    def __str__(self):\n    print(\"\", self.msg)\n", "code_toks_joined": "class Error ( Exception ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , msg ) : <NEWLINE> <INDENT> self . msg = msg <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> print ( <STRING> , self . msg ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Base class for exceptions in this module.\"\"\"", "\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["ca0cce2f463dfb85dd5fd54fb15da4c5", {"code_string": "def get_share_code_json(share_code):\n    assert re.match(\"[A-Za-z0-9]{8}\", share_code)\n    url = \"https://api.atlauncher.com/v1/share-codes/\" + share_code\n    try:\n        d = urllib2.urlopen(url)\n    except urllib2.HTTPError, e:\n        if e.code == 404:\n            print(\"ERROR - HTTP 404 while retrieving share code - {u}\".format(u = url))\n            raise\n    j = d.read()\n    d.close()\n    return j\n", "code_toks_joined": "def get_share_code_json ( share_code ) : <NEWLINE> <INDENT> assert re . match ( <STRING> , share_code ) <NEWLINE> url = <STRING> + share_code <NEWLINE> try : <NEWLINE> <INDENT> d = urllib2 . urlopen ( url ) <NEWLINE> <DEDENT> except urllib2 . HTTPError , e : <NEWLINE> <INDENT> if e . code == 404 : <NEWLINE> <INDENT> print ( <STRING> . format ( u = url ) ) <NEWLINE> raise <NEWLINE> <DEDENT> <DEDENT> j = d . read ( ) <NEWLINE> d . close ( ) <NEWLINE> return j <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"[A-Za-z0-9]{8}\"", "\"https://api.atlauncher.com/v1/share-codes/\"", "\"ERROR - HTTP 404 while retrieving share code - {u}\""]}, "err_obj": {"msg": "invalid syntax"}}], ["1aff23522ac1e83cfbd053fff68706ac", {"code_string": "def checkCourse(Run, Org, Number):\n    if len(Run + Org + Number) > 64:\n    return \"is_more_than_65\"\n    else:\n    return Run + Org + Number\n", "code_toks_joined": "def checkCourse ( Run , Org , Number ) : <NEWLINE> <INDENT> if len ( Run + Org + Number ) > 64 : <NEWLINE> return <STRING> <NEWLINE> else : <NEWLINE> return Run + Org + Number <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"is_more_than_65\""]}, "err_obj": {"msg": "expected an indented block"}}], ["0559074e0c295a59ff4079828cce0df4", {"code_string": "def set_ssl_validation(self, options):\n    if self._config.get('skip_ssl_validation', False):\n        options['verify'] = False\n    elif Platform.is_windows():\n        options['verify'] = os.path.realpath(os.path.join(\n            os.path.dirname(os.path.realpath(__file__),\n            os.pardir, os.pardir,\n            'datadog-cert.pem'\n        ))\n", "code_toks_joined": "def set_ssl_validation ( self , options ) : <NEWLINE> <INDENT> if self . _config . get ( <STRING> , False ) : <NEWLINE> <INDENT> options [ <STRING> ] = False <NEWLINE> <DEDENT> elif Platform . is_windows ( ) : <NEWLINE> <INDENT> options [ <STRING> ] = os . path . realpath ( os . path . join ( <NEWLINE> <INDENT> os . path . dirname ( os . path . realpath ( __file__ ) , <NEWLINE> os . pardir , os . pardir , <NEWLINE> <STRING> <NEWLINE> <DEDENT> ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'skip_ssl_validation'", "'verify'", "'verify'", "'datadog-cert.pem'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["028192d494e4f99cd00928dac8bf2ab1", {"code_string": "def zoom(self, scale, (mx, my)):\n    worldPos = self.unprojectAtHeight(self.width() / 2, self.height() / 2, 0)\n    if scale != self.scale:\n        self.scale = scale\n        newWorldPos = self.unprojectAtHeight(self.width() / 2, self.height() / 2, 0)\n        delta = newWorldPos - worldPos\n        self.centerPoint = self.centerPoint - delta\n", "code_toks_joined": "def zoom ( self , scale , ( mx , my ) ) : <NEWLINE> <INDENT> worldPos = self . unprojectAtHeight ( self . width ( ) / 2 , self . height ( ) / 2 , 0 ) <NEWLINE> if scale != self . scale : <NEWLINE> <INDENT> self . scale = scale <NEWLINE> newWorldPos = self . unprojectAtHeight ( self . width ( ) / 2 , self . height ( ) / 2 , 0 ) <NEWLINE> delta = newWorldPos - worldPos <NEWLINE> self . centerPoint = self . centerPoint - delta <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["be01b4f0c2f8e34e79ed3dfdf396e491", {"code_string": "def check_preconditions(cls):\n    super(TestNetworkAdvancedServerOps, cls).check_preconditions()\n    if not(CONF.network.tenant_networks_reachable\n        or CONF.network.public_network_id):\n        msg = ('Either tenant_networks_reachable must be \"true\", or '\n            'public_network_id must be defined.')\n            cls.enabled = False\n            raise cls.skipException(msg)\n", "code_toks_joined": "def check_preconditions ( cls ) : <NEWLINE> <INDENT> super ( TestNetworkAdvancedServerOps , cls ) . check_preconditions ( ) <NEWLINE> if not ( CONF . network . tenant_networks_reachable <NEWLINE> <INDENT> or CONF . network . public_network_id ) : <NEWLINE> msg = ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> cls . enabled = False <NEWLINE> raise cls . skipException ( msg ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Either tenant_networks_reachable must be \"true\", or '", "'public_network_id must be defined.'"]}, "err_obj": {"msg": "unexpected indent"}}], ["6896ea9dda0d82bc878a0efcbdb8d81b", {"code_string": "def whichlevel(n):\n    for i in range(len(mlevel)):\n        if mlevel[i] <= n <= mlevel[i + 1]:\n        return i + 1\n", "code_toks_joined": "def whichlevel ( n ) : <NEWLINE> <INDENT> for i in range ( len ( mlevel ) ) : <NEWLINE> <INDENT> if mlevel [ i ] <= n <= mlevel [ i + 1 ] : <NEWLINE> return i + 1 <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["16a82e547a120f229059680665728816", {"code_string": "'''Created on Feb 21, 2016'''\nfrom optparse import OptionParser\nfrom nma_algo_char.common import load_control_json, pair_parameter_values, parameter_value_to_string, MetropolisMCSimulator\nimport os.path\nfrom nma_algo_char.data_retrieval import load_cc_data, load_ic_data, process_energy_differences, process_after_perturb_rmsd\nimport numpy\nif __name__ == '__main__':\n    parser = OptionParser()\n    parser.add_option(\"-e\", dest = \"experiment\")\n    parser.add_option(\"-w\", dest = \"workspace\")\n    parser.add_option(\"-f\", dest = \"folder\")\n    (options, args) = parser.parse_args()\n    if not options.experiment:\n        parser.error('Experiment file not given')\n    experiment_details = load_control_json(options.experiment)\n    if options.workspace is not None:\n        workspace = os.path.normpath(options.workspace)\n    else:\n        workspace = os.path.normpath(experiment_details[\"workspace\"])\n    print(\"RESULT\\tMean\\tSigma\\tRMSD\\t\\tAcceptance\\t\\t\")\n    for(p1, v1), (p2, v2) in pair_parameter_values(experiment_details[\"check\"], experiment_details[\"parameter_values\"]):\n        folder_name = \"%s_%s_%s_%s_%s\" %(experiment_details[\"prefix\"],\n            experiment_details[\"parameter_abbv\"][p1], parameter_value_to_string(v1),\n            experiment_details[\"parameter_abbv\"][p2], parameter_value_to_string(v2))\n        dataAvailable = True\n        try:\n            if experiment_details[\"prefix\"] == \"CC\":\n                raw_data, data_len = load_cc_data(os.path.join(workspace,\n                    folder_name,\n                    options.folder),\n                    full_pele_energy = True,\n                    skip_first = 5)\n            if experiment_details[\"prefix\"] == \"IC\":\n                raw_data, data_len = load_ic_data(os.path.join(workspace,\n                    folder_name,\n                    options.folder),\n                    skip_first = 5)\n        except:\n            print(\"Data could not be loaded. Skipping %s = %.3f  %s = %.3f \" %(p1, v1, p2, v2))\n            dataAvailable = False\n        if dataAvailable:\n            energy_increments = process_energy_differences(raw_data)\n            rmsd_increments = process_after_perturb_rmsd(raw_data)\n            acc_mean_and_avg = MetropolisMCSimulator(energy_increments).perform_simulation(\n                min(100, len(energy_increments)), 20, 300)\n            mean = (float(v1) + float(v2)) / 2.\n            sigma = (float(v1) - float(v2)) / 4.\n            print(\"RESULT\\t%.3f\\t(%.3f)\\t%.3f\\t(%.3f)\\t%.3f\\t(%.3f)\" %(mean, sigma,\n                numpy.mean(rmsd_increments), numpy.std(rmsd_increments),\n                acc_mean_and_avg[0], acc_mean_and_avg[1]), v1, v2\n", "code_toks_joined": "<STRING> <NEWLINE> from optparse import OptionParser <NEWLINE> from nma_algo_char . common import load_control_json , pair_parameter_values , parameter_value_to_string , MetropolisMCSimulator <NEWLINE> import os . path <NEWLINE> from nma_algo_char . data_retrieval import load_cc_data , load_ic_data , process_energy_differences , process_after_perturb_rmsd <NEWLINE> import numpy <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> parser = OptionParser ( ) <NEWLINE> parser . add_option ( <STRING> , dest = <STRING> ) <NEWLINE> parser . add_option ( <STRING> , dest = <STRING> ) <NEWLINE> parser . add_option ( <STRING> , dest = <STRING> ) <NEWLINE> ( options , args ) = parser . parse_args ( ) <NEWLINE> if not options . experiment : <NEWLINE> <INDENT> parser . error ( <STRING> ) <NEWLINE> <DEDENT> experiment_details = load_control_json ( options . experiment ) <NEWLINE> if options . workspace is not None : <NEWLINE> <INDENT> workspace = os . path . normpath ( options . workspace ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> workspace = os . path . normpath ( experiment_details [ <STRING> ] ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for ( p1 , v1 ) , ( p2 , v2 ) in pair_parameter_values ( experiment_details [ <STRING> ] , experiment_details [ <STRING> ] ) : <NEWLINE> <INDENT> folder_name = <STRING> % ( experiment_details [ <STRING> ] , <NEWLINE> <INDENT> experiment_details [ <STRING> ] [ p1 ] , parameter_value_to_string ( v1 ) , <NEWLINE> experiment_details [ <STRING> ] [ p2 ] , parameter_value_to_string ( v2 ) ) <NEWLINE> <DEDENT> dataAvailable = True <NEWLINE> try : <NEWLINE> <INDENT> if experiment_details [ <STRING> ] == <STRING> : <NEWLINE> <INDENT> raw_data , data_len = load_cc_data ( os . path . join ( workspace , <NEWLINE> <INDENT> folder_name , <NEWLINE> options . folder ) , <NEWLINE> full_pele_energy = True , <NEWLINE> skip_first = 5 ) <NEWLINE> <DEDENT> <DEDENT> if experiment_details [ <STRING> ] == <STRING> : <NEWLINE> <INDENT> raw_data , data_len = load_ic_data ( os . path . join ( workspace , <NEWLINE> <INDENT> folder_name , <NEWLINE> options . folder ) , <NEWLINE> skip_first = 5 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> % ( p1 , v1 , p2 , v2 ) ) <NEWLINE> dataAvailable = False <NEWLINE> <DEDENT> if dataAvailable : <NEWLINE> <INDENT> energy_increments = process_energy_differences ( raw_data ) <NEWLINE> rmsd_increments = process_after_perturb_rmsd ( raw_data ) <NEWLINE> acc_mean_and_avg = MetropolisMCSimulator ( energy_increments ) . perform_simulation ( <NEWLINE> <INDENT> min ( 100 , len ( energy_increments ) ) , 20 , 300 ) <NEWLINE> <DEDENT> mean = ( float ( v1 ) + float ( v2 ) ) / 2. <NEWLINE> sigma = ( float ( v1 ) - float ( v2 ) ) / 4. <NEWLINE> print ( <STRING> % ( mean , sigma , <NEWLINE> <INDENT> numpy . mean ( rmsd_increments ) , numpy . std ( rmsd_increments ) , <NEWLINE> acc_mean_and_avg [ 0 ] , acc_mean_and_avg [ 1 ] ) , v1 , v2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Created on Feb 21, 2016'''", "'__main__'", "\"-e\"", "\"experiment\"", "\"-w\"", "\"workspace\"", "\"-f\"", "\"folder\"", "'Experiment file not given'", "\"workspace\"", "\"RESULT\\tMean\\tSigma\\tRMSD\\t\\tAcceptance\\t\\t\"", "\"check\"", "\"parameter_values\"", "\"%s_%s_%s_%s_%s\"", "\"prefix\"", "\"parameter_abbv\"", "\"parameter_abbv\"", "\"prefix\"", "\"CC\"", "\"prefix\"", "\"IC\"", "\"Data could not be loaded. Skipping %s = %.3f  %s = %.3f \"", "\"RESULT\\t%.3f\\t(%.3f)\\t%.3f\\t(%.3f)\\t%.3f\\t(%.3f)\""]}, "window_span": [442, 486], "err_obj": {"msg": "unbalanced (){}[]"}}], ["17979beec968081a2328c80132b67a0f", {"code_string": "def is_running(service):\n    \"\"\"Check if a service is running.\"\"\"\n    with settings(hide('running', 'stdout', 'stderr', 'warnings'),\n        warn_only = True):\n        if using_systemd():\n        return systemd.is_running(service)\n        else:\n        if distrib_family() != \"gentoo\":\n        test_upstart = run_as_root('test -f /etc/init/%s.conf' %\n            service)\n            status = _service(service, 'status')\n            if test_upstart.succeeded:\n            return 'running' in status\n            else:\n            return status.succeeded\n            else:\n            status = _service(service, 'status')\n            return ' started' in status\n", "code_toks_joined": "def is_running ( service ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with settings ( hide ( <STRING> , <STRING> , <STRING> , <STRING> ) , <NEWLINE> <INDENT> warn_only = True ) : <NEWLINE> if using_systemd ( ) : <NEWLINE> return systemd . is_running ( service ) <NEWLINE> else : <NEWLINE> if distrib_family ( ) != <STRING> : <NEWLINE> test_upstart = run_as_root ( <STRING> % <NEWLINE> <INDENT> service ) <NEWLINE> status = _service ( service , <STRING> ) <NEWLINE> if test_upstart . succeeded : <NEWLINE> return <STRING> in status <NEWLINE> else : <NEWLINE> return status . succeeded <NEWLINE> else : <NEWLINE> status = _service ( service , <STRING> ) <NEWLINE> return <STRING> in status <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Check if a service is running.\"\"\"", "'running'", "'stdout'", "'stderr'", "'warnings'", "\"gentoo\"", "'test -f /etc/init/%s.conf'", "'status'", "'running'", "'status'", "' started'"]}, "err_obj": {"msg": "expected an indented block"}}], ["e45ebe13d27884208f1a43f9947b66fc", {"code_string": "def dgettext(domain, message):\n    try:\n        t = translation(domain, _localedirs.get(domain, None)\n            codeset = _localecodesets.get(domain))\n    except IOError:\n        return message\n    return t.gettext(message)\n", "code_toks_joined": "def dgettext ( domain , message ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> t = translation ( domain , _localedirs . get ( domain , None ) <NEWLINE> <INDENT> codeset = _localecodesets . get ( domain ) ) <NEWLINE> <DEDENT> <DEDENT> except IOError : <NEWLINE> <INDENT> return message <NEWLINE> <DEDENT> return t . gettext ( message ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["b72212b3463d9bc2f28c4d37c2162d0d", {"code_string": "def line_format((filename, lineno, content)):\n    global current_file, current_line\n    if current_file != filename or current_line + 10 < lineno:\n        info = \"\\n# \" + str(lineno) + \" \\\"\" + relpath(filename) + \"\\\"\\n\"\n        current_file = filename\n        current_line = lineno\n    else:\n        info = \"\"\n    newlines = \"\"\n    while current_line < lineno:\n        newlines += '\\n'\n        current_line += 1\n    return info + newlines + content + \" \"\n", "code_toks_joined": "def line_format ( ( filename , lineno , content ) ) : <NEWLINE> <INDENT> global current_file , current_line <NEWLINE> if current_file != filename or current_line + 10 < lineno : <NEWLINE> <INDENT> info = <STRING> + str ( lineno ) + <STRING> + relpath ( filename ) + <STRING> <NEWLINE> current_file = filename <NEWLINE> current_line = lineno <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> info = <STRING> <NEWLINE> <DEDENT> newlines = <STRING> <NEWLINE> while current_line < lineno : <NEWLINE> <INDENT> newlines += <STRING> <NEWLINE> current_line += 1 <NEWLINE> <DEDENT> return info + newlines + content + <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\\n# \"", "\" \\\"\"", "\"\\\"\\n\"", "\"\"", "\"\"", "'\\n'", "\" \""]}, "err_obj": {"msg": "invalid syntax"}}], ["212b82338c3e046b391ae6a15aa260f0", {"code_string": "def _delete_floating_ip(self, server, fip):\n    with logging.ExceptionLogger(\n        LOG, _(\"Unable to delete IP: %s\") % fip[\"ip\"]):\n        if self.check_ip_address(fip[\"ip\"])(server):\n        self._dissociate_floating_ip(server, fip[\"ip\"])\n        network_wrapper.wrap(self.clients).delete_floating_ip(fip[\"id\"],\n            wait = True)\n", "code_toks_joined": "def _delete_floating_ip ( self , server , fip ) : <NEWLINE> <INDENT> with logging . ExceptionLogger ( <NEWLINE> <INDENT> LOG , _ ( <STRING> ) % fip [ <STRING> ] ) : <NEWLINE> if self . check_ip_address ( fip [ <STRING> ] ) ( server ) : <NEWLINE> self . _dissociate_floating_ip ( server , fip [ <STRING> ] ) <NEWLINE> network_wrapper . wrap ( self . clients ) . delete_floating_ip ( fip [ <STRING> ] , <NEWLINE> <INDENT> wait = True ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Unable to delete IP: %s\"", "\"ip\"", "\"ip\"", "\"ip\"", "\"id\""]}, "err_obj": {"msg": "expected an indented block"}}], ["ea1e2494aaaf5a77a0ae7fc9531c7b1f", {"code_string": "def create_topology(controllers, options):\n    \"\"\" Called from create_system in configs/ruby/<protocol>.py\"\"\"\n    exec \"import %s as Topo\" % options.topology\n    topology = eval(\"Topo.%s(controllers)\" % options.topology)\n    return topology\n", "code_toks_joined": "def create_topology ( controllers , options ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> exec <STRING> % options . topology <NEWLINE> topology = eval ( <STRING> % options . topology ) <NEWLINE> return topology <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Called from create_system in configs/ruby/<protocol>.py\"\"\"", "\"import %s as Topo\"", "\"Topo.%s(controllers)\""]}, "err_obj": {"msg": "invalid syntax"}}], ["2a6510aa5f2239045315e463706475ef", {"code_string": "def __init__(self, x, y, (confDict, key)):\n    Positionable.__init__(self, x, y)\n    self.confDict = confDict\n    self.key = key\n    self.leds = [LED(0, (1 - i) * Positionable.scaleFactor * LED.ledLedSpacing, LED.blue) for i in range(LedLine.nbLeds)]\n", "code_toks_joined": "def __init__ ( self , x , y , ( confDict , key ) ) : <NEWLINE> <INDENT> Positionable . __init__ ( self , x , y ) <NEWLINE> self . confDict = confDict <NEWLINE> self . key = key <NEWLINE> self . leds = [ LED ( 0 , ( 1 - i ) * Positionable . scaleFactor * LED . ledLedSpacing , LED . blue ) for i in range ( LedLine . nbLeds ) ] <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["e6ccc8ee08f26b6532ce5e6145d6fd35", {"code_string": "def doSetTilt(self):\n    try:\n    self.proxy.setTilt(self.ui.sbTilt.value())\n    self.ui.lcdTilt.display(self.ui.sbTilt.value())\n    except Ice.Exception:\n    traceback.print_exc()\n", "code_toks_joined": "def doSetTilt ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> self . proxy . setTilt ( self . ui . sbTilt . value ( ) ) <NEWLINE> self . ui . lcdTilt . display ( self . ui . sbTilt . value ( ) ) <NEWLINE> except Ice . Exception : <NEWLINE> traceback . print_exc ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["648e5cc7273cafb934d52f8173f9bb52", {"code_string": "class LocalDeleteFolder(BaseOperation):\n    \"\"\"Delete a folder(and all containing files)locally\"\"\"\n    def _run(self):\n        shutil.rmtree(str(self.local)\n        DatabaseDeleteFolder(self._context).run()\n", "code_toks_joined": "class LocalDeleteFolder ( BaseOperation ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def _run ( self ) : <NEWLINE> <INDENT> shutil . rmtree ( str ( self . local ) <NEWLINE> DatabaseDeleteFolder ( self . _context ) . run ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Delete a folder(and all containing files)locally\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["4d45e93907149d30788c9fc0ab019e7e", {"code_string": "import sys\nfrom psycopg2 import connect\nfrom psycopg2.extras import RealDictCursor\nif len(sys.argv) < 2:\n    print('usage: $ search.py[osm_id1][osm_id2]')\nconnection = connect(database = 'nskparks', cursor_factory = RealDictCursor)\ncursor = connection.cursor()\ncursor.execute('''insert into parks(osm_id, name, contour_913, contour)''', (sys.argv[1: ], ))\ncursor.execute(\"\"\"insert into distances(park, house, direct_distance, population)\"\"\", (sys.argv[1: ], )\nconnection.commit()\n", "code_toks_joined": "import sys <NEWLINE> from psycopg2 import connect <NEWLINE> from psycopg2 . extras import RealDictCursor <NEWLINE> if len ( sys . argv ) < 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> connection = connect ( database = <STRING> , cursor_factory = RealDictCursor ) <NEWLINE> cursor = connection . cursor ( ) <NEWLINE> cursor . execute ( <STRING> , ( sys . argv [ 1 : ] , ) ) <NEWLINE> cursor . execute ( <STRING> , ( sys . argv [ 1 : ] , ) <NEWLINE> connection . commit ( ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["'usage: $ search.py[osm_id1][osm_id2]'", "'nskparks'", "'''insert into parks(osm_id, name, contour_913, contour)'''", "\"\"\"insert into distances(park, house, direct_distance, population)\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["030af99cff4320d4002adfae33e98934", {"code_string": "def init():\n    '''I created this function just to make the script usable for other purposes.'''\n    init_string = '[+] Rotational System Process init.'\n    init_downld = '[*] Fetching the files from GDrive...'\n    init_parsef = '[*] Parsing and Processing the files..'\n    print(colored(init_string, 'green'))\n    print(colored(init_downld, 'blue'))\n    print(colored(init_parsef, 'blue'))\n    count = 0\n    with open('drive.conf', 'r') as f:\n    for line in f:\n        if count < 1:\n    url_timings = line\n        url_tasks = line\n            count += 1\n    download_files(url_timings, list_timings)\n    download_files(url_tasks, list_tasks)\n    return\n", "code_toks_joined": "def init ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> init_string = <STRING> <NEWLINE> init_downld = <STRING> <NEWLINE> init_parsef = <STRING> <NEWLINE> print ( colored ( init_string , <STRING> ) ) <NEWLINE> print ( colored ( init_downld , <STRING> ) ) <NEWLINE> print ( colored ( init_parsef , <STRING> ) ) <NEWLINE> count = 0 <NEWLINE> with open ( <STRING> , <STRING> ) as f : <NEWLINE> for line in f : <NEWLINE> <INDENT> if count < 1 : <NEWLINE> <DEDENT> url_timings = line <NEWLINE> <INDENT> url_tasks = line <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> download_files ( url_timings , list_timings ) <NEWLINE> download_files ( url_tasks , list_tasks ) <NEWLINE> return <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''I created this function just to make the script usable for other purposes.'''", "'[+] Rotational System Process init.'", "'[*] Fetching the files from GDrive...'", "'[*] Parsing and Processing the files..'", "'green'", "'blue'", "'blue'", "'drive.conf'", "'r'"]}, "err_obj": {"msg": "expected an indented block"}}], ["2b074ffac88e1a6e03b1a643e85a56bf", {"code_string": "def test_split_version(self):\n    \"\"\"Test version split across two packets\"\"\"\n    with patch('asyncssh.connection.SSHClientConnection',\n        _SplitClientConnection):\n        with(yield from self.connect()) as conn:\n        pass\n        yield from conn.wait_closed()\n", "code_toks_joined": "def test_split_version ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with patch ( <STRING> , <NEWLINE> <INDENT> _SplitClientConnection ) : <NEWLINE> with ( yield from self . connect ( ) ) as conn : <NEWLINE> pass <NEWLINE> yield from conn . wait_closed ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Test version split across two packets\"\"\"", "'asyncssh.connection.SSHClientConnection'"]}, "err_obj": {"msg": "expected an indented block"}}], ["59e5d3c87b1529d277241d4dc1fd9839", {"code_string": "class MetadataSystem(object):\n    def __init__(self):\n    self.GetSystemID = None\n    self.GetSystemDescription = None\n    self.GetComments = None\n    self.GetTimeZoneOffset = None\n    self.GetMetadataID = None\n    self.GetResourceVersion = None\n    self.GetResourceDate = None\n    self.GetForeignKeyVersion = None\n    self.GetForeignKeyDate = None\n    self.GetFilterVersion = None\n    self.GetFilterDate = None\n", "code_toks_joined": "class MetadataSystem ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> self . GetSystemID = None <NEWLINE> self . GetSystemDescription = None <NEWLINE> self . GetComments = None <NEWLINE> self . GetTimeZoneOffset = None <NEWLINE> self . GetMetadataID = None <NEWLINE> self . GetResourceVersion = None <NEWLINE> self . GetResourceDate = None <NEWLINE> self . GetForeignKeyVersion = None <NEWLINE> self . GetForeignKeyDate = None <NEWLINE> self . GetFilterVersion = None <NEWLINE> self . GetFilterDate = None <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["bbe9740699e62041470b5977e1b3e838", {"code_string": "def setContentType(request, response):\n    if request['output'] == 'xml':\n    response.setContentType('text/xml')\n    elif request['output'] == 'text':\n    response.setContentType('text/plain')\n    else:\n    response.setContentType('text/html')\n", "code_toks_joined": "def setContentType ( request , response ) : <NEWLINE> <INDENT> if request [ <STRING> ] == <STRING> : <NEWLINE> response . setContentType ( <STRING> ) <NEWLINE> elif request [ <STRING> ] == <STRING> : <NEWLINE> response . setContentType ( <STRING> ) <NEWLINE> else : <NEWLINE> response . setContentType ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'output'", "'xml'", "'text/xml'", "'output'", "'text'", "'text/plain'", "'text/html'"]}, "err_obj": {"msg": "expected an indented block"}}], ["250b62af11693bcbda1974a808465930", {"code_string": "def TargetProgram(env, target, source, install_dir = None):\n    if env['ARCH'] != 'host':\n    env.Program(target, source)\n    env.TargetInstall(target, install_dir)\n", "code_toks_joined": "def TargetProgram ( env , target , source , install_dir = None ) : <NEWLINE> <INDENT> if env [ <STRING> ] != <STRING> : <NEWLINE> env . Program ( target , source ) <NEWLINE> env . TargetInstall ( target , install_dir ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'ARCH'", "'host'"]}, "err_obj": {"msg": "expected an indented block"}}], ["6839cf3f5b6381a0808264b73238077c", {"code_string": "def configureSubApplications(configProperties):\n    try:\n        internalApps = configProperties.getProperty('wls.subapplications')\n        if not internalApps is None:\n    log.info('Setting up applications')\n    internalAppsList = internalApps.split(',')\n    for internalApp in internalAppsList:\n        internalAppName = configProperties.getProperty('wls.subapplication.' + internalApp + '.name')\n        internalAppSubdeployments = configProperties.getProperty('wls.subapplication.' + internalApp + '.subdeployments')\n        if not internalAppSubdeployments is None:\n            __configureInternalAppSubdeployments(internalApp, internalAppName, internalAppSubdeployments, configProperties)\n    except Exception, error:\n        log.error(str(error))\n", "code_toks_joined": "def configureSubApplications ( configProperties ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> internalApps = configProperties . getProperty ( <STRING> ) <NEWLINE> if not internalApps is None : <NEWLINE> <DEDENT> log . info ( <STRING> ) <NEWLINE> internalAppsList = internalApps . split ( <STRING> ) <NEWLINE> for internalApp in internalAppsList : <NEWLINE> <INDENT> internalAppName = configProperties . getProperty ( <STRING> + internalApp + <STRING> ) <NEWLINE> internalAppSubdeployments = configProperties . getProperty ( <STRING> + internalApp + <STRING> ) <NEWLINE> if not internalAppSubdeployments is None : <NEWLINE> <INDENT> __configureInternalAppSubdeployments ( internalApp , internalAppName , internalAppSubdeployments , configProperties ) <NEWLINE> <DEDENT> <DEDENT> except Exception , error : <NEWLINE> <INDENT> log . error ( str ( error ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'wls.subapplications'", "'Setting up applications'", "','", "'wls.subapplication.'", "'.name'", "'wls.subapplication.'", "'.subdeployments'"]}, "err_obj": {"msg": "expected an indented block"}}], ["b7f3184dd39eaac0aef864b4936c62bb", {"code_string": "def login(self, environ, req, username = None, password = None, ** kw):\n    if self._auth.login(environ, username, password)\n        return self.register(environ, REG_KEY + \":\" + \"login\", username)\n    raise HTTPUnauthorized(\"Unauthorized user!\")\n", "code_toks_joined": "def login ( self , environ , req , username = None , password = None , ** kw ) : <NEWLINE> <INDENT> if self . _auth . login ( environ , username , password ) <NEWLINE> <INDENT> return self . register ( environ , REG_KEY + <STRING> + <STRING> , username ) <NEWLINE> <DEDENT> raise HTTPUnauthorized ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\":\"", "\"login\"", "\"Unauthorized user!\""]}, "err_obj": {"msg": "invalid syntax"}}], ["049f80ec6afa2304ea4fa8fea52fe646", {"code_string": "def _resolve_name(self, import_setting):\n    name = import_setting.name\n    try:\n        name = self.variables.replace_string(name)\n    except DataError, err:\n        self._raise_replacing_vars_failed(import_setting, err)\n    return self._get_path(name, import_setting.directory, import_setting.type)\n", "code_toks_joined": "def _resolve_name ( self , import_setting ) : <NEWLINE> <INDENT> name = import_setting . name <NEWLINE> try : <NEWLINE> <INDENT> name = self . variables . replace_string ( name ) <NEWLINE> <DEDENT> except DataError , err : <NEWLINE> <INDENT> self . _raise_replacing_vars_failed ( import_setting , err ) <NEWLINE> <DEDENT> return self . _get_path ( name , import_setting . directory , import_setting . type ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["7307f4e37b44a1758d056fbb164d6d52", {"code_string": "def actor_after_save(sender, instance, created, ** kwargs):\n    \"\"\"Called to ensure the calendar is created for a given actor\"\"\"\n    if created:\n    pass\n", "code_toks_joined": "def actor_after_save ( sender , instance , created , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if created : <NEWLINE> pass <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Called to ensure the calendar is created for a given actor\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["376535fb1e29157d90808ebc0a34dccc", {"code_string": "def stop_instance(self, instance_id):\n    try:\n        self._con.stop_instances(instance_id)\n        return True\n    except boto.exception.EC2ResponseError, e:\n        return False\n", "code_toks_joined": "def stop_instance ( self , instance_id ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . _con . stop_instances ( instance_id ) <NEWLINE> return True <NEWLINE> <DEDENT> except boto . exception . EC2ResponseError , e : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["cf285439167739f61f315232c547c4b3", {"code_string": "def add_adjunto(self, boton):\n    \"\"\"Adjunta un documento a la factura de compra.\"\"\"\n    utils.ui.dialogo_adjuntar(\"ADJUNTAR DOCUMENTO\",\n        self.resultado,\n        ,\n        self.wids['ventana'])\n    self.rellenar_adjuntos()\n", "code_toks_joined": "def add_adjunto ( self , boton ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> utils . ui . dialogo_adjuntar ( <STRING> , <NEWLINE> <INDENT> self . resultado , <NEWLINE> , <NEWLINE> self . wids [ <STRING> ] ) <NEWLINE> <DEDENT> self . rellenar_adjuntos ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Adjunta un documento a la factura de compra.\"\"\"", "\"ADJUNTAR DOCUMENTO\"", "'ventana'"]}, "err_obj": {"msg": "invalid syntax"}}], ["c8c8eab6798a4ca1e9b49e2ecf423b82", {"code_string": "def check_year(year):\n    try:\n        if len(year) == 4:\n            return datetime.datetime.strptime(year, \"%Y\")\n        else:\n            return datetime.datetime.strptime(year, \"%y\")\n    except ValueError:\n        try:\n            return datetime.datetime.strptime(year, r\"%y\"))\n        except ValueError:\n            try:\n                return year.is_digit()\n            except ValueError:\n                return False\n", "code_toks_joined": "def check_year ( year ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if len ( year ) == 4 : <NEWLINE> <INDENT> return datetime . datetime . strptime ( year , <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return datetime . datetime . strptime ( year , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except ValueError : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return datetime . datetime . strptime ( year , <STRING> ) ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return year . is_digit ( ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"%Y\"", "\"%y\"", "r\"%y\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["b416c14d5ee0a6c2c7ed78a813cf9c91", {"code_string": "def testTarifaHorariodif(self):\n    precios = Tarifa(1, 2)\n    tiempoDeTrabajo = [datetime(2016, 4, 22, 23, 0, 0), datetime(2016, 4, 23, 0, 10, 0)]\n    pago = calcularPrecio(precios, tiempoDeTrabajo)\n    assert((pago == 5.0, \"se pag\u00f3 correctamente\")\n", "code_toks_joined": "def testTarifaHorariodif ( self ) : <NEWLINE> <INDENT> precios = Tarifa ( 1 , 2 ) <NEWLINE> tiempoDeTrabajo = [ datetime ( 2016 , 4 , 22 , 23 , 0 , 0 ) , datetime ( 2016 , 4 , 23 , 0 , 10 , 0 ) ] <NEWLINE> pago = calcularPrecio ( precios , tiempoDeTrabajo ) <NEWLINE> assert ( ( pago == 5.0 , <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"se pag\u00f3 correctamente\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["fe165546f1f1080e2c93f6f321c7779b", {"code_string": "def setBackground(self, imagesrc, * largs):\n    \"\"\"Helper function to change background image source of gauge\"\"\"\n        self.gauge.source = imagesrc\n", "code_toks_joined": "def setBackground ( self , imagesrc , * largs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> self . gauge . source = imagesrc <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Helper function to change background image source of gauge\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["fd6576b0aff7023829f3b1ffd645600e", {"code_string": "def info(title):\n    logger.debug(title)\n    logger.debug('debug message')\n    if hasattr(os, 'getppid'):\n        logger.debug('parent process: %i', os.getppid())\n    logger.debug('process id: %i', os.getpid()))\n", "code_toks_joined": "def info ( title ) : <NEWLINE> <INDENT> logger . debug ( title ) <NEWLINE> logger . debug ( <STRING> ) <NEWLINE> if hasattr ( os , <STRING> ) : <NEWLINE> <INDENT> logger . debug ( <STRING> , os . getppid ( ) ) <NEWLINE> <DEDENT> logger . debug ( <STRING> , os . getpid ( ) ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'debug message'", "'getppid'", "'parent process: %i'", "'process id: %i'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["d54ba68e0759dcec98c93ab84b870be9", {"code_string": "def _verify_signature_if_needed(self, checksum):\n    if(signature_utils.should_verify_signature(\n        self.image.extra_properties)):\n        result = signature_utils.verify_signature(\n        self.context, checksum, self.image.extra_properties)\n        if result:\n        LOG.info(_LI(\"Successfully verified signature for image %s\"),\n            self.image.image_id)\n", "code_toks_joined": "def _verify_signature_if_needed ( self , checksum ) : <NEWLINE> <INDENT> if ( signature_utils . should_verify_signature ( <NEWLINE> <INDENT> self . image . extra_properties ) ) : <NEWLINE> result = signature_utils . verify_signature ( <NEWLINE> self . context , checksum , self . image . extra_properties ) <NEWLINE> if result : <NEWLINE> LOG . info ( _LI ( <STRING> ) , <NEWLINE> <INDENT> self . image . image_id ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Successfully verified signature for image %s\""]}, "err_obj": {"msg": "expected an indented block"}}], ["337a87b18eaacc680e2edb8b90ddce69", {"code_string": "def GetMemoryModules(client_id, token):\n    \"\"\"Given a host, returns a list of urns to appropriate memory modules.\"\"\"\n    installer_urns = []\n    for aff4_path in config_lib.CONFIG.Get(\n        \"MemoryDriver.aff4_paths\", context = GetClientContext(client_id, token)):\n        logging.debug(\"Will fetch driver at %s for client %s\",\n            aff4_path, client_id)\n            if GetDriverFromURN(aff4_path, token):\n        logging.debug(\"Driver at %s found.\", aff4_path)\n        installer_urns.append(aff4_path)\n        else:\n        logging.debug(\"Unable to load driver at %s.\", aff4_path)\n    if not installer_urns:\n        raise IOError(\"Unable to find a driver for client.\")\n    return installer_urns\n", "code_toks_joined": "def GetMemoryModules ( client_id , token ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> installer_urns = [ ] <NEWLINE> for aff4_path in config_lib . CONFIG . Get ( <NEWLINE> <INDENT> <STRING> , context = GetClientContext ( client_id , token ) ) : <NEWLINE> logging . debug ( <STRING> , <NEWLINE> <INDENT> aff4_path , client_id ) <NEWLINE> if GetDriverFromURN ( aff4_path , token ) : <NEWLINE> <DEDENT> logging . debug ( <STRING> , aff4_path ) <NEWLINE> installer_urns . append ( aff4_path ) <NEWLINE> else : <NEWLINE> logging . debug ( <STRING> , aff4_path ) <NEWLINE> <DEDENT> if not installer_urns : <NEWLINE> <INDENT> raise IOError ( <STRING> ) <NEWLINE> <DEDENT> return installer_urns <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Given a host, returns a list of urns to appropriate memory modules.\"\"\"", "\"MemoryDriver.aff4_paths\"", "\"Will fetch driver at %s for client %s\"", "\"Driver at %s found.\"", "\"Unable to load driver at %s.\"", "\"Unable to find a driver for client.\""]}, "err_obj": {"msg": "unexpected indent"}}], ["55a95fab82eefe37f8fac8191784012e", {"code_string": "def get_userkindargrepr(self, kind):\n    if kind.fam is self.d.family:\n    if kind.arg is self.mod.UniSet.Nothing:\n    d = '()'\n    else:\n    d = self.d.ownerclassifier.get_userkindargrepr(kind.arg)\n    return 'dictof=%s' % d\n    else:\n    return kind.fam.classifier.get_userkindargrepr(kind)\n", "code_toks_joined": "def get_userkindargrepr ( self , kind ) : <NEWLINE> <INDENT> if kind . fam is self . d . family : <NEWLINE> if kind . arg is self . mod . UniSet . Nothing : <NEWLINE> d = <STRING> <NEWLINE> else : <NEWLINE> d = self . d . ownerclassifier . get_userkindargrepr ( kind . arg ) <NEWLINE> return <STRING> % d <NEWLINE> else : <NEWLINE> return kind . fam . classifier . get_userkindargrepr ( kind ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'()'", "'dictof=%s'"]}, "err_obj": {"msg": "expected an indented block"}}], ["5b9448098c9a630f1d188ec5b4467b1f", {"code_string": "def test_main(verbose = None):\n    import sys\n    from test import test_support\n    test_classes = (TestTranforms, )\n    with test_support._check_py3k_warnings(\n        (\"backquote not supported\", SyntaxWarning)):\n        test_support.run_unittest(* test_classes)\n        if verbose and hasattr(sys, \"gettotalrefcount\"):\n        import gc\n        counts = [None] * 5\n        for i in xrange(len(counts)):\n            test_support.run_unittest(* test_classes)\n            gc.collect()\n            counts[i] = sys.gettotalrefcount()\n        print(counts)\n", "code_toks_joined": "def test_main ( verbose = None ) : <NEWLINE> <INDENT> import sys <NEWLINE> from test import test_support <NEWLINE> test_classes = ( TestTranforms , ) <NEWLINE> with test_support . _check_py3k_warnings ( <NEWLINE> <INDENT> ( <STRING> , SyntaxWarning ) ) : <NEWLINE> test_support . run_unittest ( * test_classes ) <NEWLINE> if verbose and hasattr ( sys , <STRING> ) : <NEWLINE> import gc <NEWLINE> counts = [ None ] * 5 <NEWLINE> for i in xrange ( len ( counts ) ) : <NEWLINE> <INDENT> test_support . run_unittest ( * test_classes ) <NEWLINE> gc . collect ( ) <NEWLINE> counts [ i ] = sys . gettotalrefcount ( ) <NEWLINE> <DEDENT> print ( counts ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"backquote not supported\"", "\"gettotalrefcount\""]}, "err_obj": {"msg": "expected an indented block"}}], ["60b795597a1aaf45adaa8b8ec81f20a0", {"code_string": "def __init__(self):\n    generic.TorrentProvider.__init__(self \"BTN\")\n    self.supportsBacklog = True\n    self.cache = BTNCache(self)\n    self.url = \"http://broadcasthe.net\"\n", "code_toks_joined": "def __init__ ( self ) : <NEWLINE> <INDENT> generic . TorrentProvider . __init__ ( self <STRING> ) <NEWLINE> self . supportsBacklog = True <NEWLINE> self . cache = BTNCache ( self ) <NEWLINE> self . url = <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"BTN\"", "\"http://broadcasthe.net\""]}, "err_obj": {"msg": "invalid syntax"}}], ["e7443468cb12195ee19638fc056d2f40", {"code_string": "def test_count_reads_ahead(self):\n    paginator = Paginator(TestUser.objects.all().order_by(\"first_name\"), 1, readahead = 2)\n    paginator.page(1)\n    self.assertEqual(3 paginator.count)\n    paginator.page(3)\n    self.assertEqual(4, paginator.count)\n", "code_toks_joined": "def test_count_reads_ahead ( self ) : <NEWLINE> <INDENT> paginator = Paginator ( TestUser . objects . all ( ) . order_by ( <STRING> ) , 1 , readahead = 2 ) <NEWLINE> paginator . page ( 1 ) <NEWLINE> self . assertEqual ( 3 paginator . count ) <NEWLINE> paginator . page ( 3 ) <NEWLINE> self . assertEqual ( 4 , paginator . count ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"first_name\""]}, "err_obj": {"msg": "invalid syntax"}}], ["3068fb214b42d3eb8e10864bcaa0b31a", {"code_string": "def _PrintRevisionInfo(self, cl, info, depot = None):\n    commit_link = self._GetViewVCLinkFromDepotAndHash(cl, depot)\n    if commit_link:\n        commit_link = '\\nLink    : %s' % commit_link\n    else:\n        commit_link = ('\\Description:\\n%s' % info['body'])\n    print(RESULTS_REVISION_INFO %{\n        'subject': info['subject'],\n        'author': info['email'],\n        'commit_info': commit_link,\n        'cl': cl,\n        'cl_date': info['date']\n    }\n", "code_toks_joined": "def _PrintRevisionInfo ( self , cl , info , depot = None ) : <NEWLINE> <INDENT> commit_link = self . _GetViewVCLinkFromDepotAndHash ( cl , depot ) <NEWLINE> if commit_link : <NEWLINE> <INDENT> commit_link = <STRING> % commit_link <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> commit_link = ( <STRING> % info [ <STRING> ] ) <NEWLINE> <DEDENT> print ( RESULTS_REVISION_INFO % { <NEWLINE> <INDENT> <STRING> : info [ <STRING> ] , <NEWLINE> <STRING> : info [ <STRING> ] , <NEWLINE> <STRING> : commit_link , <NEWLINE> <STRING> : cl , <NEWLINE> <STRING> : info [ <STRING> ] <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'\\nLink    : %s'", "'\\Description:\\n%s'", "'body'", "'subject'", "'subject'", "'author'", "'email'", "'commit_info'", "'cl'", "'cl_date'", "'date'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e11dfeceeeae66e0d4c640e0d0ee5f0b", {"code_string": "def setupUi(self, Form):\n    Form.setObjectName(_fromUtf8(\"Form\"))\n    Form.resize(781, 439)\n    Form.setWindowTitle(_(\"Form\"))\n    self.verticalLayout = QtGui.QVBoxLayout(Form)\n    self.verticalLayout.setMargin(0)\n    self.verticalLayout.setObjectName(_fromUtf8(\"verticalLayout\"))\n    self.stack = QtGui.QStackedWidget(Form)\n    self.stack.setObjectName(_fromUtf8(\"stack\"))\n    self.page = QtGui.QWidget()\n    self.page.setObjectName(_fromUtf8(\"page\"))\n    self.gridLayout = QtGui.QGridLayout(self.page)\n    self.gridLayout.setObjectName(_fromUtf8(\"gridLayout\"))\n    self.groupBox = QtGui.QGroupBox(self.page)\n    self.groupBox.setTitle(_(\"Metadata sources\"))\n    self.groupBox.setObjectName(_fromUtf8(\"groupBox\"))\n    self.verticalLayout_3 = QtGui.QVBoxLayout(self.groupBox)\n    self.verticalLayout_3.setObjectName(_fromUtf8(\"verticalLayout_3\"))\n    self.label = QtGui.QLabel(self.groupBox)\n    self.label.setText(_(\"Disable any metadata sources you do not want by unchecking them. You can also set the cover priority. Covers from sources that have a higher (smaller) priority will be preferred when bulk downloading metadata.\\n\"\n", "code_toks_joined": "def setupUi ( self , Form ) : <NEWLINE> <INDENT> Form . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> Form . resize ( 781 , 439 ) <NEWLINE> Form . setWindowTitle ( _ ( <STRING> ) ) <NEWLINE> self . verticalLayout = QtGui . QVBoxLayout ( Form ) <NEWLINE> self . verticalLayout . setMargin ( 0 ) <NEWLINE> self . verticalLayout . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . stack = QtGui . QStackedWidget ( Form ) <NEWLINE> self . stack . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . page = QtGui . QWidget ( ) <NEWLINE> self . page . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout = QtGui . QGridLayout ( self . page ) <NEWLINE> self . gridLayout . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . groupBox = QtGui . QGroupBox ( self . page ) <NEWLINE> self . groupBox . setTitle ( _ ( <STRING> ) ) <NEWLINE> self . groupBox . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . verticalLayout_3 = QtGui . QVBoxLayout ( self . groupBox ) <NEWLINE> self . verticalLayout_3 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label = QtGui . QLabel ( self . groupBox ) <NEWLINE> self . label . setText ( _ ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Form\"", "\"Form\"", "\"verticalLayout\"", "\"stack\"", "\"page\"", "\"gridLayout\"", "\"Metadata sources\"", "\"groupBox\"", "\"verticalLayout_3\"", "\"Disable any metadata sources you do not want by unchecking them. You can also set the cover priority. Covers from sources that have a higher (smaller) priority will be preferred when bulk downloading metadata.\\n\""]}, "window_span": [221, 227], "err_obj": {"msg": "unbalanced (){}[]"}}], ["48fd2119221ba95bc539d7926736ec9f", {"code_string": "\"\"\"Tests for distutils.command.bdist_wininst.\"\"\"\nimport unittest\nfrom test.test_support import run_unittest\nfrom distutils.command.bdist_wininst import bdist_wininst\nfrom distutils.tests import support\nclass BuildWinInstTestCase(support.TempdirManager,\n    support.LoggingSilencer,\n    unittest.TestCase):\n    def test_get_exe_bytes(self):\n    pkg_pth, dist = self.create_dist()\n    cmd = bdist_wininst(dist)\n    cmd.ensure_finalized()\n    exe_file = cmd.get_exe_bytes()\n    self.assertTrue(len(exe_file) > 10)\n", "code_toks_joined": "<STRING> <NEWLINE> import unittest <NEWLINE> from test . test_support import run_unittest <NEWLINE> from distutils . command . bdist_wininst import bdist_wininst <NEWLINE> from distutils . tests import support <NEWLINE> class BuildWinInstTestCase ( support . TempdirManager , <NEWLINE> <INDENT> support . LoggingSilencer , <NEWLINE> unittest . TestCase ) : <NEWLINE> def test_get_exe_bytes ( self ) : <NEWLINE> pkg_pth , dist = self . create_dist ( ) <NEWLINE> cmd = bdist_wininst ( dist ) <NEWLINE> cmd . ensure_finalized ( ) <NEWLINE> exe_file = cmd . get_exe_bytes ( ) <NEWLINE> self . assertTrue ( len ( exe_file ) > 10 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Tests for distutils.command.bdist_wininst.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["74d5ed24176b66035db3b00c2e09595b", {"code_string": "def _loadBlt(window):\n    if _haveBlt is None:\n    if window is None:\n        window = Tkinter._default_root\n        if window is None:\n            window = Tkinter.Tk()\n            _checkForBlt(window)\n", "code_toks_joined": "def _loadBlt ( window ) : <NEWLINE> <INDENT> if _haveBlt is None : <NEWLINE> if window is None : <NEWLINE> <INDENT> window = Tkinter . _default_root <NEWLINE> if window is None : <NEWLINE> <INDENT> window = Tkinter . Tk ( ) <NEWLINE> _checkForBlt ( window ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["a70441cb08d40c30ffbbd913f21455d1", {"code_string": "def releaseLocks(self):\n    if self.locks:\n        log.msg(\"releaseLocks(%s): %s\" %(self, self.locks)))\n    for lock, access in self.locks:\n        if lock.isOwner(self, access):\n            lock.release(self, access)\n        else:\n            assert self.stopped\n", "code_toks_joined": "def releaseLocks ( self ) : <NEWLINE> <INDENT> if self . locks : <NEWLINE> <INDENT> log . msg ( <STRING> % ( self , self . locks ) ) ) <NEWLINE> <DEDENT> for lock , access in self . locks : <NEWLINE> <INDENT> if lock . isOwner ( self , access ) : <NEWLINE> <INDENT> lock . release ( self , access ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> assert self . stopped <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"releaseLocks(%s): %s\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["22e19dc5a2c046df1ce41ef54b0830ee", {"code_string": "def gaussianK(x, y, median):\n    d = len(x)\n    for d in len(x):\n    c = 2 *((1.5 * median) ** 2)\n    val = (x - y) ** 2 /(2 * variance)\n    return math.exp(val)\n", "code_toks_joined": "def gaussianK ( x , y , median ) : <NEWLINE> <INDENT> d = len ( x ) <NEWLINE> for d in len ( x ) : <NEWLINE> c = 2 * ( ( 1.5 * median ) ** 2 ) <NEWLINE> val = ( x - y ) ** 2 / ( 2 * variance ) <NEWLINE> return math . exp ( val ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["b95c70c73833a3f54a67f32e17385e1b", {"code_string": "def exit_clean(self):\n    \"\"\"Clean before quiting\"\"\"\n    if path.isfile('/root/pixiewps/Makefile') or path.isfile('/root/reaver-wps-fork-t6x/src/Makefile'):\n        print(OPTION + \"The pixiewps and reaver files are no longer needed\")\n        print(\"      and they live in the root home directory,\")\n        choice = raw_input(\"%sDo you wish to erase them? [Y/n]\" % INPUT)\n        if choice in CHOICES_YES:\n        system('cd /root && rm -r pixiewps/ && rm -r reaver-wps-fork-t6x/')\n    if c.IS_MON:\n        c.set_iface(\"DOWN\")\n        system('pkill airodump')\n        system('rm -f /usr/local/etc/reaver/*.wpc')\n    exit()\n", "code_toks_joined": "def exit_clean ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if path . isfile ( <STRING> ) or path . isfile ( <STRING> ) : <NEWLINE> <INDENT> print ( OPTION + <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> choice = raw_input ( <STRING> % INPUT ) <NEWLINE> if choice in CHOICES_YES : <NEWLINE> system ( <STRING> ) <NEWLINE> <DEDENT> if c . IS_MON : <NEWLINE> <INDENT> c . set_iface ( <STRING> ) <NEWLINE> system ( <STRING> ) <NEWLINE> system ( <STRING> ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Clean before quiting\"\"\"", "'/root/pixiewps/Makefile'", "'/root/reaver-wps-fork-t6x/src/Makefile'", "\"The pixiewps and reaver files are no longer needed\"", "\"      and they live in the root home directory,\"", "\"%sDo you wish to erase them? [Y/n]\"", "'cd /root && rm -r pixiewps/ && rm -r reaver-wps-fork-t6x/'", "\"DOWN\"", "'pkill airodump'", "'rm -f /usr/local/etc/reaver/*.wpc'"]}, "err_obj": {"msg": "expected an indented block"}}], ["f1518fd3f943f449e8e94afdc66b51f4", {"code_string": "def getCoverArtMeta(releaseId):\n    method = 'GET'\n    url = 'https://coverartarchive.org/release/' + releaseId\n    data = ''\n    req = mb._MusicbrainzHttpRequest(method, url, , data)\n    handlers = [compat.HTTPHandler()]\n    opener = compat.build_opener(* handlers)\n    _log.info('Checking for coverart ' + url)\n    resp = mb._safe_read(opener, req, '')\n    return json.loads(resp)\n", "code_toks_joined": "def getCoverArtMeta ( releaseId ) : <NEWLINE> <INDENT> method = <STRING> <NEWLINE> url = <STRING> + releaseId <NEWLINE> data = <STRING> <NEWLINE> req = mb . _MusicbrainzHttpRequest ( method , url , , data ) <NEWLINE> handlers = [ compat . HTTPHandler ( ) ] <NEWLINE> opener = compat . build_opener ( * handlers ) <NEWLINE> _log . info ( <STRING> + url ) <NEWLINE> resp = mb . _safe_read ( opener , req , <STRING> ) <NEWLINE> return json . loads ( resp ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'GET'", "'https://coverartarchive.org/release/'", "''", "'Checking for coverart '", "''"]}, "err_obj": {"msg": "invalid syntax"}}], ["b29917ab7d4009cd9cc2b6f6aae473ec", {"code_string": "def _takeRowsRange(self, selectionrange):\n    parent = self._parentitem(selectionrange)\n    rows = []\n    for row in range(selectionrange.bottom(),\n        selectionrange.top() - 1, - 1):\n        if not self.isLayer(parent.child(row)):\n        break\n        items = parent.takeRow(row)\n        rows.insert(0, items)\n    return rows\n", "code_toks_joined": "def _takeRowsRange ( self , selectionrange ) : <NEWLINE> <INDENT> parent = self . _parentitem ( selectionrange ) <NEWLINE> rows = [ ] <NEWLINE> for row in range ( selectionrange . bottom ( ) , <NEWLINE> <INDENT> selectionrange . top ( ) - 1 , - 1 ) : <NEWLINE> if not self . isLayer ( parent . child ( row ) ) : <NEWLINE> break <NEWLINE> items = parent . takeRow ( row ) <NEWLINE> rows . insert ( 0 , items ) <NEWLINE> <DEDENT> return rows <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["e83bc9c7b2615cd5239d533b2e83e307", {"code_string": "def go(x, z, cnt):\n    twist = Twist()\n    twist.linear.x = x\n    twist.angular.z = z\n    for i in range(cnt):\n    p.publish(twist)\n    rospy.sleep(0.1)\n", "code_toks_joined": "def go ( x , z , cnt ) : <NEWLINE> <INDENT> twist = Twist ( ) <NEWLINE> twist . linear . x = x <NEWLINE> twist . angular . z = z <NEWLINE> for i in range ( cnt ) : <NEWLINE> p . publish ( twist ) <NEWLINE> rospy . sleep ( 0.1 ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["0333c581c780cd3054ff8e594b5459e6", {"code_string": "def __init__(self, editor_area, parent = None, tabwidget = None):\n    \"\"\" Creates an EditorAreaWidget object.\"\"\"\n    super(EditorAreaWidget, self).__init__(parent = parent)\n    self.editor_area = editor_area\n    if not tabwidget:\n        tabwidget = DraggableTabWidget(editor_area = self.editor_area\n            parent = self)\n    self.addWidget(tabwidget)\n    tabwidget.show()\n    self.leftchild = None\n    self.rightchild = None\n", "code_toks_joined": "def __init__ ( self , editor_area , parent = None , tabwidget = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> super ( EditorAreaWidget , self ) . __init__ ( parent = parent ) <NEWLINE> self . editor_area = editor_area <NEWLINE> if not tabwidget : <NEWLINE> <INDENT> tabwidget = DraggableTabWidget ( editor_area = self . editor_area <NEWLINE> <INDENT> parent = self ) <NEWLINE> <DEDENT> <DEDENT> self . addWidget ( tabwidget ) <NEWLINE> tabwidget . show ( ) <NEWLINE> self . leftchild = None <NEWLINE> self . rightchild = None <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Creates an EditorAreaWidget object.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["7f68d96493a5b1123e1554e0113ddbd4", {"code_string": "def _fix_module_doctest(module):\n    \"\"\"Extract docstrings from cython functions, that would be skipped by doctest\"\"\"\n    module.__test__ = {}\n    for name in dir(module):\n        value = getattr(module, name)\n        if(inspect.isbuiltin(value) and isinstance(value.__doc__, str) and\n            _from_module(module, value):\n            module.__test__[name] = value.__doc__\n", "code_toks_joined": "def _fix_module_doctest ( module ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> module . __test__ = { } <NEWLINE> for name in dir ( module ) : <NEWLINE> <INDENT> value = getattr ( module , name ) <NEWLINE> if ( inspect . isbuiltin ( value ) and isinstance ( value . __doc__ , str ) and <NEWLINE> <INDENT> _from_module ( module , value ) : <NEWLINE> module . __test__ [ name ] = value . __doc__ <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Extract docstrings from cython functions, that would be skipped by doctest\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["d16caaa7cf8502b6fe9394ca9bdc7263", {"code_string": "def prepareSelectionList(self):\n    id = self.options.ids[- 1]\n    self.patterns = {id: self.selected[id]}\n    if self.options.duplicate:\n    self.patterns = self.duplicateNodes(self.patterns)\n    self.expandGroupsUnlinkClones(self.patterns, True, True)\n    self.objectsToPaths(self.patterns)\n    del self.selected[id]\n    self.skeletons = self.selected\n    self.expandGroupsUnlinkClones(self.skeletons, True, False)\n    self.objectsToPaths(self.skeletons)\n", "code_toks_joined": "def prepareSelectionList ( self ) : <NEWLINE> <INDENT> id = self . options . ids [ - 1 ] <NEWLINE> self . patterns = { id : self . selected [ id ] } <NEWLINE> if self . options . duplicate : <NEWLINE> self . patterns = self . duplicateNodes ( self . patterns ) <NEWLINE> self . expandGroupsUnlinkClones ( self . patterns , True , True ) <NEWLINE> self . objectsToPaths ( self . patterns ) <NEWLINE> del self . selected [ id ] <NEWLINE> self . skeletons = self . selected <NEWLINE> self . expandGroupsUnlinkClones ( self . skeletons , True , False ) <NEWLINE> self . objectsToPaths ( self . skeletons ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["9a51de9206906e13e425e24d9540b8b4", {"code_string": "def handle_exception(self, exc):\n    \"\"\"Handle any exception that occurs, by returning an appropriate response,\"\"\"\n    if isinstance(exc, (exceptions.NotAuthenticated,\n        exceptions.AuthenticationFailed)):\n        auth_header = self.get_authenticate_header(self.request)\n        if auth_header:\n        exc.auth_header = auth_header\n        else:\n        exc.status_code = status.HTTP_403_FORBIDDEN\n    exception_handler = self.settings.EXCEPTION_HANDLER\n    context = self.get_exception_handler_context()\n    response = exception_handler(exc, context)\n    if response is None:\n        self.raise_uncaught_exception(exc)\n    response.exception = True\n    return response\n", "code_toks_joined": "def handle_exception ( self , exc ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if isinstance ( exc , ( exceptions . NotAuthenticated , <NEWLINE> <INDENT> exceptions . AuthenticationFailed ) ) : <NEWLINE> auth_header = self . get_authenticate_header ( self . request ) <NEWLINE> if auth_header : <NEWLINE> exc . auth_header = auth_header <NEWLINE> else : <NEWLINE> exc . status_code = status . HTTP_403_FORBIDDEN <NEWLINE> <DEDENT> exception_handler = self . settings . EXCEPTION_HANDLER <NEWLINE> context = self . get_exception_handler_context ( ) <NEWLINE> response = exception_handler ( exc , context ) <NEWLINE> if response is None : <NEWLINE> <INDENT> self . raise_uncaught_exception ( exc ) <NEWLINE> <DEDENT> response . exception = True <NEWLINE> return response <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Handle any exception that occurs, by returning an appropriate response,\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["da3460a5f4c74eebf50d529e8797f1b3", {"code_string": "def test_clp_repo_option():\n    with parser_pair() as(builder, parser)\n        configure_clp_pex_resolution(parser, builder)\n        assert len(builder._fetchers) == 1\n        options, _ = parser.parse_args(args = ['-f', 'http://www.example.com'])\n        assert len(builder._fetchers) == 2\n        assert builder._fetchers == options.repos\n", "code_toks_joined": "def test_clp_repo_option ( ) : <NEWLINE> <INDENT> with parser_pair ( ) as ( builder , parser ) <NEWLINE> <INDENT> configure_clp_pex_resolution ( parser , builder ) <NEWLINE> assert len ( builder . _fetchers ) == 1 <NEWLINE> options , _ = parser . parse_args ( args = [ <STRING> , <STRING> ] ) <NEWLINE> assert len ( builder . _fetchers ) == 2 <NEWLINE> assert builder . _fetchers == options . repos <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'-f'", "'http://www.example.com'"]}, "err_obj": {"msg": "invalid syntax"}}], ["d7526e9d9c9988ec7ec1b63965125583", {"code_string": "def get_except(self, func, * args, ** kw):\n    try:\n        func(* args, ** kw)\n    except Exception, detail:\n        return detail.__class__, str(detail)\n", "code_toks_joined": "def get_except ( self , func , * args , ** kw ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> func ( * args , ** kw ) <NEWLINE> <DEDENT> except Exception , detail : <NEWLINE> <INDENT> return detail . __class__ , str ( detail ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["692bdca5e259d48956f473b60978c288", {"code_string": "def train():\n    mnist = input_data.read_data_sets(FLAGS.data_dir, one_hot = True, fake_data = FLAGS.fake_data)\n    sess = tf.InteractiveSession()\n    with tf.name_scope('input'):\n        x = tf.placeholder(tf.float32, [None, 784], name = 'x-input')\n        y_ = tf.placeholder(tf.float32, [None, 10], name = 'y-input')\n    with tf.name_scope('input_reshape'):\n        image_shaped_input = tf.reshape(x, [- 1, 28, 28, - 1])\n        tf.image_summary('input', image_shaped_input, 10)\n    def weight_variable(shape):\n        \"\"\"Create a weight variable with appropriate initialization.\"\"\"\n        initial = tf.truncated_normal(shape, stddev = 0.1)\n        return tf.Variable(initial)\n    def bias_variable(shape):\n        \"\"\"Create a bias variable with appropriate initialization.\"\"\"\n        initial = tf.constant(0.1, shape = shape)\n        return tf.Variable(initial)\n    def variable_summaries(var, name):\n        \"\"\"Attach a lot of summaries to a Tensor.\"\"\"\n        with tf.name_scope('summaries'):\n            mean = tf.reduce_mean(var)\n            tf.scalar_summary('mean/' + name, mean)\n            with tf.name_scope('stddev'):\n                stddev = tf.sqrt(tf.reduce_sum(tf.square(var - mean)))\n            tf.scalar_summary('stddev/' + name, stddev)\n            tf.scalar_summary('max/' + name, tf.reduce_max(var))\n            tf.scalar_summary('min/' + name, tf.reduce_min(var))\n            tf.histogram_summary(name, var)\n    def nn_layer(input_tensor, input_dim, output_dim, layer_name, act = tf.nn.relu):\n        \"\"\"Code for creating simple neural net layer\"\"\"\n        with tf.name_scope(layer_name):\n            with tf.name_scope('weights'):\n                weights = weights_variable([input_dim, output_dim])\n                variable_summaries(weights, layer_name + '/weights')\n            with tf.name_scope('biases'):\n                biases = bias_variable([output_dim])\n                variable_summaries(biases, layer_name + '/biases')\n            with tf.name_scope('Wx_plus_b'):\n                preactivate = tf.matmul(input_tensor, weights) + biases\n                tf.histogram_summary(layer_name + '/pre_activation', preactivate)\n            activations = act(preactivate, 'activation')\n            tf.histogram_summary(layer_name + '/activations', activations)\n            return activations\n    hidden1 = nn_layer(x, 784, 500, 'layer1')\n    with tf.name_scope('dropout'):\n        keep_prob = tf.placeholder(tf.float32)\n        tf.scalar_summary('dropout_keep_probability', keep_prob)\n        dropped = tf.nn.dropout(hidden1, keep_prob)\n    y = nn_layer(dropped, 500, 10, 'layer2', act = tf.nn.softmax)\n    with tf.name_scope('cross_entropy'):\n        diff = y_ * tf.log(y)\n        with tf.name_scope('total'):\n            cross_entropy = - tf.reduce_mean(diff)\n        tf.scalar_summary('cross entropy', cross_entropy)\n    with tf.name_scope('train'):\n        train_step = tf.train.AdamOptimizer(FLAGS.learning_rate).minimize(cross_entropy)\n    with tf.name_scope('accuracy'):\n        with tf.name_scope('correct_prediction'):\n            correct_prediction = tf.equal(tf.argmax(y, 1), tf.argmax(y_, 1))\n        with tf.name_scope('accuracy'):\n            accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))\n        tf.scalar_summary('accuracy', accura\n", "code_toks_joined": "def train ( ) : <NEWLINE> <INDENT> mnist = input_data . read_data_sets ( FLAGS . data_dir , one_hot = True , fake_data = FLAGS . fake_data ) <NEWLINE> sess = tf . InteractiveSession ( ) <NEWLINE> with tf . name_scope ( <STRING> ) : <NEWLINE> <INDENT> x = tf . placeholder ( tf . float32 , [ None , 784 ] , name = <STRING> ) <NEWLINE> y_ = tf . placeholder ( tf . float32 , [ None , 10 ] , name = <STRING> ) <NEWLINE> <DEDENT> with tf . name_scope ( <STRING> ) : <NEWLINE> <INDENT> image_shaped_input = tf . reshape ( x , [ - 1 , 28 , 28 , - 1 ] ) <NEWLINE> tf . image_summary ( <STRING> , image_shaped_input , 10 ) <NEWLINE> <DEDENT> def weight_variable ( shape ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> initial = tf . truncated_normal ( shape , stddev = 0.1 ) <NEWLINE> return tf . Variable ( initial ) <NEWLINE> <DEDENT> def bias_variable ( shape ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> initial = tf . constant ( 0.1 , shape = shape ) <NEWLINE> return tf . Variable ( initial ) <NEWLINE> <DEDENT> def variable_summaries ( var , name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with tf . name_scope ( <STRING> ) : <NEWLINE> <INDENT> mean = tf . reduce_mean ( var ) <NEWLINE> tf . scalar_summary ( <STRING> + name , mean ) <NEWLINE> with tf . name_scope ( <STRING> ) : <NEWLINE> <INDENT> stddev = tf . sqrt ( tf . reduce_sum ( tf . square ( var - mean ) ) ) <NEWLINE> <DEDENT> tf . scalar_summary ( <STRING> + name , stddev ) <NEWLINE> tf . scalar_summary ( <STRING> + name , tf . reduce_max ( var ) ) <NEWLINE> tf . scalar_summary ( <STRING> + name , tf . reduce_min ( var ) ) <NEWLINE> tf . histogram_summary ( name , var ) <NEWLINE> <DEDENT> <DEDENT> def nn_layer ( input_tensor , input_dim , output_dim , layer_name , act = tf . nn . relu ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with tf . name_scope ( layer_name ) : <NEWLINE> <INDENT> with tf . name_scope ( <STRING> ) : <NEWLINE> <INDENT> weights = weights_variable ( [ input_dim , output_dim ] ) <NEWLINE> variable_summaries ( weights , layer_name + <STRING> ) <NEWLINE> <DEDENT> with tf . name_scope ( <STRING> ) : <NEWLINE> <INDENT> biases = bias_variable ( [ output_dim ] ) <NEWLINE> variable_summaries ( biases , layer_name + <STRING> ) <NEWLINE> <DEDENT> with tf . name_scope ( <STRING> ) : <NEWLINE> <INDENT> preactivate = tf . matmul ( input_tensor , weights ) + biases <NEWLINE> tf . histogram_summary ( layer_name + <STRING> , preactivate ) <NEWLINE> <DEDENT> activations = act ( preactivate , <STRING> ) <NEWLINE> tf . histogram_summary ( layer_name + <STRING> , activations ) <NEWLINE> return activations <NEWLINE> <DEDENT> <DEDENT> hidden1 = nn_layer ( x , 784 , 500 , <STRING> ) <NEWLINE> with tf . name_scope ( <STRING> ) : <NEWLINE> <INDENT> keep_prob = tf . placeholder ( tf . float32 ) <NEWLINE> tf . scalar_summary ( <STRING> , keep_prob ) <NEWLINE> dropped = tf . nn . dropout ( hidden1 , keep_prob ) <NEWLINE> <DEDENT> y = nn_layer ( dropped , 500 , 10 , <STRING> , act = tf . nn . softmax ) <NEWLINE> with tf . name_scope ( <STRING> ) : <NEWLINE> <INDENT> diff = y_ * tf . log ( y ) <NEWLINE> with tf . name_scope ( <STRING> ) : <NEWLINE> <INDENT> cross_entropy = - tf . reduce_mean ( diff ) <NEWLINE> <DEDENT> tf . scalar_summary ( <STRING> , cross_entropy ) <NEWLINE> <DEDENT> with tf . name_scope ( <STRING> ) : <NEWLINE> <INDENT> train_step = tf . train . AdamOptimizer ( FLAGS . learning_rate ) . minimize ( cross_entropy ) <NEWLINE> <DEDENT> with tf . name_scope ( <STRING> ) : <NEWLINE> <INDENT> with tf . name_scope ( <STRING> ) : <NEWLINE> <INDENT> correct_prediction = tf . equal ( tf . argmax ( y , 1 ) , tf . argmax ( y_ , 1 ) ) <NEWLINE> <DEDENT> with tf . name_scope ( <STRING> ) : <NEWLINE> <INDENT> accuracy = tf . reduce_mean ( tf . cast ( correct_prediction , tf . float32 ) ) <NEWLINE> <DEDENT> tf . scalar_summary ( <STRING> , accura <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'input'", "'x-input'", "'y-input'", "'input_reshape'", "'input'", "\"\"\"Create a weight variable with appropriate initialization.\"\"\"", "\"\"\"Create a bias variable with appropriate initialization.\"\"\"", "\"\"\"Attach a lot of summaries to a Tensor.\"\"\"", "'summaries'", "'mean/'", "'stddev'", "'stddev/'", "'max/'", "'min/'", "\"\"\"Code for creating simple neural net layer\"\"\"", "'weights'", "'/weights'", "'biases'", "'/biases'", "'Wx_plus_b'", "'/pre_activation'", "'activation'", "'/activations'", "'layer1'", "'dropout'", "'dropout_keep_probability'", "'layer2'", "'cross_entropy'", "'total'", "'cross entropy'", "'train'", "'accuracy'", "'correct_prediction'", "'accuracy'", "'accuracy'"]}, "window_span": [715, 722], "err_obj": {"msg": "unbalanced (){}[]"}}], ["b44af312cd996e9e3004656b32e5a4c1", {"code_string": "def do_query(uri):\n    t1 = time.time()\n    try:\n        for line in urllib.urlopen(uri):\n            pass\n        print(\"Got %s in %f\" %(uri, time.time() - t1)))\n    except Exception as e:\n        print(\"Failed on %s: %s\" %(uri, str(e)))\n", "code_toks_joined": "def do_query ( uri ) : <NEWLINE> <INDENT> t1 = time . time ( ) <NEWLINE> try : <NEWLINE> <INDENT> for line in urllib . urlopen ( uri ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> print ( <STRING> % ( uri , time . time ( ) - t1 ) ) ) <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> <INDENT> print ( <STRING> % ( uri , str ( e ) ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Got %s in %f\"", "\"Failed on %s: %s\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["089d6d59527f84e20f056b24240de79c", {"code_string": "def has_group(self, cr, uid, group_ext_id):\n    \"\"\"Checks whether user belongs to given group.\"\"\"\n    assert group_ext_id and '.' in group_ext_id, \"External ID must be fully qualified\"\n    module, ext_id = group_ext_id.split('.')\n    cr.execute(\"\"\"SELECT 1 FROM res_groups_users_rel WHERE uid=%s AND gid IN\"\"\",\n        (uid, module, ext_id)\n    return bool(cr.fetchone())\n", "code_toks_joined": "def has_group ( self , cr , uid , group_ext_id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> assert group_ext_id and <STRING> in group_ext_id , <STRING> <NEWLINE> module , ext_id = group_ext_id . split ( <STRING> ) <NEWLINE> cr . execute ( <STRING> , <NEWLINE> <INDENT> ( uid , module , ext_id ) <NEWLINE> <DEDENT> return bool ( cr . fetchone ( ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Checks whether user belongs to given group.\"\"\"", "'.'", "\"External ID must be fully qualified\"", "'.'", "\"\"\"SELECT 1 FROM res_groups_users_rel WHERE uid=%s AND gid IN\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["961933735f61bd4fc93cf822cc12d552", {"code_string": "def safeClickTab(tab):\n    for bar in[\":*Qt Creator.JavaScript_QTabBar\",\n        \":*Qt Creator.Events_QTabBar\",\n        \":*Qt Creator.Timeline_QTabBar\"]:\n        try:\n        clickOnTab(bar, tab, 1000)\n        return True\n        except:\n        pass\n    test.fatal(\"Tab %s is not being shown.\" % tab)\n    return False\n", "code_toks_joined": "def safeClickTab ( tab ) : <NEWLINE> <INDENT> for bar in [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ] : <NEWLINE> try : <NEWLINE> clickOnTab ( bar , tab , 1000 ) <NEWLINE> return True <NEWLINE> except : <NEWLINE> pass <NEWLINE> <DEDENT> test . fatal ( <STRING> % tab ) <NEWLINE> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\":*Qt Creator.JavaScript_QTabBar\"", "\":*Qt Creator.Events_QTabBar\"", "\":*Qt Creator.Timeline_QTabBar\"", "\"Tab %s is not being shown.\""]}, "err_obj": {"msg": "expected an indented block"}}], ["5120aa2dcaf45479f09fd6a5871bb7d0", {"code_string": "def restoreAtomicBackup(self):\n    logging.info(\"Rolling back configuration (restoring atomic backup)\")\n    for confFilePath, content in self._backups.iteritems():\n        if content is None:\n            utils.rmFile(confFilePath)\n            logging.debug('Removing empty configuration backup %s'\n                confFilePath)\n        else:\n            with open(confFilePath, 'w') as confFile:\n                confFile.write(content)\n        logging.info('Restored %s', confFilePath)\n", "code_toks_joined": "def restoreAtomicBackup ( self ) : <NEWLINE> <INDENT> logging . info ( <STRING> ) <NEWLINE> for confFilePath , content in self . _backups . iteritems ( ) : <NEWLINE> <INDENT> if content is None : <NEWLINE> <INDENT> utils . rmFile ( confFilePath ) <NEWLINE> logging . debug ( <STRING> <NEWLINE> <INDENT> confFilePath ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> with open ( confFilePath , <STRING> ) as confFile : <NEWLINE> <INDENT> confFile . write ( content ) <NEWLINE> <DEDENT> <DEDENT> logging . info ( <STRING> , confFilePath ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Rolling back configuration (restoring atomic backup)\"", "'Removing empty configuration backup %s'", "'w'", "'Restored %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["c1cb5c598aa21c1c941fe74c9ce4b1f1", {"code_string": "class ExpertDispatchForm(forms.Form):\n    insitute_choice_list = []\n    insitute_list = InsituteCategory.objects.all()\n    for object in insitute_list:\n        insitute_choice_list.append((object.id, object.get_category_display()))\n    insitute_tuple = tuple(insitute_choice_list)\n    expert_password = forms.CharField(max_length = 20, required = False,\n    widget = forms.TextInput(attrs = {'class': 'span2', 'id': \"expert_password\", 'placeholder': u\"\u9ed8\u8ba4\u5bc6\u7801\uff1a\u90ae\u7bb1\u540d\u5b57\", 'id': 'expert_password'}\n", "code_toks_joined": "class ExpertDispatchForm ( forms . Form ) : <NEWLINE> <INDENT> insitute_choice_list = [ ] <NEWLINE> insitute_list = InsituteCategory . objects . all ( ) <NEWLINE> for object in insitute_list : <NEWLINE> <INDENT> insitute_choice_list . append ( ( object . id , object . get_category_display ( ) ) ) <NEWLINE> <DEDENT> insitute_tuple = tuple ( insitute_choice_list ) <NEWLINE> expert_password = forms . CharField ( max_length = 20 , required = False , <NEWLINE> widget = forms . TextInput ( attrs = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'class'", "'span2'", "'id'", "\"expert_password\"", "'placeholder'", "u\"\u9ed8\u8ba4\u5bc6\u7801\uff1a\u90ae\u7bb1\u540d\u5b57\"", "'id'", "'expert_password'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["7564e32a8326c4df76dcf350c7ef558e", {"code_string": "\"\"\"Filter gcprdb csv alignment by removing unwanted positions.\"\"\"\nimport argparse\nimport collections\nimport csv\nimport json\nimport re\nimport sys\nimport snooker\ndef gpcrdbalignment2snookeralignment_mapping(gpositions,\n    gprcdb2snookeralignment,\n    ):\n    c2l = {}\n    for cpos, gpos in enumerate(gpositions):\n    if gpos in gprcdb2snookeralignment:\n    c2l[cpos] = gprcdb2snookeralignment[gpos]\n    return c2l\n", "code_toks_joined": "<STRING> <NEWLINE> import argparse <NEWLINE> import collections <NEWLINE> import csv <NEWLINE> import json <NEWLINE> import re <NEWLINE> import sys <NEWLINE> import snooker <NEWLINE> def gpcrdbalignment2snookeralignment_mapping ( gpositions , <NEWLINE> <INDENT> gprcdb2snookeralignment , <NEWLINE> ) : <NEWLINE> c2l = { } <NEWLINE> for cpos , gpos in enumerate ( gpositions ) : <NEWLINE> if gpos in gprcdb2snookeralignment : <NEWLINE> c2l [ cpos ] = gprcdb2snookeralignment [ gpos ] <NEWLINE> return c2l <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Filter gcprdb csv alignment by removing unwanted positions.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["c8d9059d0dd77da80cf28a4a1ff07e45", {"code_string": "class AnonymousHospitalRequestHandler(BaseHandler):\n    allowed_methods = ('GET', )\n    model = HmsRequest\n    def read(self, request, hospital_request_id = None):\n    if(hospital_request_id):\n        return HmsRequest.objects.get(pk = hospital_request_id)\n        else:\n        return HmsRequest.objects.all()\n", "code_toks_joined": "class AnonymousHospitalRequestHandler ( BaseHandler ) : <NEWLINE> <INDENT> allowed_methods = ( <STRING> , ) <NEWLINE> model = HmsRequest <NEWLINE> def read ( self , request , hospital_request_id = None ) : <NEWLINE> if ( hospital_request_id ) : <NEWLINE> <INDENT> return HmsRequest . objects . get ( pk = hospital_request_id ) <NEWLINE> else : <NEWLINE> return HmsRequest . objects . all ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'GET'"]}, "err_obj": {"msg": "expected an indented block"}}], ["c5802a327458f2fdfbe2a071116c9bd3", {"code_string": "class SocketHandler(websocket.WebSocketHandler):\n    ''' websocket handler '''\n    def open(self):\n        ''' ran once an open ws connection is made'''\n        if self not in cl:\n            cl.append(self)\n    def on_close(self):\n        ''' on close event, triggered once a connection is closed'''\n        if self in cl:\n            cl.remove(self)\n            def push(self, message):\n    print(message)\n    self.write_message(message)\n", "code_toks_joined": "class SocketHandler ( websocket . WebSocketHandler ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def open ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self not in cl : <NEWLINE> <INDENT> cl . append ( self ) <NEWLINE> <DEDENT> <DEDENT> def on_close ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self in cl : <NEWLINE> <INDENT> cl . remove ( self ) <NEWLINE> def push ( self , message ) : <NEWLINE> <DEDENT> <DEDENT> print ( message ) <NEWLINE> self . write_message ( message ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''' websocket handler '''", "''' ran once an open ws connection is made'''", "''' on close event, triggered once a connection is closed'''"]}, "err_obj": {"msg": "expected an indented block"}}], ["56862b6f874ed9d98fbd62edd0494d87", {"code_string": "def launch(self c):\n    \"\"\"Start running a new controller and returns its id\"\"\"\n    self.controllers.append(c)\n    self.inmap.append(None)\n    self.outmap.append(None)\n    return len(self.controllers) - 1\n", "code_toks_joined": "def launch ( self c ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . controllers . append ( c ) <NEWLINE> self . inmap . append ( None ) <NEWLINE> self . outmap . append ( None ) <NEWLINE> return len ( self . controllers ) - 1 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Start running a new controller and returns its id\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["d2bff3b01fdd397c9ad41f55f680359c", {"code_string": "def getValueCount(csvReader):\n    valueCount = 0\n    for row in csvReader:\n        if row[0].startswith('#'):\n    continue\n        valueCount = len(row)\n        return valueCount\n", "code_toks_joined": "def getValueCount ( csvReader ) : <NEWLINE> <INDENT> valueCount = 0 <NEWLINE> for row in csvReader : <NEWLINE> <INDENT> if row [ 0 ] . startswith ( <STRING> ) : <NEWLINE> <DEDENT> continue <NEWLINE> <INDENT> valueCount = len ( row ) <NEWLINE> return valueCount <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'#'"]}, "err_obj": {"msg": "expected an indented block"}}], ["980295945156eab2458925530a112cd7", {"code_string": "from __future__ import with_statement\nimport unittest\nfrom flask import Flask, Response\nfrom flask_principal import Principal, Permission, Denial, RoleNeed, PermissionDenied, identity_changed, Identity, identity_loaded\nanon_permission = Permission()\nadmin_permission = Permission(RoleNeed('admin'))\nadmin_or_editor = Permission(RoleNeed('admin'), RoleNeed('editor')\neditor_permission = Permission(RoleNeed('editor'))\nadmin_denied = Denial(RoleNeed('admin'))\n", "code_toks_joined": "from __future__ import with_statement <NEWLINE> import unittest <NEWLINE> from flask import Flask , Response <NEWLINE> from flask_principal import Principal , Permission , Denial , RoleNeed , PermissionDenied , identity_changed , Identity , identity_loaded <NEWLINE> anon_permission = Permission ( ) <NEWLINE> admin_permission = Permission ( RoleNeed ( <STRING> ) ) <NEWLINE> admin_or_editor = Permission ( RoleNeed ( <STRING> ) , RoleNeed ( <STRING> ) <NEWLINE> editor_permission = Permission ( RoleNeed ( <STRING> ) ) <NEWLINE> admin_denied = Denial ( RoleNeed ( <STRING> ) ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["'admin'", "'admin'", "'editor'", "'editor'", "'admin'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["616d66566d0e278fc81edc8ced837e42", {"code_string": "def not_android_version(self, android_version_name):\n    \"\"\"If the trace device info matches indicates that the application is\"\"\"\n    if(self.device.Configuration.OS.Kind == ANDROID and\n        StrictVersion(self.device.Configuration.OS.Name) <=\n        StrictVersion(android_version_name)):\n        call_site = traceback.format_list(traceback.extract_stack(limit = 2))\n        self.warnings.append(\n        \"Code block disabled due to known Android issue\\n\" + call_site[\n            0])\n            return False\n    return True\n", "code_toks_joined": "def not_android_version ( self , android_version_name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( self . device . Configuration . OS . Kind == ANDROID and <NEWLINE> <INDENT> StrictVersion ( self . device . Configuration . OS . Name ) <= <NEWLINE> StrictVersion ( android_version_name ) ) : <NEWLINE> call_site = traceback . format_list ( traceback . extract_stack ( limit = 2 ) ) <NEWLINE> self . warnings . append ( <NEWLINE> <STRING> + call_site [ <NEWLINE> <INDENT> 0 ] ) <NEWLINE> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"If the trace device info matches indicates that the application is\"\"\"", "\"Code block disabled due to known Android issue\\n\""]}, "err_obj": {"msg": "unexpected indent"}}], ["0b1b04b04984bfa8192bb25a36d154a0", {"code_string": "def runNtrajectory(self, (x, y), repeat):\n    costAll, trajTimeAll = np.zeros(repeat), np.zeros(repeat)\n    for i in range(repeat):\n        costAll[i], trajTimeAll[i] = self.runOneTrajectoryOpti(x, y)\n    meanCost = np.mean(costAll)\n    meanTrajTime = np.mean(trajTimeAll)\n    self.costStore.append([x, y, meanCost])\n    self.trajTimeStore.append([x, y, meanTrajTime])\n    return meanCost, meanTrajTime\n", "code_toks_joined": "def runNtrajectory ( self , ( x , y ) , repeat ) : <NEWLINE> <INDENT> costAll , trajTimeAll = np . zeros ( repeat ) , np . zeros ( repeat ) <NEWLINE> for i in range ( repeat ) : <NEWLINE> <INDENT> costAll [ i ] , trajTimeAll [ i ] = self . runOneTrajectoryOpti ( x , y ) <NEWLINE> <DEDENT> meanCost = np . mean ( costAll ) <NEWLINE> meanTrajTime = np . mean ( trajTimeAll ) <NEWLINE> self . costStore . append ( [ x , y , meanCost ] ) <NEWLINE> self . trajTimeStore . append ( [ x , y , meanTrajTime ] ) <NEWLINE> return meanCost , meanTrajTime <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["50d6b80fb9937d4a507ff14a79d4ef21", {"code_string": "def __init__(self, ** kw):\n    for name, value in kw.items():\n        if not hasattr(self, name):\n            raise TypeError(\n                \"Unknown parameter: %s=%r\" %(name, value)\n        setattr(self, name, value)\n    if self.inline_style is None and 'inline_style' not in kw:\n        self.inline_style = self.style\n", "code_toks_joined": "def __init__ ( self , ** kw ) : <NEWLINE> <INDENT> for name , value in kw . items ( ) : <NEWLINE> <INDENT> if not hasattr ( self , name ) : <NEWLINE> <INDENT> raise TypeError ( <NEWLINE> <INDENT> <STRING> % ( name , value ) <NEWLINE> <DEDENT> <DEDENT> setattr ( self , name , value ) <NEWLINE> <DEDENT> if self . inline_style is None and <STRING> not in kw : <NEWLINE> <INDENT> self . inline_style = self . style <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Unknown parameter: %s=%r\"", "'inline_style'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["55f1a0f7241ef608f8272dce9f96e70c", {"code_string": "def setupUi(self, checkinPageWidget):\n    checkinPageWidget.setObjectName(\"checkinPageWidget\")\n    self.checkinPageWidgetLayout = QtGui.QVBoxLayout(checkinPageWidget)\n    self.checkinPageWidgetLayout.setContentsMargins(0, 0, 0, 0)\n    self.checkinPageWidgetLayout.setObjectName(\"checkinPageWidgetLayout\")\n    self.checkinMiscOptionsGroupBox = QtGui.QGroupBox(checkinPageWidget)\n    self.checkinMiscOptionsGroupBox.setFlat(True)\n    self.checkinMiscOptionsGroupBox.setObjectName(\"checkinMiscOptionsGroupBox\")\n    self.checkinMiscOptionsLayout = QtGui.QGridLayout(self.checkinMiscOptionsGroupBox)\n    self.checkinMiscOptionsLayout.setContentsMargins(9, - 1, 0, 0)\n    self.checkinMiscOptionsLayout.setObjectName(\"checkinMiscOptionsLayout\")\n    self.doubleClickSaveCheckBox = QtGui.QCheckBox(self.checkinMiscOptionsGroupBox)\n    self.doubleClickSaveCheckBox.setObjectName(\"doubleClickSaveCheckBox\")\n    self.checkinMiscOptionsLayout.addWidget(self.doubleClickSaveCheckBox, 0, 0, 1, 1)\n    self.versionsSeparateCheckinCheckBox = QtGui.QCheckBox(self.checkinMiscOptionsGroupBox)\n    self.versionsSeparateCheckinCheckBox.setObjectName(\"versionsSeparateCheckinCheckBox\")\n    self.checkinMiscOptionsLayout.addWidget(self.versionsSeparateCheckinCheckBox, 2, 0, 1, 1)\n    self.doubleClickOpenCheckBox = QtGui.QCheckBox(self.checkinMiscOptionsGroupBox)\n    self.doubleClickOpenCheckBox.setObjectName(\"doubleClickOpenCheckBox\")\n    self.checkinMiscOptionsLayout.addWidget(self.doubleClickOpenCheckBox, 1, 0, 1, 1)\n    self.askBeforeSaveCheckBox = QtGui.QCheckBox(self.checkinMiscOptionsGroupBox)\n    self.askBeforeSaveCheckBox.setChecked(True)\n    self.askBeforeSaveCheckBox.setObjectName(\"askBeforeSaveCheckBox\")\n    self.checkinMiscOptionsLayout.addWidget(self.askBeforeSaveCheckBox, 3, 0, 1, 1)\n    self.snapshotDescriptionLimitCheckBox = QtGui.QCheckBox(self.checkinMiscOptionsGroupBox)\n    self.snapshotDescriptionLimitCheckBox.setChecked(True)\n    self.snapshotDescriptionLimitCheckBox.setObjectName(\"snapshotDescriptionLimitCheckBox\")\n    self.checkinMiscOptionsLayout.addWidget(self.snapshotDescriptionLimitCheckBox, 4, 0, 1, 1)\n    self.snapshotDescriptionLimitSpinBox = QtGui.QSpinBox(self.checkinMiscOptionsGroupBox)\n    self.snapshotDescriptionLimitSpinBox.setMinimum(20)\n    self.snapshotDescriptionLimitSpinBox.setMaximum(50000)\n    self.snapshotDescriptionLimitSpinBox.setSingleStep(5)\n    self.snapshotDescriptionLimitSpinBox.setProperty(\"value\", 80)\n    self.snapshotDescriptionLimitSpinBox.setObjectName(\"snapshotDescriptionLimitSpinBox\")\n    self.checkinMiscOptionsLayout.addWidget(self.snapshotDescriptionLimitSpinBox, 4, 2, 1, 1)\n    self.rightVersionsRadioButton = QtGui.QRadioButton(self.checkinMiscOptionsGroupBox)\n    self.rightVersionsRadioButton.setChecked(True)\n    self.rightVersionsRadioButton.setObjectName(\"rightVersionsRadioButton\")\n    self.checkinMiscOptionsLayout.addWidget(self.rightVersionsRadioButton, 2, 2, 1, 1)\n    self.bottomVersionsRadioButton = QtGui.QRadioButton(self.checkinMiscOptionsGroupBox)\n    self.bottomVersionsRadioButton.setObjectName(\"bottomVersionsRadioButton\")\n    self.checkinMiscOptionsLayout.addWidget(self.bottomVersionsRadioButton, 2, 1, 1, 1)\n    self.checkinMiscOptionsLayout.setColumnStretch(0, 1)\n    self.checkinPageWidgetLayout.addWidget(self.checkinMiscOptionsGroupBox)\n    self.snapshotsSavingOptionsGroupBox = QtGui.QGroupBox(checkinPageWidget)\n    self.snapshotsSavingOptionsGroupBox.setFlat(True)\n    self.snapshotsSavingOptionsGroupBox.setObjectName(\"snapshotsSavingOptionsGroupBox\")\n    self.snapshotsSavingOptionsLayout = QtGui.QGridLayout(self.snapshotsSavingOptionsGroupBox)\n    self.snapshotsSavingOptionsLayout.setContentsMargins(9, - 1, 0, 0)\n    self.snapshotsSavingOptionsLayout.setObjectName(\"snapshotsSavingOptionsLayout\")\n    self.repositoryComboBox = QtGui.QComboBox(self.snapshotsSavingOptionsGroupBox)\n    self.repositoryComboBox.setObjectName(\"repositoryComboBox\")\n    self.snapshotsSavingOptionsLayout.addWidget(self.repositoryComboBox, 1, 1, 1, 1)\n    self.repositoryLabel = QtGui.QLabel(self.snapshotsSavingOptionsGroupBox)\n    self.repositoryLabel.setObjectName(\"repositoryLabel\")\n    self.snapshotsSavingOptionsLayout.addWidget(self.repositoryLabel, 1, 0, 1, 1)\n    self.checkinMethodLabel = QtGui.QLabel(self.snapshotsSavingOptionsGroupBox)\n    self.checkinMethodLabel.setObjectName(\"checkinMethodLabel\")\n    self.snapshotsSavingOptionsLayout.addWidget(self.checkinMethodLabel, 2, 0, 1, 1)\n    self.checkinMethodComboBox = QtGui.QComboBox(self.snapshotsSavingOptionsGroupBox)\n    self.checkinMethodComboBox.setObjectName(\"checkinMethodComboBox\")\n    self.checkinMethodComboBox.addItem(\"\")\n    self.checkinMethodComboBox.addItem(\"\")\n    self.checkinMethodComboBox.addItem(\"\")\n    self.checkinMethodComboBox.addItem(\"\")\n    self.checkinMethodComboBox.addItem(\"\")\n    self.snapshotsSavingOptionsLayout.addWidget(self.checkinMethodComboBox, 2, 1, 1, 1)\n    self.updateVersionlessCheckBox = QtGui.QCheckBox(self.snapshotsSavingOptionsGroupBox)\n    self.updateVersionlessCheckBox.setChecked(True)\n    self.updateVersionlessCheckBox.setObjectName(\"updateVersionlessCheckBox\")\n    self.snapshotsSavingOptionsLayout.addWidget(self.updateVersionlessCheckBox, 3, 0, 1, 1)\n    self.createMayaDirsCheckBox = QtGui.QCheckBox(self.snapshotsSavingOptionsGroupBox)\n    self.createMayaDirsCheckBox.setObjectName(\"createMayaDirsCheckBox\")\n    self.snapshotsSavingOptionsLayout.addWidget(self.createMayaDirsCheckBox, 5, 0, 1, 1)\n    self.createPlayblastCheckBox = QtGui.QCheckBox(self.snapshotsSavingOptionsGroupBox)\n    self.createPlayblastCheckBox.setChecked(True)\n    self.createPlayblastCheckBox.setObjectName(\"createPlayblastCheckBox\")\n    self.snapshotsSavingOptionsLayout.addWidget(self.createPlayblastCheckBox, 8, 0, 1, 1)\n    self.generatePreviewsCheckBox = QtGui.QCheckBox(self.snapshotsSavingOptionsGroupBox)\n    self.generatePreviewsCheckBox.setChecked(True)\n    self.generatePreviewsCheckBox.setObjectName(\"generatePreviewsCheckBox\")\n    self.snapshotsSavingOptionsLayout.addWidget(self.generatePreviewsCheckBox, 4, 0, 1, 1)\n    self.uncheckFromDropPlateCheckBox = QtGui.QCheckBox(self.snapshotsSavingOptionsGroupBox)\n    self.uncheckFromDropPlateCheckBox.setObjectName(\"uncheckFromDropPlateCheckBox\")\n    self.snapshotsSavingOptionsLayout.addWidget(self.uncheckFromDropPlateCheckBox, 6, 0, 1, 1)\n    self.clearDropPlateAfterCheckincheckBox = QtGui.QCheckBox(self.snapshotsSavingOptionsGroupBox)\n    self.clearDropPlateAfterCheckincheckBox.setObjectName(\"clearDropPlateAfterCheckincheckBox\")\n    self.snapshotsSavingOptionsLayout.addWidget(self.clearDropPlateAfterCheckincheckBox, 7, 0, 1, 1)\n    self.checkinPageWidgetLayout.addWidget(self.snapshotsSavingOptionsGroupBox)\n    self.defaultRepoPathsGroupBox = QtGui.QGroupBox(checkinPageWidget)\n    self.defaultRepoPathsGroupBox.setFlat(True)\n    self.defaultRepoPathsGroupBox.setObjectName(\"defaultRepoPathsGroupBox\")\n    self.defaultRepoPathsLayout = QtGui.QGridLayout(self.defaultRepoPathsGroupBox)\n    self.defaultRepoPathsLayout.setContentsMargins(9, 9, 0, 0)\n    self.defaultRepoPathsLayout.setObjectName(\"defaultRepoPathsLayout\")\n    self.assetBaseDirPathLineEdit = QtGui.QLineEdit(self.defaultRepoPathsGroupBox)\n    self.assetBaseDirPathLineEdit.setObjectName(\"assetBaseDirPathLineEdit\")\n    self.defaultRepoPathsLayout.addWidget(self.assetBaseDirPathLineEdit, 0, 3, 1, 1)\n    self.handoffDirPathLineEdit = QtGui.QLineEdit(self.defaultRepoPathsGroupBox)\n    self.handoffDirPathLineEdit.setObjectName(\"handoffDirPathLineEdit\")\n    self.defaultRepoPathsLayout.addWidget(self.handoffDirPathLineEdit, 4, 2, 1, 2)\n    self.sandboxDirPathLineEdit = QtGui.QLineEdit(self.defaultRepoPathsGroupBox)\n    self.sandboxDirPathLineEdit.setObjectName(\"sandboxDirPathLineEdit\")\n    self.defaultRepoPathsLayout.addWidget(self.sandboxDirPathLineEdit, 1, 3, 1, 1)\n    self.localRepoDirPathLineEdit = QtGui.QLineEdit(self.defaultRepoPathsGroupBox)\n    self.localRepoDirPathLineEdit.setObjectName(\"localRepoDirPathLineEdit\")\n    self.defaultRepoPathsLayout.addWidget(self.localRepoDirPathLineEdit, 2, 3, 1, 1)\n    self.clientRepoDirPathLineEdit = QtGui.QLineEdit(self.defaultRepoPathsGroupBox)\n    self.clientRepoDirPathLineEdit.setObjectName(\"clientRepoDirPathLineEdit\")\n    self.defaultRepoPathsLayout.addWidget(self.clientRepoDirPathLineEdit, 3, 3, 1, 1)\n    self.assetBaseDirCheckBox = QtGui.QCheckBox(self.defaultRepoPathsGroupBox)\n    self.assetBaseDirCheckBox.setChecked(True)\n    self.assetBaseDirCheckBox.setObjectName(\"assetBaseDirCheckBox\")\n    self.defaultRepoPathsLayout.addWidget(self.assetBaseDirCheckBox, 0, 0, 1, 1)\n    self.sandboxCheckBox = QtGui.QCheckBox(self.defaultRepoPathsGroupBox)\n    self.sandboxCheckBox.setObjectName(\"sandboxCheckBox\")\n    self.defaultRepoPathsLayout.addWidget(self.sandboxCheckBox, 1, 0, 1, 1)\n    self.localRepoCheckBox = QtGui.QCheckBox(self.defaultRepoPathsGroupBox)\n    self.localRepoCheckBox.setChecked(True)\n    self.localRepoCheckBox.setObjectName(\"localRepoCheckBox\")\n    self.defaultRepoPathsLayout.addWidget(self.localRepoCheckBox, 2, 0, 1, 1)\n    self.clientRepoCheckBox = QtGui.QCheckBox(self.defaultRepoPathsGroupBox)\n    self.clientRepoCheckBox.setObjectName(\"clientRepoCheckBox\")\n    self.defaultRepoPathsLayout.addWidget(self.clientRepoCheckBox, 3, 0, 1, 1)\n    self.handoffCheckBox = QtGui.QCheckBox(self.defaultRepoPathsGroupBox)\n    self.handoffCheckBox.setObjectName(\"handoffCheckBox\")\n    self.defaultRepoPathsLayout.addWidget(self.handoffCheckBox, 4, 0, 1, 1)\n    self.assetBaseDirNameLineEdit = QtGui.QLineEdit(self.defaultRepoPathsGroupBox)\n    self.assetBaseDirNameLineEdit.setObjectName(\"assetBaseDirNameLineEdit\")\n    self.defaultRepoPathsLayout.addWidget(self.assetBaseDirNameLineEdit, 0, 2, 1, 1)\n    self.sandboxDirNameLineEdit = QtGui.QLineEdit(self.defaultRepoPathsGroupBox)\n    self.sandboxDirNameLineEdit.setObjectName(\"sandboxDirNameLineEdit\")\n    self.defaultRepoPathsLayout.addWidget(self.sandboxDirNameLineEdit, 1, 2, 1, 1)\n    self.localRepoDirNameLineEdit = QtGui.QLineEdit(self.defaultRepoPathsGroupBox)\n    self.localRepoDirNameLineEdit.setObjectName(\"localRepoDirNameLineEdit\")\n    self.defaultRepoPathsLayout.addWidget(self.localRepoDirNameLineEdit, 2, 2, 1, 1)\n    self.clientRepoDirNameLineEdit = QtGui.QLineEdit(self.defaultRepoPathsGroupBox)\n    self.clientRepoDirNameLineEdit.setObjectName(\"clientRepoDirNameLineEdit\")\n    self.defaultRepoPathsLayout.addWidget(self.clientRepoDirNameLineEdit, 3, 2, 1, 1)\n    self.assetBaseDirColorToolButton = QtGui.QToolButton(self.defaultRepoPathsGroupBox)\n    self.assetBaseDirColorToolButton.setMaximumSize(QtCore.QSize(20, 20))\n    self.assetBaseDirColorToolButton.setStyleSheet(\"QToolButton {\\n\"\n", "code_toks_joined": "def setupUi ( self , checkinPageWidget ) : <NEWLINE> <INDENT> checkinPageWidget . setObjectName ( <STRING> ) <NEWLINE> self . checkinPageWidgetLayout = QtGui . QVBoxLayout ( checkinPageWidget ) <NEWLINE> self . checkinPageWidgetLayout . setContentsMargins ( 0 , 0 , 0 , 0 ) <NEWLINE> self . checkinPageWidgetLayout . setObjectName ( <STRING> ) <NEWLINE> self . checkinMiscOptionsGroupBox = QtGui . QGroupBox ( checkinPageWidget ) <NEWLINE> self . checkinMiscOptionsGroupBox . setFlat ( True ) <NEWLINE> self . checkinMiscOptionsGroupBox . setObjectName ( <STRING> ) <NEWLINE> self . checkinMiscOptionsLayout = QtGui . QGridLayout ( self . checkinMiscOptionsGroupBox ) <NEWLINE> self . checkinMiscOptionsLayout . setContentsMargins ( 9 , - 1 , 0 , 0 ) <NEWLINE> self . checkinMiscOptionsLayout . setObjectName ( <STRING> ) <NEWLINE> self . doubleClickSaveCheckBox = QtGui . QCheckBox ( self . checkinMiscOptionsGroupBox ) <NEWLINE> self . doubleClickSaveCheckBox . setObjectName ( <STRING> ) <NEWLINE> self . checkinMiscOptionsLayout . addWidget ( self . doubleClickSaveCheckBox , 0 , 0 , 1 , 1 ) <NEWLINE> self . versionsSeparateCheckinCheckBox = QtGui . QCheckBox ( self . checkinMiscOptionsGroupBox ) <NEWLINE> self . versionsSeparateCheckinCheckBox . setObjectName ( <STRING> ) <NEWLINE> self . checkinMiscOptionsLayout . addWidget ( self . versionsSeparateCheckinCheckBox , 2 , 0 , 1 , 1 ) <NEWLINE> self . doubleClickOpenCheckBox = QtGui . QCheckBox ( self . checkinMiscOptionsGroupBox ) <NEWLINE> self . doubleClickOpenCheckBox . setObjectName ( <STRING> ) <NEWLINE> self . checkinMiscOptionsLayout . addWidget ( self . doubleClickOpenCheckBox , 1 , 0 , 1 , 1 ) <NEWLINE> self . askBeforeSaveCheckBox = QtGui . QCheckBox ( self . checkinMiscOptionsGroupBox ) <NEWLINE> self . askBeforeSaveCheckBox . setChecked ( True ) <NEWLINE> self . askBeforeSaveCheckBox . setObjectName ( <STRING> ) <NEWLINE> self . checkinMiscOptionsLayout . addWidget ( self . askBeforeSaveCheckBox , 3 , 0 , 1 , 1 ) <NEWLINE> self . snapshotDescriptionLimitCheckBox = QtGui . QCheckBox ( self . checkinMiscOptionsGroupBox ) <NEWLINE> self . snapshotDescriptionLimitCheckBox . setChecked ( True ) <NEWLINE> self . snapshotDescriptionLimitCheckBox . setObjectName ( <STRING> ) <NEWLINE> self . checkinMiscOptionsLayout . addWidget ( self . snapshotDescriptionLimitCheckBox , 4 , 0 , 1 , 1 ) <NEWLINE> self . snapshotDescriptionLimitSpinBox = QtGui . QSpinBox ( self . checkinMiscOptionsGroupBox ) <NEWLINE> self . snapshotDescriptionLimitSpinBox . setMinimum ( 20 ) <NEWLINE> self . snapshotDescriptionLimitSpinBox . setMaximum ( 50000 ) <NEWLINE> self . snapshotDescriptionLimitSpinBox . setSingleStep ( 5 ) <NEWLINE> self . snapshotDescriptionLimitSpinBox . setProperty ( <STRING> , 80 ) <NEWLINE> self . snapshotDescriptionLimitSpinBox . setObjectName ( <STRING> ) <NEWLINE> self . checkinMiscOptionsLayout . addWidget ( self . snapshotDescriptionLimitSpinBox , 4 , 2 , 1 , 1 ) <NEWLINE> self . rightVersionsRadioButton = QtGui . QRadioButton ( self . checkinMiscOptionsGroupBox ) <NEWLINE> self . rightVersionsRadioButton . setChecked ( True ) <NEWLINE> self . rightVersionsRadioButton . setObjectName ( <STRING> ) <NEWLINE> self . checkinMiscOptionsLayout . addWidget ( self . rightVersionsRadioButton , 2 , 2 , 1 , 1 ) <NEWLINE> self . bottomVersionsRadioButton = QtGui . QRadioButton ( self . checkinMiscOptionsGroupBox ) <NEWLINE> self . bottomVersionsRadioButton . setObjectName ( <STRING> ) <NEWLINE> self . checkinMiscOptionsLayout . addWidget ( self . bottomVersionsRadioButton , 2 , 1 , 1 , 1 ) <NEWLINE> self . checkinMiscOptionsLayout . setColumnStretch ( 0 , 1 ) <NEWLINE> self . checkinPageWidgetLayout . addWidget ( self . checkinMiscOptionsGroupBox ) <NEWLINE> self . snapshotsSavingOptionsGroupBox = QtGui . QGroupBox ( checkinPageWidget ) <NEWLINE> self . snapshotsSavingOptionsGroupBox . setFlat ( True ) <NEWLINE> self . snapshotsSavingOptionsGroupBox . setObjectName ( <STRING> ) <NEWLINE> self . snapshotsSavingOptionsLayout = QtGui . QGridLayout ( self . snapshotsSavingOptionsGroupBox ) <NEWLINE> self . snapshotsSavingOptionsLayout . setContentsMargins ( 9 , - 1 , 0 , 0 ) <NEWLINE> self . snapshotsSavingOptionsLayout . setObjectName ( <STRING> ) <NEWLINE> self . repositoryComboBox = QtGui . QComboBox ( self . snapshotsSavingOptionsGroupBox ) <NEWLINE> self . repositoryComboBox . setObjectName ( <STRING> ) <NEWLINE> self . snapshotsSavingOptionsLayout . addWidget ( self . repositoryComboBox , 1 , 1 , 1 , 1 ) <NEWLINE> self . repositoryLabel = QtGui . QLabel ( self . snapshotsSavingOptionsGroupBox ) <NEWLINE> self . repositoryLabel . setObjectName ( <STRING> ) <NEWLINE> self . snapshotsSavingOptionsLayout . addWidget ( self . repositoryLabel , 1 , 0 , 1 , 1 ) <NEWLINE> self . checkinMethodLabel = QtGui . QLabel ( self . snapshotsSavingOptionsGroupBox ) <NEWLINE> self . checkinMethodLabel . setObjectName ( <STRING> ) <NEWLINE> self . snapshotsSavingOptionsLayout . addWidget ( self . checkinMethodLabel , 2 , 0 , 1 , 1 ) <NEWLINE> self . checkinMethodComboBox = QtGui . QComboBox ( self . snapshotsSavingOptionsGroupBox ) <NEWLINE> self . checkinMethodComboBox . setObjectName ( <STRING> ) <NEWLINE> self . checkinMethodComboBox . addItem ( <STRING> ) <NEWLINE> self . checkinMethodComboBox . addItem ( <STRING> ) <NEWLINE> self . checkinMethodComboBox . addItem ( <STRING> ) <NEWLINE> self . checkinMethodComboBox . addItem ( <STRING> ) <NEWLINE> self . checkinMethodComboBox . addItem ( <STRING> ) <NEWLINE> self . snapshotsSavingOptionsLayout . addWidget ( self . checkinMethodComboBox , 2 , 1 , 1 , 1 ) <NEWLINE> self . updateVersionlessCheckBox = QtGui . QCheckBox ( self . snapshotsSavingOptionsGroupBox ) <NEWLINE> self . updateVersionlessCheckBox . setChecked ( True ) <NEWLINE> self . updateVersionlessCheckBox . setObjectName ( <STRING> ) <NEWLINE> self . snapshotsSavingOptionsLayout . addWidget ( self . updateVersionlessCheckBox , 3 , 0 , 1 , 1 ) <NEWLINE> self . createMayaDirsCheckBox = QtGui . QCheckBox ( self . snapshotsSavingOptionsGroupBox ) <NEWLINE> self . createMayaDirsCheckBox . setObjectName ( <STRING> ) <NEWLINE> self . snapshotsSavingOptionsLayout . addWidget ( self . createMayaDirsCheckBox , 5 , 0 , 1 , 1 ) <NEWLINE> self . createPlayblastCheckBox = QtGui . QCheckBox ( self . snapshotsSavingOptionsGroupBox ) <NEWLINE> self . createPlayblastCheckBox . setChecked ( True ) <NEWLINE> self . createPlayblastCheckBox . setObjectName ( <STRING> ) <NEWLINE> self . snapshotsSavingOptionsLayout . addWidget ( self . createPlayblastCheckBox , 8 , 0 , 1 , 1 ) <NEWLINE> self . generatePreviewsCheckBox = QtGui . QCheckBox ( self . snapshotsSavingOptionsGroupBox ) <NEWLINE> self . generatePreviewsCheckBox . setChecked ( True ) <NEWLINE> self . generatePreviewsCheckBox . setObjectName ( <STRING> ) <NEWLINE> self . snapshotsSavingOptionsLayout . addWidget ( self . generatePreviewsCheckBox , 4 , 0 , 1 , 1 ) <NEWLINE> self . uncheckFromDropPlateCheckBox = QtGui . QCheckBox ( self . snapshotsSavingOptionsGroupBox ) <NEWLINE> self . uncheckFromDropPlateCheckBox . setObjectName ( <STRING> ) <NEWLINE> self . snapshotsSavingOptionsLayout . addWidget ( self . uncheckFromDropPlateCheckBox , 6 , 0 , 1 , 1 ) <NEWLINE> self . clearDropPlateAfterCheckincheckBox = QtGui . QCheckBox ( self . snapshotsSavingOptionsGroupBox ) <NEWLINE> self . clearDropPlateAfterCheckincheckBox . setObjectName ( <STRING> ) <NEWLINE> self . snapshotsSavingOptionsLayout . addWidget ( self . clearDropPlateAfterCheckincheckBox , 7 , 0 , 1 , 1 ) <NEWLINE> self . checkinPageWidgetLayout . addWidget ( self . snapshotsSavingOptionsGroupBox ) <NEWLINE> self . defaultRepoPathsGroupBox = QtGui . QGroupBox ( checkinPageWidget ) <NEWLINE> self . defaultRepoPathsGroupBox . setFlat ( True ) <NEWLINE> self . defaultRepoPathsGroupBox . setObjectName ( <STRING> ) <NEWLINE> self . defaultRepoPathsLayout = QtGui . QGridLayout ( self . defaultRepoPathsGroupBox ) <NEWLINE> self . defaultRepoPathsLayout . setContentsMargins ( 9 , 9 , 0 , 0 ) <NEWLINE> self . defaultRepoPathsLayout . setObjectName ( <STRING> ) <NEWLINE> self . assetBaseDirPathLineEdit = QtGui . QLineEdit ( self . defaultRepoPathsGroupBox ) <NEWLINE> self . assetBaseDirPathLineEdit . setObjectName ( <STRING> ) <NEWLINE> self . defaultRepoPathsLayout . addWidget ( self . assetBaseDirPathLineEdit , 0 , 3 , 1 , 1 ) <NEWLINE> self . handoffDirPathLineEdit = QtGui . QLineEdit ( self . defaultRepoPathsGroupBox ) <NEWLINE> self . handoffDirPathLineEdit . setObjectName ( <STRING> ) <NEWLINE> self . defaultRepoPathsLayout . addWidget ( self . handoffDirPathLineEdit , 4 , 2 , 1 , 2 ) <NEWLINE> self . sandboxDirPathLineEdit = QtGui . QLineEdit ( self . defaultRepoPathsGroupBox ) <NEWLINE> self . sandboxDirPathLineEdit . setObjectName ( <STRING> ) <NEWLINE> self . defaultRepoPathsLayout . addWidget ( self . sandboxDirPathLineEdit , 1 , 3 , 1 , 1 ) <NEWLINE> self . localRepoDirPathLineEdit = QtGui . QLineEdit ( self . defaultRepoPathsGroupBox ) <NEWLINE> self . localRepoDirPathLineEdit . setObjectName ( <STRING> ) <NEWLINE> self . defaultRepoPathsLayout . addWidget ( self . localRepoDirPathLineEdit , 2 , 3 , 1 , 1 ) <NEWLINE> self . clientRepoDirPathLineEdit = QtGui . QLineEdit ( self . defaultRepoPathsGroupBox ) <NEWLINE> self . clientRepoDirPathLineEdit . setObjectName ( <STRING> ) <NEWLINE> self . defaultRepoPathsLayout . addWidget ( self . clientRepoDirPathLineEdit , 3 , 3 , 1 , 1 ) <NEWLINE> self . assetBaseDirCheckBox = QtGui . QCheckBox ( self . defaultRepoPathsGroupBox ) <NEWLINE> self . assetBaseDirCheckBox . setChecked ( True ) <NEWLINE> self . assetBaseDirCheckBox . setObjectName ( <STRING> ) <NEWLINE> self . defaultRepoPathsLayout . addWidget ( self . assetBaseDirCheckBox , 0 , 0 , 1 , 1 ) <NEWLINE> self . sandboxCheckBox = QtGui . QCheckBox ( self . defaultRepoPathsGroupBox ) <NEWLINE> self . sandboxCheckBox . setObjectName ( <STRING> ) <NEWLINE> self . defaultRepoPathsLayout . addWidget ( self . sandboxCheckBox , 1 , 0 , 1 , 1 ) <NEWLINE> self . localRepoCheckBox = QtGui . QCheckBox ( self . defaultRepoPathsGroupBox ) <NEWLINE> self . localRepoCheckBox . setChecked ( True ) <NEWLINE> self . localRepoCheckBox . setObjectName ( <STRING> ) <NEWLINE> self . defaultRepoPathsLayout . addWidget ( self . localRepoCheckBox , 2 , 0 , 1 , 1 ) <NEWLINE> self . clientRepoCheckBox = QtGui . QCheckBox ( self . defaultRepoPathsGroupBox ) <NEWLINE> self . clientRepoCheckBox . setObjectName ( <STRING> ) <NEWLINE> self . defaultRepoPathsLayout . addWidget ( self . clientRepoCheckBox , 3 , 0 , 1 , 1 ) <NEWLINE> self . handoffCheckBox = QtGui . QCheckBox ( self . defaultRepoPathsGroupBox ) <NEWLINE> self . handoffCheckBox . setObjectName ( <STRING> ) <NEWLINE> self . defaultRepoPathsLayout . addWidget ( self . handoffCheckBox , 4 , 0 , 1 , 1 ) <NEWLINE> self . assetBaseDirNameLineEdit = QtGui . QLineEdit ( self . defaultRepoPathsGroupBox ) <NEWLINE> self . assetBaseDirNameLineEdit . setObjectName ( <STRING> ) <NEWLINE> self . defaultRepoPathsLayout . addWidget ( self . assetBaseDirNameLineEdit , 0 , 2 , 1 , 1 ) <NEWLINE> self . sandboxDirNameLineEdit = QtGui . QLineEdit ( self . defaultRepoPathsGroupBox ) <NEWLINE> self . sandboxDirNameLineEdit . setObjectName ( <STRING> ) <NEWLINE> self . defaultRepoPathsLayout . addWidget ( self . sandboxDirNameLineEdit , 1 , 2 , 1 , 1 ) <NEWLINE> self . localRepoDirNameLineEdit = QtGui . QLineEdit ( self . defaultRepoPathsGroupBox ) <NEWLINE> self . localRepoDirNameLineEdit . setObjectName ( <STRING> ) <NEWLINE> self . defaultRepoPathsLayout . addWidget ( self . localRepoDirNameLineEdit , 2 , 2 , 1 , 1 ) <NEWLINE> self . clientRepoDirNameLineEdit = QtGui . QLineEdit ( self . defaultRepoPathsGroupBox ) <NEWLINE> self . clientRepoDirNameLineEdit . setObjectName ( <STRING> ) <NEWLINE> self . defaultRepoPathsLayout . addWidget ( self . clientRepoDirNameLineEdit , 3 , 2 , 1 , 1 ) <NEWLINE> self . assetBaseDirColorToolButton = QtGui . QToolButton ( self . defaultRepoPathsGroupBox ) <NEWLINE> self . assetBaseDirColorToolButton . setMaximumSize ( QtCore . QSize ( 20 , 20 ) ) <NEWLINE> self . assetBaseDirColorToolButton . setStyleSheet ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"checkinPageWidget\"", "\"checkinPageWidgetLayout\"", "\"checkinMiscOptionsGroupBox\"", "\"checkinMiscOptionsLayout\"", "\"doubleClickSaveCheckBox\"", "\"versionsSeparateCheckinCheckBox\"", "\"doubleClickOpenCheckBox\"", "\"askBeforeSaveCheckBox\"", "\"snapshotDescriptionLimitCheckBox\"", "\"value\"", "\"snapshotDescriptionLimitSpinBox\"", "\"rightVersionsRadioButton\"", "\"bottomVersionsRadioButton\"", "\"snapshotsSavingOptionsGroupBox\"", "\"snapshotsSavingOptionsLayout\"", "\"repositoryComboBox\"", "\"repositoryLabel\"", "\"checkinMethodLabel\"", "\"checkinMethodComboBox\"", "\"\"", "\"\"", "\"\"", "\"\"", "\"\"", "\"updateVersionlessCheckBox\"", "\"createMayaDirsCheckBox\"", "\"createPlayblastCheckBox\"", "\"generatePreviewsCheckBox\"", "\"uncheckFromDropPlateCheckBox\"", "\"clearDropPlateAfterCheckincheckBox\"", "\"defaultRepoPathsGroupBox\"", "\"defaultRepoPathsLayout\"", "\"assetBaseDirPathLineEdit\"", "\"handoffDirPathLineEdit\"", "\"sandboxDirPathLineEdit\"", "\"localRepoDirPathLineEdit\"", "\"clientRepoDirPathLineEdit\"", "\"assetBaseDirCheckBox\"", "\"sandboxCheckBox\"", "\"localRepoCheckBox\"", "\"clientRepoCheckBox\"", "\"handoffCheckBox\"", "\"assetBaseDirNameLineEdit\"", "\"sandboxDirNameLineEdit\"", "\"localRepoDirNameLineEdit\"", "\"clientRepoDirNameLineEdit\"", "\"QToolButton {\\n\""]}, "window_span": [1786, 1790], "err_obj": {"msg": "unbalanced (){}[]"}}], ["fe8e8818f4346deb6a6878b3e9d946a9", {"code_string": "def register_user(self, user):\n    if self.registration_open():\n        registration = EventUserRegistration(event = self, user = user)\n        registration.save()\n    else:\n        raise ValidationError(_(\"Cannot register  user {user} to event \"\n            \"{event}: Registration ended at {end}\")\n            .format(user = user, event = self\n                end = self.registration_end_time)\n                )\n", "code_toks_joined": "def register_user ( self , user ) : <NEWLINE> <INDENT> if self . registration_open ( ) : <NEWLINE> <INDENT> registration = EventUserRegistration ( event = self , user = user ) <NEWLINE> registration . save ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise ValidationError ( _ ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> . format ( user = user , event = self <NEWLINE> <INDENT> end = self . registration_end_time ) <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Cannot register  user {user} to event \"", "\"{event}: Registration ended at {end}\""]}, "err_obj": {"msg": "invalid syntax"}}], ["f3dd3f1ae8b45c1df360336bbd5d089a", {"code_string": "def plot_densities((X, Y, Zs)):\n    '''Plots the iso-lines for the densities, given the results of classifier_grid.'''\n    heights = np.linspace(0, np.max(Zs), 7)\n    for ci in range(Zs.shape[- 1]):\n        Z = Zs[: , : , ci]\n        cs = plt.contour(X, Y, Z, heights, linewidths = .3, colors = 'k')\n        plt.clabel(cs, fontsize = 6)\n", "code_toks_joined": "def plot_densities ( ( X , Y , Zs ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> heights = np . linspace ( 0 , np . max ( Zs ) , 7 ) <NEWLINE> for ci in range ( Zs . shape [ - 1 ] ) : <NEWLINE> <INDENT> Z = Zs [ : , : , ci ] <NEWLINE> cs = plt . contour ( X , Y , Z , heights , linewidths = .3 , colors = <STRING> ) <NEWLINE> plt . clabel ( cs , fontsize = 6 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Plots the iso-lines for the densities, given the results of classifier_grid.'''", "'k'"]}, "err_obj": {"msg": "invalid syntax"}}], ["23a4fdd41e6b6486d3d222d457b76792", {"code_string": "def _OnTimelineEvent(self, event_info):\n    \"\"\"Invoked by the Remote Inspector Client when a timeline event occurs.\"\"\"\n    elapsed_time = int(round(time.time() - self._test_start_time)\n    if event_info['type'] == 'GCEvent':\n        self._events_to_output.append({\n            'type': 'GarbageCollection',\n            'time': elapsed_time,\n            'data':\n                {'collected_bytes': event_info['data']['usedHeapSizeDelta']},\n        })\n", "code_toks_joined": "def _OnTimelineEvent ( self , event_info ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> elapsed_time = int ( round ( time . time ( ) - self . _test_start_time ) <NEWLINE> if event_info [ <STRING> ] == <STRING> : <NEWLINE> <INDENT> self . _events_to_output . append ( { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : elapsed_time , <NEWLINE> <STRING> : <NEWLINE> <INDENT> { <STRING> : event_info [ <STRING> ] [ <STRING> ] } , <NEWLINE> <DEDENT> <DEDENT> } ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Invoked by the Remote Inspector Client when a timeline event occurs.\"\"\"", "'type'", "'GCEvent'", "'type'", "'GarbageCollection'", "'time'", "'data'", "'collected_bytes'", "'data'", "'usedHeapSizeDelta'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["044d632644a1a2c8b63ba8aa758457a4", {"code_string": "def _readResponseBody(self, response, contentType):\n    try:\n        processor = self.bodyProcessors[contentType]\n    except KeyError:\n        raise RuntimeError('Unknown content type: {}'.format(contentType)\n    else:\n        d = readBody(response)\n        if processor is not None:\n            d.addCallback(processor)\n        return d\n", "code_toks_joined": "def _readResponseBody ( self , response , contentType ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> processor = self . bodyProcessors [ contentType ] <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> raise RuntimeError ( <STRING> . format ( contentType ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = readBody ( response ) <NEWLINE> if processor is not None : <NEWLINE> <INDENT> d . addCallback ( processor ) <NEWLINE> <DEDENT> return d <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Unknown content type: {}'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["0f7c330ad4ec1457e1b1ba154ab9e27d", {"code_string": "def __print_var(self, key, val):\n    if(self.args.get('csh_output') or\n        (not self.args.get('sh_output') and\n            os.getenv('SHELL', '').endswith('csh'))):\n            if val:\n        fmt = 'setenv {key} {val};'\n        else:\n        fmt = 'unsetenv {key};'\n    else:\n        if val:\n            fmt = '{key}={val}; export {key};'\n        else:\n            fmt = 'unset {key};'\n    print(fmt.format(key = key, val = val))\n", "code_toks_joined": "def __print_var ( self , key , val ) : <NEWLINE> <INDENT> if ( self . args . get ( <STRING> ) or <NEWLINE> <INDENT> ( not self . args . get ( <STRING> ) and <NEWLINE> <INDENT> os . getenv ( <STRING> , <STRING> ) . endswith ( <STRING> ) ) ) : <NEWLINE> if val : <NEWLINE> <DEDENT> fmt = <STRING> <NEWLINE> else : <NEWLINE> fmt = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if val : <NEWLINE> <INDENT> fmt = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fmt = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( fmt . format ( key = key , val = val ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'csh_output'", "'sh_output'", "'SHELL'", "''", "'csh'", "'setenv {key} {val};'", "'unsetenv {key};'", "'{key}={val}; export {key};'", "'unset {key};'"]}, "err_obj": {"msg": "unindent does not match any outer indentation level"}}], ["c1d77d4d1dc022f952b9022bcceefe8a", {"code_string": "import logging\nfrom rest_framework import serializers\nfrom{{cookiecutter.project_slug}}.users.models import User\nlogger = logging.getLogger(__name__)\n", "code_toks_joined": "import logging <NEWLINE> from rest_framework import serializers <NEWLINE> from { { cookiecutter . project_slug } } . users . models import User <NEWLINE> logger = logging . getLogger ( __name__ ) <NEWLINE>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["8447353edf50aecabb3f9357c5ed0164", {"code_string": "def get_service_vm_status(self, vm_id):\n    try:\n        status = self._nclient.servers.get(vm_id).status\n    except(nova_exc.UnsupportedVersion, nova_exc.CommandError,\n        nova_exc.AuthorizationFailure, nova_exc.NoUniqueMatch,\n        nova_exc.AuthSystemNotFound, nova_exc.NoTokenLookupException,\n        nova_exc.EndpointNotFound, nova_exc.AmbiguousEndpoints,\n        nova_exc.ConnectionRefused, nova_exc.ClientException,\n        Exception) as e:\n        LOG.error(_('Failed to get status of service VM instance %(id)s, '\n            'due to %(err)s'), {'id': vm_id, 'err': e})\n            status = c_constants.SVM_ERROR\n    return status\n", "code_toks_joined": "def get_service_vm_status ( self , vm_id ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> status = self . _nclient . servers . get ( vm_id ) . status <NEWLINE> <DEDENT> except ( nova_exc . UnsupportedVersion , nova_exc . CommandError , <NEWLINE> <INDENT> nova_exc . AuthorizationFailure , nova_exc . NoUniqueMatch , <NEWLINE> nova_exc . AuthSystemNotFound , nova_exc . NoTokenLookupException , <NEWLINE> nova_exc . EndpointNotFound , nova_exc . AmbiguousEndpoints , <NEWLINE> nova_exc . ConnectionRefused , nova_exc . ClientException , <NEWLINE> Exception ) as e : <NEWLINE> LOG . error ( _ ( <STRING> <NEWLINE> <INDENT> <STRING> ) , { <STRING> : vm_id , <STRING> : e } ) <NEWLINE> status = c_constants . SVM_ERROR <NEWLINE> <DEDENT> <DEDENT> return status <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Failed to get status of service VM instance %(id)s, '", "'due to %(err)s'", "'id'", "'err'"]}, "err_obj": {"msg": "unexpected indent"}}], ["5b1089c9da08ecc0c7ffa781bb4cfbcc", {"code_string": "def decode_dict(x, cursor):\n    r, cursor = {}, cursor + 1\n    while x[cursor: cursor + 1] != CHR_TERM:\n        k, cursor = decode_func[x[cursor: cursor + 1]]](x, cursor)\n        r[k], cursor = decode_func[x[cursor: cursor + 1]](x, cursor)\n    return r, cursor + 1\n", "code_toks_joined": "def decode_dict ( x , cursor ) : <NEWLINE> <INDENT> r , cursor = { } , cursor + 1 <NEWLINE> while x [ cursor : cursor + 1 ] != CHR_TERM : <NEWLINE> <INDENT> k , cursor = decode_func [ x [ cursor : cursor + 1 ] ] ] ( x , cursor ) <NEWLINE> r [ k ] , cursor = decode_func [ x [ cursor : cursor + 1 ] ] ( x , cursor ) <NEWLINE> <DEDENT> return r , cursor + 1 <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["440e891fab1a9ee3c0133d7380f7e3cd", {"code_string": "for x in range(input()):\n    n = int(input()) - 1\n    while 1:\n        n += 1;\n        if str(n) == str(n)[: : - 1] and all(n % i for i in range(2, n ** 0.5 + 1, 1)):\n            print n\n127\n24.4\n", "code_toks_joined": "for x in range ( input ( ) ) : <NEWLINE> <INDENT> n = int ( input ( ) ) - 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> n += 1 ; <NEWLINE> if str ( n ) == str ( n ) [ : : - 1 ] and all ( n % i for i in range ( 2 , n ** 0.5 + 1 , 1 ) ) : <NEWLINE> <INDENT> print n <NEWLINE> <DEDENT> <DEDENT> <DEDENT> 127 <NEWLINE> 24.4 <NEWLINE>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["07d80b4d2b1043618760dca4248639a7", {"code_string": "def URL(url_obj):\n    \"\"\"Check the url_obj, if the object is a string it will be converted to a list object. Itterate\"\"\"\n        url_list = []\n        url_sort = []\n        if type(url_obj) == str:\n            url_obj = url_obj.split()\n        for obj in url_obj:\n            matches = re.findall(r'\\b(([\\w-]+://?|www[.])[^\\s()<>]+(?:\\([\\w\\d]+\\)|([^[:punct:]\\s]|/)))', obj)\n            if matches:\n                if matches[0] not in url_list:\n                    url_list.append(matches[0])\n        for url in sorted(url_list):\n            url_sort.append(url[0])\n", "code_toks_joined": "def URL ( url_obj ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> url_list = [ ] <NEWLINE> url_sort = [ ] <NEWLINE> if type ( url_obj ) == str : <NEWLINE> <INDENT> url_obj = url_obj . split ( ) <NEWLINE> <DEDENT> for obj in url_obj : <NEWLINE> <INDENT> matches = re . findall ( <STRING> , obj ) <NEWLINE> if matches : <NEWLINE> <INDENT> if matches [ 0 ] not in url_list : <NEWLINE> <INDENT> url_list . append ( matches [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for url in sorted ( url_list ) : <NEWLINE> <INDENT> url_sort . append ( url [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Check the url_obj, if the object is a string it will be converted to a list object. Itterate\"\"\"", "r'\\b(([\\w-]+://?|www[.])[^\\s()<>]+(?:\\([\\w\\d]+\\)|([^[:punct:]\\s]|/)))'"]}, "err_obj": {"msg": "unexpected indent"}}], ["a0fbaa28f9fff8f0da17da47455dbdd1", {"code_string": "def __repr__(self):\n    ret = []\n    for flist, fname in((self.fields_IN, \"VAR_IN\"),\n        (self.fields_OUT, \"VAR_OUT\"),\n        (self.fields_INOUT, \"VAR_IN_OUT\")):\n        if not flist:\n        continue\n        ret.append(fname)\n        for field in flist:\n        ret.append(\"  %s : %s;\" %(field.name, str(field.dataType)))\n        ret.append(\"END_VAR\")\n    if not ret:\n        ret = [\"<None>\"]\n    return '\\n'.join(ret)\n", "code_toks_joined": "def __repr__ ( self ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> for flist , fname in ( ( self . fields_IN , <STRING> ) , <NEWLINE> <INDENT> ( self . fields_OUT , <STRING> ) , <NEWLINE> ( self . fields_INOUT , <STRING> ) ) : <NEWLINE> if not flist : <NEWLINE> continue <NEWLINE> ret . append ( fname ) <NEWLINE> for field in flist : <NEWLINE> ret . append ( <STRING> % ( field . name , str ( field . dataType ) ) ) <NEWLINE> ret . append ( <STRING> ) <NEWLINE> <DEDENT> if not ret : <NEWLINE> <INDENT> ret = [ <STRING> ] <NEWLINE> <DEDENT> return <STRING> . join ( ret ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"VAR_IN\"", "\"VAR_OUT\"", "\"VAR_IN_OUT\"", "\"  %s : %s;\"", "\"END_VAR\"", "\"<None>\"", "'\\n'"]}, "err_obj": {"msg": "expected an indented block"}}], ["6d726d32cd040b3bae59ba97a0a462ef", {"code_string": "def loadURL(self):\n    bHasUUID = AISUtil.hasUUID(self.__settings)\n    if False == bHasUUID:\n    print('asking for UUID')\n    uuidCreateReq = APUUIDCreateRequest.APUUIDCreateRequest(self.__settings)\n    uuidDict = uuidCreateReq.loadURL(True)\n    for key, val in uuidDict.items():\n        print('key ' + key + ', value: ' + val)\n        return uuidDict\n        else:\n        print('opening session')\n        self.openSession()\n        self.prepareQueryURL()\n        return super(APAccountLoader, self).loadURL()\n", "code_toks_joined": "def loadURL ( self ) : <NEWLINE> <INDENT> bHasUUID = AISUtil . hasUUID ( self . __settings ) <NEWLINE> if False == bHasUUID : <NEWLINE> print ( <STRING> ) <NEWLINE> uuidCreateReq = APUUIDCreateRequest . APUUIDCreateRequest ( self . __settings ) <NEWLINE> uuidDict = uuidCreateReq . loadURL ( True ) <NEWLINE> for key , val in uuidDict . items ( ) : <NEWLINE> <INDENT> print ( <STRING> + key + <STRING> + val ) <NEWLINE> return uuidDict <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> self . openSession ( ) <NEWLINE> self . prepareQueryURL ( ) <NEWLINE> return super ( APAccountLoader , self ) . loadURL ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'asking for UUID'", "'key '", "', value: '", "'opening session'"]}, "err_obj": {"msg": "expected an indented block"}}], ["e39c583ce1dfc7e82ec76e97dfda9104", {"code_string": "def _init(self):\n    self.environment.setdefault(\n        constants.SysEnv.COMMAND_PATH\n        constants.Defaults.COMMAND_SEARCH_PATH\n    )\n    self.context.registerCommand(command = self)\n", "code_toks_joined": "def _init ( self ) : <NEWLINE> <INDENT> self . environment . setdefault ( <NEWLINE> <INDENT> constants . SysEnv . COMMAND_PATH <NEWLINE> constants . Defaults . COMMAND_SEARCH_PATH <NEWLINE> <DEDENT> ) <NEWLINE> self . context . registerCommand ( command = self ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["e48445c69ea2a36505a682a3880992de", {"code_string": "def _get_destination_directory_list_for_webdav_server(self, start_date):\n    directory_list = []\n    for param in[settings.GA_DIAGNOSIS_DESTINATION_ROOT_PATH, str(start_date.year),\n        '{:02d}'.format(start_date.month),\n        '{:02d}'.format(start_date.day)]:\n        directory_list.append(param)\n        if not self.webdav.exists(os.path.join(* directory_list)):\n        self.webdav.mkdir(os.path.join(* directory_list))\n    return directory_list\n", "code_toks_joined": "def _get_destination_directory_list_for_webdav_server ( self , start_date ) : <NEWLINE> <INDENT> directory_list = [ ] <NEWLINE> for param in [ settings . GA_DIAGNOSIS_DESTINATION_ROOT_PATH , str ( start_date . year ) , <NEWLINE> <INDENT> <STRING> . format ( start_date . month ) , <NEWLINE> <STRING> . format ( start_date . day ) ] : <NEWLINE> directory_list . append ( param ) <NEWLINE> if not self . webdav . exists ( os . path . join ( * directory_list ) ) : <NEWLINE> self . webdav . mkdir ( os . path . join ( * directory_list ) ) <NEWLINE> <DEDENT> return directory_list <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'{:02d}'", "'{:02d}'"]}, "err_obj": {"msg": "expected an indented block"}}], ["592e77cf25c4b74d5978d7f4e91806c6", {"code_string": "def test_config_for_dot_name_domain(self):\n    domain_config_filename = os.path.join(self.tmp_dir,\n        'keystone.abc.def.com.conf')\n    with open(domain_config_filename, 'w'):\n        \"\"\"Write an empty config file.\"\"\"\n    self.addCleanup(os.remove, domain_config_filename)\n    with mock.patch.object(identity.DomainConfigs,\n        '_load_config_from_file') as mock_load_config:\n        domain_config = identity.DomainConfigs()\n        fake_assignment_api = None\n        fake_standard_driver = None\n        domain_config.setup_domain_drivers(fake_standard_driver,\n            fake_assignment_api)\n            mock_load_config.assert_called_once_with(fake_assignment_api,\n                [domain_config_filename],\n                'abc.def.com')\n", "code_toks_joined": "def test_config_for_dot_name_domain ( self ) : <NEWLINE> <INDENT> domain_config_filename = os . path . join ( self . tmp_dir , <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> with open ( domain_config_filename , <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> self . addCleanup ( os . remove , domain_config_filename ) <NEWLINE> with mock . patch . object ( identity . DomainConfigs , <NEWLINE> <INDENT> <STRING> ) as mock_load_config : <NEWLINE> domain_config = identity . DomainConfigs ( ) <NEWLINE> fake_assignment_api = None <NEWLINE> fake_standard_driver = None <NEWLINE> domain_config . setup_domain_drivers ( fake_standard_driver , <NEWLINE> <INDENT> fake_assignment_api ) <NEWLINE> mock_load_config . assert_called_once_with ( fake_assignment_api , <NEWLINE> <INDENT> [ domain_config_filename ] , <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'keystone.abc.def.com.conf'", "'w'", "\"\"\"Write an empty config file.\"\"\"", "'_load_config_from_file'", "'abc.def.com'"]}, "err_obj": {"msg": "unexpected indent"}}], ["7d4b93f9d15b38296415d846502ac67f", {"code_string": "import re\nfrom django.db.models import Q\nfrom public_project.models import Page\ndef normalize_query(query_string,\n    findterms = re.compile(r'\"([^\"]+)\"|(\\S+)').findall,\n    normspace = re.compile(r'\\s{2, }').sub):\n    ''' Splits the query string in invidual keywords, getting rid of unecessary spaces'''\n    return[normspace(' ', (t[0] or t[1]).strip())) for t in findterms(query_string)]\n", "code_toks_joined": "import re <NEWLINE> from django . db . models import Q <NEWLINE> from public_project . models import Page <NEWLINE> def normalize_query ( query_string , <NEWLINE> <INDENT> findterms = re . compile ( <STRING> ) . findall , <NEWLINE> normspace = re . compile ( <STRING> ) . sub ) : <NEWLINE> <STRING> <NEWLINE> return [ normspace ( <STRING> , ( t [ 0 ] or t [ 1 ] ) . strip ( ) ) ) for t in findterms ( query_string ) ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["r'\"([^\"]+)\"|(\\S+)'", "r'\\s{2, }'", "''' Splits the query string in invidual keywords, getting rid of unecessary spaces'''", "' '"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["d0acf92d7872efd9354ee5db2c8cd400", {"code_string": "class MemDB(object):\n    def __init__(self, snake):\n        self._get = snake.get_method('get')\n        self._set = snake.get_method('set')\n        self._find = snake.get_method('find')\n        self._keys = snake.get_method('get_keys')\n    def get(self, key):\n        R = self._get(key = key)\n        print(R)\n        return R['result']\n    def set(self, key, value):\n        R = self._set(key = key, value = value)\n    def find(self, path, value):\n        R = self._find(path = path, value = value})\n        return R['result']\n    def get_keys(self):\n        R = self._keys()\n        return R['result']\n", "code_toks_joined": "class MemDB ( object ) : <NEWLINE> <INDENT> def __init__ ( self , snake ) : <NEWLINE> <INDENT> self . _get = snake . get_method ( <STRING> ) <NEWLINE> self . _set = snake . get_method ( <STRING> ) <NEWLINE> self . _find = snake . get_method ( <STRING> ) <NEWLINE> self . _keys = snake . get_method ( <STRING> ) <NEWLINE> <DEDENT> def get ( self , key ) : <NEWLINE> <INDENT> R = self . _get ( key = key ) <NEWLINE> print ( R ) <NEWLINE> return R [ <STRING> ] <NEWLINE> <DEDENT> def set ( self , key , value ) : <NEWLINE> <INDENT> R = self . _set ( key = key , value = value ) <NEWLINE> <DEDENT> def find ( self , path , value ) : <NEWLINE> <INDENT> R = self . _find ( path = path , value = value } ) <NEWLINE> return R [ <STRING> ] <NEWLINE> <DEDENT> def get_keys ( self ) : <NEWLINE> <INDENT> R = self . _keys ( ) <NEWLINE> return R [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'get'", "'set'", "'find'", "'get_keys'", "'result'", "'result'", "'result'"]}, "window_span": [135, 152], "err_obj": {"msg": "unbalanced (){}[]"}}], ["0113c5ec2702b453bbc931b2c647eb05", {"code_string": "from suds.client import Client\nclient = Client(\"https://my.interserver.net/api.php?wsdl\")\nsid = client.service.api_login(argv[1], argv[2])\nif(sid == '')\n    die(\"Got a blank session\")\nprint(\"Got Session ID \" + sid + \"\\n\")\nresult = client.service.api_getTicketList()\nprint(result)\n", "code_toks_joined": "from suds . client import Client <NEWLINE> client = Client ( <STRING> ) <NEWLINE> sid = client . service . api_login ( argv [ 1 ] , argv [ 2 ] ) <NEWLINE> if ( sid == <STRING> ) <NEWLINE> <INDENT> die ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> + sid + <STRING> ) <NEWLINE> result = client . service . api_getTicketList ( ) <NEWLINE> print ( result ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"https://my.interserver.net/api.php?wsdl\"", "''", "\"Got a blank session\"", "\"Got Session ID \"", "\"\\n\""]}, "err_obj": {"msg": "invalid syntax"}}], ["b898f6d9c71803d82f24df56ada68940", {"code_string": "import GBDT\nif __name__ == '__main__':\n    handle = GBDT.load('test.model')\n    s = '0 ' + ' '.join(map(lambda(i, v): '%d:%d' %(i + 1, v), enumerate([i for i in range(20)])))\n    score = GBDT.predict(handle, s)\n    print('Score = %f' % score)\n    leaves = GBDT.tree_features(handle, s)\n    print(leaves)\n", "code_toks_joined": "import GBDT <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> handle = GBDT . load ( <STRING> ) <NEWLINE> s = <STRING> + <STRING> . join ( map ( lambda ( i , v ) : <STRING> % ( i + 1 , v ) , enumerate ( [ i for i in range ( 20 ) ] ) ) ) <NEWLINE> score = GBDT . predict ( handle , s ) <NEWLINE> print ( <STRING> % score ) <NEWLINE> leaves = GBDT . tree_features ( handle , s ) <NEWLINE> print ( leaves ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'__main__'", "'test.model'", "'0 '", "' '", "'%d:%d'", "'Score = %f'"]}, "err_obj": {"msg": "invalid syntax"}}], ["edd21d3bc859263ef417d7c43ef08e62", {"code_string": "def _do_request(self, method, values):\n    '''Request JSON data from TMDB'''\n    url = \"%s/%s?language=%s&api_key=%s&%s\" %(self.url_prefix, method, self.lang, self.api_key, values)\n    try:\n        meta = requests.get(url).json()\n    except Exception, e:\n        return None\n    if meta == 'Nothing found.':\n        return None\n    else:\n        return meta\n", "code_toks_joined": "def _do_request ( self , method , values ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> url = <STRING> % ( self . url_prefix , method , self . lang , self . api_key , values ) <NEWLINE> try : <NEWLINE> <INDENT> meta = requests . get ( url ) . json ( ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> if meta == <STRING> : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return meta <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Request JSON data from TMDB'''", "\"%s/%s?language=%s&api_key=%s&%s\"", "'Nothing found.'"]}, "err_obj": {"msg": "invalid syntax"}}], ["69161a04eb3afac48f6a51a4cf5d3f0d", {"code_string": "def create_playlist_url(self, channel):\n    token = self.create_playlist_token(channel)\n    if token:\n        return self.url(HLS_PLAYLIST_PATH, channel, quote(token)\n", "code_toks_joined": "def create_playlist_url ( self , channel ) : <NEWLINE> <INDENT> token = self . create_playlist_token ( channel ) <NEWLINE> if token : <NEWLINE> <INDENT> return self . url ( HLS_PLAYLIST_PATH , channel , quote ( token ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c382f669bc14850d352a9d94e33d87fd", {"code_string": "def __openseen(self, ttype, tstring, lineno):\n    if ttype == tokenize.OP and tstring == ')':\n        if self.__data:\n            self.__addentry(EMPTYSTRING.join(self.__data))\n        self.__state = self.__waiting\n    elif ttype == tokenize.STRING:\n        self.__data.append(safe_eval(tstring))\n    elif ttype not in[tokenize.COMMENT, token.INDENT, token.DEDENT,\n        token.NEWLINE, tokenize.NL]:\n        print(_(\n        '*** %(file)s:%(lineno)s: Seen unexpected token \"%(token)s\"'\n        ) %{\n        'token': tstring,\n        'file': self.__curfile,\n        'lineno': self.__lineno\n        }\n        self.__state = self.__waiting\n", "code_toks_joined": "def __openseen ( self , ttype , tstring , lineno ) : <NEWLINE> <INDENT> if ttype == tokenize . OP and tstring == <STRING> : <NEWLINE> <INDENT> if self . __data : <NEWLINE> <INDENT> self . __addentry ( EMPTYSTRING . join ( self . __data ) ) <NEWLINE> <DEDENT> self . __state = self . __waiting <NEWLINE> <DEDENT> elif ttype == tokenize . STRING : <NEWLINE> <INDENT> self . __data . append ( safe_eval ( tstring ) ) <NEWLINE> <DEDENT> elif ttype not in [ tokenize . COMMENT , token . INDENT , token . DEDENT , <NEWLINE> <INDENT> token . NEWLINE , tokenize . NL ] : <NEWLINE> print ( _ ( <NEWLINE> <STRING> <NEWLINE> ) % { <NEWLINE> <STRING> : tstring , <NEWLINE> <STRING> : self . __curfile , <NEWLINE> <STRING> : self . __lineno <NEWLINE> } <NEWLINE> self . __state = self . __waiting <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["')'", "'*** %(file)s:%(lineno)s: Seen unexpected token \"%(token)s\"'", "'token'", "'file'", "'lineno'"]}, "window_span": [110, 150], "err_obj": {"msg": "unbalanced (){}[]"}}], ["d1d61ace1edb577cb2632aa2823e6f05", {"code_string": "class GladeDelegate(BaseView, BaseController):\n    \"\"\"A class that combines view and controller functionality into a\"\"\"\n    def __init__(self, gladefile = None, toplevel_name = None, domain = None,\n        delete_handler = None, keyactions = None):\n        \"\"\"Creates a new GladeDelegate.\"\"\"\n        BaseView.__init__(self,\n            gladefile = gladefile,\n            toplevel_name = toplevel_name,\n            domain = domain,\n            delete_handler = delete_handler)\n            BaseController.__init__(self, view = self, keyactions = keyactions)\n", "code_toks_joined": "class GladeDelegate ( BaseView , BaseController ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , gladefile = None , toplevel_name = None , domain = None , <NEWLINE> <INDENT> delete_handler = None , keyactions = None ) : <NEWLINE> <STRING> <NEWLINE> BaseView . __init__ ( self , <NEWLINE> <INDENT> gladefile = gladefile , <NEWLINE> toplevel_name = toplevel_name , <NEWLINE> domain = domain , <NEWLINE> delete_handler = delete_handler ) <NEWLINE> BaseController . __init__ ( self , view = self , keyactions = keyactions ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"A class that combines view and controller functionality into a\"\"\"", "\"\"\"Creates a new GladeDelegate.\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["0d5f3973f0a9d4ea664e40b6959cdf2f", {"code_string": "def setSparseFeatWeight(self, name, val):\n    if name in self.sparseFeaturesMap:\n    id = self.sparseFeaturesMap[name]\n    self.sparseFeatures[id] = val\n    return id\n    else:\n    self.sparseFeatures.append(val)\n    self.sparseSigma.append(0)\n    self.sparseFeaturesMap[name] = len(self.sparseFeatures) - 1\n    return len(self.sparseFeatures) - 1\n", "code_toks_joined": "def setSparseFeatWeight ( self , name , val ) : <NEWLINE> <INDENT> if name in self . sparseFeaturesMap : <NEWLINE> id = self . sparseFeaturesMap [ name ] <NEWLINE> self . sparseFeatures [ id ] = val <NEWLINE> return id <NEWLINE> else : <NEWLINE> self . sparseFeatures . append ( val ) <NEWLINE> self . sparseSigma . append ( 0 ) <NEWLINE> self . sparseFeaturesMap [ name ] = len ( self . sparseFeatures ) - 1 <NEWLINE> return len ( self . sparseFeatures ) - 1 <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["0bfcb4a2eb4ccbb9dc388b3f3ef7a5a4", {"code_string": "def info(self):\n    vars = [x[12: ] for x in dir(cv2.cv) if 'CV_CAP_PROP' in x]\n    ret = {}\n    for p in vars:\n        cmd = 'ret[\\'' + p + '\\'] = self.cam.get(cv2.cv.CV_CAP_PROP_' + p + ')'\n        exec cmd\n    return ret\n", "code_toks_joined": "def info ( self ) : <NEWLINE> <INDENT> vars = [ x [ 12 : ] for x in dir ( cv2 . cv ) if <STRING> in x ] <NEWLINE> ret = { } <NEWLINE> for p in vars : <NEWLINE> <INDENT> cmd = <STRING> + p + <STRING> + p + <STRING> <NEWLINE> exec cmd <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'CV_CAP_PROP'", "'ret[\\''", "'\\'] = self.cam.get(cv2.cv.CV_CAP_PROP_'", "')'"]}, "err_obj": {"msg": "invalid syntax"}}], ["32798bd1eb8a0d0d9e89fb1200f20593", {"code_string": "def _getSummary(self):\n    \"\"\"Return a formatted count of tests status results.\"\"\"\n    summaries = []\n    for stat in(\"skips\", \"expectedFailures\", \"failures\", \"errors\",\n        \"unexpectedSuccesses\"):\n        num = len(getattr(self, stat))\n        if num:\n        summaries.append('%s=%d' %(stat, num))\n    if self.successes:\n        summaries.append('successes=%d' %(self.successes, ))\n    summary = (summaries and ' (' + ', '.join(summaries) + ')') or ''\n    return summary\n", "code_toks_joined": "def _getSummary ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> summaries = [ ] <NEWLINE> for stat in ( <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> num = len ( getattr ( self , stat ) ) <NEWLINE> if num : <NEWLINE> summaries . append ( <STRING> % ( stat , num ) ) <NEWLINE> <DEDENT> if self . successes : <NEWLINE> <INDENT> summaries . append ( <STRING> % ( self . successes , ) ) <NEWLINE> <DEDENT> summary = ( summaries and <STRING> + <STRING> . join ( summaries ) + <STRING> ) or <STRING> <NEWLINE> return summary <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return a formatted count of tests status results.\"\"\"", "\"skips\"", "\"expectedFailures\"", "\"failures\"", "\"errors\"", "\"unexpectedSuccesses\"", "'%s=%d'", "'successes=%d'", "' ('", "', '", "')'", "''"]}, "err_obj": {"msg": "expected an indented block"}}], ["4cdbda404c7a85b9809b05f1976e052e", {"code_string": "def var2mean(self, RasterValues):\n    '\\n' 'Descripcion: Toma la imagen clasificada y una varaible\\n' '\tdistribuida a partir de esta segunda calcula la media\\n' '\ty la desviacion de la variable en cada objeto\\n' '\\n' 'Parametros\\n' '----------\\n' 'ObjectList : Lista de 3XN con las celdas que componen los objetos.\\n' 'RasterValues : Matriz con los valores raster a promediar.\\n' '\\n' 'Retornos\\n' '----------\\n' 'meanVar : Vector con las medias de cada objeto.\\n' 'stdVar : Vector con las desviaciones de cada objeto.\\n' '\\n' 'Ejemplo\\n' '----------\\n' '.\\n' meanvar, stdVar = radar_f90.var2mean(RasterValues,\n        self.elements, self.elements[0, - 1],\n        radar_f90.ncols,\n        radar_f90.nrows,\n        self.elements.shape[1])\n    return meanvar, stdVar\n", "code_toks_joined": "def var2mean ( self , RasterValues ) : <NEWLINE> <INDENT> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> meanvar , stdVar = radar_f90 . var2mean ( RasterValues , <NEWLINE> <INDENT> self . elements , self . elements [ 0 , - 1 ] , <NEWLINE> radar_f90 . ncols , <NEWLINE> radar_f90 . nrows , <NEWLINE> self . elements . shape [ 1 ] ) <NEWLINE> <DEDENT> return meanvar , stdVar <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'\\n'", "'Descripcion: Toma la imagen clasificada y una varaible\\n'", "'\tdistribuida a partir de esta segunda calcula la media\\n'", "'\ty la desviacion de la variable en cada objeto\\n'", "'\\n'", "'Parametros\\n'", "'----------\\n'", "'ObjectList : Lista de 3XN con las celdas que componen los objetos.\\n'", "'RasterValues : Matriz con los valores raster a promediar.\\n'", "'\\n'", "'Retornos\\n'", "'----------\\n'", "'meanVar : Vector con las medias de cada objeto.\\n'", "'stdVar : Vector con las desviaciones de cada objeto.\\n'", "'\\n'", "'Ejemplo\\n'", "'----------\\n'", "'.\\n'"]}, "err_obj": {"msg": "invalid syntax"}}], ["6552eef294e3b3eb925979982577a4d4", {"code_string": "import sys, re\nif __name__ == \"__main__\":\n    num = 0\n    if len(sys.argv) < 3:\n        raise Exception(\"You need to specify both the CMAP file and the AFM file\")\n    file1 = sys.argv[1]\n    file2 = sys.argv[2]\n    count = llx = urx = lly = ury = 0\n    code2cid = {}\n    cid2code = {}\n    with open(\"features.BASE\", \"w\") as fout:\n        with open(file1) as cmap:\n            target_lines = False\n            for line in cmap.readlines():\n                line = line.rstrip()\n                if re.search(r\"begincidrange$\", line):\n                    target_lines = True\n                    continue\n                elif re.search(r\"^endcidrange\", line):\n                    target_lines = False\n                    continue\n                if target_lines:\n                    m = re.search(r\"^<([0-9A-Fa-f]+)>\\s+<([0-9A-Fa-f]+)>\\s+(\\d+)$\", line)\n                    if m:\n                        begin = int(m.group(1), 16)\n                        end = int(m.group(2), 16)\n                        cid = int(m.group(3))\n                        for char in range(begin, end + 1):\n                            if int(\"4E00\", 16) <= char <= int(\"9FA5\", 16) or int(\"F900\", 16) <= char <= int(\"FA2D\", 16) or int(\"3041\", 16) <= char <= int(\"3094\", 16) or int(\"30A1\", 16) <= char <= int(\"30FA\", 16) or int(\"AC00\", 16) <= char <= int(\"D7A3\", 16):\n                                code = \"{0:02X}\".format(char)\n                                code2cid[code] = cid\n                                cid2code[cid] = code\n                                count += 1\n                                cid += 1\n        print(\"Done.\")\n        print(\"Storing AFM records for\", )\n        fontname = \"\"\n        version = \"\"\n        notice = \"\"\n        data = {}\n        with open(file2) as afm:\n            target_lines = False\n            for line in afm.readlines():\n                line = line.rstrip()\n                m = re.search(r\"^FontName\\s+(.*)$\", line)\n                if m:\n                    fontname = m.group(1)\n                    print(\"\\\"{}\\\" CIDFont into lookup structure...\".format(fontname), )\n                    continue\n                m = re.search(r\"^Version\\s+(.*)$\", line)\n                if m:\n                    version = m.group(1)\n                    continue\n                m = re.search(r\"^Notice\\s+(.*)$\", line)\n                if m:\n                    notice = m.group(1)\n                    notice = re.sub(r\"\\([Cc]\\)\\s+\", \"\", notice)\n                    continue\n                m = re.search(r\"^StartCharMetrics\", line)\n                if m:\n                    target_lines = True\n                    continue\n                elif re.search(r\"^EndCharMetrics\", line):\n                    target_lines = False\n                    continue\n                if target_lines:\n                    m = re.search(r\"^\\s*C\\s+-1\\s+;\\s+W0X\\s+(\\d+)\\s+;\\s+N\\s+(\\d+)\\s+;\\s+B\\s+((-?\\d+)\\s+(-?\\d+)\\s+(-?\\d+)\\s+(-?\\d+))\\s+;\\s*$\", line)\n                    if m:\n                        width = int(m.group(1))\n                        cid = int(m.group(2))\n                        bbox = m.group(3)\n                        a = int(m.group(4))\n                        b = int(m.group(5))\n                        c = int(m.group(6))\n                        d = int(m.group(7))\n                        if cid in cid2code:\n                            num += 1\n                            data[cid] = \"W0X {} ; B {} ;\".format(width, bbox)\n                            if bbox != \"0 0 0 0\":\n                                llx += a\n                                lly += b\n                                urx += c\n                                ury += d\n        print(\"Done.\")\n        left = llx / num\n        right = 1000 -(urx / num)\n        bottom = 120 +(lly / num)\n        top = 880 -(ury / num)\n        result = (left + right + bottom + top) / 4\n        left = result\n        right = 1000 - result\n        bottom = - 120 + result\n        top = 880 - result\n        print(\"\"\"table BASE {\"\"\"[1: - 1])\n        print(\"\"\"HorizAxis.BaseTagList                 icfb  icft  ideo  romn)\n        print ( \"\"\"} BASE)\n", "code_toks_joined": "import sys , re <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> num = 0 <NEWLINE> if len ( sys . argv ) < 3 : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> file1 = sys . argv [ 1 ] <NEWLINE> file2 = sys . argv [ 2 ] <NEWLINE> count = llx = urx = lly = ury = 0 <NEWLINE> code2cid = { } <NEWLINE> cid2code = { } <NEWLINE> with open ( <STRING> , <STRING> ) as fout : <NEWLINE> <INDENT> with open ( file1 ) as cmap : <NEWLINE> <INDENT> target_lines = False <NEWLINE> for line in cmap . readlines ( ) : <NEWLINE> <INDENT> line = line . rstrip ( ) <NEWLINE> if re . search ( <STRING> , line ) : <NEWLINE> <INDENT> target_lines = True <NEWLINE> continue <NEWLINE> <DEDENT> elif re . search ( <STRING> , line ) : <NEWLINE> <INDENT> target_lines = False <NEWLINE> continue <NEWLINE> <DEDENT> if target_lines : <NEWLINE> <INDENT> m = re . search ( <STRING> , line ) <NEWLINE> if m : <NEWLINE> <INDENT> begin = int ( m . group ( 1 ) , 16 ) <NEWLINE> end = int ( m . group ( 2 ) , 16 ) <NEWLINE> cid = int ( m . group ( 3 ) ) <NEWLINE> for char in range ( begin , end + 1 ) : <NEWLINE> <INDENT> if int ( <STRING> , 16 ) <= char <= int ( <STRING> , 16 ) or int ( <STRING> , 16 ) <= char <= int ( <STRING> , 16 ) or int ( <STRING> , 16 ) <= char <= int ( <STRING> , 16 ) or int ( <STRING> , 16 ) <= char <= int ( <STRING> , 16 ) or int ( <STRING> , 16 ) <= char <= int ( <STRING> , 16 ) : <NEWLINE> <INDENT> code = <STRING> . format ( char ) <NEWLINE> code2cid [ code ] = cid <NEWLINE> cid2code [ cid ] = code <NEWLINE> count += 1 <NEWLINE> cid += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> , ) <NEWLINE> fontname = <STRING> <NEWLINE> version = <STRING> <NEWLINE> notice = <STRING> <NEWLINE> data = { } <NEWLINE> with open ( file2 ) as afm : <NEWLINE> <INDENT> target_lines = False <NEWLINE> for line in afm . readlines ( ) : <NEWLINE> <INDENT> line = line . rstrip ( ) <NEWLINE> m = re . search ( <STRING> , line ) <NEWLINE> if m : <NEWLINE> <INDENT> fontname = m . group ( 1 ) <NEWLINE> print ( <STRING> . format ( fontname ) , ) <NEWLINE> continue <NEWLINE> <DEDENT> m = re . search ( <STRING> , line ) <NEWLINE> if m : <NEWLINE> <INDENT> version = m . group ( 1 ) <NEWLINE> continue <NEWLINE> <DEDENT> m = re . search ( <STRING> , line ) <NEWLINE> if m : <NEWLINE> <INDENT> notice = m . group ( 1 ) <NEWLINE> notice = re . sub ( <STRING> , <STRING> , notice ) <NEWLINE> continue <NEWLINE> <DEDENT> m = re . search ( <STRING> , line ) <NEWLINE> if m : <NEWLINE> <INDENT> target_lines = True <NEWLINE> continue <NEWLINE> <DEDENT> elif re . search ( <STRING> , line ) : <NEWLINE> <INDENT> target_lines = False <NEWLINE> continue <NEWLINE> <DEDENT> if target_lines : <NEWLINE> <INDENT> m = re . search ( <STRING> , line ) <NEWLINE> if m : <NEWLINE> <INDENT> width = int ( m . group ( 1 ) ) <NEWLINE> cid = int ( m . group ( 2 ) ) <NEWLINE> bbox = m . group ( 3 ) <NEWLINE> a = int ( m . group ( 4 ) ) <NEWLINE> b = int ( m . group ( 5 ) ) <NEWLINE> c = int ( m . group ( 6 ) ) <NEWLINE> d = int ( m . group ( 7 ) ) <NEWLINE> if cid in cid2code : <NEWLINE> <INDENT> num += 1 <NEWLINE> data [ cid ] = <STRING> . format ( width , bbox ) <NEWLINE> if bbox != <STRING> : <NEWLINE> <INDENT> llx += a <NEWLINE> lly += b <NEWLINE> urx += c <NEWLINE> ury += d <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> left = llx / num <NEWLINE> right = 1000 - ( urx / num ) <NEWLINE> bottom = 120 + ( lly / num ) <NEWLINE> top = 880 - ( ury / num ) <NEWLINE> result = ( left + right + bottom + top ) / 4 <NEWLINE> left = result <NEWLINE> right = 1000 - result <NEWLINE> bottom = - 120 + result <NEWLINE> top = 880 - result <NEWLINE> print ( <STRING> [ 1 : - 1 ] ) <NEWLINE> print ( <STRING> } BASE ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"__main__\"", "\"You need to specify both the CMAP file and the AFM file\"", "\"features.BASE\"", "\"w\"", "r\"begincidrange$\"", "r\"^endcidrange\"", "r\"^<([0-9A-Fa-f]+)>\\s+<([0-9A-Fa-f]+)>\\s+(\\d+)$\"", "\"4E00\"", "\"9FA5\"", "\"F900\"", "\"FA2D\"", "\"3041\"", "\"3094\"", "\"30A1\"", "\"30FA\"", "\"AC00\"", "\"D7A3\"", "\"{0:02X}\"", "\"Done.\"", "\"Storing AFM records for\"", "\"\"", "\"\"", "\"\"", "r\"^FontName\\s+(.*)$\"", "\"\\\"{}\\\" CIDFont into lookup structure...\"", "r\"^Version\\s+(.*)$\"", "r\"^Notice\\s+(.*)$\"", "r\"\\([Cc]\\)\\s+\"", "\"\"", "r\"^StartCharMetrics\"", "r\"^EndCharMetrics\"", "r\"^\\s*C\\s+-1\\s+;\\s+W0X\\s+(\\d+)\\s+;\\s+N\\s+(\\d+)\\s+;\\s+B\\s+((-?\\d+)\\s+(-?\\d+)\\s+(-?\\d+)\\s+(-?\\d+))\\s+;\\s*$\"", "\"W0X {} ; B {} ;\"", "\"0 0 0 0\"", "\"Done.\"", "\"\"\"table BASE {\"\"\"", "\"\"\"HorizAxis.BaseTagList                 icfb  icft  ideo  romn)\n        print ( \"\"\""]}, "window_span": [809, 816], "err_obj": {"msg": "unbalanced (){}[]"}}], ["5751575f973b2934313ba7d335619a2f", {"code_string": "def _test_RuntimeError(self):\n    e1 = RuntimeError\n    def fn():\n        RuntimeError = bool\n        try:\n            a = dict(a = 1, b = 2, c = 3)\n            for k, v in a.iteritems():\n                a['_%s' % k] = v\n        except e1, e:\n            self.assertTrue(isinstance(e, e1))\n            self.assertFalse(isinstance(e, RuntimeError))\n        else:\n            self.fail(\"Failed to raise RuntimeError\")\n    fn()\n", "code_toks_joined": "def _test_RuntimeError ( self ) : <NEWLINE> <INDENT> e1 = RuntimeError <NEWLINE> def fn ( ) : <NEWLINE> <INDENT> RuntimeError = bool <NEWLINE> try : <NEWLINE> <INDENT> a = dict ( a = 1 , b = 2 , c = 3 ) <NEWLINE> for k , v in a . iteritems ( ) : <NEWLINE> <INDENT> a [ <STRING> % k ] = v <NEWLINE> <DEDENT> <DEDENT> except e1 , e : <NEWLINE> <INDENT> self . assertTrue ( isinstance ( e , e1 ) ) <NEWLINE> self . assertFalse ( isinstance ( e , RuntimeError ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . fail ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> fn ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'_%s'", "\"Failed to raise RuntimeError\""]}, "err_obj": {"msg": "invalid syntax"}}], ["5fe010b07cd76cbb0f87806c2599888c", {"code_string": "def create_userpreference(sender, instance, created, ** kwargs):\n    if created:\n    UserPreference.objects.get_or_create(user = instance)\n", "code_toks_joined": "def create_userpreference ( sender , instance , created , ** kwargs ) : <NEWLINE> <INDENT> if created : <NEWLINE> UserPreference . objects . get_or_create ( user = instance ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["f98d0e0e258d6496af35cd0b90b36d41", {"code_string": "class PRecord:\n    def __init__(self, attr = 0, id = 0, category = 0, raw = ''):\n    self.raw = raw\n    self.id = id\n    self.attr = attr\n    self.category = category\n    def __cmp__(self, obj):\n    if type(obj) == type(0):\n        return cmp(self.id, obj)\n        else:\n        return cmp(self.id, obj.id)\n    def __hash__(self):\n    return self.id\n", "code_toks_joined": "class PRecord : <NEWLINE> <INDENT> def __init__ ( self , attr = 0 , id = 0 , category = 0 , raw = <STRING> ) : <NEWLINE> self . raw = raw <NEWLINE> self . id = id <NEWLINE> self . attr = attr <NEWLINE> self . category = category <NEWLINE> def __cmp__ ( self , obj ) : <NEWLINE> if type ( obj ) == type ( 0 ) : <NEWLINE> <INDENT> return cmp ( self . id , obj ) <NEWLINE> else : <NEWLINE> return cmp ( self . id , obj . id ) <NEWLINE> <DEDENT> def __hash__ ( self ) : <NEWLINE> return self . id <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''"]}, "err_obj": {"msg": "expected an indented block"}}], ["b32ed7596a68147cacd2f1b64044e6b2", {"code_string": "def save_image(img, quality, format, ContentType, Key, Bucket):\n    Metadata = {'width': str(img.size[0]), 'height', str(img.size[1]), 'format': img.format, 'mode': img.mode}\n    object = s3.Object(Bucket, Key)\n    image_buffer = BytesIO()\n    img.save(image_buffer, quality = quality, format = format)\n    res = object.put(Body = image_buffer.getvalue(), ContentType = ContentType, Metadata = Metadata)\n    return res\n", "code_toks_joined": "def save_image ( img , quality , format , ContentType , Key , Bucket ) : <NEWLINE> <INDENT> Metadata = { <STRING> : str ( img . size [ 0 ] ) , <STRING> , str ( img . size [ 1 ] ) , <STRING> : img . format , <STRING> : img . mode } <NEWLINE> object = s3 . Object ( Bucket , Key ) <NEWLINE> image_buffer = BytesIO ( ) <NEWLINE> img . save ( image_buffer , quality = quality , format = format ) <NEWLINE> res = object . put ( Body = image_buffer . getvalue ( ) , ContentType = ContentType , Metadata = Metadata ) <NEWLINE> return res <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'width'", "'height'", "'format'", "'mode'"]}, "err_obj": {"msg": "invalid syntax"}}], ["e2e114584be3204183abddb45c4abe33", {"code_string": "def log_control_err(err_string):\n    target = open(log_file, 'a')\n    target.write(str(datetime.datetime.now()) + \":\" + err_string + '\\n')\n        target.close()\n    error_list.append(err_string)\n", "code_toks_joined": "def log_control_err ( err_string ) : <NEWLINE> <INDENT> target = open ( log_file , <STRING> ) <NEWLINE> target . write ( str ( datetime . datetime . now ( ) ) + <STRING> + err_string + <STRING> ) <NEWLINE> <INDENT> target . close ( ) <NEWLINE> <DEDENT> error_list . append ( err_string ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'a'", "\":\"", "'\\n'"]}, "err_obj": {"msg": "unexpected indent"}}], ["479f55a7f4b67ec02eb23b55a8121c00", {"code_string": "def test_set_boot_device_persistent_true(self, get_ilo_object_mock):\n    ilo_mock = get_ilo_object_mock.return_value\n    with task_manager.acquire(self.context, self.node.uuid,\n        shared = False) as task:\n        task.driver.management.set_boot_device(task, boot_devices.PXE,\n            True)\n            get_ilo_object_mock.assert_called_once_with(task.node)\n            ilo_mock.update_persistent_boot.assert_called_once_with(\n            ['NETWORK'])\n", "code_toks_joined": "def test_set_boot_device_persistent_true ( self , get_ilo_object_mock ) : <NEWLINE> <INDENT> ilo_mock = get_ilo_object_mock . return_value <NEWLINE> with task_manager . acquire ( self . context , self . node . uuid , <NEWLINE> <INDENT> shared = False ) as task : <NEWLINE> task . driver . management . set_boot_device ( task , boot_devices . PXE , <NEWLINE> <INDENT> True ) <NEWLINE> get_ilo_object_mock . assert_called_once_with ( task . node ) <NEWLINE> ilo_mock . update_persistent_boot . assert_called_once_with ( <NEWLINE> [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'NETWORK'"]}, "err_obj": {"msg": "unexpected indent"}}], ["92652ac2c694fed26d0430d132756389", {"code_string": "def setupUi(self, Form):\n    Form.setObjectName(_fromUtf8(\"Form\"))\n    Form.resize(559, 113)\n    self.gridLayout = QtGui.QGridLayout(Form)\n    self.gridLayout.setContentsMargins(8, 4, 8, 0)\n    self.gridLayout.setSpacing(4)\n    self.gridLayout.setObjectName(_fromUtf8(\"gridLayout\"))\n    self.l_result = QtGui.QLabel(Form)\n    sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Preferred)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(self.l_result.sizePolicy().hasHeightForWidth())\n    self.l_result.setSizePolicy(sizePolicy)\n    self.l_result.setText(_fromUtf8(\"\"))\n    self.l_result.setObjectName(_fromUtf8(\"l_result\"))\n    self.gridLayout.addWidget(self.l_result, 2, 1, 1, 1)\n    self.frame_3 = QtGui.QFrame(Form)\n    self.frame_3.setFrameShape(QtGui.QFrame.NoFrame)\n    self.frame_3.setFrameShadow(QtGui.QFrame.Raised)\n    self.frame_3.setObjectName(_fromUtf8(\"frame_3\"))\n    self.gridLayout_4 = QtGui.QGridLayout(self.frame_3)\n    self.gridLayout_4.setMargin(0)\n    self.gridLayout_4.setSpacing(4)\n    self.gridLayout_4.setObjectName(_fromUtf8(\"gridLayout_4\"))\n    self.b_qt_designer = QtGui.QPushButton(self.frame_3)\n    self.b_qt_designer.setObjectName(_fromUtf8(\"b_qt_designer\"))\n    self.gridLayout_4.addWidget(self.b_qt_designer, 0, 3, 1, 1)\n    spacerItem = QtGui.QSpacerItem(26, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)\n    self.gridLayout_4.addItem(spacerItem, 0, 4, 1, 1)\n    self.frame = QtGui.QFrame(self.frame_3)\n    self.frame.setMinimumSize(QtCore.QSize(150, 0))\n    self.frame.setMaximumSize(QtCore.QSize(250, 16777215))\n    self.frame.setStyleSheet(_fromUtf8(\"QFrame#frame {\\n\"\n", "code_toks_joined": "def setupUi ( self , Form ) : <NEWLINE> <INDENT> Form . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> Form . resize ( 559 , 113 ) <NEWLINE> self . gridLayout = QtGui . QGridLayout ( Form ) <NEWLINE> self . gridLayout . setContentsMargins ( 8 , 4 , 8 , 0 ) <NEWLINE> self . gridLayout . setSpacing ( 4 ) <NEWLINE> self . gridLayout . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . l_result = QtGui . QLabel ( Form ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Expanding , QtGui . QSizePolicy . Preferred ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( self . l_result . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> self . l_result . setSizePolicy ( sizePolicy ) <NEWLINE> self . l_result . setText ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . l_result . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout . addWidget ( self . l_result , 2 , 1 , 1 , 1 ) <NEWLINE> self . frame_3 = QtGui . QFrame ( Form ) <NEWLINE> self . frame_3 . setFrameShape ( QtGui . QFrame . NoFrame ) <NEWLINE> self . frame_3 . setFrameShadow ( QtGui . QFrame . Raised ) <NEWLINE> self . frame_3 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_4 = QtGui . QGridLayout ( self . frame_3 ) <NEWLINE> self . gridLayout_4 . setMargin ( 0 ) <NEWLINE> self . gridLayout_4 . setSpacing ( 4 ) <NEWLINE> self . gridLayout_4 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . b_qt_designer = QtGui . QPushButton ( self . frame_3 ) <NEWLINE> self . b_qt_designer . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_4 . addWidget ( self . b_qt_designer , 0 , 3 , 1 , 1 ) <NEWLINE> spacerItem = QtGui . QSpacerItem ( 26 , 20 , QtGui . QSizePolicy . Expanding , QtGui . QSizePolicy . Minimum ) <NEWLINE> self . gridLayout_4 . addItem ( spacerItem , 0 , 4 , 1 , 1 ) <NEWLINE> self . frame = QtGui . QFrame ( self . frame_3 ) <NEWLINE> self . frame . setMinimumSize ( QtCore . QSize ( 150 , 0 ) ) <NEWLINE> self . frame . setMaximumSize ( QtCore . QSize ( 250 , 16777215 ) ) <NEWLINE> self . frame . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Form\"", "\"gridLayout\"", "\"\"", "\"l_result\"", "\"frame_3\"", "\"gridLayout_4\"", "\"b_qt_designer\"", "\"QFrame#frame {\\n\""]}, "window_span": [415, 421], "err_obj": {"msg": "unbalanced (){}[]"}}], ["4b24090bb653aa9471106bfe9e7f577e", {"code_string": "def get_authenticated_service(args):\n    flow = flow_from_clientsecrets(CLIENT_SECRETS_FILE\n        scope = YOUTUBE_UPLOAD_SCOPE,\n        message = MISSING_CLIENT_SECRETS_MESSAGE)\n    storage = Storage(\"%s-oauth2.json\" % sys.argv[0])\n    credentials = storage.get()\n    if credentials is None or credentials.invalid:\n        credentials = run_flow(flow, storage, args)\n    return build(YOUTUBE_API_SERVICE_NAME, YOUTUBE_API_VERSION,\n        http = credentials.authorize(httplib2.Http()))\n", "code_toks_joined": "def get_authenticated_service ( args ) : <NEWLINE> <INDENT> flow = flow_from_clientsecrets ( CLIENT_SECRETS_FILE <NEWLINE> <INDENT> scope = YOUTUBE_UPLOAD_SCOPE , <NEWLINE> message = MISSING_CLIENT_SECRETS_MESSAGE ) <NEWLINE> <DEDENT> storage = Storage ( <STRING> % sys . argv [ 0 ] ) <NEWLINE> credentials = storage . get ( ) <NEWLINE> if credentials is None or credentials . invalid : <NEWLINE> <INDENT> credentials = run_flow ( flow , storage , args ) <NEWLINE> <DEDENT> return build ( YOUTUBE_API_SERVICE_NAME , YOUTUBE_API_VERSION , <NEWLINE> <INDENT> http = credentials . authorize ( httplib2 . Http ( ) ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"%s-oauth2.json\""]}, "err_obj": {"msg": "invalid syntax"}}], ["458719d75e4ffb1079d2c374b7f4f6d4", {"code_string": "def fetch_template(self, template_id):\n    self.template = self.connection.call('get_template',\n        {'template_id': int(template_id)})\n    self.attributes = self.connection.call('get_template_attributes'\n        {'template_id': int(template_id)})\n    for a in self.attributes:\n        self.attr_name_map[a.name] = a\n", "code_toks_joined": "def fetch_template ( self , template_id ) : <NEWLINE> <INDENT> self . template = self . connection . call ( <STRING> , <NEWLINE> <INDENT> { <STRING> : int ( template_id ) } ) <NEWLINE> <DEDENT> self . attributes = self . connection . call ( <STRING> <NEWLINE> <INDENT> { <STRING> : int ( template_id ) } ) <NEWLINE> <DEDENT> for a in self . attributes : <NEWLINE> <INDENT> self . attr_name_map [ a . name ] = a <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'get_template'", "'template_id'", "'get_template_attributes'", "'template_id'"]}, "err_obj": {"msg": "invalid syntax"}}], ["65af90913d48e3e0dbfd639867ebfbe1", {"code_string": "def check_for_sms_sent_file(NOTIFICATION_ELASPED_TIME_HOURS, reservoir_level):\n    try:\n        last_touched_in_secs_since_epoch = subprocess.Popen([\"stat\", \"-c\", \"%Y\", \"Scripts/sent-reservoir-sms\"], stdout = subprocess.PIPE).communicate()[0]\n        now_in_secs_since_epoch = subprocess.Popen([\"printf '%(%s)T\\n' -1\"], stdout = subprocess.PIPE).communicate()[0]\n        elapsed_secs = now_in_secs_since_epoch - last_touched_in_secs_since_epoch\n        if elapsed_secs >=(NOTIFICATION_ELASPED_TIME_HOURS * 3600):\n            send_reservoir_sms(reservoir_level)\n            update_reservoir_sent_file\n        else\n            print('not enough time has elapsed')\n    except:\n        send_reservoir_sms(reservoir_level)\n        update_reservoir_sent_file\n", "code_toks_joined": "def check_for_sms_sent_file ( NOTIFICATION_ELASPED_TIME_HOURS , reservoir_level ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> last_touched_in_secs_since_epoch = subprocess . Popen ( [ <STRING> , <STRING> , <STRING> , <STRING> ] , stdout = subprocess . PIPE ) . communicate ( ) [ 0 ] <NEWLINE> now_in_secs_since_epoch = subprocess . Popen ( [ <STRING> ] , stdout = subprocess . PIPE ) . communicate ( ) [ 0 ] <NEWLINE> elapsed_secs = now_in_secs_since_epoch - last_touched_in_secs_since_epoch <NEWLINE> if elapsed_secs >= ( NOTIFICATION_ELASPED_TIME_HOURS * 3600 ) : <NEWLINE> <INDENT> send_reservoir_sms ( reservoir_level ) <NEWLINE> update_reservoir_sent_file <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> send_reservoir_sms ( reservoir_level ) <NEWLINE> update_reservoir_sent_file <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"stat\"", "\"-c\"", "\"%Y\"", "\"Scripts/sent-reservoir-sms\"", "\"printf '%(%s)T\\n' -1\"", "'not enough time has elapsed'"]}, "err_obj": {"msg": "invalid syntax"}}], ["31824b4a97aef2f226118a86fb18cf8c", {"code_string": "def can_merge(self):\n    if self.basename != 'avconv':\n        return True\n    required_version = '10-0'\n    if is_outdated_version(\n        self._versions[self.basename], required_version):\n        warning = ('Your copy of %s is outdated and unable to properly mux separate video and audio files, '\n            'youtube-dl will download single file media. '\n            'Update %s to version %s or newer to fix this.') %(\n                self.basename, self.basename, required_version)\n                if self._downloader:\n        self._downloader.report_warning(warning)\n        return False\n    return True\n", "code_toks_joined": "def can_merge ( self ) : <NEWLINE> <INDENT> if self . basename != <STRING> : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> required_version = <STRING> <NEWLINE> if is_outdated_version ( <NEWLINE> <INDENT> self . _versions [ self . basename ] , required_version ) : <NEWLINE> warning = ( <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> ) % ( <NEWLINE> <INDENT> self . basename , self . basename , required_version ) <NEWLINE> if self . _downloader : <NEWLINE> <DEDENT> <DEDENT> self . _downloader . report_warning ( warning ) <NEWLINE> return False <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'avconv'", "'10-0'", "'Your copy of %s is outdated and unable to properly mux separate video and audio files, '", "'youtube-dl will download single file media. '", "'Update %s to version %s or newer to fix this.'"]}, "err_obj": {"msg": "unexpected indent"}}], ["2f4a5bca95c1554cc5351c6f4185c954", {"code_string": "def _validate_one_email(request, cleaned_data, email, errors):\n    \"\"\"validate one email.\"\"\"\n    if cleaned_data[email]:\n        user = player_mgr.get_user_by_email(cleaned_data[email].lower()))\n        if user == None or user == request.user:\n            errors[email] = ErrorList([\"Invalid email.Please input only one valid email.\"])\n            del cleaned_data[email]\n", "code_toks_joined": "def _validate_one_email ( request , cleaned_data , email , errors ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if cleaned_data [ email ] : <NEWLINE> <INDENT> user = player_mgr . get_user_by_email ( cleaned_data [ email ] . lower ( ) ) ) <NEWLINE> if user == None or user == request . user : <NEWLINE> <INDENT> errors [ email ] = ErrorList ( [ <STRING> ] ) <NEWLINE> del cleaned_data [ email ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"validate one email.\"\"\"", "\"Invalid email.Please input only one valid email.\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["141699a271329f4000d112a9456d77d3", {"code_string": "def test_create_fails_if_configuration_is_not_provided(self):\n    r = Runner(options = {})\n    with mock.patch.multiple('littlechef_rackspace.runner',\n        abort = self.abort):\n        with self.assertRaises(AbortException):\n        r.main([\"create\"])\n        self.abort.assert_any_call(FailureMessages.NEED_API_KEY)\n", "code_toks_joined": "def test_create_fails_if_configuration_is_not_provided ( self ) : <NEWLINE> <INDENT> r = Runner ( options = { } ) <NEWLINE> with mock . patch . multiple ( <STRING> , <NEWLINE> <INDENT> abort = self . abort ) : <NEWLINE> with self . assertRaises ( AbortException ) : <NEWLINE> r . main ( [ <STRING> ] ) <NEWLINE> self . abort . assert_any_call ( FailureMessages . NEED_API_KEY ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'littlechef_rackspace.runner'", "\"create\""]}, "err_obj": {"msg": "expected an indented block"}}], ["253001c0927f39c11c90b4b52ca296a8", {"code_string": "def check_process(process):\n    import re\n    import subprocess\n    returnprocess = False\n    s = subprocess.Popen([\"ps\", \"ax\"], stdout = subprocess.PIPE)\n    for x in s.stdout:\n        if re.search(process, x):\n            returnprocess = True\n            if retornoprocesso == False:\n            print('no process executing')\n            if retornoprocesso == True:\n            print('process executing')\n", "code_toks_joined": "def check_process ( process ) : <NEWLINE> <INDENT> import re <NEWLINE> import subprocess <NEWLINE> returnprocess = False <NEWLINE> s = subprocess . Popen ( [ <STRING> , <STRING> ] , stdout = subprocess . PIPE ) <NEWLINE> for x in s . stdout : <NEWLINE> <INDENT> if re . search ( process , x ) : <NEWLINE> <INDENT> returnprocess = True <NEWLINE> if retornoprocesso == False : <NEWLINE> print ( <STRING> ) <NEWLINE> if retornoprocesso == True : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"ps\"", "\"ax\"", "'no process executing'", "'process executing'"]}, "err_obj": {"msg": "expected an indented block"}}], ["9e5014fd6b2ccaa16ca31b6825ba4c48", {"code_string": "def drawTickMarks(self):\n    canvas = self.components.canvas\n    x = self.tickXBase\n    while x < canvas.size[0]:\n        canvas.drawLine((x, canvas.size[1] - 1), (x, canvas.size[1] - 10)\n        x += self.tickWidth\n", "code_toks_joined": "def drawTickMarks ( self ) : <NEWLINE> <INDENT> canvas = self . components . canvas <NEWLINE> x = self . tickXBase <NEWLINE> while x < canvas . size [ 0 ] : <NEWLINE> <INDENT> canvas . drawLine ( ( x , canvas . size [ 1 ] - 1 ) , ( x , canvas . size [ 1 ] - 10 ) <NEWLINE> x += self . tickWidth <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["279ed9f6acb4a4916ff4ddaf151755fa", {"code_string": "def on_welcome(self, c, e):\n    self.connection.privmsg(\"maintcont\",\n        \"workerjoin %s.%s %s\"\n        %(site.language(), site.family.name, str(ver))\n", "code_toks_joined": "def on_welcome ( self , c , e ) : <NEWLINE> <INDENT> self . connection . privmsg ( <STRING> , <NEWLINE> <INDENT> <STRING> <NEWLINE> % ( site . language ( ) , site . family . name , str ( ver ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"maintcont\"", "\"workerjoin %s.%s %s\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["9d2297f9ac289c531d5ea2d6ff164b13", {"code_string": "def main():\n    if len(sys.argv) < 2:\n        print(('Usage: %s <path_to_nodes_txt>' % sys.argv[0]), file = sys.stderr)\n        exit(1)\n    g = sys.stdout\n    indir = sys.argv[1]\n    g.write('#ifndef H_CHAINPARAMSSEEDS\\n')\n    g.write('#define H_CHAINPARAMSSEEDS\\n')\n    g.write('// List of fixed seed nodes for the darksilk network\\n')\n    g.write('// AUTOGENERATED by contrib/devtools/generate-seeds.py\\n\\n')\n    g.write('// Each line contains a 16-byte IPv6 address and a port.\\n')\n    g.write('// IPv4 as well as onion addresses are wrapped inside a IPv6 address accordingly.\\n')\n    with open(os.path.join(indir, 'nodes_main.txt'), 'r') as f:\n        process_nodes(g, f, 'pnSeed6_main', 31000\n", "code_toks_joined": "def main ( ) : <NEWLINE> <INDENT> if len ( sys . argv ) < 2 : <NEWLINE> <INDENT> print ( ( <STRING> % sys . argv [ 0 ] ) , file = sys . stderr ) <NEWLINE> exit ( 1 ) <NEWLINE> <DEDENT> g = sys . stdout <NEWLINE> indir = sys . argv [ 1 ] <NEWLINE> g . write ( <STRING> ) <NEWLINE> g . write ( <STRING> ) <NEWLINE> g . write ( <STRING> ) <NEWLINE> g . write ( <STRING> ) <NEWLINE> g . write ( <STRING> ) <NEWLINE> g . write ( <STRING> ) <NEWLINE> with open ( os . path . join ( indir , <STRING> ) , <STRING> ) as f : <NEWLINE> <INDENT> process_nodes ( g , f , <STRING> , 31000 <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Usage: %s <path_to_nodes_txt>'", "'#ifndef H_CHAINPARAMSSEEDS\\n'", "'#define H_CHAINPARAMSSEEDS\\n'", "'// List of fixed seed nodes for the darksilk network\\n'", "'// AUTOGENERATED by contrib/devtools/generate-seeds.py\\n\\n'", "'// Each line contains a 16-byte IPv6 address and a port.\\n'", "'// IPv4 as well as onion addresses are wrapped inside a IPv6 address accordingly.\\n'", "'nodes_main.txt'", "'r'", "'pnSeed6_main'"]}, "window_span": [124, 135], "err_obj": {"msg": "unbalanced (){}[]"}}], ["d3d836e999d9a4921a5a1654bccfe66e", {"code_string": "def test_random():\n    \"\"\"Should work with random values.\"\"\"\n    for i in range(40):\n        moves = []\n        for i in range(random.randint(3, 50):\n            moves.append(random.choice(opts))\n        assert street_fighter_selection(fighters, (0, 0), moves) == my_street_fighter_selection(fighters, (0, 0), moves)\n", "code_toks_joined": "def test_random ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for i in range ( 40 ) : <NEWLINE> <INDENT> moves = [ ] <NEWLINE> for i in range ( random . randint ( 3 , 50 ) : <NEWLINE> <INDENT> moves . append ( random . choice ( opts ) ) <NEWLINE> <DEDENT> assert street_fighter_selection ( fighters , ( 0 , 0 ) , moves ) == my_street_fighter_selection ( fighters , ( 0 , 0 ) , moves ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Should work with random values.\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["ac765fcc4a2ba3427dfa2d45e650cf02", {"code_string": "def event_room_message(bot, (message, room, nick)):\n    text = message.getBody()\n    if message.getType() == 'groupchat' and text and nick in bot.roster[room]:\n        addseen(bot, room, nick, bot.roster[room][nick][ROSTER_JID], 'message', text)\n", "code_toks_joined": "def event_room_message ( bot , ( message , room , nick ) ) : <NEWLINE> <INDENT> text = message . getBody ( ) <NEWLINE> if message . getType ( ) == <STRING> and text and nick in bot . roster [ room ] : <NEWLINE> <INDENT> addseen ( bot , room , nick , bot . roster [ room ] [ nick ] [ ROSTER_JID ] , <STRING> , text ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'groupchat'", "'message'"]}, "err_obj": {"msg": "invalid syntax"}}], ["28697822bea58e56b79a56f885dffcc7", {"code_string": "def ConfigSectionMap(section):\n    dict1 = {}\n    options = Config.options(section)\n    for option in options:\n    try:\n    dict1[option] = Config.get(section, option)\n    if dict1[option] == - 1:\n        DebugPrint(\"skip: %s\" % option)\n        except:\n    print(\"exception on %s!\" % option)\n    dict1[option] = None\n    return dict1\n", "code_toks_joined": "def ConfigSectionMap ( section ) : <NEWLINE> <INDENT> dict1 = { } <NEWLINE> options = Config . options ( section ) <NEWLINE> for option in options : <NEWLINE> try : <NEWLINE> dict1 [ option ] = Config . get ( section , option ) <NEWLINE> if dict1 [ option ] == - 1 : <NEWLINE> <INDENT> DebugPrint ( <STRING> % option ) <NEWLINE> except : <NEWLINE> <DEDENT> print ( <STRING> % option ) <NEWLINE> dict1 [ option ] = None <NEWLINE> return dict1 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"skip: %s\"", "\"exception on %s!\""]}, "err_obj": {"msg": "expected an indented block"}}], ["a4995dfc25206382be2b93a63686de7c", {"code_string": "class ChattyKathyBot(irc.IRCClientt):\n    def connectionMade(self):\n        self.nickname = self.factory.nickname\n        self.realname = self.factory.realname\n        irc.IRCClient.connectionMade(self)\n        log.msg(\"connectionMade\")\n    def connectionLost(self, reason):\n        irc.IRCClient.connectionLost(self, reason)\n        log.msg(\"connectionLost {!r}\".format(reason))\n    def signedOn(self):\n        log.msg(\"Signed on\")\n        if(self.nickname != self.factory.nickname:\n            log.msg('Your nickname was already occupied, actual nickname is ' '\"{}.'.format(self, nickname))\n        self.join(self.factory.channel)\n    def joined(self, channel):\n        log.msg(\"[{nick} has joined {channel}]\".format(nick = self.nickname, channel = self.factory.channel, ))\n", "code_toks_joined": "class ChattyKathyBot ( irc . IRCClientt ) : <NEWLINE> <INDENT> def connectionMade ( self ) : <NEWLINE> <INDENT> self . nickname = self . factory . nickname <NEWLINE> self . realname = self . factory . realname <NEWLINE> irc . IRCClient . connectionMade ( self ) <NEWLINE> log . msg ( <STRING> ) <NEWLINE> <DEDENT> def connectionLost ( self , reason ) : <NEWLINE> <INDENT> irc . IRCClient . connectionLost ( self , reason ) <NEWLINE> log . msg ( <STRING> . format ( reason ) ) <NEWLINE> <DEDENT> def signedOn ( self ) : <NEWLINE> <INDENT> log . msg ( <STRING> ) <NEWLINE> if ( self . nickname != self . factory . nickname : <NEWLINE> <INDENT> log . msg ( <STRING> <STRING> . format ( self , nickname ) ) <NEWLINE> <DEDENT> self . join ( self . factory . channel ) <NEWLINE> <DEDENT> def joined ( self , channel ) : <NEWLINE> <INDENT> log . msg ( <STRING> . format ( nick = self . nickname , channel = self . factory . channel , ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"connectionMade\"", "\"connectionLost {!r}\"", "\"Signed on\"", "'Your nickname was already occupied, actual nickname is '", "'\"{}.'", "\"[{nick} has joined {channel}]\""]}, "window_span": [105, 183], "err_obj": {"msg": "unbalanced (){}[]"}}], ["f9d46f7209ffcfcdd6053e2369ef62de", {"code_string": "def calcNearestNeighbours(prefs, n = 10):\n    neighbours = {}\n    c = 0\n    for item in prefs:\n        c += 1\n        if c % 100 == 0: print \"%d / %d\" %(c, len(prefs))\n        scoreAndItem = topMatches(prefs, item, n = n, similarity = sim_distance)\n        neighbours[item] = scoreAndItem\n    return neighbours\n", "code_toks_joined": "def calcNearestNeighbours ( prefs , n = 10 ) : <NEWLINE> <INDENT> neighbours = { } <NEWLINE> c = 0 <NEWLINE> for item in prefs : <NEWLINE> <INDENT> c += 1 <NEWLINE> if c % 100 == 0 : print <STRING> % ( c , len ( prefs ) ) <NEWLINE> scoreAndItem = topMatches ( prefs , item , n = n , similarity = sim_distance ) <NEWLINE> neighbours [ item ] = scoreAndItem <NEWLINE> <DEDENT> return neighbours <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"%d / %d\""]}, "err_obj": {"msg": "invalid syntax"}}], ["4bfbd546e14f7ecc386bf2a2630c19a3", {"code_string": "def Flush(self, loops = 50, wait = False, allow_blocking = False):\n    while(loops != 0 and\n        len(self.write_blocked) > 0 and\n        self.Send([], try_flush = True, activity = False,\n            allow_blocking = allow_blocking)):\n            if wait and len(self.write_blocked) > 0:\n            time.sleep(0.1)\n            logging.LogDebug('Flushing...')\n            loops -= 1\n    if self.write_blocked: return False\n    return True\n", "code_toks_joined": "def Flush ( self , loops = 50 , wait = False , allow_blocking = False ) : <NEWLINE> <INDENT> while ( loops != 0 and <NEWLINE> <INDENT> len ( self . write_blocked ) > 0 and <NEWLINE> self . Send ( [ ] , try_flush = True , activity = False , <NEWLINE> <INDENT> allow_blocking = allow_blocking ) ) : <NEWLINE> if wait and len ( self . write_blocked ) > 0 : <NEWLINE> time . sleep ( 0.1 ) <NEWLINE> logging . LogDebug ( <STRING> ) <NEWLINE> loops -= 1 <NEWLINE> <DEDENT> <DEDENT> if self . write_blocked : return False <NEWLINE> return True <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Flushing...'"]}, "err_obj": {"msg": "expected an indented block"}}], ["d76ce105e59880c0c4d4e58b1827532e", {"code_string": "def test_disallowed_relativities(self):\n    for relativity in DISALLOWED_RELATIVITIES:\n        for following_lines in[[], ['following line']]:\n            with self.subTest(relativity = str(relativity),\n                following_lines = repr(following_lines)):\n                option_conf = conf_rel_any(relativity)\n                source = remaining_source('{rel_opt} file-name <<MARKER'.format(rel_opt = option_conf.option_string),\n                    ['MARKER'] + following_lines)\n                    with self.assertRaises(SingleInstructionInvalidArgumentException):\n                    _just_parse(source)\n", "code_toks_joined": "def test_disallowed_relativities ( self ) : <NEWLINE> <INDENT> for relativity in DISALLOWED_RELATIVITIES : <NEWLINE> <INDENT> for following_lines in [ [ ] , [ <STRING> ] ] : <NEWLINE> <INDENT> with self . subTest ( relativity = str ( relativity ) , <NEWLINE> <INDENT> following_lines = repr ( following_lines ) ) : <NEWLINE> option_conf = conf_rel_any ( relativity ) <NEWLINE> source = remaining_source ( <STRING> . format ( rel_opt = option_conf . option_string ) , <NEWLINE> <INDENT> [ <STRING> ] + following_lines ) <NEWLINE> with self . assertRaises ( SingleInstructionInvalidArgumentException ) : <NEWLINE> _just_parse ( source ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'following line'", "'{rel_opt} file-name <<MARKER'", "'MARKER'"]}, "err_obj": {"msg": "unexpected indent"}}], ["0f75b45f06f8e3280bb0ae9fdd61338b", {"code_string": "def __init__(self, activity):\n    try:\n        assert(IActivity.providedBy(activity))\n    except AssertionError:\n        raise ActivityRuntimeError, \" ActivityRuntime must be initialized with an Activity instance\"\n    self.activity = activity\n    self.token_pool = TokenPool()\n", "code_toks_joined": "def __init__ ( self , activity ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> assert ( IActivity . providedBy ( activity ) ) <NEWLINE> <DEDENT> except AssertionError : <NEWLINE> <INDENT> raise ActivityRuntimeError , <STRING> <NEWLINE> <DEDENT> self . activity = activity <NEWLINE> self . token_pool = TokenPool ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\" ActivityRuntime must be initialized with an Activity instance\""]}, "err_obj": {"msg": "invalid syntax"}}], ["fc95d79e5bcc538d7b3574f65770558e", {"code_string": "def fetch(self, filename, forceBundle = False, conjunct = False):\n    \"\"\"request a local copy of a file on a file server.\"\"\"\n    filename = os.path.realpath(filename)\n    if not self.isConnected():\n    return filename, False\n    try:\n    if forceBundle or self._isBundleFile(filename):\n    f, r = self._fetchBundle(filename, conjunct)\n    else:\n    f, r = self._fetchFile(filename)\n    return f, (r == 0)\n    except Exception, e:\n    error(\"unknown error: %s\" % str(e))\n    return filename, False\n", "code_toks_joined": "def fetch ( self , filename , forceBundle = False , conjunct = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> filename = os . path . realpath ( filename ) <NEWLINE> if not self . isConnected ( ) : <NEWLINE> return filename , False <NEWLINE> try : <NEWLINE> if forceBundle or self . _isBundleFile ( filename ) : <NEWLINE> f , r = self . _fetchBundle ( filename , conjunct ) <NEWLINE> else : <NEWLINE> f , r = self . _fetchFile ( filename ) <NEWLINE> return f , ( r == 0 ) <NEWLINE> except Exception , e : <NEWLINE> error ( <STRING> % str ( e ) ) <NEWLINE> return filename , False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"request a local copy of a file on a file server.\"\"\"", "\"unknown error: %s\""]}, "err_obj": {"msg": "expected an indented block"}}], ["7290d79a8f9bcb323ba0174d4fe82818", {"code_string": "def test_float__format__locale(self):\n    for i in range(- 10, 10)\n        x = 1234567890.0 *(10.0 ** i)\n        self.assertEqual(locale.format('%g', x, grouping = True), format(x, 'n'))\n        self.assertEqual(locale.format('%.10g', x, grouping = True), format(x, '.10n'))\n", "code_toks_joined": "def test_float__format__locale ( self ) : <NEWLINE> <INDENT> for i in range ( - 10 , 10 ) <NEWLINE> <INDENT> x = 1234567890.0 * ( 10.0 ** i ) <NEWLINE> self . assertEqual ( locale . format ( <STRING> , x , grouping = True ) , format ( x , <STRING> ) ) <NEWLINE> self . assertEqual ( locale . format ( <STRING> , x , grouping = True ) , format ( x , <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'%g'", "'n'", "'%.10g'", "'.10n'"]}, "err_obj": {"msg": "invalid syntax"}}], ["b070638a36fb0f95ac0084b5e27e9f1d", {"code_string": "def test_get_property_success(self):\n    value = \"propertyBody\"\n    with patch('org.o3project.odenos.core.util.remote_object_interface.'\n        'RemoteObjectInterface._get_object_to_remote_object',\n        return_value = Response(Response.StatusCode.OK, value)\n        ) as m_get_object:\n        self.result = self.target.get_property()\n        self.assertEqual(m_get_object.call_count, 1)\n        self.assertEqual(m_get_object.call_args[0][0],\n            RemoteObjectInterface.PROPETY_PATH)\n            self.assertNotEqual(self.result, None)\n", "code_toks_joined": "def test_get_property_success ( self ) : <NEWLINE> <INDENT> value = <STRING> <NEWLINE> with patch ( <STRING> <NEWLINE> <INDENT> <STRING> , <NEWLINE> return_value = Response ( Response . StatusCode . OK , value ) <NEWLINE> ) as m_get_object : <NEWLINE> self . result = self . target . get_property ( ) <NEWLINE> self . assertEqual ( m_get_object . call_count , 1 ) <NEWLINE> self . assertEqual ( m_get_object . call_args [ 0 ] [ 0 ] , <NEWLINE> <INDENT> RemoteObjectInterface . PROPETY_PATH ) <NEWLINE> self . assertNotEqual ( self . result , None ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"propertyBody\"", "'org.o3project.odenos.core.util.remote_object_interface.'", "'RemoteObjectInterface._get_object_to_remote_object'"]}, "err_obj": {"msg": "unexpected indent"}}], ["ab3558af9d91bc1db2db95ff99e32e21", {"code_string": "def parseSubtitlePage(self, url, lang, show, season, episode, teams):\n    fteams = []\n    for team in teams:\n        fteams += team.split(\"-\")\n    fteams = set(fteams)\n    subid = url.rsplit(\"-\", 1)[1].split('.', 1)[0]\n    link = self.host + \"/download-\" + subid + \".html\"\n    page = urllib.request.urlopen(url)\n    content = page.read()\n    content = content.replace(\"SCR'+'IPT\", \"script\")\n    soup = BeautifulSoup.BeautifulSoup(content)\n    subteams = set()\n    releases = soup.findAll(text = \"release:\")\n    if releases:\n        subteams.update([releases[0].parent.parent.parent.parent.findAll(\"td\")[2].string.lower()])\n    rips = soup.findAll(text = \"rip:\")\n    if rips:\n        subteams.update([rips[0].parent.parent.parent.parent.findAll(\"td\")[2].string.lower()])\n    if subteams.issubset(fteams):\n        logging.debug(\"It'a match ! : %s <= %s\" %(subteams, fteams))\n        result = {}\n        result[\"release\"] = \"%s.S%.2dE%.2d.%s\" %(show.replace(\" \", \".\").title(), int(season), int(episode), '.'.join(subteams).upper()\n", "code_toks_joined": "def parseSubtitlePage ( self , url , lang , show , season , episode , teams ) : <NEWLINE> <INDENT> fteams = [ ] <NEWLINE> for team in teams : <NEWLINE> <INDENT> fteams += team . split ( <STRING> ) <NEWLINE> <DEDENT> fteams = set ( fteams ) <NEWLINE> subid = url . rsplit ( <STRING> , 1 ) [ 1 ] . split ( <STRING> , 1 ) [ 0 ] <NEWLINE> link = self . host + <STRING> + subid + <STRING> <NEWLINE> page = urllib . request . urlopen ( url ) <NEWLINE> content = page . read ( ) <NEWLINE> content = content . replace ( <STRING> , <STRING> ) <NEWLINE> soup = BeautifulSoup . BeautifulSoup ( content ) <NEWLINE> subteams = set ( ) <NEWLINE> releases = soup . findAll ( text = <STRING> ) <NEWLINE> if releases : <NEWLINE> <INDENT> subteams . update ( [ releases [ 0 ] . parent . parent . parent . parent . findAll ( <STRING> ) [ 2 ] . string . lower ( ) ] ) <NEWLINE> <DEDENT> rips = soup . findAll ( text = <STRING> ) <NEWLINE> if rips : <NEWLINE> <INDENT> subteams . update ( [ rips [ 0 ] . parent . parent . parent . parent . findAll ( <STRING> ) [ 2 ] . string . lower ( ) ] ) <NEWLINE> <DEDENT> if subteams . issubset ( fteams ) : <NEWLINE> <INDENT> logging . debug ( <STRING> % ( subteams , fteams ) ) <NEWLINE> result = { } <NEWLINE> result [ <STRING> ] = <STRING> % ( show . replace ( <STRING> , <STRING> ) . title ( ) , int ( season ) , int ( episode ) , <STRING> . join ( subteams ) . upper ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"-\"", "\"-\"", "'.'", "\"/download-\"", "\".html\"", "\"SCR'+'IPT\"", "\"script\"", "\"release:\"", "\"td\"", "\"rip:\"", "\"td\"", "\"It'a match ! : %s <= %s\"", "\"release\"", "\"%s.S%.2dE%.2d.%s\"", "\" \"", "\".\"", "'.'"]}, "window_span": [267, 304], "err_obj": {"msg": "unbalanced (){}[]"}}], ["077de67081bcf80255e721ce8b9d017a", {"code_string": "def client_opened(self):\n    piw.client.client_opened(self)\n    if self.__sink:\n        piw.client.set_sink(self, self.__sink)\n    if self.__initial:\n        piw.client.client_data(self, self.get_data()))\n", "code_toks_joined": "def client_opened ( self ) : <NEWLINE> <INDENT> piw . client . client_opened ( self ) <NEWLINE> if self . __sink : <NEWLINE> <INDENT> piw . client . set_sink ( self , self . __sink ) <NEWLINE> <DEDENT> if self . __initial : <NEWLINE> <INDENT> piw . client . client_data ( self , self . get_data ( ) ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["fdd295bea88ccda5bc21cb57379339fc", {"code_string": "def cleardb(host, dbname, user, password):\n    ConnectionString = \"dbname=\" + dbname + \" user=\" + user + \" host=\" + host + \" password=\" + password\n    try:\n    conn = psycopg2.connect(ConnectionString)\n    except:\n    print('I am unable to connect to the database                  ')\n        print(ConnectionString)\n        return 0\n        cur = conn.cursor()\n        sql = '''DROP TABLE IF EXISTS planet_osm_buildings \tCASCADE;'''\n        cur.execute(sql)\n        conn.commit()\n", "code_toks_joined": "def cleardb ( host , dbname , user , password ) : <NEWLINE> <INDENT> ConnectionString = <STRING> + dbname + <STRING> + user + <STRING> + host + <STRING> + password <NEWLINE> try : <NEWLINE> conn = psycopg2 . connect ( ConnectionString ) <NEWLINE> except : <NEWLINE> print ( <STRING> ) <NEWLINE> <INDENT> print ( ConnectionString ) <NEWLINE> return 0 <NEWLINE> cur = conn . cursor ( ) <NEWLINE> sql = <STRING> <NEWLINE> cur . execute ( sql ) <NEWLINE> conn . commit ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"dbname=\"", "\" user=\"", "\" host=\"", "\" password=\"", "'I am unable to connect to the database                  '", "'''DROP TABLE IF EXISTS planet_osm_buildings \tCASCADE;'''"]}, "err_obj": {"msg": "expected an indented block"}}], ["647384b1b78d516938ae0bb591c7f4bc", {"code_string": "class Solution(object):\n    def arrayPairSum(self, nums):\n        \"\"\":type nums: List[int]\"\"\"\n        return sum(sorted(nums)[: : 2)\n", "code_toks_joined": "class Solution ( object ) : <NEWLINE> <INDENT> def arrayPairSum ( self , nums ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return sum ( sorted ( nums ) [ : : 2 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\":type nums: List[int]\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["46e1d519b427e59288843de8c79a48bf", {"code_string": "def getIntersectDropController(self, x, y):\n    Location location = CoordinateLocation(x, y)\n    for int i = sortedCandidates.length - 1; i >= 0; i - -:\n        Candidate candidate = sortedCandidates[i]\n        Area targetArea = candidate.getTargetArea()\n        if targetArea.intersects(location):\n            return candidate.getDropController()\n    return None\n", "code_toks_joined": "def getIntersectDropController ( self , x , y ) : <NEWLINE> <INDENT> Location location = CoordinateLocation ( x , y ) <NEWLINE> for int i = sortedCandidates . length - 1 ; i >= 0 ; i - - : <NEWLINE> <INDENT> Candidate candidate = sortedCandidates [ i ] <NEWLINE> Area targetArea = candidate . getTargetArea ( ) <NEWLINE> if targetArea . intersects ( location ) : <NEWLINE> <INDENT> return candidate . getDropController ( ) <NEWLINE> <DEDENT> <DEDENT> return None <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["a186b987e074d3c687372009b1651cc9", {"code_string": "def _invoke(self, event):\n    cmd = self['command']\n    if callable(cmd):\n    cmd()\n", "code_toks_joined": "def _invoke ( self , event ) : <NEWLINE> <INDENT> cmd = self [ <STRING> ] <NEWLINE> if callable ( cmd ) : <NEWLINE> cmd ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'command'"]}, "err_obj": {"msg": "expected an indented block"}}], ["7db39b7040c44588413cffd04e02be82", {"code_string": "def testCleanupExceptionContextException(self):\n    \"\"\"Test an exception during cleanup if the context DID raise.\"\"\"\n    was_raised = False\n    tempdir_obj = osutils.TempDir(prefix = self.PREFIX)\n    with mock.patch.object(osutils, '_TempDirTearDown',\n        side_effect = TempDirTests.HelperException):\n        try:\n        with tempdir_obj as td:\n        tempdir = td\n        raise TempDirTests.HelperExceptionInner()\n        except TempDirTests.HelperExceptionInner:\n        was_raised = True\n    self.assertTrue(was_raised)\n    self.assertIsNone(tempdir_obj.tempdir)\n    os.rmdir(tempdir)\n", "code_toks_joined": "def testCleanupExceptionContextException ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> was_raised = False <NEWLINE> tempdir_obj = osutils . TempDir ( prefix = self . PREFIX ) <NEWLINE> with mock . patch . object ( osutils , <STRING> , <NEWLINE> <INDENT> side_effect = TempDirTests . HelperException ) : <NEWLINE> try : <NEWLINE> with tempdir_obj as td : <NEWLINE> tempdir = td <NEWLINE> raise TempDirTests . HelperExceptionInner ( ) <NEWLINE> except TempDirTests . HelperExceptionInner : <NEWLINE> was_raised = True <NEWLINE> <DEDENT> self . assertTrue ( was_raised ) <NEWLINE> self . assertIsNone ( tempdir_obj . tempdir ) <NEWLINE> os . rmdir ( tempdir ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Test an exception during cleanup if the context DID raise.\"\"\"", "'_TempDirTearDown'"]}, "err_obj": {"msg": "expected an indented block"}}], ["70701e0ff991010621134b3cc3d1d4cd", {"code_string": "def GET(url):\n    try:\n        print('def GET(%s):' % url)\n        req = urllib2.Request(url)\n            req.add_header('User-Agent', 'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.9.0.3) Gecko/2008092417 Firefox/3.0.3')\n        response = urllib2.urlopen(req)\n        http = response.read()\n        response.close()\n        return http\n    except:\n        showMessage('\u041d\u0435 \u043c\u043e\u0433\u0443 \u043e\u0442\u043a\u0440\u044b\u0442\u044c URL def GET', url)\n        return None\n", "code_toks_joined": "def GET ( url ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> print ( <STRING> % url ) <NEWLINE> req = urllib2 . Request ( url ) <NEWLINE> <INDENT> req . add_header ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> response = urllib2 . urlopen ( req ) <NEWLINE> http = response . read ( ) <NEWLINE> response . close ( ) <NEWLINE> return http <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> showMessage ( <STRING> , url ) <NEWLINE> return None <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'def GET(%s):'", "'User-Agent'", "'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.9.0.3) Gecko/2008092417 Firefox/3.0.3'", "'\u041d\u0435 \u043c\u043e\u0433\u0443 \u043e\u0442\u043a\u0440\u044b\u0442\u044c URL def GET'"]}, "err_obj": {"msg": "unexpected indent"}}], ["7d0019270fd875d9607a64084fbf7e1e", {"code_string": "def test_sandbox_provider_docker_container():\n    sandbox = DefaultSandboxProvider().from_assigned_task(\n        AssignedTask(task = TaskConfig(container = Container(docker = DockerContainer())))))\n    assert sandbox._user is None\n", "code_toks_joined": "def test_sandbox_provider_docker_container ( ) : <NEWLINE> <INDENT> sandbox = DefaultSandboxProvider ( ) . from_assigned_task ( <NEWLINE> <INDENT> AssignedTask ( task = TaskConfig ( container = Container ( docker = DockerContainer ( ) ) ) ) ) ) <NEWLINE> <DEDENT> assert sandbox . _user is None <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["6e5b6993992fb4e6e8bf4c56ac90f744", {"code_string": "def getwelcome(self):\n    \"\"\"Get the welcome message from the server\"\"\"\n    if self.debugging: print '*welcome*', repr(self.welcome)\n    return self.welcome\n", "code_toks_joined": "def getwelcome ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . debugging : print <STRING> , repr ( self . welcome ) <NEWLINE> return self . welcome <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get the welcome message from the server\"\"\"", "'*welcome*'"]}, "err_obj": {"msg": "invalid syntax"}}], ["f27a58af2143c551dc70cef00abdf1ce", {"code_string": "def buffer2file(self):\n    \"\"\"add the code buffer content to CassetteFile() instance\"\"\"\n    if self.current_file is not None and self.buffer\n        self.current_file.add_block_data(self.buffered_block_length, self.buffer)\n        self.buffer = []\n        self.buffered_block_length = 0\n", "code_toks_joined": "def buffer2file ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . current_file is not None and self . buffer <NEWLINE> <INDENT> self . current_file . add_block_data ( self . buffered_block_length , self . buffer ) <NEWLINE> self . buffer = [ ] <NEWLINE> self . buffered_block_length = 0 <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"add the code buffer content to CassetteFile() instance\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["cf0c8a9f43cc5754073e31af29eee9da", {"code_string": "def test_scheme_config_error(self):\n    \"\"\"ArcGIS.__init__ invalid scheme\"\"\"\n    with self.assertRaises(exc.ConfigurationError):\n        ArcGIS(\n            username = 'a',\n            password = 'b'\n            referer = 'http://www.example.com',\n            scheme = 'http'\n        )\n", "code_toks_joined": "def test_scheme_config_error ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with self . assertRaises ( exc . ConfigurationError ) : <NEWLINE> <INDENT> ArcGIS ( <NEWLINE> <INDENT> username = <STRING> , <NEWLINE> password = <STRING> <NEWLINE> referer = <STRING> , <NEWLINE> scheme = <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"ArcGIS.__init__ invalid scheme\"\"\"", "'a'", "'b'", "'http://www.example.com'", "'http'"]}, "err_obj": {"msg": "invalid syntax"}}], ["3ad89a3dc3f09bbd1241dc00c15522a7", {"code_string": "class CourseGrade(models.Model):\n    gp_id = models.CharField(max_length = 50)\n        course_code = models.CharField(max_length = 20)\n    personid = models.ForeignKey(Personinformation, unique = False)\n    sessionid = models.ForeignKey(Academic_session, unique = False)\n", "code_toks_joined": "class CourseGrade ( models . Model ) : <NEWLINE> <INDENT> gp_id = models . CharField ( max_length = 50 ) <NEWLINE> <INDENT> course_code = models . CharField ( max_length = 20 ) <NEWLINE> <DEDENT> personid = models . ForeignKey ( Personinformation , unique = False ) <NEWLINE> sessionid = models . ForeignKey ( Academic_session , unique = False ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["0979bd325f29af90ca8a1f7d1563822d", {"code_string": "def vacuum(api, q = False):\n    try:\n        if not q: print api.deleteAndVacuum()\n        else: api.deleteAndVacuum()\n        return\n    except Exception as e: sys.stderr.write('%s\\n' % str(e)); sys.exit(13)\n", "code_toks_joined": "def vacuum ( api , q = False ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if not q : print api . deleteAndVacuum ( ) <NEWLINE> else : api . deleteAndVacuum ( ) <NEWLINE> return <NEWLINE> <DEDENT> except Exception as e : sys . stderr . write ( <STRING> % str ( e ) ) ; sys . exit ( 13 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'%s\\n'"]}, "err_obj": {"msg": "invalid syntax"}}], ["9ee5dc1c3c7115869bd8b9921c322646", {"code_string": "def write(self bytes):\n    \"\"\"The WSGI I{write} callable returned by the I{start_response} callable.\"\"\"\n    def wsgiWrite(started):\n        if not started:\n            self._sendResponseHeaders()\n        self.request.write(bytes)\n    self.reactor.callFromThread(wsgiWrite, self.started)\n    self.started = True\n", "code_toks_joined": "def write ( self bytes ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def wsgiWrite ( started ) : <NEWLINE> <INDENT> if not started : <NEWLINE> <INDENT> self . _sendResponseHeaders ( ) <NEWLINE> <DEDENT> self . request . write ( bytes ) <NEWLINE> <DEDENT> self . reactor . callFromThread ( wsgiWrite , self . started ) <NEWLINE> self . started = True <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"The WSGI I{write} callable returned by the I{start_response} callable.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["d4b9c06509d7a548cf03e334f3f4814a", {"code_string": "class Fault(Error):\n    def __init__(this, faultCode, faultString, ** extra):\n    this.faultCode = faultCode\n    this.faultString = faultString\n    def __repr__(this):\n    return(\n        \"<Fault %s: %s>\" %\n        (this.faultCode, repr(this.faultString))\n        )\n", "code_toks_joined": "class Fault ( Error ) : <NEWLINE> <INDENT> def __init__ ( this , faultCode , faultString , ** extra ) : <NEWLINE> this . faultCode = faultCode <NEWLINE> this . faultString = faultString <NEWLINE> def __repr__ ( this ) : <NEWLINE> return ( <NEWLINE> <INDENT> <STRING> % <NEWLINE> ( this . faultCode , repr ( this . faultString ) ) <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"<Fault %s: %s>\""]}, "err_obj": {"msg": "expected an indented block"}}], ["7119e7833e15bac1251db180946ea983", {"code_string": "class AndConnect(Connecter):\n    ''' Connects two tests by a boolean AND\t'''\n    def match(self, entry):\n    ret = (self.left.match(entry) and\n    self.right.match(entry))\n    if self.neg:\n        ret = not ret\n        return ret\n    def __str__(self):\n    return \"(%s) and (%s)\" %(str(self.left), str(self.right))\n", "code_toks_joined": "class AndConnect ( Connecter ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def match ( self , entry ) : <NEWLINE> ret = ( self . left . match ( entry ) and <NEWLINE> self . right . match ( entry ) ) <NEWLINE> if self . neg : <NEWLINE> <INDENT> ret = not ret <NEWLINE> return ret <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> return <STRING> % ( str ( self . left ) , str ( self . right ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''' Connects two tests by a boolean AND\t'''", "\"(%s) and (%s)\""]}, "err_obj": {"msg": "expected an indented block"}}], ["40e1d1490cf9f34948926d5a0c59149c", {"code_string": "def execute(code):\n    exec code\n    return value\n", "code_toks_joined": "def execute ( code ) : <NEWLINE> <INDENT> exec code <NEWLINE> return value <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["eb0373a69efddd82a707ca52ac9eb320", {"code_string": "def _declare_rpc_exchange(self, exchange, timeout):\n    with(self._pika_engine.connection_without_confirmation_pool\n        .acquire(timeout = timeout)) as conn:\n        try:\n        self._pika_engine.declare_exchange_by_channel(\n            conn.channel,\n            self._pika_engine.get_rpc_exchange_name(\n                exchange\n            ), \"direct\", False\n        )\n        except pika_pool.Timeout as e:\n        raise exceptions.MessagingTimeout(\n            \"Timeout for current operation was expired. {}.\".format(\n                str(e)\n            )\n        )\n", "code_toks_joined": "def _declare_rpc_exchange ( self , exchange , timeout ) : <NEWLINE> <INDENT> with ( self . _pika_engine . connection_without_confirmation_pool <NEWLINE> <INDENT> . acquire ( timeout = timeout ) ) as conn : <NEWLINE> try : <NEWLINE> self . _pika_engine . declare_exchange_by_channel ( <NEWLINE> <INDENT> conn . channel , <NEWLINE> self . _pika_engine . get_rpc_exchange_name ( <NEWLINE> <INDENT> exchange <NEWLINE> <DEDENT> ) , <STRING> , False <NEWLINE> <DEDENT> ) <NEWLINE> except pika_pool . Timeout as e : <NEWLINE> raise exceptions . MessagingTimeout ( <NEWLINE> <INDENT> <STRING> . format ( <NEWLINE> <INDENT> str ( e ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"direct\"", "\"Timeout for current operation was expired. {}.\""]}, "err_obj": {"msg": "expected an indented block"}}], ["cb970fa9a2158bf7b2e2392cbff0a279", {"code_string": "class Datetime(Validator):\n    \"\"\"Date time validation.\"\"\"\n    def __init__(self, datetime_format):\n        \"\"\":param datetime_format: Date time format,\"\"\"\n        super(Datetime, self).__init__()\n        self._format = datetime_format\n    def validate(self, value, data):\n        import datetime\n        try:\n            datetime.datetime.strptime(value, self._format)\n        except ValueError, exc:\n            error = 'Wrong datetime with format \"%s\": %s' %(self._format, str(exc))\n            self.put_msg(error)\n            return False\n        return True\n", "code_toks_joined": "class Datetime ( Validator ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , datetime_format ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> super ( Datetime , self ) . __init__ ( ) <NEWLINE> self . _format = datetime_format <NEWLINE> <DEDENT> def validate ( self , value , data ) : <NEWLINE> <INDENT> import datetime <NEWLINE> try : <NEWLINE> <INDENT> datetime . datetime . strptime ( value , self . _format ) <NEWLINE> <DEDENT> except ValueError , exc : <NEWLINE> <INDENT> error = <STRING> % ( self . _format , str ( exc ) ) <NEWLINE> self . put_msg ( error ) <NEWLINE> return False <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Date time validation.\"\"\"", "\"\"\":param datetime_format: Date time format,\"\"\"", "'Wrong datetime with format \"%s\": %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["973f6013880e85853de10f26cec5d949", {"code_string": "def runScreen(self, arg):\n    if arg[0] != \"\":\n        exec \"from \" + arg[0] + \" import *\"\n    self.openDialog(* eval(arg[1]))\n", "code_toks_joined": "def runScreen ( self , arg ) : <NEWLINE> <INDENT> if arg [ 0 ] != <STRING> : <NEWLINE> <INDENT> exec <STRING> + arg [ 0 ] + <STRING> <NEWLINE> <DEDENT> self . openDialog ( * eval ( arg [ 1 ] ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"", "\"from \"", "\" import *\""]}, "err_obj": {"msg": "invalid syntax"}}], ["3bf1c5e3aa8935076ce63f80bb80494d", {"code_string": "def test_Tokens(self):\n    \"\"\"Test Tokens\"\"\"\n        f_tmpl = TMPLTemplate.TMPLTemplate(self.__test_filename)\n        f_tmpl.init(TMPLTemplate.__version__, [], ['tokens'], {})\n        self.assertEquals(f_tmpl._tokens, ['tokens'])\n", "code_toks_joined": "def test_Tokens ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> f_tmpl = TMPLTemplate . TMPLTemplate ( self . __test_filename ) <NEWLINE> f_tmpl . init ( TMPLTemplate . __version__ , [ ] , [ <STRING> ] , { } ) <NEWLINE> self . assertEquals ( f_tmpl . _tokens , [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Test Tokens\"\"\"", "'tokens'", "'tokens'"]}, "err_obj": {"msg": "unexpected indent"}}], ["97284fa7edd31c37ed5e8f1a8e5a8b79", {"code_string": "class Generator(object):\n    def __init__(self, cmakeName, buildDir = 'build', sourceDir = '..', binDir = 'bin'):\n        self.cmakeName = cmakeName\n            self.buildDir = buildDir\n        self.sourceDir = sourceDir\n        self.binDir = binDir\n    def getBuildDir(self, target):\n        return self.buildDir\n    def getBinDir(self, target = ''):\n        return self.binDir\n    def getSourceDir(self):\n        return self.sourceDir\n", "code_toks_joined": "class Generator ( object ) : <NEWLINE> <INDENT> def __init__ ( self , cmakeName , buildDir = <STRING> , sourceDir = <STRING> , binDir = <STRING> ) : <NEWLINE> <INDENT> self . cmakeName = cmakeName <NEWLINE> <INDENT> self . buildDir = buildDir <NEWLINE> <DEDENT> self . sourceDir = sourceDir <NEWLINE> self . binDir = binDir <NEWLINE> <DEDENT> def getBuildDir ( self , target ) : <NEWLINE> <INDENT> return self . buildDir <NEWLINE> <DEDENT> def getBinDir ( self , target = <STRING> ) : <NEWLINE> <INDENT> return self . binDir <NEWLINE> <DEDENT> def getSourceDir ( self ) : <NEWLINE> <INDENT> return self . sourceDir <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'build'", "'..'", "'bin'", "''"]}, "err_obj": {"msg": "unexpected indent"}}], ["828e6883eded70cd2d7c023ee47ddd41", {"code_string": "class FakeClientParserWithReactor(PluginBase):\n    def parseStreamClient(self, * a, ** kw)\n        return StreamClient(self, a, kw)\n", "code_toks_joined": "class FakeClientParserWithReactor ( PluginBase ) : <NEWLINE> <INDENT> def parseStreamClient ( self , * a , ** kw ) <NEWLINE> <INDENT> return StreamClient ( self , a , kw ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["0acce179a754def167320d37c70481e5", {"code_string": "def _get_storage_url(self):\n    try:\n        storage_url = self.store._get_endpoint(self.context)\n        if self.image:\n            storage_url = storage_url.replace(self.context.tenant, self.image['owner'])\n        return storage_url\n    except(exceptions.BadStoreConfiguration,\n        ks_exceptions.EndpointNotFound) as e:\n        LOG.debug(\"Cannot obtain endpoint from context: %s. Use location \"\n            \"value from database to obtain swift_url.\", e)\n            return self.location.swift_url\n", "code_toks_joined": "def _get_storage_url ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> storage_url = self . store . _get_endpoint ( self . context ) <NEWLINE> if self . image : <NEWLINE> <INDENT> storage_url = storage_url . replace ( self . context . tenant , self . image [ <STRING> ] ) <NEWLINE> <DEDENT> return storage_url <NEWLINE> <DEDENT> except ( exceptions . BadStoreConfiguration , <NEWLINE> <INDENT> ks_exceptions . EndpointNotFound ) as e : <NEWLINE> LOG . debug ( <STRING> <NEWLINE> <INDENT> <STRING> , e ) <NEWLINE> return self . location . swift_url <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'owner'", "\"Cannot obtain endpoint from context: %s. Use location \"", "\"value from database to obtain swift_url.\""]}, "err_obj": {"msg": "unexpected indent"}}], ["03bc4ec4630f23b5ef888b254e204904", {"code_string": "def main(tree, n, out, seed):\n    random.seed(seed)\n    with open(out, 'w') as tfh:\n        for tree in iter_trees(tree):\n            subtree = scaled_subsample(t, n, seed = random.random()\n            print(subtree, file = tfh)\n", "code_toks_joined": "def main ( tree , n , out , seed ) : <NEWLINE> <INDENT> random . seed ( seed ) <NEWLINE> with open ( out , <STRING> ) as tfh : <NEWLINE> <INDENT> for tree in iter_trees ( tree ) : <NEWLINE> <INDENT> subtree = scaled_subsample ( t , n , seed = random . random ( ) <NEWLINE> print ( subtree , file = tfh ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'w'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["35eb70bcc7e709bb8ffbe52b8dcf3f0b", {"code_string": "def test_temperature_conversion(self)\n    original_C = 25.5\n    f = misc_utils.celsius_to_fahrenheit(original_C)\n    back_to_C = misc_utils.fahrenheit_to_celsius(f)\n    assert(str(original_C) == str(back_to_C))\n    original_F = 93.2\n    c = misc_utils.fahrenheit_to_celsius(original_F)\n    back_to_F = misc_utils.celsius_to_fahrenheit(c)\n    assert(original_F == back_to_F)\n", "code_toks_joined": "def test_temperature_conversion ( self ) <NEWLINE> <INDENT> original_C = 25.5 <NEWLINE> f = misc_utils . celsius_to_fahrenheit ( original_C ) <NEWLINE> back_to_C = misc_utils . fahrenheit_to_celsius ( f ) <NEWLINE> assert ( str ( original_C ) == str ( back_to_C ) ) <NEWLINE> original_F = 93.2 <NEWLINE> c = misc_utils . fahrenheit_to_celsius ( original_F ) <NEWLINE> back_to_F = misc_utils . celsius_to_fahrenheit ( c ) <NEWLINE> assert ( original_F == back_to_F ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["eba138f1681141da97040dc70c441c20", {"code_string": "def status(self):\n    try:\n        pf = file(self.pidfile, 'r')\n        pid = int(pf.read().strip())\n        pf.close()\n    except IOError:\n        pid = None\n    if not pid:\n        message = \"radiod status: not running\"\n            log.message(message, log.INFO)\n        print(message)\n    else:\n        message = \"radiod running pid \" + str(pid)\n            log.message(message, log.INFO)\n        print(message)\n    return\n", "code_toks_joined": "def status ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> pf = file ( self . pidfile , <STRING> ) <NEWLINE> pid = int ( pf . read ( ) . strip ( ) ) <NEWLINE> pf . close ( ) <NEWLINE> <DEDENT> except IOError : <NEWLINE> <INDENT> pid = None <NEWLINE> <DEDENT> if not pid : <NEWLINE> <INDENT> message = <STRING> <NEWLINE> <INDENT> log . message ( message , log . INFO ) <NEWLINE> <DEDENT> print ( message ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> message = <STRING> + str ( pid ) <NEWLINE> <INDENT> log . message ( message , log . INFO ) <NEWLINE> <DEDENT> print ( message ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'r'", "\"radiod status: not running\"", "\"radiod running pid \""]}, "err_obj": {"msg": "unexpected indent"}}], ["dc5e55065b90bdf62ef692f1bdac2757", {"code_string": "def get_row_data(entry, remove_from_triage):\n    dict = {}\n    for key in entry.custom:\n        if key == TRIAGE_PORTAL_KEY\n            if remove_from_triage == 't':\n                dict[key] = 'r'\n            else:\n                dict[key] = ''\n        elif key == MSK_AUTOMATION_PORTAL_KEY:\n            dict[key] = 'x'\n        else:\n            dict[key] = entry.custom[key].text\n    return dict\n", "code_toks_joined": "def get_row_data ( entry , remove_from_triage ) : <NEWLINE> <INDENT> dict = { } <NEWLINE> for key in entry . custom : <NEWLINE> <INDENT> if key == TRIAGE_PORTAL_KEY <NEWLINE> <INDENT> if remove_from_triage == <STRING> : <NEWLINE> <INDENT> dict [ key ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dict [ key ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif key == MSK_AUTOMATION_PORTAL_KEY : <NEWLINE> <INDENT> dict [ key ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dict [ key ] = entry . custom [ key ] . text <NEWLINE> <DEDENT> <DEDENT> return dict <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'t'", "'r'", "''", "'x'"]}, "err_obj": {"msg": "invalid syntax"}}], ["0d5f9ac67306c893dee680fe172a9e8a", {"code_string": "def visit_exdefs(self, node):\n    self.symplace = {}\n    for ch in node.children:\n        syms = [x.strip() for x in ch.arg.split(',')]\n        for sym in syms:\n        self.symplace[sym] = ch.tag\n", "code_toks_joined": "def visit_exdefs ( self , node ) : <NEWLINE> <INDENT> self . symplace = { } <NEWLINE> for ch in node . children : <NEWLINE> <INDENT> syms = [ x . strip ( ) for x in ch . arg . split ( <STRING> ) ] <NEWLINE> for sym in syms : <NEWLINE> self . symplace [ sym ] = ch . tag <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["','"]}, "err_obj": {"msg": "expected an indented block"}}], ["0b78e3f58c74fae9f7c559426e57bb94", {"code_string": "def fib(n):\n    if n < 1: raise ValueError, \"not n >= 1\"\n    else:\n        return fib(n - 1) + fib(n - 2)\n", "code_toks_joined": "def fib ( n ) : <NEWLINE> <INDENT> if n < 1 : raise ValueError , <STRING> <NEWLINE> else : <NEWLINE> <INDENT> return fib ( n - 1 ) + fib ( n - 2 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"not n >= 1\""]}, "err_obj": {"msg": "invalid syntax"}}], ["496e05d987bc5754bbda4623a71bf7ad", {"code_string": "class FeatureCompleteFundamentalRule(FeatureSingleEdgeFundamentalRule):\n    def _apply_incomplete(self, chart, grammar, left_edge):\n        fr = self._fundamental_rule\n        end = left_edge.end()\n        for right_edge in chart.select(start = end, end = end,\n            is_complete = True,\n            lhs = left_edge.next()):\n            for new_edge in fr.apply_iter(chart, grammar, left_edge, right_edge):\n            yield new_edge\n", "code_toks_joined": "class FeatureCompleteFundamentalRule ( FeatureSingleEdgeFundamentalRule ) : <NEWLINE> <INDENT> def _apply_incomplete ( self , chart , grammar , left_edge ) : <NEWLINE> <INDENT> fr = self . _fundamental_rule <NEWLINE> end = left_edge . end ( ) <NEWLINE> for right_edge in chart . select ( start = end , end = end , <NEWLINE> <INDENT> is_complete = True , <NEWLINE> lhs = left_edge . next ( ) ) : <NEWLINE> for new_edge in fr . apply_iter ( chart , grammar , left_edge , right_edge ) : <NEWLINE> yield new_edge <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["9069c301c0d2ceb30abe67c5e3e2e102", {"code_string": "def delete_file_from_rbd(ssh_ip, file_path):\n    with settings(host_string = ssh_ip,\n        connection_attempts = env.connection_attempts):\n        with utils.forward_agent(env.key_filename):\n        run(\"rbd rm %s\" % file_path)\n", "code_toks_joined": "def delete_file_from_rbd ( ssh_ip , file_path ) : <NEWLINE> <INDENT> with settings ( host_string = ssh_ip , <NEWLINE> <INDENT> connection_attempts = env . connection_attempts ) : <NEWLINE> with utils . forward_agent ( env . key_filename ) : <NEWLINE> run ( <STRING> % file_path ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"rbd rm %s\""]}, "err_obj": {"msg": "expected an indented block"}}], ["18e8ef850bf4e98b8901fa6eb6877e82", {"code_string": "def _get_socket(self, port, host, timeout):\n    if self.debuglevel > 0: print 'connect: ', (host, port)\n    return socket.create_connection((port, host), timeout)\n", "code_toks_joined": "def _get_socket ( self , port , host , timeout ) : <NEWLINE> <INDENT> if self . debuglevel > 0 : print <STRING> , ( host , port ) <NEWLINE> return socket . create_connection ( ( port , host ) , timeout ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'connect: '"]}, "err_obj": {"msg": "invalid syntax"}}], ["0f4822bbaa04f3bd2915665880873722", {"code_string": "def execute_file(self):\n    \"\"\"Execute the file, catching standard output\"\"\"\n    dirname, fname = os.path.split(self.filename)\n    print('plotting %s' % fname)\n    plt.close('all')\n    cwd = os.getcwd()\n    try:\n        if dirname:\n            os.chdir(dirname)\n        sys.stdout = self\n        with open(os.path.basename(self.filename)) as f:\n            code = compile(f.read(), \"somefile.py\", 'exec')\n            exec(code, {'pl': plt, 'plt': plt, 'pylab': plt})\n        fig_mgr_list = matplotlib._pylab_helpers.Gcf.get_all_fig_managers()\n        self.figlist = [manager.canvas.figure for manager in fig_mgr_list]\n        self.figlist = sorted(self.figlist,\n            key = lambda fig: fig.number)\n    except:\n        print(80 * '_')\n        print('{0} is not compiling:'.format(fname)\n        traceback.print_exc()\n        print(80 * '_')\n    finally:\n        sys.stdout = self.stdout\n        os.chdir(cwd)\n        ncol = gc.collect()\n        if self.print_output and(ncol > 0):\n            print(\"\\n > collected {0} unreachable objects\".format(ncol))\n", "code_toks_joined": "def execute_file ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> dirname , fname = os . path . split ( self . filename ) <NEWLINE> print ( <STRING> % fname ) <NEWLINE> plt . close ( <STRING> ) <NEWLINE> cwd = os . getcwd ( ) <NEWLINE> try : <NEWLINE> <INDENT> if dirname : <NEWLINE> <INDENT> os . chdir ( dirname ) <NEWLINE> <DEDENT> sys . stdout = self <NEWLINE> with open ( os . path . basename ( self . filename ) ) as f : <NEWLINE> <INDENT> code = compile ( f . read ( ) , <STRING> , <STRING> ) <NEWLINE> exec ( code , { <STRING> : plt , <STRING> : plt , <STRING> : plt } ) <NEWLINE> <DEDENT> fig_mgr_list = matplotlib . _pylab_helpers . Gcf . get_all_fig_managers ( ) <NEWLINE> self . figlist = [ manager . canvas . figure for manager in fig_mgr_list ] <NEWLINE> self . figlist = sorted ( self . figlist , <NEWLINE> <INDENT> key = lambda fig : fig . number ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> print ( 80 * <STRING> ) <NEWLINE> print ( <STRING> . format ( fname ) <NEWLINE> traceback . print_exc ( ) <NEWLINE> print ( 80 * <STRING> ) <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> sys . stdout = self . stdout <NEWLINE> os . chdir ( cwd ) <NEWLINE> ncol = gc . collect ( ) <NEWLINE> if self . print_output and ( ncol > 0 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( ncol ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Execute the file, catching standard output\"\"\"", "'plotting %s'", "'all'", "\"somefile.py\"", "'exec'", "'pl'", "'plt'", "'pylab'", "'_'", "'{0} is not compiling:'", "'_'", "\"\\n > collected {0} unreachable objects\""]}, "window_span": [188, 263], "err_obj": {"msg": "unbalanced (){}[]"}}], ["905cca18488fc70984f382907555c52a", {"code_string": "def p_bullet(p):\n    '''bullet : ITEM maybe_lines'''\n    if len(p) == 3:\n    if p[2].startswith('<para>'):\n        p[0] = '<listitem><para>' + p[1] + p[2][len('<para>'): ] + '</listitem>'\n        else:\n        p[0] = '<listitem><para>' + p[1] + '</para>' + p[2] + '</listitem>'\n    else:\n    p[0] = '<listitem><para>' + p[1] + '</para>' + p[3] + '</listitem>'\n    parser_verbose(p)\n", "code_toks_joined": "def p_bullet ( p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if len ( p ) == 3 : <NEWLINE> if p [ 2 ] . startswith ( <STRING> ) : <NEWLINE> <INDENT> p [ 0 ] = <STRING> + p [ 1 ] + p [ 2 ] [ len ( <STRING> ) : ] + <STRING> <NEWLINE> else : <NEWLINE> p [ 0 ] = <STRING> + p [ 1 ] + <STRING> + p [ 2 ] + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> p [ 0 ] = <STRING> + p [ 1 ] + <STRING> + p [ 3 ] + <STRING> <NEWLINE> parser_verbose ( p ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''bullet : ITEM maybe_lines'''", "'<para>'", "'<listitem><para>'", "'<para>'", "'</listitem>'", "'<listitem><para>'", "'</para>'", "'</listitem>'", "'<listitem><para>'", "'</para>'", "'</listitem>'"]}, "err_obj": {"msg": "expected an indented block"}}], ["1bffec10dd3166e649ca6771e6d1bdf7", {"code_string": "def configure_random(self, num_orgs, seed = None):\n    if not seed:\n        seed = random.randrange(0, 65536)\n    self.random = random.Random(seed)\n    from temba.utils import models\n    models.uuid4 = lambda: uuid.UUID(int = self.random.getrandbits(128)\n    self.org_bias = math.log(1.0 / num_orgs, 0.5)\n    return seed\n", "code_toks_joined": "def configure_random ( self , num_orgs , seed = None ) : <NEWLINE> <INDENT> if not seed : <NEWLINE> <INDENT> seed = random . randrange ( 0 , 65536 ) <NEWLINE> <DEDENT> self . random = random . Random ( seed ) <NEWLINE> from temba . utils import models <NEWLINE> models . uuid4 = lambda : uuid . UUID ( int = self . random . getrandbits ( 128 ) <NEWLINE> self . org_bias = math . log ( 1.0 / num_orgs , 0.5 ) <NEWLINE> return seed <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["dcc489e4b3bce5bcba2ae3d20ff62d5d", {"code_string": "def test_port_vif_non_admin(self):\n    with self.network(set_context = True,\n        tenant_id = 'test') as net1:\n        with self.subnet(network = net1) as subnet1:\n        host_arg = {portbindings.HOST_ID: self.hostname}\n        try:\n        with self.port(subnet = subnet1,\n            expected_res_status = 403,\n            arg_list = (portbindings.HOST_ID, ),\n            set_context = True,\n            tenant_id = 'test',\n            ** host_arg):\n            pass\n            except exc.HTTPClientError:\n            pass\n", "code_toks_joined": "def test_port_vif_non_admin ( self ) : <NEWLINE> <INDENT> with self . network ( set_context = True , <NEWLINE> <INDENT> tenant_id = <STRING> ) as net1 : <NEWLINE> with self . subnet ( network = net1 ) as subnet1 : <NEWLINE> host_arg = { portbindings . HOST_ID : self . hostname } <NEWLINE> try : <NEWLINE> with self . port ( subnet = subnet1 , <NEWLINE> <INDENT> expected_res_status = 403 , <NEWLINE> arg_list = ( portbindings . HOST_ID , ) , <NEWLINE> set_context = True , <NEWLINE> tenant_id = <STRING> , <NEWLINE> ** host_arg ) : <NEWLINE> pass <NEWLINE> except exc . HTTPClientError : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'test'", "'test'"]}, "err_obj": {"msg": "expected an indented block"}}], ["add39bff872ca1b51350f35789cf005e", {"code_string": "def install_except_hook():\n    \"\"\"Install an exception hook that first logs any uncaught exception, then\"\"\"\n    def log_exception(exc_type, exc_value, exc_traceback):\n        if not issubclass(exc_type, KeyboardInterrupt):\n            log.critical(\"Uncaught exception\", exc_info = (exc_type, exc_value\n                exc_traceback))\n        sys.__excepthook__(exc_type, exc_value, exc_traceback)\n    sys.excepthook = log_exception\n", "code_toks_joined": "def install_except_hook ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def log_exception ( exc_type , exc_value , exc_traceback ) : <NEWLINE> <INDENT> if not issubclass ( exc_type , KeyboardInterrupt ) : <NEWLINE> <INDENT> log . critical ( <STRING> , exc_info = ( exc_type , exc_value <NEWLINE> <INDENT> exc_traceback ) ) <NEWLINE> <DEDENT> <DEDENT> sys . __excepthook__ ( exc_type , exc_value , exc_traceback ) <NEWLINE> <DEDENT> sys . excepthook = log_exception <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Install an exception hook that first logs any uncaught exception, then\"\"\"", "\"Uncaught exception\""]}, "err_obj": {"msg": "invalid syntax"}}], ["e7aee3bf54e0ec06f8cfe8390fac98fe", {"code_string": "def spacesForWin32HeapSegment(segment):\n    spaces = []\n    for chunk in segment.getChunks():\n        if chunk.isBusy():\n            color = (0xff, 0, 0)\n        else:\n            color = (0, 0xff, 0)\n        spaces.append((chunk.address, len(chunk), color, \"stuff\")\n    return spaces\n", "code_toks_joined": "def spacesForWin32HeapSegment ( segment ) : <NEWLINE> <INDENT> spaces = [ ] <NEWLINE> for chunk in segment . getChunks ( ) : <NEWLINE> <INDENT> if chunk . isBusy ( ) : <NEWLINE> <INDENT> color = ( 0xff , 0 , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> color = ( 0 , 0xff , 0 ) <NEWLINE> <DEDENT> spaces . append ( ( chunk . address , len ( chunk ) , color , <STRING> ) <NEWLINE> <DEDENT> return spaces <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"stuff\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["8c828de36f27a38759be537b7b56c6ea", {"code_string": "def printUploads(self):\n    \"\"\"Print urls accepting uploads\"\"\"\n    if self.uploads !=[]:\n    sys.stderr.write(\"\\n+ Upload Scripts :\\n\")\n    for up in self.uploads:\n        print(up)\n", "code_toks_joined": "def printUploads ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . uploads != [ ] : <NEWLINE> sys . stderr . write ( <STRING> ) <NEWLINE> for up in self . uploads : <NEWLINE> <INDENT> print ( up ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Print urls accepting uploads\"\"\"", "\"\\n+ Upload Scripts :\\n\""]}, "err_obj": {"msg": "expected an indented block"}}], ["f38626919531ada532229e735f183573", {"code_string": "def run_test5(self):\n    dpid = datapathid.from_host(1)\n    port = 1\n    if(self.debug):\n        print \"removing location name 'of6k at eth0' \"\n    self.bs.remove_name_for_location(dpid, port, \"of6k at eth0\", Name.LOCATION)\n    self.next_fn = self.run_test6\n    self.wait_count = 1\n", "code_toks_joined": "def run_test5 ( self ) : <NEWLINE> <INDENT> dpid = datapathid . from_host ( 1 ) <NEWLINE> port = 1 <NEWLINE> if ( self . debug ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> self . bs . remove_name_for_location ( dpid , port , <STRING> , Name . LOCATION ) <NEWLINE> self . next_fn = self . run_test6 <NEWLINE> self . wait_count = 1 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"removing location name 'of6k at eth0' \"", "\"of6k at eth0\""]}, "err_obj": {"msg": "invalid syntax"}}], ["8826ad353faf688cac14abe692542408", {"code_string": "def translate(in_fp, out_fp):\n    with open(in_fp, 'r') as tgrep2:\n    with open(out_fp, 'w') as penn:\n        for line in tgrep2:\n            penn.write(re.sub('\\(TOP', '(', line))\n", "code_toks_joined": "def translate ( in_fp , out_fp ) : <NEWLINE> <INDENT> with open ( in_fp , <STRING> ) as tgrep2 : <NEWLINE> with open ( out_fp , <STRING> ) as penn : <NEWLINE> <INDENT> for line in tgrep2 : <NEWLINE> <INDENT> penn . write ( re . sub ( <STRING> , <STRING> , line ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'r'", "'w'", "'\\(TOP'", "'('"]}, "err_obj": {"msg": "expected an indented block"}}], ["812d41e53325faf30c114a7456037ff0", {"code_string": "def invalidate_tables(self, database, tables):\n    handle = None\n    for table in tables:\n        try:\n            hql = \"INVALIDATE METADATA %s.%s\" %(database, table, )\n            query = hql_query(hql, database, query_type = QUERY_TYPES[1])\n            handle = self.execute_and_wait(query, timeout_sec = 10.0)\n        except Exception, e:\n            LOG.warn('Refresh tables cache out of sync: %s' % smart_str(e))\n        finally:\n            if handle:\n                self.close(handle)\n", "code_toks_joined": "def invalidate_tables ( self , database , tables ) : <NEWLINE> <INDENT> handle = None <NEWLINE> for table in tables : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> hql = <STRING> % ( database , table , ) <NEWLINE> query = hql_query ( hql , database , query_type = QUERY_TYPES [ 1 ] ) <NEWLINE> handle = self . execute_and_wait ( query , timeout_sec = 10.0 ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> LOG . warn ( <STRING> % smart_str ( e ) ) <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> if handle : <NEWLINE> <INDENT> self . close ( handle ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"INVALIDATE METADATA %s.%s\"", "'Refresh tables cache out of sync: %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["7db162f04303544ef0d89d6631581fbd", {"code_string": "def getReviewStateTitle(self):\n    reviewState = self.getReviewState()\n    reviewStateTitle = self.portal_workflow.getTitleForStateOnType(reviewState, 'UW-Oshkosh CoB Internship')\n        return reviewStateTitle\n", "code_toks_joined": "def getReviewStateTitle ( self ) : <NEWLINE> <INDENT> reviewState = self . getReviewState ( ) <NEWLINE> reviewStateTitle = self . portal_workflow . getTitleForStateOnType ( reviewState , <STRING> ) <NEWLINE> <INDENT> return reviewStateTitle <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'UW-Oshkosh CoB Internship'"]}, "err_obj": {"msg": "unexpected indent"}}], ["5652fe57520e6393473bb88156a02704", {"code_string": "def format_dict(data, markup):\n    parser = Parser(markup.lower()\n    formatted_data = parser.dump(data)\n    if markup == 'YAML':\n        formatted_data = '\\n'.join(['---', formatted_data])\n    return formatted_data\n", "code_toks_joined": "def format_dict ( data , markup ) : <NEWLINE> <INDENT> parser = Parser ( markup . lower ( ) <NEWLINE> formatted_data = parser . dump ( data ) <NEWLINE> if markup == <STRING> : <NEWLINE> <INDENT> formatted_data = <STRING> . join ( [ <STRING> , formatted_data ] ) <NEWLINE> <DEDENT> return formatted_data <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'YAML'", "'\\n'", "'---'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["be6326f38427eb9ab4944b6026eafe3c", {"code_string": "def setupUi(self, PlotOptionsWidget):\n    PlotOptionsWidget.setObjectName(_fromUtf8(\"PlotOptionsWidget\"))\n    PlotOptionsWidget.resize(797, 442)\n    self.horizontalLayout = QtGui.QHBoxLayout(PlotOptionsWidget)\n    self.horizontalLayout.setObjectName(_fromUtf8(\"horizontalLayout\"))\n    self.verticalLayout = QtGui.QVBoxLayout()\n    self.verticalLayout.setObjectName(_fromUtf8(\"verticalLayout\"))\n    self.label_29 = QtGui.QLabel(PlotOptionsWidget)\n    sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(self.label_29.sizePolicy().hasHeightForWidth())\n    self.label_29.setSizePolicy(sizePolicy)\n    self.label_29.setObjectName(_fromUtf8(\"label_29\"))\n    self.verticalLayout.addWidget(self.label_29)\n    self.plotSelector = QtGui.QComboBox(PlotOptionsWidget)\n    sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(self.plotSelector.sizePolicy().hasHeightForWidth())\n    self.plotSelector.setSizePolicy(sizePolicy)\n    self.plotSelector.setSizeAdjustPolicy(QtGui.QComboBox.AdjustToContents)\n    self.plotSelector.setMinimumContentsLength(20)\n    self.plotSelector.setObjectName(_fromUtf8(\"plotSelector\"))\n    self.verticalLayout.addWidget(self.plotSelector)\n    self.line = QtGui.QFrame(PlotOptionsWidget)\n    self.line.setFrameShape(QtGui.QFrame.HLine)\n    self.line.setFrameShadow(QtGui.QFrame.Sunken)\n    self.line.setObjectName(_fromUtf8(\"line\"))\n    self.verticalLayout.addWidget(self.line)\n    self.groupBox = QtGui.QGroupBox(PlotOptionsWidget)\n    sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(self.groupBox.sizePolicy().hasHeightForWidth())\n    self.groupBox.setSizePolicy(sizePolicy)\n    self.groupBox.setMinimumSize(QtCore.QSize(200, 0))\n    self.groupBox.setObjectName(_fromUtf8(\"groupBox\"))\n    self.verticalLayout_3 = QtGui.QVBoxLayout(self.groupBox)\n    self.verticalLayout_3.setObjectName(_fromUtf8(\"verticalLayout_3\"))\n    self.label_3 = QtGui.QLabel(self.groupBox)\n    sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Fixed)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(self.label_3.sizePolicy().hasHeightForWidth())\n    self.label_3.setSizePolicy(sizePolicy)\n    self.label_3.setObjectName(_fromUtf8(\"label_3\"))\n    self.verticalLayout_3.addWidget(self.label_3)\n    self.name = QtGui.QLineEdit(self.groupBox)\n    sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Fixed)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(self.name.sizePolicy().hasHeightForWidth())\n    self.name.setSizePolicy(sizePolicy)\n    self.name.setMinimumSize(QtCore.QSize(150, 0))\n    self.name.setMaximumSize(QtCore.QSize(300, 16777215))\n    self.name.setObjectName(_fromUtf8(\"name\"))\n    self.verticalLayout_3.addWidget(self.name)\n    self.nameFont = QTextOptionsButton(self.groupBox)\n    sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(self.nameFont.sizePolicy().hasHeightForWidth())\n    self.nameFont.setSizePolicy(sizePolicy)\n    self.nameFont.setMinimumSize(QtCore.QSize(75, 0))\n    self.nameFont.setMaximumSize(QtCore.QSize(16777215, 16777215))\n    self.nameFont.setObjectName(_fromUtf8(\"nameFont\"))\n    self.verticalLayout_3.addWidget(self.nameFont)\n    self.line_5 = QtGui.QFrame(self.groupBox)\n    self.line_5.setFrameShape(QtGui.QFrame.HLine)\n    self.line_5.setFrameShadow(QtGui.QFrame.Sunken)\n    self.line_5.setObjectName(_fromUtf8(\"line_5\"))\n    self.verticalLayout_3.addWidget(self.line_5)\n    self.label_8 = QtGui.QLabel(self.groupBox)\n    sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Fixed)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(self.label_8.sizePolicy().hasHeightForWidth())\n    self.label_8.setSizePolicy(sizePolicy)\n    self.label_8.setObjectName(_fromUtf8(\"label_8\"))\n    self.verticalLayout_3.addWidget(self.label_8)\n    self.backgroundColor = QColorButton(self.groupBox)\n    self.backgroundColor.setMinimumSize(QtCore.QSize(150, 0))\n    self.backgroundColor.setStyleSheet(_fromUtf8(\"color: rgb(0, 0, 0);\\n\"\n", "code_toks_joined": "def setupUi ( self , PlotOptionsWidget ) : <NEWLINE> <INDENT> PlotOptionsWidget . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> PlotOptionsWidget . resize ( 797 , 442 ) <NEWLINE> self . horizontalLayout = QtGui . QHBoxLayout ( PlotOptionsWidget ) <NEWLINE> self . horizontalLayout . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . verticalLayout = QtGui . QVBoxLayout ( ) <NEWLINE> self . verticalLayout . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label_29 = QtGui . QLabel ( PlotOptionsWidget ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Minimum , QtGui . QSizePolicy . Fixed ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( self . label_29 . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> self . label_29 . setSizePolicy ( sizePolicy ) <NEWLINE> self . label_29 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . verticalLayout . addWidget ( self . label_29 ) <NEWLINE> self . plotSelector = QtGui . QComboBox ( PlotOptionsWidget ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Minimum , QtGui . QSizePolicy . Fixed ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( self . plotSelector . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> self . plotSelector . setSizePolicy ( sizePolicy ) <NEWLINE> self . plotSelector . setSizeAdjustPolicy ( QtGui . QComboBox . AdjustToContents ) <NEWLINE> self . plotSelector . setMinimumContentsLength ( 20 ) <NEWLINE> self . plotSelector . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . verticalLayout . addWidget ( self . plotSelector ) <NEWLINE> self . line = QtGui . QFrame ( PlotOptionsWidget ) <NEWLINE> self . line . setFrameShape ( QtGui . QFrame . HLine ) <NEWLINE> self . line . setFrameShadow ( QtGui . QFrame . Sunken ) <NEWLINE> self . line . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . verticalLayout . addWidget ( self . line ) <NEWLINE> self . groupBox = QtGui . QGroupBox ( PlotOptionsWidget ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Minimum , QtGui . QSizePolicy . Preferred ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( self . groupBox . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> self . groupBox . setSizePolicy ( sizePolicy ) <NEWLINE> self . groupBox . setMinimumSize ( QtCore . QSize ( 200 , 0 ) ) <NEWLINE> self . groupBox . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . verticalLayout_3 = QtGui . QVBoxLayout ( self . groupBox ) <NEWLINE> self . verticalLayout_3 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label_3 = QtGui . QLabel ( self . groupBox ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Preferred , QtGui . QSizePolicy . Fixed ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( self . label_3 . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> self . label_3 . setSizePolicy ( sizePolicy ) <NEWLINE> self . label_3 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . verticalLayout_3 . addWidget ( self . label_3 ) <NEWLINE> self . name = QtGui . QLineEdit ( self . groupBox ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Preferred , QtGui . QSizePolicy . Fixed ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( self . name . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> self . name . setSizePolicy ( sizePolicy ) <NEWLINE> self . name . setMinimumSize ( QtCore . QSize ( 150 , 0 ) ) <NEWLINE> self . name . setMaximumSize ( QtCore . QSize ( 300 , 16777215 ) ) <NEWLINE> self . name . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . verticalLayout_3 . addWidget ( self . name ) <NEWLINE> self . nameFont = QTextOptionsButton ( self . groupBox ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Minimum , QtGui . QSizePolicy . Fixed ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( self . nameFont . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> self . nameFont . setSizePolicy ( sizePolicy ) <NEWLINE> self . nameFont . setMinimumSize ( QtCore . QSize ( 75 , 0 ) ) <NEWLINE> self . nameFont . setMaximumSize ( QtCore . QSize ( 16777215 , 16777215 ) ) <NEWLINE> self . nameFont . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . verticalLayout_3 . addWidget ( self . nameFont ) <NEWLINE> self . line_5 = QtGui . QFrame ( self . groupBox ) <NEWLINE> self . line_5 . setFrameShape ( QtGui . QFrame . HLine ) <NEWLINE> self . line_5 . setFrameShadow ( QtGui . QFrame . Sunken ) <NEWLINE> self . line_5 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . verticalLayout_3 . addWidget ( self . line_5 ) <NEWLINE> self . label_8 = QtGui . QLabel ( self . groupBox ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Preferred , QtGui . QSizePolicy . Fixed ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( self . label_8 . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> self . label_8 . setSizePolicy ( sizePolicy ) <NEWLINE> self . label_8 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . verticalLayout_3 . addWidget ( self . label_8 ) <NEWLINE> self . backgroundColor = QColorButton ( self . groupBox ) <NEWLINE> self . backgroundColor . setMinimumSize ( QtCore . QSize ( 150 , 0 ) ) <NEWLINE> self . backgroundColor . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"PlotOptionsWidget\"", "\"horizontalLayout\"", "\"verticalLayout\"", "\"label_29\"", "\"plotSelector\"", "\"line\"", "\"groupBox\"", "\"verticalLayout_3\"", "\"label_3\"", "\"name\"", "\"nameFont\"", "\"line_5\"", "\"label_8\"", "\"color: rgb(0, 0, 0);\\n\""]}, "window_span": [1001, 1007], "err_obj": {"msg": "unbalanced (){}[]"}}], ["705fc8254255f162ba1a3b98ada16836", {"code_string": "class PoiAttributes(models.Model):\n    name = models.CharField(max_length = 60)\n    category = models.CharField(max_length = 60)\n    url = models.CharField(max_length = 60)\n    openHours = ListField(EmbeddedModelField('PoiOpenHour'))\n    fee = ListField(EmbeddedModelField('PoiFee'))\n    tags = ListField(models.CharField(max_length = 60)\n    coords = ListField(models.DecimalField())\n    city = EmbeddedModelField('PoiCity')\n", "code_toks_joined": "class PoiAttributes ( models . Model ) : <NEWLINE> <INDENT> name = models . CharField ( max_length = 60 ) <NEWLINE> category = models . CharField ( max_length = 60 ) <NEWLINE> url = models . CharField ( max_length = 60 ) <NEWLINE> openHours = ListField ( EmbeddedModelField ( <STRING> ) ) <NEWLINE> fee = ListField ( EmbeddedModelField ( <STRING> ) ) <NEWLINE> tags = ListField ( models . CharField ( max_length = 60 ) <NEWLINE> coords = ListField ( models . DecimalField ( ) ) <NEWLINE> city = EmbeddedModelField ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'PoiOpenHour'", "'PoiFee'", "'PoiCity'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["5e1a11f1c24d66e511ecb97b2f16d17c", {"code_string": "def check_dependencies():\n    \"\"\"Ensure required tools for installation are present.\"\"\"\n    print(\"Checking required dependencies...\")\n    for cmd, url in[(\"git\", \"http://git-scm.com/\"),\n        (\"wget\", \"http://www.gnu.org/software/wget/\"),\n        (\"curl\", \"http://curl.haxx.se/\")]:\n        try:\n        retcode = subprocess.call([cmd, \"--version\"], stdout = subprocess.PIPE, stderr = subprocess.STDOUT)\n        except OSError:\n        retcode = 127\n        if retcode == 127:\n        raise OSError(\"gemini requires %s (%s)\" %(cmd, url))\n        else:\n        print(\" %s found\" % cmd)\n", "code_toks_joined": "def check_dependencies ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> ) <NEWLINE> for cmd , url in [ ( <STRING> , <STRING> ) , <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) ] : <NEWLINE> try : <NEWLINE> retcode = subprocess . call ( [ cmd , <STRING> ] , stdout = subprocess . PIPE , stderr = subprocess . STDOUT ) <NEWLINE> except OSError : <NEWLINE> retcode = 127 <NEWLINE> if retcode == 127 : <NEWLINE> raise OSError ( <STRING> % ( cmd , url ) ) <NEWLINE> else : <NEWLINE> print ( <STRING> % cmd ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Ensure required tools for installation are present.\"\"\"", "\"Checking required dependencies...\"", "\"git\"", "\"http://git-scm.com/\"", "\"wget\"", "\"http://www.gnu.org/software/wget/\"", "\"curl\"", "\"http://curl.haxx.se/\"", "\"--version\"", "\"gemini requires %s (%s)\"", "\" %s found\""]}, "err_obj": {"msg": "expected an indented block"}}], ["bbaef4e70bc609c3255f3a6fa4c0abbe", {"code_string": "def WriteFile(platform, hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped):\n    '''https://msdn.microsoft.com/en-us/library/windows/desktop/aa365747(v=vs.85).aspx'''\n    logger.info(\"\"\"WriteFile(\"\"\" %(\n    toStr(platform, hFile),\n    toStr(platform, lpBuffer),\n    toStr(platform, nNumberOfBytesToWrite),\n    toStr(platform, lpNumberOfBytesWritten),\n    toStr(platform, lpOverlapped))\n", "code_toks_joined": "def WriteFile ( platform , hFile , lpBuffer , nNumberOfBytesToWrite , lpNumberOfBytesWritten , lpOverlapped ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> logger . info ( <STRING> % ( <NEWLINE> toStr ( platform , hFile ) , <NEWLINE> toStr ( platform , lpBuffer ) , <NEWLINE> toStr ( platform , nNumberOfBytesToWrite ) , <NEWLINE> toStr ( platform , lpNumberOfBytesWritten ) , <NEWLINE> toStr ( platform , lpOverlapped ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''https://msdn.microsoft.com/en-us/library/windows/desktop/aa365747(v=vs.85).aspx'''", "\"\"\"WriteFile(\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["ca13f9f5a59627271d514eeaf0bbff32", {"code_string": "def setup_control_rack(self, track):\n    \"\"\" Setup rack to use for morphing between current vals and snapped vals \"\"\"\n    self.remove_control_rack()\n    for dev in track.devices:\n        dev_name = self._parent.get_name(dev.name)\n        if dev.class_name.endswith('GroupDevice') and dev_name.startswith('CLYPHX SNAP'):\n        self._control_rack = dev\n        break\n", "code_toks_joined": "def setup_control_rack ( self , track ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . remove_control_rack ( ) <NEWLINE> for dev in track . devices : <NEWLINE> <INDENT> dev_name = self . _parent . get_name ( dev . name ) <NEWLINE> if dev . class_name . endswith ( <STRING> ) and dev_name . startswith ( <STRING> ) : <NEWLINE> self . _control_rack = dev <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Setup rack to use for morphing between current vals and snapped vals \"\"\"", "'GroupDevice'", "'CLYPHX SNAP'"]}, "err_obj": {"msg": "expected an indented block"}}], ["3f1ba270ee93a729a74db0511d2ec122", {"code_string": "def get_model_class(table_name):\n    \"\"\"Returns a Model class based on a database table name\"\"\"\n    classmap = dict((m._meta.db_table, m) for m in models.get_models()\n    if table_name in classmap:\n        return classmap[table_name]\n", "code_toks_joined": "def get_model_class ( table_name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> classmap = dict ( ( m . _meta . db_table , m ) for m in models . get_models ( ) <NEWLINE> if table_name in classmap : <NEWLINE> <INDENT> return classmap [ table_name ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns a Model class based on a database table name\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["914ff5fd9e20f648969bc6b5ae7a25bb", {"code_string": "def load_matrix(self, termList, period):\n    \"\"\"UNUSED, to test\"\"\"\n    matrix = SymmetricMatrix(termList)\n    try:\n        generator = self.storage.selectCorpusGraphPreprocess(period, \"NGram\")\n        while 1:\n            ngi, row = generator.next()\n            for ngj in row.iterkeys():\n                matrix.set(ngi, ngj, value = row[ngj])\n    except StopIteration, si:\n        return matrix\n", "code_toks_joined": "def load_matrix ( self , termList , period ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> matrix = SymmetricMatrix ( termList ) <NEWLINE> try : <NEWLINE> <INDENT> generator = self . storage . selectCorpusGraphPreprocess ( period , <STRING> ) <NEWLINE> while 1 : <NEWLINE> <INDENT> ngi , row = generator . next ( ) <NEWLINE> for ngj in row . iterkeys ( ) : <NEWLINE> <INDENT> matrix . set ( ngi , ngj , value = row [ ngj ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except StopIteration , si : <NEWLINE> <INDENT> return matrix <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"UNUSED, to test\"\"\"", "\"NGram\""]}, "err_obj": {"msg": "invalid syntax"}}], ["99fcbbaf7d38a6092cd52f6c49fee34f", {"code_string": "def http_daemon_thread(self):\n    logger.info(\"Starting HTTP daemon\")\n    try:\n        self.http_daemon.run()\n    except Exception, exp:\n        logger.error('The HTTP daemon failed with the error %s, exiting', str(exp))\n        output = cStringIO.StringIO()\n        traceback.print_exc(file = output)\n        logger.error(\"Back trace of this error: %s\", output.getvalue())\n        output.close()\n        self.do_stop()\n        os._exit(2)\n", "code_toks_joined": "def http_daemon_thread ( self ) : <NEWLINE> <INDENT> logger . info ( <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> self . http_daemon . run ( ) <NEWLINE> <DEDENT> except Exception , exp : <NEWLINE> <INDENT> logger . error ( <STRING> , str ( exp ) ) <NEWLINE> output = cStringIO . StringIO ( ) <NEWLINE> traceback . print_exc ( file = output ) <NEWLINE> logger . error ( <STRING> , output . getvalue ( ) ) <NEWLINE> output . close ( ) <NEWLINE> self . do_stop ( ) <NEWLINE> os . _exit ( 2 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Starting HTTP daemon\"", "'The HTTP daemon failed with the error %s, exiting'", "\"Back trace of this error: %s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["8cc3d5a40618089378f93dafb488e932", {"code_string": "def _set_problem(self, problem):\n    def destroy_links(widget, _):\n        if widget != self._builder.lbl_reported_value:\n            widget.destroy()\n    self.selected_problem = problem\n    sensitive_btn = problem is not None\n    self._builder.btn_delete.set_sensitive(sensitive_btn)\n    self._builder.btn_report.set_sensitive(\n        sensitive_btn and not problem['not-reportable'])\n    self._builder.vbx_links.foreach(\n        destroy_links, None)\n    self._builder.vbx_problem_messages.foreach(\n        lambda w, u: w.destroy(), None)\n    if problem:\n        self._builder.nb_problem_layout.set_current_page(0)\n        app = problem['application']\n        if problem['type'] == 'Kerneloops':\n            self._builder.lbl_reason.set_text(\n        _(\"Unexpected system error\"))\n            self._builder.lbl_summary.set_text(\n        _(\"The system has encountered a problem and recovered.\"))\n        elif problem['type'] == 'vmcore':\n            self._builder.lbl_reason.set_text(\n        _(\"Fatal system failure\"))\n            self._builder.lbl_summary.set_text(\n        _(\"The system has encountered a problem and could not continue.\"))\n        else:\n            if not app.name:\n                self._builder.lbl_reason.set_text(\n                    _(\"{0} problem has been detected\").format(\n                        problem['human_type']))\n            else:\n                self._builder.lbl_reason.set_text(\n                    _(\"{0} quit unexpectedly\").format(app.name))\n            self._builder.lbl_summary.set_text(\n        _(\"The application encountered a problem and could not continue.\"))\n        self._builder.lbl_app_name_value.set_text(\n            problem['package_name'] or _(\"N/A\"))\n        self._builder.lbl_app_version_value.set_text(\n            problem['package_version'] or _(\"N/A\"))\n        self._builder.lbl_detected_value.set_text(\n            humanize.naturaltime(datetime.datetime.now() - problem['date']))\n        self._builder.lbl_detected_value.set_tooltip_text(\n            problem['date'].strftime(config.get_configuration()['D_T_FMT']))\n        icon_buf = None\n        scale = self._builder.img_app_icon.get_scale_factor()\n        if app.icon:\n            icon_buf = load_icon(gicon = app.icon, scale = scale)\n        if icon_buf is None:\n            icon_buf = load_icon(name = \"system-run-symbolic\", scale = scale)\n            self._builder.img_app_icon.get_style_context().add_class(\n                'dim-label')\n        else:\n            self._builder.img_app_icon.get_style_context().remove_class(\n                'dim-label')\n        set_icon_from_pixbuf_with_scale(self._builder.img_app_icon,\n            icon_buf, scale)\n        self._builder.lbl_reported_value.show()\n        self._builder.lbl_reported.set_text(_(\"Reported\"))\n        if problem['not-reportable']:\n            self._builder.lbl_reported_value.set_text(\n                _('cannot be reported'))\n            self._show_problem_links(problem['submission'])\n            self._show_problem_message(problem['not-reportable'])\n        elif problem['is_reported']:\n            if self._show_problem_links(problem['submission']):\n                self._builder.lbl_reported.set_text(_(\"Reports\"))\n                self._builder.lbl_reported_value.hide()\n                if(not any((s.name == \"Bugzilla\"\n", "code_toks_joined": "def _set_problem ( self , problem ) : <NEWLINE> <INDENT> def destroy_links ( widget , _ ) : <NEWLINE> <INDENT> if widget != self . _builder . lbl_reported_value : <NEWLINE> <INDENT> widget . destroy ( ) <NEWLINE> <DEDENT> <DEDENT> self . selected_problem = problem <NEWLINE> sensitive_btn = problem is not None <NEWLINE> self . _builder . btn_delete . set_sensitive ( sensitive_btn ) <NEWLINE> self . _builder . btn_report . set_sensitive ( <NEWLINE> <INDENT> sensitive_btn and not problem [ <STRING> ] ) <NEWLINE> <DEDENT> self . _builder . vbx_links . foreach ( <NEWLINE> <INDENT> destroy_links , None ) <NEWLINE> <DEDENT> self . _builder . vbx_problem_messages . foreach ( <NEWLINE> <INDENT> lambda w , u : w . destroy ( ) , None ) <NEWLINE> <DEDENT> if problem : <NEWLINE> <INDENT> self . _builder . nb_problem_layout . set_current_page ( 0 ) <NEWLINE> app = problem [ <STRING> ] <NEWLINE> if problem [ <STRING> ] == <STRING> : <NEWLINE> <INDENT> self . _builder . lbl_reason . set_text ( <NEWLINE> <DEDENT> _ ( <STRING> ) ) <NEWLINE> <INDENT> self . _builder . lbl_summary . set_text ( <NEWLINE> <DEDENT> _ ( <STRING> ) ) <NEWLINE> elif problem [ <STRING> ] == <STRING> : <NEWLINE> <INDENT> self . _builder . lbl_reason . set_text ( <NEWLINE> <DEDENT> _ ( <STRING> ) ) <NEWLINE> <INDENT> self . _builder . lbl_summary . set_text ( <NEWLINE> <DEDENT> _ ( <STRING> ) ) <NEWLINE> else : <NEWLINE> <INDENT> if not app . name : <NEWLINE> <INDENT> self . _builder . lbl_reason . set_text ( <NEWLINE> <INDENT> _ ( <STRING> ) . format ( <NEWLINE> <INDENT> problem [ <STRING> ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> self . _builder . lbl_reason . set_text ( <NEWLINE> <INDENT> _ ( <STRING> ) . format ( app . name ) ) <NEWLINE> <DEDENT> <DEDENT> self . _builder . lbl_summary . set_text ( <NEWLINE> <DEDENT> _ ( <STRING> ) ) <NEWLINE> self . _builder . lbl_app_name_value . set_text ( <NEWLINE> <INDENT> problem [ <STRING> ] or _ ( <STRING> ) ) <NEWLINE> <DEDENT> self . _builder . lbl_app_version_value . set_text ( <NEWLINE> <INDENT> problem [ <STRING> ] or _ ( <STRING> ) ) <NEWLINE> <DEDENT> self . _builder . lbl_detected_value . set_text ( <NEWLINE> <INDENT> humanize . naturaltime ( datetime . datetime . now ( ) - problem [ <STRING> ] ) ) <NEWLINE> <DEDENT> self . _builder . lbl_detected_value . set_tooltip_text ( <NEWLINE> <INDENT> problem [ <STRING> ] . strftime ( config . get_configuration ( ) [ <STRING> ] ) ) <NEWLINE> <DEDENT> icon_buf = None <NEWLINE> scale = self . _builder . img_app_icon . get_scale_factor ( ) <NEWLINE> if app . icon : <NEWLINE> <INDENT> icon_buf = load_icon ( gicon = app . icon , scale = scale ) <NEWLINE> <DEDENT> if icon_buf is None : <NEWLINE> <INDENT> icon_buf = load_icon ( name = <STRING> , scale = scale ) <NEWLINE> self . _builder . img_app_icon . get_style_context ( ) . add_class ( <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> self . _builder . img_app_icon . get_style_context ( ) . remove_class ( <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> set_icon_from_pixbuf_with_scale ( self . _builder . img_app_icon , <NEWLINE> <INDENT> icon_buf , scale ) <NEWLINE> <DEDENT> self . _builder . lbl_reported_value . show ( ) <NEWLINE> self . _builder . lbl_reported . set_text ( _ ( <STRING> ) ) <NEWLINE> if problem [ <STRING> ] : <NEWLINE> <INDENT> self . _builder . lbl_reported_value . set_text ( <NEWLINE> <INDENT> _ ( <STRING> ) ) <NEWLINE> <DEDENT> self . _show_problem_links ( problem [ <STRING> ] ) <NEWLINE> self . _show_problem_message ( problem [ <STRING> ] ) <NEWLINE> <DEDENT> elif problem [ <STRING> ] : <NEWLINE> <INDENT> if self . _show_problem_links ( problem [ <STRING> ] ) : <NEWLINE> <INDENT> self . _builder . lbl_reported . set_text ( _ ( <STRING> ) ) <NEWLINE> self . _builder . lbl_reported_value . hide ( ) <NEWLINE> if ( not any ( ( s . name == <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'not-reportable'", "'application'", "'type'", "'Kerneloops'", "\"Unexpected system error\"", "\"The system has encountered a problem and recovered.\"", "'type'", "'vmcore'", "\"Fatal system failure\"", "\"The system has encountered a problem and could not continue.\"", "\"{0} problem has been detected\"", "'human_type'", "\"{0} quit unexpectedly\"", "\"The application encountered a problem and could not continue.\"", "'package_name'", "\"N/A\"", "'package_version'", "\"N/A\"", "'date'", "'date'", "'D_T_FMT'", "\"system-run-symbolic\"", "'dim-label'", "'dim-label'", "\"Reported\"", "'not-reportable'", "'cannot be reported'", "'submission'", "'not-reportable'", "'is_reported'", "'submission'", "\"Reports\"", "\"Bugzilla\""]}, "window_span": [655, 670], "err_obj": {"msg": "unbalanced (){}[]"}}], ["6f098eb14cada23d0c2f5e28f8a2e829", {"code_string": "def get_ttype(self):\n    \"\"\"Get the temporal type of the map\"\"\"\n    if self.D.has_key(\"temporal_type\"):\n        return self.D[\"temporal_type\"]\n            else:\n        return None\n", "code_toks_joined": "def get_ttype ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . D . has_key ( <STRING> ) : <NEWLINE> <INDENT> return self . D [ <STRING> ] <NEWLINE> <INDENT> else : <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get the temporal type of the map\"\"\"", "\"temporal_type\"", "\"temporal_type\""]}, "err_obj": {"msg": "unexpected indent"}}], ["5f85b8ded9e36c57359e3c7097c1c676", {"code_string": "class LTRect(LTPolygon):\n    def __init__(self, linewidth, (x0, y0, x1, y1)):\n        LTPolygon.__init__(self, linewidth, [(x0, y0), (x1, y0), (x1, y1), (x0, y1)])\n        return\n", "code_toks_joined": "class LTRect ( LTPolygon ) : <NEWLINE> <INDENT> def __init__ ( self , linewidth , ( x0 , y0 , x1 , y1 ) ) : <NEWLINE> <INDENT> LTPolygon . __init__ ( self , linewidth , [ ( x0 , y0 ) , ( x1 , y0 ) , ( x1 , y1 ) , ( x0 , y1 ) ] ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["e1284db644c5a489a120ffc160e871d6", {"code_string": "def read(self, size = None):\n    if size is None:\n        size = self.len - self.pos\n    if size + self.pos > self.len:\n        size = self.len - self.pos\n    txt = self.fh.read(size)\n    self.pos += len(txt)\n    if self.debug:\n        print \"WindowReader: read %s from %d(%s)\" %(size, self.pos, repr(txt))\n    return txt\n", "code_toks_joined": "def read ( self , size = None ) : <NEWLINE> <INDENT> if size is None : <NEWLINE> <INDENT> size = self . len - self . pos <NEWLINE> <DEDENT> if size + self . pos > self . len : <NEWLINE> <INDENT> size = self . len - self . pos <NEWLINE> <DEDENT> txt = self . fh . read ( size ) <NEWLINE> self . pos += len ( txt ) <NEWLINE> if self . debug : <NEWLINE> <INDENT> print <STRING> % ( size , self . pos , repr ( txt ) ) <NEWLINE> <DEDENT> return txt <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"WindowReader: read %s from %d(%s)\""]}, "err_obj": {"msg": "invalid syntax"}}], ["4f75f3c877da463417a5ebd66828a9e0", {"code_string": "def _get_command_doc_notes(cmd):\n    \"\"\"Get docs for the notes of a command.\"\"\"\n    if(cmd.maxsplit is not None or cmd.no_cmd_split or\n        cmd.no_replace_variables and cmd.name != \"spawn\"):\n        yield \"\"\n        yield \"==== note\"\n        if cmd.maxsplit is not None:\n        yield(\"* This command does not split arguments after the last \"\n            \"argument and handles quotes literally.\")\n            if cmd.no_cmd_split:\n        yield(\"* With this command, +;;+ is interpreted literally \"\n            \"instead of splitting off a second command.\")\n            if cmd.no_replace_variables and cmd.name != \"spawn\":\n        yield r\"* This command does not replace variables like +\\{url\\}+.\"\n", "code_toks_joined": "def _get_command_doc_notes ( cmd ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( cmd . maxsplit is not None or cmd . no_cmd_split or <NEWLINE> <INDENT> cmd . no_replace_variables and cmd . name != <STRING> ) : <NEWLINE> yield <STRING> <NEWLINE> yield <STRING> <NEWLINE> if cmd . maxsplit is not None : <NEWLINE> yield ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> if cmd . no_cmd_split : <NEWLINE> <DEDENT> yield ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> if cmd . no_replace_variables and cmd . name != <STRING> : <NEWLINE> <DEDENT> yield <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get docs for the notes of a command.\"\"\"", "\"spawn\"", "\"\"", "\"==== note\"", "\"* This command does not split arguments after the last \"", "\"argument and handles quotes literally.\"", "\"* With this command, +;;+ is interpreted literally \"", "\"instead of splitting off a second command.\"", "\"spawn\"", "r\"* This command does not replace variables like +\\{url\\}+.\""]}, "err_obj": {"msg": "expected an indented block"}}], ["e4501ffb1560522cb094a882474b368d", {"code_string": "def _fill_corners(self, _model):\n    'Fill the corners list.'\n    positions = list()\n    for polygon_model in _model:\n        for point in polygon_model:\n            if positions.count(point) == 0:\n                positions.append(point)\n    for position in positions:\n        self.corners.append(corner.Corner(self._get_random_id(), position)\n", "code_toks_joined": "def _fill_corners ( self , _model ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> positions = list ( ) <NEWLINE> for polygon_model in _model : <NEWLINE> <INDENT> for point in polygon_model : <NEWLINE> <INDENT> if positions . count ( point ) == 0 : <NEWLINE> <INDENT> positions . append ( point ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for position in positions : <NEWLINE> <INDENT> self . corners . append ( corner . Corner ( self . _get_random_id ( ) , position ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Fill the corners list.'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["4247180bea761ec171a37d41becfb021", {"code_string": "def __init__(self):\n    Sensor.__init__(self)\n        self.__value = 0.0\n        self.__prev_value = 0.0\n        self.__velocity = 0.0\n        self.__init_value = 0.0\n        self.__time = 0.0\n        def on(self):\n    self.__run = True\n        threading.Thread(target = self.__update).start()\n        def off(self):\n    self.__run = False\n", "code_toks_joined": "def __init__ ( self ) : <NEWLINE> <INDENT> Sensor . __init__ ( self ) <NEWLINE> <INDENT> self . __value = 0.0 <NEWLINE> self . __prev_value = 0.0 <NEWLINE> self . __velocity = 0.0 <NEWLINE> self . __init_value = 0.0 <NEWLINE> self . __time = 0.0 <NEWLINE> def on ( self ) : <NEWLINE> <DEDENT> self . __run = True <NEWLINE> <INDENT> threading . Thread ( target = self . __update ) . start ( ) <NEWLINE> def off ( self ) : <NEWLINE> <DEDENT> self . __run = False <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["59a04a56cd7dc3b6327b94c0fbc5237e", {"code_string": "class SQLScalar(WikiMacroBase):\n    \"\"\"Output a number from a scalar (1x1) SQL query.\"\"\"\n    def render_macro(self, req, name, content):\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n        cursor.execute(content)\n        value = \"Unknown\"\n        for row in cursor:\n        value = unicode(row[0])\n        break\n        out = StringIO()\n        print(u\"<span class='wikiscalar'>%s</span>\" % value)\n        add_stylesheet(req, 'wikitable/css/wikitable.css')\n        return Markup(out.getvalue())\n", "code_toks_joined": "class SQLScalar ( WikiMacroBase ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def render_macro ( self , req , name , content ) : <NEWLINE> <INDENT> db = self . env . get_db_cnx ( ) <NEWLINE> cursor = db . cursor ( ) <NEWLINE> cursor . execute ( content ) <NEWLINE> value = <STRING> <NEWLINE> for row in cursor : <NEWLINE> value = unicode ( row [ 0 ] ) <NEWLINE> break <NEWLINE> out = StringIO ( ) <NEWLINE> print ( <STRING> % value ) <NEWLINE> add_stylesheet ( req , <STRING> ) <NEWLINE> return Markup ( out . getvalue ( ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Output a number from a scalar (1x1) SQL query.\"\"\"", "\"Unknown\"", "u\"<span class='wikiscalar'>%s</span>\"", "'wikitable/css/wikitable.css'"]}, "err_obj": {"msg": "expected an indented block"}}], ["1f44c6d20f7cf6fd8372c092590e3836", {"code_string": "def parse_snap(self, response):\n    item = response.meta['item']\n    item['STOCK_DAYSNAP'] = json.loads(response.body.decode('gbk'))['snap']\n    LINE_URL = self.LINE_URLAPI.format(item['COMPANY_CODE'])\n        return scrapy.Request(LINE_URL, callback = self.parse_line, meta = {'item': item})\n", "code_toks_joined": "def parse_snap ( self , response ) : <NEWLINE> <INDENT> item = response . meta [ <STRING> ] <NEWLINE> item [ <STRING> ] = json . loads ( response . body . decode ( <STRING> ) ) [ <STRING> ] <NEWLINE> LINE_URL = self . LINE_URLAPI . format ( item [ <STRING> ] ) <NEWLINE> <INDENT> return scrapy . Request ( LINE_URL , callback = self . parse_line , meta = { <STRING> : item } ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'item'", "'STOCK_DAYSNAP'", "'gbk'", "'snap'", "'COMPANY_CODE'", "'item'"]}, "err_obj": {"msg": "unexpected indent"}}], ["934bd63af4e608f4653206cd61101d12", {"code_string": "def _adjust_pad_volume(self, pads, action_arg):\n    \"\"\" Adjust/set pad volume \"\"\"\n    for pad in pads:\n        if pad.chains:\n        self._parent.do_parameter_adjustment(pad.chains[0].mixer_device.volume, action_arg)\n", "code_toks_joined": "def _adjust_pad_volume ( self , pads , action_arg ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for pad in pads : <NEWLINE> <INDENT> if pad . chains : <NEWLINE> self . _parent . do_parameter_adjustment ( pad . chains [ 0 ] . mixer_device . volume , action_arg ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Adjust/set pad volume \"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["ec0fd59f5cc45cf99e53000f77106573", {"code_string": "def __init__(self):\n    self.pub = rospy.Publisher(\"beat\", Vector3, queue_size = 10)\n        rospy.init_node(\"logitech_controller\", anonymous = True)\n        self.jsdev = joystick_read.connect(joyname)\n        self.x = 0\n        self.y = 0\n        self.z = 0\n        self.k = 25\n", "code_toks_joined": "def __init__ ( self ) : <NEWLINE> <INDENT> self . pub = rospy . Publisher ( <STRING> , Vector3 , queue_size = 10 ) <NEWLINE> <INDENT> rospy . init_node ( <STRING> , anonymous = True ) <NEWLINE> self . jsdev = joystick_read . connect ( joyname ) <NEWLINE> self . x = 0 <NEWLINE> self . y = 0 <NEWLINE> self . z = 0 <NEWLINE> self . k = 25 <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"beat\"", "\"logitech_controller\""]}, "err_obj": {"msg": "unexpected indent"}}], ["2cbd13011cda44d12e29c58db95a44c9", {"code_string": "import glob\nfor filename in glob.glob('*_test_case.py'):\n    exec 'from %s import *' % filename[: - 3]\nif __name__ == '__main__':\n    import unittest\n    unittest.main()\n", "code_toks_joined": "import glob <NEWLINE> for filename in glob . glob ( <STRING> ) : <NEWLINE> <INDENT> exec <STRING> % filename [ : - 3 ] <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import unittest <NEWLINE> unittest . main ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'*_test_case.py'", "'from %s import *'", "'__main__'"]}, "err_obj": {"msg": "invalid syntax"}}], ["e56f494a75bcac5dd9fde609e984b045", {"code_string": "def get_last_day(values, N = \"\", NoData = NoDataVal, Thres = 1.0):\n    \"\"\"This function determines the index of the last time the\"\"\"\n    if not N: N = len(values)\n    last_day = 0\n    Nact = 0\n    for i in range(N - 1, - 1, - 1):\n    if values[i] != NoData and values[i] > Thres:\n        last_day = i\n            break\n    return(last_day)\n", "code_toks_joined": "def get_last_day ( values , N = <STRING> , NoData = NoDataVal , Thres = 1.0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not N : N = len ( values ) <NEWLINE> last_day = 0 <NEWLINE> Nact = 0 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> if values [ i ] != NoData and values [ i ] > Thres : <NEWLINE> <INDENT> last_day = i <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return ( last_day ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"", "\"\"\"This function determines the index of the last time the\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["d6cdbd9d4a027957b6a184676e39e70a", {"code_string": "def backend_object_mode(self):\n    \"\"\"Object mode compilation\"\"\"\n    with self.giveup_context(\"Function %s failed at object mode lowering\"\n        %(self.func_id.func_name, )):\n        if len(self.args) != self.nargs:\n        self.args = (tuple(self.args) +(types.pyobject, ) *\n        (self.nargs - len(self.args)))\n        return py_lowering_stage(self.targetctx,\n            self.library,\n            self.func_ir,\n            self.flags)\n", "code_toks_joined": "def backend_object_mode ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with self . giveup_context ( <STRING> <NEWLINE> <INDENT> % ( self . func_id . func_name , ) ) : <NEWLINE> if len ( self . args ) != self . nargs : <NEWLINE> self . args = ( tuple ( self . args ) + ( types . pyobject , ) * <NEWLINE> ( self . nargs - len ( self . args ) ) ) <NEWLINE> return py_lowering_stage ( self . targetctx , <NEWLINE> <INDENT> self . library , <NEWLINE> self . func_ir , <NEWLINE> self . flags ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Object mode compilation\"\"\"", "\"Function %s failed at object mode lowering\""]}, "err_obj": {"msg": "expected an indented block"}}], ["c260cb688f46fbe3818311e546e3de72", {"code_string": "def __init__(self, jel):\n    self.hostname = jel['fqdn']\n    self.cluster = jel['cluster']\n    self.roles = [str(x).strip() for x in jel['roles'].split(',')]\n    if 'compute' in self.roles:\n        self.role = 'compute'\n    elif 'controller' in self.roles:\n        self.role = 'controller'\n            else:\n                self.role = 'ignore'\n    self.id = jel['id']\n    self.repolist = None\n", "code_toks_joined": "def __init__ ( self , jel ) : <NEWLINE> <INDENT> self . hostname = jel [ <STRING> ] <NEWLINE> self . cluster = jel [ <STRING> ] <NEWLINE> self . roles = [ str ( x ) . strip ( ) for x in jel [ <STRING> ] . split ( <STRING> ) ] <NEWLINE> if <STRING> in self . roles : <NEWLINE> <INDENT> self . role = <STRING> <NEWLINE> <DEDENT> elif <STRING> in self . roles : <NEWLINE> <INDENT> self . role = <STRING> <NEWLINE> <INDENT> else : <NEWLINE> <INDENT> self . role = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> self . id = jel [ <STRING> ] <NEWLINE> self . repolist = None <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'fqdn'", "'cluster'", "'roles'", "','", "'compute'", "'compute'", "'controller'", "'controller'", "'ignore'", "'id'"]}, "err_obj": {"msg": "unexpected indent"}}], ["bea2cf718e4ea310e4dc97e7b2bd0544", {"code_string": "def _onHideActionTriggered(self, checked = False):\n    plot = self._hideActions[id(self.sender()))]\n    self.hidePlot(plot)\n", "code_toks_joined": "def _onHideActionTriggered ( self , checked = False ) : <NEWLINE> <INDENT> plot = self . _hideActions [ id ( self . sender ( ) ) ) ] <NEWLINE> self . hidePlot ( plot ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["b69f3794b6b2533d29a1fd35e6d79640", {"code_string": "def update_graph_from_dropdown(dropdown multi):\n    ch = qm.get_symbol(dropdown, start = '2016/01/01')\n    if 'EMA' in multi:\n        ch.add_EMA()\n    if 'RSI' in multi:\n        ch.add_RSI()\n    if 'MACD' in multi:\n        ch.add_MACD()\n    if 'BBANDS' in multi:\n        ch.add_BBANDS()\n    return ch.to_figure()\n", "code_toks_joined": "def update_graph_from_dropdown ( dropdown multi ) : <NEWLINE> <INDENT> ch = qm . get_symbol ( dropdown , start = <STRING> ) <NEWLINE> if <STRING> in multi : <NEWLINE> <INDENT> ch . add_EMA ( ) <NEWLINE> <DEDENT> if <STRING> in multi : <NEWLINE> <INDENT> ch . add_RSI ( ) <NEWLINE> <DEDENT> if <STRING> in multi : <NEWLINE> <INDENT> ch . add_MACD ( ) <NEWLINE> <DEDENT> if <STRING> in multi : <NEWLINE> <INDENT> ch . add_BBANDS ( ) <NEWLINE> <DEDENT> return ch . to_figure ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'2016/01/01'", "'EMA'", "'RSI'", "'MACD'", "'BBANDS'"]}, "err_obj": {"msg": "invalid syntax"}}], ["f29a12daf24770f29edb15259da2c42b", {"code_string": "def set_http_debug(val):\n    global _http_debug\n    _http_debug = val\n    if identity:\n        identity.http_log_debug = val\n    for svc in(cloudservers, cloudfiles, cloud_loadbalancers,\n        cloud_blockstorage, cloud_databases, cloud_dns, cloud_networks,\n        autoscale, images, queues):\n        if svc is not None:\n        svc.http_log_debug = val\n", "code_toks_joined": "def set_http_debug ( val ) : <NEWLINE> <INDENT> global _http_debug <NEWLINE> _http_debug = val <NEWLINE> if identity : <NEWLINE> <INDENT> identity . http_log_debug = val <NEWLINE> <DEDENT> for svc in ( cloudservers , cloudfiles , cloud_loadbalancers , <NEWLINE> <INDENT> cloud_blockstorage , cloud_databases , cloud_dns , cloud_networks , <NEWLINE> autoscale , images , queues ) : <NEWLINE> if svc is not None : <NEWLINE> svc . http_log_debug = val <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["0c85152fa93bc6ee54ebae8e36309a38", {"code_string": "def delete_playlist(self):\n    self.playlist.lock()\n        for i in range(self.playlist.count()):\n            self.playlist.remove_index(0)\n        self.playlist.unlock()\n        self.create_random_playlist()\n", "code_toks_joined": "def delete_playlist ( self ) : <NEWLINE> <INDENT> self . playlist . lock ( ) <NEWLINE> <INDENT> for i in range ( self . playlist . count ( ) ) : <NEWLINE> <INDENT> self . playlist . remove_index ( 0 ) <NEWLINE> <DEDENT> self . playlist . unlock ( ) <NEWLINE> self . create_random_playlist ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["247b0a55f9a63d18d0aba407d9163d1b", {"code_string": "def fred_timer_start(s_timer_name):\n    \"\"\"Start a timer with the given name.\"\"\"\n    global GB_ENABLE_TIMINGS, gd_timers\n    if GB_ENABLE_TIMINGS:\n    gd_timers[s_timer_name] = time.time()\n        fred_debug(\"Starting timer '%s'.\" % s_timer_name)\n", "code_toks_joined": "def fred_timer_start ( s_timer_name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> global GB_ENABLE_TIMINGS , gd_timers <NEWLINE> if GB_ENABLE_TIMINGS : <NEWLINE> gd_timers [ s_timer_name ] = time . time ( ) <NEWLINE> <INDENT> fred_debug ( <STRING> % s_timer_name ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Start a timer with the given name.\"\"\"", "\"Starting timer '%s'.\""]}, "err_obj": {"msg": "expected an indented block"}}], ["09ffd6fb3d67cfc9b7373023fa7d3c32", {"code_string": "def get_temperature(self):\n    temperature = self.__send_relay_command__(commands['getTemperature'], True)\n    if temperature:\n    return temperature.rstrip()\n    else:\n    return False\n", "code_toks_joined": "def get_temperature ( self ) : <NEWLINE> <INDENT> temperature = self . __send_relay_command__ ( commands [ <STRING> ] , True ) <NEWLINE> if temperature : <NEWLINE> return temperature . rstrip ( ) <NEWLINE> else : <NEWLINE> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'getTemperature'"]}, "err_obj": {"msg": "expected an indented block"}}], ["e3ff03a4c7f61fa64144b74d59899f76", {"code_string": "def GetOption(self, name):\n    \"\"\"Return value of named option\"\"\"\n    return self._Options.GetValue(name)\n    def Conf(self, name, * values):\n    \"\"\"Set an option, via config file\"\"\"\n    self._Options.Conf(name, values)\n", "code_toks_joined": "def GetOption ( self , name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . _Options . GetValue ( name ) <NEWLINE> def Conf ( self , name , * values ) : <NEWLINE> <STRING> <NEWLINE> self . _Options . Conf ( name , values ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return value of named option\"\"\"", "\"\"\"Set an option, via config file\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["042f844504b5a1378806182240cee803", {"code_string": "def check_sphinx_version(expected_version):\n    sphinx_version = LooseVersion(sphinx.__version__)\n    expected_version = LooseVersion(expected_version)\n    if sphinx_version < expected_version:\n        raise RuntimeError(\n            \"At least Sphinx version{0}is required to build this \"\n            \"documentation.Found{1}.\".format(\n                expected_version, sphinx_version)\n", "code_toks_joined": "def check_sphinx_version ( expected_version ) : <NEWLINE> <INDENT> sphinx_version = LooseVersion ( sphinx . __version__ ) <NEWLINE> expected_version = LooseVersion ( expected_version ) <NEWLINE> if sphinx_version < expected_version : <NEWLINE> <INDENT> raise RuntimeError ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> . format ( <NEWLINE> <INDENT> expected_version , sphinx_version ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"At least Sphinx version{0}is required to build this \"", "\"documentation.Found{1}.\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["58a92a74b4b7cc8d5177a920189bfbe6", {"code_string": "def fix_nfs((node_id, instance_id, dns)):\n    key = get_key()\n    cmd = \"mount /home\"\n    if not ssh_command(key, dns, cmd):\n        print(\"FAILED\", node_id, instance_id, dns, \"NOT REACHABLE\")\n    return False\n", "code_toks_joined": "def fix_nfs ( ( node_id , instance_id , dns ) ) : <NEWLINE> <INDENT> key = get_key ( ) <NEWLINE> cmd = <STRING> <NEWLINE> if not ssh_command ( key , dns , cmd ) : <NEWLINE> <INDENT> print ( <STRING> , node_id , instance_id , dns , <STRING> ) <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"mount /home\"", "\"FAILED\"", "\"NOT REACHABLE\""]}, "err_obj": {"msg": "invalid syntax"}}], ["d07b40c9eaed7f24ad75bea770017332", {"code_string": "def Decode(self, hex):\n    plain = \"\"\n    cipher = hex.decode('hex').decode('rot13')\n    for i in range(len(cipher)):\n    plain += chr(ord(cipher[i]) ^(ord(\"S\")))\n    return plain\n", "code_toks_joined": "def Decode ( self , hex ) : <NEWLINE> <INDENT> plain = <STRING> <NEWLINE> cipher = hex . decode ( <STRING> ) . decode ( <STRING> ) <NEWLINE> for i in range ( len ( cipher ) ) : <NEWLINE> plain += chr ( ord ( cipher [ i ] ) ^ ( ord ( <STRING> ) ) ) <NEWLINE> return plain <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"", "'hex'", "'rot13'", "\"S\""]}, "err_obj": {"msg": "expected an indented block"}}], ["11b7bffbae21622a6d89483269b7f5c0", {"code_string": "def fix_indices(Is, Js, (M, N)):\n    Is[Is == M] = 0\n    Is[Is == - 1] = M - 1\n    Js[Js == N] = 0\n    Js[Js == - 1] = N - 1\n    return(Is, Js)\n", "code_toks_joined": "def fix_indices ( Is , Js , ( M , N ) ) : <NEWLINE> <INDENT> Is [ Is == M ] = 0 <NEWLINE> Is [ Is == - 1 ] = M - 1 <NEWLINE> Js [ Js == N ] = 0 <NEWLINE> Js [ Js == - 1 ] = N - 1 <NEWLINE> return ( Is , Js ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["272f5ca6d1fc4fa48eb4c44d019e2da8", {"code_string": "def checkBranches(self, starteip, endeip, op):\n    \"\"\"This routine gets the current branch list for this opcode, adds branch\"\"\"\n    ret = []\n    blist = op.getBranches(emu = self)\n    if len(blist) > 1:\n        for bva, bflags in blist:\n            if bva == None:\n                print(\"Unresolved branch even WITH an emulator?\")\n                continue\n            bpath = self.getBranchNode(self.curpath, bva)\n            ret.append((bva, bpath)\n    return ret\n", "code_toks_joined": "def checkBranches ( self , starteip , endeip , op ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = [ ] <NEWLINE> blist = op . getBranches ( emu = self ) <NEWLINE> if len ( blist ) > 1 : <NEWLINE> <INDENT> for bva , bflags in blist : <NEWLINE> <INDENT> if bva == None : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> bpath = self . getBranchNode ( self . curpath , bva ) <NEWLINE> ret . append ( ( bva , bpath ) <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"This routine gets the current branch list for this opcode, adds branch\"\"\"", "\"Unresolved branch even WITH an emulator?\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["3849705d9c10bd7832700c05bcf5c724", {"code_string": "class CLIP_UL_tracking_objects(UIList):\n    def draw_item(self, context, layout, data, item, icon,\n        active_data, active_propname, index):\n        tobj = item\n        if self.layout_type in{'DEFAULT', 'COMPACT'}:\n        layout.prop(tobj, \"name\", text = \"\", emboss = False,\n            icon = 'CAMERA_DATA' if tobj.is_camera\n            else 'OBJECT_DATA')\n            elif self.layout_type == 'GRID':\n            layout.alignment = 'CENTER'\n            layout.label(text = \"\",\n                icon = 'CAMERA_DATA' if tobj.is_camera\n                else 'OBJECT_DATA')\n", "code_toks_joined": "class CLIP_UL_tracking_objects ( UIList ) : <NEWLINE> <INDENT> def draw_item ( self , context , layout , data , item , icon , <NEWLINE> <INDENT> active_data , active_propname , index ) : <NEWLINE> tobj = item <NEWLINE> if self . layout_type in { <STRING> , <STRING> } : <NEWLINE> layout . prop ( tobj , <STRING> , text = <STRING> , emboss = False , <NEWLINE> <INDENT> icon = <STRING> if tobj . is_camera <NEWLINE> else <STRING> ) <NEWLINE> elif self . layout_type == <STRING> : <NEWLINE> layout . alignment = <STRING> <NEWLINE> layout . label ( text = <STRING> , <NEWLINE> <INDENT> icon = <STRING> if tobj . is_camera <NEWLINE> else <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'DEFAULT'", "'COMPACT'", "\"name\"", "\"\"", "'CAMERA_DATA'", "'OBJECT_DATA'", "'GRID'", "'CENTER'", "\"\"", "'CAMERA_DATA'", "'OBJECT_DATA'"]}, "err_obj": {"msg": "expected an indented block"}}], ["07e8077158abc69695c21b422d18db11", {"code_string": "from ex.common import *\nfrom ex.ioo import *\nif len(sys.argv) < 3:\n    print('''generated a html list of input files''')\n    sys.exit(1)\noutput = sys.argv[1]\nfiles = sys.argv[2: ]\nif os.path.exists(output):\n    print('Output file already exists.')\n    sys.exit(1)\nprint('Generating a list for {0} files...'.format(len(files))))\nfilelist = []\nfor f in files:\n    filelist.append('<a href=\"{0}\">{0}</a><br>'.format(f))\nhtml = '\\n'.join(filelist)\nhtml = '<html><body>' + html + '</body></html>'\nSaveText(output, html)\nlog.info('Result saved to {0}'.format(output))\n", "code_toks_joined": "from ex . common import * <NEWLINE> from ex . ioo import * <NEWLINE> if len ( sys . argv ) < 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> output = sys . argv [ 1 ] <NEWLINE> files = sys . argv [ 2 : ] <NEWLINE> if os . path . exists ( output ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> print ( <STRING> . format ( len ( files ) ) ) ) <NEWLINE> filelist = [ ] <NEWLINE> for f in files : <NEWLINE> <INDENT> filelist . append ( <STRING> . format ( f ) ) <NEWLINE> <DEDENT> html = <STRING> . join ( filelist ) <NEWLINE> html = <STRING> + html + <STRING> <NEWLINE> SaveText ( output , html ) <NEWLINE> log . info ( <STRING> . format ( output ) ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["'''generated a html list of input files'''", "'Output file already exists.'", "'Generating a list for {0} files...'", "'<a href=\"{0}\">{0}</a><br>'", "'\\n'", "'<html><body>'", "'</body></html>'", "'Result saved to {0}'"]}, "window_span": [82, 97], "err_obj": {"msg": "unbalanced (){}[]"}}], ["ecfc98e0e551e5d3c38c65dd302206c4", {"code_string": "def _get_pass_envs():\n    \"\"\"Pass external proxy information inside container for retrieval.\"\"\"\n    out = []\n    for proxyenv in[\"HTTP_PROXY\", \"http_proxy\", \"HTTPS_PROXY\", \"https_proxy\",\n        \"ALL_PROXY\", \"all_proxy\", \"FTP_PROXY\", \"ftp_proxy\",\n        \"RSYNC_PROXY\", \"rsync_proxy\",\n        \"AWS_ACCESS_KEY_ID\", \"AWS_SECRET_ACCESS_KEY\"]:\n        if proxyenv in os.environ:\n        out +=[\"-e\", \"%s=%s\" %(proxyenv, os.environ[proxyenv])]\n    return out\n", "code_toks_joined": "def _get_pass_envs ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> out = [ ] <NEWLINE> for proxyenv in [ <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> ] : <NEWLINE> if proxyenv in os . environ : <NEWLINE> out += [ <STRING> , <STRING> % ( proxyenv , os . environ [ proxyenv ] ) ] <NEWLINE> <DEDENT> return out <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Pass external proxy information inside container for retrieval.\"\"\"", "\"HTTP_PROXY\"", "\"http_proxy\"", "\"HTTPS_PROXY\"", "\"https_proxy\"", "\"ALL_PROXY\"", "\"all_proxy\"", "\"FTP_PROXY\"", "\"ftp_proxy\"", "\"RSYNC_PROXY\"", "\"rsync_proxy\"", "\"AWS_ACCESS_KEY_ID\"", "\"AWS_SECRET_ACCESS_KEY\"", "\"-e\"", "\"%s=%s\""]}, "err_obj": {"msg": "expected an indented block"}}], ["ed82687bd66057d6fae411f716823f96", {"code_string": "def write_submission():\n    with open(submission, 'w') as outfile:\n        outfile.write('id, click\\n')\n        for t, date, ID, x, y in data(test, D):\n            p = learner.predict(x)\n            outfile.write('%s, %s\\n' %(ID, str(p))\n", "code_toks_joined": "def write_submission ( ) : <NEWLINE> <INDENT> with open ( submission , <STRING> ) as outfile : <NEWLINE> <INDENT> outfile . write ( <STRING> ) <NEWLINE> for t , date , ID , x , y in data ( test , D ) : <NEWLINE> <INDENT> p = learner . predict ( x ) <NEWLINE> outfile . write ( <STRING> % ( ID , str ( p ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'w'", "'id, click\\n'", "'%s, %s\\n'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c36034809a5a61ef4a5dd9d3584ef6ce", {"code_string": "def __exit__(self, type, value, traceback):\n    if isinstance(value, LevMarError):\n    self.traceback = (type, value, traceback)\n    if isinstance(value, LinAlgError):\n    self.traceback = (type, value, traceback)\n    return isinstance(value, LevMarError) or isinstance(value, LinAlgError)\n", "code_toks_joined": "def __exit__ ( self , type , value , traceback ) : <NEWLINE> <INDENT> if isinstance ( value , LevMarError ) : <NEWLINE> self . traceback = ( type , value , traceback ) <NEWLINE> if isinstance ( value , LinAlgError ) : <NEWLINE> self . traceback = ( type , value , traceback ) <NEWLINE> return isinstance ( value , LevMarError ) or isinstance ( value , LinAlgError ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["75fb24bd0ecdae5efec9c0411b4ac069", {"code_string": "def testGetFailures02(self):\n    output = ('141.3.81.106', 4, 1124013539.0,\n        [u'Aug 14 11:%d:59 i60p295 sshd[12365]: Failed publickey for roehl from ::ffff:141.3.81.106 port 51332 ssh2'\n            % m for m in 53, 54, 57, 58])\n    self.filter.addLogPath(GetFailures.FILENAME_02)\n    self.filter.addFailRegex(\"Failed .* from <HOST>\")\n    self.filter.getFailures(GetFailures.FILENAME_02)\n    _assert_correct_last_attempt(self, self.filter, output)\n", "code_toks_joined": "def testGetFailures02 ( self ) : <NEWLINE> <INDENT> output = ( <STRING> , 4 , 1124013539.0 , <NEWLINE> <INDENT> [ <STRING> <NEWLINE> <INDENT> % m for m in 53 , 54 , 57 , 58 ] ) <NEWLINE> <DEDENT> <DEDENT> self . filter . addLogPath ( GetFailures . FILENAME_02 ) <NEWLINE> self . filter . addFailRegex ( <STRING> ) <NEWLINE> self . filter . getFailures ( GetFailures . FILENAME_02 ) <NEWLINE> _assert_correct_last_attempt ( self , self . filter , output ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'141.3.81.106'", "u'Aug 14 11:%d:59 i60p295 sshd[12365]: Failed publickey for roehl from ::ffff:141.3.81.106 port 51332 ssh2'", "\"Failed .* from <HOST>\""]}, "err_obj": {"msg": "invalid syntax"}}], ["6ecf29eaa04b13861a9149af1810fdb4", {"code_string": "def GET_PROGRAMS(self):\n    if self.debug_mode: print \"D8 addon: GET_PROGRAMS()\"\n    webcontent = self.get_webcontent(CAT_URL)\n    catalogue = json.loads(webcontent)\n    for categorie in catalogue:\n        if categorie['title'].encode('utf-8') == self.name:\n            programs = categorie['programs']\n            for program in programs:\n                title = program['title'].encode('utf-8')\n                self.add_item(title, self.name, 2)\n                if self.debug_mode:\n                    print \"D8 addon: Add programme \\\"%s\\\"\" % title\n", "code_toks_joined": "def GET_PROGRAMS ( self ) : <NEWLINE> <INDENT> if self . debug_mode : print <STRING> <NEWLINE> webcontent = self . get_webcontent ( CAT_URL ) <NEWLINE> catalogue = json . loads ( webcontent ) <NEWLINE> for categorie in catalogue : <NEWLINE> <INDENT> if categorie [ <STRING> ] . encode ( <STRING> ) == self . name : <NEWLINE> <INDENT> programs = categorie [ <STRING> ] <NEWLINE> for program in programs : <NEWLINE> <INDENT> title = program [ <STRING> ] . encode ( <STRING> ) <NEWLINE> self . add_item ( title , self . name , 2 ) <NEWLINE> if self . debug_mode : <NEWLINE> <INDENT> print <STRING> % title <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"D8 addon: GET_PROGRAMS()\"", "'title'", "'utf-8'", "'programs'", "'title'", "'utf-8'", "\"D8 addon: Add programme \\\"%s\\\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["fc44fdad39fc3a9342de90f75394822f", {"code_string": "def __init__(self, curve, curve_date, conn):\n    self.name = curve\n    self.curve_date = curve_date\n    self.iso_date = curve_date.ISO()\n    self.conn = conn\n    self.day_count_fraction = {\n        'Act360': ql.Actual360(),\n        'Act365Fixed': ql.Actual365Fixed(),\n        'ActAct': ql.ActualActual(),\n        'Bus252': ql.Business252(),\n        '30360': ql.Thirty360()\n    }\n    self.holiday_calendar = {\n    \"NYSE\": ql.UnitedStates(ql.UnitedStates.NYSE)\n    }\n    path = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'data/')\n    cursor = conn.cursor()\n    sql_statement = ('SELECT * FROM conventions '\n        'WHERE curve_name IS \"{curve}\"').format(** locals())\n    cursor.execute(sql_statement)\n    self.conventions = cursor.fetchone()\n    if self.conventions is None:\n        raise ValueError('No conventions exist for {self.name}'.format(** locals()))\n    sql_statement = ('SELECT * FROM rates_data '\n", "code_toks_joined": "def __init__ ( self , curve , curve_date , conn ) : <NEWLINE> <INDENT> self . name = curve <NEWLINE> self . curve_date = curve_date <NEWLINE> self . iso_date = curve_date . ISO ( ) <NEWLINE> self . conn = conn <NEWLINE> self . day_count_fraction = { <NEWLINE> <INDENT> <STRING> : ql . Actual360 ( ) , <NEWLINE> <STRING> : ql . Actual365Fixed ( ) , <NEWLINE> <STRING> : ql . ActualActual ( ) , <NEWLINE> <STRING> : ql . Business252 ( ) , <NEWLINE> <STRING> : ql . Thirty360 ( ) <NEWLINE> <DEDENT> } <NEWLINE> self . holiday_calendar = { <NEWLINE> <STRING> : ql . UnitedStates ( ql . UnitedStates . NYSE ) <NEWLINE> } <NEWLINE> path = os . path . join ( os . path . dirname ( os . path . dirname ( __file__ ) ) , <STRING> ) <NEWLINE> cursor = conn . cursor ( ) <NEWLINE> sql_statement = ( <STRING> <NEWLINE> <INDENT> <STRING> ) . format ( ** locals ( ) ) <NEWLINE> <DEDENT> cursor . execute ( sql_statement ) <NEWLINE> self . conventions = cursor . fetchone ( ) <NEWLINE> if self . conventions is None : <NEWLINE> <INDENT> raise ValueError ( <STRING> . format ( ** locals ( ) ) ) <NEWLINE> <DEDENT> sql_statement = ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Act360'", "'Act365Fixed'", "'ActAct'", "'Bus252'", "'30360'", "\"NYSE\"", "'data/'", "'SELECT * FROM conventions '", "'WHERE curve_name IS \"{curve}\"'", "'No conventions exist for {self.name}'", "'SELECT * FROM rates_data '"]}, "window_span": [213, 217], "err_obj": {"msg": "unbalanced (){}[]"}}], ["0a6c875fdd5a84bac6e11a6b9b2db4c2", {"code_string": "def _get_cache_size(self):\n    for size in self._size_dict.keys():\n        for row in self._cc.execute(\n            'select path from files where size == ?', (size, )):\n            if row[0] not in self._path_files:\n            file_list = self._size_dict.get(size, [])\n            self._size_dict[size] = [row[0]] + file_list\n", "code_toks_joined": "def _get_cache_size ( self ) : <NEWLINE> <INDENT> for size in self . _size_dict . keys ( ) : <NEWLINE> <INDENT> for row in self . _cc . execute ( <NEWLINE> <INDENT> <STRING> , ( size , ) ) : <NEWLINE> if row [ 0 ] not in self . _path_files : <NEWLINE> file_list = self . _size_dict . get ( size , [ ] ) <NEWLINE> self . _size_dict [ size ] = [ row [ 0 ] ] + file_list <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'select path from files where size == ?'"]}, "err_obj": {"msg": "expected an indented block"}}], ["b24c5f59b727ad3e906659f4bebf0fdf", {"code_string": "class{{modelname}}(CommonColumns):\n    __tablename__ = '{{modelname.lower()}}'\n    guid = Column(String(36), primary_key = True)\n", "code_toks_joined": "class { { modelname } } ( CommonColumns ) : <NEWLINE> <INDENT> __tablename__ = <STRING> <NEWLINE> guid = Column ( String ( 36 ) , primary_key = True ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'{{modelname.lower()}}'"]}, "err_obj": {"msg": "invalid syntax"}}], ["0bbf99fc8d5713808adf3efeab67ab2d", {"code_string": "def segments(self, precision = 0):\n    '''Return a list of segments, each segment is ended by a MoveTo.'''\n    ret = []\n    for moveTo, group in itertools.groupby(self.items,\n        lambda x: isinstance(x, MoveTo)):\n        if not moveTo:\n        seg = [x.segments(precision) for x in group]\n        ret.append(list(itertools.chain.from_iterable(seg)))\n    return ret\n", "code_toks_joined": "def segments ( self , precision = 0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = [ ] <NEWLINE> for moveTo , group in itertools . groupby ( self . items , <NEWLINE> <INDENT> lambda x : isinstance ( x , MoveTo ) ) : <NEWLINE> if not moveTo : <NEWLINE> seg = [ x . segments ( precision ) for x in group ] <NEWLINE> ret . append ( list ( itertools . chain . from_iterable ( seg ) ) ) <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Return a list of segments, each segment is ended by a MoveTo.'''"]}, "err_obj": {"msg": "expected an indented block"}}], ["50b87b5e5078067eed670ddac0345dab", {"code_string": "def check_if_ready_for_barracuda():\n    mariadb_variables = frappe._dict(frappe.db.sql(\"\"\"show variables\"\"\"))\n    for key, value in{\n        \"innodb_file_format\": \"Barracuda\",\n        \"innodb_file_per_table\": \"ON\",\n        \"innodb_large_prefix\": \"ON\",\n        \"character_set_server\": \"utf8mb4\",\n        \"collation_server\": \"utf8mb4_unicode_ci\"\n        }.items():\n        if mariadb_variables.get(key) != value:\n        print(\"=\" * 80)\n        print(\"Please add this to MariaDB's my.cnf and restart MariaDB before proceeding\")\n        print\n        print(expected_config_for_barracuda)\n        print(\"=\" * 80)\n        sys.exit(1)\n", "code_toks_joined": "def check_if_ready_for_barracuda ( ) : <NEWLINE> <INDENT> mariadb_variables = frappe . _dict ( frappe . db . sql ( <STRING> ) ) <NEWLINE> for key , value in { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> } . items ( ) : <NEWLINE> if mariadb_variables . get ( key ) != value : <NEWLINE> print ( <STRING> * 80 ) <NEWLINE> print ( <STRING> ) <NEWLINE> print <NEWLINE> print ( expected_config_for_barracuda ) <NEWLINE> print ( <STRING> * 80 ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"show variables\"\"\"", "\"innodb_file_format\"", "\"Barracuda\"", "\"innodb_file_per_table\"", "\"ON\"", "\"innodb_large_prefix\"", "\"ON\"", "\"character_set_server\"", "\"utf8mb4\"", "\"collation_server\"", "\"utf8mb4_unicode_ci\"", "\"=\"", "\"Please add this to MariaDB's my.cnf and restart MariaDB before proceeding\"", "\"=\""]}, "err_obj": {"msg": "expected an indented block"}}], ["48ff57a5b9dc6022aebd1843d8c9b6e5", {"code_string": "def __init__(self, * args, ** kwargs):\n    dict.__init__(self)\n    self._as_list = {}\n    self._last_key = None\n    if(len(args) == 1 and len(kwargs) == 0 and\n        isinstance(args[0], HTTPHeaders)):\n        for k, v in args[0].get_all():\n        self.add(k, v)\n    else:\n        self.update(* args, ** kwargs)\n", "code_toks_joined": "def __init__ ( self , * args , ** kwargs ) : <NEWLINE> <INDENT> dict . __init__ ( self ) <NEWLINE> self . _as_list = { } <NEWLINE> self . _last_key = None <NEWLINE> if ( len ( args ) == 1 and len ( kwargs ) == 0 and <NEWLINE> <INDENT> isinstance ( args [ 0 ] , HTTPHeaders ) ) : <NEWLINE> for k , v in args [ 0 ] . get_all ( ) : <NEWLINE> self . add ( k , v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . update ( * args , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["43815a84d1a070aa27e67d2aa4a701fc", {"code_string": "def indentfault():\n    asd(\n    indentback\n", "code_toks_joined": "def indentfault ( ) : <NEWLINE> <INDENT> asd ( <NEWLINE> indentback <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["b1d4f34f5cc4bff37dbd55dbaaff432f", {"code_string": "def setupUi(self, GameWindow):\n    GameWindow.setObjectName(\"GameWindow\")\n    GameWindow.resize(524, 353)\n    self.centralwidget = QtGui.QWidget(GameWindow)\n    self.centralwidget.setObjectName(\"centralwidget\")\n    self.horizontalLayout_4 = QtGui.QHBoxLayout(self.centralwidget)\n    self.horizontalLayout_4.setObjectName(\"horizontalLayout_4\")\n    self.horizontalLayout_2 = QtGui.QHBoxLayout()\n    self.horizontalLayout_2.setObjectName(\"horizontalLayout_2\")\n    self.verticalLayout = QtGui.QVBoxLayout()\n    self.verticalLayout.setObjectName(\"verticalLayout\")\n    self.vLayTarget = QtGui.QVBoxLayout()\n    self.vLayTarget.setObjectName(\"vLayTarget\")\n    self.horizontalLayout_3 = QtGui.QHBoxLayout()\n    self.horizontalLayout_3.setObjectName(\"horizontalLayout_3\")\n    self.lblName = QtGui.QLabel(self.centralwidget)\n    self.lblName.setObjectName(\"lblName\")\n    self.horizontalLayout_3.addWidget(self.lblName)\n    spacerItem = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)\n    self.horizontalLayout_3.addItem(spacerItem)\n    self.lblHeart = QtGui.QLabel(self.centralwidget)\n    self.lblHeart.setText(\"\")\n    self.lblHeart.setPixmap(QtGui.QPixmap(\"images/Heart.png\"))\n    self.lblHeart.setObjectName(\"lblHeart\")\n    self.horizontalLayout_3.addWidget(self.lblHeart)\n    self.lblHP = QtGui.QLabel(self.centralwidget)\n    self.lblHP.setObjectName(\"lblHP\")\n    self.horizontalLayout_3.addWidget(self.lblHP)\n    self.lblSword = QtGui.QLabel(self.centralwidget)\n    self.lblSword.setText(\"\")\n    self.lblSword.setPixmap(QtGui.QPixmap(\"images/Swords.png\"))\n    self.lblSword.setObjectName(\"lblSword\")\n    self.horizontalLayout_3.addWidget(self.lblSword)\n    self.lblVP = QtGui.QLabel(self.centralwidget)\n    self.lblVP.setObjectName(\"lblVP\")\n    self.horizontalLayout_3.addWidget(self.lblVP)\n    self.vLayTarget.addLayout(self.horizontalLayout_3)\n    self.listPlayer = QtGui.QTableWidget(self.centralwidget)\n    self.listPlayer.setEditTriggers(QtGui.QAbstractItemView.NoEditTriggers)\n    self.listPlayer.setAlternatingRowColors(True)\n    self.listPlayer.setObjectName(\"listPlayer\")\n    self.listPlayer.setColumnCount(3)\n    self.listPlayer.setRowCount(0)\n    item = QtGui.QTableWidgetItem()\n    self.listPlayer.setHorizontalHeaderItem(0, item)\n    item = QtGui.QTableWidgetItem()\n    self.listPlayer.setHorizontalHeaderItem(1, item)\n    item = QtGui.QTableWidgetItem()\n    self.listPlayer.setHorizontalHeaderItem(2, item)\n    self.vLayTarget.addWidget(self.listPlayer)\n    self.verticalLayout.addLayout(self.vLayTarget)\n    self.horizontalLayout = QtGui.QHBoxLayout()\n    self.horizontalLayout.setObjectName(\"horizontalLayout\")\n    self.verticalLayout.addLayout(self.horizontalLayout)\n    self.horizontalLayout_2.addLayout(self.verticalLayout)\n    self.vLayActions = QtGui.QVBoxLayout()\n    self.vLayActions.setObjectName(\"vLayActions\")\n    self.vLayAtk = QtGui.QVBoxLayout()\n    self.vLayAtk.setObjectName(\"vLayAtk\")\n    self.btnStrike = QtGui.QPushButton(self.centralwidget)\n    self.btnStrike.setStyleSheet(\"QPushButton \\n\"\n", "code_toks_joined": "def setupUi ( self , GameWindow ) : <NEWLINE> <INDENT> GameWindow . setObjectName ( <STRING> ) <NEWLINE> GameWindow . resize ( 524 , 353 ) <NEWLINE> self . centralwidget = QtGui . QWidget ( GameWindow ) <NEWLINE> self . centralwidget . setObjectName ( <STRING> ) <NEWLINE> self . horizontalLayout_4 = QtGui . QHBoxLayout ( self . centralwidget ) <NEWLINE> self . horizontalLayout_4 . setObjectName ( <STRING> ) <NEWLINE> self . horizontalLayout_2 = QtGui . QHBoxLayout ( ) <NEWLINE> self . horizontalLayout_2 . setObjectName ( <STRING> ) <NEWLINE> self . verticalLayout = QtGui . QVBoxLayout ( ) <NEWLINE> self . verticalLayout . setObjectName ( <STRING> ) <NEWLINE> self . vLayTarget = QtGui . QVBoxLayout ( ) <NEWLINE> self . vLayTarget . setObjectName ( <STRING> ) <NEWLINE> self . horizontalLayout_3 = QtGui . QHBoxLayout ( ) <NEWLINE> self . horizontalLayout_3 . setObjectName ( <STRING> ) <NEWLINE> self . lblName = QtGui . QLabel ( self . centralwidget ) <NEWLINE> self . lblName . setObjectName ( <STRING> ) <NEWLINE> self . horizontalLayout_3 . addWidget ( self . lblName ) <NEWLINE> spacerItem = QtGui . QSpacerItem ( 40 , 20 , QtGui . QSizePolicy . Expanding , QtGui . QSizePolicy . Minimum ) <NEWLINE> self . horizontalLayout_3 . addItem ( spacerItem ) <NEWLINE> self . lblHeart = QtGui . QLabel ( self . centralwidget ) <NEWLINE> self . lblHeart . setText ( <STRING> ) <NEWLINE> self . lblHeart . setPixmap ( QtGui . QPixmap ( <STRING> ) ) <NEWLINE> self . lblHeart . setObjectName ( <STRING> ) <NEWLINE> self . horizontalLayout_3 . addWidget ( self . lblHeart ) <NEWLINE> self . lblHP = QtGui . QLabel ( self . centralwidget ) <NEWLINE> self . lblHP . setObjectName ( <STRING> ) <NEWLINE> self . horizontalLayout_3 . addWidget ( self . lblHP ) <NEWLINE> self . lblSword = QtGui . QLabel ( self . centralwidget ) <NEWLINE> self . lblSword . setText ( <STRING> ) <NEWLINE> self . lblSword . setPixmap ( QtGui . QPixmap ( <STRING> ) ) <NEWLINE> self . lblSword . setObjectName ( <STRING> ) <NEWLINE> self . horizontalLayout_3 . addWidget ( self . lblSword ) <NEWLINE> self . lblVP = QtGui . QLabel ( self . centralwidget ) <NEWLINE> self . lblVP . setObjectName ( <STRING> ) <NEWLINE> self . horizontalLayout_3 . addWidget ( self . lblVP ) <NEWLINE> self . vLayTarget . addLayout ( self . horizontalLayout_3 ) <NEWLINE> self . listPlayer = QtGui . QTableWidget ( self . centralwidget ) <NEWLINE> self . listPlayer . setEditTriggers ( QtGui . QAbstractItemView . NoEditTriggers ) <NEWLINE> self . listPlayer . setAlternatingRowColors ( True ) <NEWLINE> self . listPlayer . setObjectName ( <STRING> ) <NEWLINE> self . listPlayer . setColumnCount ( 3 ) <NEWLINE> self . listPlayer . setRowCount ( 0 ) <NEWLINE> item = QtGui . QTableWidgetItem ( ) <NEWLINE> self . listPlayer . setHorizontalHeaderItem ( 0 , item ) <NEWLINE> item = QtGui . QTableWidgetItem ( ) <NEWLINE> self . listPlayer . setHorizontalHeaderItem ( 1 , item ) <NEWLINE> item = QtGui . QTableWidgetItem ( ) <NEWLINE> self . listPlayer . setHorizontalHeaderItem ( 2 , item ) <NEWLINE> self . vLayTarget . addWidget ( self . listPlayer ) <NEWLINE> self . verticalLayout . addLayout ( self . vLayTarget ) <NEWLINE> self . horizontalLayout = QtGui . QHBoxLayout ( ) <NEWLINE> self . horizontalLayout . setObjectName ( <STRING> ) <NEWLINE> self . verticalLayout . addLayout ( self . horizontalLayout ) <NEWLINE> self . horizontalLayout_2 . addLayout ( self . verticalLayout ) <NEWLINE> self . vLayActions = QtGui . QVBoxLayout ( ) <NEWLINE> self . vLayActions . setObjectName ( <STRING> ) <NEWLINE> self . vLayAtk = QtGui . QVBoxLayout ( ) <NEWLINE> self . vLayAtk . setObjectName ( <STRING> ) <NEWLINE> self . btnStrike = QtGui . QPushButton ( self . centralwidget ) <NEWLINE> self . btnStrike . setStyleSheet ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"GameWindow\"", "\"centralwidget\"", "\"horizontalLayout_4\"", "\"horizontalLayout_2\"", "\"verticalLayout\"", "\"vLayTarget\"", "\"horizontalLayout_3\"", "\"lblName\"", "\"\"", "\"images/Heart.png\"", "\"lblHeart\"", "\"lblHP\"", "\"\"", "\"images/Swords.png\"", "\"lblSword\"", "\"lblVP\"", "\"listPlayer\"", "\"horizontalLayout\"", "\"vLayActions\"", "\"vLayAtk\"", "\"QPushButton \\n\""]}, "window_span": [636, 640], "err_obj": {"msg": "unbalanced (){}[]"}}], ["6aa6b55d812652ff62aaed8265859ef0", {"code_string": "def startBeat(self, connection, request_handler):\n    beater = PeriodicCallback(None, self.heart_interval, IOLoop.instance())\n    def _beat():\n        if connection.connected is False:\n        beater.stop()\n        else:\n        request_handler.write(chr(messaging.StreamingMessage.NULL_BYTE))\n        request_handler.flush()\n        beater.callback = _beat\n        beater.start()\n", "code_toks_joined": "def startBeat ( self , connection , request_handler ) : <NEWLINE> <INDENT> beater = PeriodicCallback ( None , self . heart_interval , IOLoop . instance ( ) ) <NEWLINE> def _beat ( ) : <NEWLINE> <INDENT> if connection . connected is False : <NEWLINE> beater . stop ( ) <NEWLINE> else : <NEWLINE> request_handler . write ( chr ( messaging . StreamingMessage . NULL_BYTE ) ) <NEWLINE> request_handler . flush ( ) <NEWLINE> beater . callback = _beat <NEWLINE> beater . start ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["56667161cdbdadc353fca734d9ed2845", {"code_string": "def test_connect_put_node_timeout(self):\n    controller = proxy_server.ObjectController(self.app, 'a', 'c', 'o')\n    self.app.conn_timeout = 0.1\n    with set_http_connect(200, slow_connect = True):\n        nodes = [dict(ip = '', port = '', device = '')]\n        res = controller._connect_put_node(nodes, '', '', {}, ('', '')\n    self.assertTrue(res is None)\n", "code_toks_joined": "def test_connect_put_node_timeout ( self ) : <NEWLINE> <INDENT> controller = proxy_server . ObjectController ( self . app , <STRING> , <STRING> , <STRING> ) <NEWLINE> self . app . conn_timeout = 0.1 <NEWLINE> with set_http_connect ( 200 , slow_connect = True ) : <NEWLINE> <INDENT> nodes = [ dict ( ip = <STRING> , port = <STRING> , device = <STRING> ) ] <NEWLINE> res = controller . _connect_put_node ( nodes , <STRING> , <STRING> , { } , ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> self . assertTrue ( res is None ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'a'", "'c'", "'o'", "''", "''", "''", "''", "''", "''", "''"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["02e873d8c1d6f338d774417f13e23115", {"code_string": "def dice(self, (tag, start, stop, subtags), buffer):\n    \"\"\"This defines the actual dice being rolled\"\"\"\n    lex_log(\"def:            dice\")\n    lex_log(\"tag:           \" + str(tag))\n    lex_log(\"start:         \" + str(start))\n    lex_log(\"stop:          \" + str(stop))\n    lex_log(\"subtags:       \" + str(subtags))\n    lex_log(\"buffer:        \" + str(buffer))\n    lex_log(\"rolls:\")\n    return self.rollit((tag, start, stop, subtags), buffer)\n", "code_toks_joined": "def dice ( self , ( tag , start , stop , subtags ) , buffer ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> lex_log ( <STRING> ) <NEWLINE> lex_log ( <STRING> + str ( tag ) ) <NEWLINE> lex_log ( <STRING> + str ( start ) ) <NEWLINE> lex_log ( <STRING> + str ( stop ) ) <NEWLINE> lex_log ( <STRING> + str ( subtags ) ) <NEWLINE> lex_log ( <STRING> + str ( buffer ) ) <NEWLINE> lex_log ( <STRING> ) <NEWLINE> return self . rollit ( ( tag , start , stop , subtags ) , buffer ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"This defines the actual dice being rolled\"\"\"", "\"def:            dice\"", "\"tag:           \"", "\"start:         \"", "\"stop:          \"", "\"subtags:       \"", "\"buffer:        \"", "\"rolls:\""]}, "err_obj": {"msg": "invalid syntax"}}], ["2c23508e5c48a1c3addfef9b31034515", {"code_string": "def test_create_route_no_subnet_raises(self):\n    subnet = dict(id = 2, ip_policy = [], cidr = \"192.168.0.0/24\")\n    create_route = dict(id = 1, cidr = \"192.168.0.0/24\", gateway = \"192.168.0.1\")\n    with self._stubs(create_route = create_route, find_routes = [],\n        subnet = subnet):\n        with self.assertRaises(\n        exceptions.BadRequest):\n        self.plugin.create_route(self.context,\n            dict(route = create_route))\n", "code_toks_joined": "def test_create_route_no_subnet_raises ( self ) : <NEWLINE> <INDENT> subnet = dict ( id = 2 , ip_policy = [ ] , cidr = <STRING> ) <NEWLINE> create_route = dict ( id = 1 , cidr = <STRING> , gateway = <STRING> ) <NEWLINE> with self . _stubs ( create_route = create_route , find_routes = [ ] , <NEWLINE> <INDENT> subnet = subnet ) : <NEWLINE> with self . assertRaises ( <NEWLINE> exceptions . BadRequest ) : <NEWLINE> self . plugin . create_route ( self . context , <NEWLINE> <INDENT> dict ( route = create_route ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"192.168.0.0/24\"", "\"192.168.0.0/24\"", "\"192.168.0.1\""]}, "err_obj": {"msg": "expected an indented block"}}], ["bf3743dcbe5e72263092003284a98d9a", {"code_string": "def goBack(self):\n    if self.isAdvancedBladeActive():\n        self.setFocus(self.advancedButton)\n        else:\n        self.close()\n", "code_toks_joined": "def goBack ( self ) : <NEWLINE> <INDENT> if self . isAdvancedBladeActive ( ) : <NEWLINE> <INDENT> self . setFocus ( self . advancedButton ) <NEWLINE> else : <NEWLINE> self . close ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["6cd293fa8015cddf445927feb3d5872c", {"code_string": "def toggleScreen(value):\n    file = open(SCREEN, 'r')\n    current_status = int(file.read(1))\n        if current_status != value:\n        os.system(\"echo \" + str(value) + \" > \" + SCREEN)\n", "code_toks_joined": "def toggleScreen ( value ) : <NEWLINE> <INDENT> file = open ( SCREEN , <STRING> ) <NEWLINE> current_status = int ( file . read ( 1 ) ) <NEWLINE> <INDENT> if current_status != value : <NEWLINE> os . system ( <STRING> + str ( value ) + <STRING> + SCREEN ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'r'", "\"echo \"", "\" > \""]}, "err_obj": {"msg": "unexpected indent"}}], ["b5a53ce80a7f0c3ce56a91fc9a58849e", {"code_string": "class desktopui_BrowserTest(chrome_test.ChromeTestBase):\n    version = 1\n    binary_to_run = 'browser_tests'\n    blacklist = []\n    def run_once(self, group = 0, total_groups = 4):\n        tests_to_run = self.filter_bad_tests(\n            self.generate_test_list(self.binary_to_run, group, total_groups))\n        tests_to_run.extend(map(lambda(x): '-' + x, self.blacklist))\n        self.run_chrome_test(self.binary_to_run,\n            '--gtest_filter=%s' % ':'.join(tests_to_run))\n", "code_toks_joined": "class desktopui_BrowserTest ( chrome_test . ChromeTestBase ) : <NEWLINE> <INDENT> version = 1 <NEWLINE> binary_to_run = <STRING> <NEWLINE> blacklist = [ ] <NEWLINE> def run_once ( self , group = 0 , total_groups = 4 ) : <NEWLINE> <INDENT> tests_to_run = self . filter_bad_tests ( <NEWLINE> <INDENT> self . generate_test_list ( self . binary_to_run , group , total_groups ) ) <NEWLINE> <DEDENT> tests_to_run . extend ( map ( lambda ( x ) : <STRING> + x , self . blacklist ) ) <NEWLINE> self . run_chrome_test ( self . binary_to_run , <NEWLINE> <INDENT> <STRING> % <STRING> . join ( tests_to_run ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'browser_tests'", "'-'", "'--gtest_filter=%s'", "':'"]}, "err_obj": {"msg": "invalid syntax"}}], ["e15e34bfd61ff78616a5bc5e22240f94", {"code_string": "def html(file_name):\n    \"\"\"Loads and outputs file directrly to response stream\"\"\"\n        def html_decorator(func):\n            def func_wrapper(* args, ** kwargs):\n                self = args[0]\n                with open(file_name, 'r') as f:\n                    text = f.read()\n                    self.response.write(text)\n                func(* args, ** kwargs)\n            return func_wrapper\n        return html_decorator\n", "code_toks_joined": "def html ( file_name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> def html_decorator ( func ) : <NEWLINE> <INDENT> def func_wrapper ( * args , ** kwargs ) : <NEWLINE> <INDENT> self = args [ 0 ] <NEWLINE> with open ( file_name , <STRING> ) as f : <NEWLINE> <INDENT> text = f . read ( ) <NEWLINE> self . response . write ( text ) <NEWLINE> <DEDENT> func ( * args , ** kwargs ) <NEWLINE> <DEDENT> return func_wrapper <NEWLINE> <DEDENT> return html_decorator <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Loads and outputs file directrly to response stream\"\"\"", "'r'"]}, "err_obj": {"msg": "unexpected indent"}}], ["5f2838ded3cc81c4214e2f3549771fd3", {"code_string": "def main_list(params):\n    plugintools.log(\"kodicenter ===> \" + repr(params))\n        icon2 = \"https://pbs.twimg.com/profile_images/648985217529724928/eloz4kiW_200x200.png\"\n        plugintools.add_item(title = \"Nerd News\", url = base + \"channel/UCVTPXwVDI1Ab85guTAkE3Rw/\", thumbnail = icon2, folder = True)\n    xbmcplugin.setContent(int(sys.argv[1]), 'movies')\n    xbmc.executebuiltin('Container.SetViewMode(500)')\n", "code_toks_joined": "def main_list ( params ) : <NEWLINE> <INDENT> plugintools . log ( <STRING> + repr ( params ) ) <NEWLINE> <INDENT> icon2 = <STRING> <NEWLINE> plugintools . add_item ( title = <STRING> , url = base + <STRING> , thumbnail = icon2 , folder = True ) <NEWLINE> <DEDENT> xbmcplugin . setContent ( int ( sys . argv [ 1 ] ) , <STRING> ) <NEWLINE> xbmc . executebuiltin ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"kodicenter ===> \"", "\"https://pbs.twimg.com/profile_images/648985217529724928/eloz4kiW_200x200.png\"", "\"Nerd News\"", "\"channel/UCVTPXwVDI1Ab85guTAkE3Rw/\"", "'movies'", "'Container.SetViewMode(500)'"]}, "err_obj": {"msg": "unexpected indent"}}], ["77784e89579eff4e97687239d46db486", {"code_string": "class SMTPHandler(logging.handlers.SMTPHandler):\n    def __init__(self, mailhost, fromaddr, toaddrs, subject,\n        credentials = None, secure = None):\n        if secure is True:\n        secure = tuple()\n        super(SMTPHandler, self).__init__(mailhost, fromaddr, toaddrs,\n            subject, credentials, secure)\n            self.subject = subject\n    def getSubject(self, record):\n        now = datetime.datetime.now()\n        return now.strftime(self.subject)\n", "code_toks_joined": "class SMTPHandler ( logging . handlers . SMTPHandler ) : <NEWLINE> <INDENT> def __init__ ( self , mailhost , fromaddr , toaddrs , subject , <NEWLINE> <INDENT> credentials = None , secure = None ) : <NEWLINE> if secure is True : <NEWLINE> secure = tuple ( ) <NEWLINE> super ( SMTPHandler , self ) . __init__ ( mailhost , fromaddr , toaddrs , <NEWLINE> <INDENT> subject , credentials , secure ) <NEWLINE> self . subject = subject <NEWLINE> <DEDENT> <DEDENT> def getSubject ( self , record ) : <NEWLINE> <INDENT> now = datetime . datetime . now ( ) <NEWLINE> return now . strftime ( self . subject ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["7781400a95f0a2a6eac29d98ff061b5b", {"code_string": "def mapSimpleSequenceProperty(self, prop):\n    javaprop, javatype = self._createComplexJavaProp(prop)\n    values = []\n    if prop.hasValue():\n        for value in prop.value():\n            values.append(java.literal(value,\n                javatype,\n                complex = prop.isComplex()))\n                javaprop['javavalues'] = values\n    javaprop['isOptional'] = prop.isOptional()\n    return javaprop\n", "code_toks_joined": "def mapSimpleSequenceProperty ( self , prop ) : <NEWLINE> <INDENT> javaprop , javatype = self . _createComplexJavaProp ( prop ) <NEWLINE> values = [ ] <NEWLINE> if prop . hasValue ( ) : <NEWLINE> <INDENT> for value in prop . value ( ) : <NEWLINE> <INDENT> values . append ( java . literal ( value , <NEWLINE> <INDENT> javatype , <NEWLINE> complex = prop . isComplex ( ) ) ) <NEWLINE> javaprop [ <STRING> ] = values <NEWLINE> <DEDENT> <DEDENT> <DEDENT> javaprop [ <STRING> ] = prop . isOptional ( ) <NEWLINE> return javaprop <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'javavalues'", "'isOptional'"]}, "err_obj": {"msg": "unexpected indent"}}], ["f95373879a1f7726beaead606dc63c35", {"code_string": "class FIFOQueueWithTimeoutTest(tf.test.TestCase):\n    def testDequeueWithTimeout(self):\n        with self.test_session(\n            config = tf.ConfigProto(operation_timeout_in_ms = 20)) as sess:\n            q = tf.FIFOQueue(10, tf.float32)\n            dequeued_t = q.dequeue()\n            with self.assertRaisesRegexp(tf.errors.DeadlineExceededError,\n                \"Timed out waiting for notification\"):\n            sess.run(dequeued_t)\n", "code_toks_joined": "class FIFOQueueWithTimeoutTest ( tf . test . TestCase ) : <NEWLINE> <INDENT> def testDequeueWithTimeout ( self ) : <NEWLINE> <INDENT> with self . test_session ( <NEWLINE> <INDENT> config = tf . ConfigProto ( operation_timeout_in_ms = 20 ) ) as sess : <NEWLINE> q = tf . FIFOQueue ( 10 , tf . float32 ) <NEWLINE> dequeued_t = q . dequeue ( ) <NEWLINE> with self . assertRaisesRegexp ( tf . errors . DeadlineExceededError , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> <DEDENT> sess . run ( dequeued_t ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Timed out waiting for notification\""]}, "err_obj": {"msg": "expected an indented block"}}], ["a10d1af171ee6ec0d1a618885bbcfa5c", {"code_string": "def getCPULoad():\n    CPU_LOAD_LOC = \"/proc/loadavg\"\n        loadFile = open(CPU_LOAD_LOC)\n        cpuLoad = loadFile.read()\n        cpuLoad = cpuLoad.split()[0]\n        cpuLoad = long(float(cpuLoad))\n        print(\"The CPU temperature is: %.2f\" % cpuLoad)\n        return cpuLoad\n", "code_toks_joined": "def getCPULoad ( ) : <NEWLINE> <INDENT> CPU_LOAD_LOC = <STRING> <NEWLINE> <INDENT> loadFile = open ( CPU_LOAD_LOC ) <NEWLINE> cpuLoad = loadFile . read ( ) <NEWLINE> cpuLoad = cpuLoad . split ( ) [ 0 ] <NEWLINE> cpuLoad = long ( float ( cpuLoad ) ) <NEWLINE> print ( <STRING> % cpuLoad ) <NEWLINE> return cpuLoad <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"/proc/loadavg\"", "\"The CPU temperature is: %.2f\""]}, "err_obj": {"msg": "unexpected indent"}}], ["84b058dd1f52d2f23467e7090cb0dda8", {"code_string": "def mostrar_friends():\n    user = main.me()\n    friends = main.friends_ids(user.id)\n    for f in friends\n        name = main.get_user(f)\n        print(name)\n", "code_toks_joined": "def mostrar_friends ( ) : <NEWLINE> <INDENT> user = main . me ( ) <NEWLINE> friends = main . friends_ids ( user . id ) <NEWLINE> for f in friends <NEWLINE> <INDENT> name = main . get_user ( f ) <NEWLINE> print ( name ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["2ab95d670df2301749ea2876a5db85ce", {"code_string": "def _ConditionallyUploadToCloudStorage(self, img_name, page, tab, screenshot):\n    \"\"\"Uploads the screenshot to cloud storage as the reference image\"\"\"\n    if not self.options.refimg_cloud_storage_bucket:\n        raise Exception('--refimg-cloud-storage-bucket argument is required')\n    cloud_name = self._FormatReferenceImageName(img_name, page, tab)\n    if not cloud_storage.Exists(self.options.refimg_cloud_storage_bucket,\n        cloud_name):\n        self._UploadBitmapToCloudStorage(self.options.refimg_cloud_storage_bucket,\n            cloud_name,\n            screenshot)\n            return True\n    return False\n", "code_toks_joined": "def _ConditionallyUploadToCloudStorage ( self , img_name , page , tab , screenshot ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not self . options . refimg_cloud_storage_bucket : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> cloud_name = self . _FormatReferenceImageName ( img_name , page , tab ) <NEWLINE> if not cloud_storage . Exists ( self . options . refimg_cloud_storage_bucket , <NEWLINE> <INDENT> cloud_name ) : <NEWLINE> self . _UploadBitmapToCloudStorage ( self . options . refimg_cloud_storage_bucket , <NEWLINE> <INDENT> cloud_name , <NEWLINE> screenshot ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Uploads the screenshot to cloud storage as the reference image\"\"\"", "'--refimg-cloud-storage-bucket argument is required'"]}, "err_obj": {"msg": "unexpected indent"}}], ["56f95403238035c2d501ddfbf99936c8", {"code_string": "def set_computer_name(name):\n    '''Set the Windows computer name'''\n    if name:\n        name = name.decode('utf-8')\n    if windll.kernel32.SetComputerNameExW(win32con.ComputerNamePhysicalDnsHostname,\n        name):\n        ret = {'Computer Name': {'Current': get_computer_name()}}\n        pending = get_pending_computer_name()\n        if pending not in(None, False):\n        ret['Computer Name']['Pending'] = pending\n        return ret\n    return False\n", "code_toks_joined": "def set_computer_name ( name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if name : <NEWLINE> <INDENT> name = name . decode ( <STRING> ) <NEWLINE> <DEDENT> if windll . kernel32 . SetComputerNameExW ( win32con . ComputerNamePhysicalDnsHostname , <NEWLINE> <INDENT> name ) : <NEWLINE> ret = { <STRING> : { <STRING> : get_computer_name ( ) } } <NEWLINE> pending = get_pending_computer_name ( ) <NEWLINE> if pending not in ( None , False ) : <NEWLINE> ret [ <STRING> ] [ <STRING> ] = pending <NEWLINE> return ret <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Set the Windows computer name'''", "'utf-8'", "'Computer Name'", "'Current'", "'Computer Name'", "'Pending'"]}, "err_obj": {"msg": "expected an indented block"}}], ["0f22e8c68e863e8430f1cf798d919977", {"code_string": "class MetricsPlot(object):\n    def __init__(self, query_dict, plot_type, inverted_series, normalize_to,\n        drilldown_callback):\n        \"\"\"query_dict: dictionary containing the main query and the drilldown\"\"\"\n        self.query_dict = query_dict\n        if plot_type == 'Line':\n        self.is_line = True\n        elif plot_type == 'Bar':\n        self.is_line = False\n        else:\n        raise ValidationError({'plot': 'Plot must be either Line or Bar'})\n        self.plot_type = plot_type\n        self.inverted_series = inverted_series\n        self.normalize_to = normalize_to\n        if self.normalize_to is None:\n        self.normalize_to = ''\n        self.drilldown_callback = drilldown_callback\n", "code_toks_joined": "class MetricsPlot ( object ) : <NEWLINE> <INDENT> def __init__ ( self , query_dict , plot_type , inverted_series , normalize_to , <NEWLINE> <INDENT> drilldown_callback ) : <NEWLINE> <STRING> <NEWLINE> self . query_dict = query_dict <NEWLINE> if plot_type == <STRING> : <NEWLINE> self . is_line = True <NEWLINE> elif plot_type == <STRING> : <NEWLINE> self . is_line = False <NEWLINE> else : <NEWLINE> raise ValidationError ( { <STRING> : <STRING> } ) <NEWLINE> self . plot_type = plot_type <NEWLINE> self . inverted_series = inverted_series <NEWLINE> self . normalize_to = normalize_to <NEWLINE> if self . normalize_to is None : <NEWLINE> self . normalize_to = <STRING> <NEWLINE> self . drilldown_callback = drilldown_callback <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"query_dict: dictionary containing the main query and the drilldown\"\"\"", "'Line'", "'Bar'", "'plot'", "'Plot must be either Line or Bar'", "''"]}, "err_obj": {"msg": "expected an indented block"}}], ["64c5f0d5578555d99b45a7b722445914", {"code_string": "try:\n    from icu import Normalizer2, UNormalizationMode2\nexcept ImportError, e:\n    pass\nfrom unittest import main\nfrom BaseTokenStreamTestCase import BaseTokenStreamTestCase\n", "code_toks_joined": "try : <NEWLINE> <INDENT> from icu import Normalizer2 , UNormalizationMode2 <NEWLINE> <DEDENT> except ImportError , e : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> from unittest import main <NEWLINE> from BaseTokenStreamTestCase import BaseTokenStreamTestCase <NEWLINE>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["f6c0fc662afcde181b0cc2d213999c60", {"code_string": "def sliver_status(self, slice_urn, authority, options):\n    result = self.shell.SliverStatus(slice_urn)\n    return result\n        def get_expiration_date(slice_hrn, creds):\n            for cred in creds:\n                credential = Credential(string = cred)\n                    if credential.get_gid_caller().get_hrn() == slice_hrn:\n                        return credential.get_expiration()\n                        return None\n", "code_toks_joined": "def sliver_status ( self , slice_urn , authority , options ) : <NEWLINE> <INDENT> result = self . shell . SliverStatus ( slice_urn ) <NEWLINE> return result <NEWLINE> <INDENT> def get_expiration_date ( slice_hrn , creds ) : <NEWLINE> <INDENT> for cred in creds : <NEWLINE> <INDENT> credential = Credential ( string = cred ) <NEWLINE> <INDENT> if credential . get_gid_caller ( ) . get_hrn ( ) == slice_hrn : <NEWLINE> <INDENT> return credential . get_expiration ( ) <NEWLINE> return None <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["d47109e4087a261f6c1e2c92e899dcd2", {"code_string": "def collidewithladders(self, player):\n    for i in self.ladders:\n        if i != None and i.collidewithladder(self, player):\n        return 2\n    return 0\n", "code_toks_joined": "def collidewithladders ( self , player ) : <NEWLINE> <INDENT> for i in self . ladders : <NEWLINE> <INDENT> if i != None and i . collidewithladder ( self , player ) : <NEWLINE> return 2 <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["6d1f86266c120b7d0020f0d5fae53a97", {"code_string": "class LogoutRequest(Request):\n    def __init__(self, sec_context, receiver_addrs, log = None, timeslack = 0,\n        debug = 0):\n        Request.__init__(self, sec_context, receiver_addrs, log, timeslack,\n            debug)\n            self.signature_check = self.sec.correctly_signed_logout_request\n", "code_toks_joined": "class LogoutRequest ( Request ) : <NEWLINE> <INDENT> def __init__ ( self , sec_context , receiver_addrs , log = None , timeslack = 0 , <NEWLINE> <INDENT> debug = 0 ) : <NEWLINE> Request . __init__ ( self , sec_context , receiver_addrs , log , timeslack , <NEWLINE> <INDENT> debug ) <NEWLINE> self . signature_check = self . sec . correctly_signed_logout_request <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["adc262cbb4b24e8823b26abc0053dfa3", {"code_string": "def __init__(self, ticket_id, subject_id, , actor_id):\n    assert ticket_id\n    assert subject_id\n    assert actor_id\n    self.ticket_id = ticket_id\n    self.subject_id = subject_id\n    self.actor_id = actor_id\n", "code_toks_joined": "def __init__ ( self , ticket_id , subject_id , , actor_id ) : <NEWLINE> <INDENT> assert ticket_id <NEWLINE> assert subject_id <NEWLINE> assert actor_id <NEWLINE> self . ticket_id = ticket_id <NEWLINE> self . subject_id = subject_id <NEWLINE> self . actor_id = actor_id <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["92b167f4d551be529b0602a88de8480c", {"code_string": "class ReaderObserver(Observer):\n    \"\"\"ReaderObserver is a base abstract class for objects that are to be notified\"\"\"\n    def __init__(self):\n        pass\n    def update(self, observable, (addedreaders, removedreaders)):\n        \"\"\"Called upon reader insertion/removal.\"\"\"\n        pass\n", "code_toks_joined": "class ReaderObserver ( Observer ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def update ( self , observable , ( addedreaders , removedreaders ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"ReaderObserver is a base abstract class for objects that are to be notified\"\"\"", "\"\"\"Called upon reader insertion/removal.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["f41c7a23c3d9d5f3b756f1b822e9c3b6", {"code_string": "def print_paths(self):\n    for path in self.paths:\n        for pt in path:\n            print(str(pt[0]) + \", \" + str(pt[1])))\n", "code_toks_joined": "def print_paths ( self ) : <NEWLINE> <INDENT> for path in self . paths : <NEWLINE> <INDENT> for pt in path : <NEWLINE> <INDENT> print ( str ( pt [ 0 ] ) + <STRING> + str ( pt [ 1 ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\", \""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["9d62ce85851e9df5a0760443b5152459", {"code_string": "def optionGet(conffile, section, variable):\n    if(DEBUG == true): print \"get-Block: \"\n    print(cp.get(str(section), str(variable)))\n    return cp.get(str(section), str(variable))\n    if(DEBUG == true):\n        print \"end\"\n", "code_toks_joined": "def optionGet ( conffile , section , variable ) : <NEWLINE> <INDENT> if ( DEBUG == true ) : print <STRING> <NEWLINE> print ( cp . get ( str ( section ) , str ( variable ) ) ) <NEWLINE> return cp . get ( str ( section ) , str ( variable ) ) <NEWLINE> if ( DEBUG == true ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"get-Block: \"", "\"end\""]}, "err_obj": {"msg": "invalid syntax"}}], ["2cb33fc2f9621e4416766883aa63648d", {"code_string": "def buildCSSFile(filename, output_filename):\n    if verbose:\n    print(\"compiling \" + filename + \" to \" + output_filename)\n    with open(filename, \"r\") as myfile:\n        css = myfile.read()\n        minified_css = cssmin(css)\n        with open(output_filename, \"w\") as text_file:\n        text_file.write(minified_css)\n    return 0\n", "code_toks_joined": "def buildCSSFile ( filename , output_filename ) : <NEWLINE> <INDENT> if verbose : <NEWLINE> print ( <STRING> + filename + <STRING> + output_filename ) <NEWLINE> with open ( filename , <STRING> ) as myfile : <NEWLINE> <INDENT> css = myfile . read ( ) <NEWLINE> minified_css = cssmin ( css ) <NEWLINE> with open ( output_filename , <STRING> ) as text_file : <NEWLINE> text_file . write ( minified_css ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"compiling \"", "\" to \"", "\"r\"", "\"w\""]}, "err_obj": {"msg": "expected an indented block"}}], ["87dc60bddccfaef06909347c832a0b5d", {"code_string": "def get_property(property):\n    \"\"\"This should return the property from the properties file\"\"\"\n        return self.__properties_dict[property]\n", "code_toks_joined": "def get_property ( property ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> return self . __properties_dict [ property ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"This should return the property from the properties file\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["0b69de2bb6c72a3cfe981d58921beb83", {"code_string": "def collidewithladdersdown(self, player):\n    for i in self.ladders:\n        if i != None and i.collidewithladderdown(self, player):\n        return 2\n    return 0\n", "code_toks_joined": "def collidewithladdersdown ( self , player ) : <NEWLINE> <INDENT> for i in self . ladders : <NEWLINE> <INDENT> if i != None and i . collidewithladderdown ( self , player ) : <NEWLINE> return 2 <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["05f1f77843ac9f68bc49ab981b95c44a", {"code_string": "def copy_vm_console_logs(self, vm_name, dest_host):\n    local_log_paths = self._pathutils.get_vm_console_log_paths(\n        vm_name)\n    remote_log_paths = self._pathutils.get_vm_console_log_paths(\n        vm_name, remote_server = dest_host)\n    for local_log_path, remote_log_path in zip(local_log_paths,\n        remote_log_paths):\n        if self._pathutils.exists(local_log_path):\n        self._pathutils.copy(local_log_path,\n        remote_log_path)\n", "code_toks_joined": "def copy_vm_console_logs ( self , vm_name , dest_host ) : <NEWLINE> <INDENT> local_log_paths = self . _pathutils . get_vm_console_log_paths ( <NEWLINE> <INDENT> vm_name ) <NEWLINE> <DEDENT> remote_log_paths = self . _pathutils . get_vm_console_log_paths ( <NEWLINE> <INDENT> vm_name , remote_server = dest_host ) <NEWLINE> <DEDENT> for local_log_path , remote_log_path in zip ( local_log_paths , <NEWLINE> <INDENT> remote_log_paths ) : <NEWLINE> if self . _pathutils . exists ( local_log_path ) : <NEWLINE> self . _pathutils . copy ( local_log_path , <NEWLINE> remote_log_path ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["d39caf327845c6006600dc3dd3b4ddc6", {"code_string": "def get_events_conf(config, key, default = None):\n    \"\"\"Return a named [cylc][[events]] configuration.\"\"\"\n    for getter in[\n        config.cfg['cylc']['events'],\n        GLOBAL_CFG.get(['cylc', 'events'])]:\n        try:\n        value = getter[key]\n        except KeyError:\n        pass\n        else:\n        if value is not None:\n            return value\n    return default\n", "code_toks_joined": "def get_events_conf ( config , key , default = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for getter in [ <NEWLINE> <INDENT> config . cfg [ <STRING> ] [ <STRING> ] , <NEWLINE> GLOBAL_CFG . get ( [ <STRING> , <STRING> ] ) ] : <NEWLINE> try : <NEWLINE> value = getter [ key ] <NEWLINE> except KeyError : <NEWLINE> pass <NEWLINE> else : <NEWLINE> if value is not None : <NEWLINE> <INDENT> return value <NEWLINE> <DEDENT> <DEDENT> return default <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return a named [cylc][[events]] configuration.\"\"\"", "'cylc'", "'events'", "'cylc'", "'events'"]}, "err_obj": {"msg": "expected an indented block"}}], ["9c9e8c42be19040addb219b4d47b1e9b", {"code_string": "def build_features(a_templates, b_templates):\n    a_features = []\n    b_features = []\n    for template in a_templates:\n        for i in xrange(template.cardinality()):\n            a_features.append(template(i)))\n    for template in b_templates:\n        for i in xrange(template.cardinality()):\n            b_features.append(template(i))\n    return(a_features, b_features)\n", "code_toks_joined": "def build_features ( a_templates , b_templates ) : <NEWLINE> <INDENT> a_features = [ ] <NEWLINE> b_features = [ ] <NEWLINE> for template in a_templates : <NEWLINE> <INDENT> for i in xrange ( template . cardinality ( ) ) : <NEWLINE> <INDENT> a_features . append ( template ( i ) ) ) <NEWLINE> <DEDENT> <DEDENT> for template in b_templates : <NEWLINE> <INDENT> for i in xrange ( template . cardinality ( ) ) : <NEWLINE> <INDENT> b_features . append ( template ( i ) ) <NEWLINE> <DEDENT> <DEDENT> return ( a_features , b_features ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["43c4625ef740e628b2815439e3796fd4", {"code_string": "def test_nonascii_bytes_literals(self):\n    expected = \"non-ascii bytes literals not supported in 3.x\"\n    with check_py3k_warnings((expected, SyntaxWarning)):\n        exec \"b'\\xbd'\"\n", "code_toks_joined": "def test_nonascii_bytes_literals ( self ) : <NEWLINE> <INDENT> expected = <STRING> <NEWLINE> with check_py3k_warnings ( ( expected , SyntaxWarning ) ) : <NEWLINE> <INDENT> exec <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"non-ascii bytes literals not supported in 3.x\"", "\"b'\\xbd'\""]}, "err_obj": {"msg": "invalid syntax"}}], ["fe810a6ab7816f56f7112828f00a229a", {"code_string": "def _test_revamp():\n    ImportManager().install()\n    sys.path.insert(0, BuiltinImporter()))\n", "code_toks_joined": "def _test_revamp ( ) : <NEWLINE> <INDENT> ImportManager ( ) . install ( ) <NEWLINE> sys . path . insert ( 0 , BuiltinImporter ( ) ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["adb988d656a489bd9649b257abdb92e7", {"code_string": "class Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(_fromUtf8(\"Form\"))\n        Form.resize(104, 105)\n        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Maximum, QtGui.QSizePolicy.Maximum)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(Form.sizePolicy().hasHeightForWidth())\n        Form.setSizePolicy(sizePolicy)\n        Form.setMinimumSize(QtCore.QSize(100, 105))\n        Form.setMaximumSize(QtCore.QSize(104, 105))\n        font = QtGui.QFont()\n        font.setPointSize(10)\n        font.setBold(True)\n        font.setWeight(75)\n        Form.setFont(font)\n        Form.setStyleSheet(_fromUtf8(\"QFrame.PeripheralCollection{\\n\"\n", "code_toks_joined": "class Ui_Form ( object ) : <NEWLINE> <INDENT> def setupUi ( self , Form ) : <NEWLINE> <INDENT> Form . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> Form . resize ( 104 , 105 ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Maximum , QtGui . QSizePolicy . Maximum ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( Form . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> Form . setSizePolicy ( sizePolicy ) <NEWLINE> Form . setMinimumSize ( QtCore . QSize ( 100 , 105 ) ) <NEWLINE> Form . setMaximumSize ( QtCore . QSize ( 104 , 105 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setPointSize ( 10 ) <NEWLINE> font . setBold ( True ) <NEWLINE> font . setWeight ( 75 ) <NEWLINE> Form . setFont ( font ) <NEWLINE> Form . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Form\"", "\"QFrame.PeripheralCollection{\\n\""]}, "window_span": [159, 166], "err_obj": {"msg": "unbalanced (){}[]"}}], ["31f6717ab4592d3766fa443f00f2e9ee", {"code_string": "def TranslatePagespeed(self):\n    \"\"\"Translates pagespeed settings in appengine-web.xml to yaml.\"\"\"\n    pagespeed = self.app_engine_web_xml.pagespeed\n    if not pagespeed:\n        return[]\n    statements = ['pagespeed:']\n    for title, urls in[('domains_to_rewrite', pagespeed.domains_to_rewrite),\n        ('url_blacklist', pagespeed.url_blacklist),\n        ('enabled_rewriters', pagespeed.enabled_rewriters),\n        ('disabled_rewriters', pagespeed.disabled_rewriters)]:\n        if urls:\n        statements.append('  %s:' % title)\n        statements +=['  - %s' % url for url in urls]\n    return statements\n", "code_toks_joined": "def TranslatePagespeed ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> pagespeed = self . app_engine_web_xml . pagespeed <NEWLINE> if not pagespeed : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> statements = [ <STRING> ] <NEWLINE> for title , urls in [ ( <STRING> , pagespeed . domains_to_rewrite ) , <NEWLINE> <INDENT> ( <STRING> , pagespeed . url_blacklist ) , <NEWLINE> ( <STRING> , pagespeed . enabled_rewriters ) , <NEWLINE> ( <STRING> , pagespeed . disabled_rewriters ) ] : <NEWLINE> if urls : <NEWLINE> statements . append ( <STRING> % title ) <NEWLINE> statements += [ <STRING> % url for url in urls ] <NEWLINE> <DEDENT> return statements <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Translates pagespeed settings in appengine-web.xml to yaml.\"\"\"", "'pagespeed:'", "'domains_to_rewrite'", "'url_blacklist'", "'enabled_rewriters'", "'disabled_rewriters'", "'  %s:'", "'  - %s'"]}, "err_obj": {"msg": "expected an indented block"}}], ["feb9a68aec3629e7296bae02a79b35fe", {"code_string": "def collectOutput(c1, c2, output):\n    for i in range(len(output['output_locations'])):\n        iOutput = output['output_locations'][i]\n        iSubstance = output['output_substance'][i]\n        iLabel = output['output_labels'][i]\n        if(iSubstance == 1):\n            output['output_values'][iLabel].append(c1[iOutput])\n            else:\n            output['output_values'][iLabel].append(c2[iOutput])\n", "code_toks_joined": "def collectOutput ( c1 , c2 , output ) : <NEWLINE> <INDENT> for i in range ( len ( output [ <STRING> ] ) ) : <NEWLINE> <INDENT> iOutput = output [ <STRING> ] [ i ] <NEWLINE> iSubstance = output [ <STRING> ] [ i ] <NEWLINE> iLabel = output [ <STRING> ] [ i ] <NEWLINE> if ( iSubstance == 1 ) : <NEWLINE> <INDENT> output [ <STRING> ] [ iLabel ] . append ( c1 [ iOutput ] ) <NEWLINE> else : <NEWLINE> output [ <STRING> ] [ iLabel ] . append ( c2 [ iOutput ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'output_locations'", "'output_locations'", "'output_substance'", "'output_labels'", "'output_values'", "'output_values'"]}, "err_obj": {"msg": "invalid syntax"}}], ["d570366bb89b17d8844cf29bf9246978", {"code_string": "def subst(self, s):\n    '''Create a new Rule where substitution s has been substituted into both the head and goals.'''\n        new_head = subst(s, self.head)\n        new_goals = list(subst_conjunction(s, self.goals))\n        new_rule = Rule(new_head, new_goals, name = self.name, tv = self.tv,\n            formula = self.formula, match = self.match)\n        return new_rule\n", "code_toks_joined": "def subst ( self , s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> new_head = subst ( s , self . head ) <NEWLINE> new_goals = list ( subst_conjunction ( s , self . goals ) ) <NEWLINE> new_rule = Rule ( new_head , new_goals , name = self . name , tv = self . tv , <NEWLINE> <INDENT> formula = self . formula , match = self . match ) <NEWLINE> <DEDENT> return new_rule <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Create a new Rule where substitution s has been substituted into both the head and goals.'''"]}, "err_obj": {"msg": "unexpected indent"}}], ["b37be0de0b08ae03b7dc2c3012343346", {"code_string": "def _download_file(uri, filename):\n    try:\n        with open(filename, 'wb') as handle:\n            request = requests.get(uri, stream = True)\n            for block in request.iter_content(1024):\n                if not block:\n                    break\n                handle.write(block)\n    except IOError, e:\n        print(e)\n", "code_toks_joined": "def _download_file ( uri , filename ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> with open ( filename , <STRING> ) as handle : <NEWLINE> <INDENT> request = requests . get ( uri , stream = True ) <NEWLINE> for block in request . iter_content ( 1024 ) : <NEWLINE> <INDENT> if not block : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> handle . write ( block ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except IOError , e : <NEWLINE> <INDENT> print ( e ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'wb'"]}, "err_obj": {"msg": "invalid syntax"}}], ["7071279a84493b2625b430dd3e4bb186", {"code_string": "class Ui_gpsDialog(object):\n    def setupUi(self, gpsDialog):\n        gpsDialog.setObjectName(_fromUtf8(\"gpsDialog\"))\n        gpsDialog.resize(595, 300)\n        gpsDialog.setStyleSheet(_fromUtf8(\"#gpsDialog{\\n\"\n", "code_toks_joined": "class Ui_gpsDialog ( object ) : <NEWLINE> <INDENT> def setupUi ( self , gpsDialog ) : <NEWLINE> <INDENT> gpsDialog . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> gpsDialog . resize ( 595 , 300 ) <NEWLINE> gpsDialog . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"gpsDialog\"", "\"#gpsDialog{\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["57bbc8f22b6ca8ea6983f8928b44b711", {"code_string": "def _recursive_delete(self, reg, start_path, end_path):\n    try:\n        while(len(start_path) < len(end_path)):\n            _winreg.DeleteKey(reg, end_path)\n            end_path = end_path[0: end_path.rfind('\\\\')]\n    except Exception, e:\n        pass\n", "code_toks_joined": "def _recursive_delete ( self , reg , start_path , end_path ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> while ( len ( start_path ) < len ( end_path ) ) : <NEWLINE> <INDENT> _winreg . DeleteKey ( reg , end_path ) <NEWLINE> end_path = end_path [ 0 : end_path . rfind ( <STRING> ) ] <NEWLINE> <DEDENT> <DEDENT> except Exception , e : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'\\\\'"]}, "err_obj": {"msg": "invalid syntax"}}], ["f23b2f7ecd167335f10f84f2150c6ba0", {"code_string": "def get_measurement_no(self, number):\n    \"Returns measurement_byte_number\"\n    if not 0 <= number < 8:\n        raise ValueError('Measurements are numbered 0 to 7, not ' + str(number)\n    base_address, format = self.I2C_ADDRESS['measurement_byte_0']\n    return self._i2c_query(base_address + number, format)[0]\n", "code_toks_joined": "def get_measurement_no ( self , number ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not 0 <= number < 8 : <NEWLINE> <INDENT> raise ValueError ( <STRING> + str ( number ) <NEWLINE> <DEDENT> base_address , format = self . I2C_ADDRESS [ <STRING> ] <NEWLINE> return self . _i2c_query ( base_address + number , format ) [ 0 ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Returns measurement_byte_number\"", "'Measurements are numbered 0 to 7, not '", "'measurement_byte_0'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["35d0c81acb0b305c15a127828b13245c", {"code_string": "def run_lstm(self, init_state, input_vecs):\n    s = init_state\n    out_vectors = []\n    for vector in input_vecs:\n    x_t = lookup(self.input_lookup, int(vector))\n        s = s.add_input(x_t)\n        out_vector = s.output()\n        out_vectors.append(out_vector)\n    return out_vectors\n", "code_toks_joined": "def run_lstm ( self , init_state , input_vecs ) : <NEWLINE> <INDENT> s = init_state <NEWLINE> out_vectors = [ ] <NEWLINE> for vector in input_vecs : <NEWLINE> x_t = lookup ( self . input_lookup , int ( vector ) ) <NEWLINE> <INDENT> s = s . add_input ( x_t ) <NEWLINE> out_vector = s . output ( ) <NEWLINE> out_vectors . append ( out_vector ) <NEWLINE> <DEDENT> return out_vectors <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["2d7f8c1a989af7ad1e6e8952281d212d", {"code_string": "class TransmitThread(threading.Thread):\n    def get_message(self):\n        return \"\"\"have you ever went over a friends house to eat\"\"\"\n    def run(self):\n        morsecodelib.sound.config.config.WORDS_PER_MINUTE = 20\n        laser = laserControl.LaserController()\n        with laser:\n            morse = laserControl.MorseRenderLaser(laser)\n            morse.text_to_sound(self.get_message()\n", "code_toks_joined": "class TransmitThread ( threading . Thread ) : <NEWLINE> <INDENT> def get_message ( self ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> def run ( self ) : <NEWLINE> <INDENT> morsecodelib . sound . config . config . WORDS_PER_MINUTE = 20 <NEWLINE> laser = laserControl . LaserController ( ) <NEWLINE> with laser : <NEWLINE> <INDENT> morse = laserControl . MorseRenderLaser ( laser ) <NEWLINE> morse . text_to_sound ( self . get_message ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"have you ever went over a friends house to eat\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["f785ee4e5aba18ef43b8d2ee2208f3f6", {"code_string": "class IdentifyGate(Task):\n    \"\"\"Finish when we can see a good enough amount of the gate\"\"\"\n    min_bbar_width = 0.3\n    def on_first_run(self, vision):\n        self.seen_cons_check = ConsistencyCheck(4, 5)\n    def on_run(self, vision):\n        self.seen_cons_check.add(vision.bottom is not None and\n        if self.seen_cons_check.check():\n            self.finish()\n", "code_toks_joined": "class IdentifyGate ( Task ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> min_bbar_width = 0.3 <NEWLINE> def on_first_run ( self , vision ) : <NEWLINE> <INDENT> self . seen_cons_check = ConsistencyCheck ( 4 , 5 ) <NEWLINE> <DEDENT> def on_run ( self , vision ) : <NEWLINE> <INDENT> self . seen_cons_check . add ( vision . bottom is not None and <NEWLINE> if self . seen_cons_check . check ( ) : <NEWLINE> <INDENT> self . finish ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Finish when we can see a good enough amount of the gate\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["863a2cf8df2c21935ef25592097d61cf", {"code_string": "def get_hspl(self, target = None, editor = None, token = None):\n    url = self.base_URL + 'HSPL/'\n    params = {}\n        if token is not None:\n            params['token'] = token\n    if target is not None:\n        params['target'] = target\n    if editor is not None:\n        params['editor'] = editor\n    return get(url, params = params)\n", "code_toks_joined": "def get_hspl ( self , target = None , editor = None , token = None ) : <NEWLINE> <INDENT> url = self . base_URL + <STRING> <NEWLINE> params = { } <NEWLINE> <INDENT> if token is not None : <NEWLINE> <INDENT> params [ <STRING> ] = token <NEWLINE> <DEDENT> <DEDENT> if target is not None : <NEWLINE> <INDENT> params [ <STRING> ] = target <NEWLINE> <DEDENT> if editor is not None : <NEWLINE> <INDENT> params [ <STRING> ] = editor <NEWLINE> <DEDENT> return get ( url , params = params ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'HSPL/'", "'token'", "'target'", "'editor'"]}, "err_obj": {"msg": "unexpected indent"}}], ["613ab268bc9e7a90c72de3bdbf3dfd5f", {"code_string": "class HandleMessage(Thread):\n    \"\"\" Class that process the message and calls appropiate handling method \"\"\"\n        def __init__(self, report_object, received, addr):\n            Thread.__init__(self)\n            self.received = received\n            self.src_address = addr[0]\n            self.response_port = 23456\n            self.bw_for_new_flows = 0.1\n            self.report_object = report_object\n        def run(self):\n            self.report_object.message_from_controller(self.received)\n", "code_toks_joined": "class HandleMessage ( Thread ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> def __init__ ( self , report_object , received , addr ) : <NEWLINE> <INDENT> Thread . __init__ ( self ) <NEWLINE> self . received = received <NEWLINE> self . src_address = addr [ 0 ] <NEWLINE> self . response_port = 23456 <NEWLINE> self . bw_for_new_flows = 0.1 <NEWLINE> self . report_object = report_object <NEWLINE> <DEDENT> def run ( self ) : <NEWLINE> <INDENT> self . report_object . message_from_controller ( self . received ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Class that process the message and calls appropiate handling method \"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["a02c609251092b86db0547cfcf719344", {"code_string": "def test_classifyKind(self):\n    aPath = \"/MyProject1/library/aae/mvc/Controller.php\"\n        fc = TemplateFileCreator(aPath)\n        expectedKind = \"class\"\n        result = fc.classifyKind()\n        self.assertEqual(expectedKind, result)\n", "code_toks_joined": "def test_classifyKind ( self ) : <NEWLINE> <INDENT> aPath = <STRING> <NEWLINE> <INDENT> fc = TemplateFileCreator ( aPath ) <NEWLINE> expectedKind = <STRING> <NEWLINE> result = fc . classifyKind ( ) <NEWLINE> self . assertEqual ( expectedKind , result ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"/MyProject1/library/aae/mvc/Controller.php\"", "\"class\""]}, "err_obj": {"msg": "unexpected indent"}}], ["9e44afff97ef213dcf58209bc201fe72", {"code_string": "class Nivel(models.Model):\n    nombre = models.CharField(, max_length = 50)\n    margen = models.PositiveSmallIntegerField()\n        class Meta:\n            verbose_name = _('Nivel')\n            verbose_name_plural = _('Niveles')\n        def __unicode__(self):\n            return self.nombre\n", "code_toks_joined": "class Nivel ( models . Model ) : <NEWLINE> <INDENT> nombre = models . CharField ( , max_length = 50 ) <NEWLINE> margen = models . PositiveSmallIntegerField ( ) <NEWLINE> <INDENT> class Meta : <NEWLINE> <INDENT> verbose_name = _ ( <STRING> ) <NEWLINE> verbose_name_plural = _ ( <STRING> ) <NEWLINE> <DEDENT> def __unicode__ ( self ) : <NEWLINE> <INDENT> return self . nombre <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Nivel'", "'Niveles'"]}, "err_obj": {"msg": "invalid syntax"}}], ["fb2b91b42031ffff809733c0d39dbe7c", {"code_string": "class CANDaemon(threading.Thread):\n    log = None\n    def __init__(self):\n        threading.Thread.__init__(self)\n        self.setDaemon(True)\n        self.log = logging.getLogger('digilogger')\n    def run(self):\n    self.log.debug(\"CANDaemon started\")\n        can_process()\n        self.log.debug(\"CANDaemon exited.\")\n", "code_toks_joined": "class CANDaemon ( threading . Thread ) : <NEWLINE> <INDENT> log = None <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> threading . Thread . __init__ ( self ) <NEWLINE> self . setDaemon ( True ) <NEWLINE> self . log = logging . getLogger ( <STRING> ) <NEWLINE> <DEDENT> def run ( self ) : <NEWLINE> self . log . debug ( <STRING> ) <NEWLINE> <INDENT> can_process ( ) <NEWLINE> self . log . debug ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'digilogger'", "\"CANDaemon started\"", "\"CANDaemon exited.\""]}, "err_obj": {"msg": "expected an indented block"}}], ["c16dd13a31e5b2a871589b47a3477651", {"code_string": "class Command(BaseCommand):\n    args = '<directory ...>'\n    help = 'Imports some directories in to the music database.'\n    def handle(self, * args, ** options):\n        for directory in args:\n        self.stdout.write('Scanning \"%s\" for music files...\\n' % directory)\n        scan_dir_for_new_songs(directory, verbose = True)\n", "code_toks_joined": "class Command ( BaseCommand ) : <NEWLINE> <INDENT> args = <STRING> <NEWLINE> help = <STRING> <NEWLINE> def handle ( self , * args , ** options ) : <NEWLINE> <INDENT> for directory in args : <NEWLINE> self . stdout . write ( <STRING> % directory ) <NEWLINE> scan_dir_for_new_songs ( directory , verbose = True ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'<directory ...>'", "'Imports some directories in to the music database.'", "'Scanning \"%s\" for music files...\\n'"]}, "err_obj": {"msg": "expected an indented block"}}], ["6998421788e99677d81a74daca7d35ef", {"code_string": "def get_file_size(file_obj):\n    \"\"\"Analyze file-like object and attempt to determine its size.\"\"\"\n    if(hasattr(file_obj, 'seek') and hasattr(file_obj, 'tell') and\n        (six.PY2 or six.PY3 and file_obj.seekable())):\n        try:\n        curr = file_obj.tell()\n        file_obj.seek(0, os.SEEK_END)\n        size = file_obj.tell()\n        file_obj.seek(curr)\n        return size\n        except IOError as e:\n        if e.errno == errno.ESPIPE:\n            return\n        else:\n            raise\n", "code_toks_joined": "def get_file_size ( file_obj ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( hasattr ( file_obj , <STRING> ) and hasattr ( file_obj , <STRING> ) and <NEWLINE> <INDENT> ( six . PY2 or six . PY3 and file_obj . seekable ( ) ) ) : <NEWLINE> try : <NEWLINE> curr = file_obj . tell ( ) <NEWLINE> file_obj . seek ( 0 , os . SEEK_END ) <NEWLINE> size = file_obj . tell ( ) <NEWLINE> file_obj . seek ( curr ) <NEWLINE> return size <NEWLINE> except IOError as e : <NEWLINE> if e . errno == errno . ESPIPE : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Analyze file-like object and attempt to determine its size.\"\"\"", "'seek'", "'tell'"]}, "err_obj": {"msg": "expected an indented block"}}], ["99930fc27f877906b4be6632d453594d", {"code_string": "def set_wizard_text(self, text):\n    try:\n        self.getControl(self.wizTextbox).setText(text)\n    except Exception, e:\n        self.oe.dbg_log('oeWindows.wizard::set_wizard_text()',\n            'ERROR: (' + repr(e) + ')')\n", "code_toks_joined": "def set_wizard_text ( self , text ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . getControl ( self . wizTextbox ) . setText ( text ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> self . oe . dbg_log ( <STRING> , <NEWLINE> <INDENT> <STRING> + repr ( e ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'oeWindows.wizard::set_wizard_text()'", "'ERROR: ('", "')'"]}, "err_obj": {"msg": "invalid syntax"}}], ["e02b506f1ae86d3a42eabb8ca240a5fd", {"code_string": "class Logging:\n    \"\"\"A super-simple logging class\"\"\"\n    def error(self, msg):\n        print \"ERROR: \", msg\n    def warn(self, msg):\n        print \"WARNING: \", msg\n    def info(self, msg): print msg\n    def debug(self, msg): self.vlog(1, msg)\n    def vlog(self, level, msg):\n        if FLAGS.v >= level: print msg\n", "code_toks_joined": "class Logging : <NEWLINE> <INDENT> <STRING> <NEWLINE> def error ( self , msg ) : <NEWLINE> <INDENT> print <STRING> , msg <NEWLINE> <DEDENT> def warn ( self , msg ) : <NEWLINE> <INDENT> print <STRING> , msg <NEWLINE> <DEDENT> def info ( self , msg ) : print msg <NEWLINE> def debug ( self , msg ) : self . vlog ( 1 , msg ) <NEWLINE> def vlog ( self , level , msg ) : <NEWLINE> <INDENT> if FLAGS . v >= level : print msg <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"A super-simple logging class\"\"\"", "\"ERROR: \"", "\"WARNING: \""]}, "err_obj": {"msg": "invalid syntax"}}], ["7bddbef035bb94beeb4e644fbb57d3b1", {"code_string": "def start(self, tb):\n    if tb is None:\n        fn, args = self.set_trace, ()\n    else:\n        fn, args = self.post_mortem, (tb, )\n    try:\n        t = self.translator\n        exec \"\"\n        locals().update(self.exposed)\n        fn(* args)\n        pass\n    except bdb.BdbQuit:\n        pass\n", "code_toks_joined": "def start ( self , tb ) : <NEWLINE> <INDENT> if tb is None : <NEWLINE> <INDENT> fn , args = self . set_trace , ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fn , args = self . post_mortem , ( tb , ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> t = self . translator <NEWLINE> exec <STRING> <NEWLINE> locals ( ) . update ( self . exposed ) <NEWLINE> fn ( * args ) <NEWLINE> pass <NEWLINE> <DEDENT> except bdb . BdbQuit : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["3f09b753b9fa761c7acd73b8a2ed0ed1", {"code_string": "def check_program(p):\n    for d in os.getenv('PATH').split(':'):\n    if os.path.exists(os.path.join(d, p)):\n        return True\n    return False\n", "code_toks_joined": "def check_program ( p ) : <NEWLINE> <INDENT> for d in os . getenv ( <STRING> ) . split ( <STRING> ) : <NEWLINE> if os . path . exists ( os . path . join ( d , p ) ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'PATH'", "':'"]}, "err_obj": {"msg": "expected an indented block"}}], ["f901f194f324d06cdff9b5a5626e0a74", {"code_string": "class SqliteDict(proxydict.JsonProxyDict):\n    def __init__(self, path = \":memory:\", table = \"dict\",\n        isolation_level = \"DEFERRED\", * args, ** kwargs):\n        target = SqliteStringDict(path, table = table,\n            isolation_level = isolation_level)\n            super(proxydict.JsonProxyDict, self).__init__(target)\n            self.update(dict(* args, ** kwargs))\n    def copy(self):\n        t = self.target\n        return SqliteDict(t.path, t.table, t.isolation_level)\n", "code_toks_joined": "class SqliteDict ( proxydict . JsonProxyDict ) : <NEWLINE> <INDENT> def __init__ ( self , path = <STRING> , table = <STRING> , <NEWLINE> <INDENT> isolation_level = <STRING> , * args , ** kwargs ) : <NEWLINE> target = SqliteStringDict ( path , table = table , <NEWLINE> <INDENT> isolation_level = isolation_level ) <NEWLINE> super ( proxydict . JsonProxyDict , self ) . __init__ ( target ) <NEWLINE> self . update ( dict ( * args , ** kwargs ) ) <NEWLINE> <DEDENT> <DEDENT> def copy ( self ) : <NEWLINE> <INDENT> t = self . target <NEWLINE> return SqliteDict ( t . path , t . table , t . isolation_level ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\":memory:\"", "\"dict\"", "\"DEFERRED\""]}, "err_obj": {"msg": "unexpected indent"}}], ["2d28093b2b9c4935b67f26235a924987", {"code_string": "class TunClientFactory(WebSocketClientFactory):\n    \"\"\"Class responsible for create and initialize the protocol instances.\"\"\"\n    def __init__(* args, ** kwargs):\n        if 'dev' in kwargs and kwargs['dev']:\n            self.device = kwargs['dev']\n        else:\n            raise TypeError(\"'dev' must be specified!\")\n        self.crypto = kwargs['crypto'] if 'crypto' in kwargs and kwargs['crypto'] else None\n        WebSocketClientFactory.__init__(self, * args, ** kwargs)\n        self.log = logging.getLogger(type(self))\n        self.log.debug(\"Factory {0} created.\".format(type(self))\n", "code_toks_joined": "class TunClientFactory ( WebSocketClientFactory ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( * args , ** kwargs ) : <NEWLINE> <INDENT> if <STRING> in kwargs and kwargs [ <STRING> ] : <NEWLINE> <INDENT> self . device = kwargs [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise TypeError ( <STRING> ) <NEWLINE> <DEDENT> self . crypto = kwargs [ <STRING> ] if <STRING> in kwargs and kwargs [ <STRING> ] else None <NEWLINE> WebSocketClientFactory . __init__ ( self , * args , ** kwargs ) <NEWLINE> self . log = logging . getLogger ( type ( self ) ) <NEWLINE> self . log . debug ( <STRING> . format ( type ( self ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Class responsible for create and initialize the protocol instances.\"\"\"", "'dev'", "'dev'", "'dev'", "\"'dev' must be specified!\"", "'crypto'", "'crypto'", "'crypto'", "\"Factory {0} created.\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["7a452e350ae86860bc812919fa72113b", {"code_string": "def forwards(self, orm):\n    db.create_table(u'endpoint_mockobjectclass', (\n        (u'id', self.gf('django.db.models.fields.AutoField')(primary_key = True)),\n        ('class_name', self.gf('django.db.models.fields.CharField')(unique = True, max_length = 255)),\n    )\n    db.send_create_signal(u'endpoint', ['MockObjectClass'])\n", "code_toks_joined": "def forwards ( self , orm ) : <NEWLINE> <INDENT> db . create_table ( <STRING> , ( <NEWLINE> <INDENT> ( <STRING> , self . gf ( <STRING> ) ( primary_key = True ) ) , <NEWLINE> ( <STRING> , self . gf ( <STRING> ) ( unique = True , max_length = 255 ) ) , <NEWLINE> <DEDENT> ) <NEWLINE> db . send_create_signal ( <STRING> , [ <STRING> ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["u'endpoint_mockobjectclass'", "u'id'", "'django.db.models.fields.AutoField'", "'class_name'", "'django.db.models.fields.CharField'", "u'endpoint'", "'MockObjectClass'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["bd546e8839b3b81feeea61f5eaa59fda", {"code_string": "def get_jaccard_index_map(g):\n    edge_to_jaccard = {}\n    for u, v in g.edges_iter():\n    u_neighbors = set(g.neighbors(u))\n    v_neighbors = set(g.neighbors(v))\n    edge_to_jaccard[(u, v)] = float(len(u_neighbors & v_neighbors)) / len(u_neighbors | v_neighbors)\n    return edge_to_jaccard\n", "code_toks_joined": "def get_jaccard_index_map ( g ) : <NEWLINE> <INDENT> edge_to_jaccard = { } <NEWLINE> for u , v in g . edges_iter ( ) : <NEWLINE> u_neighbors = set ( g . neighbors ( u ) ) <NEWLINE> v_neighbors = set ( g . neighbors ( v ) ) <NEWLINE> edge_to_jaccard [ ( u , v ) ] = float ( len ( u_neighbors & v_neighbors ) ) / len ( u_neighbors | v_neighbors ) <NEWLINE> return edge_to_jaccard <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["61583cb33fe465d7a6f4ebabc3e54e5f", {"code_string": "def gammp(a, x):\n    \"\"\"Incomplete gamma function.\"\"\"\n    if(x < 0.0 or a <= 0.0):\n        raise ValueError, (a, x)\n    if(x < a + 1.0):\n        return gser(a, x)[0]\n    else:\n        return 1. - gcf(a, x)[0]\n", "code_toks_joined": "def gammp ( a , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( x < 0.0 or a <= 0.0 ) : <NEWLINE> <INDENT> raise ValueError , ( a , x ) <NEWLINE> <DEDENT> if ( x < a + 1.0 ) : <NEWLINE> <INDENT> return gser ( a , x ) [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1. - gcf ( a , x ) [ 0 ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Incomplete gamma function.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["68af7665caf7026ccfd90027e4322299", {"code_string": "class ProcessExecutionError(IOError):\n    def __init__(self, stdout = None, stderr = None, exit_code = None, cmd = None,\n        description = None):\n        self.exit_code = exit_code\n        self.stderr = stderr\n        self.stdout = stdout\n        self.cmd = cmd\n        self.description = description\n        if description is None:\n        description = _('Unexpected error while running command.')\n        if exit_code is None:\n        exit_code = '-'\n        message = _('%(description)s\\nCommand: %(cmd)s\\n'\n            'Exit code: %(exit_code)s\\nStdout: %(stdout)r\\n'\n            'Stderr: %(stderr)r') % locals()\n            IOError.__init__(self, message)\n", "code_toks_joined": "class ProcessExecutionError ( IOError ) : <NEWLINE> <INDENT> def __init__ ( self , stdout = None , stderr = None , exit_code = None , cmd = None , <NEWLINE> <INDENT> description = None ) : <NEWLINE> self . exit_code = exit_code <NEWLINE> self . stderr = stderr <NEWLINE> self . stdout = stdout <NEWLINE> self . cmd = cmd <NEWLINE> self . description = description <NEWLINE> if description is None : <NEWLINE> description = _ ( <STRING> ) <NEWLINE> if exit_code is None : <NEWLINE> exit_code = <STRING> <NEWLINE> message = _ ( <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> ) % locals ( ) <NEWLINE> IOError . __init__ ( self , message ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Unexpected error while running command.'", "'-'", "'%(description)s\\nCommand: %(cmd)s\\n'", "'Exit code: %(exit_code)s\\nStdout: %(stdout)r\\n'", "'Stderr: %(stderr)r'"]}, "err_obj": {"msg": "expected an indented block"}}], ["562af0e9b4242c299878bdda6721f854", {"code_string": "def getDuration(self):\n    if self.entry.media is not None and self.entry.media.duration is not None\n        return self.entry.media.duration.seconds\n    else:\n        return 0\n", "code_toks_joined": "def getDuration ( self ) : <NEWLINE> <INDENT> if self . entry . media is not None and self . entry . media . duration is not None <NEWLINE> <INDENT> return self . entry . media . duration . seconds <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["b53b18fefa7022edc6c9885beec0d2fe", {"code_string": "def retranslateUi(self, h5quicklook):\n    h5quicklook.setWindowTitle(QtGui.QApplication.translate(\"h5quicklook\", \"ARCONS QuickLook\", None, QtGui.QApplication.UnicodeUTF8))\n    self.browse_button.setText(QtGui.QApplication.translate(\"h5quicklook\", \"Browse\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_2.setText(QtGui.QApplication.translate(\"h5quicklook\", \"Loaded:\", None, QtGui.QApplication.UnicodeUTF8))\n    self.darksub_checkbox.setText(QtGui.QApplication.translate(\"h5quicklook\", \"Dark Subtraction?\", None, QtGui.QApplication.UnicodeUTF8))\n    self.flat_checkbox.setText(QtGui.QApplication.translate(\"h5quicklook\", \"Flat fielding?\", None, QtGui.QApplication.UnicodeUTF8))\n    self.displayimage_button.setText(QtGui.QApplication.translate(\"h5quicklook\", \"Display Image\", None, QtGui.QApplication.UnicodeUTF8))\n    self.saveimage_button.setText(QtGui.QApplication.translate(\"h5quicklook\", \"Save Image\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_3.setText(QtGui.QApplication.translate(\"h5quicklook\", \"Observation is\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_4.setText(QtGui.QApplication.translate(\"h5quicklook\", \"seconds.\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_5.setText(QtGui.QApplication.translate(\"h5quicklook\", \"Which chunk would you like to image?\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_6.setText(QtGui.QApplication.translate(\"h5quicklook\", \"to\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_7.setText(QtGui.QApplication.translate(\"h5quicklook\", \"seconds.\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_8.setText(QtGui.QApplication.translate(\"h5quicklook\", \"Do you want:\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_11.setText(QtGui.QApplication.translate(\"h5quicklook\", \"Choose an observation:\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label.setText(QtGui.QApplication.translate(\"h5quicklook\", \"with # of bins=\", None, QtGui.QApplication.UnicodeUTF8))\n    self.plot_pushButton.setText(QtGui.QApplication.translate(\"h5quicklook\", \"Plot\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_13.setText(QtGui.QApplication.translate(\"h5quicklook\", \"Header Info\", None, QtGui.QApplication.UnicodeUTF8))\n    self.time_up.setText(QtGui.QApplication.translate(\"h5quicklook\", \"t++\", None, QtGui.QApplication.UnicodeUTF8))\n    self.time_down.setText(QtGui.QApplication.translate(\"h5quicklook\", \"t--\", None, QtGui.QApplication.UnicodeUTF8))\n    self.satpercent.setToolTip(QtGui.QApplication.translate(\"h5quicklook\", \"Default is to have brightest 10% of pixels saturated \\n\"\n", "code_toks_joined": "def retranslateUi ( self , h5quicklook ) : <NEWLINE> <INDENT> h5quicklook . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . browse_button . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_2 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . darksub_checkbox . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . flat_checkbox . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . displayimage_button . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . saveimage_button . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_3 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_4 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_5 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_6 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_7 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_8 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_11 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . plot_pushButton . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_13 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . time_up . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . time_down . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . satpercent . setToolTip ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"h5quicklook\"", "\"ARCONS QuickLook\"", "\"h5quicklook\"", "\"Browse\"", "\"h5quicklook\"", "\"Loaded:\"", "\"h5quicklook\"", "\"Dark Subtraction?\"", "\"h5quicklook\"", "\"Flat fielding?\"", "\"h5quicklook\"", "\"Display Image\"", "\"h5quicklook\"", "\"Save Image\"", "\"h5quicklook\"", "\"Observation is\"", "\"h5quicklook\"", "\"seconds.\"", "\"h5quicklook\"", "\"Which chunk would you like to image?\"", "\"h5quicklook\"", "\"to\"", "\"h5quicklook\"", "\"seconds.\"", "\"h5quicklook\"", "\"Do you want:\"", "\"h5quicklook\"", "\"Choose an observation:\"", "\"h5quicklook\"", "\"with # of bins=\"", "\"h5quicklook\"", "\"Plot\"", "\"h5quicklook\"", "\"Header Info\"", "\"h5quicklook\"", "\"t++\"", "\"h5quicklook\"", "\"t--\"", "\"h5quicklook\"", "\"Default is to have brightest 10% of pixels saturated \\n\""]}, "window_span": [507, 519], "err_obj": {"msg": "unbalanced (){}[]"}}], ["25e9d5cc1639f9a949fe3de763dd3048", {"code_string": "def _build_config(self):\n    with patch.object(self.cert_obj, '_build_instance',\n        return_value = {}) as mock_build_instance:\n        result = self.cert_obj.build_config()\n        self.assertTrue(mock_build_instance.called)\n        self.assertEqual(result['cert_check']['instances'][0]['url'],\n            'http://fake-cert.com')\n            self.assertEqual(result['cert_check']['instances'][0]['name'],\n            'http://fake-cert.com')\n            return result\n", "code_toks_joined": "def _build_config ( self ) : <NEWLINE> <INDENT> with patch . object ( self . cert_obj , <STRING> , <NEWLINE> <INDENT> return_value = { } ) as mock_build_instance : <NEWLINE> result = self . cert_obj . build_config ( ) <NEWLINE> self . assertTrue ( mock_build_instance . called ) <NEWLINE> self . assertEqual ( result [ <STRING> ] [ <STRING> ] [ 0 ] [ <STRING> ] , <NEWLINE> <INDENT> <STRING> ) <NEWLINE> self . assertEqual ( result [ <STRING> ] [ <STRING> ] [ 0 ] [ <STRING> ] , <NEWLINE> <STRING> ) <NEWLINE> return result <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'_build_instance'", "'cert_check'", "'instances'", "'url'", "'http://fake-cert.com'", "'cert_check'", "'instances'", "'name'", "'http://fake-cert.com'"]}, "err_obj": {"msg": "unexpected indent"}}], ["a6e9c95e1e95a9e5ac0b6910d8ee2609", {"code_string": "class ExtraTreeRegressor(DecisionTreeRegressor):\n    \"\"\"An extremely randomized tree regressor.\"\"\"\n    def __init__(self, criterion = \"mse\",\n        max_depth = None,\n        min_samples_split = 1,\n        min_samples_leaf = 1,\n        min_density = 0.1,\n        max_features = \"auto\",\n        compute_importances = False,\n        random_state = None):\n        super(ExtraTreeRegressor, self).__init__(criterion,\n            max_depth,\n            min_samples_split,\n            min_samples_leaf,\n            min_density,\n            max_features,\n            compute_importances,\n            random_state)\n            self.find_split_ = _tree.TREE_SPLIT_RANDOM\n", "code_toks_joined": "class ExtraTreeRegressor ( DecisionTreeRegressor ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , criterion = <STRING> , <NEWLINE> <INDENT> max_depth = None , <NEWLINE> min_samples_split = 1 , <NEWLINE> min_samples_leaf = 1 , <NEWLINE> min_density = 0.1 , <NEWLINE> max_features = <STRING> , <NEWLINE> compute_importances = False , <NEWLINE> random_state = None ) : <NEWLINE> super ( ExtraTreeRegressor , self ) . __init__ ( criterion , <NEWLINE> <INDENT> max_depth , <NEWLINE> min_samples_split , <NEWLINE> min_samples_leaf , <NEWLINE> min_density , <NEWLINE> max_features , <NEWLINE> compute_importances , <NEWLINE> random_state ) <NEWLINE> self . find_split_ = _tree . TREE_SPLIT_RANDOM <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"An extremely randomized tree regressor.\"\"\"", "\"mse\"", "\"auto\""]}, "err_obj": {"msg": "unexpected indent"}}], ["2cb86a81c179a5b41430e3c4a52db461", {"code_string": "def recommendDruidMaxMemoryLimitConfigurations(self, configurations, clusterData, services, hosts):\n    putEnvPropertyAttribute = self.putPropertyAttribute(configurations, \"druid-env\")\n    for component in[\"DRUID_HISTORICAL\", \"DRUID_MIDDLEMANAGER\", \"DRUID_BROKER\", \"DRUID_OVERLORD\",\n        \"DRUID_COORDINATOR\"]:\n        component_hosts = self.getHostsWithComponent(\"DRUID\", component, services, hosts)\n        if component_hosts is not None and len(component_hosts) > 0:\n        totalAvailableMem = self.getMinMemory(component_hosts) / 1024\n        nodeType = self.DRUID_COMPONENT_NODE_TYPE_MAP[component]\n        putEnvPropertyAttribute(format('druid.{nodeType}.jvm.heap.memory'), 'maximum',\n            max(totalAvailableMem, 1024))\n", "code_toks_joined": "def recommendDruidMaxMemoryLimitConfigurations ( self , configurations , clusterData , services , hosts ) : <NEWLINE> <INDENT> putEnvPropertyAttribute = self . putPropertyAttribute ( configurations , <STRING> ) <NEWLINE> for component in [ <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ] : <NEWLINE> component_hosts = self . getHostsWithComponent ( <STRING> , component , services , hosts ) <NEWLINE> if component_hosts is not None and len ( component_hosts ) > 0 : <NEWLINE> totalAvailableMem = self . getMinMemory ( component_hosts ) / 1024 <NEWLINE> nodeType = self . DRUID_COMPONENT_NODE_TYPE_MAP [ component ] <NEWLINE> putEnvPropertyAttribute ( format ( <STRING> ) , <STRING> , <NEWLINE> <INDENT> max ( totalAvailableMem , 1024 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"druid-env\"", "\"DRUID_HISTORICAL\"", "\"DRUID_MIDDLEMANAGER\"", "\"DRUID_BROKER\"", "\"DRUID_OVERLORD\"", "\"DRUID_COORDINATOR\"", "\"DRUID\"", "'druid.{nodeType}.jvm.heap.memory'", "'maximum'"]}, "err_obj": {"msg": "expected an indented block"}}], ["11015d0276ba149f8ab2e5fd0df67e1b", {"code_string": "def median(m, axis = 0):\n    \"\"\"Returns median of the given nonmasked m array along the given axis.\"\"\"\n    if numpy.ma.isMA(m):\n        raise TypeError, \"wrong type for m (%s), try using medianMA instead\" % type(m).__name__\n    m = numpy.asarray(m, numpy.float)\n    m = numpy.transpose(m, [axis] + range(axis) + range(axis + 1, numpy.rank(m)))\n    return numpy.median(m)\n", "code_toks_joined": "def median ( m , axis = 0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if numpy . ma . isMA ( m ) : <NEWLINE> <INDENT> raise TypeError , <STRING> % type ( m ) . __name__ <NEWLINE> <DEDENT> m = numpy . asarray ( m , numpy . float ) <NEWLINE> m = numpy . transpose ( m , [ axis ] + range ( axis ) + range ( axis + 1 , numpy . rank ( m ) ) ) <NEWLINE> return numpy . median ( m ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns median of the given nonmasked m array along the given axis.\"\"\"", "\"wrong type for m (%s), try using medianMA instead\""]}, "err_obj": {"msg": "invalid syntax"}}], ["0c61a480f280a0f94fd04963217833cf", {"code_string": "def test_port_rule_masking(self):\n    if(inspect.isclass(self.expected)\n        and issubclass(self.expected, Exception)):\n        with testtools.ExpectedException(self.expected):\n        utils.port_rule_masking(self.port_min, self.port_max)\n    else:\n        rules = utils.port_rule_masking(self.port_min, self.port_max)\n        self.assertItemsEqual(self.expected, rules)\n", "code_toks_joined": "def test_port_rule_masking ( self ) : <NEWLINE> <INDENT> if ( inspect . isclass ( self . expected ) <NEWLINE> <INDENT> and issubclass ( self . expected , Exception ) ) : <NEWLINE> with testtools . ExpectedException ( self . expected ) : <NEWLINE> utils . port_rule_masking ( self . port_min , self . port_max ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rules = utils . port_rule_masking ( self . port_min , self . port_max ) <NEWLINE> self . assertItemsEqual ( self . expected , rules ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["d757e53384de9f7fd8ad953e234a6a50", {"code_string": "def endElement(self, name):\n    if name == \"context\":\n        self.in_context = False\n        self.sentences.append((self.lexelt,\n            self.head_count,\n            self.cur_sentence,\n            self.instance_id)\n    if name == \"head\":\n        self.cur_sentence += \"</head>\"\n", "code_toks_joined": "def endElement ( self , name ) : <NEWLINE> <INDENT> if name == <STRING> : <NEWLINE> <INDENT> self . in_context = False <NEWLINE> self . sentences . append ( ( self . lexelt , <NEWLINE> <INDENT> self . head_count , <NEWLINE> self . cur_sentence , <NEWLINE> self . instance_id ) <NEWLINE> <DEDENT> <DEDENT> if name == <STRING> : <NEWLINE> <INDENT> self . cur_sentence += <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"context\"", "\"head\"", "\"</head>\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["aae6020e65923e5b130f91dafdb31695", {"code_string": "def home()\n    \"\"\"Home page.\"\"\"\n    return render_template('public/home.html')\n", "code_toks_joined": "def home ( ) <NEWLINE> <INDENT> <STRING> <NEWLINE> return render_template ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Home page.\"\"\"", "'public/home.html'"]}, "err_obj": {"msg": "invalid syntax"}}], ["c5ac865616d3f5f4efbca59e461f64e7", {"code_string": "def send_req(host, port, req):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    print(\"Connecting to %s:%d...\" %(host, port))\n    sock.connect((host, port))\n    print(\"Connected, sending request...\")\n    sock.send(req)\n    print(\"Request sent, waiting for reply...\")\n    rbuf = sock.recv(1024)\n    resp = \"\"\n    while len(rbuf):\n    resp = resp + rbuf\n    rbuf = sock.recv(1024)\n    print(\"Received reply.\")\n    sock.close()\n    return resp\n", "code_toks_joined": "def send_req ( host , port , req ) : <NEWLINE> <INDENT> sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) <NEWLINE> print ( <STRING> % ( host , port ) ) <NEWLINE> sock . connect ( ( host , port ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> sock . send ( req ) <NEWLINE> print ( <STRING> ) <NEWLINE> rbuf = sock . recv ( 1024 ) <NEWLINE> resp = <STRING> <NEWLINE> while len ( rbuf ) : <NEWLINE> resp = resp + rbuf <NEWLINE> rbuf = sock . recv ( 1024 ) <NEWLINE> print ( <STRING> ) <NEWLINE> sock . close ( ) <NEWLINE> return resp <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Connecting to %s:%d...\"", "\"Connected, sending request...\"", "\"Request sent, waiting for reply...\"", "\"\"", "\"Received reply.\""]}, "err_obj": {"msg": "expected an indented block"}}], ["e5ddc3a6003dadb775f4f7ad079e5d1c", {"code_string": "from oslo_log import log as logging\nfrom cinder.backup import driver\nfrom cinder.tests.unit.backup import fake_service\nLOG = logging.getLogger(__name__)\nclass FakeBackupServiceWithVerify(driver.BackupDriverWithVerify,\n    fake_service.FakeBackupService):\n    def verify(self, backup):\n    pass\n", "code_toks_joined": "from oslo_log import log as logging <NEWLINE> from cinder . backup import driver <NEWLINE> from cinder . tests . unit . backup import fake_service <NEWLINE> LOG = logging . getLogger ( __name__ ) <NEWLINE> class FakeBackupServiceWithVerify ( driver . BackupDriverWithVerify , <NEWLINE> <INDENT> fake_service . FakeBackupService ) : <NEWLINE> def verify ( self , backup ) : <NEWLINE> pass <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["3dde0e9e164326b0108b8a139cf7fe8b", {"code_string": "def from_crawler(cls, crawler):\n    return cls(\n        mongo_uri = MONGO_URI,\n        mongo_db = 'zhihu'\n        image_dir = os.path.join(PROJECT_DIR, 'images')\n    )\n", "code_toks_joined": "def from_crawler ( cls , crawler ) : <NEWLINE> <INDENT> return cls ( <NEWLINE> <INDENT> mongo_uri = MONGO_URI , <NEWLINE> mongo_db = <STRING> <NEWLINE> image_dir = os . path . join ( PROJECT_DIR , <STRING> ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'zhihu'", "'images'"]}, "err_obj": {"msg": "invalid syntax"}}], ["58d8bfc6987ecd2a1555ba3631341de7", {"code_string": "def get_namespace(self):\n    \"\"\"Returns the single namespace bound to this name.\"\"\"\n    if len(self.__namespaces) != 1:\n        raise ValueError, \"name is bound to multiple namespaces\"\n    return self.__namespaces[0]\n", "code_toks_joined": "def get_namespace ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if len ( self . __namespaces ) != 1 : <NEWLINE> <INDENT> raise ValueError , <STRING> <NEWLINE> <DEDENT> return self . __namespaces [ 0 ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns the single namespace bound to this name.\"\"\"", "\"name is bound to multiple namespaces\""]}, "err_obj": {"msg": "invalid syntax"}}], ["b32bd906a4c4b7e3a4f46e97f5ec964f", {"code_string": "def get_pixmap(self, cat, value):\n    pix = None\n    if cat == \"state\":\n        pix = STATE_PIX.get(value, None)\n    elif cat == \"tracker_host\":\n        pix = TRACKER_PIX.get(value, None)\n    if pix:\n        try:\n            return GdkPixbuf.Pixbuf.new_from_file(deluge.common.get_pixmap(\"%s16.png\" % pix))\n        except GError, e:\n            log.warning(e)\n    return self.get_transparent_pix(16, 16)\n", "code_toks_joined": "def get_pixmap ( self , cat , value ) : <NEWLINE> <INDENT> pix = None <NEWLINE> if cat == <STRING> : <NEWLINE> <INDENT> pix = STATE_PIX . get ( value , None ) <NEWLINE> <DEDENT> elif cat == <STRING> : <NEWLINE> <INDENT> pix = TRACKER_PIX . get ( value , None ) <NEWLINE> <DEDENT> if pix : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return GdkPixbuf . Pixbuf . new_from_file ( deluge . common . get_pixmap ( <STRING> % pix ) ) <NEWLINE> <DEDENT> except GError , e : <NEWLINE> <INDENT> log . warning ( e ) <NEWLINE> <DEDENT> <DEDENT> return self . get_transparent_pix ( 16 , 16 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"state\"", "\"tracker_host\"", "\"%s16.png\""]}, "err_obj": {"msg": "invalid syntax"}}], ["47ba3fe31e30408a7fce4f7934960273", {"code_string": "class ResourceManagementClientConfiguration(AzureConfiguration):\n    \"\"\"Configuration for ResourceManagementClient\"\"\"\n    def __init__(\n        self, credentials, subscription_id, base_url = None):\n        if credentials is None:\n        raise ValueError(\"Parameter 'credentials' must not be None.\")\n        if subscription_id is None:\n        raise ValueError(\"Parameter 'subscription_id' must not be None.\")\n        if not base_url:\n        base_url = 'https://management.azure.com'\n        super(ResourceManagementClientConfiguration, self).__init__(base_url)\n        self.add_user_agent('resourcemanagementclient/{}'.format(VERSION))\n        self.add_user_agent('Azure-SDK-For-Python')\n        self.credentials = credentials\n        self.subscription_id = subscription_id\n", "code_toks_joined": "class ResourceManagementClientConfiguration ( AzureConfiguration ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( <NEWLINE> <INDENT> self , credentials , subscription_id , base_url = None ) : <NEWLINE> if credentials is None : <NEWLINE> raise ValueError ( <STRING> ) <NEWLINE> if subscription_id is None : <NEWLINE> raise ValueError ( <STRING> ) <NEWLINE> if not base_url : <NEWLINE> base_url = <STRING> <NEWLINE> super ( ResourceManagementClientConfiguration , self ) . __init__ ( base_url ) <NEWLINE> self . add_user_agent ( <STRING> . format ( VERSION ) ) <NEWLINE> self . add_user_agent ( <STRING> ) <NEWLINE> self . credentials = credentials <NEWLINE> self . subscription_id = subscription_id <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Configuration for ResourceManagementClient\"\"\"", "\"Parameter 'credentials' must not be None.\"", "\"Parameter 'subscription_id' must not be None.\"", "'https://management.azure.com'", "'resourcemanagementclient/{}'", "'Azure-SDK-For-Python'"]}, "err_obj": {"msg": "expected an indented block"}}], ["9d4bddcab7dd7bd12e29e16f206e8847", {"code_string": "class TaskWorkArea(object):\n    def __init__(self, taskTab: [] Task):\n        self.taskTab = taskTab\n        let self.taskList: Task = None\n        let self.holdCount: int = 0\n        let self.qpktCount: int = 0\n", "code_toks_joined": "class TaskWorkArea ( object ) : <NEWLINE> <INDENT> def __init__ ( self , taskTab : [ ] Task ) : <NEWLINE> <INDENT> self . taskTab = taskTab <NEWLINE> let self . taskList : Task = None <NEWLINE> let self . holdCount : int = 0 <NEWLINE> let self . qpktCount : int = 0 <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["874acf6deefa39265e160b4df0de238d", {"code_string": "def initGui(self):\n    \"\"\"Create the menu entries and toolbar icons inside the QGIS GUI.\"\"\"\n    icon_path = ': /plugins/mysqlimport/icon.png'\n    self.add_action(\n        icon_path,\n        text = self.tr(u'Import data into MySQL/MariaDB'),\n        callback = self.run,\n        parent = self.iface.mainWindow()\n    self.dlg.toolButton.clicked.connect(self.selectFile)\n    self.dlg.testButton.clicked.connect(self.testConnection)\n", "code_toks_joined": "def initGui ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> icon_path = <STRING> <NEWLINE> self . add_action ( <NEWLINE> <INDENT> icon_path , <NEWLINE> text = self . tr ( <STRING> ) , <NEWLINE> callback = self . run , <NEWLINE> parent = self . iface . mainWindow ( ) <NEWLINE> <DEDENT> self . dlg . toolButton . clicked . connect ( self . selectFile ) <NEWLINE> self . dlg . testButton . clicked . connect ( self . testConnection ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Create the menu entries and toolbar icons inside the QGIS GUI.\"\"\"", "': /plugins/mysqlimport/icon.png'", "u'Import data into MySQL/MariaDB'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["81995d6c10d379a024dd6f3a12fc9cab", {"code_string": "def draw(self, dc, gc, (x, y)):\n    x = x + self.get_width()\n    self.children.reverse()\n    for child in self.children:\n        x = x - child.get_width()\n        child.draw(dc, gc, (x, y))\n    self.children.reverse()\n", "code_toks_joined": "def draw ( self , dc , gc , ( x , y ) ) : <NEWLINE> <INDENT> x = x + self . get_width ( ) <NEWLINE> self . children . reverse ( ) <NEWLINE> for child in self . children : <NEWLINE> <INDENT> x = x - child . get_width ( ) <NEWLINE> child . draw ( dc , gc , ( x , y ) ) <NEWLINE> <DEDENT> self . children . reverse ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["4daffe2ed374f44b6da2cf9d199a0163", {"code_string": "def process_response(self, request, response):\n    if(self.sts_seconds and request.is_secure() and\n        'strict-transport-security' not in response):\n        sts_header = \"max-age=%s\" % self.sts_seconds\n        if self.sts_include_subdomains:\n        sts_header = sts_header + \"; includeSubDomains\"\n        response[\"strict-transport-security\"] = sts_header\n    if self.content_type_nosniff and 'x-content-type-options' not in response:\n        response[\"x-content-type-options\"] = \"nosniff\"\n    if self.xss_filter and 'x-xss-protection' not in response:\n        response[\"x-xss-protection\"] = \"1; mode=block\"\n    return response\n", "code_toks_joined": "def process_response ( self , request , response ) : <NEWLINE> <INDENT> if ( self . sts_seconds and request . is_secure ( ) and <NEWLINE> <INDENT> <STRING> not in response ) : <NEWLINE> sts_header = <STRING> % self . sts_seconds <NEWLINE> if self . sts_include_subdomains : <NEWLINE> sts_header = sts_header + <STRING> <NEWLINE> response [ <STRING> ] = sts_header <NEWLINE> <DEDENT> if self . content_type_nosniff and <STRING> not in response : <NEWLINE> <INDENT> response [ <STRING> ] = <STRING> <NEWLINE> <DEDENT> if self . xss_filter and <STRING> not in response : <NEWLINE> <INDENT> response [ <STRING> ] = <STRING> <NEWLINE> <DEDENT> return response <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'strict-transport-security'", "\"max-age=%s\"", "\"; includeSubDomains\"", "\"strict-transport-security\"", "'x-content-type-options'", "\"x-content-type-options\"", "\"nosniff\"", "'x-xss-protection'", "\"x-xss-protection\"", "\"1; mode=block\""]}, "err_obj": {"msg": "expected an indented block"}}], ["9b0680afcacb6e37de5766fb927cdf83", {"code_string": "class Faction:\n    def __init__(self, name, ascendancy, manufacturing, research, culture, speed, m_node, r_node, c_node, defense, attack):\n        self.name = name\n        self.ascendancy = ascendancy\n        self.manufacturing = manufacturing\n        self.research = research\n        self.culture = culture\n        self.speed = speed\n        self.m_node = m_node\n        self.r_node = r_node\n        self.c_node = c_node\n        self.defense = defense\n        self.attack = attack\n    def show_stats(self):\n        print(\" {} level {}\\n Manufacture = {}\\n Research = {}\\n Culture = {}\\n Warp speed = {}\\n Deflectors = {}\\n Phasers = {}\\n\"\n", "code_toks_joined": "class Faction : <NEWLINE> <INDENT> def __init__ ( self , name , ascendancy , manufacturing , research , culture , speed , m_node , r_node , c_node , defense , attack ) : <NEWLINE> <INDENT> self . name = name <NEWLINE> self . ascendancy = ascendancy <NEWLINE> self . manufacturing = manufacturing <NEWLINE> self . research = research <NEWLINE> self . culture = culture <NEWLINE> self . speed = speed <NEWLINE> self . m_node = m_node <NEWLINE> self . r_node = r_node <NEWLINE> self . c_node = c_node <NEWLINE> self . defense = defense <NEWLINE> self . attack = attack <NEWLINE> <DEDENT> def show_stats ( self ) : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\" {} level {}\\n Manufacture = {}\\n Research = {}\\n Culture = {}\\n Warp speed = {}\\n Deflectors = {}\\n Phasers = {}\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["3e3561f01c3fa12d93d89ca5ee779b9d", {"code_string": "class HTTPForbidden(HTTPClientError):\n    \"\"\"subclass of :class:`~HTTPClientError`\"\"\"\n    code = 403\n    title = 'Forbidden'\n    explanation = ('Access was denied to this resource.')\n    def __init__(self, detail = None, headers = None, comment = None,\n        body_template = None, result = None, ** kw):\n        HTTPClientError.__init__(self, detail = detail, headers = headers,\n            comment = comment, body_template = body_template,\n            ** kw)\n            self.result = result\n", "code_toks_joined": "class HTTPForbidden ( HTTPClientError ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> code = 403 <NEWLINE> title = <STRING> <NEWLINE> explanation = ( <STRING> ) <NEWLINE> def __init__ ( self , detail = None , headers = None , comment = None , <NEWLINE> <INDENT> body_template = None , result = None , ** kw ) : <NEWLINE> HTTPClientError . __init__ ( self , detail = detail , headers = headers , <NEWLINE> <INDENT> comment = comment , body_template = body_template , <NEWLINE> ** kw ) <NEWLINE> self . result = result <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"subclass of :class:`~HTTPClientError`\"\"\"", "'Forbidden'", "'Access was denied to this resource.'"]}, "err_obj": {"msg": "unexpected indent"}}], ["df7ae84b4accaa7cc162d1233276f95b", {"code_string": "def __init__(self, handler = None):\n    self.fkiss_started = 0\n    self.event = None\n        self.actions = []\n    self.setindex = - 1\n        self.handler = handler\n", "code_toks_joined": "def __init__ ( self , handler = None ) : <NEWLINE> <INDENT> self . fkiss_started = 0 <NEWLINE> self . event = None <NEWLINE> <INDENT> self . actions = [ ] <NEWLINE> <DEDENT> self . setindex = - 1 <NEWLINE> <INDENT> self . handler = handler <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["2dd23678d8554e3772590364ac527f25", {"code_string": "def testBootTimeNonExistantFile(self):\n    with MonkeyPatchScope([(sampling, '_PROC_STAT_PATH',\n        '/i/do/not/exist/1234567890')]):\n        with self.assertRaises(IOError):\n        sampling.getBootTime()\n", "code_toks_joined": "def testBootTimeNonExistantFile ( self ) : <NEWLINE> <INDENT> with MonkeyPatchScope ( [ ( sampling , <STRING> , <NEWLINE> <INDENT> <STRING> ) ] ) : <NEWLINE> with self . assertRaises ( IOError ) : <NEWLINE> sampling . getBootTime ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'_PROC_STAT_PATH'", "'/i/do/not/exist/1234567890'"]}, "err_obj": {"msg": "expected an indented block"}}], ["95edbaf27f38ec93558ccb6466b7af8f", {"code_string": "def close(self):\n    if DEBUG: print self._address, \"MiniBitTorrent.close()\"\n    if not self._closed:\n        self.connection_lost(self._socket)\n        self._socket.close()\n", "code_toks_joined": "def close ( self ) : <NEWLINE> <INDENT> if DEBUG : print self . _address , <STRING> <NEWLINE> if not self . _closed : <NEWLINE> <INDENT> self . connection_lost ( self . _socket ) <NEWLINE> self . _socket . close ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"MiniBitTorrent.close()\""]}, "err_obj": {"msg": "invalid syntax"}}], ["804bfef925be8d56bec3b89615867f7e", {"code_string": "def is_arbiter_master_selected(self):\n    if self.dbg:\n        print \"GS: is_arbiter_master_selected()\"\n    return self.arbiter_selected is not None\n", "code_toks_joined": "def is_arbiter_master_selected ( self ) : <NEWLINE> <INDENT> if self . dbg : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> return self . arbiter_selected is not None <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"GS: is_arbiter_master_selected()\""]}, "err_obj": {"msg": "invalid syntax"}}], ["0a56c54e19908fba6cc5fb5000a63e33", {"code_string": "def _prepare_to_process(self, options, args, tool):\n    try:\n        self.state = self._prepare_state(options, args, tool)\n    except ScriptError, e:\n        _log.error(e.message_with_output())\n        self._exit(e.exit_code or 2)\n    self._prepare_sequence.run_and_handle_errors(tool, options, self.state)\n", "code_toks_joined": "def _prepare_to_process ( self , options , args , tool ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . state = self . _prepare_state ( options , args , tool ) <NEWLINE> <DEDENT> except ScriptError , e : <NEWLINE> <INDENT> _log . error ( e . message_with_output ( ) ) <NEWLINE> self . _exit ( e . exit_code or 2 ) <NEWLINE> <DEDENT> self . _prepare_sequence . run_and_handle_errors ( tool , options , self . state ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["eea3d2caf8a1095bc183ab0c21702720", {"code_string": "class DatasetValidationShuffleSplit(DatasetCV):\n    \"\"\"Shuffle-split cross-validation with train/valid/test subsets.\"\"\"\n    def __init__(self, dataset, n_iter = 10, test_size = 0.1, valid_size = None,\n        train_size = None, random_state = None, ** kwargs):\n        n = dataset.get_num_examples()\n        cv = ValidationShuffleSplit(n, n_iter, test_size, valid_size,\n            train_size, random_state)\n            super(DatasetValidationShuffleSplit, self).__init__(dataset, cv,\n                ** kwargs)\n", "code_toks_joined": "class DatasetValidationShuffleSplit ( DatasetCV ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , dataset , n_iter = 10 , test_size = 0.1 , valid_size = None , <NEWLINE> <INDENT> train_size = None , random_state = None , ** kwargs ) : <NEWLINE> n = dataset . get_num_examples ( ) <NEWLINE> cv = ValidationShuffleSplit ( n , n_iter , test_size , valid_size , <NEWLINE> <INDENT> train_size , random_state ) <NEWLINE> super ( DatasetValidationShuffleSplit , self ) . __init__ ( dataset , cv , <NEWLINE> <INDENT> ** kwargs ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Shuffle-split cross-validation with train/valid/test subsets.\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["dce0e766c0500837b9b8ea2ea8c5622f", {"code_string": "def setUp(self):\n    super(AntlrJavaGenTest, self).setUp()\n    for ver in self.VERSIONS:\n        self.create_file(\n            relpath = '{srcroot}/{dir}/{prefix}.g{version}'.format(version = ver, ** self.PARTS),\n            contents = dedent(\"\"\"grammar{prefix}; \"\"\".format(** self.PARTS))))\n", "code_toks_joined": "def setUp ( self ) : <NEWLINE> <INDENT> super ( AntlrJavaGenTest , self ) . setUp ( ) <NEWLINE> for ver in self . VERSIONS : <NEWLINE> <INDENT> self . create_file ( <NEWLINE> <INDENT> relpath = <STRING> . format ( version = ver , ** self . PARTS ) , <NEWLINE> contents = dedent ( <STRING> . format ( ** self . PARTS ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'{srcroot}/{dir}/{prefix}.g{version}'", "\"\"\"grammar{prefix}; \"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["1bfc43aae70f7b8a97cf67db7dcf4002", {"code_string": "def get_user_config_path(* args):\n    if sys.platform == \"win32\":\n        return win32_get_app_data_path(* args)\n    config_home = os.environ.get(\n        'XDG_CONFIG_HOME', os.path.join(os.path.expanduser('~'), '.config')))\n    return os.path.join(config_home, * args)\n", "code_toks_joined": "def get_user_config_path ( * args ) : <NEWLINE> <INDENT> if sys . platform == <STRING> : <NEWLINE> <INDENT> return win32_get_app_data_path ( * args ) <NEWLINE> <DEDENT> config_home = os . environ . get ( <NEWLINE> <INDENT> <STRING> , os . path . join ( os . path . expanduser ( <STRING> ) , <STRING> ) ) ) <NEWLINE> <DEDENT> return os . path . join ( config_home , * args ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"win32\"", "'XDG_CONFIG_HOME'", "'~'", "'.config'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["b459d2685e4bbcf36597a9b603944c59", {"code_string": "def EndMapping(self, top_value, mapping):\n    \"\"\"When leaving scope, makes sure new object is initialized.\"\"\"\n    try:\n        mapping.value.CheckInitialized()\n    except validation.ValidationError:\n        raise\n    except Exception, e:\n        try:\n            error_str = str(e)\n        except Exception:\n            error_str = '<unknown>'\n        raise validation.ValidationError(\"Invalid object:\\n%s\" % error_str, e)\n", "code_toks_joined": "def EndMapping ( self , top_value , mapping ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> mapping . value . CheckInitialized ( ) <NEWLINE> <DEDENT> except validation . ValidationError : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> error_str = str ( e ) <NEWLINE> <DEDENT> except Exception : <NEWLINE> <INDENT> error_str = <STRING> <NEWLINE> <DEDENT> raise validation . ValidationError ( <STRING> % error_str , e ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"When leaving scope, makes sure new object is initialized.\"\"\"", "'<unknown>'", "\"Invalid object:\\n%s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["8c5e05688319b1434500fac154e41ffd", {"code_string": "class HandlerA(object)\n    def __init__(self):\n        print('Handler A created')\n    def __call__(self, packet):\n        print('HandlerA handle packet: {}'.format(packet))\n", "code_toks_joined": "class HandlerA ( object ) <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> def __call__ ( self , packet ) : <NEWLINE> <INDENT> print ( <STRING> . format ( packet ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Handler A created'", "'HandlerA handle packet: {}'"]}, "err_obj": {"msg": "invalid syntax"}}], ["da193c5672e8f1bb7ce95447f4d08b80", {"code_string": "def __ds_activity_record_changed(self, event)\n    self._revalidate_activities()\n    self._revalidate_links()\n", "code_toks_joined": "def __ds_activity_record_changed ( self , event ) <NEWLINE> <INDENT> self . _revalidate_activities ( ) <NEWLINE> self . _revalidate_links ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["0dba178d483e80d9c1b97e0ac1989d53", {"code_string": "def __getMovieTitle(sHtmlContent):\n    sPattern = '<div class=\"videoText\"><p><strong>(.*?)<span>'\n    oParser = cParser()\n    aResult = oParser.parse(sHtmlContent, sPattern)\n    if(aResult[0] == True):\n    return cUtil().removeHtmlTags(str(aResult[1][0]))\n    return False\n", "code_toks_joined": "def __getMovieTitle ( sHtmlContent ) : <NEWLINE> <INDENT> sPattern = <STRING> <NEWLINE> oParser = cParser ( ) <NEWLINE> aResult = oParser . parse ( sHtmlContent , sPattern ) <NEWLINE> if ( aResult [ 0 ] == True ) : <NEWLINE> return cUtil ( ) . removeHtmlTags ( str ( aResult [ 1 ] [ 0 ] ) ) <NEWLINE> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'<div class=\"videoText\"><p><strong>(.*?)<span>'"]}, "err_obj": {"msg": "expected an indented block"}}], ["9421912814e57d292b4f51a863df19d8", {"code_string": "def get_nvml():\n    \"\"\"Return the ctypes.DLL object for cudart or None\"\"\"\n    if platform.system() == 'Windows':\n        return get_library('nvml.dll')\n    else:\n        for name in(\n            'libnvidia-ml.so.1',\n            'libnvidia-ml.so',\n            'nvml.so'):\n            nvml = get_library(name)\n            if nvml is not None:\n            return nvml\n    return None\n", "code_toks_joined": "def get_nvml ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if platform . system ( ) == <STRING> : <NEWLINE> <INDENT> return get_library ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for name in ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ) : <NEWLINE> nvml = get_library ( name ) <NEWLINE> if nvml is not None : <NEWLINE> return nvml <NEWLINE> <DEDENT> <DEDENT> return None <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return the ctypes.DLL object for cudart or None\"\"\"", "'Windows'", "'nvml.dll'", "'libnvidia-ml.so.1'", "'libnvidia-ml.so'", "'nvml.so'"]}, "err_obj": {"msg": "expected an indented block"}}], ["be066a8aba534ed0876636673e9955cf", {"code_string": "def defineCharacteristics(self):\n    self.name = 'Split RGB bands'\n    self.group = 'Grid - Tools'\n    self.addParameter(ParameterRaster(SplitRGBBands.INPUT, 'Input layer',\n        False))\n    self.addOutput(OutputRaster(SplitRGBBands.R, 'Output R band layer'))\n    self.addOutput(OutputRaster(SplitRGBBands.G, 'Output G band layer'))\n    self.addOutput(OutputRaster(SplitRGBBands.B, 'Output B band layer')\n", "code_toks_joined": "def defineCharacteristics ( self ) : <NEWLINE> <INDENT> self . name = <STRING> <NEWLINE> self . group = <STRING> <NEWLINE> self . addParameter ( ParameterRaster ( SplitRGBBands . INPUT , <STRING> , <NEWLINE> <INDENT> False ) ) <NEWLINE> <DEDENT> self . addOutput ( OutputRaster ( SplitRGBBands . R , <STRING> ) ) <NEWLINE> self . addOutput ( OutputRaster ( SplitRGBBands . G , <STRING> ) ) <NEWLINE> self . addOutput ( OutputRaster ( SplitRGBBands . B , <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Split RGB bands'", "'Grid - Tools'", "'Input layer'", "'Output R band layer'", "'Output G band layer'", "'Output B band layer'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["dec07603c4aa2d039844bbae52f7da72", {"code_string": "def upgrade():\n    op.add_column('myuser', sa.Column('claimed', sa.Boolean(), nullable = True)\n    op.create_index('aga_id__claimed', 'myuser', ['aga_id', 'claimed'], unique = True)\n    op.drop_constraint('myuser_aga_id_key', 'myuser', type_ = 'unique')\n", "code_toks_joined": "def upgrade ( ) : <NEWLINE> <INDENT> op . add_column ( <STRING> , sa . Column ( <STRING> , sa . Boolean ( ) , nullable = True ) <NEWLINE> op . create_index ( <STRING> , <STRING> , [ <STRING> , <STRING> ] , unique = True ) <NEWLINE> op . drop_constraint ( <STRING> , <STRING> , type_ = <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'myuser'", "'claimed'", "'aga_id__claimed'", "'myuser'", "'aga_id'", "'claimed'", "'myuser_aga_id_key'", "'myuser'", "'unique'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["aa14fc170de58d5301f0f1e3d1358901", {"code_string": "class AutoRestResourceFlatteningTestServiceConfiguration(AzureConfiguration):\n    \"\"\"Configuration for AutoRestResourceFlatteningTestService\"\"\"\n    def __init__(\n        self, credentials, base_url = None):\n        if credentials is None:\n        raise ValueError(\"Parameter 'credentials' must not be None.\")\n        if not base_url:\n        base_url = 'http://localhost'\n        super(AutoRestResourceFlatteningTestServiceConfiguration, self).__init__(base_url)\n        self.add_user_agent('autorestresourceflatteningtestservice/{}'.format(VERSION))\n        self.add_user_agent('Azure-SDK-For-Python')\n        self.credentials = credentials\n", "code_toks_joined": "class AutoRestResourceFlatteningTestServiceConfiguration ( AzureConfiguration ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( <NEWLINE> <INDENT> self , credentials , base_url = None ) : <NEWLINE> if credentials is None : <NEWLINE> raise ValueError ( <STRING> ) <NEWLINE> if not base_url : <NEWLINE> base_url = <STRING> <NEWLINE> super ( AutoRestResourceFlatteningTestServiceConfiguration , self ) . __init__ ( base_url ) <NEWLINE> self . add_user_agent ( <STRING> . format ( VERSION ) ) <NEWLINE> self . add_user_agent ( <STRING> ) <NEWLINE> self . credentials = credentials <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Configuration for AutoRestResourceFlatteningTestService\"\"\"", "\"Parameter 'credentials' must not be None.\"", "'http://localhost'", "'autorestresourceflatteningtestservice/{}'", "'Azure-SDK-For-Python'"]}, "err_obj": {"msg": "expected an indented block"}}], ["b4558c80a16a047e038cb4bd3f56855c", {"code_string": "def get_outputs(self):\n    \"\"\"convert pubkeys to addresses\"\"\"\n    o = []\n    for type, x, v in self.outputs:\n        if type == 'address':\n            addr = x\n        elif type == 'pubkey':\n            addr = public_key_to_bc_address(x.decode('hex')\n        else:\n            addr = 'SCRIPT ' + x.encode('hex')\n        o.append((addr, v))\n    return o\n", "code_toks_joined": "def get_outputs ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> o = [ ] <NEWLINE> for type , x , v in self . outputs : <NEWLINE> <INDENT> if type == <STRING> : <NEWLINE> <INDENT> addr = x <NEWLINE> <DEDENT> elif type == <STRING> : <NEWLINE> <INDENT> addr = public_key_to_bc_address ( x . decode ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> addr = <STRING> + x . encode ( <STRING> ) <NEWLINE> <DEDENT> o . append ( ( addr , v ) ) <NEWLINE> <DEDENT> return o <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"convert pubkeys to addresses\"\"\"", "'address'", "'pubkey'", "'hex'", "'SCRIPT '", "'hex'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["23796dcd62d632dd6aac502691364dea", {"code_string": "def affected(self, source, sites):\n    \"\"\"Returns the sites within the integration distance from the source, \"\"\"\n    source_sites = list(self([source], sites)\n    if source_sites:\n        return source_sites[0][1]\n", "code_toks_joined": "def affected ( self , source , sites ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> source_sites = list ( self ( [ source ] , sites ) <NEWLINE> if source_sites : <NEWLINE> <INDENT> return source_sites [ 0 ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns the sites within the integration distance from the source, \"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["5304dcf732a7ed118030367ecd58bd0b", {"code_string": "def xml(self):\n    \"\"\"Get an etree if possible.\"\"\"\n    if 'xml' not in self.mimetype:\n        raise AttributeError(\n            'Not a XML response (Content-Type: %s)'\n            % self.mimetype)\n    for module in['xml.etree.ElementTree', 'ElementTree',\n        'elementtree.ElementTree']:\n        etree = import_string(module, silent = True)\n        if etree is not None:\n        return etree.XML(self.body)\n    raise RuntimeError('You must have ElementTree installed '\n        'to use TestResponse.xml')\n", "code_toks_joined": "def xml ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if <STRING> not in self . mimetype : <NEWLINE> <INDENT> raise AttributeError ( <NEWLINE> <INDENT> <STRING> <NEWLINE> % self . mimetype ) <NEWLINE> <DEDENT> <DEDENT> for module in [ <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ] : <NEWLINE> etree = import_string ( module , silent = True ) <NEWLINE> if etree is not None : <NEWLINE> return etree . XML ( self . body ) <NEWLINE> <DEDENT> raise RuntimeError ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get an etree if possible.\"\"\"", "'xml'", "'Not a XML response (Content-Type: %s)'", "'xml.etree.ElementTree'", "'ElementTree'", "'elementtree.ElementTree'", "'You must have ElementTree installed '", "'to use TestResponse.xml'"]}, "err_obj": {"msg": "expected an indented block"}}], ["e81d07afc0e86a551e5901f508901375", {"code_string": "def load(np, typ, cfg):\n    if typ == \"rds\":\n    sink = NP_RDS(np)\n    elif typ == \"icecast\":\n    sink = NP_Icecast(np)\n    elif typ == \"shoutcast\":\n    sink = NP_Shoutcast(np)\n    elif typ == \"ftp\":\n    sink = NP_FTP(np)\n    elif typ == \"udp\":\n    sink = NP_UDP(np)\n    elif typ == \"csv\":\n    sink = NP_CSV(np)\n    else:\n    raise Exception, \"Unknown sink type %s\" %(typ, )\n    sink.config(cfg)\n    return sink\n", "code_toks_joined": "def load ( np , typ , cfg ) : <NEWLINE> <INDENT> if typ == <STRING> : <NEWLINE> sink = NP_RDS ( np ) <NEWLINE> elif typ == <STRING> : <NEWLINE> sink = NP_Icecast ( np ) <NEWLINE> elif typ == <STRING> : <NEWLINE> sink = NP_Shoutcast ( np ) <NEWLINE> elif typ == <STRING> : <NEWLINE> sink = NP_FTP ( np ) <NEWLINE> elif typ == <STRING> : <NEWLINE> sink = NP_UDP ( np ) <NEWLINE> elif typ == <STRING> : <NEWLINE> sink = NP_CSV ( np ) <NEWLINE> else : <NEWLINE> raise Exception , <STRING> % ( typ , ) <NEWLINE> sink . config ( cfg ) <NEWLINE> return sink <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"rds\"", "\"icecast\"", "\"shoutcast\"", "\"ftp\"", "\"udp\"", "\"csv\"", "\"Unknown sink type %s\""]}, "err_obj": {"msg": "expected an indented block"}}], ["dab03a48ef8120fa75723f092de8fbc2", {"code_string": "def _configure(self):\n    \"\"\"Set attributes based on inventory.\"\"\"\n    try:\n        Component._configure(self)\n        self.label(self.inventory.label)\n    except ValueError, err:\n        aliases = \", \".join(self.aliases)\n        raise ValueError(\"Error while configuring spatial database \"\n            \"(%s):\\n%s\" %(aliases, err.message))\n    return\n", "code_toks_joined": "def _configure ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> Component . _configure ( self ) <NEWLINE> self . label ( self . inventory . label ) <NEWLINE> <DEDENT> except ValueError , err : <NEWLINE> <INDENT> aliases = <STRING> . join ( self . aliases ) <NEWLINE> raise ValueError ( <STRING> <NEWLINE> <INDENT> <STRING> % ( aliases , err . message ) ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Set attributes based on inventory.\"\"\"", "\", \"", "\"Error while configuring spatial database \"", "\"(%s):\\n%s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["825561d98f89fdc633cb51d77d83e8e1", {"code_string": "def create_workset_request(message):\n    workseturi = handlers['createWorkset'](message, \"insert\")\n    if workseturi:\n    print(\"Created workset: \", workseturi)\n    emit('createWorksetHandled', workseturi)\n    else:\n    emit('createWorksetFailed')\n", "code_toks_joined": "def create_workset_request ( message ) : <NEWLINE> <INDENT> workseturi = handlers [ <STRING> ] ( message , <STRING> ) <NEWLINE> if workseturi : <NEWLINE> print ( <STRING> , workseturi ) <NEWLINE> emit ( <STRING> , workseturi ) <NEWLINE> else : <NEWLINE> emit ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'createWorkset'", "\"insert\"", "\"Created workset: \"", "'createWorksetHandled'", "'createWorksetFailed'"]}, "err_obj": {"msg": "expected an indented block"}}], ["a09bcbf2b4b4f95155a5e7ae09c13dec", {"code_string": "def _make_app()\n    \"\"\"Set up the API handler.\"\"\"\n    return\n", "code_toks_joined": "def _make_app ( ) <NEWLINE> <INDENT> <STRING> <NEWLINE> return <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Set up the API handler.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["01fecdd3f794fce81d44f8dad545f57d", {"code_string": "def draw_button(self, txt, icon, key):\n    button = gtk.Button()\n        button.connect(\"pressed\", self.callback, key)\n    h_pixbuf = gtk.gdk.pixbuf_new_from_file(ICON + \"tab_h.png\")\n    p_pixbuf = gtk.gdk.pixbuf_new_from_file(ICON + \"tab_p.png\")\n    button.set_size_request(h_pixbuf.get_width(), h_pixbuf.get_height())\n    button.connect(\"expose_event\", self.expose_tab, txt, icon, h_pixbuf, p_pixbuf, key, self.get_id)\n    return button\n", "code_toks_joined": "def draw_button ( self , txt , icon , key ) : <NEWLINE> <INDENT> button = gtk . Button ( ) <NEWLINE> <INDENT> button . connect ( <STRING> , self . callback , key ) <NEWLINE> <DEDENT> h_pixbuf = gtk . gdk . pixbuf_new_from_file ( ICON + <STRING> ) <NEWLINE> p_pixbuf = gtk . gdk . pixbuf_new_from_file ( ICON + <STRING> ) <NEWLINE> button . set_size_request ( h_pixbuf . get_width ( ) , h_pixbuf . get_height ( ) ) <NEWLINE> button . connect ( <STRING> , self . expose_tab , txt , icon , h_pixbuf , p_pixbuf , key , self . get_id ) <NEWLINE> return button <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"pressed\"", "\"tab_h.png\"", "\"tab_p.png\"", "\"expose_event\""]}, "err_obj": {"msg": "unexpected indent"}}], ["78ff2de9de97d5edd6fe984f8473ff34", {"code_string": "def test_017_disconnect_output_not_connected(self):\n    hblock = gr.hier_block2(\"test_block\",\n        gr.io_signature(1, 1, gr.sizeof_int),\n        gr.io_signature(1, 1, gr.sizeof_int))\n    nop1 = blocks.nop(gr.sizeof_int)\n        nop2 = blocks.nop(gr.sizeof_int)\n    hblock.connect(nop1, hblock)\n        self.assertRaises(ValueError,\n            lambda: hblock.disconnect(nop2, hblock))\n", "code_toks_joined": "def test_017_disconnect_output_not_connected ( self ) : <NEWLINE> <INDENT> hblock = gr . hier_block2 ( <STRING> , <NEWLINE> <INDENT> gr . io_signature ( 1 , 1 , gr . sizeof_int ) , <NEWLINE> gr . io_signature ( 1 , 1 , gr . sizeof_int ) ) <NEWLINE> <DEDENT> nop1 = blocks . nop ( gr . sizeof_int ) <NEWLINE> <INDENT> nop2 = blocks . nop ( gr . sizeof_int ) <NEWLINE> <DEDENT> hblock . connect ( nop1 , hblock ) <NEWLINE> <INDENT> self . assertRaises ( ValueError , <NEWLINE> <INDENT> lambda : hblock . disconnect ( nop2 , hblock ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"test_block\""]}, "err_obj": {"msg": "unexpected indent"}}], ["677b79fd304b595cc5d5cc0c464a3566", {"code_string": "def test_database_url_additional_args(self):\n    def mock_database_url_caster(self, url, engine = None):\n        return{'URL': url, 'ENGINE': engine}\n    with patch('configurations.values.DatabaseURLValue.caster',\n        mock_database_url_caster):\n        value = DatabaseURLValue(\n        engine = 'django_mysqlpool.backends.mysqlpool')\n        with env(DATABASE_URL = 'sqlite://'):\n        self.assertEqual(value.setup('DATABASE_URL'), {\n            'default': {\n                'URL': 'sqlite://',\n                'ENGINE': 'django_mysqlpool.backends.mysqlpool'\n            }\n            })\n", "code_toks_joined": "def test_database_url_additional_args ( self ) : <NEWLINE> <INDENT> def mock_database_url_caster ( self , url , engine = None ) : <NEWLINE> <INDENT> return { <STRING> : url , <STRING> : engine } <NEWLINE> <DEDENT> with patch ( <STRING> , <NEWLINE> <INDENT> mock_database_url_caster ) : <NEWLINE> value = DatabaseURLValue ( <NEWLINE> engine = <STRING> ) <NEWLINE> with env ( DATABASE_URL = <STRING> ) : <NEWLINE> self . assertEqual ( value . setup ( <STRING> ) , { <NEWLINE> <INDENT> <STRING> : { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> <DEDENT> } <NEWLINE> } ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'URL'", "'ENGINE'", "'configurations.values.DatabaseURLValue.caster'", "'django_mysqlpool.backends.mysqlpool'", "'sqlite://'", "'DATABASE_URL'", "'default'", "'URL'", "'sqlite://'", "'ENGINE'", "'django_mysqlpool.backends.mysqlpool'"]}, "err_obj": {"msg": "expected an indented block"}}], ["760bfb6b3c116ca1cdab278d57e3bb78", {"code_string": "def fixup(dir):\n    for root, dirs, files in os.walk(dir):\n    for f in files:\n        if f.endswith('.h'):\n    path = \"%s\\\\%s\" %(root, f)\n    fix_hdr(path)\n", "code_toks_joined": "def fixup ( dir ) : <NEWLINE> <INDENT> for root , dirs , files in os . walk ( dir ) : <NEWLINE> for f in files : <NEWLINE> <INDENT> if f . endswith ( <STRING> ) : <NEWLINE> <DEDENT> path = <STRING> % ( root , f ) <NEWLINE> fix_hdr ( path ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'.h'", "\"%s\\\\%s\""]}, "err_obj": {"msg": "expected an indented block"}}], ["5c3ff16f4547b0fdd396270c90c4c290", {"code_string": "def test_set_device_status_mismatch(self):\n    with mock.patch(\"neutron.plugins.ml2.drivers.mech_sriov.agent.\"\n        \"eswitch_manager.EmbSwitch.get_pci_device\",\n        return_value = self.ASSIGNED_MAC), mock.patch(\"neutron.plugins.ml2.drivers.mech_sriov.agent.\"\n            \"eswitch_manager.EmbSwitch.set_device_state\"):\n            with mock.patch(\"neutron.plugins.ml2.drivers.mech_sriov.agent.\"\n                \"eswitch_manager.LOG.warning\") as log_mock:\n                self.eswitch_mgr.set_device_state(self.WRONG_MAC,\n                    self.PCI_SLOT, True)\n                    log_mock.assert_called_with('device pci mismatch: '\n                    '%(device_mac)s - %(pci_slot)s',\n                    {'pci_slot': self.PCI_SLOT,\n                    'device_mac': self.WRONG_MAC})\n", "code_toks_joined": "def test_set_device_status_mismatch ( self ) : <NEWLINE> <INDENT> with mock . patch ( <STRING> <NEWLINE> <INDENT> <STRING> , <NEWLINE> return_value = self . ASSIGNED_MAC ) , mock . patch ( <STRING> <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> with mock . patch ( <STRING> <NEWLINE> <INDENT> <STRING> ) as log_mock : <NEWLINE> self . eswitch_mgr . set_device_state ( self . WRONG_MAC , <NEWLINE> <INDENT> self . PCI_SLOT , True ) <NEWLINE> log_mock . assert_called_with ( <STRING> <NEWLINE> <STRING> , <NEWLINE> { <STRING> : self . PCI_SLOT , <NEWLINE> <STRING> : self . WRONG_MAC } ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"neutron.plugins.ml2.drivers.mech_sriov.agent.\"", "\"eswitch_manager.EmbSwitch.get_pci_device\"", "\"neutron.plugins.ml2.drivers.mech_sriov.agent.\"", "\"eswitch_manager.EmbSwitch.set_device_state\"", "\"neutron.plugins.ml2.drivers.mech_sriov.agent.\"", "\"eswitch_manager.LOG.warning\"", "'device pci mismatch: '", "'%(device_mac)s - %(pci_slot)s'", "'pci_slot'", "'device_mac'"]}, "err_obj": {"msg": "unexpected indent"}}], ["cd5e0160776d31d6d166f12c50ed1fbb", {"code_string": "class Term(BaseAccounting):\n    def to_dict(self):\n        if self.obj == None:\n        return{}\n        return{\n            'Name': self.obj.GetName().decode(GC_ENC),\n            'Description': self.obj.GetDescription().decode(GC_ENC),\n            'DueDays': self.obj.GetDueDays(),\n        }\n", "code_toks_joined": "class Term ( BaseAccounting ) : <NEWLINE> <INDENT> def to_dict ( self ) : <NEWLINE> <INDENT> if self . obj == None : <NEWLINE> return { } <NEWLINE> return { <NEWLINE> <INDENT> <STRING> : self . obj . GetName ( ) . decode ( GC_ENC ) , <NEWLINE> <STRING> : self . obj . GetDescription ( ) . decode ( GC_ENC ) , <NEWLINE> <STRING> : self . obj . GetDueDays ( ) , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Name'", "'Description'", "'DueDays'"]}, "err_obj": {"msg": "expected an indented block"}}], ["90815faf9ba641e8cceb7da53a48a3e6", {"code_string": "def sendtoBh_sock(self, data):\n    client_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n    client_socket.connect(\"/tmp/Blackhole.socket\")\n    client_socket.send(data)\n        client_socket.close()\n", "code_toks_joined": "def sendtoBh_sock ( self , data ) : <NEWLINE> <INDENT> client_socket = socket . socket ( socket . AF_UNIX , socket . SOCK_STREAM ) <NEWLINE> client_socket . connect ( <STRING> ) <NEWLINE> client_socket . send ( data ) <NEWLINE> <INDENT> client_socket . close ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"/tmp/Blackhole.socket\""]}, "err_obj": {"msg": "unexpected indent"}}], ["24e6d094f1c321a2a8cdd7e4595dfe55", {"code_string": "def _listing_iter(self, account_name, lcontainer, lprefix, req):\n    try:\n        for page in self._listing_pages_iter(account_name, lcontainer,\n            lprefix, req.environ):\n            for item in page:\n            yield item\n    except ListingIterNotFound:\n        pass\n    except HTTPPreconditionFailed:\n        raise HTTPPreconditionFailed(request = req)\n    except ListingIterError:\n        raise HTTPServerError(request = req)\n", "code_toks_joined": "def _listing_iter ( self , account_name , lcontainer , lprefix , req ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> for page in self . _listing_pages_iter ( account_name , lcontainer , <NEWLINE> <INDENT> lprefix , req . environ ) : <NEWLINE> for item in page : <NEWLINE> yield item <NEWLINE> <DEDENT> <DEDENT> except ListingIterNotFound : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> except HTTPPreconditionFailed : <NEWLINE> <INDENT> raise HTTPPreconditionFailed ( request = req ) <NEWLINE> <DEDENT> except ListingIterError : <NEWLINE> <INDENT> raise HTTPServerError ( request = req ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["b79d350b4e9f6cc4c4434c0f46bc9ae0", {"code_string": "def draw_bearing((x, y), my_dict):\n    drawCircle(my_dict['bearing_diameter'] / 2, (x, - y), my_dict['parent'])\n    drawCircle(my_dict['screw_diameter'] / 2, (x - my_dict['screw_offset'], - y), my_dict['parent'])\n    drawCircle(my_dict['screw_diameter'] / 2, (x + my_dict['screw_offset'], - y), my_dict['parent'])\n", "code_toks_joined": "def draw_bearing ( ( x , y ) , my_dict ) : <NEWLINE> <INDENT> drawCircle ( my_dict [ <STRING> ] / 2 , ( x , - y ) , my_dict [ <STRING> ] ) <NEWLINE> drawCircle ( my_dict [ <STRING> ] / 2 , ( x - my_dict [ <STRING> ] , - y ) , my_dict [ <STRING> ] ) <NEWLINE> drawCircle ( my_dict [ <STRING> ] / 2 , ( x + my_dict [ <STRING> ] , - y ) , my_dict [ <STRING> ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'bearing_diameter'", "'parent'", "'screw_diameter'", "'screw_offset'", "'parent'", "'screw_diameter'", "'screw_offset'", "'parent'"]}, "err_obj": {"msg": "invalid syntax"}}], ["ea44567c312bd6a999da1a33f07751d1", {"code_string": "import re\nfrom utils import *\nPhase = enum(WRAPPER_WAIT = 1, SCRIPT_WAIT = 2, TEMPLATES_WAIT = 3, RUN_WAIT = 4, DONE = 5, GIVENUP = 6)\ntemplate = \"experiment-machine-script-template.sh\"\ndirname = \"./\"\nenv_ht = {}\ncloud = \"euca\"\nis_done = lambda(instance, public, status, port): (status == \"running\" and not public.startswith(\"server-\"))\nnum_attempts = 10\n", "code_toks_joined": "import re <NEWLINE> from utils import * <NEWLINE> Phase = enum ( WRAPPER_WAIT = 1 , SCRIPT_WAIT = 2 , TEMPLATES_WAIT = 3 , RUN_WAIT = 4 , DONE = 5 , GIVENUP = 6 ) <NEWLINE> template = <STRING> <NEWLINE> dirname = <STRING> <NEWLINE> env_ht = { } <NEWLINE> cloud = <STRING> <NEWLINE> is_done = lambda ( instance , public , status , port ) : ( status == <STRING> and not public . startswith ( <STRING> ) ) <NEWLINE> num_attempts = 10 <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"experiment-machine-script-template.sh\"", "\"./\"", "\"euca\"", "\"running\"", "\"server-\""]}, "err_obj": {"msg": "invalid syntax"}}], ["d25c097642c3ac2ebf36a391a42a9c43", {"code_string": "def _string_common(cls, column, field_args, ** extra):\n    if column.type.length:\n        field_args['validators'].append(validators.Length(max = column.type.length)\n", "code_toks_joined": "def _string_common ( cls , column , field_args , ** extra ) : <NEWLINE> <INDENT> if column . type . length : <NEWLINE> <INDENT> field_args [ <STRING> ] . append ( validators . Length ( max = column . type . length ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'validators'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["6f17883617b65ac54162764bfc23dc62", {"code_string": "class InvalidSeverityError(ImportException):\n    def __init__(self, * rest):\n    ImportException.__init__(self, rest)\n", "code_toks_joined": "class InvalidSeverityError ( ImportException ) : <NEWLINE> <INDENT> def __init__ ( self , * rest ) : <NEWLINE> ImportException . __init__ ( self , rest ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["e6dab175add4e1fc72fe10f12e8df686", {"code_string": "def testDepthwiseConv2DInputGrad(self):\n    for index, (input_size, filter_size, output_size, stride,\n        padding) in enumerate(CheckGradConfigsToTest()):\n        print(\"Processing \", index, \"th config.\")\n        for use_gpu in[True, False]:\n        self._ConstructAndTestGradient(input_size,\n            filter_size,\n            output_size,\n            stride,\n            padding,\n            tf.float32,\n            test_input = True,\n            use_gpu = use_gpu)\n", "code_toks_joined": "def testDepthwiseConv2DInputGrad ( self ) : <NEWLINE> <INDENT> for index , ( input_size , filter_size , output_size , stride , <NEWLINE> <INDENT> padding ) in enumerate ( CheckGradConfigsToTest ( ) ) : <NEWLINE> print ( <STRING> , index , <STRING> ) <NEWLINE> for use_gpu in [ True , False ] : <NEWLINE> self . _ConstructAndTestGradient ( input_size , <NEWLINE> <INDENT> filter_size , <NEWLINE> output_size , <NEWLINE> stride , <NEWLINE> padding , <NEWLINE> tf . float32 , <NEWLINE> test_input = True , <NEWLINE> use_gpu = use_gpu ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Processing \"", "\"th config.\""]}, "err_obj": {"msg": "expected an indented block"}}], ["7b13ed33a71ffe4efff6eddb25d1e769", {"code_string": "def coerce(self, argument):\n    for handles, handle in[(self._is_string, self._handle_string),\n        (self._is_number, self._pass_through),\n        (is_dict_like, self._coerce_dict),\n        (is_list_like, self._coerce_list),\n        (lambda arg: True, self._to_string)]:\n        if handles(argument):\n        return handle(argument)\n", "code_toks_joined": "def coerce ( self , argument ) : <NEWLINE> <INDENT> for handles , handle in [ ( self . _is_string , self . _handle_string ) , <NEWLINE> <INDENT> ( self . _is_number , self . _pass_through ) , <NEWLINE> ( is_dict_like , self . _coerce_dict ) , <NEWLINE> ( is_list_like , self . _coerce_list ) , <NEWLINE> ( lambda arg : True , self . _to_string ) ] : <NEWLINE> if handles ( argument ) : <NEWLINE> return handle ( argument ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["0fe3c86ee98d09c49215d4b20fe4293f", {"code_string": "def init_screen(self):\n    pygame.draw.rect(self.screen, (154, 255, 154), (0, 0, 640, 480), 0)\n    myfont = pygame.font.SysFont(\"monospace\", 30)\n    welcome = myfont.render(\"WELCOME TO SWIM LITTLE FISH SWIM!\", 1, (47, 79, 79))\n    self.screen.blit(welcome, (30, 210)))\n    pygame.display.update()\n", "code_toks_joined": "def init_screen ( self ) : <NEWLINE> <INDENT> pygame . draw . rect ( self . screen , ( 154 , 255 , 154 ) , ( 0 , 0 , 640 , 480 ) , 0 ) <NEWLINE> myfont = pygame . font . SysFont ( <STRING> , 30 ) <NEWLINE> welcome = myfont . render ( <STRING> , 1 , ( 47 , 79 , 79 ) ) <NEWLINE> self . screen . blit ( welcome , ( 30 , 210 ) ) ) <NEWLINE> pygame . display . update ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"monospace\"", "\"WELCOME TO SWIM LITTLE FISH SWIM!\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["da6c00e82903ae433b6698665cb416cd", {"code_string": "def maxrss():\n    \"\"\"Return maximal resident memory size in bytes.\"\"\"\n    for name in('VmHWM:',\n        'VmRss:',\n        'VmPeak:',\n        'VmSize:',\n        ):\n        mm = _VmB(name)\n        if mm > 0:\n        return mm\n    mm = resource.getrusage(resource.RUSAGE_SELF)[2]\n    if mm > 0:\n        if mm <(1024) ** 2:\n            mm = mm * 1024\n        return mm\n    return 0.0\n", "code_toks_joined": "def maxrss ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for name in ( <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> ) : <NEWLINE> mm = _VmB ( name ) <NEWLINE> if mm > 0 : <NEWLINE> return mm <NEWLINE> <DEDENT> mm = resource . getrusage ( resource . RUSAGE_SELF ) [ 2 ] <NEWLINE> if mm > 0 : <NEWLINE> <INDENT> if mm < ( 1024 ) ** 2 : <NEWLINE> <INDENT> mm = mm * 1024 <NEWLINE> <DEDENT> return mm <NEWLINE> <DEDENT> return 0.0 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return maximal resident memory size in bytes.\"\"\"", "'VmHWM:'", "'VmRss:'", "'VmPeak:'", "'VmSize:'"]}, "err_obj": {"msg": "expected an indented block"}}], ["f6e58be44c483f8307f0ff80f2814a39", {"code_string": "class DiscontigScannerGroup(ScannerGroup):\n    \"\"\"A scanner group which works over a virtual address space.\"\"\"\n    def scan(self, offset = 0, maxlen = None):\n        maxlen = maxlen or self.session.profile.get_constant(\"MaxPointer\")\n        for(start, _, length) in self.address_space.get_address_ranges(\n            offset, offset + maxlen):\n            for match in super(DiscontigScannerGroup, self).scan(\n                start, maxlen = length):\n            yield match\n", "code_toks_joined": "class DiscontigScannerGroup ( ScannerGroup ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def scan ( self , offset = 0 , maxlen = None ) : <NEWLINE> <INDENT> maxlen = maxlen or self . session . profile . get_constant ( <STRING> ) <NEWLINE> for ( start , _ , length ) in self . address_space . get_address_ranges ( <NEWLINE> <INDENT> offset , offset + maxlen ) : <NEWLINE> for match in super ( DiscontigScannerGroup , self ) . scan ( <NEWLINE> <INDENT> start , maxlen = length ) : <NEWLINE> <DEDENT> yield match <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"A scanner group which works over a virtual address space.\"\"\"", "\"MaxPointer\""]}, "err_obj": {"msg": "expected an indented block"}}], ["320f7a0a97958298f0cfaca75dd81434", {"code_string": "def setupUi(self, MainWindow):\n    MainWindow.setObjectName(_fromUtf8(\"MainWindow\"))\n    MainWindow.resize(457, 560)\n    sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(MainWindow.sizePolicy().hasHeightForWidth())\n    MainWindow.setSizePolicy(sizePolicy)\n    icon = QtGui.QIcon()\n    icon.addPixmap(QtGui.QPixmap(_fromUtf8(\":/images/images/icon.png\")), QtGui.QIcon.Normal, QtGui.QIcon.Off)\n    MainWindow.setWindowIcon(icon)\n    self.centralwidget = QtGui.QWidget(MainWindow)\n    sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Preferred)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(self.centralwidget.sizePolicy().hasHeightForWidth())\n    self.centralwidget.setSizePolicy(sizePolicy)\n    self.centralwidget.setObjectName(_fromUtf8(\"centralwidget\"))\n    self.verticalLayout_2 = QtGui.QVBoxLayout(self.centralwidget)\n    self.verticalLayout_2.setContentsMargins(10, 0, 10, 0)\n    self.verticalLayout_2.setSpacing(0)\n    self.verticalLayout_2.setObjectName(_fromUtf8(\"verticalLayout_2\"))\n    self.buttonsBar = QtGui.QWidget(self.centralwidget)\n    sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Maximum, QtGui.QSizePolicy.Fixed)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(self.buttonsBar.sizePolicy().hasHeightForWidth())\n    self.buttonsBar.setSizePolicy(sizePolicy)\n    self.buttonsBar.setMinimumSize(QtCore.QSize(0, 70))\n    self.buttonsBar.setMaximumSize(QtCore.QSize(500, 70))\n    self.buttonsBar.setObjectName(_fromUtf8(\"buttonsBar\"))\n    self.horizontalLayout_3 = QtGui.QHBoxLayout(self.buttonsBar)\n    self.horizontalLayout_3.setContentsMargins(0, 10, 0, 10)\n    self.horizontalLayout_3.setSpacing(6)\n    self.horizontalLayout_3.setObjectName(_fromUtf8(\"horizontalLayout_3\"))\n    self.button_start = QtGui.QPushButton(self.buttonsBar)\n    sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)\n    sizePolicy.setHorizontalStretch(2)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(self.button_start.sizePolicy().hasHeightForWidth())\n    self.button_start.setSizePolicy(sizePolicy)\n    self.button_start.setMinimumSize(QtCore.QSize(259, 50))\n    self.button_start.setMaximumSize(QtCore.QSize(259, 50))\n    font = QtGui.QFont()\n    font.setPointSize(16)\n    self.button_start.setFont(font)\n    self.button_start.setAutoFillBackground(False)\n    self.button_start.setStyleSheet(_fromUtf8(\"QPushButton {\\n\"\n", "code_toks_joined": "def setupUi ( self , MainWindow ) : <NEWLINE> <INDENT> MainWindow . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> MainWindow . resize ( 457 , 560 ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Minimum , QtGui . QSizePolicy . Preferred ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( MainWindow . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> MainWindow . setSizePolicy ( sizePolicy ) <NEWLINE> icon = QtGui . QIcon ( ) <NEWLINE> icon . addPixmap ( QtGui . QPixmap ( _fromUtf8 ( <STRING> ) ) , QtGui . QIcon . Normal , QtGui . QIcon . Off ) <NEWLINE> MainWindow . setWindowIcon ( icon ) <NEWLINE> self . centralwidget = QtGui . QWidget ( MainWindow ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Minimum , QtGui . QSizePolicy . Preferred ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( self . centralwidget . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> self . centralwidget . setSizePolicy ( sizePolicy ) <NEWLINE> self . centralwidget . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . verticalLayout_2 = QtGui . QVBoxLayout ( self . centralwidget ) <NEWLINE> self . verticalLayout_2 . setContentsMargins ( 10 , 0 , 10 , 0 ) <NEWLINE> self . verticalLayout_2 . setSpacing ( 0 ) <NEWLINE> self . verticalLayout_2 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . buttonsBar = QtGui . QWidget ( self . centralwidget ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Maximum , QtGui . QSizePolicy . Fixed ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( self . buttonsBar . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> self . buttonsBar . setSizePolicy ( sizePolicy ) <NEWLINE> self . buttonsBar . setMinimumSize ( QtCore . QSize ( 0 , 70 ) ) <NEWLINE> self . buttonsBar . setMaximumSize ( QtCore . QSize ( 500 , 70 ) ) <NEWLINE> self . buttonsBar . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . horizontalLayout_3 = QtGui . QHBoxLayout ( self . buttonsBar ) <NEWLINE> self . horizontalLayout_3 . setContentsMargins ( 0 , 10 , 0 , 10 ) <NEWLINE> self . horizontalLayout_3 . setSpacing ( 6 ) <NEWLINE> self . horizontalLayout_3 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . button_start = QtGui . QPushButton ( self . buttonsBar ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Fixed , QtGui . QSizePolicy . Fixed ) <NEWLINE> sizePolicy . setHorizontalStretch ( 2 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( self . button_start . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> self . button_start . setSizePolicy ( sizePolicy ) <NEWLINE> self . button_start . setMinimumSize ( QtCore . QSize ( 259 , 50 ) ) <NEWLINE> self . button_start . setMaximumSize ( QtCore . QSize ( 259 , 50 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setPointSize ( 16 ) <NEWLINE> self . button_start . setFont ( font ) <NEWLINE> self . button_start . setAutoFillBackground ( False ) <NEWLINE> self . button_start . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"MainWindow\"", "\":/images/images/icon.png\"", "\"centralwidget\"", "\"verticalLayout_2\"", "\"buttonsBar\"", "\"horizontalLayout_3\"", "\"QPushButton {\\n\""]}, "window_span": [564, 570], "err_obj": {"msg": "unbalanced (){}[]"}}], ["a781ba1f0d3b0d515db5e17f5025c169", {"code_string": "def testGetPowerData_packageCollisionDifferent(self):\n    self.battery._cache['uids'] = {'test_package1': '1'}\n    with self.assertCall(\n        self.call.device.RunShellCommand(\n            ['dumpsys', 'batterystats', '-c'],\n            check_return = True, large_output = True),\n        _DUMPSYS_OUTPUT):\n        with self.assertRaises(device_errors.CommandFailedError):\n        self.battery.GetPowerData()\n", "code_toks_joined": "def testGetPowerData_packageCollisionDifferent ( self ) : <NEWLINE> <INDENT> self . battery . _cache [ <STRING> ] = { <STRING> : <STRING> } <NEWLINE> with self . assertCall ( <NEWLINE> <INDENT> self . call . device . RunShellCommand ( <NEWLINE> <INDENT> [ <STRING> , <STRING> , <STRING> ] , <NEWLINE> check_return = True , large_output = True ) , <NEWLINE> <DEDENT> _DUMPSYS_OUTPUT ) : <NEWLINE> with self . assertRaises ( device_errors . CommandFailedError ) : <NEWLINE> self . battery . GetPowerData ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'uids'", "'test_package1'", "'1'", "'dumpsys'", "'batterystats'", "'-c'"]}, "err_obj": {"msg": "expected an indented block"}}], ["a53b58d16775d9d7ebb5dc1e9b6676ac", {"code_string": "def test_field_validation_error(testapp):\n    def always_fail(value):\n        raise ValidationError('something went wrong')\n    args = {'text': fields.Field(validate = always_fail)}\n    with testapp.test_request_context('/foo', data = json.dumps({'text': 'bar'}),\n        content_type = 'application/json', method = 'POST'):\n        with pytest.raises(HTTPException) as excinfo:\n        parser.parse(args, locations = ('json', ))\n    exc = excinfo.value\n    assert exc.code == 422\n", "code_toks_joined": "def test_field_validation_error ( testapp ) : <NEWLINE> <INDENT> def always_fail ( value ) : <NEWLINE> <INDENT> raise ValidationError ( <STRING> ) <NEWLINE> <DEDENT> args = { <STRING> : fields . Field ( validate = always_fail ) } <NEWLINE> with testapp . test_request_context ( <STRING> , data = json . dumps ( { <STRING> : <STRING> } ) , <NEWLINE> <INDENT> content_type = <STRING> , method = <STRING> ) : <NEWLINE> with pytest . raises ( HTTPException ) as excinfo : <NEWLINE> parser . parse ( args , locations = ( <STRING> , ) ) <NEWLINE> <DEDENT> exc = excinfo . value <NEWLINE> assert exc . code == 422 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'something went wrong'", "'text'", "'/foo'", "'text'", "'bar'", "'application/json'", "'POST'", "'json'"]}, "err_obj": {"msg": "expected an indented block"}}], ["b4e8248af6761a9b055b14ef40892ef7", {"code_string": "def train(self, labeled_data):\n    self.feature_distribution = CounterMap()\n    labels = set()\n    for label, datum in labeled_data:\n        labels.add(label)\n        for feature in ngrams(datum, 3)\n            self.feature_distribution[feature][label] += 1\n    for feature in self.feature_distribution.iterkeys():\n        self.feature_distribution[feature].default = 0.01\n    self.feature_distribution.normalize()\n    self.feature_distribution.log()\n", "code_toks_joined": "def train ( self , labeled_data ) : <NEWLINE> <INDENT> self . feature_distribution = CounterMap ( ) <NEWLINE> labels = set ( ) <NEWLINE> for label , datum in labeled_data : <NEWLINE> <INDENT> labels . add ( label ) <NEWLINE> for feature in ngrams ( datum , 3 ) <NEWLINE> <INDENT> self . feature_distribution [ feature ] [ label ] += 1 <NEWLINE> <DEDENT> <DEDENT> for feature in self . feature_distribution . iterkeys ( ) : <NEWLINE> <INDENT> self . feature_distribution [ feature ] . default = 0.01 <NEWLINE> <DEDENT> self . feature_distribution . normalize ( ) <NEWLINE> self . feature_distribution . log ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["f861642319ddaf3fd42606fce2ceba71", {"code_string": "def rename(self, inner_path_before, inner_path_after):\n    for retry in range(3):\n        try:\n            os.rename(self.getPath(inner_path_before), self.getPath(inner_path_after))\n            err = None\n            break\n        except Exception, err:\n            self.log.error(\"%s rename error: %s (retry #%s)\" %(inner_path_before, err, retry))\n            time.sleep(0.1 + retry)\n    if err:\n        raise err\n", "code_toks_joined": "def rename ( self , inner_path_before , inner_path_after ) : <NEWLINE> <INDENT> for retry in range ( 3 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> os . rename ( self . getPath ( inner_path_before ) , self . getPath ( inner_path_after ) ) <NEWLINE> err = None <NEWLINE> break <NEWLINE> <DEDENT> except Exception , err : <NEWLINE> <INDENT> self . log . error ( <STRING> % ( inner_path_before , err , retry ) ) <NEWLINE> time . sleep ( 0.1 + retry ) <NEWLINE> <DEDENT> <DEDENT> if err : <NEWLINE> <INDENT> raise err <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"%s rename error: %s (retry #%s)\""]}, "err_obj": {"msg": "invalid syntax"}}], ["bd9590faab98c2fdb1f545916230eee7", {"code_string": "class ReaderPosition(object):\n    \"\"\"A representation of position in an iteration of a 'NativeSourceReader'.\"\"\"\n    def __init__(self, end = None, key = None, byte_offset = None, record_index = None,\n        shuffle_position = None, concat_position = None):\n        \"\"\"Initializes ReaderPosition.\"\"\"\n        self.end = end\n        self.key = key\n        self.byte_offset = byte_offset\n        self.record_index = record_index\n        self.shuffle_position = shuffle_position\n        if concat_position is not None:\n        assert isinstance(concat_position, ConcatPosition)\n        self.concat_position = concat_position\n", "code_toks_joined": "class ReaderPosition ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , end = None , key = None , byte_offset = None , record_index = None , <NEWLINE> <INDENT> shuffle_position = None , concat_position = None ) : <NEWLINE> <STRING> <NEWLINE> self . end = end <NEWLINE> self . key = key <NEWLINE> self . byte_offset = byte_offset <NEWLINE> self . record_index = record_index <NEWLINE> self . shuffle_position = shuffle_position <NEWLINE> if concat_position is not None : <NEWLINE> assert isinstance ( concat_position , ConcatPosition ) <NEWLINE> self . concat_position = concat_position <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"A representation of position in an iteration of a 'NativeSourceReader'.\"\"\"", "\"\"\"Initializes ReaderPosition.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["8b0ed9c1bc58a758e229e39e77228bcc", {"code_string": "def run_ofctl(self, cmd, args):\n    full_args = [\"ovs-ofctl\", cmd, self.br_name] + args\n    try:\n        return utils.execute(full_args, root_helper = self.root_helper)\n    except Exception, e:\n        LOG.error(_(\"Unable to execute %(cmd)s. Exception: %(exception)s\"),\n            {'cmd': full_args, 'exception': e})\n", "code_toks_joined": "def run_ofctl ( self , cmd , args ) : <NEWLINE> <INDENT> full_args = [ <STRING> , cmd , self . br_name ] + args <NEWLINE> try : <NEWLINE> <INDENT> return utils . execute ( full_args , root_helper = self . root_helper ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> LOG . error ( _ ( <STRING> ) , <NEWLINE> <INDENT> { <STRING> : full_args , <STRING> : e } ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"ovs-ofctl\"", "\"Unable to execute %(cmd)s. Exception: %(exception)s\"", "'cmd'", "'exception'"]}, "err_obj": {"msg": "invalid syntax"}}], ["81ea64150ea5d7290f68f9707aec0dab", {"code_string": "def json_to_array(string, dtype):\n    \"\"\"Create an array from a JSON string, as the specified data type.\"\"\"\n        return np.fromiter(json.loads(string), dtype)\n", "code_toks_joined": "def json_to_array ( string , dtype ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> return np . fromiter ( json . loads ( string ) , dtype ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Create an array from a JSON string, as the specified data type.\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["e38488e252bc2687e587479c229fb8a1", {"code_string": "class LttreeSettings(BasicUISettings):\n    def __init__(self,\n        user_bindings_x = None,\n        user_bindings = None,\n        order_method = 'by_command'):\n        BasicUISettings.__init__(self,\n            user_bindings_x,\n            user_bindings,\n            order_method)\n            self.column_names = []\n            self.ii_coords = []\n            self.ii_vects = []\n            self.i_atomid = None\n            self.i_atomtype = None\n            self.i_molid = None\n            self.infile = None\n", "code_toks_joined": "class LttreeSettings ( BasicUISettings ) : <NEWLINE> <INDENT> def __init__ ( self , <NEWLINE> <INDENT> user_bindings_x = None , <NEWLINE> user_bindings = None , <NEWLINE> order_method = <STRING> ) : <NEWLINE> BasicUISettings . __init__ ( self , <NEWLINE> <INDENT> user_bindings_x , <NEWLINE> user_bindings , <NEWLINE> order_method ) <NEWLINE> self . column_names = [ ] <NEWLINE> self . ii_coords = [ ] <NEWLINE> self . ii_vects = [ ] <NEWLINE> self . i_atomid = None <NEWLINE> self . i_atomtype = None <NEWLINE> self . i_molid = None <NEWLINE> self . infile = None <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'by_command'"]}, "err_obj": {"msg": "unexpected indent"}}], ["05dba44c040b83614cb7e9cb62cd40db", {"code_string": "def macros(lines):\n    for line in string.split(lines, \"\\n\"):\n        if not re.match(r\"\\s*$\", line):\n            return_type, name, arg_types = extract_macro(line)\n            if return_type:\n    emit_redef(return_type, name, arg_types)\n", "code_toks_joined": "def macros ( lines ) : <NEWLINE> <INDENT> for line in string . split ( lines , <STRING> ) : <NEWLINE> <INDENT> if not re . match ( <STRING> , line ) : <NEWLINE> <INDENT> return_type , name , arg_types = extract_macro ( line ) <NEWLINE> if return_type : <NEWLINE> <DEDENT> <DEDENT> emit_redef ( return_type , name , arg_types ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\\n\"", "r\"\\s*$\""]}, "err_obj": {"msg": "expected an indented block"}}], ["24288aa4f818f26b46b385752dc04ff8", {"code_string": "def print_device_event(device):\n    '''Print details of a device added or removed'''\n    global current_devices\n    global observer\n    global ser_port\n    print(list(device.items()))\n    if device.action == 'add':\n    print(\"device added\")\n    elif device.action == 'remove':\n    print(\"device removed\")\n    else:\n    print(\"act: \" + str(device.action))\n    if device.subsystem == 'tty':\n    print('tty: ' + device['DEVNAME'])\n    ser_port = device['DEVNAME']\n    observer.stop()\n", "code_toks_joined": "def print_device_event ( device ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> global current_devices <NEWLINE> global observer <NEWLINE> global ser_port <NEWLINE> print ( list ( device . items ( ) ) ) <NEWLINE> if device . action == <STRING> : <NEWLINE> print ( <STRING> ) <NEWLINE> elif device . action == <STRING> : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> + str ( device . action ) ) <NEWLINE> if device . subsystem == <STRING> : <NEWLINE> print ( <STRING> + device [ <STRING> ] ) <NEWLINE> ser_port = device [ <STRING> ] <NEWLINE> observer . stop ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Print details of a device added or removed'''", "'add'", "\"device added\"", "'remove'", "\"device removed\"", "\"act: \"", "'tty'", "'tty: '", "'DEVNAME'", "'DEVNAME'"]}, "err_obj": {"msg": "expected an indented block"}}], ["46f4c78bf54c6b0a5b9ec0ba78da81be", {"code_string": "def process_request(self, client, addr):\n    client.setblocking(1)\n    client.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n    flags = fcntl.fcntl(client, fcntl.F_GETFD) | fcntl.FD_CLOEXEC\n    fcntl.fcntl(client, fcntl.F_SETFD, flags)\n    self.server.socket = client\n    try:\n        self.server.process_request(client, addr)\n    except IOError, e:\n        if e.errno != errno.EPIPE:\n            raise\n    self.request_count += 1\n", "code_toks_joined": "def process_request ( self , client , addr ) : <NEWLINE> <INDENT> client . setblocking ( 1 ) <NEWLINE> client . setsockopt ( socket . IPPROTO_TCP , socket . TCP_NODELAY , 1 ) <NEWLINE> flags = fcntl . fcntl ( client , fcntl . F_GETFD ) | fcntl . FD_CLOEXEC <NEWLINE> fcntl . fcntl ( client , fcntl . F_SETFD , flags ) <NEWLINE> self . server . socket = client <NEWLINE> try : <NEWLINE> <INDENT> self . server . process_request ( client , addr ) <NEWLINE> <DEDENT> except IOError , e : <NEWLINE> <INDENT> if e . errno != errno . EPIPE : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> <DEDENT> self . request_count += 1 <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["087423cbc1f98d2672b34fceb520a075", {"code_string": "def main():\n    parser = ParseGLC(10, 6)\n    for d in parser.scraped_data:\n        print(\"sub_subject: %s\\n\\nsubject: %s\\n\\ntext: %s\\n\\n\\n\\n\" %(d[\"subtitle\"], d[\"title\"], d[\"decision\"])\n    parser = ParseGLC(11, 4)\n    for d in parser.scraped_data:\n        print(\"sub_subject: %s\\n\\nsubject: %s\\n\\ntext: %s\\n\\n\\n\\n\" %(d[\"subtitle\"], d[\"title\"], d[\"decision\"]))\n", "code_toks_joined": "def main ( ) : <NEWLINE> <INDENT> parser = ParseGLC ( 10 , 6 ) <NEWLINE> for d in parser . scraped_data : <NEWLINE> <INDENT> print ( <STRING> % ( d [ <STRING> ] , d [ <STRING> ] , d [ <STRING> ] ) <NEWLINE> <DEDENT> parser = ParseGLC ( 11 , 4 ) <NEWLINE> for d in parser . scraped_data : <NEWLINE> <INDENT> print ( <STRING> % ( d [ <STRING> ] , d [ <STRING> ] , d [ <STRING> ] ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"sub_subject: %s\\n\\nsubject: %s\\n\\ntext: %s\\n\\n\\n\\n\"", "\"subtitle\"", "\"title\"", "\"decision\"", "\"sub_subject: %s\\n\\nsubject: %s\\n\\ntext: %s\\n\\n\\n\\n\"", "\"subtitle\"", "\"title\"", "\"decision\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["dec411fb4028d27dca09f901e311b9d9", {"code_string": "class Main:\n    def __init__(self, dir, database = \"default\"):\n        self.start_dir = os.getcwd()\n        self.dir = dir\n        self.database = database\n    def main()\n        os.chdir(self.dir)\n        self.database = database.init(self.database)\n        template.init(self.database)\n", "code_toks_joined": "class Main : <NEWLINE> <INDENT> def __init__ ( self , dir , database = <STRING> ) : <NEWLINE> <INDENT> self . start_dir = os . getcwd ( ) <NEWLINE> self . dir = dir <NEWLINE> self . database = database <NEWLINE> <DEDENT> def main ( ) <NEWLINE> <INDENT> os . chdir ( self . dir ) <NEWLINE> self . database = database . init ( self . database ) <NEWLINE> template . init ( self . database ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"default\""]}, "err_obj": {"msg": "invalid syntax"}}], ["bb1cc6004c7b7df186b6a73d84e039c1", {"code_string": "class MustCoupError(Exception):\n    def __init__(self, conn):\n    self.conn = conn\n    conn.sendall(\"You have 10 or more coins, you must Coup.\\n\")\n", "code_toks_joined": "class MustCoupError ( Exception ) : <NEWLINE> <INDENT> def __init__ ( self , conn ) : <NEWLINE> self . conn = conn <NEWLINE> conn . sendall ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"You have 10 or more coins, you must Coup.\\n\""]}, "err_obj": {"msg": "expected an indented block"}}], ["3abca5a5b92b4f660ccc63bececfc9e9", {"code_string": "def _refresh_view_trigger(self change):\n    \"\"\" An observer which triggers a compiled view refresh.\"\"\"\n    self.refresh_view()\n", "code_toks_joined": "def _refresh_view_trigger ( self change ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . refresh_view ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" An observer which triggers a compiled view refresh.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["7c2365e5ce8509163043ff09357da766", {"code_string": "def ExportDynamicResults(self, options = {}, progress = None):\n    progupdate = None\n    if progress is not None: progupdate = progress.Update\n    oldoptions = self._updateOptions(options)\n    try:\n    CallInternalPlugin(EOFTPLUGIN_DYNAMICRESULTSEXPORT, self, progupdate)\n    CallUserPlugins(EOFTPLUGIN_DYNAMICRESULTSEXPORT, progress, self, progupdate)\n    finally:\n        if oldoptions is not None:\n            self.options = oldoptions\n", "code_toks_joined": "def ExportDynamicResults ( self , options = { } , progress = None ) : <NEWLINE> <INDENT> progupdate = None <NEWLINE> if progress is not None : progupdate = progress . Update <NEWLINE> oldoptions = self . _updateOptions ( options ) <NEWLINE> try : <NEWLINE> CallInternalPlugin ( EOFTPLUGIN_DYNAMICRESULTSEXPORT , self , progupdate ) <NEWLINE> CallUserPlugins ( EOFTPLUGIN_DYNAMICRESULTSEXPORT , progress , self , progupdate ) <NEWLINE> finally : <NEWLINE> <INDENT> if oldoptions is not None : <NEWLINE> <INDENT> self . options = oldoptions <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["3cbc4be0932dbc2cdd502758c00bc185", {"code_string": "def apiRequest(call):\n    if Prefs['debug_log'] == True: Log(\"apiRequest() - talking to dropbox api: \" + call)\n        headers = {\"Authorization\": \"Bearer \" + Prefs['access_token']}\n    try:\n        req = urllib2.Request(call, None, headers)\n        response = urllib2.urlopen(req)\n        result = response.read()\n    except Exception, e:\n        if Prefs['debug_log'] == True: Log(\"ERROR! apiRequest(): \" + str(e))\n        return False\n            return result\n", "code_toks_joined": "def apiRequest ( call ) : <NEWLINE> <INDENT> if Prefs [ <STRING> ] == True : Log ( <STRING> + call ) <NEWLINE> <INDENT> headers = { <STRING> : <STRING> + Prefs [ <STRING> ] } <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> req = urllib2 . Request ( call , None , headers ) <NEWLINE> response = urllib2 . urlopen ( req ) <NEWLINE> result = response . read ( ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> if Prefs [ <STRING> ] == True : Log ( <STRING> + str ( e ) ) <NEWLINE> return False <NEWLINE> <INDENT> return result <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'debug_log'", "\"apiRequest() - talking to dropbox api: \"", "\"Authorization\"", "\"Bearer \"", "'access_token'", "'debug_log'", "\"ERROR! apiRequest(): \""]}, "err_obj": {"msg": "unexpected indent"}}], ["7c5174c194c4063464637e414554c3c8", {"code_string": "def _build_mails_response(self, (mails, total)):\n    return{\n        \"stats\": {\n            \"total\": total,\n        },\n        \"mails\": [mail.as_dict() for mail in mails]\n    }\n", "code_toks_joined": "def _build_mails_response ( self , ( mails , total ) ) : <NEWLINE> <INDENT> return { <NEWLINE> <INDENT> <STRING> : { <NEWLINE> <INDENT> <STRING> : total , <NEWLINE> <DEDENT> } , <NEWLINE> <STRING> : [ mail . as_dict ( ) for mail in mails ] <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"stats\"", "\"total\"", "\"mails\""]}, "err_obj": {"msg": "invalid syntax"}}], ["91431b05d556e01df401dc8005643387", {"code_string": "def histogram(self, mask = None):\n    \"Take histogram of image\"\n    self.load()\n    if mask:\n    mask.load()\n    return self.im.histogram(mask.im)\n    return self.im.histogram()\n", "code_toks_joined": "def histogram ( self , mask = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . load ( ) <NEWLINE> if mask : <NEWLINE> mask . load ( ) <NEWLINE> return self . im . histogram ( mask . im ) <NEWLINE> return self . im . histogram ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Take histogram of image\""]}, "err_obj": {"msg": "expected an indented block"}}], ["7f5175d1bfbaac4a712df52ba5a00561", {"code_string": "def _new_packet_cb(self, pk):\n    \"\"\"Callback for newly arrived packets\"\"\"\n    if pk.channel == READ_CHANNEL or pk.channel == WRITE_CHANNEL:\n        var_id = pk.data[0]\n        if(pk.channel != TOC_CHANNEL and self._req_param == var_id and\n            pk is not None):\n            self.updated_callback(pk)\n            self._req_param = - 1\n            try:\n            self.wait_lock.release()\n            except:\n            pass\n", "code_toks_joined": "def _new_packet_cb ( self , pk ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if pk . channel == READ_CHANNEL or pk . channel == WRITE_CHANNEL : <NEWLINE> <INDENT> var_id = pk . data [ 0 ] <NEWLINE> if ( pk . channel != TOC_CHANNEL and self . _req_param == var_id and <NEWLINE> <INDENT> pk is not None ) : <NEWLINE> self . updated_callback ( pk ) <NEWLINE> self . _req_param = - 1 <NEWLINE> try : <NEWLINE> self . wait_lock . release ( ) <NEWLINE> except : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Callback for newly arrived packets\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["b7c34cdf01a45fe998126ea004bcf538", {"code_string": "def packetReceived(self, command, payload2):\n    try:\n        if command != 'version' and not self.connected2:\n            raise PeerMisbehavingError('first message was not version message')\n        p2protocol.Protocol.packetReceived(self, command, payload2)\n    except PeerMisbehavingError, e:\n        print('Peer %s:%i misbehaving, will drop and ban. Reason:' % self.addr, e.message)\n        self.badPeerHappened()\n", "code_toks_joined": "def packetReceived ( self , command , payload2 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if command != <STRING> and not self . connected2 : <NEWLINE> <INDENT> raise PeerMisbehavingError ( <STRING> ) <NEWLINE> <DEDENT> p2protocol . Protocol . packetReceived ( self , command , payload2 ) <NEWLINE> <DEDENT> except PeerMisbehavingError , e : <NEWLINE> <INDENT> print ( <STRING> % self . addr , e . message ) <NEWLINE> self . badPeerHappened ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'version'", "'first message was not version message'", "'Peer %s:%i misbehaving, will drop and ban. Reason:'"]}, "err_obj": {"msg": "invalid syntax"}}], ["3904b48ec7b172af731c59b34a2fc384", {"code_string": "def _resolveReferences(self, flatdb):\n    for element in flatdb.keys():\n        for attribute in flatdb[element].keys():\n        val = flatdb[element][attribute]\n        if isinstance(val, basestring):\n            if flatdb.has_key(val):\n        flatdb[element][attribute] = flatdb[val]\n    return flatdb\n", "code_toks_joined": "def _resolveReferences ( self , flatdb ) : <NEWLINE> <INDENT> for element in flatdb . keys ( ) : <NEWLINE> <INDENT> for attribute in flatdb [ element ] . keys ( ) : <NEWLINE> val = flatdb [ element ] [ attribute ] <NEWLINE> if isinstance ( val , basestring ) : <NEWLINE> <INDENT> if flatdb . has_key ( val ) : <NEWLINE> <DEDENT> flatdb [ element ] [ attribute ] = flatdb [ val ] <NEWLINE> <DEDENT> return flatdb <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["c73e2bb8ecbacf4d02e75ac15e91597f", {"code_string": "def _do_find(self):\n    self._cached_attributes = dict()\n    for fn in[self._probe_jetdirect,\n        self._probe_ipp,\n        self._probe_snmp,\n        self._probe_lpd,\n        self._probe_hplip,\n        self._probe_smb]:\n        if self.quit:\n        return\n        try:\n        fn()\n        except Exception:\n        nonfatalException()\n    if not self.quit:\n        self.callback_fn(None)\n", "code_toks_joined": "def _do_find ( self ) : <NEWLINE> <INDENT> self . _cached_attributes = dict ( ) <NEWLINE> for fn in [ self . _probe_jetdirect , <NEWLINE> <INDENT> self . _probe_ipp , <NEWLINE> self . _probe_snmp , <NEWLINE> self . _probe_lpd , <NEWLINE> self . _probe_hplip , <NEWLINE> self . _probe_smb ] : <NEWLINE> if self . quit : <NEWLINE> return <NEWLINE> try : <NEWLINE> fn ( ) <NEWLINE> except Exception : <NEWLINE> nonfatalException ( ) <NEWLINE> <DEDENT> if not self . quit : <NEWLINE> <INDENT> self . callback_fn ( None ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["2fcc2cc8c2d21749002f361698b613c8", {"code_string": "def on_connect(client, userdata, flags, rc):\n    print(\"Connected with result code \" + str(rc))\n        client.subscribe(\"+/status\")\n    client.subscribe(\"discovery\")\n    client.subscribe(\"+/switch/#\")\n", "code_toks_joined": "def on_connect ( client , userdata , flags , rc ) : <NEWLINE> <INDENT> print ( <STRING> + str ( rc ) ) <NEWLINE> <INDENT> client . subscribe ( <STRING> ) <NEWLINE> <DEDENT> client . subscribe ( <STRING> ) <NEWLINE> client . subscribe ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Connected with result code \"", "\"+/status\"", "\"discovery\"", "\"+/switch/#\""]}, "err_obj": {"msg": "unexpected indent"}}], ["91f2ba873346f8e4242f75f3b467ea1a", {"code_string": "def _get_down_payment(self, data, context = None):\n    cr = self.cr\n    res = 0.0\n    target_data = {'type': data.billing_type,\n        'amount': data.billing_extra_amount,\n        'months': data.billing_months,\n        'total': data.amount_total}\n    temp_bank = [\n        (['monthly by percentage', 'by percentage'], \"res = target_data['total']*target_data['amount']/100\"),\n        (['fixed amount'], \"res = target_data['amount']\"),\n        ]\n    for target_types, str_result in temp_bank:\n        if target_data['type'] in target_types:\n            exec str_result\n    return res\n", "code_toks_joined": "def _get_down_payment ( self , data , context = None ) : <NEWLINE> <INDENT> cr = self . cr <NEWLINE> res = 0.0 <NEWLINE> target_data = { <STRING> : data . billing_type , <NEWLINE> <INDENT> <STRING> : data . billing_extra_amount , <NEWLINE> <STRING> : data . billing_months , <NEWLINE> <STRING> : data . amount_total } <NEWLINE> <DEDENT> temp_bank = [ <NEWLINE> <INDENT> ( [ <STRING> , <STRING> ] , <STRING> ) , <NEWLINE> ( [ <STRING> ] , <STRING> ) , <NEWLINE> ] <NEWLINE> <DEDENT> for target_types , str_result in temp_bank : <NEWLINE> <INDENT> if target_data [ <STRING> ] in target_types : <NEWLINE> <INDENT> exec str_result <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'type'", "'amount'", "'months'", "'total'", "'monthly by percentage'", "'by percentage'", "\"res = target_data['total']*target_data['amount']/100\"", "'fixed amount'", "\"res = target_data['amount']\"", "'type'"]}, "err_obj": {"msg": "invalid syntax"}}], ["63bcc6c184ee6d8db7478a0e73dd6836", {"code_string": "class Simple_tenant_usage(extensions.ExtensionDescriptor):\n    \"\"\"Simple tenant usage extension.\"\"\"\n    name = \"SimpleTenantUsage\"\n    alias = \"os-simple-tenant-usage\"\n    namespace = (\"http: //docs.openstack.org/compute/ext/\"\n        \"os-simple-tenant-usage/api/v1.1\")\n    updated = \"2011-08-19T00: 00: 00+00: 00\"\n    def get_resources(self):\n        resources = []\n        res = extensions.ResourceExtension('os-simple-tenant-usage',\n            SimpleTenantUsageController()\n        resources.append(res)\n        return resources\n", "code_toks_joined": "class Simple_tenant_usage ( extensions . ExtensionDescriptor ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> name = <STRING> <NEWLINE> alias = <STRING> <NEWLINE> namespace = ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> updated = <STRING> <NEWLINE> def get_resources ( self ) : <NEWLINE> <INDENT> resources = [ ] <NEWLINE> res = extensions . ResourceExtension ( <STRING> , <NEWLINE> <INDENT> SimpleTenantUsageController ( ) <NEWLINE> <DEDENT> resources . append ( res ) <NEWLINE> return resources <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Simple tenant usage extension.\"\"\"", "\"SimpleTenantUsage\"", "\"os-simple-tenant-usage\"", "\"http: //docs.openstack.org/compute/ext/\"", "\"os-simple-tenant-usage/api/v1.1\"", "\"2011-08-19T00: 00: 00+00: 00\"", "'os-simple-tenant-usage'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e4788f715509ab8bbd33985f6019c570", {"code_string": "def _capture_device_settings(self, clip, track, args):\n    dev_range = self._get_device_range(args, track)\n    if dev_range:\n        for dev_index in range(dev_range[0], dev_range[1]):\n        if dev_index <(len(track.devices)):\n            current_device = track.devices[dev_index]\n            for p in current_device.parameters:\n        self._insert_envelope(clip, p)\n            if current_device.can_have_chains:\n        self._capture_nested_devices(clip, current_device)\n", "code_toks_joined": "def _capture_device_settings ( self , clip , track , args ) : <NEWLINE> <INDENT> dev_range = self . _get_device_range ( args , track ) <NEWLINE> if dev_range : <NEWLINE> <INDENT> for dev_index in range ( dev_range [ 0 ] , dev_range [ 1 ] ) : <NEWLINE> if dev_index < ( len ( track . devices ) ) : <NEWLINE> <INDENT> current_device = track . devices [ dev_index ] <NEWLINE> for p in current_device . parameters : <NEWLINE> <DEDENT> self . _insert_envelope ( clip , p ) <NEWLINE> <INDENT> if current_device . can_have_chains : <NEWLINE> <DEDENT> self . _capture_nested_devices ( clip , current_device ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["34f319bccdc05e46aea7fa670d51ec1e", {"code_string": "def __init__(self, line):\n    \"\"\"Creates a results instance given the line in the file\"\"\"\n    self.values = line.split('\\t')\n    self.chromosome = self.values[0]\n    if self.isHitSNP(self.values[1])\n        self.hit_snp = True\n        self.hit_allele = strip(self.values[2])\n    else:\n        self.hit_snp = False\n        self.hit_allele = None\n    self.position = int(self.values[3])\n", "code_toks_joined": "def __init__ ( self , line ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . values = line . split ( <STRING> ) <NEWLINE> self . chromosome = self . values [ 0 ] <NEWLINE> if self . isHitSNP ( self . values [ 1 ] ) <NEWLINE> <INDENT> self . hit_snp = True <NEWLINE> self . hit_allele = strip ( self . values [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . hit_snp = False <NEWLINE> self . hit_allele = None <NEWLINE> <DEDENT> self . position = int ( self . values [ 3 ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Creates a results instance given the line in the file\"\"\"", "'\\t'"]}, "err_obj": {"msg": "invalid syntax"}}], ["332968915e7a24b055d5becb3f9cc618", {"code_string": "def formatException(self, (E, e, tb)):\n    if conf.supybot.log.stdout.colorized():\n        return ''.join([ansi.RED,\n            Formatter.formatException(self, (E, e, tb)),\n            ansi.RESET])\n    else:\n        return Formatter.formatException(self, (E, e, tb))\n", "code_toks_joined": "def formatException ( self , ( E , e , tb ) ) : <NEWLINE> <INDENT> if conf . supybot . log . stdout . colorized ( ) : <NEWLINE> <INDENT> return <STRING> . join ( [ ansi . RED , <NEWLINE> <INDENT> Formatter . formatException ( self , ( E , e , tb ) ) , <NEWLINE> ansi . RESET ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return Formatter . formatException ( self , ( E , e , tb ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''"]}, "err_obj": {"msg": "invalid syntax"}}], ["714e03705e378a7fcc358a644add9b09", {"code_string": "def test_scan_with_existent_ns_and_set(self):\n    ns = 'test'\n    st = 'demo'\n    records = []\n    scan_obj = None\n    def callback((key, meta, bins)):\n        records.append(bins)\n    scan_obj = self.client.scan(ns, st)\n    scan_obj.foreach(callback)\n    assert len(records) != 0\n", "code_toks_joined": "def test_scan_with_existent_ns_and_set ( self ) : <NEWLINE> <INDENT> ns = <STRING> <NEWLINE> st = <STRING> <NEWLINE> records = [ ] <NEWLINE> scan_obj = None <NEWLINE> def callback ( ( key , meta , bins ) ) : <NEWLINE> <INDENT> records . append ( bins ) <NEWLINE> <DEDENT> scan_obj = self . client . scan ( ns , st ) <NEWLINE> scan_obj . foreach ( callback ) <NEWLINE> assert len ( records ) != 0 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'test'", "'demo'"]}, "err_obj": {"msg": "invalid syntax"}}], ["39336fa65f7b7f6347217018b0498cf0", {"code_string": "def whoosh_index(app, model):\n    ''' Create whoosh index for ``model``, if one does not exist.If'''\n    if not hasattr(app, 'whoosh_indexes'):\n        app.whoosh_indexes = {}\n    return app.whoosh_indexes.get(model.__name__,\n        _create_index(app, model)\n", "code_toks_joined": "def whoosh_index ( app , model ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not hasattr ( app , <STRING> ) : <NEWLINE> <INDENT> app . whoosh_indexes = { } <NEWLINE> <DEDENT> return app . whoosh_indexes . get ( model . __name__ , <NEWLINE> <INDENT> _create_index ( app , model ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''' Create whoosh index for ``model``, if one does not exist.If'''", "'whoosh_indexes'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e45d822af9fd5d5c391649d1a04c2cec", {"code_string": "def test_getParameterNames_python_function_doesnt_have_parameters(self):\n    functionName = \"aMemberFunctionWithoutParameters\"\n    fileDir = path.join(os.sep, \"MyProject1\", \"library\", \"aaeTest\", \"mvc\", \"ControllerTest.py\")\n    expected = []\n        obj = self._getInstance()\n        parameterNames = obj._getParameterNames(functionName, fileDir)\n        self.assertEqual(expected, parameterNames)\n", "code_toks_joined": "def test_getParameterNames_python_function_doesnt_have_parameters ( self ) : <NEWLINE> <INDENT> functionName = <STRING> <NEWLINE> fileDir = path . join ( os . sep , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> expected = [ ] <NEWLINE> <INDENT> obj = self . _getInstance ( ) <NEWLINE> parameterNames = obj . _getParameterNames ( functionName , fileDir ) <NEWLINE> self . assertEqual ( expected , parameterNames ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"aMemberFunctionWithoutParameters\"", "\"MyProject1\"", "\"library\"", "\"aaeTest\"", "\"mvc\"", "\"ControllerTest.py\""]}, "err_obj": {"msg": "unexpected indent"}}], ["7d3a31a4c190d834b3a58b830356fd27", {"code_string": "def get_connection(self):\n    self._config_boto_timeout(self.connection_timeout, self.num_retries)\n    if not all((self.connection_data[\"aws_access_key_id\"],\n        self.connection_data[\"aws_secret_access_key\"])):\n        if all(self.ks_cred.itervalues()):\n        ec2_cred = self._keystone_aws_get()\n        self.connection_data[\"aws_access_key_id\"] = ec2_cred.access\n        self.connection_data[\"aws_secret_access_key\"] = ec2_cred.secret\n        else:\n        raise exceptions.InvalidConfiguration(\n            \"Unable to get access and secret keys\")\n    return self.connect_method(** self.connection_data)\n", "code_toks_joined": "def get_connection ( self ) : <NEWLINE> <INDENT> self . _config_boto_timeout ( self . connection_timeout , self . num_retries ) <NEWLINE> if not all ( ( self . connection_data [ <STRING> ] , <NEWLINE> <INDENT> self . connection_data [ <STRING> ] ) ) : <NEWLINE> if all ( self . ks_cred . itervalues ( ) ) : <NEWLINE> ec2_cred = self . _keystone_aws_get ( ) <NEWLINE> self . connection_data [ <STRING> ] = ec2_cred . access <NEWLINE> self . connection_data [ <STRING> ] = ec2_cred . secret <NEWLINE> else : <NEWLINE> raise exceptions . InvalidConfiguration ( <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return self . connect_method ( ** self . connection_data ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"aws_access_key_id\"", "\"aws_secret_access_key\"", "\"aws_access_key_id\"", "\"aws_secret_access_key\"", "\"Unable to get access and secret keys\""]}, "err_obj": {"msg": "expected an indented block"}}], ["99f82cd06b30f6fd641a70559945400a", {"code_string": "def follows(curs):\n    l = set([])\n    for c in curs.execute('SELECT follower, followed FROM x_follows_y'):\n        l.add(c)\n        if len(l) < 10 or len(l) % 10000 == 0: print '\\tGrabbed: {}'.format(len(l))\n    return l\n", "code_toks_joined": "def follows ( curs ) : <NEWLINE> <INDENT> l = set ( [ ] ) <NEWLINE> for c in curs . execute ( <STRING> ) : <NEWLINE> <INDENT> l . add ( c ) <NEWLINE> if len ( l ) < 10 or len ( l ) % 10000 == 0 : print <STRING> . format ( len ( l ) ) <NEWLINE> <DEDENT> return l <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'SELECT follower, followed FROM x_follows_y'", "'\\tGrabbed: {}'"]}, "err_obj": {"msg": "invalid syntax"}}], ["07f4a48627eb6ab0ce49a20e9c517908", {"code_string": "import sys\nif len(sys.argv) < 2 or len(sys.argv[1]) < 2: print 'V'\nmy_moves, opp_moves = sys.argv[1], sys.argv[2]\nmoves = ('R', 'P', 'S', 'V', 'L')\nhistory = zip([moves.index(i) for i in my_moves],\n    [moves.index(i) for i in opp_moves])\n", "code_toks_joined": "import sys <NEWLINE> if len ( sys . argv ) < 2 or len ( sys . argv [ 1 ] ) < 2 : print <STRING> <NEWLINE> my_moves , opp_moves = sys . argv [ 1 ] , sys . argv [ 2 ] <NEWLINE> moves = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> history = zip ( [ moves . index ( i ) for i in my_moves ] , <NEWLINE> <INDENT> [ moves . index ( i ) for i in opp_moves ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'V'", "'R'", "'P'", "'S'", "'V'", "'L'"]}, "err_obj": {"msg": "invalid syntax"}}], ["dfd13c09437cd90f72573ad5eaa59f05", {"code_string": "def analyzeAPIFiles(top):\n    count = 0\n    cur = top.children\n    while cur != None:\n        if cur.type == 'text':\n        cur = cur.next\n        continue\n        if cur.name == \"file\":\n        count = count + analyzeAPIFile(cur)\n        else:\n        print(\"unexpected element %s in API doc <files>\" %(cur.name))\n        cur = cur.next\n    return count\n", "code_toks_joined": "def analyzeAPIFiles ( top ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> cur = top . children <NEWLINE> while cur != None : <NEWLINE> <INDENT> if cur . type == <STRING> : <NEWLINE> cur = cur . next <NEWLINE> continue <NEWLINE> if cur . name == <STRING> : <NEWLINE> count = count + analyzeAPIFile ( cur ) <NEWLINE> else : <NEWLINE> print ( <STRING> % ( cur . name ) ) <NEWLINE> cur = cur . next <NEWLINE> <DEDENT> return count <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'text'", "\"file\"", "\"unexpected element %s in API doc <files>\""]}, "err_obj": {"msg": "expected an indented block"}}], ["d10608c1ec7623ab09974edeb250cf81", {"code_string": "def has_excessive_failures(self):\n    if(self.failures.first_failure_time is not None and\n        self.disable_hard_timeout):\n        if(time.time() >= self.failures.first_failure_time +\n            self.disable_hard_timeout):\n        return True\n    if self.failures.num_failures() >= self.disable_failures:\n        return True\n    return False\n", "code_toks_joined": "def has_excessive_failures ( self ) : <NEWLINE> <INDENT> if ( self . failures . first_failure_time is not None and <NEWLINE> <INDENT> self . disable_hard_timeout ) : <NEWLINE> if ( time . time ( ) >= self . failures . first_failure_time + <NEWLINE> <INDENT> self . disable_hard_timeout ) : <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT> if self . failures . num_failures ( ) >= self . disable_failures : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["e2ea1cebecf29f6b4bc9d3d5b5bf4992", {"code_string": "def make_client(port, host):\n    uri = ''\n    framed = False\n    http = False\n    if http:\n        transport = THttpClient.THttpClient(host, port, uri)\n    else:\n        socket = TSocket.TSocket(host, port)\n        if framed:\n        transport = TTransport.TFramedTransport(socket)\n        else:\n        transport = TTransport.TBufferedTransport(socket)\n    protocol = TBinaryProtocol.TBinaryProtocol(transport)\n    client = LarkService.Client(protocol)\n    transport.open()\n    return client\n", "code_toks_joined": "def make_client ( port , host ) : <NEWLINE> <INDENT> uri = <STRING> <NEWLINE> framed = False <NEWLINE> http = False <NEWLINE> if http : <NEWLINE> <INDENT> transport = THttpClient . THttpClient ( host , port , uri ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> socket = TSocket . TSocket ( host , port ) <NEWLINE> if framed : <NEWLINE> transport = TTransport . TFramedTransport ( socket ) <NEWLINE> else : <NEWLINE> transport = TTransport . TBufferedTransport ( socket ) <NEWLINE> <DEDENT> protocol = TBinaryProtocol . TBinaryProtocol ( transport ) <NEWLINE> client = LarkService . Client ( protocol ) <NEWLINE> transport . open ( ) <NEWLINE> return client <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''"]}, "err_obj": {"msg": "expected an indented block"}}], ["71b02b0f87624a13eff2a9d3c493d6d4", {"code_string": "def nice_output(digits, volts):\n    sys.stdout.write(\n        \"\\0337\"\n", "code_toks_joined": "def nice_output ( digits , volts ) : <NEWLINE> <INDENT> sys . stdout . write ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\\0337\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e2005f5ecf8ffd310d68edfa1d24b1ab", {"code_string": "def __add__(self, (ox, oy, oz)):\n    sx, sy, sz = self\n    return self.__class__(sx + ox, sy + oy, sz + oz)\n", "code_toks_joined": "def __add__ ( self , ( ox , oy , oz ) ) : <NEWLINE> <INDENT> sx , sy , sz = self <NEWLINE> return self . __class__ ( sx + ox , sy + oy , sz + oz ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["721db38380445ac405c940052ee449ee", {"code_string": "def _call(self, method, params):\n    while True:\n        try:\n        return self.conns[self.curr_conn]._call(method, params)\n        except:\n        self.next_connection()\n", "code_toks_joined": "def _call ( self , method , params ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> return self . conns [ self . curr_conn ] . _call ( method , params ) <NEWLINE> except : <NEWLINE> self . next_connection ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["d6f7eff56f99f6ce0c53a81d5e95e541", {"code_string": "def install(self, seedKey, seedEntry):\n    sanitizedKey = seedKey.hash\n    logging.debug('Installing seed for key %(key)s - sanitized %(sanitized)s'\n        dict(key = seedKey, sanitized = sanitizedKey))\n    self._storeCode(sanitizedKey, seedEntry['code'])\n    self._storeManifest(sanitizedKey, {'deps': seedEntry['deps'], 'key': seedKey.__repr__()})\n", "code_toks_joined": "def install ( self , seedKey , seedEntry ) : <NEWLINE> <INDENT> sanitizedKey = seedKey . hash <NEWLINE> logging . debug ( <STRING> <NEWLINE> <INDENT> dict ( key = seedKey , sanitized = sanitizedKey ) ) <NEWLINE> <DEDENT> self . _storeCode ( sanitizedKey , seedEntry [ <STRING> ] ) <NEWLINE> self . _storeManifest ( sanitizedKey , { <STRING> : seedEntry [ <STRING> ] , <STRING> : seedKey . __repr__ ( ) } ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Installing seed for key %(key)s - sanitized %(sanitized)s'", "'code'", "'deps'", "'deps'", "'key'"]}, "err_obj": {"msg": "invalid syntax"}}], ["00895cbd41d7922479cfed58f990c1ea", {"code_string": "def get(self, request, pk):\n    try:\n        odlc = find_odlc(request, int(pk)\n    except Odlc.DoesNotExist:\n        return HttpResponseNotFound('Odlc %s not found' % pk)\n    except ValueError as e:\n        return HttpResponseForbidden(str(e))\n    if not odlc.thumbnail.name:\n        return HttpResponseNotFound('Odlc %s has no image' % pk)\n    return sendfile(request, odlc.thumbnail.path)\n", "code_toks_joined": "def get ( self , request , pk ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> odlc = find_odlc ( request , int ( pk ) <NEWLINE> <DEDENT> except Odlc . DoesNotExist : <NEWLINE> <INDENT> return HttpResponseNotFound ( <STRING> % pk ) <NEWLINE> <DEDENT> except ValueError as e : <NEWLINE> <INDENT> return HttpResponseForbidden ( str ( e ) ) <NEWLINE> <DEDENT> if not odlc . thumbnail . name : <NEWLINE> <INDENT> return HttpResponseNotFound ( <STRING> % pk ) <NEWLINE> <DEDENT> return sendfile ( request , odlc . thumbnail . path ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Odlc %s not found'", "'Odlc %s has no image'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["36429473455c9a4c5cdb69764d64a37c", {"code_string": "def refreshSecondWidgets(self):\n    self.wprocessus.LoadInfoProcess()\n        self.wmodules.LoadInfoModules()\n", "code_toks_joined": "def refreshSecondWidgets ( self ) : <NEWLINE> <INDENT> self . wprocessus . LoadInfoProcess ( ) <NEWLINE> <INDENT> self . wmodules . LoadInfoModules ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["ca35d4d31ba659853b094ed988f3dba3", {"code_string": "def test_end(passed):\n    if passed:\n    sys.stdout.write(\"\\033[1;32m Passed\\033[00m\\n\")\n    else:\n    sys.stdout.write(\"\\033[1;31m Failed\\033[00m\\n\")\n", "code_toks_joined": "def test_end ( passed ) : <NEWLINE> <INDENT> if passed : <NEWLINE> sys . stdout . write ( <STRING> ) <NEWLINE> else : <NEWLINE> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\\033[1;32m Passed\\033[00m\\n\"", "\"\\033[1;31m Failed\\033[00m\\n\""]}, "err_obj": {"msg": "expected an indented block"}}], ["991e75ce052d025be7e564034743c5a6", {"code_string": "def delImage(self, label):\n    for config in self.images:\n    if string.lower(config.getEntry('label')) == string.lower(label):\n        self.images.remove(config)\n        return\n        raise IndexError, \"unknown image %s\" %(label, )\n", "code_toks_joined": "def delImage ( self , label ) : <NEWLINE> <INDENT> for config in self . images : <NEWLINE> if string . lower ( config . getEntry ( <STRING> ) ) == string . lower ( label ) : <NEWLINE> <INDENT> self . images . remove ( config ) <NEWLINE> return <NEWLINE> raise IndexError , <STRING> % ( label , ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'label'", "\"unknown image %s\""]}, "err_obj": {"msg": "expected an indented block"}}], ["2c135caddab3fddcfc28f6d97866bcd1", {"code_string": "def put(self, metric_id):\n    obj = {'_id': metric_id, 'updated': datetime.utcnow()}\n    for arg in['caption', 'compare', 'current',\n        'current_caption', 'compare_caption',\n        'priority']:\n        value = request.form.get(arg, None)\n        if value:\n        obj[arg] = value\n    self.mongo.db.metric.save(obj)\n    return obj, 201\n", "code_toks_joined": "def put ( self , metric_id ) : <NEWLINE> <INDENT> obj = { <STRING> : metric_id , <STRING> : datetime . utcnow ( ) } <NEWLINE> for arg in [ <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> <STRING> ] : <NEWLINE> value = request . form . get ( arg , None ) <NEWLINE> if value : <NEWLINE> obj [ arg ] = value <NEWLINE> <DEDENT> self . mongo . db . metric . save ( obj ) <NEWLINE> return obj , 201 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'_id'", "'updated'", "'caption'", "'compare'", "'current'", "'current_caption'", "'compare_caption'", "'priority'"]}, "err_obj": {"msg": "expected an indented block"}}], ["83a4bef168c0d608a77278e0ff08acc4", {"code_string": "def _parse_headers(file):\n    \"\"\"Parses the headers of the bootchart.\"\"\"\n        def parse((headers, last), line):\n            if '=' in line: last, value = map(string.strip, line.split('=', 1))\n            else: value = line.strip()\n            headers[last] += value\n            return headers, last\n        return reduce(parse, file.read().split('\\n'), (defaultdict(str), ''))[0]\n", "code_toks_joined": "def _parse_headers ( file ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> def parse ( ( headers , last ) , line ) : <NEWLINE> <INDENT> if <STRING> in line : last , value = map ( string . strip , line . split ( <STRING> , 1 ) ) <NEWLINE> else : value = line . strip ( ) <NEWLINE> headers [ last ] += value <NEWLINE> return headers , last <NEWLINE> <DEDENT> return reduce ( parse , file . read ( ) . split ( <STRING> ) , ( defaultdict ( str ) , <STRING> ) ) [ 0 ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Parses the headers of the bootchart.\"\"\"", "'='", "'='", "'\\n'", "''"]}, "err_obj": {"msg": "unexpected indent"}}], ["2f19173d25b26a5c2adb22e3d72c614b", {"code_string": "def force(self, x):\n    \"\"\"Worm Like Chain basic equation.\"\"\"\n    p = self.p\n    Lc = self.lc\n    T = self.t\n    k = 0.138\n    Ec = (k * T) /(4.0 * p)\n    return Ec *(((1. -(x / Lc)) ** - 2) - 1 +(4 * x / Lc)\n", "code_toks_joined": "def force ( self , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> p = self . p <NEWLINE> Lc = self . lc <NEWLINE> T = self . t <NEWLINE> k = 0.138 <NEWLINE> Ec = ( k * T ) / ( 4.0 * p ) <NEWLINE> return Ec * ( ( ( 1. - ( x / Lc ) ) ** - 2 ) - 1 + ( 4 * x / Lc ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Worm Like Chain basic equation.\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["bcaff988c1ba78aaa94d3a77b81f8aca", {"code_string": "def isConnected(self):\n    \"\"\" Returns True if this object has a TWS connection.\"\"\"\n    return bool(self.connection and self.connection.isConnected()\n", "code_toks_joined": "def isConnected ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return bool ( self . connection and self . connection . isConnected ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Returns True if this object has a TWS connection.\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["6f2d473d4c20c30de498a550cc45079d", {"code_string": "def _run_info_handler(self, args, screen_info = None):\n    output = debugger_cli_common.RichTextLines([])\n    if self._run_call_count == 1:\n        output.extend(cli_shared.get_tfdbg_logo())\n    output.extend(self._run_info)\n    if(not self._is_run_start and\n        debugger_cli_common.MAIN_MENU_KEY in output.annotations):\n        menu = output.annotations[debugger_cli_common.MAIN_MENU_KEY]\n        if \"list_tensors\" not in menu.captions():\n        menu.insert(\n            0, debugger_cli_common.MenuItem(\"list_tensors\", \"list_tensors\"))\n    return output\n", "code_toks_joined": "def _run_info_handler ( self , args , screen_info = None ) : <NEWLINE> <INDENT> output = debugger_cli_common . RichTextLines ( [ ] ) <NEWLINE> if self . _run_call_count == 1 : <NEWLINE> <INDENT> output . extend ( cli_shared . get_tfdbg_logo ( ) ) <NEWLINE> <DEDENT> output . extend ( self . _run_info ) <NEWLINE> if ( not self . _is_run_start and <NEWLINE> <INDENT> debugger_cli_common . MAIN_MENU_KEY in output . annotations ) : <NEWLINE> menu = output . annotations [ debugger_cli_common . MAIN_MENU_KEY ] <NEWLINE> if <STRING> not in menu . captions ( ) : <NEWLINE> menu . insert ( <NEWLINE> <INDENT> 0 , debugger_cli_common . MenuItem ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> return output <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"list_tensors\"", "\"list_tensors\"", "\"list_tensors\""]}, "err_obj": {"msg": "expected an indented block"}}], ["8495453c2f3dec0026f99c45b28b8e3d", {"code_string": "import collections\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom scipy import stats\ndata = pd.read_csv('https://spark-public.s3.amazonaws.com/dataanalysis/loansData.csv')\ndata.dropna(inplace = True)\nopen_credit_freq = collections.Counter(data['Open.CREDIT.Lines']\nplt.figure()\nplt.bar(open_credit_freq.keys(), open_credit_freq.values(), width = 1)\nplt.show()\nchi_redux = {}\nfor k in open_credit_freq:\n    if open_credit_freq[k] >= 5:\n        chi_redux[k] = open_credit_freq[k]\nchi, p = stats.chisquare(chi_redux.values())\nprint(chi)\nprint(p)\n", "code_toks_joined": "import collections <NEWLINE> import pandas as pd <NEWLINE> import matplotlib . pyplot as plt <NEWLINE> from scipy import stats <NEWLINE> data = pd . read_csv ( <STRING> ) <NEWLINE> data . dropna ( inplace = True ) <NEWLINE> open_credit_freq = collections . Counter ( data [ <STRING> ] <NEWLINE> plt . figure ( ) <NEWLINE> plt . bar ( open_credit_freq . keys ( ) , open_credit_freq . values ( ) , width = 1 ) <NEWLINE> plt . show ( ) <NEWLINE> chi_redux = { } <NEWLINE> for k in open_credit_freq : <NEWLINE> <INDENT> if open_credit_freq [ k ] >= 5 : <NEWLINE> <INDENT> chi_redux [ k ] = open_credit_freq [ k ] <NEWLINE> <DEDENT> <DEDENT> chi , p = stats . chisquare ( chi_redux . values ( ) ) <NEWLINE> print ( chi ) <NEWLINE> print ( p ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["'https://spark-public.s3.amazonaws.com/dataanalysis/loansData.csv'", "'Open.CREDIT.Lines'"]}, "window_span": [43, 141], "err_obj": {"msg": "unbalanced (){}[]"}}], ["c118b9708412f6e207f513c05264dbdd", {"code_string": "def rename_unicode_files(path):\n    files = []\n    for name in os.listdir(path):\n        if os.path.isfile(os.path.join(path, name)):\n            files.append(name)\n            for f in files:\n    try:\n        os.rename(path + f, path + urllib.unquote_plus(f).decode('utf-8'))\n    except:\n        xbmc.log(\"Error rename file: \" + f)\n    return\n", "code_toks_joined": "def rename_unicode_files ( path ) : <NEWLINE> <INDENT> files = [ ] <NEWLINE> for name in os . listdir ( path ) : <NEWLINE> <INDENT> if os . path . isfile ( os . path . join ( path , name ) ) : <NEWLINE> <INDENT> files . append ( name ) <NEWLINE> for f in files : <NEWLINE> <DEDENT> <DEDENT> try : <NEWLINE> <INDENT> os . rename ( path + f , path + urllib . unquote_plus ( f ) . decode ( <STRING> ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> xbmc . log ( <STRING> + f ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'utf-8'", "\"Error rename file: \""]}, "err_obj": {"msg": "expected an indented block"}}], ["4e1f7e6a34fc7d8a605b83ce2da7f4f3", {"code_string": "def main():\n    sys.argv = bjam.variable(\"ARGV\")\n    if \"--profiling\" in sys.argv:\n        import cProfile\n        r = cProfile.runctx('main_real()', globals(), locals(), \"stones.prof\")\n        import pstats\n        stats = pstats.Stats(\"stones.prof\")\n        stats.strip_dirs()\n        stats.sort_stats('time', 'calls')\n        stats.print_callers(20)\n        return r\n    else:\n        try:\n            return main_real()\n        except ExceptionWithUserContext, e:\n            e.report()\n", "code_toks_joined": "def main ( ) : <NEWLINE> <INDENT> sys . argv = bjam . variable ( <STRING> ) <NEWLINE> if <STRING> in sys . argv : <NEWLINE> <INDENT> import cProfile <NEWLINE> r = cProfile . runctx ( <STRING> , globals ( ) , locals ( ) , <STRING> ) <NEWLINE> import pstats <NEWLINE> stats = pstats . Stats ( <STRING> ) <NEWLINE> stats . strip_dirs ( ) <NEWLINE> stats . sort_stats ( <STRING> , <STRING> ) <NEWLINE> stats . print_callers ( 20 ) <NEWLINE> return r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return main_real ( ) <NEWLINE> <DEDENT> except ExceptionWithUserContext , e : <NEWLINE> <INDENT> e . report ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"ARGV\"", "\"--profiling\"", "'main_real()'", "\"stones.prof\"", "\"stones.prof\"", "'time'", "'calls'"]}, "err_obj": {"msg": "invalid syntax"}}], ["8bf873d9ed6f2f7a32249f59164d6cff", {"code_string": "def test_snippets(self):\n    for input, output, kind in((exec_tests, exec_results, \"exec\"),\n        (single_tests, single_results, \"single\"),\n        (eval_tests, eval_results, \"eval\")):\n        for i, o in zip(input, output):\n        ast_tree = compile(i, \"?\", kind, ast.PyCF_ONLY_AST)\n        self.assertEqual(to_tuple(ast_tree), o)\n        self._assertTrueorder(ast_tree, (0, 0))\n", "code_toks_joined": "def test_snippets ( self ) : <NEWLINE> <INDENT> for input , output , kind in ( ( exec_tests , exec_results , <STRING> ) , <NEWLINE> <INDENT> ( single_tests , single_results , <STRING> ) , <NEWLINE> ( eval_tests , eval_results , <STRING> ) ) : <NEWLINE> for i , o in zip ( input , output ) : <NEWLINE> ast_tree = compile ( i , <STRING> , kind , ast . PyCF_ONLY_AST ) <NEWLINE> self . assertEqual ( to_tuple ( ast_tree ) , o ) <NEWLINE> self . _assertTrueorder ( ast_tree , ( 0 , 0 ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"exec\"", "\"single\"", "\"eval\"", "\"?\""]}, "err_obj": {"msg": "expected an indented block"}}], ["79cd68f851b4574ea05662821eebe5ab", {"code_string": "class SubformField(Field):\n    \"\"\"This is a pseudo-form field: use to override the form class of a subform or\"\"\"\n    def __init__(self, formclass = None, label = None, can_delete = True, can_order = False,\n        * args, ** kwargs):\n        if formclass is not None:\n        self.formclass = formclass\n        if label is not None:\n        self.form_label = label\n        self.can_delete = can_delete\n        self.can_order = can_order\n        super(SubformField, self).__init__(* args, ** kwargs)\n", "code_toks_joined": "class SubformField ( Field ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , formclass = None , label = None , can_delete = True , can_order = False , <NEWLINE> <INDENT> * args , ** kwargs ) : <NEWLINE> if formclass is not None : <NEWLINE> self . formclass = formclass <NEWLINE> if label is not None : <NEWLINE> self . form_label = label <NEWLINE> self . can_delete = can_delete <NEWLINE> self . can_order = can_order <NEWLINE> super ( SubformField , self ) . __init__ ( * args , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"This is a pseudo-form field: use to override the form class of a subform or\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["ae7f05afbb2c0d4c0366ecf35675faed", {"code_string": "def testShouldNotDeleteCookiesWithASimilarName(cookie, driver, webserver)\n    cookie2 = cookie.copy()\n    cookie2['name'] = '{}x'.format(cookie['name'])\n    driver.add_cookie(cookie)\n    driver.add_cookie(cookie2)\n    driver.delete_cookie(cookie['name'])\n    cookies = driver.get_cookies()\n    assert cookie['name'] != cookies[0]['name']\n    assert cookie2['name'] == cookies[0]['name']\n", "code_toks_joined": "def testShouldNotDeleteCookiesWithASimilarName ( cookie , driver , webserver ) <NEWLINE> <INDENT> cookie2 = cookie . copy ( ) <NEWLINE> cookie2 [ <STRING> ] = <STRING> . format ( cookie [ <STRING> ] ) <NEWLINE> driver . add_cookie ( cookie ) <NEWLINE> driver . add_cookie ( cookie2 ) <NEWLINE> driver . delete_cookie ( cookie [ <STRING> ] ) <NEWLINE> cookies = driver . get_cookies ( ) <NEWLINE> assert cookie [ <STRING> ] != cookies [ 0 ] [ <STRING> ] <NEWLINE> assert cookie2 [ <STRING> ] == cookies [ 0 ] [ <STRING> ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'name'", "'{}x'", "'name'", "'name'", "'name'", "'name'", "'name'", "'name'"]}, "err_obj": {"msg": "invalid syntax"}}], ["e013490e424b0f0839931a9557992abd", {"code_string": "'''Created on 18 f\u00e9vr.2010'''\nimport sys\nimport os\nimport re\nfrom os import makedirs, path\nfrom types import StringTypes\nfrom whoosh.index import create_in\nfrom whoosh.fields import *\nfrom whoosh import index\nfrom whoosh.index import open_dir\nfrom harvestman.apps.spider import HarvestMan\nfrom harvestman.lib.common.common import objects\nfrom sgmllib import SGMLParser\nspanreg = re.compile('\"class=\\\"aya\\\"\"\"')\ndef info(S): print \"info>\", S\ndef extrainfo(S, T):\n    print \"extrainfo>\", S, \">>\", T\n", "code_toks_joined": "<STRING> <NEWLINE> import sys <NEWLINE> import os <NEWLINE> import re <NEWLINE> from os import makedirs , path <NEWLINE> from types import StringTypes <NEWLINE> from whoosh . index import create_in <NEWLINE> from whoosh . fields import * <NEWLINE> from whoosh import index <NEWLINE> from whoosh . index import open_dir <NEWLINE> from harvestman . apps . spider import HarvestMan <NEWLINE> from harvestman . lib . common . common import objects <NEWLINE> from sgmllib import SGMLParser <NEWLINE> spanreg = re . compile ( <STRING> ) <NEWLINE> def info ( S ) : print <STRING> , S <NEWLINE> def extrainfo ( S , T ) : <NEWLINE> <INDENT> print <STRING> , S , <STRING> , T <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Created on 18 f\u00e9vr.2010'''", "'\"class=\\\"aya\\\"\"\"'", "\"info>\"", "\"extrainfo>\"", "\">>\""]}, "err_obj": {"msg": "invalid syntax"}}], ["770283d13b37a68a90b8731fe8967ff8", {"code_string": "def _rescale_data(X, y, sample_weight):\n    \"\"\"Rescale data so as to support sample_weight\"\"\"\n    n_samples = X.shape[0]\n    sample_weight = sample_weight * np.ones(n_samples)\n    sample_weight = np.sqrt(sample_weight)\n    sw_matrix = sparse.dia_matrix((sample_weight, 0)\n        shape = (n_samples, n_samples))\n    X = safe_sparse_dot(sw_matrix, X)\n    y = safe_sparse_dot(sw_matrix, y)\n    return X, y\n", "code_toks_joined": "def _rescale_data ( X , y , sample_weight ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> n_samples = X . shape [ 0 ] <NEWLINE> sample_weight = sample_weight * np . ones ( n_samples ) <NEWLINE> sample_weight = np . sqrt ( sample_weight ) <NEWLINE> sw_matrix = sparse . dia_matrix ( ( sample_weight , 0 ) <NEWLINE> <INDENT> shape = ( n_samples , n_samples ) ) <NEWLINE> <DEDENT> X = safe_sparse_dot ( sw_matrix , X ) <NEWLINE> y = safe_sparse_dot ( sw_matrix , y ) <NEWLINE> return X , y <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Rescale data so as to support sample_weight\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["f33f06670ef2f09b736b904f7c007e0b", {"code_string": "def __init__(self, default_path, user_path):\n    self._default_settings = ConfigObj(default_path, unrepr = True)\n    self._user_path = user_path\n    try:\n        self._old_settings = ConfigObj(user_path, unrepr = True)\n    except UnreprError, err:\n        raise ConfigurationError(\"Invalid config file '%s': %s\" %\n            (user_path, err))\n", "code_toks_joined": "def __init__ ( self , default_path , user_path ) : <NEWLINE> <INDENT> self . _default_settings = ConfigObj ( default_path , unrepr = True ) <NEWLINE> self . _user_path = user_path <NEWLINE> try : <NEWLINE> <INDENT> self . _old_settings = ConfigObj ( user_path , unrepr = True ) <NEWLINE> <DEDENT> except UnreprError , err : <NEWLINE> <INDENT> raise ConfigurationError ( <STRING> % <NEWLINE> <INDENT> ( user_path , err ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Invalid config file '%s': %s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["7e8995170e0f0f1d58fc724ab2af0a56", {"code_string": "class Functor:\n    def __init__(self, fo, fa, src = None, tgt = None):\n    self.fo = adapt_function(fo)\n    self.fa = adapt_function(fa)\n    self.src = src\n    self.tgt = tgt\n", "code_toks_joined": "class Functor : <NEWLINE> <INDENT> def __init__ ( self , fo , fa , src = None , tgt = None ) : <NEWLINE> self . fo = adapt_function ( fo ) <NEWLINE> self . fa = adapt_function ( fa ) <NEWLINE> self . src = src <NEWLINE> self . tgt = tgt <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["a16120e23d1d3d3c2efba63324662697", {"code_string": "def get_chain_selector(self, device):\n    \"\"\" Get rack chain selector param \"\"\"\n    result = None\n    if device.class_name.endswith('GroupDevice'):\n        for parameter in device.parameters:\n        if str(parameter.original_name) == 'Chain Selector':\n            result = parameter\n            break\n    return result\n", "code_toks_joined": "def get_chain_selector ( self , device ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> result = None <NEWLINE> if device . class_name . endswith ( <STRING> ) : <NEWLINE> <INDENT> for parameter in device . parameters : <NEWLINE> if str ( parameter . original_name ) == <STRING> : <NEWLINE> <INDENT> result = parameter <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Get rack chain selector param \"\"\"", "'GroupDevice'", "'Chain Selector'"]}, "err_obj": {"msg": "expected an indented block"}}], ["0518453eeaf8cff60f9befaf176ec3f5", {"code_string": "def BuildDirStructure(featRootDir, dirs):\n    curDir = os.getcwd()\n    os.chdir(featRootDir)\n    for d in dirs:\n        if not os.path.exists(d):\n        os.makedirs(d)\n        os.chdir(d)\n    os.chdir(curDir)\n", "code_toks_joined": "def BuildDirStructure ( featRootDir , dirs ) : <NEWLINE> <INDENT> curDir = os . getcwd ( ) <NEWLINE> os . chdir ( featRootDir ) <NEWLINE> for d in dirs : <NEWLINE> <INDENT> if not os . path . exists ( d ) : <NEWLINE> os . makedirs ( d ) <NEWLINE> os . chdir ( d ) <NEWLINE> <DEDENT> os . chdir ( curDir ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["3dd94f2c366b17850ddd10337831e122", {"code_string": "def getEnvelopeFromCenterXYLengthWidth(x, y, length, width):\n    halfWidth = width / 2.0\n    halfLength = length / 2.0\n    bounding = []\n    bounding.append(getStringFromXY(x - halfWidth, y + halfLength))\n    bounding.append(getStringFromXY(x - halfWidth, y - halfLength))\n    bounding.append(getStringFromXY(x + halfWidth, y - halfLength))\n    bounding.append(getStringFromXY(x + halfWidth, y + halfLength)\n    return bounding\n", "code_toks_joined": "def getEnvelopeFromCenterXYLengthWidth ( x , y , length , width ) : <NEWLINE> <INDENT> halfWidth = width / 2.0 <NEWLINE> halfLength = length / 2.0 <NEWLINE> bounding = [ ] <NEWLINE> bounding . append ( getStringFromXY ( x - halfWidth , y + halfLength ) ) <NEWLINE> bounding . append ( getStringFromXY ( x - halfWidth , y - halfLength ) ) <NEWLINE> bounding . append ( getStringFromXY ( x + halfWidth , y - halfLength ) ) <NEWLINE> bounding . append ( getStringFromXY ( x + halfWidth , y + halfLength ) <NEWLINE> return bounding <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["9366c48cf1c0468e291a41d0cb32de0c", {"code_string": "def lookup_compression(method):\n    \"\"\"Looks up the passed compression method in supported COMPRESSION_METHODS\"\"\"\n    try:\n        cmd, ext = COMPRESSION_METHODS[method]\n        argv = shlex.split(cmd)\n        try:\n            return[which.which(argv[0])] + argv[1: ], ext\n        except which.WhichError, e:\n            raise OSError(\"No command found for compression method '%s'\" %\n                method)\n    except KeyError:\n        raise OSError(\"Unsupported compression method '%s'\" % method)\n", "code_toks_joined": "def lookup_compression ( method ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> cmd , ext = COMPRESSION_METHODS [ method ] <NEWLINE> argv = shlex . split ( cmd ) <NEWLINE> try : <NEWLINE> <INDENT> return [ which . which ( argv [ 0 ] ) ] + argv [ 1 : ] , ext <NEWLINE> <DEDENT> except which . WhichError , e : <NEWLINE> <INDENT> raise OSError ( <STRING> % <NEWLINE> <INDENT> method ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except KeyError : <NEWLINE> <INDENT> raise OSError ( <STRING> % method ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Looks up the passed compression method in supported COMPRESSION_METHODS\"\"\"", "\"No command found for compression method '%s'\"", "\"Unsupported compression method '%s'\""]}, "err_obj": {"msg": "invalid syntax"}}], ["46c8ef4650655f5e066518fbe1bcbe30", {"code_string": "def execute(version, command, arguments, data = None):\n    \"\"\"with subprocess.Popen((\"playpen\",\"\"\"\n    with subprocess.Popen((command, ) + arguments,\n        stdin = subprocess.PIPE,\n        stdout = subprocess.PIPE,\n        stderr = subprocess.STDOUT) as p:\n        if data is None:\n        out = p.communicate()[0]\n        else:\n        out = p.communicate(data.encode())[0]\n        return(out, p.returncode)\n", "code_toks_joined": "def execute ( version , command , arguments , data = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with subprocess . Popen ( ( command , ) + arguments , <NEWLINE> <INDENT> stdin = subprocess . PIPE , <NEWLINE> stdout = subprocess . PIPE , <NEWLINE> stderr = subprocess . STDOUT ) as p : <NEWLINE> if data is None : <NEWLINE> out = p . communicate ( ) [ 0 ] <NEWLINE> else : <NEWLINE> out = p . communicate ( data . encode ( ) ) [ 0 ] <NEWLINE> return ( out , p . returncode ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"with subprocess.Popen((\"playpen\",\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["bcf1ff37981aae318bb419d61d0461e4", {"code_string": "def get_case_parameters(case_name, ** kwargs):\n    global remote_data, data_dir, data_host, remote_server_auto, paraview_cmd\n    _remote_dir = data_dir\n    if 'data_dir' in kwargs:\n        _remote_dir = kwargs['data_dir']\n    _remote_host = data_host\n    if 'data_host' in kwargs:\n        _remote_host = kwargs['data_host']\n    env.use_ssh_config = True\n    env.host_string = _remote_host\n    case_file_str = cat_case_file(_remote_dir, case_name)\n    exec case_file_str\n    return parameters\n", "code_toks_joined": "def get_case_parameters ( case_name , ** kwargs ) : <NEWLINE> <INDENT> global remote_data , data_dir , data_host , remote_server_auto , paraview_cmd <NEWLINE> _remote_dir = data_dir <NEWLINE> if <STRING> in kwargs : <NEWLINE> <INDENT> _remote_dir = kwargs [ <STRING> ] <NEWLINE> <DEDENT> _remote_host = data_host <NEWLINE> if <STRING> in kwargs : <NEWLINE> <INDENT> _remote_host = kwargs [ <STRING> ] <NEWLINE> <DEDENT> env . use_ssh_config = True <NEWLINE> env . host_string = _remote_host <NEWLINE> case_file_str = cat_case_file ( _remote_dir , case_name ) <NEWLINE> exec case_file_str <NEWLINE> return parameters <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'data_dir'", "'data_dir'", "'data_host'", "'data_host'"]}, "err_obj": {"msg": "invalid syntax"}}], ["4276e0f213aceef6053a3b2149656adb", {"code_string": "def test_enrollments_for_course_id(self):\n    with self.settings(\n        RESTCLIENTS_CANVAS_DAO_CLASS = 'restclients.dao_implementation.canvas.File'):\n        canvas = Enrollments()\n        enrollments = canvas.get_enrollments_for_course_by_sis_id(\"2013-autumn-PHYS-248-A\")\n        self.assertEquals(len(enrollments), 3, \"Has 3 canvas enrollments\")\n        students = canvas.get_enrollments_for_course_by_sis_id(\"2013-autumn-PHYS-248-A\",\n            {\"role\": \"student\"})\n            self.assertEquals(len(students), 2, \"Has 2 student enrollments\")\n", "code_toks_joined": "def test_enrollments_for_course_id ( self ) : <NEWLINE> <INDENT> with self . settings ( <NEWLINE> <INDENT> RESTCLIENTS_CANVAS_DAO_CLASS = <STRING> ) : <NEWLINE> canvas = Enrollments ( ) <NEWLINE> enrollments = canvas . get_enrollments_for_course_by_sis_id ( <STRING> ) <NEWLINE> self . assertEquals ( len ( enrollments ) , 3 , <STRING> ) <NEWLINE> students = canvas . get_enrollments_for_course_by_sis_id ( <STRING> , <NEWLINE> <INDENT> { <STRING> : <STRING> } ) <NEWLINE> self . assertEquals ( len ( students ) , 2 , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'restclients.dao_implementation.canvas.File'", "\"2013-autumn-PHYS-248-A\"", "\"Has 3 canvas enrollments\"", "\"2013-autumn-PHYS-248-A\"", "\"role\"", "\"student\"", "\"Has 2 student enrollments\""]}, "err_obj": {"msg": "unexpected indent"}}], ["1edca1c28672d83be10bb5968032654b", {"code_string": "def getObjectHistory(self, request):\n    if isinstance(request, getObjectHistoryRequest) is False:\n        raise TypeError, \"%s incorrect request type\" %(request.__class__)\n    kw = {}\n    self.binding.Send(None, None, request, soapaction = \"http://www.fedora.info/definitions/1/0/api/#getObjectHistory\", encodingStyle = \"http://schemas.xmlsoap.org/soap/encoding/\", ** kw)\n    typecode = Struct(pname = None, ofwhat = getObjectHistoryResponse.typecode.ofwhat, pyclass = getObjectHistoryResponse.typecode.pyclass)\n    response = self.binding.Receive(typecode)\n    return response\n", "code_toks_joined": "def getObjectHistory ( self , request ) : <NEWLINE> <INDENT> if isinstance ( request , getObjectHistoryRequest ) is False : <NEWLINE> <INDENT> raise TypeError , <STRING> % ( request . __class__ ) <NEWLINE> <DEDENT> kw = { } <NEWLINE> self . binding . Send ( None , None , request , soapaction = <STRING> , encodingStyle = <STRING> , ** kw ) <NEWLINE> typecode = Struct ( pname = None , ofwhat = getObjectHistoryResponse . typecode . ofwhat , pyclass = getObjectHistoryResponse . typecode . pyclass ) <NEWLINE> response = self . binding . Receive ( typecode ) <NEWLINE> return response <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"%s incorrect request type\"", "\"http://www.fedora.info/definitions/1/0/api/#getObjectHistory\"", "\"http://schemas.xmlsoap.org/soap/encoding/\""]}, "err_obj": {"msg": "invalid syntax"}}], ["ecd1db867b89838f7cb03728ca00d758", {"code_string": "def new_figure_manager(num, * args, ** kwargs):\n    \"\"\"Create a new figure manager instance\"\"\"\n    if _debug:\n        print '%s.%s()' %(self.__class__.__name__, _fn_name())\n    FigureClass = kwargs.pop('FigureClass', Figure)\n    thisFig = FigureClass(* args, ** kwargs)\n    canvas = FigureCanvasCairo(thisFig)\n    manager = FigureManagerBase(canvas, num)\n    return manager\n", "code_toks_joined": "def new_figure_manager ( num , * args , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if _debug : <NEWLINE> <INDENT> print <STRING> % ( self . __class__ . __name__ , _fn_name ( ) ) <NEWLINE> <DEDENT> FigureClass = kwargs . pop ( <STRING> , Figure ) <NEWLINE> thisFig = FigureClass ( * args , ** kwargs ) <NEWLINE> canvas = FigureCanvasCairo ( thisFig ) <NEWLINE> manager = FigureManagerBase ( canvas , num ) <NEWLINE> return manager <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Create a new figure manager instance\"\"\"", "'%s.%s()'", "'FigureClass'"]}, "err_obj": {"msg": "invalid syntax"}}], ["5d6707688ee8f53fb7ad9bf6f9a5704b", {"code_string": "class EngineStrategyMetaBase(ABCMeta):\n    def __init__(cls, name, bases_classes, attributes):\n        if hasattr(cls, 'configuration_schema'):\n            schema = cls.configuration_schema\n            Draft4Validator.check_schema(schema)\n            cls.__config_validator__ = build_validator(schema, get_module_path(cls)\n", "code_toks_joined": "class EngineStrategyMetaBase ( ABCMeta ) : <NEWLINE> <INDENT> def __init__ ( cls , name , bases_classes , attributes ) : <NEWLINE> <INDENT> if hasattr ( cls , <STRING> ) : <NEWLINE> <INDENT> schema = cls . configuration_schema <NEWLINE> Draft4Validator . check_schema ( schema ) <NEWLINE> cls . __config_validator__ = build_validator ( schema , get_module_path ( cls ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'configuration_schema'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["4c5f25e46e2cd79a2032ba7574b9e722", {"code_string": "def get_int_type_range(type_id):\n    \"\"\"Get valid range of an integer literal of the given type.\"\"\"\n    if type_id.inst.op_name not in['OpTypeInt', 'OpTypeFloat']:\n        raise ParseError('Type must be OpTypeInt or OpTypeFloat')\n    bitwidth = type_id.inst.operands[0]\n    assert bitwidth in[16, 32, 64]\n    min_val = -(1 <<(bitwidth - 1)\n    max_val = (1 << bitwidth) - 1\n    if type_id.inst.op_name == 'OpTypeFloat':\n        min_val = 0\n    return min_val, max_val\n", "code_toks_joined": "def get_int_type_range ( type_id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if type_id . inst . op_name not in [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> raise ParseError ( <STRING> ) <NEWLINE> <DEDENT> bitwidth = type_id . inst . operands [ 0 ] <NEWLINE> assert bitwidth in [ 16 , 32 , 64 ] <NEWLINE> min_val = - ( 1 << ( bitwidth - 1 ) <NEWLINE> max_val = ( 1 << bitwidth ) - 1 <NEWLINE> if type_id . inst . op_name == <STRING> : <NEWLINE> <INDENT> min_val = 0 <NEWLINE> <DEDENT> return min_val , max_val <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get valid range of an integer literal of the given type.\"\"\"", "'OpTypeInt'", "'OpTypeFloat'", "'Type must be OpTypeInt or OpTypeFloat'", "'OpTypeFloat'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["abbfe84917022d6046b86204323536dd", {"code_string": "class Command(BaseCommand):\n    help = 'Copy temporary design docs over existing ones'\n    def handle(self, * args, ** options):\n        for plugin in get_preindex_plugins():\n            print(\"Copying design docs for plugin{}\".format(plugin.app_label)))\n            plugin.copy_designs(temp = 'tmp')\n", "code_toks_joined": "class Command ( BaseCommand ) : <NEWLINE> <INDENT> help = <STRING> <NEWLINE> def handle ( self , * args , ** options ) : <NEWLINE> <INDENT> for plugin in get_preindex_plugins ( ) : <NEWLINE> <INDENT> print ( <STRING> . format ( plugin . app_label ) ) ) <NEWLINE> plugin . copy_designs ( temp = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Copy temporary design docs over existing ones'", "\"Copying design docs for plugin{}\"", "'tmp'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["51838b26c564287f3d9ea4189deaf2af", {"code_string": "class EtniaareasAdmin(admin.ModelAdmin):\n    def formfield_for_foreignkey(self, db_field, request, ** kwargs):\n        if db_field.name == \"userupdate\":\n            kwargs[\"queryset\"] = User.objects.filter(id = request.user.id)\n        return super(EtniaareasAdmin, self).formfield_for_foreignkey(db_field, request, ** kwargs)\n    class Media:\n    js = ('/js/tiny_mce/tiny_mce.js', '/js/textareas.js')\n", "code_toks_joined": "class EtniaareasAdmin ( admin . ModelAdmin ) : <NEWLINE> <INDENT> def formfield_for_foreignkey ( self , db_field , request , ** kwargs ) : <NEWLINE> <INDENT> if db_field . name == <STRING> : <NEWLINE> <INDENT> kwargs [ <STRING> ] = User . objects . filter ( id = request . user . id ) <NEWLINE> <DEDENT> return super ( EtniaareasAdmin , self ) . formfield_for_foreignkey ( db_field , request , ** kwargs ) <NEWLINE> <DEDENT> class Media : <NEWLINE> js = ( <STRING> , <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"userupdate\"", "\"queryset\"", "'/js/tiny_mce/tiny_mce.js'", "'/js/textareas.js'"]}, "err_obj": {"msg": "expected an indented block"}}], ["31b30735f3b72ede9d2549e195865456", {"code_string": "class ForumsPostsLikes(db.Model):\n    \"\"\"Contains the images for posts in the forums\"\"\"\n    id = db.Column(db.Integer, primary_key = True)\n    post_id = db.Column(db.Integer, db.ForeignKey('forums_posts.id')\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))\n    def __init__(self, post_id, user_id):\n        \"\"\"Creates a like that is affiliated with a post\"\"\"\n        self.post_id = post_id\n        self.user_id = user_id\n", "code_toks_joined": "class ForumsPostsLikes ( db . Model ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> id = db . Column ( db . Integer , primary_key = True ) <NEWLINE> post_id = db . Column ( db . Integer , db . ForeignKey ( <STRING> ) <NEWLINE> user_id = db . Column ( db . Integer , db . ForeignKey ( <STRING> ) ) <NEWLINE> def __init__ ( self , post_id , user_id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . post_id = post_id <NEWLINE> self . user_id = user_id <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Contains the images for posts in the forums\"\"\"", "'forums_posts.id'", "'user.id'", "\"\"\"Creates a like that is affiliated with a post\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["84fd2982bc2f7f126fd25e42ef5a069b", {"code_string": "def menu():\n    __limpiar()\n    print('''033[1)\n    print (''' 0 33[1)\n    while True:\n        d = raw_input(\"\\033[1;35mCifrado > \\033[1;m\")\n        if d == \"1\":\n            subprocess.call(['python', 'cesar/cesar.py'])\n        if d == \"2\":\n            subprocess.call(['python', 'vigenere/vigenere.py'])\n        if d == \"3\":\n            subprocess.call(['python', 'Dangerous.py'])\n", "code_toks_joined": "def menu ( ) : <NEWLINE> <INDENT> __limpiar ( ) <NEWLINE> print ( <STRING> 0 33 [ 1 ) <NEWLINE> while True : <NEWLINE> <INDENT> d = raw_input ( <STRING> ) <NEWLINE> if d == <STRING> : <NEWLINE> <INDENT> subprocess . call ( [ <STRING> , <STRING> ] ) <NEWLINE> <DEDENT> if d == <STRING> : <NEWLINE> <INDENT> subprocess . call ( [ <STRING> , <STRING> ] ) <NEWLINE> <DEDENT> if d == <STRING> : <NEWLINE> <INDENT> subprocess . call ( [ <STRING> , <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''033[1)\n    print ('''", "\"\\033[1;35mCifrado > \\033[1;m\"", "\"1\"", "'python'", "'cesar/cesar.py'", "\"2\"", "'python'", "'vigenere/vigenere.py'", "\"3\"", "'python'", "'Dangerous.py'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["16cb2075d4f4f95f9f83c64567c2ddf3", {"code_string": "def test3_right(self):\n    self.t.set_align_mode('right')\n    expected = [B(t) for t in \"        I walk the\", \" city in the night\"]\n    got = self.t.render((18, ))._text\n    assert got == expected, \"got: %r expected: %r\" %(got, expected)\n", "code_toks_joined": "def test3_right ( self ) : <NEWLINE> <INDENT> self . t . set_align_mode ( <STRING> ) <NEWLINE> expected = [ B ( t ) for t in <STRING> , <STRING> ] <NEWLINE> got = self . t . render ( ( 18 , ) ) . _text <NEWLINE> assert got == expected , <STRING> % ( got , expected ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'right'", "\"        I walk the\"", "\" city in the night\"", "\"got: %r expected: %r\""]}, "err_obj": {"msg": "invalid syntax"}}], ["139555b7bcdacedf0688ad364d8ed4d7", {"code_string": "def _collect_slave_state(self):\n    result = self._get('slave(1)/state')\n    if not result:\n        return\n    for framework in result['frameworks']:\n        self.known_frameworks[framework['id']] = framework['name']\n    for key in['failed_tasks', 'finished_tasks', 'staged_tasks',\n        'started_tasks', 'lost_tasks']:\n        value = result.get(key)\n        if value is not None:\n        self.publish(key, value, precision = self._precision(value))\n", "code_toks_joined": "def _collect_slave_state ( self ) : <NEWLINE> <INDENT> result = self . _get ( <STRING> ) <NEWLINE> if not result : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for framework in result [ <STRING> ] : <NEWLINE> <INDENT> self . known_frameworks [ framework [ <STRING> ] ] = framework [ <STRING> ] <NEWLINE> <DEDENT> for key in [ <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> ] : <NEWLINE> value = result . get ( key ) <NEWLINE> if value is not None : <NEWLINE> self . publish ( key , value , precision = self . _precision ( value ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'slave(1)/state'", "'frameworks'", "'id'", "'name'", "'failed_tasks'", "'finished_tasks'", "'staged_tasks'", "'started_tasks'", "'lost_tasks'"]}, "err_obj": {"msg": "expected an indented block"}}], ["4fedb85eb62ee2c1542d57f9c24b9297", {"code_string": "def __init__(self):\n    self._attrs = {}\n        self._parser = expat.ParserCreate()\n        self._parser.StartElementHandler = self.start\n        self._parser.EndElementHandler = self.end\n        self._parser.StartCdataSectionHandler = self.startCdata\n        self._parser.EndCdataSectionHandler = self.endCdata\n        self._parser.CharacterDataHandler = self.data\n", "code_toks_joined": "def __init__ ( self ) : <NEWLINE> <INDENT> self . _attrs = { } <NEWLINE> <INDENT> self . _parser = expat . ParserCreate ( ) <NEWLINE> self . _parser . StartElementHandler = self . start <NEWLINE> self . _parser . EndElementHandler = self . end <NEWLINE> self . _parser . StartCdataSectionHandler = self . startCdata <NEWLINE> self . _parser . EndCdataSectionHandler = self . endCdata <NEWLINE> self . _parser . CharacterDataHandler = self . data <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["0bf9d710a130bc5519b3aaac4fff853f", {"code_string": "class Solution(object):\n    def printlist(self, head):\n    while head:\n        print(head.val)\n        head = head.next\n    def isHappy(self, head):\n    if not head:\n        return head\n        start = head\n        nextnode = head.next\n        start.next = None\n        while nextnode:\n        tmp = nextnode.next\n        nextnode.next = start\n        start = nextnode\n        nextnode = tmp\n        return start\n", "code_toks_joined": "class Solution ( object ) : <NEWLINE> <INDENT> def printlist ( self , head ) : <NEWLINE> while head : <NEWLINE> <INDENT> print ( head . val ) <NEWLINE> head = head . next <NEWLINE> <DEDENT> def isHappy ( self , head ) : <NEWLINE> if not head : <NEWLINE> <INDENT> return head <NEWLINE> start = head <NEWLINE> nextnode = head . next <NEWLINE> start . next = None <NEWLINE> while nextnode : <NEWLINE> tmp = nextnode . next <NEWLINE> nextnode . next = start <NEWLINE> start = nextnode <NEWLINE> nextnode = tmp <NEWLINE> return start <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["505887ec173c5958f85031a6aa6e7a30", {"code_string": "def test_search_services_loading(self):\n    \"\"\"websearch - loading default search services\"\"\"\n    error_messages = []\n    services_classes = [str(service.__class__) for service in get_search_services()]\n    for expected_service_class in('CollectionNameSearchService.CollectionNameSearchService',\n        'FAQKBService.FAQKBService',\n        'SubmissionNameSearchService.SubmissionNameSearchService'):\n        if not expected_service_class in services_classes:\n        error_messages.append('%s not found in list of loaded services.' % expected_service_class)\n    if error_messages:\n        self.fail(merge_error_messages(error_messages) + '\\nList of loaded services: \\n%s' % repr(services_classes))\n", "code_toks_joined": "def test_search_services_loading ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> error_messages = [ ] <NEWLINE> services_classes = [ str ( service . __class__ ) for service in get_search_services ( ) ] <NEWLINE> for expected_service_class in ( <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ) : <NEWLINE> if not expected_service_class in services_classes : <NEWLINE> error_messages . append ( <STRING> % expected_service_class ) <NEWLINE> <DEDENT> if error_messages : <NEWLINE> <INDENT> self . fail ( merge_error_messages ( error_messages ) + <STRING> % repr ( services_classes ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"websearch - loading default search services\"\"\"", "'CollectionNameSearchService.CollectionNameSearchService'", "'FAQKBService.FAQKBService'", "'SubmissionNameSearchService.SubmissionNameSearchService'", "'%s not found in list of loaded services.'", "'\\nList of loaded services: \\n%s'"]}, "err_obj": {"msg": "expected an indented block"}}], ["184e616ebb9ce44bb6b7961d201ac749", {"code_string": "class NpmRequirement(PackageRequirement):\n    \"\"\"This class is a subclass of ``PackageRequirement``. It specifies the proper\"\"\"\n    def __init__(self, package, version = \"\"):\n        \"\"\"Constructs a new ``NpmRequirement``, using the ``PackageRequirement``\"\"\"\n        PackageRequirement.__init__(self, 'npm', package, version)\n    def is_installed(self):\n        \"\"\"Checks if the dependency is installed.\"\"\"\n        for cmd in(['npm', 'list', self.package],\n            ['npm', 'list', '-g', self.package]):\n            if platform.system() == 'Windows':\n            cmd = ['cmd', '/c'] + cmd\n            if not call_without_output(cmd):\n            return True\n        return False\n", "code_toks_joined": "class NpmRequirement ( PackageRequirement ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , package , version = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> PackageRequirement . __init__ ( self , <STRING> , package , version ) <NEWLINE> <DEDENT> def is_installed ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for cmd in ( [ <STRING> , <STRING> , self . package ] , <NEWLINE> <INDENT> [ <STRING> , <STRING> , <STRING> , self . package ] ) : <NEWLINE> if platform . system ( ) == <STRING> : <NEWLINE> cmd = [ <STRING> , <STRING> ] + cmd <NEWLINE> if not call_without_output ( cmd ) : <NEWLINE> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"This class is a subclass of ``PackageRequirement``. It specifies the proper\"\"\"", "\"\"", "\"\"\"Constructs a new ``NpmRequirement``, using the ``PackageRequirement``\"\"\"", "'npm'", "\"\"\"Checks if the dependency is installed.\"\"\"", "'npm'", "'list'", "'npm'", "'list'", "'-g'", "'Windows'", "'cmd'", "'/c'"]}, "err_obj": {"msg": "expected an indented block"}}], ["18bbc5d432c0873732ec5d3f35b6d7e6", {"code_string": "class GetTopSharedEvents(DailySharesBase):\n    def __init__(self,\n        date = None,\n        count = 20,\n        returnInfo = ReturnInfo()):\n        QueryParamsBase.__init__(self)\n        self._setVal(\"action\", \"getEvents\")\n        self._setVal(\"count\", count)\n        self._update(returnInfo.getParams())\n        if date == None:\n        date = datetime.date.today()\n        self._setDateVal(\"date\", date)\n", "code_toks_joined": "class GetTopSharedEvents ( DailySharesBase ) : <NEWLINE> <INDENT> def __init__ ( self , <NEWLINE> <INDENT> date = None , <NEWLINE> count = 20 , <NEWLINE> returnInfo = ReturnInfo ( ) ) : <NEWLINE> QueryParamsBase . __init__ ( self ) <NEWLINE> self . _setVal ( <STRING> , <STRING> ) <NEWLINE> self . _setVal ( <STRING> , count ) <NEWLINE> self . _update ( returnInfo . getParams ( ) ) <NEWLINE> if date == None : <NEWLINE> date = datetime . date . today ( ) <NEWLINE> self . _setDateVal ( <STRING> , date ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"action\"", "\"getEvents\"", "\"count\"", "\"date\""]}, "err_obj": {"msg": "expected an indented block"}}], ["f2b560d10f6ffea885d011f7f0b60e5f", {"code_string": "def tg_command_whoami(bot, chat_id, args):\n    user_id = args['user_id']\n    chat_type = args['chat_type']\n    if 'private' == chat_type:\n        yield from bot.sendMessage(chat_id, \"Your Telegram user id: {user_id}\".format(user_id = user_id)))\n    else:\n        yield from bot.sendMessage(chat_id, \"This command can only be used in private chats\")\n", "code_toks_joined": "def tg_command_whoami ( bot , chat_id , args ) : <NEWLINE> <INDENT> user_id = args [ <STRING> ] <NEWLINE> chat_type = args [ <STRING> ] <NEWLINE> if <STRING> == chat_type : <NEWLINE> <INDENT> yield from bot . sendMessage ( chat_id , <STRING> . format ( user_id = user_id ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> yield from bot . sendMessage ( chat_id , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'user_id'", "'chat_type'", "'private'", "\"Your Telegram user id: {user_id}\"", "\"This command can only be used in private chats\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["074c7d96619bb4e7507fefe5d2c16121", {"code_string": "class DatasourceManager(models.Manager):\n    def cached(self):\n        \"\"\"Return all datasources, caching the results.\"\"\"\n        sources = cache.get(SOURCES_CACHE_KEY)\n        if not sources:\n            sources = list(self.all()\n            cache.set(SOURCES_CACHE_KEY, sources)\n        return sources\n", "code_toks_joined": "class DatasourceManager ( models . Manager ) : <NEWLINE> <INDENT> def cached ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> sources = cache . get ( SOURCES_CACHE_KEY ) <NEWLINE> if not sources : <NEWLINE> <INDENT> sources = list ( self . all ( ) <NEWLINE> cache . set ( SOURCES_CACHE_KEY , sources ) <NEWLINE> <DEDENT> return sources <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return all datasources, caching the results.\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["5e49f34a788e95c1e031bd0de84082bf", {"code_string": "def get_job(self, jobid):\n    \"\"\"Returns a ThriftJobInProgress (including task info)\"\"\"\n    try:\n        job = self.client.getJob(self.thread_local.request_context, jobid)\n    except JobNotFoundException, e:\n        raise StructuredException(code = \"JT_JOB_NOT_FOUND\", message = \"Could not find job %s on JobTracker.\" % jobid.asString, data = jobid)\n    self._fixup_job(job)\n    return job\n", "code_toks_joined": "def get_job ( self , jobid ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> job = self . client . getJob ( self . thread_local . request_context , jobid ) <NEWLINE> <DEDENT> except JobNotFoundException , e : <NEWLINE> <INDENT> raise StructuredException ( code = <STRING> , message = <STRING> % jobid . asString , data = jobid ) <NEWLINE> <DEDENT> self . _fixup_job ( job ) <NEWLINE> return job <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns a ThriftJobInProgress (including task info)\"\"\"", "\"JT_JOB_NOT_FOUND\"", "\"Could not find job %s on JobTracker.\""]}, "err_obj": {"msg": "invalid syntax"}}], ["4ee4c4ffdcc61d0eea8f819733393690", {"code_string": "class ConnectionKey(Connection):\n    \"\"\"Base connection class which accepts a single ``key`` argument.\"\"\"\n    def __init__(self, key, secure = True, host = None, port = None, url = None,\n        timeout = None, proxy_url = None, backoff = None, retry_delay = None):\n        \"\"\"Initialize `user_id` and `key`; set `secure` to an ``int`` based on\"\"\"\n        super(ConnectionKey, self).__init__(secure = secure, host = host,\n            port = port, url = url,\n            timeout = timeout,\n            proxy_url = proxy_url,\n            backoff = backoff,\n            retry_delay = retry_delay)\n            self.key = key\n", "code_toks_joined": "class ConnectionKey ( Connection ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , key , secure = True , host = None , port = None , url = None , <NEWLINE> <INDENT> timeout = None , proxy_url = None , backoff = None , retry_delay = None ) : <NEWLINE> <STRING> <NEWLINE> super ( ConnectionKey , self ) . __init__ ( secure = secure , host = host , <NEWLINE> <INDENT> port = port , url = url , <NEWLINE> timeout = timeout , <NEWLINE> proxy_url = proxy_url , <NEWLINE> backoff = backoff , <NEWLINE> retry_delay = retry_delay ) <NEWLINE> self . key = key <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Base connection class which accepts a single ``key`` argument.\"\"\"", "\"\"\"Initialize `user_id` and `key`; set `secure` to an ``int`` based on\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["3975488321405e65423e9a14ccb98ae2", {"code_string": "from material.frontend import Module\n    class Sample(Module):\n        icon = 'mdi-image-compare'\n", "code_toks_joined": "from material . frontend import Module <NEWLINE> <INDENT> class Sample ( Module ) : <NEWLINE> <INDENT> icon = <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'mdi-image-compare'"]}, "err_obj": {"msg": "unexpected indent"}}], ["7b8fa926c46291f29ad74e7f83cff17b", {"code_string": "class Ui_About(object):\n    def setupUi(self, About):\n        About.setObjectName(\"About\")\n        About.resize(462, 249)\n        self.verticalLayoutWidget = QtGui.QWidget(About)\n        self.verticalLayoutWidget.setGeometry(QtCore.QRect(10, 0, 441, 208))\n        self.verticalLayoutWidget.setObjectName(\"verticalLayoutWidget\")\n        self.verticalLayout = QtGui.QVBoxLayout(self.verticalLayoutWidget)\n        self.verticalLayout.setObjectName(\"verticalLayout\")\n        self.label = QtGui.QLabel(self.verticalLayoutWidget)\n        self.label.setObjectName(\"label\")\n        self.verticalLayout.addWidget(self.label)\n        self.version = QtGui.QLabel(self.verticalLayoutWidget)\n        self.version.setObjectName(\"version\")\n        self.verticalLayout.addWidget(self.version)\n        self.retranslateUi(About)\n        QtCore.QMetaObject.connectSlotsByName(About)\n    def retranslateUi(self, About):\n        About.setWindowTitle(QtGui.QApplication.translate(\"About\", \"Dialog\", None, QtGui.QApplication.UnicodeUTF8))\n        self.label.setText(QtGui.QApplication.translate(\"About\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "class Ui_About ( object ) : <NEWLINE> <INDENT> def setupUi ( self , About ) : <NEWLINE> <INDENT> About . setObjectName ( <STRING> ) <NEWLINE> About . resize ( 462 , 249 ) <NEWLINE> self . verticalLayoutWidget = QtGui . QWidget ( About ) <NEWLINE> self . verticalLayoutWidget . setGeometry ( QtCore . QRect ( 10 , 0 , 441 , 208 ) ) <NEWLINE> self . verticalLayoutWidget . setObjectName ( <STRING> ) <NEWLINE> self . verticalLayout = QtGui . QVBoxLayout ( self . verticalLayoutWidget ) <NEWLINE> self . verticalLayout . setObjectName ( <STRING> ) <NEWLINE> self . label = QtGui . QLabel ( self . verticalLayoutWidget ) <NEWLINE> self . label . setObjectName ( <STRING> ) <NEWLINE> self . verticalLayout . addWidget ( self . label ) <NEWLINE> self . version = QtGui . QLabel ( self . verticalLayoutWidget ) <NEWLINE> self . version . setObjectName ( <STRING> ) <NEWLINE> self . verticalLayout . addWidget ( self . version ) <NEWLINE> self . retranslateUi ( About ) <NEWLINE> QtCore . QMetaObject . connectSlotsByName ( About ) <NEWLINE> <DEDENT> def retranslateUi ( self , About ) : <NEWLINE> <INDENT> About . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"About\"", "\"verticalLayoutWidget\"", "\"verticalLayout\"", "\"label\"", "\"version\"", "\"About\"", "\"Dialog\"", "\"About\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "window_span": [218, 231], "err_obj": {"msg": "unbalanced (){}[]"}}], ["26b587afbc28733e89fc357c68aef15a", {"code_string": "class Audit(Model):\n    def __init__(self, enabled, keep_files = 7, rotate = \"daily\",\n        events = None, restrictions = None):\n        \"\"\"Create an audit.\"\"\"\n        self._config = {\n        'audit-enabled': enabled,\n        'keep-audit-files': keep_files,\n        'rotate-audit-files': rotate\n        }\n        if events is not None:\n        self._config['audit-event'] = events\n        if restrictions is not None:\n        self._config['audit-restriction'] = restrictions\n", "code_toks_joined": "class Audit ( Model ) : <NEWLINE> <INDENT> def __init__ ( self , enabled , keep_files = 7 , rotate = <STRING> , <NEWLINE> <INDENT> events = None , restrictions = None ) : <NEWLINE> <STRING> <NEWLINE> self . _config = { <NEWLINE> <STRING> : enabled , <NEWLINE> <STRING> : keep_files , <NEWLINE> <STRING> : rotate <NEWLINE> } <NEWLINE> if events is not None : <NEWLINE> self . _config [ <STRING> ] = events <NEWLINE> if restrictions is not None : <NEWLINE> self . _config [ <STRING> ] = restrictions <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"daily\"", "\"\"\"Create an audit.\"\"\"", "'audit-enabled'", "'keep-audit-files'", "'rotate-audit-files'", "'audit-event'", "'audit-restriction'"]}, "err_obj": {"msg": "expected an indented block"}}], ["29d9f1fbde88d5fd9f42503d22b6bea9", {"code_string": "def getAllEventForAllUser(self):\n    allUser = User.getAllUser()\n    allEvent = []\n    if allUser:\n        for user in allUser:\n            allEvent.append(user)\n        return allUser\n    else\n        return None\n", "code_toks_joined": "def getAllEventForAllUser ( self ) : <NEWLINE> <INDENT> allUser = User . getAllUser ( ) <NEWLINE> allEvent = [ ] <NEWLINE> if allUser : <NEWLINE> <INDENT> for user in allUser : <NEWLINE> <INDENT> allEvent . append ( user ) <NEWLINE> <DEDENT> return allUser <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["95659ae1c2b5469756e15bfd4e3b5a78", {"code_string": "class CAboutDlg(CDialog):\n    CAboutDlg()\n    enum IDD = IDD_ABOUTBOX\n    DoDataExchange = virtual void(CDataExchange * pDX)\n    DECLARE_MESSAGE_MAP()\n", "code_toks_joined": "class CAboutDlg ( CDialog ) : <NEWLINE> <INDENT> CAboutDlg ( ) <NEWLINE> enum IDD = IDD_ABOUTBOX <NEWLINE> DoDataExchange = virtual void ( CDataExchange * pDX ) <NEWLINE> DECLARE_MESSAGE_MAP ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["a4623b31c703efa0c91f56b405df1621", {"code_string": "def test_index_default_limit(self):\n    self.config(limit_param_default = 1, api_limit_max = 3)\n    path = '/tasks'\n    request = unit_test_utils.get_fake_request(path)\n    output = self.controller.index(request)\n    actual = set([task.task_id for task in output['tasks']])\n    self.assertEqual(1, len(actual)\n", "code_toks_joined": "def test_index_default_limit ( self ) : <NEWLINE> <INDENT> self . config ( limit_param_default = 1 , api_limit_max = 3 ) <NEWLINE> path = <STRING> <NEWLINE> request = unit_test_utils . get_fake_request ( path ) <NEWLINE> output = self . controller . index ( request ) <NEWLINE> actual = set ( [ task . task_id for task in output [ <STRING> ] ] ) <NEWLINE> self . assertEqual ( 1 , len ( actual ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'/tasks'", "'tasks'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["53e8826f12f8d083e4959bbf39860135", {"code_string": "def get(self, url, data = None, headers = {}, type = None):\n    req = None\n    try:\n        if self.AcceptTypes[type]:\n            headers['Accept'] = self.AcceptTypes[type]\n            req = RequestWithMethod(url, 'GET', headers = headers)\n    except:\n        req = RequestWithMethod(url, 'GET', , headers = headers)\n    return(self._query(req))\n", "code_toks_joined": "def get ( self , url , data = None , headers = { } , type = None ) : <NEWLINE> <INDENT> req = None <NEWLINE> try : <NEWLINE> <INDENT> if self . AcceptTypes [ type ] : <NEWLINE> <INDENT> headers [ <STRING> ] = self . AcceptTypes [ type ] <NEWLINE> req = RequestWithMethod ( url , <STRING> , headers = headers ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> req = RequestWithMethod ( url , <STRING> , , headers = headers ) <NEWLINE> <DEDENT> return ( self . _query ( req ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Accept'", "'GET'", "'GET'"]}, "err_obj": {"msg": "invalid syntax"}}], ["434a899c42550d3a6e77293fb2d0f5fe", {"code_string": "def build_extra(d):\n    data_fields = ['value', 'url', 'img', 'class', 'data']\n    if not isinstance(d['value'], list):\n        for k, v in d.items():\n            d[k] = [v]\n    col = dict(filter(lambda(k, v): k in data_fields, d.items()))\n    return col\n", "code_toks_joined": "def build_extra ( d ) : <NEWLINE> <INDENT> data_fields = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> if not isinstance ( d [ <STRING> ] , list ) : <NEWLINE> <INDENT> for k , v in d . items ( ) : <NEWLINE> <INDENT> d [ k ] = [ v ] <NEWLINE> <DEDENT> <DEDENT> col = dict ( filter ( lambda ( k , v ) : k in data_fields , d . items ( ) ) ) <NEWLINE> return col <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'value'", "'url'", "'img'", "'class'", "'data'", "'value'"]}, "err_obj": {"msg": "invalid syntax"}}], ["b90a904695a789ce31925d335704c192", {"code_string": "def default(func, exception, deflt):\n    try:\n    return func()\n    except exception:\n    return deflt\n", "code_toks_joined": "def default ( func , exception , deflt ) : <NEWLINE> <INDENT> try : <NEWLINE> return func ( ) <NEWLINE> except exception : <NEWLINE> return deflt <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["704131fac5613fcf6ecc4ee413dfa22e", {"code_string": "\"\"\"ShallowLandslide_py v2.4.1\"\"\"\nimport arcpy\nimport os\nimport time\nfrom arcpy import env\narcpy.CheckOutExtension(\"spatial\")\nfrom arcpy.sa import *\nver = 2.4 .1\nisLiDAR = True\nDEM_raster_input = \"C:\\\\WorkSpace\\\\Biocriteria\\\\WatershedCharaterization\\\\BareEarth_Prob.gdb\\\\be_prob\"\nFSP_raster_input = \"C:\\\\WorkSpace\\\\Biocriteria\\\\WatershedCharaterization\\\\Lithology.gdb\\\\Lithology_ws_FSP\"\nSlope_Reclassification_Table = \"C:\\\\WorkSpace\\\\Biocriteria\\\\WatershedCharaterization\\\\ShallowLandslides\\\\Reclass_Tables_v2_4\\\\slope_relcass\"\nLith_Reclassification_Table = \"C:\\\\WorkSpace\\\\Biocriteria\\\\WatershedCharaterization\\\\ShallowLandslides\\\\Reclass_Tables_v2_4\\\\lithology_reclass\"\nPlan_Reclassification_Table1 = \"C:\\\\WorkSpace\\\\Biocriteria\\\\WatershedCharaterization\\\\ShallowLandslides\\\\Reclass_Tables_v2_4\\\\planform_reclass_LiDAR\"\nPlan_Reclassification_Table2 = \"C:\\\\WorkSpace\\\\Biocriteria\\\\WatershedCharaterization\\\\ShallowLandslides\\\\Reclass_Tables_v2_4\\\\planform_reclass_dem10m\"\nSusceptability_Reclassification_Table = \"C:\\\\WorkSpace\\\\Biocriteria\\\\WatershedCharaterization\\\\ShallowLandslides\\\\Reclass_Tables_v2_4\\\\susceptibility_reclass\"\nenv.workspace = \"C:\\\\WorkSpace\\\\Biocriteria\\\\WatershedCharaterization\\\\ShallowLandslides\\\\ShallowLandslides_OUT_LiDAR_prob.gdb\"\nOUT_SUSCEP = env.workspace + \"\\\\SUSCEP\"\nOUT_SUSCEP_reclass = env.workspace + \"\\\\SUSCEP_reclass_Final\"\nOUT_SLOPE = env.workspace + \"\\\\SLOPE\"\nOUT_SLOPE_reclass = env.workspace + \"\\\\SLOPE_reclass\"\nOUT_LITH_reclass = env.workspace + \"\\\\LITH_reclass\"\nOUT_PROFILE = env.workspace + \"\\\\PROFILE\"\nOUT_CURVE = env.workspace + \"\\\\CURVE\"\nOUT_PLAN = env.workspace + \"\\\\PLAN\"\nOUT_PLAN_Focal = env.workspace + \"\\\\PLAN_Focal\"\nOUT_PLAN_reclass = env.workspace + \"\\\\PLAN_reclass\"\nenv.overwriteOutput = True\nenv.cellSize = DEM_raster_input\nenv.snapRaster = DEM_raster_input\nstartTime = time.time()\nprint(\"START ShallowLandslide_py v{0}: {1}\".format(ver, time.ctime(startTime)))\nprint(\"Starting process 1/8: Generate Planform Curvature\")\nif arcpy.Exists(OUT_PLAN) == False:\n    CURVE = Curvature(DEM_raster_input, 1.0, OUT_PROFILE, OUT_PLAN)\n    CURVE.save(OUT_CURVE)\nelse:\n    OUT_PLAN = Raster(OUT_PLAN)\n    print(\"PLAN raster exists\")\nprint(\"Starting process 2/8: Focal statistics on Planform Curvature\")\nif arcpy.Exists(OUT_PLAN_Focal) == False:\n    if isLiDAR == True:\n        PLAN_Focal = FocalStatistics(OUT_PLAN, NbrRectangle(5, 5, \"CELL\"), \"MEAN\", \"DATA\")\n        PLAN_Focal.save(OUT_PLAN_Focal)\n    else:\n        print(\"10m DEM, skipping focal statistics\")\n        PLAN_Focal = Raster(OUT_PLAN)\nelse:\n    PLAN_Focal = Raster(OUT_PLAN_Focal)\n    print(\"PLAN_focal raster exists\")\nprint(\"Starting process 3/8: Reclassify PLAN\")\nif isLiDAR == True:\n    Plan_Reclassification_Table = Plan_Reclassification_Table1\nelse:\n    Plan_Reclassification_Table = Plan_Reclassification_Table2\nif arcpy.Exists(OUT_PLAN_reclass) == False:\n    PLAN_reclass = ReclassByTable(PLAN_Focal, Plan_Reclassification_Table, \"FROM\", \"TO\", \"OUT\", \"DATA\")\n    PLAN_reclass.save(OUT_PLAN_reclass)\nelse:\n    PLAN_reclass = OUT_PLAN_reclass\n    print(\"PLAN_reclass raster exists\")\nprint(\"Starting process 4/8: Reclassify LITH\")\nif arcpy.Exists(OUT_LITH_reclass) == False:\n    LITH_reclass = ReclassByTable(FSP_raster_input, Lith_Reclassification_Table, \"FROM\", \"TO\", \"OUT\", \"DATA\")\n    LITH_reclass.save(OUT_LITH_reclass)\nelse:\n    LITH_reclass = Raster(OUT_LITH_reclass)\n    print(\"LITH_reclass raster exists\")\nprint(\"Starting process 5/8: Slope\")\nif arcpy.Exists(OUT_SLOPE) == False:\n    SLOPE = Slope(DEM_raster_input, \"PERCENT_RISE\", 1.0)\n    SLOPE.save(OUT_SLOPE)\nelse:\n    SLOPE = Raster(OUT_SLOPE)\n    print(\"SLOPE raster exists\")\nprint(\"Starting process 6/8: Reclassify SLOPE\")\nif arcpy.Exists(OUT_SLOPE_reclass) == False:\n    SLOPE_reclass = ReclassByTable(SLOPE, Slope_Reclassification_Table, \"FROM\", \"TO\", \"OUT\", \"DATA\")\n    SLOPE_reclass.save(OUT_SLOPE_reclass)\nelse:\n    SLOPE_reclass = Raster(OUT_SLOPE_reclass)\n    print(\"SLOPE_reclass raster exists\")\nprint(\"Starting process 7/8: Calculate SUSCEP Raster Codes (Plus)\")\nif arcpy.Exists(OUT_SUSCEP) == False:\n    SUSCEP = (LITH_reclass + SLOPE_reclass + PLAN_reclass)\n    SUSCEP.save(OUT_SUSCEP)\nelse:\n    SUSCEP = Raster(OUT_SUSCEP)\n    print(\"SUSCEP raster exists\")\nprint(\"Starting process 8/8: Reclassify SUSCEP\")\nSUSCEP_relcass = ReclassByTable(SUSCEP, Susceptability_Reclassification_Table, \"FROM\", \"TO\", \"OUT\", \"DATA\")\nSUSCEP_relcass.save(OUT_SUSCEP_reclass)\nendTime = time.time()\nElapsed_MIN = (endTime - startTime) / 60\nprint(\"All processes complete in {0} minutes\".format(Elapsed_MIN))\nprint(\"END ShallowLandslide_py v{0}: {1}\".format(ver, (time.ctime(endTime)))\n", "code_toks_joined": "<STRING> <NEWLINE> import arcpy <NEWLINE> import os <NEWLINE> import time <NEWLINE> from arcpy import env <NEWLINE> arcpy . CheckOutExtension ( <STRING> ) <NEWLINE> from arcpy . sa import * <NEWLINE> ver = 2.4 .1 <NEWLINE> isLiDAR = True <NEWLINE> DEM_raster_input = <STRING> <NEWLINE> FSP_raster_input = <STRING> <NEWLINE> Slope_Reclassification_Table = <STRING> <NEWLINE> Lith_Reclassification_Table = <STRING> <NEWLINE> Plan_Reclassification_Table1 = <STRING> <NEWLINE> Plan_Reclassification_Table2 = <STRING> <NEWLINE> Susceptability_Reclassification_Table = <STRING> <NEWLINE> env . workspace = <STRING> <NEWLINE> OUT_SUSCEP = env . workspace + <STRING> <NEWLINE> OUT_SUSCEP_reclass = env . workspace + <STRING> <NEWLINE> OUT_SLOPE = env . workspace + <STRING> <NEWLINE> OUT_SLOPE_reclass = env . workspace + <STRING> <NEWLINE> OUT_LITH_reclass = env . workspace + <STRING> <NEWLINE> OUT_PROFILE = env . workspace + <STRING> <NEWLINE> OUT_CURVE = env . workspace + <STRING> <NEWLINE> OUT_PLAN = env . workspace + <STRING> <NEWLINE> OUT_PLAN_Focal = env . workspace + <STRING> <NEWLINE> OUT_PLAN_reclass = env . workspace + <STRING> <NEWLINE> env . overwriteOutput = True <NEWLINE> env . cellSize = DEM_raster_input <NEWLINE> env . snapRaster = DEM_raster_input <NEWLINE> startTime = time . time ( ) <NEWLINE> print ( <STRING> . format ( ver , time . ctime ( startTime ) ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> if arcpy . Exists ( OUT_PLAN ) == False : <NEWLINE> <INDENT> CURVE = Curvature ( DEM_raster_input , 1.0 , OUT_PROFILE , OUT_PLAN ) <NEWLINE> CURVE . save ( OUT_CURVE ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> OUT_PLAN = Raster ( OUT_PLAN ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> if arcpy . Exists ( OUT_PLAN_Focal ) == False : <NEWLINE> <INDENT> if isLiDAR == True : <NEWLINE> <INDENT> PLAN_Focal = FocalStatistics ( OUT_PLAN , NbrRectangle ( 5 , 5 , <STRING> ) , <STRING> , <STRING> ) <NEWLINE> PLAN_Focal . save ( OUT_PLAN_Focal ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> PLAN_Focal = Raster ( OUT_PLAN ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> PLAN_Focal = Raster ( OUT_PLAN_Focal ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> if isLiDAR == True : <NEWLINE> <INDENT> Plan_Reclassification_Table = Plan_Reclassification_Table1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Plan_Reclassification_Table = Plan_Reclassification_Table2 <NEWLINE> <DEDENT> if arcpy . Exists ( OUT_PLAN_reclass ) == False : <NEWLINE> <INDENT> PLAN_reclass = ReclassByTable ( PLAN_Focal , Plan_Reclassification_Table , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> PLAN_reclass . save ( OUT_PLAN_reclass ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> PLAN_reclass = OUT_PLAN_reclass <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> if arcpy . Exists ( OUT_LITH_reclass ) == False : <NEWLINE> <INDENT> LITH_reclass = ReclassByTable ( FSP_raster_input , Lith_Reclassification_Table , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> LITH_reclass . save ( OUT_LITH_reclass ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> LITH_reclass = Raster ( OUT_LITH_reclass ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> if arcpy . Exists ( OUT_SLOPE ) == False : <NEWLINE> <INDENT> SLOPE = Slope ( DEM_raster_input , <STRING> , 1.0 ) <NEWLINE> SLOPE . save ( OUT_SLOPE ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> SLOPE = Raster ( OUT_SLOPE ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> if arcpy . Exists ( OUT_SLOPE_reclass ) == False : <NEWLINE> <INDENT> SLOPE_reclass = ReclassByTable ( SLOPE , Slope_Reclassification_Table , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> SLOPE_reclass . save ( OUT_SLOPE_reclass ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> SLOPE_reclass = Raster ( OUT_SLOPE_reclass ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> if arcpy . Exists ( OUT_SUSCEP ) == False : <NEWLINE> <INDENT> SUSCEP = ( LITH_reclass + SLOPE_reclass + PLAN_reclass ) <NEWLINE> SUSCEP . save ( OUT_SUSCEP ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> SUSCEP = Raster ( OUT_SUSCEP ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> SUSCEP_relcass = ReclassByTable ( SUSCEP , Susceptability_Reclassification_Table , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> SUSCEP_relcass . save ( OUT_SUSCEP_reclass ) <NEWLINE> endTime = time . time ( ) <NEWLINE> Elapsed_MIN = ( endTime - startTime ) / 60 <NEWLINE> print ( <STRING> . format ( Elapsed_MIN ) ) <NEWLINE> print ( <STRING> . format ( ver , ( time . ctime ( endTime ) ) ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"\"\"ShallowLandslide_py v2.4.1\"\"\"", "\"spatial\"", "\"C:\\\\WorkSpace\\\\Biocriteria\\\\WatershedCharaterization\\\\BareEarth_Prob.gdb\\\\be_prob\"", "\"C:\\\\WorkSpace\\\\Biocriteria\\\\WatershedCharaterization\\\\Lithology.gdb\\\\Lithology_ws_FSP\"", "\"C:\\\\WorkSpace\\\\Biocriteria\\\\WatershedCharaterization\\\\ShallowLandslides\\\\Reclass_Tables_v2_4\\\\slope_relcass\"", "\"C:\\\\WorkSpace\\\\Biocriteria\\\\WatershedCharaterization\\\\ShallowLandslides\\\\Reclass_Tables_v2_4\\\\lithology_reclass\"", "\"C:\\\\WorkSpace\\\\Biocriteria\\\\WatershedCharaterization\\\\ShallowLandslides\\\\Reclass_Tables_v2_4\\\\planform_reclass_LiDAR\"", "\"C:\\\\WorkSpace\\\\Biocriteria\\\\WatershedCharaterization\\\\ShallowLandslides\\\\Reclass_Tables_v2_4\\\\planform_reclass_dem10m\"", "\"C:\\\\WorkSpace\\\\Biocriteria\\\\WatershedCharaterization\\\\ShallowLandslides\\\\Reclass_Tables_v2_4\\\\susceptibility_reclass\"", "\"C:\\\\WorkSpace\\\\Biocriteria\\\\WatershedCharaterization\\\\ShallowLandslides\\\\ShallowLandslides_OUT_LiDAR_prob.gdb\"", "\"\\\\SUSCEP\"", "\"\\\\SUSCEP_reclass_Final\"", "\"\\\\SLOPE\"", "\"\\\\SLOPE_reclass\"", "\"\\\\LITH_reclass\"", "\"\\\\PROFILE\"", "\"\\\\CURVE\"", "\"\\\\PLAN\"", "\"\\\\PLAN_Focal\"", "\"\\\\PLAN_reclass\"", "\"START ShallowLandslide_py v{0}: {1}\"", "\"Starting process 1/8: Generate Planform Curvature\"", "\"PLAN raster exists\"", "\"Starting process 2/8: Focal statistics on Planform Curvature\"", "\"CELL\"", "\"MEAN\"", "\"DATA\"", "\"10m DEM, skipping focal statistics\"", "\"PLAN_focal raster exists\"", "\"Starting process 3/8: Reclassify PLAN\"", "\"FROM\"", "\"TO\"", "\"OUT\"", "\"DATA\"", "\"PLAN_reclass raster exists\"", "\"Starting process 4/8: Reclassify LITH\"", "\"FROM\"", "\"TO\"", "\"OUT\"", "\"DATA\"", "\"LITH_reclass raster exists\"", "\"Starting process 5/8: Slope\"", "\"PERCENT_RISE\"", "\"SLOPE raster exists\"", "\"Starting process 6/8: Reclassify SLOPE\"", "\"FROM\"", "\"TO\"", "\"OUT\"", "\"DATA\"", "\"SLOPE_reclass raster exists\"", "\"Starting process 7/8: Calculate SUSCEP Raster Codes (Plus)\"", "\"SUSCEP raster exists\"", "\"Starting process 8/8: Reclassify SUSCEP\"", "\"FROM\"", "\"TO\"", "\"OUT\"", "\"DATA\"", "\"All processes complete in {0} minutes\"", "\"END ShallowLandslide_py v{0}: {1}\""]}, "window_span": [696, 713], "err_obj": {"msg": "unbalanced (){}[]"}}], ["110447c9b82681215498763ebc41516b", {"code_string": "def SummarizeUrl(url, i = 5):\n    summaries = []\n    try:\n        article = grab_link(url)\n    except IOError:\n        print('IOError')\n        return None\n    if not(article and article.cleaned_text and article.title):\n        return None\n    summaries = Summarize(unicode(article.title)\n        unicode(article.cleaned_text), i)\n    return summaries\n", "code_toks_joined": "def SummarizeUrl ( url , i = 5 ) : <NEWLINE> <INDENT> summaries = [ ] <NEWLINE> try : <NEWLINE> <INDENT> article = grab_link ( url ) <NEWLINE> <DEDENT> except IOError : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return None <NEWLINE> <DEDENT> if not ( article and article . cleaned_text and article . title ) : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> summaries = Summarize ( unicode ( article . title ) <NEWLINE> <INDENT> unicode ( article . cleaned_text ) , i ) <NEWLINE> <DEDENT> return summaries <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'IOError'"]}, "err_obj": {"msg": "invalid syntax"}}], ["afeebf6f460e510de7cc7ac98dbc2f64", {"code_string": "def final_action_state(path):\n    \"return the final state from a path\"\n    if len(path) > 1\n        return path[- 2][0], path[- 1]\n    return None, path[- 1]\n", "code_toks_joined": "def final_action_state ( path ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if len ( path ) > 1 <NEWLINE> <INDENT> return path [ - 2 ] [ 0 ] , path [ - 1 ] <NEWLINE> <DEDENT> return None , path [ - 1 ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"return the final state from a path\""]}, "err_obj": {"msg": "invalid syntax"}}], ["67b63291f63420b4a4cf8b3b29ff3efa", {"code_string": "def get_history(self):\n    \"\"\"Returns list of history entries.\"\"\"\n    history_file_name = self._get_history_file_name()\n    if os.path.isfile(history_file_name):\n        with io.open(history_file_name, 'r',\n            encoding = 'utf-8', errors = 'ignore') as history:\n            for line in history:\n            prepared = self._script_from_history(line).strip()\n            if prepared:\n            yield prepared\n", "code_toks_joined": "def get_history ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> history_file_name = self . _get_history_file_name ( ) <NEWLINE> if os . path . isfile ( history_file_name ) : <NEWLINE> <INDENT> with io . open ( history_file_name , <STRING> , <NEWLINE> <INDENT> encoding = <STRING> , errors = <STRING> ) as history : <NEWLINE> for line in history : <NEWLINE> prepared = self . _script_from_history ( line ) . strip ( ) <NEWLINE> if prepared : <NEWLINE> yield prepared <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns list of history entries.\"\"\"", "'r'", "'utf-8'", "'ignore'"]}, "err_obj": {"msg": "expected an indented block"}}], ["a1dacbad360de5c518497e9334c8ea68", {"code_string": "def print_latex(go_analyses, f = sys.stdout, factors = True):\n    transcriptional_programs, factor_universe, target_universe = tp_threshold.threshold_tps()\n    t = factors and 'Factors' or 'Targets'\n    print('%% %s' % t)\n    print('TP & %s & GO term & & GO description & \\\\multicolumn{2}{c}{annotated} & $p$-score \\\\\\\\' % t)\n    print('\\\\hline')\n    for k, (tp, tp_analysis) in enumerate(zip(transcriptional_programs, go_analyses)):\n        if factors:\n            type_analysis = tp_analysis.factors_go_analysis\n            size = len(tp.factors)\n        else:\n            type_analysis = tp_analysis.targets_go_analysis\n            size = len(tp.targets)\n        for ontology, analysis in type_analysis.iteritems():\n            if None != analysis:\n                for go_id, go_term, annotated, significant, expected, pvalue in topgo.yield_stats(analysis):\n                    tp.k,\n                    size,\n                    go_id,\n                    ontology,\n                    go_term,\n                    significant,\n                    annotated,\n                    pvalue\n                    )\n    print('\\\\\\\\')\n", "code_toks_joined": "def print_latex ( go_analyses , f = sys . stdout , factors = True ) : <NEWLINE> <INDENT> transcriptional_programs , factor_universe , target_universe = tp_threshold . threshold_tps ( ) <NEWLINE> t = factors and <STRING> or <STRING> <NEWLINE> print ( <STRING> % t ) <NEWLINE> print ( <STRING> % t ) <NEWLINE> print ( <STRING> ) <NEWLINE> for k , ( tp , tp_analysis ) in enumerate ( zip ( transcriptional_programs , go_analyses ) ) : <NEWLINE> <INDENT> if factors : <NEWLINE> <INDENT> type_analysis = tp_analysis . factors_go_analysis <NEWLINE> size = len ( tp . factors ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> type_analysis = tp_analysis . targets_go_analysis <NEWLINE> size = len ( tp . targets ) <NEWLINE> <DEDENT> for ontology , analysis in type_analysis . iteritems ( ) : <NEWLINE> <INDENT> if None != analysis : <NEWLINE> <INDENT> for go_id , go_term , annotated , significant , expected , pvalue in topgo . yield_stats ( analysis ) : <NEWLINE> <INDENT> tp . k , <NEWLINE> size , <NEWLINE> go_id , <NEWLINE> ontology , <NEWLINE> go_term , <NEWLINE> significant , <NEWLINE> annotated , <NEWLINE> pvalue <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Factors'", "'Targets'", "'%% %s'", "'TP & %s & GO term & & GO description & \\\\multicolumn{2}{c}{annotated} & $p$-score \\\\\\\\'", "'\\\\hline'", "'\\\\\\\\'"]}, "window_span": [184, 188], "err_obj": {"msg": "unbalanced (){}[]"}}], ["f4b3e58ab8d9545599e80e68749ce51c", {"code_string": "def _check_simple_error(ret, func, args):\n    if ret == ReturnCode.ERROR:\n    raise RuntimeError\n    return ret\n", "code_toks_joined": "def _check_simple_error ( ret , func , args ) : <NEWLINE> <INDENT> if ret == ReturnCode . ERROR : <NEWLINE> raise RuntimeError <NEWLINE> return ret <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["033056311786895101c33c57217f79a8", {"code_string": "def do_script(self, attrs):\n    baiceurl = self.baiceurl\n        for name, value in attrs:\n            if name == 'src' and value not in self.urls:\n                if value.startswith('/static'):\n                self.urls.append(baiceurl + value)\n                else:\n                if re.search('99114', value):\n        self.urls.append(value)\n            else:\n                continue\n            return\n", "code_toks_joined": "def do_script ( self , attrs ) : <NEWLINE> <INDENT> baiceurl = self . baiceurl <NEWLINE> <INDENT> for name , value in attrs : <NEWLINE> <INDENT> if name == <STRING> and value not in self . urls : <NEWLINE> <INDENT> if value . startswith ( <STRING> ) : <NEWLINE> self . urls . append ( baiceurl + value ) <NEWLINE> else : <NEWLINE> if re . search ( <STRING> , value ) : <NEWLINE> <DEDENT> <DEDENT> self . urls . append ( value ) <NEWLINE> <INDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'src'", "'/static'", "'99114'"]}, "err_obj": {"msg": "unexpected indent"}}], ["2ed965577a37567893c56f14e79c6b70", {"code_string": "def test_copes_with_empty_path_component(self):\n    file_name = 'file.txt'\n    response = self.client.get('/%s//%s' %(self.prefix, file_name))\n    response_content = b''.join(response)\n    with open(path.join(media_dir, file_name), 'rb') as fp\n        self.assertEqual(fp.read(), response_content)\n", "code_toks_joined": "def test_copes_with_empty_path_component ( self ) : <NEWLINE> <INDENT> file_name = <STRING> <NEWLINE> response = self . client . get ( <STRING> % ( self . prefix , file_name ) ) <NEWLINE> response_content = <STRING> . join ( response ) <NEWLINE> with open ( path . join ( media_dir , file_name ) , <STRING> ) as fp <NEWLINE> <INDENT> self . assertEqual ( fp . read ( ) , response_content ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'file.txt'", "'/%s//%s'", "b''", "'rb'"]}, "err_obj": {"msg": "invalid syntax"}}], ["894a540b0cb70cfaee76af2bca54c6de", {"code_string": "def adjust_loop_end(self, clip, track, xclip, ident, args):\n    \"\"\" Adjust/set clip loop end if loop is on or close end otherwise. \"\"\"\n    args = args.strip()\n    if args.startswith(('<', '>')):\n        factor = self._parent.get_adjustment_factor(args, True)\n        clip.loop_end = max((clip.loop_start - factor), (clip.loop_end + factor))\n    else:\n        try:\n        clip.loop_end = float(args)\n        except: pass\n", "code_toks_joined": "def adjust_loop_end ( self , clip , track , xclip , ident , args ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> args = args . strip ( ) <NEWLINE> if args . startswith ( ( <STRING> , <STRING> ) ) : <NEWLINE> <INDENT> factor = self . _parent . get_adjustment_factor ( args , True ) <NEWLINE> clip . loop_end = max ( ( clip . loop_start - factor ) , ( clip . loop_end + factor ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> clip . loop_end = float ( args ) <NEWLINE> except : pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Adjust/set clip loop end if loop is on or close end otherwise. \"\"\"", "'<'", "'>'"]}, "err_obj": {"msg": "expected an indented block"}}], ["a811793bd324f4776ae4796410191093", {"code_string": "def __get_file_docstrings(self):\n    \"\"\"get docstring of each file\"\"\"\n    file_lines = self.__get_file_lines()\n    file_docstrings = file_lines.map(\n        lambda((repo_name, file_path), file_lines): get_docstring(((repo_name, file_path), file_lines))\n    )\n    return file_docstrings\n", "code_toks_joined": "def __get_file_docstrings ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> file_lines = self . __get_file_lines ( ) <NEWLINE> file_docstrings = file_lines . map ( <NEWLINE> <INDENT> lambda ( ( repo_name , file_path ) , file_lines ) : get_docstring ( ( ( repo_name , file_path ) , file_lines ) ) <NEWLINE> <DEDENT> ) <NEWLINE> return file_docstrings <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"get docstring of each file\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["dffcbea6161f7086ad9e21160c614c0c", {"code_string": "def __iter__(self)\n    self.ind = - 1\n    self.a = len(self.data)\n    self.b = len(self.data[0].keys())\n    self.c = len(self.data[0][self.data[0].keys()[0]])\n    return(self)\n", "code_toks_joined": "def __iter__ ( self ) <NEWLINE> <INDENT> self . ind = - 1 <NEWLINE> self . a = len ( self . data ) <NEWLINE> self . b = len ( self . data [ 0 ] . keys ( ) ) <NEWLINE> self . c = len ( self . data [ 0 ] [ self . data [ 0 ] . keys ( ) [ 0 ] ] ) <NEWLINE> return ( self ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["60fccf4110588f82ed38743feddcb9c1", {"code_string": "def _get_next_friendly_id(conn, event_id):\n    cur = conn.execute(\"\"\"UPDATE events.events\"\"\", (event_id, )\n    return cur.fetchone()[0]\n", "code_toks_joined": "def _get_next_friendly_id ( conn , event_id ) : <NEWLINE> <INDENT> cur = conn . execute ( <STRING> , ( event_id , ) <NEWLINE> return cur . fetchone ( ) [ 0 ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"UPDATE events.events\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c842ac564aeeaf8f4e9a5ad7e68238b7", {"code_string": "def save(self):\n    if not self.filename:\n        self.filename = QtGui.QFileDialog.getSaveFileName(self, 'Save File')\n    if self.filename:\n        if not str(self.filename).endswith(\".writer\"):\n            self.filename += \".writer\"\n        with open(self.filename, \"wt\") as file:\n            file.write(self.text.toHtml()\n        self.changesSaved = True\n", "code_toks_joined": "def save ( self ) : <NEWLINE> <INDENT> if not self . filename : <NEWLINE> <INDENT> self . filename = QtGui . QFileDialog . getSaveFileName ( self , <STRING> ) <NEWLINE> <DEDENT> if self . filename : <NEWLINE> <INDENT> if not str ( self . filename ) . endswith ( <STRING> ) : <NEWLINE> <INDENT> self . filename += <STRING> <NEWLINE> <DEDENT> with open ( self . filename , <STRING> ) as file : <NEWLINE> <INDENT> file . write ( self . text . toHtml ( ) <NEWLINE> <DEDENT> self . changesSaved = True <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Save File'", "\".writer\"", "\".writer\"", "\"wt\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["18eecdf395c7d47f9197b4afa6172c6e", {"code_string": "def _assert_comments_service_called_without_group_id(self, mock_request):\n    self.assertTrue(mock_request.called)\n    self.assertNotIn(\"group_id\", self._data_or_params_cs_request(mock_request)\n", "code_toks_joined": "def _assert_comments_service_called_without_group_id ( self , mock_request ) : <NEWLINE> <INDENT> self . assertTrue ( mock_request . called ) <NEWLINE> self . assertNotIn ( <STRING> , self . _data_or_params_cs_request ( mock_request ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"group_id\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["9bb2bd15902e0accc6d546e8f9e9797b", {"code_string": "def obj_delete(self, request = None, ** kwargs):\n    internalDataStore = self.get_internal_datastore(request)\n    key = self.get_key(request)\n    if internalDataStore is not None and key is not None:\n        internalDataStore.saveAnswer({\"key\": key, \"value\": [] if self._meta.isList else{})\n", "code_toks_joined": "def obj_delete ( self , request = None , ** kwargs ) : <NEWLINE> <INDENT> internalDataStore = self . get_internal_datastore ( request ) <NEWLINE> key = self . get_key ( request ) <NEWLINE> if internalDataStore is not None and key is not None : <NEWLINE> <INDENT> internalDataStore . saveAnswer ( { <STRING> : key , <STRING> : [ ] if self . _meta . isList else { } ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"key\"", "\"value\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["3237940a464deac895e38a7946cc2b70", {"code_string": "class WaitingListDelete(threading.Thread):\n    def __init__(self, waitingid):\n        self.waitingid = waitingid\n        threading.Thread.__init__(self)\n    def run(self):\n    data = urllib.urlencode({'id': self.waitingid})\n    request = urllib2.Request('http://dev.watercooler.io/v1/waitinglist/delete', data, headers = {\"User-Agent\": \"Sublime Devunity\"})\n    http_file = urllib2.urlopen(request, timeout = 30).read()\n    response = json.loads(http_file)\n    print(response)\n", "code_toks_joined": "class WaitingListDelete ( threading . Thread ) : <NEWLINE> <INDENT> def __init__ ( self , waitingid ) : <NEWLINE> <INDENT> self . waitingid = waitingid <NEWLINE> threading . Thread . __init__ ( self ) <NEWLINE> <DEDENT> def run ( self ) : <NEWLINE> data = urllib . urlencode ( { <STRING> : self . waitingid } ) <NEWLINE> request = urllib2 . Request ( <STRING> , data , headers = { <STRING> : <STRING> } ) <NEWLINE> http_file = urllib2 . urlopen ( request , timeout = 30 ) . read ( ) <NEWLINE> response = json . loads ( http_file ) <NEWLINE> print ( response ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'id'", "'http://dev.watercooler.io/v1/waitinglist/delete'", "\"User-Agent\"", "\"Sublime Devunity\""]}, "err_obj": {"msg": "expected an indented block"}}], ["f20ffb14c8de9139828ae95393086e6e", {"code_string": "class hr_employee(orm.Model):\n    _name = 'hr.employee'\n    _inherit = 'hr.employee'\n    infraction_ids = fields.One2many(\n        'hr.infraction',\n        'employee_id',\n        'Infractions',\n        readonly = True\n        )\n        infraction_action_ids = fields.One2many(\n        'hr.infraction.action',\n        'employee_id',\n        'Disciplinary Actions',\n        readonly = True\n        )\n", "code_toks_joined": "class hr_employee ( orm . Model ) : <NEWLINE> <INDENT> _name = <STRING> <NEWLINE> _inherit = <STRING> <NEWLINE> infraction_ids = fields . One2many ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> readonly = True <NEWLINE> ) <NEWLINE> infraction_action_ids = fields . One2many ( <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> readonly = True <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'hr.employee'", "'hr.employee'", "'hr.infraction'", "'employee_id'", "'Infractions'", "'hr.infraction.action'", "'employee_id'", "'Disciplinary Actions'"]}, "err_obj": {"msg": "unexpected indent"}}], ["7d0291df463b95c2736d6d8d24901c25", {"code_string": "def insert_row(self, query, params):\n    try:\n        self.cursor.execute(query, params)\n    self.connection.commit()\n    except:\n        self.connection.rollback()\n", "code_toks_joined": "def insert_row ( self , query , params ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . cursor . execute ( query , params ) <NEWLINE> <DEDENT> self . connection . commit ( ) <NEWLINE> except : <NEWLINE> <INDENT> self . connection . rollback ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["4c67cb9b75df248ebf318b37d3858edd", {"code_string": "def allocate_primaryIPS(self, domains):\n    log.info(\"*** Allocating primary IPs\\n\")\n    for net, domain in self.network_for_domains(self.unallocated_ip_base,\n        domains,\n        max_prefixlen = self\n        .max_alloc_prefixlen):\n        hosts = net.hosts()\n        for intf in domain:\n        ip = str(next(hosts))\n        intf.setIP(ip, prefixLen = net.prefixlen)\n", "code_toks_joined": "def allocate_primaryIPS ( self , domains ) : <NEWLINE> <INDENT> log . info ( <STRING> ) <NEWLINE> for net , domain in self . network_for_domains ( self . unallocated_ip_base , <NEWLINE> <INDENT> domains , <NEWLINE> max_prefixlen = self <NEWLINE> . max_alloc_prefixlen ) : <NEWLINE> hosts = net . hosts ( ) <NEWLINE> for intf in domain : <NEWLINE> ip = str ( next ( hosts ) ) <NEWLINE> intf . setIP ( ip , prefixLen = net . prefixlen ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"*** Allocating primary IPs\\n\""]}, "err_obj": {"msg": "expected an indented block"}}], ["f16e721df000ba8b2e21a8cc66536cc5", {"code_string": "def get_atoms(pdb_file):\n    \"\"\"Returns an array with the atoms of the pdb file specified\"\"\"\n    parser = PDBParser()\n    structure = parser.get_structure(pdb_file[: - 4], pdb_file)\n    atms = structure.get_atoms()\n    atoms = []\n    for a in atms:\n    atoms.append(a.get_name())\n    if len(atoms) == 0:\n    print('404 - No Atoms Found!!!')\n    raise NoProtError('404 - No Atoms Found!!!')\n    return atoms\n", "code_toks_joined": "def get_atoms ( pdb_file ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> parser = PDBParser ( ) <NEWLINE> structure = parser . get_structure ( pdb_file [ : - 4 ] , pdb_file ) <NEWLINE> atms = structure . get_atoms ( ) <NEWLINE> atoms = [ ] <NEWLINE> for a in atms : <NEWLINE> atoms . append ( a . get_name ( ) ) <NEWLINE> if len ( atoms ) == 0 : <NEWLINE> print ( <STRING> ) <NEWLINE> raise NoProtError ( <STRING> ) <NEWLINE> return atoms <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns an array with the atoms of the pdb file specified\"\"\"", "'404 - No Atoms Found!!!'", "'404 - No Atoms Found!!!'"]}, "err_obj": {"msg": "expected an indented block"}}], ["4e2baa186ed99267607edac9ab38fbc0", {"code_string": "def directViewUi(self):\n    exec 'from controllers.directview import directView'\n    exec 'from controllers.VLCplayer import VLCPlayer'\n    self.directView = directView(self)\n    self.setCentralWidget(self.directView)\n    self.VLCPlayer = VLCPlayer()\n    self.directView.horizontalLayout.insertWidget(0, self.VLCPlayer)\n    self.directView.verticalLayout1.setAlignment(QtCore.Qt.AlignTop)\n    self.directView.verticalLayout2.setAlignment(QtCore.Qt.AlignTop)\n", "code_toks_joined": "def directViewUi ( self ) : <NEWLINE> <INDENT> exec <STRING> <NEWLINE> exec <STRING> <NEWLINE> self . directView = directView ( self ) <NEWLINE> self . setCentralWidget ( self . directView ) <NEWLINE> self . VLCPlayer = VLCPlayer ( ) <NEWLINE> self . directView . horizontalLayout . insertWidget ( 0 , self . VLCPlayer ) <NEWLINE> self . directView . verticalLayout1 . setAlignment ( QtCore . Qt . AlignTop ) <NEWLINE> self . directView . verticalLayout2 . setAlignment ( QtCore . Qt . AlignTop ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'from controllers.directview import directView'", "'from controllers.VLCplayer import VLCPlayer'"]}, "err_obj": {"msg": "invalid syntax"}}], ["f211b9c990de5e1c8585842065cce794", {"code_string": "def printErrors(self):\n    \"\"\"Nicely print the info about this subsystem in\"\"\"\n    print(\"Subsystem:\", self.subsystemName)\n    print(\"Base dir:\", self.baseDir)\n    for err in self.errors:\n        if self.duplicatedErrors.count(err.getNumber()) > 0:\n            print(\"The following error is defined more then once!\")\n                print(\"\\tType:\", err.getNumber())\n                print(\"\\tName: \", err.getName())\n                print(\"\\tDefined in\", err.getFile())\n    for err in self.errors:\n        err.printError()\n", "code_toks_joined": "def printErrors ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> , self . subsystemName ) <NEWLINE> print ( <STRING> , self . baseDir ) <NEWLINE> for err in self . errors : <NEWLINE> <INDENT> if self . duplicatedErrors . count ( err . getNumber ( ) ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> print ( <STRING> , err . getNumber ( ) ) <NEWLINE> print ( <STRING> , err . getName ( ) ) <NEWLINE> print ( <STRING> , err . getFile ( ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for err in self . errors : <NEWLINE> <INDENT> err . printError ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Nicely print the info about this subsystem in\"\"\"", "\"Subsystem:\"", "\"Base dir:\"", "\"The following error is defined more then once!\"", "\"\\tType:\"", "\"\\tName: \"", "\"\\tDefined in\""]}, "err_obj": {"msg": "unexpected indent"}}], ["affa6f4729bfb2f3e8cdd847adf736d2", {"code_string": "def cutype(type):\n    \"\"\"Decorator for declaring the type of a Copperhead procedure.\"\"\"\n    from compiler.parsetypes import T, type_from_text\n    if isinstance(type, str):\n        type = type_from_text(type)\n    elif not isinstance(type, T.Type):\n        raise TypeError, \"type (%s) must be string or Copperhead Type object\" % type\n    def setter(fn):\n        fn.cu_type = type\n        return fn\n    return setter\n", "code_toks_joined": "def cutype ( type ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> from compiler . parsetypes import T , type_from_text <NEWLINE> if isinstance ( type , str ) : <NEWLINE> <INDENT> type = type_from_text ( type ) <NEWLINE> <DEDENT> elif not isinstance ( type , T . Type ) : <NEWLINE> <INDENT> raise TypeError , <STRING> % type <NEWLINE> <DEDENT> def setter ( fn ) : <NEWLINE> <INDENT> fn . cu_type = type <NEWLINE> return fn <NEWLINE> <DEDENT> return setter <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Decorator for declaring the type of a Copperhead procedure.\"\"\"", "\"type (%s) must be string or Copperhead Type object\""]}, "err_obj": {"msg": "invalid syntax"}}], ["b83a3060e1588e52a33835b6d200d210", {"code_string": "def load_additional_args(self, config):\n    GPIO.setmode(GPIO.BCM)\n    GPIO.setwarnings(False)\n    outpins = self.config_get(config, 'Pins', 'output')\n    inpins = self.config_get(config, 'Pins', 'input')\n    for pins, mode in((outpins, GPIO.OUT),\n        (inpins, GPIO.IN)):\n        for pin in pins:\n        GPIO.setup(pin, mode)\n", "code_toks_joined": "def load_additional_args ( self , config ) : <NEWLINE> <INDENT> GPIO . setmode ( GPIO . BCM ) <NEWLINE> GPIO . setwarnings ( False ) <NEWLINE> outpins = self . config_get ( config , <STRING> , <STRING> ) <NEWLINE> inpins = self . config_get ( config , <STRING> , <STRING> ) <NEWLINE> for pins , mode in ( ( outpins , GPIO . OUT ) , <NEWLINE> <INDENT> ( inpins , GPIO . IN ) ) : <NEWLINE> for pin in pins : <NEWLINE> GPIO . setup ( pin , mode ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Pins'", "'output'", "'Pins'", "'input'"]}, "err_obj": {"msg": "expected an indented block"}}], ["9d86f830fb31b0e558ff63dd822cc99a", {"code_string": "from.fields import FIELD_NO_INPUT\ndef run_all(rule_list,\n    defined_variables,\n    defined_actions,\n    stop_on_first_trigger = False):\n    rule_was_triggered = False\n    for rule in rule_list:\n    result = run(rule, defined_variables, defined_actions)\n    if result:\n    rule_was_triggered = True\n    if stop_on_first_trigger:\n        return True\n        return rule_was_triggered\n", "code_toks_joined": "from . fields import FIELD_NO_INPUT <NEWLINE> def run_all ( rule_list , <NEWLINE> <INDENT> defined_variables , <NEWLINE> defined_actions , <NEWLINE> stop_on_first_trigger = False ) : <NEWLINE> rule_was_triggered = False <NEWLINE> for rule in rule_list : <NEWLINE> result = run ( rule , defined_variables , defined_actions ) <NEWLINE> if result : <NEWLINE> rule_was_triggered = True <NEWLINE> if stop_on_first_trigger : <NEWLINE> <INDENT> return True <NEWLINE> return rule_was_triggered <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["721e1cdd98c6952b1d1d4d8481736638", {"code_string": "def OnPaint(self, evt):\n    dc = self.__getClientDC()\n        self.doPaint(dc)\n    evt.Skip()\n", "code_toks_joined": "def OnPaint ( self , evt ) : <NEWLINE> <INDENT> dc = self . __getClientDC ( ) <NEWLINE> <INDENT> self . doPaint ( dc ) <NEWLINE> <DEDENT> evt . Skip ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["cf6d4ce878f337022b6bc99f325b7bc5", {"code_string": "def _apply_battery_charge_thresholds(self):\n    start_threshold, stop_threshold = [spin_box.value() for spin_box in\n        self._form.start_threshold_spin_box,\n        self._form.stop_threshold_spin_box\n        ]\n    self._set_battery_charge_threshold(start_threshold, stop_threshold)\n", "code_toks_joined": "def _apply_battery_charge_thresholds ( self ) : <NEWLINE> <INDENT> start_threshold , stop_threshold = [ spin_box . value ( ) for spin_box in <NEWLINE> <INDENT> self . _form . start_threshold_spin_box , <NEWLINE> self . _form . stop_threshold_spin_box <NEWLINE> ] <NEWLINE> <DEDENT> self . _set_battery_charge_threshold ( start_threshold , stop_threshold ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["e3b17638d4e8067359023304b2f9d6c9", {"code_string": "def testAsserCalls_succeeds_withAction(self):\n    with self.assertCall(\n        self.call.adb.Shell('echo hello'), self.ShellError()):\n        with self.assertRaises(ValueError):\n        self.adb.Shell('echo hello')\n", "code_toks_joined": "def testAsserCalls_succeeds_withAction ( self ) : <NEWLINE> <INDENT> with self . assertCall ( <NEWLINE> <INDENT> self . call . adb . Shell ( <STRING> ) , self . ShellError ( ) ) : <NEWLINE> with self . assertRaises ( ValueError ) : <NEWLINE> self . adb . Shell ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'echo hello'", "'echo hello'"]}, "err_obj": {"msg": "expected an indented block"}}], ["9b71130c6e46aa3542a90eb72927e2ef", {"code_string": "def InputDialog():\n    d = MyDialog(root)\n        root.wait_window(d.top)\n    strinfo = d.name + str(d.age)\n        tkMessageBox.showinfo('Info', strinfo)\n", "code_toks_joined": "def InputDialog ( ) : <NEWLINE> <INDENT> d = MyDialog ( root ) <NEWLINE> <INDENT> root . wait_window ( d . top ) <NEWLINE> <DEDENT> strinfo = d . name + str ( d . age ) <NEWLINE> <INDENT> tkMessageBox . showinfo ( <STRING> , strinfo ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Info'"]}, "err_obj": {"msg": "unexpected indent"}}], ["a6c6ea1d346ff5bcf5066f00cbad2b22", {"code_string": "def main(self):\n    try:\n        while 1:\n            self.process()\n    except KeyboardInterrupt:\n        print('')\n        print('hash = {')\n        l = sorted(self.hash.iteritems(), key = lambda(k, v): (v, k))\n        for hash, value in l:\n            print('        \\'%s\\': %s' %(hash, value))\n        print('}')\n", "code_toks_joined": "def main ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> while 1 : <NEWLINE> <INDENT> self . process ( ) <NEWLINE> <DEDENT> <DEDENT> except KeyboardInterrupt : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> l = sorted ( self . hash . iteritems ( ) , key = lambda ( k , v ) : ( v , k ) ) <NEWLINE> for hash , value in l : <NEWLINE> <INDENT> print ( <STRING> % ( hash , value ) ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "'hash = {'", "'        \\'%s\\': %s'", "'}'"]}, "err_obj": {"msg": "invalid syntax"}}], ["b63b41505e4c5d238125479326e71247", {"code_string": "class Question(models.Model):\n    question_text = models.CharField(max_length = 200)\n    pub_date = models.DateTimeField('date published')\n    def __str__(self):\n    return self.question_text\n    def was_published_recently(self):\n        now = timezone.now()\n        return now - datetime.timedelta(days = 1) <= self.pub_date <= now\n", "code_toks_joined": "class Question ( models . Model ) : <NEWLINE> <INDENT> question_text = models . CharField ( max_length = 200 ) <NEWLINE> pub_date = models . DateTimeField ( <STRING> ) <NEWLINE> def __str__ ( self ) : <NEWLINE> return self . question_text <NEWLINE> def was_published_recently ( self ) : <NEWLINE> <INDENT> now = timezone . now ( ) <NEWLINE> return now - datetime . timedelta ( days = 1 ) <= self . pub_date <= now <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'date published'"]}, "err_obj": {"msg": "expected an indented block"}}], ["7fde1b5983fc40179f6fc610f889dec5", {"code_string": "def read_file_into_string(filename):\n    path = os.path.abspath(os.path.dirname(__file__)))\n    filepath = os.path.join(path, filename)\n    try:\n        return open(filepath).read()\n    except IOError:\n        return ''\n", "code_toks_joined": "def read_file_into_string ( filename ) : <NEWLINE> <INDENT> path = os . path . abspath ( os . path . dirname ( __file__ ) ) ) <NEWLINE> filepath = os . path . join ( path , filename ) <NEWLINE> try : <NEWLINE> <INDENT> return open ( filepath ) . read ( ) <NEWLINE> <DEDENT> except IOError : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c981bc9fb9e1e3a7f245b8e168c74f3b", {"code_string": "def decompose(C):\n    try:\n        return cholesky(C)\n    except Exception, e:\n        return modified_cholesky(C)\n", "code_toks_joined": "def decompose ( C ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return cholesky ( C ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> return modified_cholesky ( C ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["9ef5572cc735f84259223cf00d3a06f6", {"code_string": "def gradient(self, l):\n    return numpy.array([\n        numpy.ones(len(l), float)\n    ] + sum(\n        (list(gaussian.gradient(l))) for gaussian in self.gaussians)\n    , []))\n", "code_toks_joined": "def gradient ( self , l ) : <NEWLINE> <INDENT> return numpy . array ( [ <NEWLINE> <INDENT> numpy . ones ( len ( l ) , float ) <NEWLINE> <DEDENT> ] + sum ( <NEWLINE> <INDENT> ( list ( gaussian . gradient ( l ) ) ) for gaussian in self . gaussians ) <NEWLINE> <DEDENT> , [ ] ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["3b95e10c3dcaf5322c24931d967e7541", {"code_string": "def test_chunkcoding(self):\n    for native, utf8 in zip(*[StringIO(f).readlines()\n        for f in self.tstring]):\n        u = self.decode(native)[0]\n        self.assertEqual(u, utf8.decode('utf-8'))\n        if self.roundtriptest:\n        self.assertEqual(native, self.encode(u)[0])\n", "code_toks_joined": "def test_chunkcoding ( self ) : <NEWLINE> <INDENT> for native , utf8 in zip ( * [ StringIO ( f ) . readlines ( ) <NEWLINE> <INDENT> for f in self . tstring ] ) : <NEWLINE> u = self . decode ( native ) [ 0 ] <NEWLINE> self . assertEqual ( u , utf8 . decode ( <STRING> ) ) <NEWLINE> if self . roundtriptest : <NEWLINE> self . assertEqual ( native , self . encode ( u ) [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'utf-8'"]}, "err_obj": {"msg": "expected an indented block"}}], ["4e66cab03cf9bb44d4cad6e6dc763af7", {"code_string": "def do_generate_modified_query_string(parser, token):\n    try:\n        tag_name, key, value = token.split_contents()\n    except ValueError:\n        return GetStringNode()\n    if not(key[0] == key[- 1] and key[0] in('\"', \"'\")):\n        raise template.TemplateSyntaxError, \"%r tag's argument should be in quotes\" % tag_name\n    return GetStringNode(key[1: - 1], value)\n", "code_toks_joined": "def do_generate_modified_query_string ( parser , token ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> tag_name , key , value = token . split_contents ( ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> return GetStringNode ( ) <NEWLINE> <DEDENT> if not ( key [ 0 ] == key [ - 1 ] and key [ 0 ] in ( <STRING> , <STRING> ) ) : <NEWLINE> <INDENT> raise template . TemplateSyntaxError , <STRING> % tag_name <NEWLINE> <DEDENT> return GetStringNode ( key [ 1 : - 1 ] , value ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'\"'", "\"'\"", "\"%r tag's argument should be in quotes\""]}, "err_obj": {"msg": "invalid syntax"}}], ["2fcd049175bf72babc88db87e5bbf477", {"code_string": "def row_to_dict(x):\n    return{\n        'id': x[0],\n        'address': x[1],\n        'amount': x[2],\n        'confirmations': x[3]\n        'received_at': x[4],\n        'expires_at': x[5],\n        'paid': x[6],\n        'processed': x[7]\n    }\n", "code_toks_joined": "def row_to_dict ( x ) : <NEWLINE> <INDENT> return { <NEWLINE> <INDENT> <STRING> : x [ 0 ] , <NEWLINE> <STRING> : x [ 1 ] , <NEWLINE> <STRING> : x [ 2 ] , <NEWLINE> <STRING> : x [ 3 ] <NEWLINE> <STRING> : x [ 4 ] , <NEWLINE> <STRING> : x [ 5 ] , <NEWLINE> <STRING> : x [ 6 ] , <NEWLINE> <STRING> : x [ 7 ] <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'id'", "'address'", "'amount'", "'confirmations'", "'received_at'", "'expires_at'", "'paid'", "'processed'"]}, "err_obj": {"msg": "invalid syntax"}}], ["3a97f2df91356cf8069ffa300988b183", {"code_string": "def _setelement(self, s):\n    s = string.lower(s)\n    try:\n        self.element = PeriodicTable[s]\n    except KeyError, x:\n        print(\"Invalid element:\", x)\n", "code_toks_joined": "def _setelement ( self , s ) : <NEWLINE> <INDENT> s = string . lower ( s ) <NEWLINE> try : <NEWLINE> <INDENT> self . element = PeriodicTable [ s ] <NEWLINE> <DEDENT> except KeyError , x : <NEWLINE> <INDENT> print ( <STRING> , x ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Invalid element:\""]}, "err_obj": {"msg": "invalid syntax"}}], ["7a995b4a021ae4c5d496237d3a1ea3f1", {"code_string": "def log(iterator):\n    for val in iterator:\n        time.sleep(60)\n            print(val)\n", "code_toks_joined": "def log ( iterator ) : <NEWLINE> <INDENT> for val in iterator : <NEWLINE> <INDENT> time . sleep ( 60 ) <NEWLINE> <INDENT> print ( val ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["25c39437ada4b2d432db50dbd1b99308", {"code_string": "def input(self, entry, key):\n    if entry.aux.match(key):\n        self.value = key\n        self.close()\n        return True\n    else:\n        print(_(\"You have provided an invalid username: %s\\n\")\n            \"Do not use spaces or capital letters.\\n\") % key\n        return NormalTUISpoke.input(self, entry, key)\n", "code_toks_joined": "def input ( self , entry , key ) : <NEWLINE> <INDENT> if entry . aux . match ( key ) : <NEWLINE> <INDENT> self . value = key <NEWLINE> self . close ( ) <NEWLINE> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( _ ( <STRING> ) <NEWLINE> <INDENT> <STRING> ) % key <NEWLINE> <DEDENT> return NormalTUISpoke . input ( self , entry , key ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"You have provided an invalid username: %s\\n\"", "\"Do not use spaces or capital letters.\\n\""]}, "err_obj": {"msg": "invalid syntax"}}], ["9adcd60de5dea6059d2e24d306beb99f", {"code_string": "def test_dim_check_fail(arr):\n    from pybind11_tests.array import(index_at, index_at_t, offset_at, offset_at_t, data, data_t,\n        mutate_data, mutate_data_t)\n    for func in(index_at, index_at_t, offset_at, offset_at_t, data, data_t,\n        mutate_data, mutate_data_t):\n        with pytest.raises(IndexError) as excinfo:\n        func(arr, 1, 2, 3)\n        assert str(excinfo.value) == 'too many indices for an array: 3 (ndim = 2)'\n", "code_toks_joined": "def test_dim_check_fail ( arr ) : <NEWLINE> <INDENT> from pybind11_tests . array import ( index_at , index_at_t , offset_at , offset_at_t , data , data_t , <NEWLINE> <INDENT> mutate_data , mutate_data_t ) <NEWLINE> <DEDENT> for func in ( index_at , index_at_t , offset_at , offset_at_t , data , data_t , <NEWLINE> <INDENT> mutate_data , mutate_data_t ) : <NEWLINE> with pytest . raises ( IndexError ) as excinfo : <NEWLINE> func ( arr , 1 , 2 , 3 ) <NEWLINE> assert str ( excinfo . value ) == <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'too many indices for an array: 3 (ndim = 2)'"]}, "err_obj": {"msg": "expected an indented block"}}], ["420c0718105c17e8e16fa4cd4429b607", {"code_string": "def diffuse(Z):\n    Z = Z.reshape(n * n, 2)\n        img = np.zeros((256, 256))\n        for i in xrange(n * n):\n        x, y = Z[i] *(256, 256)\n        img[x, y] += 1\n    return ndi.gaussian_filter(img, (12, 12), mode = 'wrap')\n", "code_toks_joined": "def diffuse ( Z ) : <NEWLINE> <INDENT> Z = Z . reshape ( n * n , 2 ) <NEWLINE> <INDENT> img = np . zeros ( ( 256 , 256 ) ) <NEWLINE> for i in xrange ( n * n ) : <NEWLINE> x , y = Z [ i ] * ( 256 , 256 ) <NEWLINE> img [ x , y ] += 1 <NEWLINE> <DEDENT> return ndi . gaussian_filter ( img , ( 12 , 12 ) , mode = <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'wrap'"]}, "err_obj": {"msg": "unexpected indent"}}], ["b44d010e3801da6c377866f66f520c7f", {"code_string": "def front_x(words):\n    xwords = []\n    for str in words:\n    if str[0] == 'x': xwords.append(str)\n    for str in xwords:\n    words.remove(str)\n    result = sorted(xwords) + sorted(words)\n    return result\n", "code_toks_joined": "def front_x ( words ) : <NEWLINE> <INDENT> xwords = [ ] <NEWLINE> for str in words : <NEWLINE> if str [ 0 ] == <STRING> : xwords . append ( str ) <NEWLINE> for str in xwords : <NEWLINE> words . remove ( str ) <NEWLINE> result = sorted ( xwords ) + sorted ( words ) <NEWLINE> return result <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'x'"]}, "err_obj": {"msg": "expected an indented block"}}], ["03a9261dd7956f9277c80cb3401ed351", {"code_string": "def setup(self):\n    if self.account:\n        self.sid = self.account.getAccountData(self.user).get('SID' None)\n    else:\n        self.sid = None\n    if self.sid:\n        self.premium = True\n    self.resumeDownload = self.multiDL = self.premium\n    self.chunkLimit = 1\n", "code_toks_joined": "def setup ( self ) : <NEWLINE> <INDENT> if self . account : <NEWLINE> <INDENT> self . sid = self . account . getAccountData ( self . user ) . get ( <STRING> None ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . sid = None <NEWLINE> <DEDENT> if self . sid : <NEWLINE> <INDENT> self . premium = True <NEWLINE> <DEDENT> self . resumeDownload = self . multiDL = self . premium <NEWLINE> self . chunkLimit = 1 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'SID'"]}, "err_obj": {"msg": "invalid syntax"}}], ["461d65f3f1ffa5c3188149a1bddf756b", {"code_string": "def clean():\n    shutil.rmtree(\"../build\", ignore_errors = True)\n    shutil.rmtree(\"examples\", ignore_errors = True)\n    for pattern in['scot_examples/api/*.png',\n        'scot_examples/pylab_examples/*.png',\n        'scot_examples/pylab_examples/*.pdf',\n        'scot_examples/units/*.png',\n        'pyplots/tex_demo.png',\n        '_static/matplotlibrc',\n        '_templates/gallery.html',\n        'users/installing.rst']:\n        for filename in glob.glob(pattern):\n        if os.path.exists(filename):\n        os.remove(filename)\n", "code_toks_joined": "def clean ( ) : <NEWLINE> <INDENT> shutil . rmtree ( <STRING> , ignore_errors = True ) <NEWLINE> shutil . rmtree ( <STRING> , ignore_errors = True ) <NEWLINE> for pattern in [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ] : <NEWLINE> for filename in glob . glob ( pattern ) : <NEWLINE> if os . path . exists ( filename ) : <NEWLINE> os . remove ( filename ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"../build\"", "\"examples\"", "'scot_examples/api/*.png'", "'scot_examples/pylab_examples/*.png'", "'scot_examples/pylab_examples/*.pdf'", "'scot_examples/units/*.png'", "'pyplots/tex_demo.png'", "'_static/matplotlibrc'", "'_templates/gallery.html'", "'users/installing.rst'"]}, "err_obj": {"msg": "expected an indented block"}}], ["a5f595666d26e0f5c13b49e1fcd3b130", {"code_string": "def clean(self):\n    print('Bannished.[{}]scrubbed.'.format(self.pidfile)\n    try:\n        os.remove(self.pidfile)\n    except Exception:\n        print('Unable to remove[{}]'.format(self.pidfile))\n", "code_toks_joined": "def clean ( self ) : <NEWLINE> <INDENT> print ( <STRING> . format ( self . pidfile ) <NEWLINE> try : <NEWLINE> <INDENT> os . remove ( self . pidfile ) <NEWLINE> <DEDENT> except Exception : <NEWLINE> <INDENT> print ( <STRING> . format ( self . pidfile ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Bannished.[{}]scrubbed.'", "'Unable to remove[{}]'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["292022de594277e9056b011a47dba51c", {"code_string": "def test_wrong_models_raise_exceptions(self, kind, other):\n    with pytest.raises(ValueError):\n        self.t.sidereal_time(kind, 'greenwich', 'nonsense')\n    for model in(set(SIDEREAL_TIME_MODELS[other].keys()) -\n        set(SIDEREAL_TIME_MODELS[kind].keys())):\n        with pytest.raises(ValueError):\n        self.t.sidereal_time(kind, 'greenwich', model)\n        with pytest.raises(ValueError):\n        self.t.sidereal_time(kind, None, model)\n", "code_toks_joined": "def test_wrong_models_raise_exceptions ( self , kind , other ) : <NEWLINE> <INDENT> with pytest . raises ( ValueError ) : <NEWLINE> <INDENT> self . t . sidereal_time ( kind , <STRING> , <STRING> ) <NEWLINE> <DEDENT> for model in ( set ( SIDEREAL_TIME_MODELS [ other ] . keys ( ) ) - <NEWLINE> <INDENT> set ( SIDEREAL_TIME_MODELS [ kind ] . keys ( ) ) ) : <NEWLINE> with pytest . raises ( ValueError ) : <NEWLINE> self . t . sidereal_time ( kind , <STRING> , model ) <NEWLINE> with pytest . raises ( ValueError ) : <NEWLINE> self . t . sidereal_time ( kind , None , model ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'greenwich'", "'nonsense'", "'greenwich'"]}, "err_obj": {"msg": "expected an indented block"}}], ["d8d91534f960cd90eb1304dd8dfb04e6", {"code_string": "def on_touch_down(self, touch):\n    ret = super(Console, self).on_touch_down(touch)\n    if(('button' not in touch.profile or touch.button == 'left') and\n        not ret and self.inspect_enabled):\n        self.highlight_at(* touch.pos)\n        if touch.is_double_tap:\n        self.inspect_enabled = False\n        ret = True\n    else:\n        ret = self.collide_point(* touch.pos)\n    return ret\n", "code_toks_joined": "def on_touch_down ( self , touch ) : <NEWLINE> <INDENT> ret = super ( Console , self ) . on_touch_down ( touch ) <NEWLINE> if ( ( <STRING> not in touch . profile or touch . button == <STRING> ) and <NEWLINE> <INDENT> not ret and self . inspect_enabled ) : <NEWLINE> self . highlight_at ( * touch . pos ) <NEWLINE> if touch . is_double_tap : <NEWLINE> self . inspect_enabled = False <NEWLINE> ret = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = self . collide_point ( * touch . pos ) <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'button'", "'left'"]}, "err_obj": {"msg": "expected an indented block"}}], ["3606c4a2a229b2d9feff131726a8475f", {"code_string": "class JyEntityResolverWrapper(javasax.EntityResolver):\n    def __init__(self, entityResolver):\n    self._resolver = entityResolver\n    def resolveEntity(self, pubId, sysId):\n    return JyInputSourceWrapper(self._resolver.resolveEntity(pubId, sysId))\n", "code_toks_joined": "class JyEntityResolverWrapper ( javasax . EntityResolver ) : <NEWLINE> <INDENT> def __init__ ( self , entityResolver ) : <NEWLINE> self . _resolver = entityResolver <NEWLINE> def resolveEntity ( self , pubId , sysId ) : <NEWLINE> return JyInputSourceWrapper ( self . _resolver . resolveEntity ( pubId , sysId ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["c282911f7ab07a73e972f21700e419f3", {"code_string": "def test_call_method(self, mock_invoke_ob):\n    with mock.patch.object(self.vm_session,\n        \"_is_vim_object\",\n        return_value = True):\n        self.vm_session._call_method(\"fake_module\",\n            \"get_objects\",\n            \"HostSystem\", ['name'])\n            self.assertTrue(mock_invoke_ob.called)\n", "code_toks_joined": "def test_call_method ( self , mock_invoke_ob ) : <NEWLINE> <INDENT> with mock . patch . object ( self . vm_session , <NEWLINE> <INDENT> <STRING> , <NEWLINE> return_value = True ) : <NEWLINE> self . vm_session . _call_method ( <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , [ <STRING> ] ) <NEWLINE> self . assertTrue ( mock_invoke_ob . called ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"_is_vim_object\"", "\"fake_module\"", "\"get_objects\"", "\"HostSystem\"", "'name'"]}, "err_obj": {"msg": "unexpected indent"}}], ["428f68273f27145935224d310b460f69", {"code_string": "def __setattr__(self, attr, value):\n    if self.__dict__.has_key(attr): self.__dict__[attr] = value; return\n    try:\n        args, defArgs = self._prop_map_put_[attr]\n    except KeyError:\n        raise AttributeError, \"'%s' object has no attribute '%s'\" %(repr(self), attr)\n    self._oleobj_.Invoke(*(args +(value, ) + defArgs))\n", "code_toks_joined": "def __setattr__ ( self , attr , value ) : <NEWLINE> <INDENT> if self . __dict__ . has_key ( attr ) : self . __dict__ [ attr ] = value ; return <NEWLINE> try : <NEWLINE> <INDENT> args , defArgs = self . _prop_map_put_ [ attr ] <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> raise AttributeError , <STRING> % ( repr ( self ) , attr ) <NEWLINE> <DEDENT> self . _oleobj_ . Invoke ( * ( args + ( value , ) + defArgs ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"'%s' object has no attribute '%s'\""]}, "err_obj": {"msg": "invalid syntax"}}], ["a57e72670ede611bb5b695d4a989bc0b", {"code_string": "class sha1:\n    name = \"sha1\"\n    description = \"Applies a sha1 hash to the given string\"\n    category = [\"hashes\"]\n    priority = 99\n    def encode(self, string):\n    s = hashlib.sha1()\n    s.update(string)\n    res = s.hexdigest()\n    return res\n", "code_toks_joined": "class sha1 : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> description = <STRING> <NEWLINE> category = [ <STRING> ] <NEWLINE> priority = 99 <NEWLINE> def encode ( self , string ) : <NEWLINE> s = hashlib . sha1 ( ) <NEWLINE> s . update ( string ) <NEWLINE> res = s . hexdigest ( ) <NEWLINE> return res <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"sha1\"", "\"Applies a sha1 hash to the given string\"", "\"hashes\""]}, "err_obj": {"msg": "expected an indented block"}}], ["60ce027215d1d7cec469e63684f3d89e", {"code_string": "def vxlan_mcast_supported(self):\n    if not cfg.CONF.VXLAN.vxlan_group:\n        LOG.warning(_LW('VXLAN muticast group must be provided in '\n            'vxlan_group option to enable VXLAN MCAST mode'))\n        return False\n    if not ip_lib.iproute_arg_supported(\n        ['ip', 'link', 'add', 'type', 'vxlan'],\n        'proxy'):\n        LOG.warning(_LW('Option \"%(option)s\" must be supported by command '\n            '\"%(command)s\" to enable %(mode)s mode'),\n            {'option': 'proxy',\n            'command': 'ip link add type vxlan',\n            'mode': 'VXLAN MCAST'})\n            return False\n    return True\n", "code_toks_joined": "def vxlan_mcast_supported ( self ) : <NEWLINE> <INDENT> if not cfg . CONF . VXLAN . vxlan_group : <NEWLINE> <INDENT> LOG . warning ( _LW ( <STRING> <NEWLINE> <INDENT> <STRING> ) ) <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> if not ip_lib . iproute_arg_supported ( <NEWLINE> <INDENT> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <NEWLINE> <STRING> ) : <NEWLINE> LOG . warning ( _LW ( <STRING> <NEWLINE> <INDENT> <STRING> ) , <NEWLINE> { <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> } ) <NEWLINE> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'VXLAN muticast group must be provided in '", "'vxlan_group option to enable VXLAN MCAST mode'", "'ip'", "'link'", "'add'", "'type'", "'vxlan'", "'proxy'", "'Option \"%(option)s\" must be supported by command '", "'\"%(command)s\" to enable %(mode)s mode'", "'option'", "'proxy'", "'command'", "'ip link add type vxlan'", "'mode'", "'VXLAN MCAST'"]}, "err_obj": {"msg": "unexpected indent"}}], ["4084d6bd5b9c88997ab089899494db89", {"code_string": "def deleteProfile(self, strId):\n    \"\"\"deleteProfile accepts a customer profile ID\"\"\"\n    if not strId:\n        return 0\n    conn = odbc.odbc(CONNECTION_STRING)\n    cmd = conn.cursor()\n    ok = cmd.execute(\"delete from customer where customerId = '\"\n        + strId + \"'\")):\n    conn.close()\n    return ok and 1 or 0\n", "code_toks_joined": "def deleteProfile ( self , strId ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not strId : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> conn = odbc . odbc ( CONNECTION_STRING ) <NEWLINE> cmd = conn . cursor ( ) <NEWLINE> ok = cmd . execute ( <STRING> <NEWLINE> <INDENT> + strId + <STRING> ) ) : <NEWLINE> <DEDENT> conn . close ( ) <NEWLINE> return ok and 1 or 0 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"deleteProfile accepts a customer profile ID\"\"\"", "\"delete from customer where customerId = '\"", "\"'\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["897ef5e372c567be1a28b45cc0a1c4ef", {"code_string": "def pluralize(count, multiple = 's', single = '')\n    if count == 1:\n        return single\n    return multiple\n", "code_toks_joined": "def pluralize ( count , multiple = <STRING> , single = <STRING> ) <NEWLINE> <INDENT> if count == 1 : <NEWLINE> <INDENT> return single <NEWLINE> <DEDENT> return multiple <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'s'", "''"]}, "err_obj": {"msg": "invalid syntax"}}], ["484c66c1877e7f478a4d7c2f2a3762dd", {"code_string": "def emcLubeOff(self):\n    if debug(): print \"py: emcLubeOff\"\n    self.hal[\"lube\"] = 0\n    self.io.lube.on = 0\n    self.io.status = emctask.RCS_STATUS.RCS_DONE\n    return 0\n", "code_toks_joined": "def emcLubeOff ( self ) : <NEWLINE> <INDENT> if debug ( ) : print <STRING> <NEWLINE> self . hal [ <STRING> ] = 0 <NEWLINE> self . io . lube . on = 0 <NEWLINE> self . io . status = emctask . RCS_STATUS . RCS_DONE <NEWLINE> return 0 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"py: emcLubeOff\"", "\"lube\""]}, "err_obj": {"msg": "invalid syntax"}}], ["60b6c174e48a43b324252419343b6ae8", {"code_string": "class SwaggerPetstoreConfiguration(Configuration):\n    \"\"\"Configuration for SwaggerPetstore\"\"\"\n    def __init__(\n        self, base_url = None, filepath = None):\n        if not base_url:\n        base_url = 'http://petstore.swagger.io/v2'\n        super(SwaggerPetstoreConfiguration, self).__init__(base_url, filepath)\n        self.add_user_agent('swaggerpetstore/{}'.format(VERSION))\n", "code_toks_joined": "class SwaggerPetstoreConfiguration ( Configuration ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( <NEWLINE> <INDENT> self , base_url = None , filepath = None ) : <NEWLINE> if not base_url : <NEWLINE> base_url = <STRING> <NEWLINE> super ( SwaggerPetstoreConfiguration , self ) . __init__ ( base_url , filepath ) <NEWLINE> self . add_user_agent ( <STRING> . format ( VERSION ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Configuration for SwaggerPetstore\"\"\"", "'http://petstore.swagger.io/v2'", "'swaggerpetstore/{}'"]}, "err_obj": {"msg": "expected an indented block"}}], ["fb71b6ccfc6d588388cc5eec44866154", {"code_string": "def get_users_not_anybody():\n    anybody_user_ids = [user.uid for user in anybody.users]\n    query = dbsession.query(User).filter(User.uid.notin_(anybody_user_ids)\n    return query.all()\n", "code_toks_joined": "def get_users_not_anybody ( ) : <NEWLINE> <INDENT> anybody_user_ids = [ user . uid for user in anybody . users ] <NEWLINE> query = dbsession . query ( User ) . filter ( User . uid . notin_ ( anybody_user_ids ) <NEWLINE> return query . all ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["1e867adcfb07e699a7c921e4966052c6", {"code_string": "def move_cb(word, word_eol, userdata):\n    global moved\n    if moved:\n        return\n        for chan in hexchat.get_list(\"channels\"):\n        if chan.type == 1 and chan.id == hexchat.get_prefs(\"id\"):\n            network_context = chan.context\n            moved = True\n            network_context.emit_print(\"Change Nick\", word[0], word[1])\n            moved = False\n            return hexchat.EAT_ALL\n", "code_toks_joined": "def move_cb ( word , word_eol , userdata ) : <NEWLINE> <INDENT> global moved <NEWLINE> if moved : <NEWLINE> <INDENT> return <NEWLINE> for chan in hexchat . get_list ( <STRING> ) : <NEWLINE> if chan . type == 1 and chan . id == hexchat . get_prefs ( <STRING> ) : <NEWLINE> <INDENT> network_context = chan . context <NEWLINE> moved = True <NEWLINE> network_context . emit_print ( <STRING> , word [ 0 ] , word [ 1 ] ) <NEWLINE> moved = False <NEWLINE> return hexchat . EAT_ALL <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"channels\"", "\"id\"", "\"Change Nick\""]}, "err_obj": {"msg": "expected an indented block"}}], ["6f5185e2c85fb72f94cb43323a14a09a", {"code_string": "def toggle(self):\n    if self.__pin.read() == self.__up:\n        self.__pin.write(self.__down)\n        else:\n        self.__pin.write(self.__up)\n", "code_toks_joined": "def toggle ( self ) : <NEWLINE> <INDENT> if self . __pin . read ( ) == self . __up : <NEWLINE> <INDENT> self . __pin . write ( self . __down ) <NEWLINE> else : <NEWLINE> self . __pin . write ( self . __up ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["8e8edd337fc5b7da792c356351f2eb08", {"code_string": "def main():\n    api_url, auth, counter = varsetup()\n    r = requests.get(api_url, auth = auth)\n    my_dict = xmltodict.parse(r.text)\n    my_list = my_dict['list']['device']\n    for l in my_list:\n    print(my_list[counter]['location'])\n    counter = counter + 1\n", "code_toks_joined": "def main ( ) : <NEWLINE> <INDENT> api_url , auth , counter = varsetup ( ) <NEWLINE> r = requests . get ( api_url , auth = auth ) <NEWLINE> my_dict = xmltodict . parse ( r . text ) <NEWLINE> my_list = my_dict [ <STRING> ] [ <STRING> ] <NEWLINE> for l in my_list : <NEWLINE> print ( my_list [ counter ] [ <STRING> ] ) <NEWLINE> counter = counter + 1 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'list'", "'device'", "'location'"]}, "err_obj": {"msg": "expected an indented block"}}], ["20b5c97e269855cfe9adb8114a72baac", {"code_string": "def _fbank(* args, ** kwargs) -> np.ndarray\n    feat, _ = fbank(* args, ** kwargs)\n    return feat\n", "code_toks_joined": "def _fbank ( * args , ** kwargs ) -> np . ndarray <NEWLINE> <INDENT> feat , _ = fbank ( * args , ** kwargs ) <NEWLINE> return feat <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["f2d92d6b0fff7e670215a8aa995ae5d9", {"code_string": "def group_by_user(changes):\n    changes_bydate = {}\n    for date in changes.keys():\n    changes_byuser = {}\n    for logmsg, name, filename in changes[date]:\n        byuser = changes_byuser.get(name, [])\n        byuser.append((filename, logmsg))\n        changes_byuser[name] = byuser\n        changes_bydate[date] = changes_byuser\n    return changes_bydate\n", "code_toks_joined": "def group_by_user ( changes ) : <NEWLINE> <INDENT> changes_bydate = { } <NEWLINE> for date in changes . keys ( ) : <NEWLINE> changes_byuser = { } <NEWLINE> for logmsg , name , filename in changes [ date ] : <NEWLINE> <INDENT> byuser = changes_byuser . get ( name , [ ] ) <NEWLINE> byuser . append ( ( filename , logmsg ) ) <NEWLINE> changes_byuser [ name ] = byuser <NEWLINE> changes_bydate [ date ] = changes_byuser <NEWLINE> <DEDENT> return changes_bydate <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["ca5692a2ff9b072d308adb4957c997c5", {"code_string": "def prepareSend(self, type, size = None, response = 200):\n    try:\n        self.send_response(response)\n    except Exception, e:\n        print(\"Error sending response: %s\" % e)\n        return\n    self.send_header(\"server\", self.server_version)\n    self.send_header(\"Content-Type\", type)\n    if size:\n        self.send_header(\"Content-Length\", size)\n    self.end_headers()\n", "code_toks_joined": "def prepareSend ( self , type , size = None , response = 200 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . send_response ( response ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> print ( <STRING> % e ) <NEWLINE> return <NEWLINE> <DEDENT> self . send_header ( <STRING> , self . server_version ) <NEWLINE> self . send_header ( <STRING> , type ) <NEWLINE> if size : <NEWLINE> <INDENT> self . send_header ( <STRING> , size ) <NEWLINE> <DEDENT> self . end_headers ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Error sending response: %s\"", "\"server\"", "\"Content-Type\"", "\"Content-Length\""]}, "err_obj": {"msg": "invalid syntax"}}], ["be976766a34c5eb6fc7ca7af03566657", {"code_string": "def ordering(first, second):\n    ((name1, obj, logo), priority1) = first\n    ((name2, obj, logo), priority2) = second\n    if priority1 < priority2:\n    return - 1\n    elif priority1 > priority2:\n    return 1\n    if name1 < name2:\n    return - 1\n    elif name1 > name2:\n    return 1\n    return 0\n", "code_toks_joined": "def ordering ( first , second ) : <NEWLINE> <INDENT> ( ( name1 , obj , logo ) , priority1 ) = first <NEWLINE> ( ( name2 , obj , logo ) , priority2 ) = second <NEWLINE> if priority1 < priority2 : <NEWLINE> return - 1 <NEWLINE> elif priority1 > priority2 : <NEWLINE> return 1 <NEWLINE> if name1 < name2 : <NEWLINE> return - 1 <NEWLINE> elif name1 > name2 : <NEWLINE> return 1 <NEWLINE> return 0 <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["5a1a7f91888fc11713ef2fdbd7a81f76", {"code_string": "def _check_path_symbol(cls, module, symname, addr):\n    sym = bcc_symbol()\n    psym = ct.pointer(sym)\n    if lib.bcc_resolve_symname(module.encode(\"ascii\"),\n        symname.encode(\"ascii\"), addr or 0x0, psym) < 0:\n        if not sym.module:\n        raise Exception(\"could not find library %s\" % module)\n        raise Exception(\"could not determine address of symbol %s\" % symname)\n    return sym.module.decode(), sym.offset\n", "code_toks_joined": "def _check_path_symbol ( cls , module , symname , addr ) : <NEWLINE> <INDENT> sym = bcc_symbol ( ) <NEWLINE> psym = ct . pointer ( sym ) <NEWLINE> if lib . bcc_resolve_symname ( module . encode ( <STRING> ) , <NEWLINE> <INDENT> symname . encode ( <STRING> ) , addr or 0x0 , psym ) < 0 : <NEWLINE> if not sym . module : <NEWLINE> raise Exception ( <STRING> % module ) <NEWLINE> raise Exception ( <STRING> % symname ) <NEWLINE> <DEDENT> return sym . module . decode ( ) , sym . offset <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"ascii\"", "\"ascii\"", "\"could not find library %s\"", "\"could not determine address of symbol %s\""]}, "err_obj": {"msg": "expected an indented block"}}], ["00c1b40f93eab7c58c21031c8d6a8dec", {"code_string": "def testPropertyPublicMethodOverlap(self):\n    self._bean.setProperty1(\"val\")\n    self.assertEqual(\"getsetval\", self._bean.getProperty1()\n", "code_toks_joined": "def testPropertyPublicMethodOverlap ( self ) : <NEWLINE> <INDENT> self . _bean . setProperty1 ( <STRING> ) <NEWLINE> self . assertEqual ( <STRING> , self . _bean . getProperty1 ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"val\"", "\"getsetval\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["6138ea33131f9a67516f05d4f8614ce4", {"code_string": "def find_GCD(a, b):\n    while a != b:\n        if a > b:\n        a -= b\n    else:\n        b -= a\n    return a\n", "code_toks_joined": "def find_GCD ( a , b ) : <NEWLINE> <INDENT> while a != b : <NEWLINE> <INDENT> if a > b : <NEWLINE> a -= b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b -= a <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["c30e1583bdaea8dee4cc43b3ddadf35e", {"code_string": "def section_names(self, ordkey = \"wall_time\"):\n    \"\"\"Return the names of sections ordered by ordkey.\"\"\"\n    section_names = []\n    for idx, timer in enumerate(self.timers():\n        if idx == 0:\n            section_names = [s.name for s in timer.order_sections(ordkey)]\n    return section_names\n", "code_toks_joined": "def section_names ( self , ordkey = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> section_names = [ ] <NEWLINE> for idx , timer in enumerate ( self . timers ( ) : <NEWLINE> <INDENT> if idx == 0 : <NEWLINE> <INDENT> section_names = [ s . name for s in timer . order_sections ( ordkey ) ] <NEWLINE> <DEDENT> <DEDENT> return section_names <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"wall_time\"", "\"\"\"Return the names of sections ordered by ordkey.\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["b86b9f1780f46d1400575997fd9242b5", {"code_string": "def test_list_configs_nojobs(self):\n    mock_context = FakeAuroraCommandContext()\n    with patch('apache.aurora.client.cli.config.ConfigNoun.create_context',\n        return_value = mock_context):\n        with temporary_file() as fp:\n        fp.write(self.get_config_with_no_jobs())\n        fp.flush()\n        cmd = AuroraCommandLine()\n        cmd.execute(['config', 'list', fp.name])\n        assert mock_context.out ==[\"jobs=[]\"]\n        assert mock_context.err ==[]\n", "code_toks_joined": "def test_list_configs_nojobs ( self ) : <NEWLINE> <INDENT> mock_context = FakeAuroraCommandContext ( ) <NEWLINE> with patch ( <STRING> , <NEWLINE> <INDENT> return_value = mock_context ) : <NEWLINE> with temporary_file ( ) as fp : <NEWLINE> fp . write ( self . get_config_with_no_jobs ( ) ) <NEWLINE> fp . flush ( ) <NEWLINE> cmd = AuroraCommandLine ( ) <NEWLINE> cmd . execute ( [ <STRING> , <STRING> , fp . name ] ) <NEWLINE> assert mock_context . out == [ <STRING> ] <NEWLINE> assert mock_context . err == [ ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'apache.aurora.client.cli.config.ConfigNoun.create_context'", "'config'", "'list'", "\"jobs=[]\""]}, "err_obj": {"msg": "expected an indented block"}}], ["e5d19815348bef29ba7d0df705d70ee9", {"code_string": "def _on_begin_drag(self evt):\n    tree_item_id = evt.GetItem()\n    fs_node = self._get_fs_node_by_tree_item_id(tree_item_id)\n    self.node_tool.begin_drag([fs_node], self)\n", "code_toks_joined": "def _on_begin_drag ( self evt ) : <NEWLINE> <INDENT> tree_item_id = evt . GetItem ( ) <NEWLINE> fs_node = self . _get_fs_node_by_tree_item_id ( tree_item_id ) <NEWLINE> self . node_tool . begin_drag ( [ fs_node ] , self ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["df8fdd8d8f1529c37e7c5743b5175db6", {"code_string": "def format_num(self, val, width = 8):\n    val = \"%X\" % val\n        val = val.zfill(width)\n    return val\n", "code_toks_joined": "def format_num ( self , val , width = 8 ) : <NEWLINE> <INDENT> val = <STRING> % val <NEWLINE> <INDENT> val = val . zfill ( width ) <NEWLINE> <DEDENT> return val <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"%X\""]}, "err_obj": {"msg": "unexpected indent"}}], ["483bfff1c2bc4b27aae24fa6dc925c6b", {"code_string": "def run_one_push(self):\n    s = self.quotify(self.val)\n    buf = cStringIO.StringIO()\n    c = pycurl.Curl()\n    url = self.getURL(s)\n    c.setopt(c.URL, url)\n    c.setopt(pycurl.USERAGENT, \"Lynx\")\n    c.setopt(pycurl.WRITEFUNCTION, buf.write)\n    try:\n        res = c.perform()\n    except:\n        if not self.expect_fail():\n        print(\"Push failed\", url)\n", "code_toks_joined": "def run_one_push ( self ) : <NEWLINE> <INDENT> s = self . quotify ( self . val ) <NEWLINE> buf = cStringIO . StringIO ( ) <NEWLINE> c = pycurl . Curl ( ) <NEWLINE> url = self . getURL ( s ) <NEWLINE> c . setopt ( c . URL , url ) <NEWLINE> c . setopt ( pycurl . USERAGENT , <STRING> ) <NEWLINE> c . setopt ( pycurl . WRITEFUNCTION , buf . write ) <NEWLINE> try : <NEWLINE> <INDENT> res = c . perform ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> if not self . expect_fail ( ) : <NEWLINE> print ( <STRING> , url ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Lynx\"", "\"Push failed\""]}, "err_obj": {"msg": "expected an indented block"}}], ["1d83d12944c757dcea238f3f6f61e3ff", {"code_string": "def article_delete(request):\n    if C.checkLoginAdmin(request.session.get('uInfo', False)) == False:\n        return HttpResponseRedirect('/signin/')\n    else:\n    idList = request.REQUEST.getlist('idlist')\n    if len(idList) > 0:\n        Article.objects.filter(article_id__in = idList).delete()\n        Relation.objects.filter(aid__in = idList).delete()\n        return HttpResponse('delete success')\n    return HttpResponse('delete faild')\n", "code_toks_joined": "def article_delete ( request ) : <NEWLINE> <INDENT> if C . checkLoginAdmin ( request . session . get ( <STRING> , False ) ) == False : <NEWLINE> <INDENT> return HttpResponseRedirect ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> idList = request . REQUEST . getlist ( <STRING> ) <NEWLINE> if len ( idList ) > 0 : <NEWLINE> <INDENT> Article . objects . filter ( article_id__in = idList ) . delete ( ) <NEWLINE> Relation . objects . filter ( aid__in = idList ) . delete ( ) <NEWLINE> return HttpResponse ( <STRING> ) <NEWLINE> <DEDENT> return HttpResponse ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'uInfo'", "'/signin/'", "'idlist'", "'delete success'", "'delete faild'"]}, "err_obj": {"msg": "expected an indented block"}}], ["cf3c2a613cd9723e70f9ea0b424fb14c", {"code_string": "def commit_id(self, commit):\n    if not commit:\n        commit = \"HEAD\"\n            cmt_id = None\n            try:\n        cmt_id = check_output(\"git rev-parse {0}\".format(commit), shell = True)\n        if cmt_id:\n        cmt_id = cmt_id.strip()\n        commit_type = self.git_object_type(commit)\n        if \"commit\" != commit_type:\n        sys.exit(\"{0} is a {1}. The value of the --commit option must refer to commit\".format(commit, commit_type))\n            except(CalledProcessError, OSError) as e:\n        sys.exit(\"Error: Cannot find revision {0}\".format(commit))\n    return cmt_id\n", "code_toks_joined": "def commit_id ( self , commit ) : <NEWLINE> <INDENT> if not commit : <NEWLINE> <INDENT> commit = <STRING> <NEWLINE> <INDENT> cmt_id = None <NEWLINE> try : <NEWLINE> <DEDENT> cmt_id = check_output ( <STRING> . format ( commit ) , shell = True ) <NEWLINE> if cmt_id : <NEWLINE> cmt_id = cmt_id . strip ( ) <NEWLINE> commit_type = self . git_object_type ( commit ) <NEWLINE> if <STRING> != commit_type : <NEWLINE> sys . exit ( <STRING> . format ( commit , commit_type ) ) <NEWLINE> <INDENT> except ( CalledProcessError , OSError ) as e : <NEWLINE> <DEDENT> sys . exit ( <STRING> . format ( commit ) ) <NEWLINE> <DEDENT> return cmt_id <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"HEAD\"", "\"git rev-parse {0}\"", "\"commit\"", "\"{0} is a {1}. The value of the --commit option must refer to commit\"", "\"Error: Cannot find revision {0}\""]}, "err_obj": {"msg": "unexpected indent"}}], ["e46a7a05ca387566870c80f06236194d", {"code_string": "def create_video_url(self):\n    \"\"\"Create our VideoUrl object.\"\"\"\n    try:\n        self.video_url = self.cleaned_data['video'].add_url(\n            self.cleaned_data['url'],\n            self.user)\n    except Video.UrlAlreadyAdded, e:\n        raise forms.ValidationError(self.already_added_message(e.video))\n", "code_toks_joined": "def create_video_url ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> self . video_url = self . cleaned_data [ <STRING> ] . add_url ( <NEWLINE> <INDENT> self . cleaned_data [ <STRING> ] , <NEWLINE> self . user ) <NEWLINE> <DEDENT> <DEDENT> except Video . UrlAlreadyAdded , e : <NEWLINE> <INDENT> raise forms . ValidationError ( self . already_added_message ( e . video ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Create our VideoUrl object.\"\"\"", "'video'", "'url'"]}, "err_obj": {"msg": "invalid syntax"}}], ["6c5ac9395991f763efe0fdfaf96a09b5", {"code_string": "def test_invalid_mixing_encrypt_decrypt(self):\n    for method1_name, method2_name in((\"encrypt\", \"decrypt\"),\n        (\"decrypt\", \"encrypt\")):\n        for assoc_data_present in(True, False):\n        cipher = AES.new(self.key_128, AES.MODE_CCM,\n        nonce = self.nonce_96,\n        msg_len = 32)\n        if assoc_data_present:\n        cipher.update(self.data_128)\n        getattr(cipher, method1_name)(self.data_128)\n        self.assertRaises(TypeError, getattr(cipher, method2_name),\n        self.data_128)\n", "code_toks_joined": "def test_invalid_mixing_encrypt_decrypt ( self ) : <NEWLINE> <INDENT> for method1_name , method2_name in ( ( <STRING> , <STRING> ) , <NEWLINE> <INDENT> ( <STRING> , <STRING> ) ) : <NEWLINE> for assoc_data_present in ( True , False ) : <NEWLINE> cipher = AES . new ( self . key_128 , AES . MODE_CCM , <NEWLINE> nonce = self . nonce_96 , <NEWLINE> msg_len = 32 ) <NEWLINE> if assoc_data_present : <NEWLINE> cipher . update ( self . data_128 ) <NEWLINE> getattr ( cipher , method1_name ) ( self . data_128 ) <NEWLINE> self . assertRaises ( TypeError , getattr ( cipher , method2_name ) , <NEWLINE> self . data_128 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"encrypt\"", "\"decrypt\"", "\"decrypt\"", "\"encrypt\""]}, "err_obj": {"msg": "expected an indented block"}}], ["3105b920cc6b2bbb48c69b0f192a538a", {"code_string": "def test_get_vhd_format_zero_length_file(self):\n    with mock.patch('nova.virt.hyperv.vhdutils.open',\n        mock.mock_open(read_data = ''),\n        create = True) as mock_open:\n        f = mock_open.return_value\n        f.tell.return_value = 0\n        self.assertRaises(vmutils.HyperVException,\n            self._vhdutils.get_vhd_format,\n            self._FAKE_VHD_PATH)\n            f.seek.assert_called_once_with(0, 2)\n", "code_toks_joined": "def test_get_vhd_format_zero_length_file ( self ) : <NEWLINE> <INDENT> with mock . patch ( <STRING> , <NEWLINE> <INDENT> mock . mock_open ( read_data = <STRING> ) , <NEWLINE> create = True ) as mock_open : <NEWLINE> f = mock_open . return_value <NEWLINE> f . tell . return_value = 0 <NEWLINE> self . assertRaises ( vmutils . HyperVException , <NEWLINE> <INDENT> self . _vhdutils . get_vhd_format , <NEWLINE> self . _FAKE_VHD_PATH ) <NEWLINE> f . seek . assert_called_once_with ( 0 , 2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'nova.virt.hyperv.vhdutils.open'", "''"]}, "err_obj": {"msg": "unexpected indent"}}], ["399f253d64a829d80499235b3d1b421b", {"code_string": "def retranslateUi(self, CiteDialog):\n    _translate = QtCore.QCoreApplication.translate\n    CiteDialog.setWindowTitle(_translate(\"CiteDialog\", \"How to cite \u2013 Coquery\"))\n    self.label.setText(_translate(\"CiteDialog\", \"&Unified Stylesheet\"))\n    self.edit_unified.setHtml(_translate(\"CiteDialog\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , CiteDialog ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> CiteDialog . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . label . setText ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . edit_unified . setHtml ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"CiteDialog\"", "\"How to cite \u2013 Coquery\"", "\"CiteDialog\"", "\"&Unified Stylesheet\"", "\"CiteDialog\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c65825bb3fd89061b9b06d19db6294ea", {"code_string": "def test_file_display(self):\n    for handler in(self.dialog.idle_credits,\n        self.dialog.idle_readme,\n        self.dialog.idle_news):\n        self.error.message = ''\n        self.view.called = False\n        with self.subTest(handler = handler):\n        handler()\n        self.assertEqual(self.error.message, '')\n        self.assertEqual(self.view.called, True)\n", "code_toks_joined": "def test_file_display ( self ) : <NEWLINE> <INDENT> for handler in ( self . dialog . idle_credits , <NEWLINE> <INDENT> self . dialog . idle_readme , <NEWLINE> self . dialog . idle_news ) : <NEWLINE> self . error . message = <STRING> <NEWLINE> self . view . called = False <NEWLINE> with self . subTest ( handler = handler ) : <NEWLINE> handler ( ) <NEWLINE> self . assertEqual ( self . error . message , <STRING> ) <NEWLINE> self . assertEqual ( self . view . called , True ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "''"]}, "err_obj": {"msg": "expected an indented block"}}], ["9c74e8e9e2964b49029890d8825331cc", {"code_string": "def _set_cookies(self, payload, response):\n    cookies = []\n    for cookie in[x.split(';', 1)[0]\n        for x in response.headers.getlist('Set-Cookie')]:\n        if cookie not in self.cookies_seen:\n        self.cookies_seen.add(cookie)\n        cookies.append(cookie)\n    if cookies:\n        payload[\"cookies\"] = cookies\n", "code_toks_joined": "def _set_cookies ( self , payload , response ) : <NEWLINE> <INDENT> cookies = [ ] <NEWLINE> for cookie in [ x . split ( <STRING> , 1 ) [ 0 ] <NEWLINE> <INDENT> for x in response . headers . getlist ( <STRING> ) ] : <NEWLINE> if cookie not in self . cookies_seen : <NEWLINE> self . cookies_seen . add ( cookie ) <NEWLINE> cookies . append ( cookie ) <NEWLINE> <DEDENT> if cookies : <NEWLINE> <INDENT> payload [ <STRING> ] = cookies <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["';'", "'Set-Cookie'", "\"cookies\""]}, "err_obj": {"msg": "expected an indented block"}}], ["63fbf3a238208cbc30b1081a0c2e3c00", {"code_string": "def extract_column(t, names):\n    \"\"\"Return a list of columns from a table\"\"\"\n    lst = []\n    for i in names:\n        lst.append(np.array(t[i])\n    return lst\n", "code_toks_joined": "def extract_column ( t , names ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> lst = [ ] <NEWLINE> for i in names : <NEWLINE> <INDENT> lst . append ( np . array ( t [ i ] ) <NEWLINE> <DEDENT> return lst <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return a list of columns from a table\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["8520d3a746019b209e2838a7172b609a", {"code_string": "def get_dhcp_leases(context, network_ref):\n    \"\"\"Return a network's hosts config in dnsmasq leasefile format.\"\"\"\n    hosts = []\n    for fixed_ref in db.network_get_associated_fixed_ips(context,\n        network_ref['id']):\n        host = fixed_ref['instance']['host']\n        if network_ref['multi_host'] and FLAGS.host != host:\n        continue\n        hosts.append(_host_lease(fixed_ref))\n    return '\\n'.join(hosts)\n", "code_toks_joined": "def get_dhcp_leases ( context , network_ref ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> hosts = [ ] <NEWLINE> for fixed_ref in db . network_get_associated_fixed_ips ( context , <NEWLINE> <INDENT> network_ref [ <STRING> ] ) : <NEWLINE> host = fixed_ref [ <STRING> ] [ <STRING> ] <NEWLINE> if network_ref [ <STRING> ] and FLAGS . host != host : <NEWLINE> continue <NEWLINE> hosts . append ( _host_lease ( fixed_ref ) ) <NEWLINE> <DEDENT> return <STRING> . join ( hosts ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return a network's hosts config in dnsmasq leasefile format.\"\"\"", "'id'", "'instance'", "'host'", "'multi_host'", "'\\n'"]}, "err_obj": {"msg": "expected an indented block"}}], ["3e9b2afc11bd78e7a8ac92c4a820ca1a", {"code_string": "def dyld_find(name, executable_path = None, env = None, loader_path = None):\n    \"\"\"Find a library or framework using dyld semantics\"\"\"\n    name = _ensure_utf8(name)\n    executable_path = _ensure_utf8(executable_path)\n    for path in dyld_image_suffix_search(chain(\n        dyld_override_search(name, env),\n        dyld_executable_path_search(name, executable_path),\n        dyld_loader_search(name, loader_path),\n        dyld_default_search(name, env),\n        ), env):\n        if os.path.isfile(path):\n        return path\n    raise ValueError(\"dylib %s could not be found\" %(name, ))\n", "code_toks_joined": "def dyld_find ( name , executable_path = None , env = None , loader_path = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> name = _ensure_utf8 ( name ) <NEWLINE> executable_path = _ensure_utf8 ( executable_path ) <NEWLINE> for path in dyld_image_suffix_search ( chain ( <NEWLINE> <INDENT> dyld_override_search ( name , env ) , <NEWLINE> dyld_executable_path_search ( name , executable_path ) , <NEWLINE> dyld_loader_search ( name , loader_path ) , <NEWLINE> dyld_default_search ( name , env ) , <NEWLINE> ) , env ) : <NEWLINE> if os . path . isfile ( path ) : <NEWLINE> return path <NEWLINE> <DEDENT> raise ValueError ( <STRING> % ( name , ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Find a library or framework using dyld semantics\"\"\"", "\"dylib %s could not be found\""]}, "err_obj": {"msg": "expected an indented block"}}], ["3d94d63e3e01f4371993fe5383ee2d93", {"code_string": "def update_item(self, key, view):\n    self.lock.acquire()\n    try:\n        try:\n            i = self.keys.index(key)\n        except ValueError:\n            raise ListBufferError, \"Item not found\"\n        view = self.clean_item(view)\n        self.items[i] = view\n        self.activity(1)\n        self.display(i)\n    finally:\n        self.lock.release()\n", "code_toks_joined": "def update_item ( self , key , view ) : <NEWLINE> <INDENT> self . lock . acquire ( ) <NEWLINE> try : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> i = self . keys . index ( key ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> raise ListBufferError , <STRING> <NEWLINE> <DEDENT> view = self . clean_item ( view ) <NEWLINE> self . items [ i ] = view <NEWLINE> self . activity ( 1 ) <NEWLINE> self . display ( i ) <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> self . lock . release ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Item not found\""]}, "err_obj": {"msg": "invalid syntax"}}], ["ae6b3f637865fbeb8e10208de1a1454f", {"code_string": "def _ensure_list(self, value, field):\n    if(not isinstance(value, collections.Sequence)\n        or isinstance(value, six.string_types)):\n        warn(('In object \"{id}\": Field \"{field}\" of type \"{type}\" must '\n            + 'contain a list, but a non-list value was found '\n            + 'instead.').format(id = self._data['id'], field = field,\n            type = self._data['type']), SpecificationWarning)\n            value = [value]\n    return value\n", "code_toks_joined": "def _ensure_list ( self , value , field ) : <NEWLINE> <INDENT> if ( not isinstance ( value , collections . Sequence ) <NEWLINE> <INDENT> or isinstance ( value , six . string_types ) ) : <NEWLINE> warn ( ( <STRING> <NEWLINE> <INDENT> + <STRING> <NEWLINE> + <STRING> ) . format ( id = self . _data [ <STRING> ] , field = field , <NEWLINE> type = self . _data [ <STRING> ] ) , SpecificationWarning ) <NEWLINE> value = [ value ] <NEWLINE> <DEDENT> <DEDENT> return value <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'In object \"{id}\": Field \"{field}\" of type \"{type}\" must '", "'contain a list, but a non-list value was found '", "'instead.'", "'id'", "'type'"]}, "err_obj": {"msg": "unexpected indent"}}], ["7cde69d3e73ac818726cb80ddf38ea9a", {"code_string": "def data2ni_form(data, form):\n    if(type(data) is np.ndarray and\n        (numpy_data_isint(data) or numpy_data_isfloat(data))):\n        byteorder = data.dtype.byteorder\n        if not form in['binary', 'base64']:\n        raise ValueError('illegal form %s' % form)\n        if byteorder == '=':\n        byteorder = '<' if sys.byteorder == 'little' else '>'\n        if byteorder in '<>':\n        return '%s.%s' %(form, 'lsbfirst' if byteorder == '<' else 'msbfirst')\n        else:\n        raise ValueError(\"Unrecognized byte order %s\" % byteorder)\n    return None\n", "code_toks_joined": "def data2ni_form ( data , form ) : <NEWLINE> <INDENT> if ( type ( data ) is np . ndarray and <NEWLINE> <INDENT> ( numpy_data_isint ( data ) or numpy_data_isfloat ( data ) ) ) : <NEWLINE> byteorder = data . dtype . byteorder <NEWLINE> if not form in [ <STRING> , <STRING> ] : <NEWLINE> raise ValueError ( <STRING> % form ) <NEWLINE> if byteorder == <STRING> : <NEWLINE> byteorder = <STRING> if sys . byteorder == <STRING> else <STRING> <NEWLINE> if byteorder in <STRING> : <NEWLINE> return <STRING> % ( form , <STRING> if byteorder == <STRING> else <STRING> ) <NEWLINE> else : <NEWLINE> raise ValueError ( <STRING> % byteorder ) <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'binary'", "'base64'", "'illegal form %s'", "'='", "'<'", "'little'", "'>'", "'<>'", "'%s.%s'", "'lsbfirst'", "'<'", "'msbfirst'", "\"Unrecognized byte order %s\""]}, "err_obj": {"msg": "expected an indented block"}}], ["b8adab5d3c3857a604bdd4cac42ed1cf", {"code_string": "'''*  JsonRpc-Cpp - JSON-RPC implementation.'''\n'''** file jsonrpc_udpclient.h'''\nnamespace Json\n    namespace Rpc\n        '''** class UdpClient'''\n        class UdpClient: public Client\n            public:\n                '''** brief Constructor.'''\n                UdpClient(std.string & address, port)\n                '''** brief Destructor.'''\n                virtual ~ UdpClient()\n                '''** brief Receive data from the network.'''\n                virtual ssize_t Recv(std.string & data)\n                '''** brief Send data.'''\n                ssize_t Send(std.string & data)\n    } ''' namespace Rpc '''\n} ''' namespace Json '''\n", "code_toks_joined": "<STRING> <NEWLINE> <STRING> <NEWLINE> namespace Json <NEWLINE> <INDENT> namespace Rpc <NEWLINE> <INDENT> <STRING> <NEWLINE> class UdpClient : public Client <NEWLINE> <INDENT> public : <NEWLINE> <INDENT> <STRING> <NEWLINE> UdpClient ( std . string & address , port ) <NEWLINE> <STRING> <NEWLINE> virtual ~ UdpClient ( ) <NEWLINE> <STRING> <NEWLINE> virtual ssize_t Recv ( std . string & data ) <NEWLINE> <STRING> <NEWLINE> ssize_t Send ( std . string & data ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> } <STRING> <NEWLINE> <DEDENT> } <STRING> <NEWLINE>", "anonymize_dict": {"<STRING>": ["'''*  JsonRpc-Cpp - JSON-RPC implementation.'''", "'''** file jsonrpc_udpclient.h'''", "'''** class UdpClient'''", "'''** brief Constructor.'''", "'''** brief Destructor.'''", "'''** brief Receive data from the network.'''", "'''** brief Send data.'''", "''' namespace Rpc '''", "''' namespace Json '''"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["5e551480b1e42374ff3867ae208a286b", {"code_string": "from pygame import *\ninit()\ndisplay.init()\nj = joystick.Joystick(0)\nj.init()\nif j.get_init() == 1:\n    print \"Joystick is initialized\"\nwhile 1:\n    for e in event.get():\n        if e.type != QUIT:\n            print('%s: %s' %(event.event_name(e.type), e.dict))\n", "code_toks_joined": "from pygame import * <NEWLINE> init ( ) <NEWLINE> display . init ( ) <NEWLINE> j = joystick . Joystick ( 0 ) <NEWLINE> j . init ( ) <NEWLINE> if j . get_init ( ) == 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> while 1 : <NEWLINE> <INDENT> for e in event . get ( ) : <NEWLINE> <INDENT> if e . type != QUIT : <NEWLINE> <INDENT> print ( <STRING> % ( event . event_name ( e . type ) , e . dict ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Joystick is initialized\"", "'%s: %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["dd0e0010c69d004fb2002719f51901da", {"code_string": "def test_treat_devices_removed_returns_true_for_missing_device(self):\n    with mock.patch.object(self.agent.plugin_rpc, 'update_device_down'\n        side_effect = Exception()):\n        self.assertTrue(self.agent.treat_devices_removed([{}]))\n", "code_toks_joined": "def test_treat_devices_removed_returns_true_for_missing_device ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( self . agent . plugin_rpc , <STRING> <NEWLINE> <INDENT> side_effect = Exception ( ) ) : <NEWLINE> self . assertTrue ( self . agent . treat_devices_removed ( [ { } ] ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'update_device_down'"]}, "err_obj": {"msg": "invalid syntax"}}], ["f5eed42960694f961a8c0b5932da6cf7", {"code_string": "class CountWords(beam.PTransform):\n    \"\"\"A transform to count the occurrences of each word.\"\"\"\n    def expand(self, pcoll):\n        return(pcoll\n            | 'pair_with_one' >> beam.Map(lambda x: (x, 1))\n            | 'group' >> beam.GroupByKey()\n            | 'count' >> beam.Map(lambda(word, ones): (word, sum(ones)))\n            | 'format' >> beam.Map(lambda(word, c): '%s: %s' %(word, c)))\n", "code_toks_joined": "class CountWords ( beam . PTransform ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def expand ( self , pcoll ) : <NEWLINE> <INDENT> return ( pcoll <NEWLINE> <INDENT> | <STRING> >> beam . Map ( lambda x : ( x , 1 ) ) <NEWLINE> | <STRING> >> beam . GroupByKey ( ) <NEWLINE> | <STRING> >> beam . Map ( lambda ( word , ones ) : ( word , sum ( ones ) ) ) <NEWLINE> | <STRING> >> beam . Map ( lambda ( word , c ) : <STRING> % ( word , c ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"A transform to count the occurrences of each word.\"\"\"", "'pair_with_one'", "'group'", "'count'", "'format'", "'%s: %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["e0ea0c35a0b1eb788e1b416811334d67", {"code_string": "def __init__(self, listenIP, listenPort):\n    setUp()\n    UDP_IP = listenIP\n    UDP_PORT = listenPort\n    INsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    INsock.bind((UDP_IP, UDP_PORT)))\n    OUTsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    print(\"1\")\n", "code_toks_joined": "def __init__ ( self , listenIP , listenPort ) : <NEWLINE> <INDENT> setUp ( ) <NEWLINE> UDP_IP = listenIP <NEWLINE> UDP_PORT = listenPort <NEWLINE> INsock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) <NEWLINE> INsock . bind ( ( UDP_IP , UDP_PORT ) ) ) <NEWLINE> OUTsock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"1\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["0c6268ce33c52e2f922adbf2d9aa448f", {"code_string": "def testFailedUnaryRequestStreamResponse(self):\n    for(group, method), test_messages_sequence in(\n        six.iteritems(self._digest.unary_stream_messages_sequences)):\n        for test_messages in test_messages_sequence:\n        request = test_messages.request()\n        with self._control.fail(), self.assertRaises(face.ExpirationError):\n            response_iterator = self._invoker.future(group, method)(\n                request, _3069_test_constant.REALLY_SHORT_TIMEOUT)\n            list(response_iterator)\n", "code_toks_joined": "def testFailedUnaryRequestStreamResponse ( self ) : <NEWLINE> <INDENT> for ( group , method ) , test_messages_sequence in ( <NEWLINE> <INDENT> six . iteritems ( self . _digest . unary_stream_messages_sequences ) ) : <NEWLINE> for test_messages in test_messages_sequence : <NEWLINE> request = test_messages . request ( ) <NEWLINE> with self . _control . fail ( ) , self . assertRaises ( face . ExpirationError ) : <NEWLINE> <INDENT> response_iterator = self . _invoker . future ( group , method ) ( <NEWLINE> <INDENT> request , _3069_test_constant . REALLY_SHORT_TIMEOUT ) <NEWLINE> <DEDENT> list ( response_iterator ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["70f894d0e1d247280ddec67ea1a4bc06", {"code_string": "class RemoveSlashMiddleware(object):\n    \"\"\"Middleware that tries to remove a trailing slash if there was a 404.\"\"\"\n    def process_response(self, request, response):\n        if(response.status_code == 404 and\n            request.path_info.endswith('/') and\n            not is_valid_path(request.path_info) and\n            is_valid_path(request.path_info[: - 1])):\n            newurl = request.path[: - 1]\n            if request.GET:\n            with safe_query_string(request):\n                newurl += '?' + request.META['QUERY_STRING']\n                return HttpResponsePermanentRedirect(newurl)\n        return response\n", "code_toks_joined": "class RemoveSlashMiddleware ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def process_response ( self , request , response ) : <NEWLINE> <INDENT> if ( response . status_code == 404 and <NEWLINE> <INDENT> request . path_info . endswith ( <STRING> ) and <NEWLINE> not is_valid_path ( request . path_info ) and <NEWLINE> is_valid_path ( request . path_info [ : - 1 ] ) ) : <NEWLINE> newurl = request . path [ : - 1 ] <NEWLINE> if request . GET : <NEWLINE> with safe_query_string ( request ) : <NEWLINE> <INDENT> newurl += <STRING> + request . META [ <STRING> ] <NEWLINE> return HttpResponsePermanentRedirect ( newurl ) <NEWLINE> <DEDENT> <DEDENT> return response <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Middleware that tries to remove a trailing slash if there was a 404.\"\"\"", "'/'", "'?'", "'QUERY_STRING'"]}, "err_obj": {"msg": "expected an indented block"}}], ["ef3765921c89ff18df5109d6cb90c517", {"code_string": "def extract_credentials(self, request):\n    if request.META.get('HTTP_AUTHORIZATION', '').lower().startswith(\n        'key '):\n        (auth_type, secret_key) = (\n        request.META['HTTP_AUTHORIZATION'].split())\n        if auth_type.lower() != 'key':\n        raise ValueError(\"Incorrect authorization header.\")\n    else:\n        secret_key = request.GET.get('key') or request.POST.get('key')\n    return secret_key\n", "code_toks_joined": "def extract_credentials ( self , request ) : <NEWLINE> <INDENT> if request . META . get ( <STRING> , <STRING> ) . lower ( ) . startswith ( <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> ( auth_type , secret_key ) = ( <NEWLINE> request . META [ <STRING> ] . split ( ) ) <NEWLINE> if auth_type . lower ( ) != <STRING> : <NEWLINE> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> secret_key = request . GET . get ( <STRING> ) or request . POST . get ( <STRING> ) <NEWLINE> <DEDENT> return secret_key <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'HTTP_AUTHORIZATION'", "''", "'key '", "'HTTP_AUTHORIZATION'", "'key'", "\"Incorrect authorization header.\"", "'key'", "'key'"]}, "err_obj": {"msg": "expected an indented block"}}], ["299312ea70d1aa812738f320694224e5", {"code_string": "def retranslateUi(self, cadastre_load_form):\n    cadastre_load_form.setWindowTitle(_translate(\"cadastre_load_form\", \"Cadastre\", None))\n    self.groupBox.setTitle(_translate(\"cadastre_load_form\", \"Base de donn\u00e9es de travail\", None))\n    self.label_2.setText(_translate(\"cadastre_load_form\", \"Connexions\", None))\n    self.label_3.setText(_translate(\"cadastre_load_form\", \"Sch\u00e9ma\", None))\n    self.label.setText(_translate(\"cadastre_load_form\", \"Type de base\", None))\n    self.liDbType.setItemText(0, _translate(\"cadastre_load_form\", \"-- Choisir --\", None))\n    self.liDbType.setItemText(1, _translate(\"cadastre_load_form\", \"Postgis\", None))\n    self.liDbType.setItemText(2, _translate(\"cadastre_load_form\", \"Spatialite\", None))\n    self.groupBox_5.setTitle(_translate(\"cadastre_load_form\", \"Styles \u00e0 appliquer\", None))\n    self.label_12.setText(_translate(\"cadastre_load_form\", \"Th\u00e8me\", None))\n    self.liTheme.setItemText(0, _translate(\"cadastre_load_form\", \"classique\", None))\n    self.btProcessLoading.setText(_translate(\"cadastre_load_form\", \"Charger les donn\u00e9es\", None))\n    self.txtLog.setHtml(_translate(\"cadastre_load_form\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , cadastre_load_form ) : <NEWLINE> <INDENT> cadastre_load_form . setWindowTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . groupBox . setTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_2 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_3 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . liDbType . setItemText ( 0 , _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . liDbType . setItemText ( 1 , _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . liDbType . setItemText ( 2 , _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . groupBox_5 . setTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_12 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . liTheme . setItemText ( 0 , _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . btProcessLoading . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . txtLog . setHtml ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"cadastre_load_form\"", "\"Cadastre\"", "\"cadastre_load_form\"", "\"Base de donn\u00e9es de travail\"", "\"cadastre_load_form\"", "\"Connexions\"", "\"cadastre_load_form\"", "\"Sch\u00e9ma\"", "\"cadastre_load_form\"", "\"Type de base\"", "\"cadastre_load_form\"", "\"-- Choisir --\"", "\"cadastre_load_form\"", "\"Postgis\"", "\"cadastre_load_form\"", "\"Spatialite\"", "\"cadastre_load_form\"", "\"Styles \u00e0 appliquer\"", "\"cadastre_load_form\"", "\"Th\u00e8me\"", "\"cadastre_load_form\"", "\"classique\"", "\"cadastre_load_form\"", "\"Charger les donn\u00e9es\"", "\"cadastre_load_form\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "window_span": [213, 221], "err_obj": {"msg": "unbalanced (){}[]"}}], ["fb385f89a0127d5a4039e8e58d115398", {"code_string": "def purgeRecursive(self, path):\n    \"\"\"Returns void\"\"\"\n    try:\n        _lock.writeLock().lock()\n        parentPath = File(path).getParent()\n        name = File(path).getName()\n        removeFromParentChildSet(parentPath, name)\n        znode = _cache.remove(path)\n        if znode != None:\n            childNames = znode.getChildSet()\n            for\n            childName = None\n                in childNames)\n                    childPath = path + \"/\" + childName\n                    purgeRecursive(childPath)\n    final:\n        _lock.writeLock().unlock()\n", "code_toks_joined": "def purgeRecursive ( self , path ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> _lock . writeLock ( ) . lock ( ) <NEWLINE> parentPath = File ( path ) . getParent ( ) <NEWLINE> name = File ( path ) . getName ( ) <NEWLINE> removeFromParentChildSet ( parentPath , name ) <NEWLINE> znode = _cache . remove ( path ) <NEWLINE> if znode != None : <NEWLINE> <INDENT> childNames = znode . getChildSet ( ) <NEWLINE> for <NEWLINE> childName = None <NEWLINE> <INDENT> in childNames ) <NEWLINE> <INDENT> childPath = path + <STRING> + childName <NEWLINE> purgeRecursive ( childPath ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> final : <NEWLINE> <INDENT> _lock . writeLock ( ) . unlock ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns void\"\"\"", "\"/\""]}, "window_span": [85, 90], "err_obj": {"msg": "unbalanced (){}[]"}}], ["fba2cf56966ed76e4fe1a20bd23098ee", {"code_string": "class Reference(ReferenceBase):\n    def __init__(self, target_id, type = 'number', link = True, style = None,\n        quiet = False, ** kwargs):\n        super().__init__(type = type, link = link, style = style, quiet = quiet,\n            ** kwargs)\n            self._target_id = target_id\n    def target_id(self, document):\n        return self._target_id\n", "code_toks_joined": "class Reference ( ReferenceBase ) : <NEWLINE> <INDENT> def __init__ ( self , target_id , type = <STRING> , link = True , style = None , <NEWLINE> <INDENT> quiet = False , ** kwargs ) : <NEWLINE> super ( ) . __init__ ( type = type , link = link , style = style , quiet = quiet , <NEWLINE> <INDENT> ** kwargs ) <NEWLINE> self . _target_id = target_id <NEWLINE> <DEDENT> <DEDENT> def target_id ( self , document ) : <NEWLINE> <INDENT> return self . _target_id <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'number'"]}, "err_obj": {"msg": "unexpected indent"}}], ["d1f964d5ab92fb8489a33a9a01c9c2f2", {"code_string": "def GetShowIds(self):\n    show_ids = []\n    try:\n        response = GetUrlData(url = settings.__url__ + \"?cmd=shows\")\n        if not response:\n            return None\n        result = json.loads(response)\n        for each in result['data']:\n            show_ids.append(each)\n    except Exception, e:\n        common.errorWindow(sys._getframe().f_code.co_name, self.CONNECT_ERROR + str(e))\n    return show_ids\n", "code_toks_joined": "def GetShowIds ( self ) : <NEWLINE> <INDENT> show_ids = [ ] <NEWLINE> try : <NEWLINE> <INDENT> response = GetUrlData ( url = settings . __url__ + <STRING> ) <NEWLINE> if not response : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> result = json . loads ( response ) <NEWLINE> for each in result [ <STRING> ] : <NEWLINE> <INDENT> show_ids . append ( each ) <NEWLINE> <DEDENT> <DEDENT> except Exception , e : <NEWLINE> <INDENT> common . errorWindow ( sys . _getframe ( ) . f_code . co_name , self . CONNECT_ERROR + str ( e ) ) <NEWLINE> <DEDENT> return show_ids <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"?cmd=shows\"", "'data'"]}, "err_obj": {"msg": "invalid syntax"}}], ["ed94d5615131e05126b03989f48b2467", {"code_string": "def load_plugins(plugins):\n    print(\"Loading plugins: %s\" % \", \".join(plugins))\n    for plugin in plugins:\n        start = datetime.datetime.now()\n        try:\n            __import__(plugin, globals(), locals(), ['plugins'])\n        except Exception, e:\n            print(\"Could not load %s Plugin\" % plugin)\n            print(e)\n        print(\"%s: %s\" %(plugin, datetime.datetime.now() - start))\n    pass\n", "code_toks_joined": "def load_plugins ( plugins ) : <NEWLINE> <INDENT> print ( <STRING> % <STRING> . join ( plugins ) ) <NEWLINE> for plugin in plugins : <NEWLINE> <INDENT> start = datetime . datetime . now ( ) <NEWLINE> try : <NEWLINE> <INDENT> __import__ ( plugin , globals ( ) , locals ( ) , [ <STRING> ] ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> print ( <STRING> % plugin ) <NEWLINE> print ( e ) <NEWLINE> <DEDENT> print ( <STRING> % ( plugin , datetime . datetime . now ( ) - start ) ) <NEWLINE> <DEDENT> pass <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Loading plugins: %s\"", "\", \"", "'plugins'", "\"Could not load %s Plugin\"", "\"%s: %s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["43145676dec938d20c94d8ede955fdc5", {"code_string": "def __init__(self, wqlf, wqlb, ssd, parent = None):\n    print(\"initialised query results dialog\")\n        QtGui.QWidget.__init__(self, parent)\n    self.smartSpaceData = ssd\n    self.wqlResultUI = Ui_WQLResultDialog()\n    self.wqlResultUI.setupUi(self)\n    self.wqlframe = wqlf\n    self.wqlbody = wqlb\n    self.performQuery()\n", "code_toks_joined": "def __init__ ( self , wqlf , wqlb , ssd , parent = None ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> QtGui . QWidget . __init__ ( self , parent ) <NEWLINE> <DEDENT> self . smartSpaceData = ssd <NEWLINE> self . wqlResultUI = Ui_WQLResultDialog ( ) <NEWLINE> self . wqlResultUI . setupUi ( self ) <NEWLINE> self . wqlframe = wqlf <NEWLINE> self . wqlbody = wqlb <NEWLINE> self . performQuery ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"initialised query results dialog\""]}, "err_obj": {"msg": "unexpected indent"}}], ["04293b184028bbf64542c5da19751eb4", {"code_string": "def parse(self, * args, ** kwargs)\n    \"\"\"Execute parsing steps on the input data. Must be implemented\"\"\"\n    abstract\n", "code_toks_joined": "def parse ( self , * args , ** kwargs ) <NEWLINE> <INDENT> <STRING> <NEWLINE> abstract <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Execute parsing steps on the input data. Must be implemented\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["827e8504db881aa914076038232bcb1c", {"code_string": "def setupUi(self, w_chatwindow):\n    w_chatwindow.setObjectName(\"w_chatwindow\")\n    w_chatwindow.resize(466, 529)\n    self.centralwidget = QtGui.QWidget(w_chatwindow)\n    self.centralwidget.setObjectName(\"centralwidget\")\n    self.gridLayout_2 = QtGui.QGridLayout(self.centralwidget)\n    self.gridLayout_2.setObjectName(\"gridLayout_2\")\n    self.splitter_2 = QtGui.QSplitter(self.centralwidget)\n    self.splitter_2.setFrameShape(QtGui.QFrame.NoFrame)\n    self.splitter_2.setFrameShadow(QtGui.QFrame.Sunken)\n    self.splitter_2.setLineWidth(1)\n    self.splitter_2.setOrientation(QtCore.Qt.Vertical)\n    self.splitter_2.setHandleWidth(6)\n    self.splitter_2.setChildrenCollapsible(False)\n    self.splitter_2.setObjectName(\"splitter_2\")\n    self.w_chatframe = QtGui.QFrame(self.splitter_2)\n    sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Preferred)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(100)\n    sizePolicy.setHeightForWidth(self.w_chatframe.sizePolicy().hasHeightForWidth())\n    self.w_chatframe.setSizePolicy(sizePolicy)\n    self.w_chatframe.setFrameShadow(QtGui.QFrame.Raised)\n    self.w_chatframe.setLineWidth(0)\n    self.w_chatframe.setObjectName(\"w_chatframe\")\n    self.gridLayout = QtGui.QGridLayout(self.w_chatframe)\n    self.gridLayout.setMargin(0)\n    self.gridLayout.setSpacing(0)\n    self.gridLayout.setObjectName(\"gridLayout\")\n    self.splitter_3 = QtGui.QSplitter(self.w_chatframe)\n    self.splitter_3.setOrientation(QtCore.Qt.Horizontal)\n    self.splitter_3.setObjectName(\"splitter_3\")\n    self.convtext = QtGui.QTextBrowser(self.splitter_3)\n    self.convtext.setEnabled(True)\n    sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding)\n    sizePolicy.setHorizontalStretch(100)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(self.convtext.sizePolicy().hasHeightForWidth())\n    self.convtext.setSizePolicy(sizePolicy)\n    self.convtext.setAcceptDrops(False)\n    self.convtext.setStyleSheet(\"QTextEdit {\\n\"\n", "code_toks_joined": "def setupUi ( self , w_chatwindow ) : <NEWLINE> <INDENT> w_chatwindow . setObjectName ( <STRING> ) <NEWLINE> w_chatwindow . resize ( 466 , 529 ) <NEWLINE> self . centralwidget = QtGui . QWidget ( w_chatwindow ) <NEWLINE> self . centralwidget . setObjectName ( <STRING> ) <NEWLINE> self . gridLayout_2 = QtGui . QGridLayout ( self . centralwidget ) <NEWLINE> self . gridLayout_2 . setObjectName ( <STRING> ) <NEWLINE> self . splitter_2 = QtGui . QSplitter ( self . centralwidget ) <NEWLINE> self . splitter_2 . setFrameShape ( QtGui . QFrame . NoFrame ) <NEWLINE> self . splitter_2 . setFrameShadow ( QtGui . QFrame . Sunken ) <NEWLINE> self . splitter_2 . setLineWidth ( 1 ) <NEWLINE> self . splitter_2 . setOrientation ( QtCore . Qt . Vertical ) <NEWLINE> self . splitter_2 . setHandleWidth ( 6 ) <NEWLINE> self . splitter_2 . setChildrenCollapsible ( False ) <NEWLINE> self . splitter_2 . setObjectName ( <STRING> ) <NEWLINE> self . w_chatframe = QtGui . QFrame ( self . splitter_2 ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Preferred , QtGui . QSizePolicy . Preferred ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 100 ) <NEWLINE> sizePolicy . setHeightForWidth ( self . w_chatframe . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> self . w_chatframe . setSizePolicy ( sizePolicy ) <NEWLINE> self . w_chatframe . setFrameShadow ( QtGui . QFrame . Raised ) <NEWLINE> self . w_chatframe . setLineWidth ( 0 ) <NEWLINE> self . w_chatframe . setObjectName ( <STRING> ) <NEWLINE> self . gridLayout = QtGui . QGridLayout ( self . w_chatframe ) <NEWLINE> self . gridLayout . setMargin ( 0 ) <NEWLINE> self . gridLayout . setSpacing ( 0 ) <NEWLINE> self . gridLayout . setObjectName ( <STRING> ) <NEWLINE> self . splitter_3 = QtGui . QSplitter ( self . w_chatframe ) <NEWLINE> self . splitter_3 . setOrientation ( QtCore . Qt . Horizontal ) <NEWLINE> self . splitter_3 . setObjectName ( <STRING> ) <NEWLINE> self . convtext = QtGui . QTextBrowser ( self . splitter_3 ) <NEWLINE> self . convtext . setEnabled ( True ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Expanding , QtGui . QSizePolicy . Expanding ) <NEWLINE> sizePolicy . setHorizontalStretch ( 100 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( self . convtext . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> self . convtext . setSizePolicy ( sizePolicy ) <NEWLINE> self . convtext . setAcceptDrops ( False ) <NEWLINE> self . convtext . setStyleSheet ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"w_chatwindow\"", "\"centralwidget\"", "\"gridLayout_2\"", "\"splitter_2\"", "\"w_chatframe\"", "\"gridLayout\"", "\"splitter_3\"", "\"QTextEdit {\\n\""]}, "window_span": [429, 433], "err_obj": {"msg": "unbalanced (){}[]"}}], ["b26ac4842758c80301d06bbf36916d4f", {"code_string": "def configure_event(self, widget, event):\n    if _debug:\n        print 'FigureCanvasGTK3.%s' % fn_name()\n    if widget.get_property(\"window\") is None:\n        return\n    w, h = event.width, event.height\n    if w < 3 or h < 3:\n        return\n    dpi = self.figure.dpi\n    self.figure.set_size_inches(w / dpi, h / dpi)\n    self._need_redraw = True\n    return False\n", "code_toks_joined": "def configure_event ( self , widget , event ) : <NEWLINE> <INDENT> if _debug : <NEWLINE> <INDENT> print <STRING> % fn_name ( ) <NEWLINE> <DEDENT> if widget . get_property ( <STRING> ) is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> w , h = event . width , event . height <NEWLINE> if w < 3 or h < 3 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> dpi = self . figure . dpi <NEWLINE> self . figure . set_size_inches ( w / dpi , h / dpi ) <NEWLINE> self . _need_redraw = True <NEWLINE> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'FigureCanvasGTK3.%s'", "\"window\""]}, "err_obj": {"msg": "invalid syntax"}}], ["dca5a1488b70fae8f7203cd5cae5e1a6", {"code_string": "def _create_catalog_rows(self, catalog, prune = False):\n    rows = []\n    for message in catalog:\n        if not message.id:\n            continue\n        if prune and not message.locations:\n            continue\n        rows.append(self._create_catalog_row(\n            message.id, message.string, message.auto_comments, message.locations)\n    return rows\n", "code_toks_joined": "def _create_catalog_rows ( self , catalog , prune = False ) : <NEWLINE> <INDENT> rows = [ ] <NEWLINE> for message in catalog : <NEWLINE> <INDENT> if not message . id : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if prune and not message . locations : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> rows . append ( self . _create_catalog_row ( <NEWLINE> <INDENT> message . id , message . string , message . auto_comments , message . locations ) <NEWLINE> <DEDENT> <DEDENT> return rows <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["a21a1f6f57802cb24a650a7f7c8d8b5b", {"code_string": "def sentence_semantic_vector(s, joint_word_set):\n    s_words = re.sub(\"[^\\w-]\", \" \", s1).split()\n    sv = [0] * len(joint_word_set)\n    for i in range(0, len(joint_word_set))\n        sv[i] = 1 if joint_word_set[i] in s_words else word_semantic_similarity(joint_word_set[i], s)[1]\n    return sv\n", "code_toks_joined": "def sentence_semantic_vector ( s , joint_word_set ) : <NEWLINE> <INDENT> s_words = re . sub ( <STRING> , <STRING> , s1 ) . split ( ) <NEWLINE> sv = [ 0 ] * len ( joint_word_set ) <NEWLINE> for i in range ( 0 , len ( joint_word_set ) ) <NEWLINE> <INDENT> sv [ i ] = 1 if joint_word_set [ i ] in s_words else word_semantic_similarity ( joint_word_set [ i ] , s ) [ 1 ] <NEWLINE> <DEDENT> return sv <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"[^\\w-]\"", "\" \""]}, "err_obj": {"msg": "invalid syntax"}}], ["c1057cc710f889f6cff9cf8019727e27", {"code_string": "def euclid_vectors(self, a = [], b = []):\n    if a.__len__() != b.__len__():\n        if self.verbose:\n            print \"euclid_vectors: \", a.__len__(), \"!=\", b.__len__()\n        raise Exception\n    euclid_sqrd = 0\n    for i in range(0, a.__len__()):\n        euclid_sqrd += math.pow((a[i] - b[i]), 2)\n    return math.sqrt(euclid_sqrd)\n", "code_toks_joined": "def euclid_vectors ( self , a = [ ] , b = [ ] ) : <NEWLINE> <INDENT> if a . __len__ ( ) != b . __len__ ( ) : <NEWLINE> <INDENT> if self . verbose : <NEWLINE> <INDENT> print <STRING> , a . __len__ ( ) , <STRING> , b . __len__ ( ) <NEWLINE> <DEDENT> raise Exception <NEWLINE> <DEDENT> euclid_sqrd = 0 <NEWLINE> for i in range ( 0 , a . __len__ ( ) ) : <NEWLINE> <INDENT> euclid_sqrd += math . pow ( ( a [ i ] - b [ i ] ) , 2 ) <NEWLINE> <DEDENT> return math . sqrt ( euclid_sqrd ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"euclid_vectors: \"", "\"!=\""]}, "err_obj": {"msg": "invalid syntax"}}], ["dca7cb88ddc280135fd74a0fdd2354e9", {"code_string": "def __init__(self, parent = None, pos = None, size = None, font = None):\n    if parent is not None:\n    if pos is not None:\n    pos, size = parent.parse(pos, size, font)\n    self.x, self.y = pos\n    self.w, self.h = size\n    else:\n    self.x = None\n    self.y = None\n    self.w = None\n    self.h = None\n", "code_toks_joined": "def __init__ ( self , parent = None , pos = None , size = None , font = None ) : <NEWLINE> <INDENT> if parent is not None : <NEWLINE> if pos is not None : <NEWLINE> pos , size = parent . parse ( pos , size , font ) <NEWLINE> self . x , self . y = pos <NEWLINE> self . w , self . h = size <NEWLINE> else : <NEWLINE> self . x = None <NEWLINE> self . y = None <NEWLINE> self . w = None <NEWLINE> self . h = None <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["538326121b5fc7c75201bcd0970dd51a", {"code_string": "def stop(self, key):\n    if(Config.DEBUG > 3): print 'stop loop at key: ' + str(key)\n    for n in self.notesDict[key]:\n        self.csnd.loopDelete(n)\n    del self.notesDict[key]\n    if(Config.DEBUG > 3):\n        print self.notesDict\n", "code_toks_joined": "def stop ( self , key ) : <NEWLINE> <INDENT> if ( Config . DEBUG > 3 ) : print <STRING> + str ( key ) <NEWLINE> for n in self . notesDict [ key ] : <NEWLINE> <INDENT> self . csnd . loopDelete ( n ) <NEWLINE> <DEDENT> del self . notesDict [ key ] <NEWLINE> if ( Config . DEBUG > 3 ) : <NEWLINE> <INDENT> print self . notesDict <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'stop loop at key: '"]}, "err_obj": {"msg": "invalid syntax"}}], ["be6c1159800bbfc86fc3e29ecaf08dc6", {"code_string": "def print_page(request, id, pin):\n    check_inputs(id, pin)\n    con = Connection.objects.get(id = id)\n    translation.activate(brain.get_user_lang(con.telegram_id)))\n    message_link = HPQR_HOST + \"/\" + id + \".\" + pin\n    return render(request, 'print.html', {'message_link': message_link, 'HPQR_YANDEX_METRIKA': HPQR_YANDEX_METRIKA})\n", "code_toks_joined": "def print_page ( request , id , pin ) : <NEWLINE> <INDENT> check_inputs ( id , pin ) <NEWLINE> con = Connection . objects . get ( id = id ) <NEWLINE> translation . activate ( brain . get_user_lang ( con . telegram_id ) ) ) <NEWLINE> message_link = HPQR_HOST + <STRING> + id + <STRING> + pin <NEWLINE> return render ( request , <STRING> , { <STRING> : message_link , <STRING> : HPQR_YANDEX_METRIKA } ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"/\"", "\".\"", "'print.html'", "'message_link'", "'HPQR_YANDEX_METRIKA'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["a2cb184f12904d9a6f4ec7a74e87bbfc", {"code_string": "def test_rank(score, expected_rank):\n    if(hasattr(expected_rank, '__call__') and\n        isinstance(expected_rank(), Exception)):\n        with pytest.raises(expected_rank):\n        cc_rank(score)\n    else:\n        assert cc_rank(score) == expected_rank\n", "code_toks_joined": "def test_rank ( score , expected_rank ) : <NEWLINE> <INDENT> if ( hasattr ( expected_rank , <STRING> ) and <NEWLINE> <INDENT> isinstance ( expected_rank ( ) , Exception ) ) : <NEWLINE> with pytest . raises ( expected_rank ) : <NEWLINE> cc_rank ( score ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> assert cc_rank ( score ) == expected_rank <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'__call__'"]}, "err_obj": {"msg": "expected an indented block"}}], ["afeb8152a175e9cc5786c40e7e19ed3a", {"code_string": "def setUp(self):\n    self.archive_path = binary_manager.FetchPath(\n        'example_domain_wpr_go_archive',\n        py_utils.GetHostArchName(),\n        ,\n        py_utils.GetHostOsName())\n", "code_toks_joined": "def setUp ( self ) : <NEWLINE> <INDENT> self . archive_path = binary_manager . FetchPath ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> py_utils . GetHostArchName ( ) , <NEWLINE> , <NEWLINE> py_utils . GetHostOsName ( ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'example_domain_wpr_go_archive'"]}, "err_obj": {"msg": "invalid syntax"}}], ["dea1660c4bcd27a4982b75534fe2c068", {"code_string": "def changes(self, other):\n    \"\"\"Returns dictionary of codons that differ\"\"\"\n    changes = {}\n    try:\n        other_code = other.code_sequence\n    except AttributeError:\n        other_code = other\n    for codon, old, new in zip(self._codons, self.code_sequence,\n        other_code):\n        if old != new:\n        changes[codon] = old + new\n    return changes\n", "code_toks_joined": "def changes ( self , other ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> changes = { } <NEWLINE> try : <NEWLINE> <INDENT> other_code = other . code_sequence <NEWLINE> <DEDENT> except AttributeError : <NEWLINE> <INDENT> other_code = other <NEWLINE> <DEDENT> for codon , old , new in zip ( self . _codons , self . code_sequence , <NEWLINE> <INDENT> other_code ) : <NEWLINE> if old != new : <NEWLINE> changes [ codon ] = old + new <NEWLINE> <DEDENT> return changes <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns dictionary of codons that differ\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["a96ec5be7c69ac5473c9eefb1a465566", {"code_string": "class Solution(object):\n    def intersect(self, nums1, nums2):\n    \"\"\":type nums1: List[int]\"\"\"\n    dict = collections.defaultdict(int)\n    for i in nums1:\n        dict[i] += 1\n    ans = []\n    for i in nums2:\n        if dict[i] > 0:\n            ans.append(i)\n            dict[i] -= 1\n    return ans\n", "code_toks_joined": "class Solution ( object ) : <NEWLINE> <INDENT> def intersect ( self , nums1 , nums2 ) : <NEWLINE> <STRING> <NEWLINE> dict = collections . defaultdict ( int ) <NEWLINE> for i in nums1 : <NEWLINE> <INDENT> dict [ i ] += 1 <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> for i in nums2 : <NEWLINE> <INDENT> if dict [ i ] > 0 : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> dict [ i ] -= 1 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\":type nums1: List[int]\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["4db309986a8f8e5ea9df4f2204d4a72c", {"code_string": "import pickle\nimport numpy as np\nweight_history(append only)\n(read only)\n[Xy1, Xy2,..]\nrun multi processes\n", "code_toks_joined": "import pickle <NEWLINE> import numpy as np <NEWLINE> weight_history ( append only ) <NEWLINE> ( read only ) <NEWLINE> [ Xy1 , Xy2 , . . ] <NEWLINE> run multi processes <NEWLINE>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["505fc37c4ef6a4d1b7c529172e38ad12", {"code_string": "def format_dictlist(dictlist, features):\n    \"\"\"Convert a list of dictionaries to be compatible with create_csv_response\"\"\"\n    def dict_to_entry(dct):\n        \"\"\" Convert dictionary to a list for a csv row \"\"\"\n        relevant_items = [(k, v) for(k, v) in dct.items() if k in features]\n        ordered = sorted(relevant_items, key = lambda(k, v): header.index(k))\n        vals = [v for(_, v) in ordered]\n        return vals\n    header = features\n    datarows = map(dict_to_entry, dictlist)\n    return header, datarows\n", "code_toks_joined": "def format_dictlist ( dictlist , features ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def dict_to_entry ( dct ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> relevant_items = [ ( k , v ) for ( k , v ) in dct . items ( ) if k in features ] <NEWLINE> ordered = sorted ( relevant_items , key = lambda ( k , v ) : header . index ( k ) ) <NEWLINE> vals = [ v for ( _ , v ) in ordered ] <NEWLINE> return vals <NEWLINE> <DEDENT> header = features <NEWLINE> datarows = map ( dict_to_entry , dictlist ) <NEWLINE> return header , datarows <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Convert a list of dictionaries to be compatible with create_csv_response\"\"\"", "\"\"\" Convert dictionary to a list for a csv row \"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["6dbaaa46d935c0a57d157dc8c3969a30", {"code_string": "def GetClines(self):\n    print(\"Now getting Cccamcafard clines!\")\n    cccamcafardClines = []\n    cccamcafardClines.append(self.__GetCccamcafardCline(1))\n    cccamcafardClines.append(self.__GetCccamcafardCline(2))\n    cccamcafardClines = filter(None, cccamcafardClines)\n    if len(cccamcafardClines) == 0: print \"No CCcamcafard lines retrieved\"\n    return cccamcafardClines\n", "code_toks_joined": "def GetClines ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> cccamcafardClines = [ ] <NEWLINE> cccamcafardClines . append ( self . __GetCccamcafardCline ( 1 ) ) <NEWLINE> cccamcafardClines . append ( self . __GetCccamcafardCline ( 2 ) ) <NEWLINE> cccamcafardClines = filter ( None , cccamcafardClines ) <NEWLINE> if len ( cccamcafardClines ) == 0 : print <STRING> <NEWLINE> return cccamcafardClines <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Now getting Cccamcafard clines!\"", "\"No CCcamcafard lines retrieved\""]}, "err_obj": {"msg": "invalid syntax"}}], ["f6de4a79560b1d2b9fd5d1d71541f041", {"code_string": "def test_46_disableHost_user_stop_startVM(self):\n    \"\"\"Validate that regular user is allowed to stop and start existing VMs running in a disabled host\"\"\"\n        self.vm_user.stop(self.user_apiclient)\n    listResp = VirtualMachine.list(self.user_apiclient, id = self.vm_user.id)\n    self.assertEqual(listResp[0].state,\n        VirtualMachine.STOPPED,\n        \"Regular user is not able to Stop Vm in a disabled Host! \")\n        self.vm_user.start(self.user_apiclient)\n    listResp = VirtualMachine.list(self.user_apiclient, id = self.vm_user.id)\n    self.assertEqual(listResp[0].state,\n        VirtualMachine.RUNNING,\n        \"Regular is not able to Stop Vm in a disabled Host! \")\n", "code_toks_joined": "def test_46_disableHost_user_stop_startVM ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> self . vm_user . stop ( self . user_apiclient ) <NEWLINE> <DEDENT> listResp = VirtualMachine . list ( self . user_apiclient , id = self . vm_user . id ) <NEWLINE> self . assertEqual ( listResp [ 0 ] . state , <NEWLINE> <INDENT> VirtualMachine . STOPPED , <NEWLINE> <STRING> ) <NEWLINE> self . vm_user . start ( self . user_apiclient ) <NEWLINE> <DEDENT> listResp = VirtualMachine . list ( self . user_apiclient , id = self . vm_user . id ) <NEWLINE> self . assertEqual ( listResp [ 0 ] . state , <NEWLINE> <INDENT> VirtualMachine . RUNNING , <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Validate that regular user is allowed to stop and start existing VMs running in a disabled host\"\"\"", "\"Regular user is not able to Stop Vm in a disabled Host! \"", "\"Regular is not able to Stop Vm in a disabled Host! \""]}, "err_obj": {"msg": "unexpected indent"}}], ["3d27d7adda99b101aaa28f80dd4c5e6c", {"code_string": "class Ui_Outline_Tree(object):\n    def setupUi(self, Outline_Tree):\n        Outline_Tree.setObjectName(_fromUtf8(\"Outline_Tree\"))\n        Outline_Tree.resize(196, 308)\n        self.gridLayout = QtGui.QGridLayout(Outline_Tree)\n        self.gridLayout.setMargin(0)\n        self.gridLayout.setSpacing(0)\n        self.gridLayout.setObjectName(_fromUtf8(\"gridLayout\"))\n        self.l_title = QtGui.QLabel(Outline_Tree)\n        font = QtGui.QFont()\n        font.setBold(True)\n        font.setWeight(75)\n        self.l_title.setFont(font)\n        self.l_title.setStyleSheet(_fromUtf8(\"    background-color: qlineargradient(spread:pad, x1:1, y1:1, x2:1, y2:0, stop:0 rgba(48, 85, 100, 255), stop:0.21267 rgba(61, 107, 127, 255), stop:0.831818 rgba(72, 127, 150, 255), stop:1 rgba(104, 166, 175, 255));\\n\"\n", "code_toks_joined": "class Ui_Outline_Tree ( object ) : <NEWLINE> <INDENT> def setupUi ( self , Outline_Tree ) : <NEWLINE> <INDENT> Outline_Tree . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> Outline_Tree . resize ( 196 , 308 ) <NEWLINE> self . gridLayout = QtGui . QGridLayout ( Outline_Tree ) <NEWLINE> self . gridLayout . setMargin ( 0 ) <NEWLINE> self . gridLayout . setSpacing ( 0 ) <NEWLINE> self . gridLayout . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . l_title = QtGui . QLabel ( Outline_Tree ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setBold ( True ) <NEWLINE> font . setWeight ( 75 ) <NEWLINE> self . l_title . setFont ( font ) <NEWLINE> self . l_title . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Outline_Tree\"", "\"gridLayout\"", "\"    background-color: qlineargradient(spread:pad, x1:1, y1:1, x2:1, y2:0, stop:0 rgba(48, 85, 100, 255), stop:0.21267 rgba(61, 107, 127, 255), stop:0.831818 rgba(72, 127, 150, 255), stop:1 rgba(104, 166, 175, 255));\\n\""]}, "window_span": [125, 132], "err_obj": {"msg": "unbalanced (){}[]"}}], ["2ae9e8015c44f60ecd9fbd2e9db9117c", {"code_string": "def usage(doc = bddown_help.usage, message = None):\n    if hasattr(doc, '__call__'):\n        doc = doc()\n    if message:\n        print(message)\n    print(doc.strip()\n", "code_toks_joined": "def usage ( doc = bddown_help . usage , message = None ) : <NEWLINE> <INDENT> if hasattr ( doc , <STRING> ) : <NEWLINE> <INDENT> doc = doc ( ) <NEWLINE> <DEDENT> if message : <NEWLINE> <INDENT> print ( message ) <NEWLINE> <DEDENT> print ( doc . strip ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'__call__'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["8c9b88e577a8eae5c62e6fd5a0a3625d", {"code_string": "def check_version(easybuild_version, last_version_git_tag):\n    \"\"\"Check whether version has been bumped.\"\"\"\n    print(\"Current %s version: %s\" %(easybuild_package, easybuild_version))\n    print(\"Last git version tag: %s \" % last_version_git_tag)\n    if not easybuild_version == last_version_git_tag:\n        warning(\"Current %s version %s does not match last git version tag %s.\" %(easybuild_package,\n            easybuild_version,\n            ,\n            last_version_git_tag))\n        return False\n    else:\n        print(\"Version checks passed.\")\n        return True\n", "code_toks_joined": "def check_version ( easybuild_version , last_version_git_tag ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> % ( easybuild_package , easybuild_version ) ) <NEWLINE> print ( <STRING> % last_version_git_tag ) <NEWLINE> if not easybuild_version == last_version_git_tag : <NEWLINE> <INDENT> warning ( <STRING> % ( easybuild_package , <NEWLINE> <INDENT> easybuild_version , <NEWLINE> , <NEWLINE> last_version_git_tag ) ) <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Check whether version has been bumped.\"\"\"", "\"Current %s version: %s\"", "\"Last git version tag: %s \"", "\"Current %s version %s does not match last git version tag %s.\"", "\"Version checks passed.\""]}, "err_obj": {"msg": "invalid syntax"}}], ["5bd074a1293a401dfb111e436326393f", {"code_string": "def trace_exit(pid, flags, tricklist, exitstatus, termsig):\n    signalname = None\n    if termsig:\n    signalname = signalmap.lookup_name(termsig)\n    for trick, callmask, signalmask in tricklist:\n        if trick.is_enabled(pid): trick.exit(pid, exitstatus, signalname)\n", "code_toks_joined": "def trace_exit ( pid , flags , tricklist , exitstatus , termsig ) : <NEWLINE> <INDENT> signalname = None <NEWLINE> if termsig : <NEWLINE> signalname = signalmap . lookup_name ( termsig ) <NEWLINE> for trick , callmask , signalmask in tricklist : <NEWLINE> <INDENT> if trick . is_enabled ( pid ) : trick . exit ( pid , exitstatus , signalname ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["e98b25c334c79c862f79784eee1acfc8", {"code_string": "def process_details():\n    \"\"\"Returns details about the current process\"\"\"\n    results = {\n        'argv': sys.argv,\n        'working.directory': os.getcwd(),\n    }\n    for key, method in{'pid': 'getpid', 'ppid': 'getppid',\n        'login': 'getlogin', 'uid': 'getuid',\n        'euid': 'geteuid', 'gid': 'getgid',\n        'egid': 'getegid', 'groups': 'getgroups'}.items():\n        try:\n        results[key] = getattr(os, method)()\n        except AttributeError:\n        results[key] = None\n    return results\n", "code_toks_joined": "def process_details ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> results = { <NEWLINE> <INDENT> <STRING> : sys . argv , <NEWLINE> <STRING> : os . getcwd ( ) , <NEWLINE> <DEDENT> } <NEWLINE> for key , method in { <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <STRING> : <STRING> } . items ( ) : <NEWLINE> try : <NEWLINE> results [ key ] = getattr ( os , method ) ( ) <NEWLINE> except AttributeError : <NEWLINE> results [ key ] = None <NEWLINE> <DEDENT> return results <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns details about the current process\"\"\"", "'argv'", "'working.directory'", "'pid'", "'getpid'", "'ppid'", "'getppid'", "'login'", "'getlogin'", "'uid'", "'getuid'", "'euid'", "'geteuid'", "'gid'", "'getgid'", "'egid'", "'getegid'", "'groups'", "'getgroups'"]}, "err_obj": {"msg": "expected an indented block"}}], ["7c781c42df0b5c225329f11d4f5b3ee1", {"code_string": "def search(self, params):\n    if not params:\n    raise Exception('No params specified - search halted')\n    encoded_params = urllib.urlencode(params)\n    self.request_url = \"%s?%s\" %(self.search_url, encoded_params)\n    self.init_request()\n    return self.send_request()\n", "code_toks_joined": "def search ( self , params ) : <NEWLINE> <INDENT> if not params : <NEWLINE> raise Exception ( <STRING> ) <NEWLINE> encoded_params = urllib . urlencode ( params ) <NEWLINE> self . request_url = <STRING> % ( self . search_url , encoded_params ) <NEWLINE> self . init_request ( ) <NEWLINE> return self . send_request ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'No params specified - search halted'", "\"%s?%s\""]}, "err_obj": {"msg": "expected an indented block"}}], ["55564167b02f4f055c477cb9f7c979f1", {"code_string": "def selu(x, name = 'selu'):\n    alpha = 1.6732632423543772848170429916717\n    scale = 1.0507009873554804934193349852946\n    return scale * tf.where(x >= 0.0, x, alpha * tf.nn.elu(x)\n", "code_toks_joined": "def selu ( x , name = <STRING> ) : <NEWLINE> <INDENT> alpha = 1.6732632423543772848170429916717 <NEWLINE> scale = 1.0507009873554804934193349852946 <NEWLINE> return scale * tf . where ( x >= 0.0 , x , alpha * tf . nn . elu ( x ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'selu'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["150066ee305fe6db1dce25ded01de62a", {"code_string": "def _from_block_OB(block, basedir, extra_info, level):\n    for block_mod in bf_utils.iter_ListBase(\n        block.get_pointer((b'modifiers', b'first')),\n        next_item = (b'modifier', b'next')):\n        item_md_type = block_mod[b'modifier', b'type']\n        if item_md_type == C_defs.eModifierType_MeshCache:\n        yield FPElem_block_path(basedir, level, (block_mod, b'filepath')), extra_info\n", "code_toks_joined": "def _from_block_OB ( block , basedir , extra_info , level ) : <NEWLINE> <INDENT> for block_mod in bf_utils . iter_ListBase ( <NEWLINE> <INDENT> block . get_pointer ( ( <STRING> , <STRING> ) ) , <NEWLINE> next_item = ( <STRING> , <STRING> ) ) : <NEWLINE> item_md_type = block_mod [ <STRING> , <STRING> ] <NEWLINE> if item_md_type == C_defs . eModifierType_MeshCache : <NEWLINE> yield FPElem_block_path ( basedir , level , ( block_mod , <STRING> ) ) , extra_info <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["b'modifiers'", "b'first'", "b'modifier'", "b'next'", "b'modifier'", "b'type'", "b'filepath'"]}, "err_obj": {"msg": "expected an indented block"}}], ["1d87ea1f8a93823b46275e48c2e1715a", {"code_string": "class Cone(GeometricalObject3D):\n    \"\"\"Cone\"\"\"\n    def __init__(self, center, axis, angle):\n    self.center = center\n    self.axis = axis.normal()\n    self.angle = angle\n    def volume(self):\n    return None\n", "code_toks_joined": "class Cone ( GeometricalObject3D ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , center , axis , angle ) : <NEWLINE> self . center = center <NEWLINE> self . axis = axis . normal ( ) <NEWLINE> self . angle = angle <NEWLINE> def volume ( self ) : <NEWLINE> return None <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Cone\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["9c4846e86f0ad1e3446c4d4c912f4ed9", {"code_string": "def retrieve_all_links_coords_degree(self):\n    result = []\n    try:\n        self._cursor.execute('select l.target_x_coord_1920_1080, l.target_y_coord_1920_1080, l.target_article_degree, p.page_length_1920_1080 from link_features l, page_length p where  l.source_article_id = p.id and l.target_x_coord_1920_1080 is not Null and l.target_y_coord_1920_1080 is not Null  and l.target_x_coord_1920_1080!=0 and l.target_y_coord_1920_1080!=0;')\n        result = self._cursor.fetchall()\n    except MySQLdb.Error, e:\n        logging.error('error retrieving xy coord for all links links %s (%d)' %(e.args[1], e.args[0]))\n    return result\n", "code_toks_joined": "def retrieve_all_links_coords_degree ( self ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> try : <NEWLINE> <INDENT> self . _cursor . execute ( <STRING> ) <NEWLINE> result = self . _cursor . fetchall ( ) <NEWLINE> <DEDENT> except MySQLdb . Error , e : <NEWLINE> <INDENT> logging . error ( <STRING> % ( e . args [ 1 ] , e . args [ 0 ] ) ) <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'select l.target_x_coord_1920_1080, l.target_y_coord_1920_1080, l.target_article_degree, p.page_length_1920_1080 from link_features l, page_length p where  l.source_article_id = p.id and l.target_x_coord_1920_1080 is not Null and l.target_y_coord_1920_1080 is not Null  and l.target_x_coord_1920_1080!=0 and l.target_y_coord_1920_1080!=0;'", "'error retrieving xy coord for all links links %s (%d)'"]}, "err_obj": {"msg": "invalid syntax"}}], ["c4ef3ecc309173e5d1f1faf584701d21", {"code_string": "def artifact_dir(self):\n    \"\"\"Get the artifact directory.\"\"\"\n    dir = os.path.join(self.project_dir, _get_value(self.config, 'config.artifact_dir', '.build')\n    if not os.path.exists(dir):\n        _log.debug('artifact directory does not exist, creating it...')\n        os.makedirs(dir)\n    return dir\n", "code_toks_joined": "def artifact_dir ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> dir = os . path . join ( self . project_dir , _get_value ( self . config , <STRING> , <STRING> ) <NEWLINE> if not os . path . exists ( dir ) : <NEWLINE> <INDENT> _log . debug ( <STRING> ) <NEWLINE> os . makedirs ( dir ) <NEWLINE> <DEDENT> return dir <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get the artifact directory.\"\"\"", "'config.artifact_dir'", "'.build'", "'artifact directory does not exist, creating it...'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["df375fbf4e5e2bbe766ffc22ead007c0", {"code_string": "def printMat(mat):\n    n = len(mat)\n    for row in range(n):\n        print('[',\n        for col in range(n):\n            print('\\t', mat[row][col], )\n        print(']')\n", "code_toks_joined": "def printMat ( mat ) : <NEWLINE> <INDENT> n = len ( mat ) <NEWLINE> for row in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> , <NEWLINE> for col in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> , mat [ row ] [ col ] , ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'['", "'\\t'", "']'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["a9a8db8817fd39810ea122c73041996d", {"code_string": "class TOTPSlot(OTPSlot):\n    '''Time-based OTP slot specialisation'''\n    def __init__(self, name, key, base32_encoded, salt, digits, totp_algorithm,\n        time_step_size, start_time, now_time):\n        super().__init__(name, key, base32_encoded, salt, digits)\n        if not isinstance(totp_algorithm, TOTPAlgorithm):\n        raise Exception('Attempt to instantiate TOTPSlot with an invalid '\n            'algorithm: \\'%s\\'\\n\\n%s'\n            %(totp_algorithm, traceback.format_exc()))\n            self.totp_algorithm = totp_algorithm\n            self.time_step_size = time_step_size\n            self.start_time = start_time\n            self.now_time = now_time\n", "code_toks_joined": "class TOTPSlot ( OTPSlot ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , name , key , base32_encoded , salt , digits , totp_algorithm , <NEWLINE> <INDENT> time_step_size , start_time , now_time ) : <NEWLINE> super ( ) . __init__ ( name , key , base32_encoded , salt , digits ) <NEWLINE> if not isinstance ( totp_algorithm , TOTPAlgorithm ) : <NEWLINE> raise Exception ( <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> % ( totp_algorithm , traceback . format_exc ( ) ) ) <NEWLINE> self . totp_algorithm = totp_algorithm <NEWLINE> self . time_step_size = time_step_size <NEWLINE> self . start_time = start_time <NEWLINE> self . now_time = now_time <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Time-based OTP slot specialisation'''", "'Attempt to instantiate TOTPSlot with an invalid '", "'algorithm: \\'%s\\'\\n\\n%s'"]}, "err_obj": {"msg": "expected an indented block"}}], ["583eda85f0e340b98bec8ceeb3e31bca", {"code_string": "def __getActiveBlocks(self):\n    \"\"\"Get a list of active blocks/boundary/nodesets. (private)\"\"\"\n    blockinfo = self.getBlockInformation()\n    output = []\n    for param, object_type in zip(['block', 'boundary', 'nodeset'],\n        [self.BLOCK, self.SIDESET, self.NODESET]):\n        if self.isOptionValid(param):\n        blocks = self.getOption(param)\n        for data in blockinfo[object_type].itervalues():\n        if data.name in blocks:\n        output.append(data)\n    return output\n", "code_toks_joined": "def __getActiveBlocks ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> blockinfo = self . getBlockInformation ( ) <NEWLINE> output = [ ] <NEWLINE> for param , object_type in zip ( [ <STRING> , <STRING> , <STRING> ] , <NEWLINE> <INDENT> [ self . BLOCK , self . SIDESET , self . NODESET ] ) : <NEWLINE> if self . isOptionValid ( param ) : <NEWLINE> blocks = self . getOption ( param ) <NEWLINE> for data in blockinfo [ object_type ] . itervalues ( ) : <NEWLINE> if data . name in blocks : <NEWLINE> output . append ( data ) <NEWLINE> <DEDENT> return output <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get a list of active blocks/boundary/nodesets. (private)\"\"\"", "'block'", "'boundary'", "'nodeset'"]}, "err_obj": {"msg": "expected an indented block"}}], ["cdf36b312bd04ecd4430e54a6d91f0aa", {"code_string": "def test_downvoted__other_user(self):\n    self.reddit.read_only = False\n    with self.recorder.use_cassette(\n        'TestRedditorListings.test_downvoted__other_user'):\n        redditor = self.reddit.redditor('spez')\n        with pytest.raises(Forbidden):\n        list(redditor.downvoted())\n", "code_toks_joined": "def test_downvoted__other_user ( self ) : <NEWLINE> <INDENT> self . reddit . read_only = False <NEWLINE> with self . recorder . use_cassette ( <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> redditor = self . reddit . redditor ( <STRING> ) <NEWLINE> with pytest . raises ( Forbidden ) : <NEWLINE> list ( redditor . downvoted ( ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'TestRedditorListings.test_downvoted__other_user'", "'spez'"]}, "err_obj": {"msg": "expected an indented block"}}], ["b6e6f391372e7c94ccf33e6d1a8569c8", {"code_string": "def handle_exception(self, exc):\n    \"\"\"Handle any exception that occurs, by returning an appropriate response,\"\"\"\n    if isinstance(exc, (exceptions.NotAuthenticated,\n        exceptions.AuthenticationFailed)):\n        auth_header = self.get_authenticate_header(self.request)\n        if auth_header:\n        exc.auth_header = auth_header\n        else:\n        exc.status_code = status.HTTP_403_FORBIDDEN\n    response = self.settings.EXCEPTION_HANDLER(exc)\n    if response is None:\n        raise\n    response.exception = True\n    return response\n", "code_toks_joined": "def handle_exception ( self , exc ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if isinstance ( exc , ( exceptions . NotAuthenticated , <NEWLINE> <INDENT> exceptions . AuthenticationFailed ) ) : <NEWLINE> auth_header = self . get_authenticate_header ( self . request ) <NEWLINE> if auth_header : <NEWLINE> exc . auth_header = auth_header <NEWLINE> else : <NEWLINE> exc . status_code = status . HTTP_403_FORBIDDEN <NEWLINE> <DEDENT> response = self . settings . EXCEPTION_HANDLER ( exc ) <NEWLINE> if response is None : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> response . exception = True <NEWLINE> return response <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Handle any exception that occurs, by returning an appropriate response,\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["3b0c76aaf54b31d6f8bdbbdd410f25c2", {"code_string": "def retranslateUi(self, PreferencesDialog):\n    PreferencesDialog.setWindowTitle(QtGui.QApplication.translate(\"PreferencesDialog\", \"sconcho: Preferences\", None, QtGui.QApplication.UnicodeUTF8))\n    self.groupBox.setTitle(QtGui.QApplication.translate(\"PreferencesDialog\", \"Legend Font\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"Family\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_2.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"Style\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_3.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"Size\", None, QtGui.QApplication.UnicodeUTF8))\n    self.tabWidget.setTabText(self.tabWidget.indexOf(self.legendTab), QtGui.QApplication.translate(\"PreferencesDialog\", \"Legend\", None, QtGui.QApplication.UnicodeUTF8))\n    self.labelFontGrouper.setTitle(QtGui.QApplication.translate(\"PreferencesDialog\", \"Label Font\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_10.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"Family\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_11.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"Style\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_12.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"Size\", None, QtGui.QApplication.UnicodeUTF8))\n    self.showRowLabelChecker.setTitle(QtGui.QApplication.translate(\"PreferencesDialog\", \"Show Row Labels\", None, QtGui.QApplication.UnicodeUTF8))\n    self.customRowLabelsChecker.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"Use custom row labels (disables all automatic updates)\", None, QtGui.QApplication.UnicodeUTF8))\n    self.alignRowLabelsToVisibleChecker.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"Align row labels to visible cells\", None, QtGui.QApplication.UnicodeUTF8))\n    self.evenRowLabel.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"even row label location\", None, QtGui.QApplication.UnicodeUTF8))\n    self.evenRowLabelLocationComboBox.setItemText(0, QtGui.QApplication.translate(\"PreferencesDialog\", \"right of chart\", None, QtGui.QApplication.UnicodeUTF8))\n    self.evenRowLabelLocationComboBox.setItemText(1, QtGui.QApplication.translate(\"PreferencesDialog\", \"left of chart\", None, QtGui.QApplication.UnicodeUTF8))\n    self.showRowsWithIntervalButton.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"show only every \", None, QtGui.QApplication.UnicodeUTF8))\n    self.showOddRowsButton.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"show only odd row labels\", None, QtGui.QApplication.UnicodeUTF8))\n    self.oddRowLabel.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"odd row label location\", None, QtGui.QApplication.UnicodeUTF8))\n    self.oddRowLabelLocationComboBox.setItemText(0, QtGui.QApplication.translate(\"PreferencesDialog\", \"right of chart\", None, QtGui.QApplication.UnicodeUTF8))\n    self.oddRowLabelLocationComboBox.setItemText(1, QtGui.QApplication.translate(\"PreferencesDialog\", \"left of chart\", None, QtGui.QApplication.UnicodeUTF8))\n    self.showEvenRowsButton.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"show only even row labels\", None, QtGui.QApplication.UnicodeUTF8))\n    self.rowLabelsStartLabel.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"label starting at row\", None, QtGui.QApplication.UnicodeUTF8))\n    self.labelAllRowsButton.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"show all  row labels\", None, QtGui.QApplication.UnicodeUTF8))\n    self.rowLabelStart.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"row labels start with\", None, QtGui.QApplication.UnicodeUTF8))\n    self.showColumnLabelChecker.setTitle(QtGui.QApplication.translate(\"PreferencesDialog\", \"Show Column Labels\", None, QtGui.QApplication.UnicodeUTF8))\n    self.customColumnLabelsChecker.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"Use custom column labels (disables all automatic updates)\", None, QtGui.QApplication.UnicodeUTF8))\n    self.labelAllColumnsButton.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"label all columns\", None, QtGui.QApplication.UnicodeUTF8))\n    self.showColumnsWithIntervalButton.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"show only every \", None, QtGui.QApplication.UnicodeUTF8))\n    self.columnLabelStart.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"label starting at column\", None, QtGui.QApplication.UnicodeUTF8))\n    self.tabWidget.setTabText(self.tabWidget.indexOf(self.labelTab), QtGui.QApplication.translate(\"PreferencesDialog\", \"Labels\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_5.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"Grid Cell Width (pixels)\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_6.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"Grid Cell Height (pixels)\", None, QtGui.QApplication.UnicodeUTF8))\n    self.rowHighlightChecker.setTitle(QtGui.QApplication.translate(\"PreferencesDialog\", \"Highlight Grid Rows\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_7.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"&Opacity (%)\", None, QtGui.QApplication.UnicodeUTF8))\n    self.highlightRowColorButton.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"Highlight Color\", None, QtGui.QApplication.UnicodeUTF8))\n    self.highlightRowStartComboBox.setItemText(0, QtGui.QApplication.translate(\"PreferencesDialog\", \"start at bottom row\", None, QtGui.QApplication.UnicodeUTF8))\n    self.highlightRowStartComboBox.setItemText(1, QtGui.QApplication.translate(\"PreferencesDialog\", \"start at second row\", None, QtGui.QApplication.UnicodeUTF8))\n    self.snapPatternRepeatChecker.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"snap pattern repeats to grid\", None, QtGui.QApplication.UnicodeUTF8))\n    self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_2), QtGui.QApplication.translate(\"PreferencesDialog\", \"Grid Properties\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_4.setText(QtGui.QApplication.translate(\"PreferencesDialog\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , PreferencesDialog ) : <NEWLINE> <INDENT> PreferencesDialog . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . groupBox . setTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_2 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_3 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . tabWidget . setTabText ( self . tabWidget . indexOf ( self . legendTab ) , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . labelFontGrouper . setTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_10 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_11 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_12 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . showRowLabelChecker . setTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . customRowLabelsChecker . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . alignRowLabelsToVisibleChecker . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . evenRowLabel . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . evenRowLabelLocationComboBox . setItemText ( 0 , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . evenRowLabelLocationComboBox . setItemText ( 1 , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . showRowsWithIntervalButton . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . showOddRowsButton . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . oddRowLabel . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . oddRowLabelLocationComboBox . setItemText ( 0 , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . oddRowLabelLocationComboBox . setItemText ( 1 , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . showEvenRowsButton . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . rowLabelsStartLabel . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . labelAllRowsButton . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . rowLabelStart . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . showColumnLabelChecker . setTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . customColumnLabelsChecker . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . labelAllColumnsButton . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . showColumnsWithIntervalButton . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . columnLabelStart . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . tabWidget . setTabText ( self . tabWidget . indexOf ( self . labelTab ) , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_5 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_6 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . rowHighlightChecker . setTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_7 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . highlightRowColorButton . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . highlightRowStartComboBox . setItemText ( 0 , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . highlightRowStartComboBox . setItemText ( 1 , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . snapPatternRepeatChecker . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . tabWidget . setTabText ( self . tabWidget . indexOf ( self . tab_2 ) , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_4 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"PreferencesDialog\"", "\"sconcho: Preferences\"", "\"PreferencesDialog\"", "\"Legend Font\"", "\"PreferencesDialog\"", "\"Family\"", "\"PreferencesDialog\"", "\"Style\"", "\"PreferencesDialog\"", "\"Size\"", "\"PreferencesDialog\"", "\"Legend\"", "\"PreferencesDialog\"", "\"Label Font\"", "\"PreferencesDialog\"", "\"Family\"", "\"PreferencesDialog\"", "\"Style\"", "\"PreferencesDialog\"", "\"Size\"", "\"PreferencesDialog\"", "\"Show Row Labels\"", "\"PreferencesDialog\"", "\"Use custom row labels (disables all automatic updates)\"", "\"PreferencesDialog\"", "\"Align row labels to visible cells\"", "\"PreferencesDialog\"", "\"even row label location\"", "\"PreferencesDialog\"", "\"right of chart\"", "\"PreferencesDialog\"", "\"left of chart\"", "\"PreferencesDialog\"", "\"show only every \"", "\"PreferencesDialog\"", "\"show only odd row labels\"", "\"PreferencesDialog\"", "\"odd row label location\"", "\"PreferencesDialog\"", "\"right of chart\"", "\"PreferencesDialog\"", "\"left of chart\"", "\"PreferencesDialog\"", "\"show only even row labels\"", "\"PreferencesDialog\"", "\"label starting at row\"", "\"PreferencesDialog\"", "\"show all  row labels\"", "\"PreferencesDialog\"", "\"row labels start with\"", "\"PreferencesDialog\"", "\"Show Column Labels\"", "\"PreferencesDialog\"", "\"Use custom column labels (disables all automatic updates)\"", "\"PreferencesDialog\"", "\"label all columns\"", "\"PreferencesDialog\"", "\"show only every \"", "\"PreferencesDialog\"", "\"label starting at column\"", "\"PreferencesDialog\"", "\"Labels\"", "\"PreferencesDialog\"", "\"Grid Cell Width (pixels)\"", "\"PreferencesDialog\"", "\"Grid Cell Height (pixels)\"", "\"PreferencesDialog\"", "\"Highlight Grid Rows\"", "\"PreferencesDialog\"", "\"&Opacity (%)\"", "\"PreferencesDialog\"", "\"Highlight Color\"", "\"PreferencesDialog\"", "\"start at bottom row\"", "\"PreferencesDialog\"", "\"start at second row\"", "\"PreferencesDialog\"", "\"snap pattern repeats to grid\"", "\"PreferencesDialog\"", "\"Grid Properties\"", "\"PreferencesDialog\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "window_span": [1098, 1110], "err_obj": {"msg": "unbalanced (){}[]"}}], ["01e967bddb03f596ea87a4e6fdca0371", {"code_string": "myString = \"Hello, World!\"\nif myString == \"Hello, World!\"\n    print(myString)\n", "code_toks_joined": "myString = <STRING> <NEWLINE> if myString == <STRING> <NEWLINE> <INDENT> print ( myString ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Hello, World!\"", "\"Hello, World!\""]}, "err_obj": {"msg": "invalid syntax"}}], ["4e2f636fa9148dfb89ba555d9a5ec63e", {"code_string": "def replace_action(target, source, env):\n    open(str(target[0]), 'w').write(PercentDelimitedTemplate(open(str(source[0]), 'r').read()).substitute(env))\n        env.Depends(target, env.Value(env.Dictionary()))\n", "code_toks_joined": "def replace_action ( target , source , env ) : <NEWLINE> <INDENT> open ( str ( target [ 0 ] ) , <STRING> ) . write ( PercentDelimitedTemplate ( open ( str ( source [ 0 ] ) , <STRING> ) . read ( ) ) . substitute ( env ) ) <NEWLINE> <INDENT> env . Depends ( target , env . Value ( env . Dictionary ( ) ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'w'", "'r'"]}, "err_obj": {"msg": "unexpected indent"}}], ["cd0222e8cd81166c71c5d8d360cfcb19", {"code_string": "def lookup_login_info(self, credentials, options):\n    \"\"\"Return member public cert/key and private key for user by EPPN.\"\"\"\n    with MethodContext(self, MA_LOG_PREFIX,\n        'lookup_login_info',\n        {}, credentials, options, read_only = True) as mc:\n        if not mc._error:\n        mc._result = self._delegate.lookup_login_info(mc._client_cert,\n            credentials,\n            options,\n            mc._session)\n    return mc._result\n", "code_toks_joined": "def lookup_login_info ( self , credentials , options ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with MethodContext ( self , MA_LOG_PREFIX , <NEWLINE> <INDENT> <STRING> , <NEWLINE> { } , credentials , options , read_only = True ) as mc : <NEWLINE> if not mc . _error : <NEWLINE> mc . _result = self . _delegate . lookup_login_info ( mc . _client_cert , <NEWLINE> <INDENT> credentials , <NEWLINE> options , <NEWLINE> mc . _session ) <NEWLINE> <DEDENT> <DEDENT> return mc . _result <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return member public cert/key and private key for user by EPPN.\"\"\"", "'lookup_login_info'"]}, "err_obj": {"msg": "expected an indented block"}}], ["cb79720d08d2dd9ae9de8225f6fdf094", {"code_string": "def htmlBalloon(county, party):\n    return '''<div style=\"font-weight:bold;\">''' %(\n    county['name'],\n    partyName(party),\n    htmlBalloonTally(county, party)\n", "code_toks_joined": "def htmlBalloon ( county , party ) : <NEWLINE> <INDENT> return <STRING> % ( <NEWLINE> county [ <STRING> ] , <NEWLINE> partyName ( party ) , <NEWLINE> htmlBalloonTally ( county , party ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''<div style=\"font-weight:bold;\">'''", "'name'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["872d477974d25b0ddf0010a95811e4ad", {"code_string": "def combinationWithoutRepetition(self):\n    '''handles button click when calculating combinations without repetitions'''\n    stuff = self.combinationParser()\n    if stuff['k'] > stuff['n']\n        return '''<br><img src=\"%s\" alt=\"Error!\">''' % QOMBICON16\n    else:\n        stuff['answer'] = factorial(stuff['n']) / factorial(stuff['k']) / factorial(stuff['n'] - stuff['k'])\n        return \"%(n)s!/%(k)s!/(%(n)s-%(k)s)! = %(answer)s\" % stuff\n", "code_toks_joined": "def combinationWithoutRepetition ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> stuff = self . combinationParser ( ) <NEWLINE> if stuff [ <STRING> ] > stuff [ <STRING> ] <NEWLINE> <INDENT> return <STRING> % QOMBICON16 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stuff [ <STRING> ] = factorial ( stuff [ <STRING> ] ) / factorial ( stuff [ <STRING> ] ) / factorial ( stuff [ <STRING> ] - stuff [ <STRING> ] ) <NEWLINE> return <STRING> % stuff <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''handles button click when calculating combinations without repetitions'''", "'k'", "'n'", "'''<br><img src=\"%s\" alt=\"Error!\">'''", "'answer'", "'n'", "'k'", "'n'", "'k'", "\"%(n)s!/%(k)s!/(%(n)s-%(k)s)! = %(answer)s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["f68425bec8871e6915a0c68ad291f670", {"code_string": "def confirm(self, confirmed):\n    if not confirmed:\n        print(\"not confirmed\")\n        return\n    else:\n        self.nameEntry[1].setValue(iInputDevices.getDeviceAttribute(self.inputDevice, 'name'))\n        cmd = \"config.inputDevices.\" + self.inputDevice + \".name.save()\"\n        exec cmd\n        self.keySave()\n", "code_toks_joined": "def confirm ( self , confirmed ) : <NEWLINE> <INDENT> if not confirmed : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . nameEntry [ 1 ] . setValue ( iInputDevices . getDeviceAttribute ( self . inputDevice , <STRING> ) ) <NEWLINE> cmd = <STRING> + self . inputDevice + <STRING> <NEWLINE> exec cmd <NEWLINE> self . keySave ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"not confirmed\"", "'name'", "\"config.inputDevices.\"", "\".name.save()\""]}, "err_obj": {"msg": "invalid syntax"}}], ["68dca50954a99fd05fbf4a01a7b735e7", {"code_string": "def _exec(self, irc, msg, args, s):\n    \"\"\"<statement>\"\"\"\n    exec s\n    irc.replySuccess()\n", "code_toks_joined": "def _exec ( self , irc , msg , args , s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> exec s <NEWLINE> irc . replySuccess ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"<statement>\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["7e350ee57089be26dbdcf6c46aabd743", {"code_string": "def test_search(self):\n    self.driver.get('https://www.aweber.com/search.htm')\n    search_input = self.driver.find_element_by_css_selector\n        '#content input[type=\"text\"]')\n    search_input.send_keys('Meet the Team')\n    search_submit = self.driver.find_element_by_css_selector(\n        '#content input[type=\"submit\"]')\n    search_submit.click()\n    self.assertTrue(self.driver.find_element_by_css_selector(\n        'a[href=\"http://www.aweber.com/meet-the-team.htm\"]'))\n", "code_toks_joined": "def test_search ( self ) : <NEWLINE> <INDENT> self . driver . get ( <STRING> ) <NEWLINE> search_input = self . driver . find_element_by_css_selector <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> search_input . send_keys ( <STRING> ) <NEWLINE> search_submit = self . driver . find_element_by_css_selector ( <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> search_submit . click ( ) <NEWLINE> self . assertTrue ( self . driver . find_element_by_css_selector ( <NEWLINE> <INDENT> <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'https://www.aweber.com/search.htm'", "'#content input[type=\"text\"]'", "'Meet the Team'", "'#content input[type=\"submit\"]'", "'a[href=\"http://www.aweber.com/meet-the-team.htm\"]'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["b830ec288d1bf52f234a26ce8c5376b1", {"code_string": "def __compute_camera_matrix_and_distortion_coefficients(self, distorted_image_path):\n    if self.__is_stage_complete(self.STAGE_COMPUTED_OBJ_AND_IMG_POINTS) and not self.__is_stage_complete(\n        self.STAGE_CALCULATED_CAMERA_MTX_AND_DIST_COEFFICIENTS):\n        fname = distorted_image_path\n        img = mpimg.imread(fname)\n        ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(self.__objpoints, self.__imgpoints, img.shape[0: 2][: : - 1],\n            None, None)\n            self.__camera_matrix = mtx\n            self.__distortion_coefficients = dist\n            self.__apply_stage(self.STAGE_CALCULATED_CAMERA_MTX_AND_DIST_COEFFICIENTS)\n", "code_toks_joined": "def __compute_camera_matrix_and_distortion_coefficients ( self , distorted_image_path ) : <NEWLINE> <INDENT> if self . __is_stage_complete ( self . STAGE_COMPUTED_OBJ_AND_IMG_POINTS ) and not self . __is_stage_complete ( <NEWLINE> <INDENT> self . STAGE_CALCULATED_CAMERA_MTX_AND_DIST_COEFFICIENTS ) : <NEWLINE> fname = distorted_image_path <NEWLINE> img = mpimg . imread ( fname ) <NEWLINE> ret , mtx , dist , rvecs , tvecs = cv2 . calibrateCamera ( self . __objpoints , self . __imgpoints , img . shape [ 0 : 2 ] [ : : - 1 ] , <NEWLINE> <INDENT> None , None ) <NEWLINE> self . __camera_matrix = mtx <NEWLINE> self . __distortion_coefficients = dist <NEWLINE> self . __apply_stage ( self . STAGE_CALCULATED_CAMERA_MTX_AND_DIST_COEFFICIENTS ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["7ee469666e181d7114ebfd33d1762e9b", {"code_string": "def create_configurable_widget(client, config_key):\n    frame = gtk.Frame(config_key)\n    label = gtk.Label('')\n    frame.add(label)\n    s = client.get_string(config_key)\n    if s:\n    label.set_text(s)\n    notify_id = client.notify_add(config_key,\n        configurable_widget_config_notify,\n        label)\n    label.set_data('notify_id', notify_id)\n    label.set_data('client', client)\n    label.connect('destroy', configurable_widget_destroy_callback)\n    return frame\n", "code_toks_joined": "def create_configurable_widget ( client , config_key ) : <NEWLINE> <INDENT> frame = gtk . Frame ( config_key ) <NEWLINE> label = gtk . Label ( <STRING> ) <NEWLINE> frame . add ( label ) <NEWLINE> s = client . get_string ( config_key ) <NEWLINE> if s : <NEWLINE> label . set_text ( s ) <NEWLINE> notify_id = client . notify_add ( config_key , <NEWLINE> <INDENT> configurable_widget_config_notify , <NEWLINE> label ) <NEWLINE> <DEDENT> label . set_data ( <STRING> , notify_id ) <NEWLINE> label . set_data ( <STRING> , client ) <NEWLINE> label . connect ( <STRING> , configurable_widget_destroy_callback ) <NEWLINE> return frame <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "'notify_id'", "'client'", "'destroy'"]}, "err_obj": {"msg": "expected an indented block"}}], ["ed25801f54ce39389d9de594fec9b9fa", {"code_string": "def sample_getPosts(self):\n    prefix, suffix = getAPI(URL, 'GET/posts')\n    url = prefix + suffix\n    req1 = requests.get(url)\n        body = json.loads(req1.text)\n        return body\n", "code_toks_joined": "def sample_getPosts ( self ) : <NEWLINE> <INDENT> prefix , suffix = getAPI ( URL , <STRING> ) <NEWLINE> url = prefix + suffix <NEWLINE> req1 = requests . get ( url ) <NEWLINE> <INDENT> body = json . loads ( req1 . text ) <NEWLINE> return body <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'GET/posts'"]}, "err_obj": {"msg": "unexpected indent"}}], ["0578fa263051d084fea7ae8bc5ab39e5", {"code_string": "def retranslateUi(self, NoDevicesDialog_base):\n    NoDevicesDialog_base.setWindowTitle(QtGui.QApplication.translate(\"NoDevicesDialog_base\", \"HP Device Manager - No Installed HP Devices Found\", None, QtGui.QApplication.UnicodeUTF8))\n    self.textLabel7.setText(QtGui.QApplication.translate(\"NoDevicesDialog_base\", \"<html><head><meta name=\\\"qrichtext\\\" content=\\\"1\\\" /><style type=\\\"text/css\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , NoDevicesDialog_base ) : <NEWLINE> <INDENT> NoDevicesDialog_base . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . textLabel7 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"NoDevicesDialog_base\"", "\"HP Device Manager - No Installed HP Devices Found\"", "\"NoDevicesDialog_base\"", "\"<html><head><meta name=\\\"qrichtext\\\" content=\\\"1\\\" /><style type=\\\"text/css\\\">\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["60ae7ec160914697836f3b72e32d88b6", {"code_string": "def paint_aggr_hosts(row, link_to_view):\n    h = []\n    for site, host in row[\"aggr_hosts\"]:\n        url = html.makeuri([(\"view_name\", link_to_view), (\"site\", site), (\"host\", host)])\n        h.append('<a href=\"%s\">%s</a>' %(url host))\n    return \"\", \" \".join(h)\n", "code_toks_joined": "def paint_aggr_hosts ( row , link_to_view ) : <NEWLINE> <INDENT> h = [ ] <NEWLINE> for site , host in row [ <STRING> ] : <NEWLINE> <INDENT> url = html . makeuri ( [ ( <STRING> , link_to_view ) , ( <STRING> , site ) , ( <STRING> , host ) ] ) <NEWLINE> h . append ( <STRING> % ( url host ) ) <NEWLINE> <DEDENT> return <STRING> , <STRING> . join ( h ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"aggr_hosts\"", "\"view_name\"", "\"site\"", "\"host\"", "'<a href=\"%s\">%s</a>'", "\"\"", "\" \""]}, "err_obj": {"msg": "invalid syntax"}}], ["b504eaf0409def1478995e6c869b2a26", {"code_string": "class SecurityNegotiationFailure(StreamNegotiationFailure):\n    def __init__(self, xmpp_error,\n        kind = \"Security negotiation failure\",\n        text = None):\n        msg = \"{}: {}\".format(kind, xmpp_error)\n        if text:\n        msg += \" ('{}')\".format(text)\n        super().__init__(msg)\n        self.xmpp_error = xmpp_error\n        self.text = text\n", "code_toks_joined": "class SecurityNegotiationFailure ( StreamNegotiationFailure ) : <NEWLINE> <INDENT> def __init__ ( self , xmpp_error , <NEWLINE> <INDENT> kind = <STRING> , <NEWLINE> text = None ) : <NEWLINE> msg = <STRING> . format ( kind , xmpp_error ) <NEWLINE> if text : <NEWLINE> msg += <STRING> . format ( text ) <NEWLINE> super ( ) . __init__ ( msg ) <NEWLINE> self . xmpp_error = xmpp_error <NEWLINE> self . text = text <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Security negotiation failure\"", "\"{}: {}\"", "\" ('{}')\""]}, "err_obj": {"msg": "expected an indented block"}}], ["fab304d7485bfedbf2197e57aafe3f31", {"code_string": "def update(self, context):\n    global last_update\n    if(context.window is not None and\n        context.window.screen is not None and\n        context.window.screen.areas is not None):\n        areas = context.window.screen.areas\n        for area in areas:\n        if area.type == 'INFO':\n            area.tag_redraw()\n            if time() - last_update > 0.1:\n        bpy.ops.wm.redraw_timer(type = 'DRAW_WIN_SWAP', iterations = 1)\n        last_update = time()\n", "code_toks_joined": "def update ( self , context ) : <NEWLINE> <INDENT> global last_update <NEWLINE> if ( context . window is not None and <NEWLINE> <INDENT> context . window . screen is not None and <NEWLINE> context . window . screen . areas is not None ) : <NEWLINE> areas = context . window . screen . areas <NEWLINE> for area in areas : <NEWLINE> if area . type == <STRING> : <NEWLINE> <INDENT> area . tag_redraw ( ) <NEWLINE> if time ( ) - last_update > 0.1 : <NEWLINE> <DEDENT> bpy . ops . wm . redraw_timer ( type = <STRING> , iterations = 1 ) <NEWLINE> last_update = time ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'INFO'", "'DRAW_WIN_SWAP'"]}, "err_obj": {"msg": "expected an indented block"}}], ["39dfb213c4618e30d3a7b5c413305584", {"code_string": "def _lock_svn(self):\n    repo = get_output('git rev-parse --git-dir')[0]\n    dir = os.path.join(repo, 'yap')\n    fd, tmplock = tempfile.mkstemp(\"yap\", dir = dir)\n    try:\n        os.close(fd)\n        lockfile = os.path.join(dir, 'svn-lock')\n        try:\n        os.link(tmplock, lockfile)\n        except OSError:\n        raise YapError(\"A subversion operation is already in progress\")\n    finally:\n        os.unlink(tmplock)\n", "code_toks_joined": "def _lock_svn ( self ) : <NEWLINE> <INDENT> repo = get_output ( <STRING> ) [ 0 ] <NEWLINE> dir = os . path . join ( repo , <STRING> ) <NEWLINE> fd , tmplock = tempfile . mkstemp ( <STRING> , dir = dir ) <NEWLINE> try : <NEWLINE> <INDENT> os . close ( fd ) <NEWLINE> lockfile = os . path . join ( dir , <STRING> ) <NEWLINE> try : <NEWLINE> os . link ( tmplock , lockfile ) <NEWLINE> except OSError : <NEWLINE> raise YapError ( <STRING> ) <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> os . unlink ( tmplock ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'git rev-parse --git-dir'", "'yap'", "\"yap\"", "'svn-lock'", "\"A subversion operation is already in progress\""]}, "err_obj": {"msg": "expected an indented block"}}], ["9e34b55440d221e1b8ceca0168448e44", {"code_string": "from smiles_parsers import Smiles, BuildMol\nfrom perception import RingDetection, BasicAromaticity, sssr\ndef smilin(smiles, transforms = [sssr.sssr,\n    BasicAromaticity.aromatize],\n    enable_vfgraph = 0):\n    \"\"\"(smiles)->molecule\"\"\"\n    builder = BuildMol.BuildMol(enable_vfgraph)\n    Smiles.tokenize(smiles, builder)\n    mol = builder.mol\n    for transform in transforms:\n    mol = transform(mol)\n    for atom in mol.atoms:\n    if not atom.has_explicit_hcount:\n    atom.imp_hcount = atom.hcount - atom.explicit_hcount\n    return mol\n", "code_toks_joined": "from smiles_parsers import Smiles , BuildMol <NEWLINE> from perception import RingDetection , BasicAromaticity , sssr <NEWLINE> def smilin ( smiles , transforms = [ sssr . sssr , <NEWLINE> <INDENT> BasicAromaticity . aromatize ] , <NEWLINE> enable_vfgraph = 0 ) : <NEWLINE> <STRING> <NEWLINE> builder = BuildMol . BuildMol ( enable_vfgraph ) <NEWLINE> Smiles . tokenize ( smiles , builder ) <NEWLINE> mol = builder . mol <NEWLINE> for transform in transforms : <NEWLINE> mol = transform ( mol ) <NEWLINE> for atom in mol . atoms : <NEWLINE> if not atom . has_explicit_hcount : <NEWLINE> atom . imp_hcount = atom . hcount - atom . explicit_hcount <NEWLINE> return mol <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"(smiles)->molecule\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["3185bf6eea4a73234597e2c3c7e4ebf7", {"code_string": "def GenerateItems(self, offset = 0):\n    \"\"\"First iterate over the versions, and then iterate over the stream.\"\"\"\n    index = 0\n    for x in super(PackedVersionedCollection, self).GenerateItems():\n        if index >= offset:\n            yield x\n        index += 1\n    for x in self.GenerateUncompactedItems(\n        max_reversed_results = self.MAX_REVERSED_RESULTS):\n        if index >= offset:\n        yield x\n        index += 1\n", "code_toks_joined": "def GenerateItems ( self , offset = 0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> index = 0 <NEWLINE> for x in super ( PackedVersionedCollection , self ) . GenerateItems ( ) : <NEWLINE> <INDENT> if index >= offset : <NEWLINE> <INDENT> yield x <NEWLINE> <DEDENT> index += 1 <NEWLINE> <DEDENT> for x in self . GenerateUncompactedItems ( <NEWLINE> <INDENT> max_reversed_results = self . MAX_REVERSED_RESULTS ) : <NEWLINE> if index >= offset : <NEWLINE> yield x <NEWLINE> index += 1 <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"First iterate over the versions, and then iterate over the stream.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["469380a7c730088662bc73b9fd3cc3be", {"code_string": "def total_score(filename):\n    with open(filename, mode = 'r') as f:\n        names = [n[1: - 1] for n in f.readline().split(', ')]\n        names.sort()\n        return sum((1 + i) *(sum(ord(letter) - ord('A') + 1 for letter in name)) for i, name in enumerate(names)\n", "code_toks_joined": "def total_score ( filename ) : <NEWLINE> <INDENT> with open ( filename , mode = <STRING> ) as f : <NEWLINE> <INDENT> names = [ n [ 1 : - 1 ] for n in f . readline ( ) . split ( <STRING> ) ] <NEWLINE> names . sort ( ) <NEWLINE> return sum ( ( 1 + i ) * ( sum ( ord ( letter ) - ord ( <STRING> ) + 1 for letter in name ) ) for i , name in enumerate ( names ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'r'", "', '", "'A'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c2f39c38d486723538f88dec0b727877", {"code_string": "def _monitor(self):\n    while True:\n        for dp in self.datapaths.values():\n        self._request_stats(dp)\n        hub.sleep(10)\n        hub.sleep(1)\n", "code_toks_joined": "def _monitor ( self ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> for dp in self . datapaths . values ( ) : <NEWLINE> self . _request_stats ( dp ) <NEWLINE> hub . sleep ( 10 ) <NEWLINE> hub . sleep ( 1 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["ed2f821f3d036b688d1f8c8b112d1c70", {"code_string": "def kd_sort(elems, prop_func = (lambda x: x), dir = 'increase'):\n    elems.sort(key = prop_func)\n    if dir == 'decrease' or dir == 'decr':\n    elems.reverse()\n", "code_toks_joined": "def kd_sort ( elems , prop_func = ( lambda x : x ) , dir = <STRING> ) : <NEWLINE> <INDENT> elems . sort ( key = prop_func ) <NEWLINE> if dir == <STRING> or dir == <STRING> : <NEWLINE> elems . reverse ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'increase'", "'decrease'", "'decr'"]}, "err_obj": {"msg": "expected an indented block"}}], ["2a7ef241f364c59307c7af2ed8d05f24", {"code_string": "def findvideosbyserver(data, serverid):\n    logger.info(\"pelisalacarta.core.servertools findvideosbyserver\")\n    encontrados = set()\n    devuelve = []\n    try:\n        exec \"from servers import \" + serverid\n        exec \"devuelve.extend(\" + serverid + \".find_videos(data))\"\n    except ImportError:\n        logger.info(\"No existe conector para #\" + serverid + \"#\")\n    except:\n        logger.info(\"Error en el conector #\" + serverid + \"#\")\n        import traceback\n        logger.info(traceback.format_exc())\n    return devuelve\n", "code_toks_joined": "def findvideosbyserver ( data , serverid ) : <NEWLINE> <INDENT> logger . info ( <STRING> ) <NEWLINE> encontrados = set ( ) <NEWLINE> devuelve = [ ] <NEWLINE> try : <NEWLINE> <INDENT> exec <STRING> + serverid <NEWLINE> exec <STRING> + serverid + <STRING> <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> logger . info ( <STRING> + serverid + <STRING> ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> logger . info ( <STRING> + serverid + <STRING> ) <NEWLINE> import traceback <NEWLINE> logger . info ( traceback . format_exc ( ) ) <NEWLINE> <DEDENT> return devuelve <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"pelisalacarta.core.servertools findvideosbyserver\"", "\"from servers import \"", "\"devuelve.extend(\"", "\".find_videos(data))\"", "\"No existe conector para #\"", "\"#\"", "\"Error en el conector #\"", "\"#\""]}, "err_obj": {"msg": "invalid syntax"}}], ["99f2c0ddc8475243c4a3d42839481c8a", {"code_string": "def sanitize_token(self, token):\n    token_type = token[\"type\"]\n    if token_type in list(tokenTypes.keys()):\n        token_type = tokenTypes[token_type]\n    if token_type in(tokenTypes[\"StartTag\"], tokenTypes[\"EndTag\"],\n        tokenTypes[\"EmptyTag\"]):\n        if token[\"name\"] in self.allowed_elements:\n        return self.allowed_token(token, token_type)\n        else:\n        return self.disallowed_token(token, token_type)\n    elif token_type == tokenTypes[\"Comment\"]:\n        pass\n    else:\n        return token\n", "code_toks_joined": "def sanitize_token ( self , token ) : <NEWLINE> <INDENT> token_type = token [ <STRING> ] <NEWLINE> if token_type in list ( tokenTypes . keys ( ) ) : <NEWLINE> <INDENT> token_type = tokenTypes [ token_type ] <NEWLINE> <DEDENT> if token_type in ( tokenTypes [ <STRING> ] , tokenTypes [ <STRING> ] , <NEWLINE> <INDENT> tokenTypes [ <STRING> ] ) : <NEWLINE> if token [ <STRING> ] in self . allowed_elements : <NEWLINE> return self . allowed_token ( token , token_type ) <NEWLINE> else : <NEWLINE> return self . disallowed_token ( token , token_type ) <NEWLINE> <DEDENT> elif token_type == tokenTypes [ <STRING> ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return token <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"type\"", "\"StartTag\"", "\"EndTag\"", "\"EmptyTag\"", "\"name\"", "\"Comment\""]}, "err_obj": {"msg": "expected an indented block"}}], ["5d1a8f7fe34f453bb1a3fda984c20507", {"code_string": "def rastrigin_skew(individual):\n    \"\"\"Skewed Rastrigin test objective function.\"\"\"\n    N = len(individual)\n    return 10 * N + sum((10 * x if x > 0 else x) ** 2\n", "code_toks_joined": "def rastrigin_skew ( individual ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> N = len ( individual ) <NEWLINE> return 10 * N + sum ( ( 10 * x if x > 0 else x ) ** 2 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Skewed Rastrigin test objective function.\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["6c8ed45c841c6c590e4549dd93e82b08", {"code_string": "class _SecureHTTPServer(BaseHTTPServer.HTTPServer):\n    def __init__(self, private_key_pem_filepath, cert_pem_filepath,\n        binding = None, handler_cls = _SecureHTTPRequestHandler):\n        if binding is None:\n        binding = ('', 1443)\n        SocketServer.BaseServer.__init__(self, binding, handler_cls)\n        s = socket.socket(self.address_family, self.socket_type)\n        self.socket = ssl.SSLSocket(\n            s,\n            keyfile = private_key_pem_filepath,\n            certfile = cert_pem_filepath)\n            self.server_bind()\n            self.server_activate()\n", "code_toks_joined": "class _SecureHTTPServer ( BaseHTTPServer . HTTPServer ) : <NEWLINE> <INDENT> def __init__ ( self , private_key_pem_filepath , cert_pem_filepath , <NEWLINE> <INDENT> binding = None , handler_cls = _SecureHTTPRequestHandler ) : <NEWLINE> if binding is None : <NEWLINE> binding = ( <STRING> , 1443 ) <NEWLINE> SocketServer . BaseServer . __init__ ( self , binding , handler_cls ) <NEWLINE> s = socket . socket ( self . address_family , self . socket_type ) <NEWLINE> self . socket = ssl . SSLSocket ( <NEWLINE> <INDENT> s , <NEWLINE> keyfile = private_key_pem_filepath , <NEWLINE> certfile = cert_pem_filepath ) <NEWLINE> self . server_bind ( ) <NEWLINE> self . server_activate ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''"]}, "err_obj": {"msg": "expected an indented block"}}], ["bf7073e48c333aa59049c78c386f6356", {"code_string": "def pack_bitmap_128(value):\n    x = 0 l\n    for y in value:\n        x |= 1 << y\n    return struct.pack(\"!QQ\", (x >> 64) & MASK64, x & MASK64)\n", "code_toks_joined": "def pack_bitmap_128 ( value ) : <NEWLINE> <INDENT> x = 0 l <NEWLINE> for y in value : <NEWLINE> <INDENT> x |= 1 << y <NEWLINE> <DEDENT> return struct . pack ( <STRING> , ( x >> 64 ) & MASK64 , x & MASK64 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"!QQ\""]}, "err_obj": {"msg": "invalid syntax"}}], ["60af94a7cdfe74111b7e51e012a9fb15", {"code_string": "class AutoRestSwaggerBATFormDataServiceConfiguration(Configuration):\n    def __init__(\n        self, base_url = None, filepath = None):\n        if not base_url:\n        base_url = 'http://localhost'\n        super(AutoRestSwaggerBATFormDataServiceConfiguration, self).__init__(base_url, filepath)\n        self.user_agent = 'auto_rest_swagger_bat_form_data_service/1.0.0'\n", "code_toks_joined": "class AutoRestSwaggerBATFormDataServiceConfiguration ( Configuration ) : <NEWLINE> <INDENT> def __init__ ( <NEWLINE> <INDENT> self , base_url = None , filepath = None ) : <NEWLINE> if not base_url : <NEWLINE> base_url = <STRING> <NEWLINE> super ( AutoRestSwaggerBATFormDataServiceConfiguration , self ) . __init__ ( base_url , filepath ) <NEWLINE> self . user_agent = <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'http://localhost'", "'auto_rest_swagger_bat_form_data_service/1.0.0'"]}, "err_obj": {"msg": "expected an indented block"}}], ["9b0fe1e1ebe5c119947c4a3117c692a2", {"code_string": "def make_each_machine_c(machine_name, archs, functions, fcountlist, taglist, alignment):\n    tempstring = r\"\"\"// This file is automatically generated by make_each_machine_c.py.\"\"\"\n    for arch in archs:\n        tempstring += \"#define LV_HAVE_\" + arch.swapcase() + \" 1\\n\"\n    tempstring += \"\"\"\"\"\"\n    for func in functions:\n        tempstring += \"#include <volk/\" + func + \".h>\\n\"\n    tempstring += \"\\n\\n\"\n    tempstring += \"\"\"%s\"\"\" %(\n    _make_each_machine_struct(machine_name, archs +[\"orc\"], functions, fcountlist, taglist, alignment),\n    _make_each_machine_struct(machine_name, archs, functions, fcountlist, taglist, alignment)\n", "code_toks_joined": "def make_each_machine_c ( machine_name , archs , functions , fcountlist , taglist , alignment ) : <NEWLINE> <INDENT> tempstring = <STRING> <NEWLINE> for arch in archs : <NEWLINE> <INDENT> tempstring += <STRING> + arch . swapcase ( ) + <STRING> <NEWLINE> <DEDENT> tempstring += <STRING> <NEWLINE> for func in functions : <NEWLINE> <INDENT> tempstring += <STRING> + func + <STRING> <NEWLINE> <DEDENT> tempstring += <STRING> <NEWLINE> tempstring += <STRING> % ( <NEWLINE> _make_each_machine_struct ( machine_name , archs + [ <STRING> ] , functions , fcountlist , taglist , alignment ) , <NEWLINE> _make_each_machine_struct ( machine_name , archs , functions , fcountlist , taglist , alignment ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["r\"\"\"// This file is automatically generated by make_each_machine_c.py.\"\"\"", "\"#define LV_HAVE_\"", "\" 1\\n\"", "\"\"\"\"\"\"", "\"#include <volk/\"", "\".h>\\n\"", "\"\\n\\n\"", "\"\"\"%s\"\"\"", "\"orc\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["fc89b725f563af439e7b41f496c23842", {"code_string": "class KategoriForm(ModelForm):\n    class Meta:\n    model = Kategori\n", "code_toks_joined": "class KategoriForm ( ModelForm ) : <NEWLINE> <INDENT> class Meta : <NEWLINE> model = Kategori <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["c38a6958c1eb394bcfbc1882eb59d5a0", {"code_string": "def plugin_builder_function(plugin_name, plugin_code):\n    \"\"\"Internal function used to build the plugin container, so it behaves as a\"\"\"\n    ret = {}\n    for funct_name in('can_read_local',\n        'can_read_remote',\n        'can_write_local',\n        'read_metadata_local',\n        'write_metadata_local',\n        'read_metadata_remote'):\n        funct = getattr(plugin_code, funct_name, None)\n        if funct is not None:\n        ret[funct_name] = funct\n    return ret\n", "code_toks_joined": "def plugin_builder_function ( plugin_name , plugin_code ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = { } <NEWLINE> for funct_name in ( <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ) : <NEWLINE> funct = getattr ( plugin_code , funct_name , None ) <NEWLINE> if funct is not None : <NEWLINE> ret [ funct_name ] = funct <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Internal function used to build the plugin container, so it behaves as a\"\"\"", "'can_read_local'", "'can_read_remote'", "'can_write_local'", "'read_metadata_local'", "'write_metadata_local'", "'read_metadata_remote'"]}, "err_obj": {"msg": "expected an indented block"}}], ["8fa0effc0f079dc7359c995c909b66e5", {"code_string": "def get_footer(self):\n    \"\"\"Return closing string for tarfile, reset offset\"\"\"\n    blocks, remainder = divmod(self.offset, tarfile.RECORDSIZE)\n    self.offset = 0 l\n    return '\\0' *(tarfile.RECORDSIZE - remainder)\n", "code_toks_joined": "def get_footer ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> blocks , remainder = divmod ( self . offset , tarfile . RECORDSIZE ) <NEWLINE> self . offset = 0 l <NEWLINE> return <STRING> * ( tarfile . RECORDSIZE - remainder ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return closing string for tarfile, reset offset\"\"\"", "'\\0'"]}, "err_obj": {"msg": "invalid syntax"}}], ["a3ca058c87f69b91b2064e497e15e8f5", {"code_string": "def handle(self):\n    while True:\n        data = self.request.recv(1024)\n        if not data:\n        break\n        try:\n        info = simplejson.loads(data)\n        if info['type'] == 'cmd':\n            self.dowith_cmd_info(info)\n        except Exception as e:\n        pass\n", "code_toks_joined": "def handle ( self ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> data = self . request . recv ( 1024 ) <NEWLINE> if not data : <NEWLINE> break <NEWLINE> try : <NEWLINE> info = simplejson . loads ( data ) <NEWLINE> if info [ <STRING> ] == <STRING> : <NEWLINE> <INDENT> self . dowith_cmd_info ( info ) <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'type'", "'cmd'"]}, "err_obj": {"msg": "expected an indented block"}}], ["db30a336d9188d67841b3d2a734c6d2f", {"code_string": "def _mysql_drop_constraint(element, compiler, ** kw):\n    \"\"\"Redefine SQLAlchemy's drop constraint to\"\"\"\n    constraint = element.element\n    if isinstance(constraint, (schema.ForeignKeyConstraint,\n        schema.PrimaryKeyConstraint\n        schema.UniqueConstraint)\n        ):\n        return compiler.visit_drop_constraint(element, ** kw)\n    elif isinstance(constraint, schema.CheckConstraint):\n        raise NotImplementedError(\n            \"MySQL does not support CHECK constraints.\")\n    else:\n        raise NotImplementedError(\n            \"No generic 'DROP CONSTRAINT' in MySQL - \"\n            \"please specify constraint type\")\n", "code_toks_joined": "def _mysql_drop_constraint ( element , compiler , ** kw ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> constraint = element . element <NEWLINE> if isinstance ( constraint , ( schema . ForeignKeyConstraint , <NEWLINE> <INDENT> schema . PrimaryKeyConstraint <NEWLINE> schema . UniqueConstraint ) <NEWLINE> ) : <NEWLINE> return compiler . visit_drop_constraint ( element , ** kw ) <NEWLINE> <DEDENT> elif isinstance ( constraint , schema . CheckConstraint ) : <NEWLINE> <INDENT> raise NotImplementedError ( <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> raise NotImplementedError ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Redefine SQLAlchemy's drop constraint to\"\"\"", "\"MySQL does not support CHECK constraints.\"", "\"No generic 'DROP CONSTRAINT' in MySQL - \"", "\"please specify constraint type\""]}, "err_obj": {"msg": "invalid syntax"}}], ["e627556145994bb1c7b9f47b081ce0c0", {"code_string": "def recent(request):\n    return render(request, 'index.html', {\n        'signals': Signal.objects.filter(status__in = ('ACCEPTED', 'PROFIT', 'LOSS', 'BE', 'PENDING', 'LIVE').order_by(\n            '-server_time')[: 10]\n    })\n", "code_toks_joined": "def recent ( request ) : <NEWLINE> <INDENT> return render ( request , <STRING> , { <NEWLINE> <INDENT> <STRING> : Signal . objects . filter ( status__in = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) . order_by ( <NEWLINE> <INDENT> <STRING> ) [ : 10 ] <NEWLINE> <DEDENT> <DEDENT> } ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'index.html'", "'signals'", "'ACCEPTED'", "'PROFIT'", "'LOSS'", "'BE'", "'PENDING'", "'LIVE'", "'-server_time'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["4ea9a1777a85befb90e83b000f2181f8", {"code_string": "def removed_same_coordinate(verts):\n    d = OrderedDict(zip((tuple(v.co) for v in verts), range(len(verts)))\n    return[verts[i] for i in d.values()]\n", "code_toks_joined": "def removed_same_coordinate ( verts ) : <NEWLINE> <INDENT> d = OrderedDict ( zip ( ( tuple ( v . co ) for v in verts ) , range ( len ( verts ) ) ) <NEWLINE> return [ verts [ i ] for i in d . values ( ) ] <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["1570cd266b41fb24589f94c8b967bbc3", {"code_string": "def visit_callmod(self, node, (l, args, r)):\n    if args:\n        return lambda expr: Call(expr, args[0])\n    else:\n        return lambda expr: Call(expr, [])\n", "code_toks_joined": "def visit_callmod ( self , node , ( l , args , r ) ) : <NEWLINE> <INDENT> if args : <NEWLINE> <INDENT> return lambda expr : Call ( expr , args [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return lambda expr : Call ( expr , [ ] ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["463bd24f77baa8feaedb1ab821addaec", {"code_string": "def __info__(self):\n    info = []\n    info.append(('bias', self._bias))\n    info.append(('centre', self._centre)\n    info.append(('widths', self._widths))\n    return info\n", "code_toks_joined": "def __info__ ( self ) : <NEWLINE> <INDENT> info = [ ] <NEWLINE> info . append ( ( <STRING> , self . _bias ) ) <NEWLINE> info . append ( ( <STRING> , self . _centre ) <NEWLINE> info . append ( ( <STRING> , self . _widths ) ) <NEWLINE> return info <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'bias'", "'centre'", "'widths'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["afb98e6ef7473e8a0ba241ef46c100ab", {"code_string": "def getFromRecentChanges():\n    gen = pagegenerators.RecentchangesPageGenerator(site = self.site)\n    ecart_minimal_requis = 30\n    for Page in pagegenerators.PreloadingGenerator(gen, 100):\n        if debugLevel > 0:\n            print str(lastEditTime(Page)) + ' =? ' + str(ecart_minimal_requis)\n        if lastEditTime(Page) > ecart_minimal_requis:\n            c.creation(Page.title())\n", "code_toks_joined": "def getFromRecentChanges ( ) : <NEWLINE> <INDENT> gen = pagegenerators . RecentchangesPageGenerator ( site = self . site ) <NEWLINE> ecart_minimal_requis = 30 <NEWLINE> for Page in pagegenerators . PreloadingGenerator ( gen , 100 ) : <NEWLINE> <INDENT> if debugLevel > 0 : <NEWLINE> <INDENT> print str ( lastEditTime ( Page ) ) + <STRING> + str ( ecart_minimal_requis ) <NEWLINE> <DEDENT> if lastEditTime ( Page ) > ecart_minimal_requis : <NEWLINE> <INDENT> c . creation ( Page . title ( ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["' =? '"]}, "err_obj": {"msg": "invalid syntax"}}], ["ab23915cea36a352309289161b164fa0", {"code_string": "def __undistort_chessboard_images(self):\n    if self.__is_stage_complete(self.STAGE_COMPUTED_OBJ_AND_IMG_POINTS) and not self.__is_stage_complete(\n        self.STAGE_UNDISTORED_CALIBRATION_IMAGES):\n        for fname in self.__calibration_images:\n        img = mpimg.imread(fname)\n        undistorted = self.undistort(img)\n        undist_file = 'camera_cal/undistorted/{}'.format(os.path.basename(fname))\n        cv2.imwrite(undist_file, undistorted)\n        self.__apply_stage(self.STAGE_UNDISTORED_CALIBRATION_IMAGES)\n", "code_toks_joined": "def __undistort_chessboard_images ( self ) : <NEWLINE> <INDENT> if self . __is_stage_complete ( self . STAGE_COMPUTED_OBJ_AND_IMG_POINTS ) and not self . __is_stage_complete ( <NEWLINE> <INDENT> self . STAGE_UNDISTORED_CALIBRATION_IMAGES ) : <NEWLINE> for fname in self . __calibration_images : <NEWLINE> img = mpimg . imread ( fname ) <NEWLINE> undistorted = self . undistort ( img ) <NEWLINE> undist_file = <STRING> . format ( os . path . basename ( fname ) ) <NEWLINE> cv2 . imwrite ( undist_file , undistorted ) <NEWLINE> self . __apply_stage ( self . STAGE_UNDISTORED_CALIBRATION_IMAGES ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'camera_cal/undistorted/{}'"]}, "err_obj": {"msg": "expected an indented block"}}], ["abf9a566c7b44cad1f0aff0d39f0f57a", {"code_string": "def out(t):\n    integrator.fwdSeed(\"x0\").set([1, 0])\n        integrator.evaluate(1, 0)\n    A = integrator.fwdSens().toArray()\n    integrator.fwdSeed(\"x0\").set([0, 1])\n    integrator.evaluate(1, 0)\n    B = integrator.fwdSens().toArray()\n    return array([A, B]).squeeze().T\n", "code_toks_joined": "def out ( t ) : <NEWLINE> <INDENT> integrator . fwdSeed ( <STRING> ) . set ( [ 1 , 0 ] ) <NEWLINE> <INDENT> integrator . evaluate ( 1 , 0 ) <NEWLINE> <DEDENT> A = integrator . fwdSens ( ) . toArray ( ) <NEWLINE> integrator . fwdSeed ( <STRING> ) . set ( [ 0 , 1 ] ) <NEWLINE> integrator . evaluate ( 1 , 0 ) <NEWLINE> B = integrator . fwdSens ( ) . toArray ( ) <NEWLINE> return array ( [ A , B ] ) . squeeze ( ) . T <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"x0\"", "\"x0\""]}, "err_obj": {"msg": "unexpected indent"}}], ["a6357e77f17de9877e1806a7f1767f0d", {"code_string": "def _check_query(self, query):\n    \"\"\"Check query validity with regex\"\"\"\n    if not(self.word_re.match(query) or\n        self.multiple_word_re.match(query):\n        return False\n    else:\n        return True\n", "code_toks_joined": "def _check_query ( self , query ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not ( self . word_re . match ( query ) or <NEWLINE> <INDENT> self . multiple_word_re . match ( query ) : <NEWLINE> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Check query validity with regex\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["19bc7af433de9202db8c1433099bd639", {"code_string": "def disneychannelGetStreamingUrl(url):\n    if debug == True: Log(\"Running disneychannelGetStreamingUrl()...\")\n    try:\n    content = getURL(url)\n    match = re.compile('embedURL\":\"(.+?)\",', re.DOTALL).findall(content)\n    content = getURL(match[0])\n    match2 = re.compile('url\":\"https://once-eu.unicornmedia.com(.+?)\"', re.DOTALL).findall(content)\n    finalURL = 'http://once-eu.unicornmedia.com' + match2[0]\n    return Redirect(finalURL)\n    except Exception as e:\n        if debug == True: Log(\"ERROR: \" + str(e))\n", "code_toks_joined": "def disneychannelGetStreamingUrl ( url ) : <NEWLINE> <INDENT> if debug == True : Log ( <STRING> ) <NEWLINE> try : <NEWLINE> content = getURL ( url ) <NEWLINE> match = re . compile ( <STRING> , re . DOTALL ) . findall ( content ) <NEWLINE> content = getURL ( match [ 0 ] ) <NEWLINE> match2 = re . compile ( <STRING> , re . DOTALL ) . findall ( content ) <NEWLINE> finalURL = <STRING> + match2 [ 0 ] <NEWLINE> return Redirect ( finalURL ) <NEWLINE> except Exception as e : <NEWLINE> <INDENT> if debug == True : Log ( <STRING> + str ( e ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Running disneychannelGetStreamingUrl()...\"", "'embedURL\":\"(.+?)\",'", "'url\":\"https://once-eu.unicornmedia.com(.+?)\"'", "'http://once-eu.unicornmedia.com'", "\"ERROR: \""]}, "err_obj": {"msg": "expected an indented block"}}], ["36fe059850dbf2ae288a0d17f2528bfd", {"code_string": "def get_metadata(cls, video_id):\n    url = \"https://api.dailymotion.com/video/{}\".format(video_id)\n    try:\n        response = requests.get(url, params = {\n            'fields': 'id,title,description,thumbnail_url'\n        })\n        return response.json()\n    except RequestException, e:\n        logger.warn(\"Error requesting dailymotion metadata: {}\", e)\n        return{}\n", "code_toks_joined": "def get_metadata ( cls , video_id ) : <NEWLINE> <INDENT> url = <STRING> . format ( video_id ) <NEWLINE> try : <NEWLINE> <INDENT> response = requests . get ( url , params = { <NEWLINE> <INDENT> <STRING> : <STRING> <NEWLINE> <DEDENT> } ) <NEWLINE> return response . json ( ) <NEWLINE> <DEDENT> except RequestException , e : <NEWLINE> <INDENT> logger . warn ( <STRING> , e ) <NEWLINE> return { } <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"https://api.dailymotion.com/video/{}\"", "'fields'", "'id,title,description,thumbnail_url'", "\"Error requesting dailymotion metadata: {}\""]}, "err_obj": {"msg": "invalid syntax"}}], ["fb92bd9c7c12f2be6df8de9fbe825f36", {"code_string": "def _closedrepr(oldmethod):\n    \"\"\"Decorate string representation method to handle closed nodes.\"\"\"\n    def newmethod(self):\n        if not self._v_isopen:\n            cmod = self.__class__.__module__\n            cname = self.__class__.__name__\n            addr = hex(id(self)\n            return '<closed %s.%s at %s>' %(cmod, cname, addr)\n        return oldmethod(self)\n    newmethod.__name__ = oldmethod.__name__\n    newmethod.__doc__ = oldmethod.__doc__\n    return newmethod\n", "code_toks_joined": "def _closedrepr ( oldmethod ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def newmethod ( self ) : <NEWLINE> <INDENT> if not self . _v_isopen : <NEWLINE> <INDENT> cmod = self . __class__ . __module__ <NEWLINE> cname = self . __class__ . __name__ <NEWLINE> addr = hex ( id ( self ) <NEWLINE> return <STRING> % ( cmod , cname , addr ) <NEWLINE> <DEDENT> return oldmethod ( self ) <NEWLINE> <DEDENT> newmethod . __name__ = oldmethod . __name__ <NEWLINE> newmethod . __doc__ = oldmethod . __doc__ <NEWLINE> return newmethod <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Decorate string representation method to handle closed nodes.\"\"\"", "'<closed %s.%s at %s>'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["467a3dd77a49336fbeae94016bc7ea24", {"code_string": "class Iload(Instruction, PushInstruction):\n    def __init__(self, line, variable):\n    Instruction.__init__(self, line)\n    self.sourceLocal = variable\n    PushInstruction.__init__(self)\n", "code_toks_joined": "class Iload ( Instruction , PushInstruction ) : <NEWLINE> <INDENT> def __init__ ( self , line , variable ) : <NEWLINE> Instruction . __init__ ( self , line ) <NEWLINE> self . sourceLocal = variable <NEWLINE> PushInstruction . __init__ ( self ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["e34b6e2b3340786b96740ec7da8687eb", {"code_string": "class UT(BaseChannel):\n    playable = True\n    short_name = 'ut'\n    long_name = 'Ukraine Today'\n    default_action = 'play_stream'\n    def action_play_stream(self):\n    self.plugin.set_stream_url('http://stream2g01-g50.1plus1.ua/380555/smil:380555.smil/playlist.m3u8')\n", "code_toks_joined": "class UT ( BaseChannel ) : <NEWLINE> <INDENT> playable = True <NEWLINE> short_name = <STRING> <NEWLINE> long_name = <STRING> <NEWLINE> default_action = <STRING> <NEWLINE> def action_play_stream ( self ) : <NEWLINE> self . plugin . set_stream_url ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'ut'", "'Ukraine Today'", "'play_stream'", "'http://stream2g01-g50.1plus1.ua/380555/smil:380555.smil/playlist.m3u8'"]}, "err_obj": {"msg": "expected an indented block"}}], ["08c5736c4d46771d858b22001f0791c8", {"code_string": "def overlaps((u1, v1), (u2, v2)):\n    ''' Determine whether [u1, v2] overlaps [u2, v2]. '''\n    assert u1 <= v1\n    assert u2 <= v2\n    return u1 <= v2 and v1 >= v2\n", "code_toks_joined": "def overlaps ( ( u1 , v1 ) , ( u2 , v2 ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> assert u1 <= v1 <NEWLINE> assert u2 <= v2 <NEWLINE> return u1 <= v2 and v1 >= v2 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''' Determine whether [u1, v2] overlaps [u2, v2]. '''"]}, "err_obj": {"msg": "invalid syntax"}}], ["44b8169961d517286a1f565b8273c719", {"code_string": "def test_extended_arg(self):\n    longexpr = 'x = x or ' + '-x' * 2500\n    code = '''def f(x):''' %((longexpr, ) * 10)\n    exec code\n    self.assertEqual(f(5), 0)\n", "code_toks_joined": "def test_extended_arg ( self ) : <NEWLINE> <INDENT> longexpr = <STRING> + <STRING> * 2500 <NEWLINE> code = <STRING> % ( ( longexpr , ) * 10 ) <NEWLINE> exec code <NEWLINE> self . assertEqual ( f ( 5 ) , 0 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'x = x or '", "'-x'", "'''def f(x):'''"]}, "err_obj": {"msg": "invalid syntax"}}], ["346137fd08f3f81f2ed4f3862fbe8d24", {"code_string": "class clear_impl:\n    def __repr__(self):\n    global _last_exc, _last_level, frame\n        _last_exc = None\n        frame = None\n", "code_toks_joined": "class clear_impl : <NEWLINE> <INDENT> def __repr__ ( self ) : <NEWLINE> global _last_exc , _last_level , frame <NEWLINE> <INDENT> _last_exc = None <NEWLINE> frame = None <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["7f0effb7fc789a7912f260f61c290d71", {"code_string": "def check_requirements():\n    for tool in['STAR', 'seqcluster', 'samtools',\n        'bedtools']:\n        try:\n        config_utils.get_program(tool, {})\n        print(\"Tool installed: %s\" % tool)\n        except Exception, e:\n        print(\"Error: Tool not found: %s\" % tool)\n        raise(e)\n    print(\"Everything is fine.\")\n", "code_toks_joined": "def check_requirements ( ) : <NEWLINE> <INDENT> for tool in [ <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ] : <NEWLINE> try : <NEWLINE> config_utils . get_program ( tool , { } ) <NEWLINE> print ( <STRING> % tool ) <NEWLINE> except Exception , e : <NEWLINE> print ( <STRING> % tool ) <NEWLINE> raise ( e ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'STAR'", "'seqcluster'", "'samtools'", "'bedtools'", "\"Tool installed: %s\"", "\"Error: Tool not found: %s\"", "\"Everything is fine.\""]}, "err_obj": {"msg": "expected an indented block"}}], ["87665fa4ad0369868a54f0626760fe50", {"code_string": "class NullDecoder(AbstractSimpleDecoder):\n    protoComponent = univ.Null('')\n    def valueDecoder(self, fullSubstrate, substrate, asn1Spec, tagSet,\n        length, state, decodeFun, substrateFun):\n        head, tail = substrate[: length], substrate[length: ]\n        r = self._createComponent(asn1Spec, tagSet)\n        if head:\n        raise error.PyAsn1Error('Unexpected %d-octet substrate for Null' % length)\n        return r, tail\n", "code_toks_joined": "class NullDecoder ( AbstractSimpleDecoder ) : <NEWLINE> <INDENT> protoComponent = univ . Null ( <STRING> ) <NEWLINE> def valueDecoder ( self , fullSubstrate , substrate , asn1Spec , tagSet , <NEWLINE> <INDENT> length , state , decodeFun , substrateFun ) : <NEWLINE> head , tail = substrate [ : length ] , substrate [ length : ] <NEWLINE> r = self . _createComponent ( asn1Spec , tagSet ) <NEWLINE> if head : <NEWLINE> raise error . PyAsn1Error ( <STRING> % length ) <NEWLINE> return r , tail <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "'Unexpected %d-octet substrate for Null'"]}, "err_obj": {"msg": "expected an indented block"}}], ["dff9cef2d8d26289da9cc6584c9dbfb2", {"code_string": "def tryXorBreak(ciphertext, distribution = English1Grams):\n    return min([\n    {\"Text\": repKeyXor(ciphertext, char), \"Key\": char}\n    for char in allCharacters],\n    key = lambda result: distribution.surprise(str(result[\"Text\"]).lower())\n", "code_toks_joined": "def tryXorBreak ( ciphertext , distribution = English1Grams ) : <NEWLINE> <INDENT> return min ( [ <NEWLINE> { <STRING> : repKeyXor ( ciphertext , char ) , <STRING> : char } <NEWLINE> for char in allCharacters ] , <NEWLINE> key = lambda result : distribution . surprise ( str ( result [ <STRING> ] ) . lower ( ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Text\"", "\"Key\"", "\"Text\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["231304dca061758fe18baadec00d3e77", {"code_string": "def test_port_unbound(self):\n    map = {\n        'network_type': 'vlan',\n        'vswitch_name': 'fake-vswitch',\n        'ports': [],\n        'vlan_id': 1}\n    net_uuid = 'my-net-uuid'\n    network_vswitch_map = (net_uuid, map)\n    with mock.patch.object(self.agent,\n        '_get_network_vswitch_map_by_port_id',\n        return_value = network_vswitch_map):\n        with mock.patch.object(\n        self.agent._utils,\n        'disconnect_switch_port'):\n        self.agent._port_unbound(net_uuid)\n", "code_toks_joined": "def test_port_unbound ( self ) : <NEWLINE> <INDENT> map = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : [ ] , <NEWLINE> <STRING> : 1 } <NEWLINE> <DEDENT> net_uuid = <STRING> <NEWLINE> network_vswitch_map = ( net_uuid , map ) <NEWLINE> with mock . patch . object ( self . agent , <NEWLINE> <INDENT> <STRING> , <NEWLINE> return_value = network_vswitch_map ) : <NEWLINE> with mock . patch . object ( <NEWLINE> self . agent . _utils , <NEWLINE> <STRING> ) : <NEWLINE> self . agent . _port_unbound ( net_uuid ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'network_type'", "'vlan'", "'vswitch_name'", "'fake-vswitch'", "'ports'", "'vlan_id'", "'my-net-uuid'", "'_get_network_vswitch_map_by_port_id'", "'disconnect_switch_port'"]}, "err_obj": {"msg": "expected an indented block"}}], ["45f56a38c938fedd720d46c55a9ddbd6", {"code_string": "def test4_center(self):\n    self.t.set_align_mode('center')\n    expected = [B(t) for t in \"    I walk the    \", \" city in the night\"]\n    got = self.t.render((18, ))._text\n    assert got == expected, \"got: %r expected: %r\" %(got, expected)\n", "code_toks_joined": "def test4_center ( self ) : <NEWLINE> <INDENT> self . t . set_align_mode ( <STRING> ) <NEWLINE> expected = [ B ( t ) for t in <STRING> , <STRING> ] <NEWLINE> got = self . t . render ( ( 18 , ) ) . _text <NEWLINE> assert got == expected , <STRING> % ( got , expected ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'center'", "\"    I walk the    \"", "\" city in the night\"", "\"got: %r expected: %r\""]}, "err_obj": {"msg": "invalid syntax"}}], ["94c7bd198ecad789d6d44661ffcaab26", {"code_string": "def _get_tables(self):\n    for names, table in[(self._setting_table_names, self.setting_table),\n        (self._variable_table_names, self.variable_table),\n        (self._testcase_table_names, self.testcase_table),\n        (self._keyword_table_names, self.keyword_table)]:\n        for name in names:\n        yield name, table\n", "code_toks_joined": "def _get_tables ( self ) : <NEWLINE> <INDENT> for names , table in [ ( self . _setting_table_names , self . setting_table ) , <NEWLINE> <INDENT> ( self . _variable_table_names , self . variable_table ) , <NEWLINE> ( self . _testcase_table_names , self . testcase_table ) , <NEWLINE> ( self . _keyword_table_names , self . keyword_table ) ] : <NEWLINE> for name in names : <NEWLINE> yield name , table <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["38cd586d10e5a264768ea7be665b492b", {"code_string": "def worker(virt):\n    \"\"\"Worker thread (infinite) loop of virtio_guest.\"\"\"\n    global exiting\n    print(\"PASS: Start\")\n    while not exiting:\n        str = raw_input()\n        try:\n            exec str\n        except:\n            exc_type, exc_value, exc_traceback = sys.exc_info()\n            print(\"On Guest exception from: \\n\" + \"\".join(\n                traceback.format_exception(exc_type,\n                    exc_value,\n                    exc_traceback)))\n", "code_toks_joined": "def worker ( virt ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> global exiting <NEWLINE> print ( <STRING> ) <NEWLINE> while not exiting : <NEWLINE> <INDENT> str = raw_input ( ) <NEWLINE> try : <NEWLINE> <INDENT> exec str <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> exc_type , exc_value , exc_traceback = sys . exc_info ( ) <NEWLINE> print ( <STRING> + <STRING> . join ( <NEWLINE> <INDENT> traceback . format_exception ( exc_type , <NEWLINE> <INDENT> exc_value , <NEWLINE> exc_traceback ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Worker thread (infinite) loop of virtio_guest.\"\"\"", "\"PASS: Start\"", "\"On Guest exception from: \\n\"", "\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["ca40a9185b9bd12af86a666157cd19ac", {"code_string": "def reviewed_by(cls, user):\n    \"\"\"Returns two lists: cases being reviewed by the user vs by other users.\"\"\"\n    these_cases, other_cases = [], []\n    for case in cls.query_under_review().run():\n        if case.reviewer == user:\n        these_cases.append(case)\n        else:\n        other_cases.append(case)\n    return these_cases, other_cases\n", "code_toks_joined": "def reviewed_by ( cls , user ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> these_cases , other_cases = [ ] , [ ] <NEWLINE> for case in cls . query_under_review ( ) . run ( ) : <NEWLINE> <INDENT> if case . reviewer == user : <NEWLINE> these_cases . append ( case ) <NEWLINE> else : <NEWLINE> other_cases . append ( case ) <NEWLINE> <DEDENT> return these_cases , other_cases <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns two lists: cases being reviewed by the user vs by other users.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["b417544f5c442d8694f111eba82fd34e", {"code_string": "def handle_endtag(self, tag):\n    if not self.open_tags:\n        self.error(\"Unexpected end tag `%s`(%s)\" %(\n            tag, self.format_position()))\n    element = self.open_tags.pop()\n    while element.name != tag:\n        if not self.open_tags:\n            self.error(\"Unexpected end tag `%s`(%s)\" %(\n                tag, self.format_position())\n        element = self.open_tags.pop()\n", "code_toks_joined": "def handle_endtag ( self , tag ) : <NEWLINE> <INDENT> if not self . open_tags : <NEWLINE> <INDENT> self . error ( <STRING> % ( <NEWLINE> <INDENT> tag , self . format_position ( ) ) ) <NEWLINE> <DEDENT> <DEDENT> element = self . open_tags . pop ( ) <NEWLINE> while element . name != tag : <NEWLINE> <INDENT> if not self . open_tags : <NEWLINE> <INDENT> self . error ( <STRING> % ( <NEWLINE> <INDENT> tag , self . format_position ( ) ) <NEWLINE> <DEDENT> <DEDENT> element = self . open_tags . pop ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Unexpected end tag `%s`(%s)\"", "\"Unexpected end tag `%s`(%s)\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["8580c2621f81c8fa731cbfaff2756eae", {"code_string": "def test_3_join_in_forked_from_thread(self):\n    import os\n    if not hasattr(os, 'fork'):\n        return\n    if sys.platform in('freebsd4', 'freebsd5', 'freebsd6', 'netbsd5',\n        'os2emx'):\n        print('Skipping test_3_join_in_forked_from_thread'\n            ' due to known OS bugs on'), sys.platform\n            return\n    script = \"\"\"if 1:\"\"\"\n    self._run_and_join(script)\n", "code_toks_joined": "def test_3_join_in_forked_from_thread ( self ) : <NEWLINE> <INDENT> import os <NEWLINE> if not hasattr ( os , <STRING> ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if sys . platform in ( <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> print ( <STRING> <NEWLINE> <INDENT> <STRING> ) , sys . platform <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> script = <STRING> <NEWLINE> self . _run_and_join ( script ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'fork'", "'freebsd4'", "'freebsd5'", "'freebsd6'", "'netbsd5'", "'os2emx'", "'Skipping test_3_join_in_forked_from_thread'", "' due to known OS bugs on'", "\"\"\"if 1:\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["55c32fcc81887081fa9e68eb72ab5019", {"code_string": "def disable_igmp(self):\n    \"\"\"Disable IGMP\"\"\"\n        hpSwitchIgmpState = (1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 7, 1, 15, 1, 1, 2)\n    self.switch.snmp_set((hpSwitchIgmpState +(self.vid, ), rfc1902.Integer(2)))\n", "code_toks_joined": "def disable_igmp ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> hpSwitchIgmpState = ( 1 , 3 , 6 , 1 , 4 , 1 , 11 , 2 , 14 , 11 , 5 , 1 , 7 , 1 , 15 , 1 , 1 , 2 ) <NEWLINE> <DEDENT> self . switch . snmp_set ( ( hpSwitchIgmpState + ( self . vid , ) , rfc1902 . Integer ( 2 ) ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Disable IGMP\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["f19e369b178746cac42519f2c680f076", {"code_string": "def test_padding(self):\n    self._test_format(\"%20.f\", - 42, grouping = 0, out = '-42'.rjust(20))\n    self._test_format(\"%+10.f\", - 4200, grouping = 0, out = '-4200'.rjust(10))\n    self._test_format(\"%-10.f\", 4200, grouping = 0, out = '4200'.ljust(10)\n", "code_toks_joined": "def test_padding ( self ) : <NEWLINE> <INDENT> self . _test_format ( <STRING> , - 42 , grouping = 0 , out = <STRING> . rjust ( 20 ) ) <NEWLINE> self . _test_format ( <STRING> , - 4200 , grouping = 0 , out = <STRING> . rjust ( 10 ) ) <NEWLINE> self . _test_format ( <STRING> , 4200 , grouping = 0 , out = <STRING> . ljust ( 10 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"%20.f\"", "'-42'", "\"%+10.f\"", "'-4200'", "\"%-10.f\"", "'4200'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["516f05ff6d94cd8f6b09cd484e158165", {"code_string": "def retranslateUi(self, ApplyCalleeDialog):\n    ApplyCalleeDialog.setWindowTitle(QtGui.QApplication.translate(\"ApplyCalleeDialog\", \"ApplyCalleeType\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label.setText(QtGui.QApplication.translate(\"ApplyCalleeDialog\", \"Enter Type\\n\"\n", "code_toks_joined": "def retranslateUi ( self , ApplyCalleeDialog ) : <NEWLINE> <INDENT> ApplyCalleeDialog . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"ApplyCalleeDialog\"", "\"ApplyCalleeType\"", "\"ApplyCalleeDialog\"", "\"Enter Type\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["891455c7a3f0e4023acc9aac4fb5d65b", {"code_string": "def test_add(self):\n    for i in range(size * 2):\n        trans = generate_transition()\n        self.buffer.add(* trans, ,\n    self.assertTrue(True)\n", "code_toks_joined": "def test_add ( self ) : <NEWLINE> <INDENT> for i in range ( size * 2 ) : <NEWLINE> <INDENT> trans = generate_transition ( ) <NEWLINE> self . buffer . add ( * trans , , <NEWLINE> <DEDENT> self . assertTrue ( True ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["ed64adc781981dc0249eee5bcbd7b274", {"code_string": "def train(PATH, batch, epochs):\n    img = load_img(PATH)\n    for epoch in range(epochs):\n        if(epoch == 0):\n            if os.path.exist('generator_weights') ans os.path.exist('discriminator_weights'):\n                print(\"Loading Saved Weights..\")\n                generator.load_weights('generator_weights')\n                discriminator.load_weights('discriminator_weights')\n                print(\"Finished Loading\")\n                pass\n", "code_toks_joined": "def train ( PATH , batch , epochs ) : <NEWLINE> <INDENT> img = load_img ( PATH ) <NEWLINE> for epoch in range ( epochs ) : <NEWLINE> <INDENT> if ( epoch == 0 ) : <NEWLINE> <INDENT> if os . path . exist ( <STRING> ) ans os . path . exist ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> generator . load_weights ( <STRING> ) <NEWLINE> discriminator . load_weights ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'generator_weights'", "'discriminator_weights'", "\"Loading Saved Weights..\"", "'generator_weights'", "'discriminator_weights'", "\"Finished Loading\""]}, "err_obj": {"msg": "invalid syntax"}}], ["b39cda108d12c8f57f623c479f0f2670", {"code_string": "def readline(self size = - 1):\n    self._empty_stderr()\n    return self.process.stdout.readline(size)\n", "code_toks_joined": "def readline ( self size = - 1 ) : <NEWLINE> <INDENT> self . _empty_stderr ( ) <NEWLINE> return self . process . stdout . readline ( size ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["1d97ed6cc6391bab09163746a8719660", {"code_string": "def _after_request_callback(self, exc, permid):\n    \"\"\"Called by the Crawler with the result of the request_callback\"\"\"\n    if not exc:\n        if DEBUG: print \"usereventlogcrawler: request send to\", show_permid_short(permid)\n        msg = \"; \".join(['REQUEST', show_permid(permid)])\n        self.__log(msg)\n", "code_toks_joined": "def _after_request_callback ( self , exc , permid ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not exc : <NEWLINE> <INDENT> if DEBUG : print <STRING> , show_permid_short ( permid ) <NEWLINE> msg = <STRING> . join ( [ <STRING> , show_permid ( permid ) ] ) <NEWLINE> self . __log ( msg ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Called by the Crawler with the result of the request_callback\"\"\"", "\"usereventlogcrawler: request send to\"", "\"; \"", "'REQUEST'"]}, "err_obj": {"msg": "invalid syntax"}}], ["d38c798036edd76a8ee437f453f71483", {"code_string": "def test_connection(self):\n    engine = self._connect()\n    list(engine.connection.list_tables()))\n", "code_toks_joined": "def test_connection ( self ) : <NEWLINE> <INDENT> engine = self . _connect ( ) <NEWLINE> list ( engine . connection . list_tables ( ) ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["992cf68a611ac45b2a37b7d70e66453e", {"code_string": "def get_branch(self):\n    if not self.ov_list:\n        self._get_ov_list()\n    branches = []\n    for ov in self.ov_list:\n        branches[ov['name']] = ov['branch']\n        if self.type == 'git':\n        return(XEbuildGit.get_branch(self), branches)\n        else:\n        return(XEbuildHG.get_branch(self), branches)\n", "code_toks_joined": "def get_branch ( self ) : <NEWLINE> <INDENT> if not self . ov_list : <NEWLINE> <INDENT> self . _get_ov_list ( ) <NEWLINE> <DEDENT> branches = [ ] <NEWLINE> for ov in self . ov_list : <NEWLINE> <INDENT> branches [ ov [ <STRING> ] ] = ov [ <STRING> ] <NEWLINE> if self . type == <STRING> : <NEWLINE> return ( XEbuildGit . get_branch ( self ) , branches ) <NEWLINE> else : <NEWLINE> return ( XEbuildHG . get_branch ( self ) , branches ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'name'", "'branch'", "'git'"]}, "err_obj": {"msg": "expected an indented block"}}], ["c745d11eef3b416d28da87908491034e", {"code_string": "def OnSDLNotify(self, VARname, SDLname, playerID, tag):\n    ageSDL = PtGetAgeSDL()\n    print(\"kdshVault.OnSDLNotify:\\tVARname=\", VARname, \" value=\", ageSDL[VARname][0])\n    if VARname == \"ButtonsPushed\":\n        ButtonsPushed = ageSDL[\"ButtonsPushed\"][0]\n        if ButtonsPushed == 0:\n            return\n        ButtonsPushed = str(ButtonsPushed)\n        lastbuttonpushed = ButtonsPushed[- 1: ]\n        print(\"kdshVault.OnSDLNotify: new ButtonsPushed = \", ButtonsPushed)\n        code = \"respButton\" + str(lastbuttonpushed) + \".run(self.key)\"\n        exec code\n        code = \"actButton\" + str(lastbuttonpushed) + \".disable()\"\n        exec code\n", "code_toks_joined": "def OnSDLNotify ( self , VARname , SDLname , playerID , tag ) : <NEWLINE> <INDENT> ageSDL = PtGetAgeSDL ( ) <NEWLINE> print ( <STRING> , VARname , <STRING> , ageSDL [ VARname ] [ 0 ] ) <NEWLINE> if VARname == <STRING> : <NEWLINE> <INDENT> ButtonsPushed = ageSDL [ <STRING> ] [ 0 ] <NEWLINE> if ButtonsPushed == 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> ButtonsPushed = str ( ButtonsPushed ) <NEWLINE> lastbuttonpushed = ButtonsPushed [ - 1 : ] <NEWLINE> print ( <STRING> , ButtonsPushed ) <NEWLINE> code = <STRING> + str ( lastbuttonpushed ) + <STRING> <NEWLINE> exec code <NEWLINE> code = <STRING> + str ( lastbuttonpushed ) + <STRING> <NEWLINE> exec code <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"kdshVault.OnSDLNotify:\\tVARname=\"", "\" value=\"", "\"ButtonsPushed\"", "\"ButtonsPushed\"", "\"kdshVault.OnSDLNotify: new ButtonsPushed = \"", "\"respButton\"", "\".run(self.key)\"", "\"actButton\"", "\".disable()\""]}, "err_obj": {"msg": "invalid syntax"}}], ["9e448d3e8854dcc2819b5f9027e95d3a", {"code_string": "def test_datetime(self):\n    \"\"\"get/set timestamps with datetime objects\"\"\"\n    msg_id = self.db.get_history()[- 1]\n    rec = self.db.get_record(msg_id)\n    self.assertTrue(isinstance(rec['submitted'], datetime)\n    self.db.update_record(msg_id, dict(completed = datetime.now()))\n    rec = self.db.get_record(msg_id)\n    self.assertTrue(isinstance(rec['completed'], datetime))\n", "code_toks_joined": "def test_datetime ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> msg_id = self . db . get_history ( ) [ - 1 ] <NEWLINE> rec = self . db . get_record ( msg_id ) <NEWLINE> self . assertTrue ( isinstance ( rec [ <STRING> ] , datetime ) <NEWLINE> self . db . update_record ( msg_id , dict ( completed = datetime . now ( ) ) ) <NEWLINE> rec = self . db . get_record ( msg_id ) <NEWLINE> self . assertTrue ( isinstance ( rec [ <STRING> ] , datetime ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"get/set timestamps with datetime objects\"\"\"", "'submitted'", "'completed'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c394ad03ebf6ef0ca4e74fa4c0f88338", {"code_string": "def getFromAllRedirects(self):\n    for Page in self.site.allpages(start = u'', namespace = 0, includeredirects = 'only'):\n        if debugLevel > 0: print Page.title()\n        c.creation(Page.title())\n", "code_toks_joined": "def getFromAllRedirects ( self ) : <NEWLINE> <INDENT> for Page in self . site . allpages ( start = <STRING> , namespace = 0 , includeredirects = <STRING> ) : <NEWLINE> <INDENT> if debugLevel > 0 : print Page . title ( ) <NEWLINE> c . creation ( Page . title ( ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["u''", "'only'"]}, "err_obj": {"msg": "invalid syntax"}}], ["dbd20f72df7e384b9472d2254fb6dd2b", {"code_string": "def updateFunction(newValues, runningCount):\n    if runningCount is None:\n    runningCount = 0\n    return sum(newValues, runningCount)\n", "code_toks_joined": "def updateFunction ( newValues , runningCount ) : <NEWLINE> <INDENT> if runningCount is None : <NEWLINE> runningCount = 0 <NEWLINE> return sum ( newValues , runningCount ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["79b9c0a98ad69a08e01cd10aac5bd2e3", {"code_string": "def _op_generic_StoU_saturation(self, value, min_value, max_value):\n    \"\"\"Return unsigned saturated BV from signed BV.\"\"\"\n    return claripy.If(\n        claripy.SGT(value, max_value)\n        max_value,\n        claripy.If(claripy.SLT(value, min_value), min_value, value))\n", "code_toks_joined": "def _op_generic_StoU_saturation ( self , value , min_value , max_value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return claripy . If ( <NEWLINE> <INDENT> claripy . SGT ( value , max_value ) <NEWLINE> max_value , <NEWLINE> claripy . If ( claripy . SLT ( value , min_value ) , min_value , value ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return unsigned saturated BV from signed BV.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["fe5cd71550c7131cfd7ab0b5aaae5812", {"code_string": "def retranslateUi(self, fmtomo_parameters):\n    fmtomo_parameters.setWindowTitle(QtGui.QApplication.translate(\"fmtomo_parameters\", \"Choose FMTOMO parameters\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_19.setText(QtGui.QApplication.translate(\"fmtomo_parameters\", \"Choose parameters for FMTOMO simulation\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_17.setToolTip(QtGui.QApplication.translate(\"fmtomo_parameters\", \"Directory containing a clean FMTOMO installation.\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_17.setText(QtGui.QApplication.translate(\"fmtomo_parameters\", \"FMTOMO\\n\"\n", "code_toks_joined": "def retranslateUi ( self , fmtomo_parameters ) : <NEWLINE> <INDENT> fmtomo_parameters . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_19 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_17 . setToolTip ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_17 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"fmtomo_parameters\"", "\"Choose FMTOMO parameters\"", "\"fmtomo_parameters\"", "\"Choose parameters for FMTOMO simulation\"", "\"fmtomo_parameters\"", "\"Directory containing a clean FMTOMO installation.\"", "\"fmtomo_parameters\"", "\"FMTOMO\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["a5aaf0b80ed20e005e65750d5438c936", {"code_string": "class UpdateLoc(webapp2.RequestHandler):\n    def post(self):\n        try:\n            self.userKey = ndb.Key(urlsafe = self.request.get('userKey'))\n            self.user = self.userKey.get()\n            if(self.user is None):\n                self.response.write(\"yapersone\")\n            else:\n                self.response.write(self.user.firstName)\n        except Exception, e:\n            self.response.write(\"error bad encoding\")\n", "code_toks_joined": "class UpdateLoc ( webapp2 . RequestHandler ) : <NEWLINE> <INDENT> def post ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . userKey = ndb . Key ( urlsafe = self . request . get ( <STRING> ) ) <NEWLINE> self . user = self . userKey . get ( ) <NEWLINE> if ( self . user is None ) : <NEWLINE> <INDENT> self . response . write ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . response . write ( self . user . firstName ) <NEWLINE> <DEDENT> <DEDENT> except Exception , e : <NEWLINE> <INDENT> self . response . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'userKey'", "\"yapersone\"", "\"error bad encoding\""]}, "err_obj": {"msg": "invalid syntax"}}], ["aded6d2d5b5a468a4b150e43f8573ac0", {"code_string": "def unionRect((xMin1, yMin1, xMax1, yMax1), (xMin2, yMin2, xMax2, yMax2)):\n    \"\"\"Return the smallest rectangle in which both input rectangles are fully\"\"\"\n    xMin, yMin, xMax, yMax = (min(xMin1, xMin2), min(yMin1, yMin2),\n        max(xMax1, xMax2), max(yMax1, yMax2))\n    return(xMin, yMin, xMax, yMax)\n", "code_toks_joined": "def unionRect ( ( xMin1 , yMin1 , xMax1 , yMax1 ) , ( xMin2 , yMin2 , xMax2 , yMax2 ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> xMin , yMin , xMax , yMax = ( min ( xMin1 , xMin2 ) , min ( yMin1 , yMin2 ) , <NEWLINE> <INDENT> max ( xMax1 , xMax2 ) , max ( yMax1 , yMax2 ) ) <NEWLINE> <DEDENT> return ( xMin , yMin , xMax , yMax ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return the smallest rectangle in which both input rectangles are fully\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["e5c7dd1e938626460b1f81cec1671c96", {"code_string": "def _resetQ(self):\n    print(\"table erased\")\n    loop0 = 0\n    loop1 = 0\n    loop2 = 0\n    for loop0 in range(200):\n        for loop1 in range(200):\n        for loop2 in range(self.actions):\n            self.QL[loop0, loop1, loop2] = random.random()\n", "code_toks_joined": "def _resetQ ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> loop0 = 0 <NEWLINE> loop1 = 0 <NEWLINE> loop2 = 0 <NEWLINE> for loop0 in range ( 200 ) : <NEWLINE> <INDENT> for loop1 in range ( 200 ) : <NEWLINE> for loop2 in range ( self . actions ) : <NEWLINE> <INDENT> self . QL [ loop0 , loop1 , loop2 ] = random . random ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"table erased\""]}, "err_obj": {"msg": "expected an indented block"}}], ["1a2afe09be278f94184a15f0161ed542", {"code_string": "def database_exists(database_name, ** options):\n    db = options.get('database', DEFAULT_DB_ALIAS)\n    try:\n        connection = connections[db]\n        with connection.cursor() as cursor:\n            cursor.execute(\"SELECT 1 from pg_database WHERE datname='{}'; \".format(database_name))\n            return_value = bool(cursor.fetchone()\n        connections.close_all()\n        return return_value\n    except OperationalError:\n        return False\n", "code_toks_joined": "def database_exists ( database_name , ** options ) : <NEWLINE> <INDENT> db = options . get ( <STRING> , DEFAULT_DB_ALIAS ) <NEWLINE> try : <NEWLINE> <INDENT> connection = connections [ db ] <NEWLINE> with connection . cursor ( ) as cursor : <NEWLINE> <INDENT> cursor . execute ( <STRING> . format ( database_name ) ) <NEWLINE> return_value = bool ( cursor . fetchone ( ) <NEWLINE> <DEDENT> connections . close_all ( ) <NEWLINE> return return_value <NEWLINE> <DEDENT> except OperationalError : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'database'", "\"SELECT 1 from pg_database WHERE datname='{}'; \""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["fc12dadb0bbce43bdea697b2d69c8018", {"code_string": "def run():\n    plugintools.log(\"docu.run\")\n    params = plugintools.get_params()\n    if params.get(\"action\") is None:\n        main_list(params)\n    else:\n        action = params.get(\"action\")\n        exec action + \"(params)\"\n    plugintools.close_item_list()\n", "code_toks_joined": "def run ( ) : <NEWLINE> <INDENT> plugintools . log ( <STRING> ) <NEWLINE> params = plugintools . get_params ( ) <NEWLINE> if params . get ( <STRING> ) is None : <NEWLINE> <INDENT> main_list ( params ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> action = params . get ( <STRING> ) <NEWLINE> exec action + <STRING> <NEWLINE> <DEDENT> plugintools . close_item_list ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"docu.run\"", "\"action\"", "\"action\"", "\"(params)\""]}, "err_obj": {"msg": "invalid syntax"}}], ["91ecfee8e15c8f75c51b7ad88d7b09a1", {"code_string": "def TerminatorThread(long maxExecutionTime, list threads, Workload workload):\n    this.maxExecutionTime = maxExecutionTime\n    this.threads = threads\n    this.workload = workload\n    waitTimeOutInMS = 2000;\n    print(\"Maximum execution time specified as: \" + maxExecutionTime + \" secs\")\n", "code_toks_joined": "def TerminatorThread ( long maxExecutionTime , list threads , Workload workload ) : <NEWLINE> <INDENT> this . maxExecutionTime = maxExecutionTime <NEWLINE> this . threads = threads <NEWLINE> this . workload = workload <NEWLINE> waitTimeOutInMS = 2000 ; <NEWLINE> print ( <STRING> + maxExecutionTime + <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Maximum execution time specified as: \"", "\" secs\""]}, "err_obj": {"msg": "invalid syntax"}}], ["f4d777f427db1d5769f6c271cb7b04e7", {"code_string": "class TestObject(object):\n    def __init__(self):\n        self.v = self.add()\n    def add(self):\n        print('return 1')\n            return 1\n", "code_toks_joined": "class TestObject ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . v = self . add ( ) <NEWLINE> <DEDENT> def add ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'return 1'"]}, "err_obj": {"msg": "unexpected indent"}}], ["e7970fa0545f217a96b8f936b0be66f2", {"code_string": "def _objectIdsToUsers(self, (users, ids)):\n    '''Convert a list of Fluidinfo object ids to a JSON RPC result dict'''\n    if ids:\n        log.err('Unexpected object ids matched query: %r' %(ids, ))\n    return{\n        'result': {\n            'result': True,\n            'users': users}}\n", "code_toks_joined": "def _objectIdsToUsers ( self , ( users , ids ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ids : <NEWLINE> <INDENT> log . err ( <STRING> % ( ids , ) ) <NEWLINE> <DEDENT> return { <NEWLINE> <INDENT> <STRING> : { <NEWLINE> <INDENT> <STRING> : True , <NEWLINE> <STRING> : users } } <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Convert a list of Fluidinfo object ids to a JSON RPC result dict'''", "'Unexpected object ids matched query: %r'", "'result'", "'result'", "'users'"]}, "err_obj": {"msg": "invalid syntax"}}], ["56c0115252417a4f8811b7540885be9e", {"code_string": "def load_tensor_from_event(event):\n    \"\"\"Load a tensor from an Event proto.\"\"\"\n    if(event.summary.value[0].tensor.tensor_content or\n        event.summary.value[0].tensor.string_val):\n        tensor_proto = event.summary.value[0].tensor\n        if tensor_proto.dtype == types_pb2.DT_RESOURCE:\n        return None\n        else:\n        try:\n            tensor_value = tensor_util.MakeNdarray(tensor_proto)\n        except KeyError:\n            tensor_value = None\n    else:\n        tensor_value = None\n    return tensor_value\n", "code_toks_joined": "def load_tensor_from_event ( event ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( event . summary . value [ 0 ] . tensor . tensor_content or <NEWLINE> <INDENT> event . summary . value [ 0 ] . tensor . string_val ) : <NEWLINE> tensor_proto = event . summary . value [ 0 ] . tensor <NEWLINE> if tensor_proto . dtype == types_pb2 . DT_RESOURCE : <NEWLINE> return None <NEWLINE> else : <NEWLINE> try : <NEWLINE> <INDENT> tensor_value = tensor_util . MakeNdarray ( tensor_proto ) <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> tensor_value = None <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tensor_value = None <NEWLINE> <DEDENT> return tensor_value <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Load a tensor from an Event proto.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["ec52a1d6c00a0f686b3c6e79f62ebeab", {"code_string": "def reduction(before, after, cutoff = 0.35):\n    if isinstance(after, str):\n    try:\n    if float(after) == 0.0:\n        return False\n        except:\n    return False\n    if float(after) == 0:\n        return False\n    temp = (before - after) / before\n    return(temp > cutoff)\n", "code_toks_joined": "def reduction ( before , after , cutoff = 0.35 ) : <NEWLINE> <INDENT> if isinstance ( after , str ) : <NEWLINE> try : <NEWLINE> if float ( after ) == 0.0 : <NEWLINE> <INDENT> return False <NEWLINE> except : <NEWLINE> <DEDENT> return False <NEWLINE> if float ( after ) == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> temp = ( before - after ) / before <NEWLINE> return ( temp > cutoff ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["172e086f04ef08e7663ebaf0a39f7d40", {"code_string": "def search(self, query, page = 1, pageSize = 30):\n    try:\n        url = self._urlHelper(self.SEARCH_ENDPOINT, q = query, page = page, count = pageSize)\n        contents = self._getUrlContents(url)\n        data = json.loads(contents)\n        if(self.debugMode): print contents\n        return data\n    except Exception as inst:\n        if(self.debugMode): print inst\n        return None\n", "code_toks_joined": "def search ( self , query , page = 1 , pageSize = 30 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> url = self . _urlHelper ( self . SEARCH_ENDPOINT , q = query , page = page , count = pageSize ) <NEWLINE> contents = self . _getUrlContents ( url ) <NEWLINE> data = json . loads ( contents ) <NEWLINE> if ( self . debugMode ) : print contents <NEWLINE> return data <NEWLINE> <DEDENT> except Exception as inst : <NEWLINE> <INDENT> if ( self . debugMode ) : print inst <NEWLINE> return None <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["3eea4b775bcb70149f8fe7ebaa6fb014", {"code_string": "def getAndSaveTweet(count, page):\n    '''this function is used to get twitter by cron job.'''\n    try:\n        for single_page in tweepy.Cursor(twitter_map_config.twitter_api.search,\n            q = 'i',\n            count = count,\n            result_type = \"recent\",\n            include_entities = True,\n            lang = \"en\").pages(page):\n            for tweet in single_page:\n            res = putTweetToDataStore(tweet)\n            if res == - 1:\n            raise ValueError(res)\n    except Exception, e:\n        print(e)\n        print(\"have reached the rate limit\")\n        return - 1\n    return \"succeed\"\n", "code_toks_joined": "def getAndSaveTweet ( count , page ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> for single_page in tweepy . Cursor ( twitter_map_config . twitter_api . search , <NEWLINE> <INDENT> q = <STRING> , <NEWLINE> count = count , <NEWLINE> result_type = <STRING> , <NEWLINE> include_entities = True , <NEWLINE> lang = <STRING> ) . pages ( page ) : <NEWLINE> for tweet in single_page : <NEWLINE> res = putTweetToDataStore ( tweet ) <NEWLINE> if res == - 1 : <NEWLINE> raise ValueError ( res ) <NEWLINE> <DEDENT> <DEDENT> except Exception , e : <NEWLINE> <INDENT> print ( e ) <NEWLINE> print ( <STRING> ) <NEWLINE> return - 1 <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''this function is used to get twitter by cron job.'''", "'i'", "\"recent\"", "\"en\"", "\"have reached the rate limit\"", "\"succeed\""]}, "err_obj": {"msg": "expected an indented block"}}], ["50a840c8b548bf3e1e5ff999ed231c72", {"code_string": "def __is_bad_pick(t_planet, pl_list):\n    if(t_planet.x + t_planet.rad >= DISP_W - 1) or(t_planet.x - t_planet.rad <= 0):\n        return True\n    if(t_planet.y + self.rad >= DISP_H - 1) or(t_planet.y - self.rad <= BORDER_UP):\n        return True\n    for oth_planet in pl_list:\n        if t_planet.overlaps(self.__overlaps(t_planet):\n            return True\n    return False\n", "code_toks_joined": "def __is_bad_pick ( t_planet , pl_list ) : <NEWLINE> <INDENT> if ( t_planet . x + t_planet . rad >= DISP_W - 1 ) or ( t_planet . x - t_planet . rad <= 0 ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if ( t_planet . y + self . rad >= DISP_H - 1 ) or ( t_planet . y - self . rad <= BORDER_UP ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> for oth_planet in pl_list : <NEWLINE> <INDENT> if t_planet . overlaps ( self . __overlaps ( t_planet ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["471843e15c7823c6274b6b51093a9b4a", {"code_string": "def __setitem__(self, (i, j), value):\n    if self.arr[i] == None:\n        self.arr[i] = [0] * self.NO_COLS\n    self.arr[i][j] = value\n", "code_toks_joined": "def __setitem__ ( self , ( i , j ) , value ) : <NEWLINE> <INDENT> if self . arr [ i ] == None : <NEWLINE> <INDENT> self . arr [ i ] = [ 0 ] * self . NO_COLS <NEWLINE> <DEDENT> self . arr [ i ] [ j ] = value <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["38cf2d2bf0347bc9221d6cfd70b14fd5", {"code_string": "def print_matrix(matr):\n    for row in matr:\n        print(\"[\",\n        for ent in row:\n            print(\"%2.3f \" % ent, )\n        print(\"]\")\n", "code_toks_joined": "def print_matrix ( matr ) : <NEWLINE> <INDENT> for row in matr : <NEWLINE> <INDENT> print ( <STRING> , <NEWLINE> for ent in row : <NEWLINE> <INDENT> print ( <STRING> % ent , ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"[\"", "\"%2.3f \"", "\"]\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["d95f927442bb6985d326adc86b8ebb15", {"code_string": "class ValueConstant(_ValueConstant):\n    def __cmp__(self, other):\n        return cmp(self.value, (other.value if isinstance(other, ValueConstant) else other)\n", "code_toks_joined": "class ValueConstant ( _ValueConstant ) : <NEWLINE> <INDENT> def __cmp__ ( self , other ) : <NEWLINE> <INDENT> return cmp ( self . value , ( other . value if isinstance ( other , ValueConstant ) else other ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["6f74ba8609b20c81a2c977929f9830bc", {"code_string": "def update_bandwidth_xml(iface, vnicXML, specParams = None):\n    if(specParams and\n        ('inbound' in specParams or 'outbound' in specParams)):\n        oldBandwidth = vmxml.find_first(vnicXML, 'bandwidth', None)\n        newBandwidth = iface.get_bandwidth_xml(specParams, oldBandwidth)\n        if oldBandwidth is not None:\n        vmxml.remove_child(vnicXML, oldBandwidth)\n        vmxml.append_child(vnicXML, newBandwidth)\n", "code_toks_joined": "def update_bandwidth_xml ( iface , vnicXML , specParams = None ) : <NEWLINE> <INDENT> if ( specParams and <NEWLINE> <INDENT> ( <STRING> in specParams or <STRING> in specParams ) ) : <NEWLINE> oldBandwidth = vmxml . find_first ( vnicXML , <STRING> , None ) <NEWLINE> newBandwidth = iface . get_bandwidth_xml ( specParams , oldBandwidth ) <NEWLINE> if oldBandwidth is not None : <NEWLINE> vmxml . remove_child ( vnicXML , oldBandwidth ) <NEWLINE> vmxml . append_child ( vnicXML , newBandwidth ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'inbound'", "'outbound'", "'bandwidth'"]}, "err_obj": {"msg": "expected an indented block"}}], ["735a5e6982bda8ea0f69142f308d4231", {"code_string": "def peeknamedpipe_request(treeid, processid, userid, multiplex_id):\n    \"\"\"Generate tran2 request\"\"\"\n    log.debug(\"generate peeknamedpipe request\")\n    netbios = [\n        '\\x00',\n        '\\x00\\x00\\x4a'\n    ]\n    smb_header = [\n        '\\xFF\\x53\\x4D\\x42',\n        '\\x25',\n        '\\x00\\x00\\x00\\x00',\n        '\\x18',\n        '\\x01\\x28',\n        '\\x00\\x00',\n        '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n        '\\x00\\x00',\n        treeid,\n        processid,\n        userid,\n        multiplex_id\n    ]\n    tran_request = [\n        '\\x10',\n        '\\x00\\x00',\n        '\\x00\\x00',\n        '\\xff\\xff',\n        '\\xff\\xff',\n        '\\x00',\n        '\\x00',\n        '\\x00\\x00',\n        '\\x00\\x00\\x00\\x00',\n        '\\x00\\x00',\n        '\\x00\\x00',\n        '\\x4a\\x00',\n        '\\x00\\x00',\n        '\\x4a\\x00',\n        '\\x02',\n        '\\x00',\n        '\\x23\\x00',\n        '\\x00\\x00',\n        '\\x07\\x00',\n        '\\x5c\\x50\\x49\\x50\\x45\\x5c\\x00'\n    return generate_smb_proto_payload(netbios, smb_header, tran_request)\n", "code_toks_joined": "def peeknamedpipe_request ( treeid , processid , userid , multiplex_id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> log . debug ( <STRING> ) <NEWLINE> netbios = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> <NEWLINE> <DEDENT> ] <NEWLINE> smb_header = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> treeid , <NEWLINE> processid , <NEWLINE> userid , <NEWLINE> multiplex_id <NEWLINE> <DEDENT> ] <NEWLINE> tran_request = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> <NEWLINE> <DEDENT> return generate_smb_proto_payload ( netbios , smb_header , tran_request ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Generate tran2 request\"\"\"", "\"generate peeknamedpipe request\"", "'\\x00'", "'\\x00\\x00\\x4a'", "'\\xFF\\x53\\x4D\\x42'", "'\\x25'", "'\\x00\\x00\\x00\\x00'", "'\\x18'", "'\\x01\\x28'", "'\\x00\\x00'", "'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "'\\x00\\x00'", "'\\x10'", "'\\x00\\x00'", "'\\x00\\x00'", "'\\xff\\xff'", "'\\xff\\xff'", "'\\x00'", "'\\x00'", "'\\x00\\x00'", "'\\x00\\x00\\x00\\x00'", "'\\x00\\x00'", "'\\x00\\x00'", "'\\x4a\\x00'", "'\\x00\\x00'", "'\\x4a\\x00'", "'\\x02'", "'\\x00'", "'\\x23\\x00'", "'\\x00\\x00'", "'\\x07\\x00'", "'\\x5c\\x50\\x49\\x50\\x45\\x5c\\x00'"]}, "window_span": [81, 155], "err_obj": {"msg": "unbalanced (){}[]"}}], ["19ccb3a3afafff97dc57262428fa9a02", {"code_string": "def test_rank_one_tensor_raises_if_rank_too_large_dynamic_rank(self):\n    with self.test_session():\n        tensor = array_ops.placeholder(dtypes.float32, name = \"my_tensor\")\n        desired_rank = 0\n        with ops.control_dependencies(\n            [check_ops.assert_rank(tensor, desired_rank)]):\n            with self.assertRaisesOpError(\"my_tensor.*rank\"):\n            array_ops.identity(tensor).eval(feed_dict = {tensor: [1, 2]})\n", "code_toks_joined": "def test_rank_one_tensor_raises_if_rank_too_large_dynamic_rank ( self ) : <NEWLINE> <INDENT> with self . test_session ( ) : <NEWLINE> <INDENT> tensor = array_ops . placeholder ( dtypes . float32 , name = <STRING> ) <NEWLINE> desired_rank = 0 <NEWLINE> with ops . control_dependencies ( <NEWLINE> <INDENT> [ check_ops . assert_rank ( tensor , desired_rank ) ] ) : <NEWLINE> with self . assertRaisesOpError ( <STRING> ) : <NEWLINE> array_ops . identity ( tensor ) . eval ( feed_dict = { tensor : [ 1 , 2 ] } ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"my_tensor\"", "\"my_tensor.*rank\""]}, "err_obj": {"msg": "expected an indented block"}}], ["b471cf95c7e008c7540b08d449e918e1", {"code_string": "def get_perpendicular_back_direction(self, direction):\n    if not(direction == 'down' or direction == 'right'):\n        raise ValueError('direction must be down or right')\n        if direction == 'right':\n        return 'up'\n        else:\n        return 'left'\n", "code_toks_joined": "def get_perpendicular_back_direction ( self , direction ) : <NEWLINE> <INDENT> if not ( direction == <STRING> or direction == <STRING> ) : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> if direction == <STRING> : <NEWLINE> return <STRING> <NEWLINE> else : <NEWLINE> return <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'down'", "'right'", "'direction must be down or right'", "'right'", "'up'", "'left'"]}, "err_obj": {"msg": "expected an indented block"}}], ["9385320ae4a5daee014bed3904820a63", {"code_string": "class ProcessGroup(models.Model):\n    name = models.CharField(\n        verbose_name = _(\"Name\"),\n        max_length = 100,\n        blank = false,\n        unique = True,\n        null = True)\n        description = models.TextField(\n        verbose_name = _(\"Description\"),\n        blank = True, help_text = _(\"a description of the process group\"))\n    objects = ProcessGroupManager()\n    class Meta:\n        verbose_name = _(\"Process Group\")\n        verbose_name_plural = _(\"Process Groups\")\n    def __str__(self):\n        return self.name\n", "code_toks_joined": "class ProcessGroup ( models . Model ) : <NEWLINE> <INDENT> name = models . CharField ( <NEWLINE> <INDENT> verbose_name = _ ( <STRING> ) , <NEWLINE> max_length = 100 , <NEWLINE> blank = false , <NEWLINE> unique = True , <NEWLINE> null = True ) <NEWLINE> description = models . TextField ( <NEWLINE> verbose_name = _ ( <STRING> ) , <NEWLINE> blank = True , help_text = _ ( <STRING> ) ) <NEWLINE> <DEDENT> objects = ProcessGroupManager ( ) <NEWLINE> class Meta : <NEWLINE> <INDENT> verbose_name = _ ( <STRING> ) <NEWLINE> verbose_name_plural = _ ( <STRING> ) <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return self . name <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Name\"", "\"Description\"", "\"a description of the process group\"", "\"Process Group\"", "\"Process Groups\""]}, "err_obj": {"msg": "unexpected indent"}}], ["29449fc22c1584a24d8567a08aaf8270", {"code_string": "def setupUi(self, completeWidget):\n    completeWidget.setObjectName(_fromUtf8(\"completeWidget\"))\n    completeWidget.resize(800, 600)\n    completeWidget.setStyleSheet(_fromUtf8(\"\"))\n    self.logoImg = LogoImage(completeWidget)\n    self.logoImg.setGeometry(QtCore.QRect(698, 10, 141, 101))\n    self.logoImg.setObjectName(_fromUtf8(\"logoImg\"))\n    self.installedLabel = QtGui.QLabel(completeWidget)\n    self.installedLabel.setGeometry(QtCore.QRect(60, 50, 561, 31))\n    font = QtGui.QFont()\n    font.setPointSize(16)\n    font.setBold(True)\n    font.setWeight(75)\n    self.installedLabel.setFont(font)\n    self.installedLabel.setObjectName(_fromUtf8(\"installedLabel\"))\n    self.setupPushButton = QtGui.QPushButton(completeWidget)\n    self.setupPushButton.setGeometry(QtCore.QRect(714, 130, 71, 27))\n    self.setupPushButton.setStyleSheet(_fromUtf8(\"background-color:rgb(85, 170, 255);\\n\"\n", "code_toks_joined": "def setupUi ( self , completeWidget ) : <NEWLINE> <INDENT> completeWidget . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> completeWidget . resize ( 800 , 600 ) <NEWLINE> completeWidget . setStyleSheet ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . logoImg = LogoImage ( completeWidget ) <NEWLINE> self . logoImg . setGeometry ( QtCore . QRect ( 698 , 10 , 141 , 101 ) ) <NEWLINE> self . logoImg . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . installedLabel = QtGui . QLabel ( completeWidget ) <NEWLINE> self . installedLabel . setGeometry ( QtCore . QRect ( 60 , 50 , 561 , 31 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setPointSize ( 16 ) <NEWLINE> font . setBold ( True ) <NEWLINE> font . setWeight ( 75 ) <NEWLINE> self . installedLabel . setFont ( font ) <NEWLINE> self . installedLabel . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . setupPushButton = QtGui . QPushButton ( completeWidget ) <NEWLINE> self . setupPushButton . setGeometry ( QtCore . QRect ( 714 , 130 , 71 , 27 ) ) <NEWLINE> self . setupPushButton . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"completeWidget\"", "\"\"", "\"logoImg\"", "\"installedLabel\"", "\"background-color:rgb(85, 170, 255);\\n\""]}, "window_span": [197, 203], "err_obj": {"msg": "unbalanced (){}[]"}}], ["b339a14b409d04214d15ea312db38a5f", {"code_string": "def main(request, response):\n    headers = [(\"Content-Type\", \"text/javascript\")]\n    test = request.GET.first('test')\n    assert(re.match('^[a-zA-Z0-9_]+$', test);\n    if test.find('_load') >= 0:\n        status = 200\n        content = '\"use strict\"; %s.executed = true; ' % test\n    else:\n        status = 404\n        content = '\"use strict\"; %s.test.step(function(){assert_unreached(\"404 script should not be executed\"); }); ' % test\n    return status, headers, content\n", "code_toks_joined": "def main ( request , response ) : <NEWLINE> <INDENT> headers = [ ( <STRING> , <STRING> ) ] <NEWLINE> test = request . GET . first ( <STRING> ) <NEWLINE> assert ( re . match ( <STRING> , test ) ; <NEWLINE> if test . find ( <STRING> ) >= 0 : <NEWLINE> <INDENT> status = 200 <NEWLINE> content = <STRING> % test <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> status = 404 <NEWLINE> content = <STRING> % test <NEWLINE> <DEDENT> return status , headers , content <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Content-Type\"", "\"text/javascript\"", "'test'", "'^[a-zA-Z0-9_]+$'", "'_load'", "'\"use strict\"; %s.executed = true; '", "'\"use strict\"; %s.test.step(function(){assert_unreached(\"404 script should not be executed\"); }); '"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["8443f26ad1d834a1c16d4bce3bf09a3f", {"code_string": "def apm_enc_data(keyfile, data):\n    try:\n        key = M2Crypto.RSA.load_pub_key(keyfile)\n            cdata = key.public_encrypt(data, M2Crypto.RSA.pkcs1_padding)\n        return base64.encodestring(cdata)\n        except:\n        return \"\"\n", "code_toks_joined": "def apm_enc_data ( keyfile , data ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> key = M2Crypto . RSA . load_pub_key ( keyfile ) <NEWLINE> <INDENT> cdata = key . public_encrypt ( data , M2Crypto . RSA . pkcs1_padding ) <NEWLINE> <DEDENT> return base64 . encodestring ( cdata ) <NEWLINE> except : <NEWLINE> return <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["6eb401da0ff99c0dc63b27181fa35f0d", {"code_string": "def get_ordered_fields(resource_id):\n    \"\"\"Get fields ordered the same as the uploaded dataset\"\"\"\n    data = {'resource_id': resource_id, 'limit': 0}\n    try:\n        result = p.toolkit.get_action('datastore_search')({}, data)\n    except NotFound:\n        return[]\n    else:\n        return[f['id'] for f in result['fields']\n", "code_toks_joined": "def get_ordered_fields ( resource_id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> data = { <STRING> : resource_id , <STRING> : 0 } <NEWLINE> try : <NEWLINE> <INDENT> result = p . toolkit . get_action ( <STRING> ) ( { } , data ) <NEWLINE> <DEDENT> except NotFound : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ f [ <STRING> ] for f in result [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get fields ordered the same as the uploaded dataset\"\"\"", "'resource_id'", "'limit'", "'datastore_search'", "'id'", "'fields'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e92bfb16bc1a1083d9c2fc64f542cfba", {"code_string": "def logfilename():\n    \"\"\" Ritorna il path ed il filename del file di log di accounting\"\"\"\n        return \"%s-\" + yesterday() + \".gz\" %(ConfigSectionMap(\"log\")['acct'])\n", "code_toks_joined": "def logfilename ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> return <STRING> + yesterday ( ) + <STRING> % ( ConfigSectionMap ( <STRING> ) [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Ritorna il path ed il filename del file di log di accounting\"\"\"", "\"%s-\"", "\".gz\"", "\"log\"", "'acct'"]}, "err_obj": {"msg": "unexpected indent"}}], ["0f4b1ccb8414d08fba146c632c0555fc", {"code_string": "def _get_homedirs(self):\n    \"\"\"On windows the homedirs are the paths of the user's profile.\"\"\"\n    result = []\n    for artifact_hit in self.session.plugins.artifact_collector(\n        \"WindowsRegistryProfiles\"):\n        for hit_result in artifact_hit.get(\"result\", []):\n        profile_path = hit_result.get(\"value\")\n        if profile_path:\n            result.append(profile_path)\n    return result\n", "code_toks_joined": "def _get_homedirs ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> result = [ ] <NEWLINE> for artifact_hit in self . session . plugins . artifact_collector ( <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> for hit_result in artifact_hit . get ( <STRING> , [ ] ) : <NEWLINE> profile_path = hit_result . get ( <STRING> ) <NEWLINE> if profile_path : <NEWLINE> <INDENT> result . append ( profile_path ) <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"On windows the homedirs are the paths of the user's profile.\"\"\"", "\"WindowsRegistryProfiles\"", "\"result\"", "\"value\""]}, "err_obj": {"msg": "expected an indented block"}}], ["17c67f848a6a5c901a840ef0403ca394", {"code_string": "def test_clone_unknown_subprocess_error(mocker, clone_dir):\n    \"\"\"In `clone()`, unknown subprocess errors should be raised.\"\"\"\n    mocker.patch(\n        'cookiecutter.vcs.subprocess.check_output',\n        autospec = True\n        side_effect = [subprocess.CalledProcessError(\n            - 1, 'cmd', output = 'Something went wrong'\n        )]\n    )\n    with pytest.raises(subprocess.CalledProcessError):\n        vcs.clone(\n            'https://github.com/pytest-dev/cookiecutter-pytest-plugin',\n            clone_to_dir = clone_dir,\n            no_input = True\n        )\n", "code_toks_joined": "def test_clone_unknown_subprocess_error ( mocker , clone_dir ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> mocker . patch ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> autospec = True <NEWLINE> side_effect = [ subprocess . CalledProcessError ( <NEWLINE> <INDENT> - 1 , <STRING> , output = <STRING> <NEWLINE> <DEDENT> ) ] <NEWLINE> <DEDENT> ) <NEWLINE> with pytest . raises ( subprocess . CalledProcessError ) : <NEWLINE> <INDENT> vcs . clone ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> clone_to_dir = clone_dir , <NEWLINE> no_input = True <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"In `clone()`, unknown subprocess errors should be raised.\"\"\"", "'cookiecutter.vcs.subprocess.check_output'", "'cmd'", "'Something went wrong'", "'https://github.com/pytest-dev/cookiecutter-pytest-plugin'"]}, "err_obj": {"msg": "invalid syntax"}}], ["b64782fda22f2cde9fe6a23e98a4235c", {"code_string": "def help_fix(self):\n    print(_(\"The fix command verifies relations of given packages\\n\")\n        \"and marks the necessary changes for fixing them.\")\n    print\n    print(_(\"Options:\"))\n    print(_(\"   --explain  Include additional information about\\n\")\n        \"              changes, when possible\")\n    print\n    print(_(\"Usage: fix <pkgname> ...\"))\n", "code_toks_joined": "def help_fix ( self ) : <NEWLINE> <INDENT> print ( _ ( <STRING> ) <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> print <NEWLINE> print ( _ ( <STRING> ) ) <NEWLINE> print ( _ ( <STRING> ) <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> print <NEWLINE> print ( _ ( <STRING> ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"The fix command verifies relations of given packages\\n\"", "\"and marks the necessary changes for fixing them.\"", "\"Options:\"", "\"   --explain  Include additional information about\\n\"", "\"              changes, when possible\"", "\"Usage: fix <pkgname> ...\""]}, "err_obj": {"msg": "invalid syntax"}}], ["dead43dae530ad99604b571c8ee36fce", {"code_string": "def log_user_out():\n    f = open('/var/tmp/uid.txt', 'r')\n    uid = f.read()\n    mydata = [('uid', uid)]\n    mydata = urllib.urlencode(mydata)\n    path = 'http://www.example.com/offline.php'\n        req = urllib2.Request(path, mydata)\n        req.add_header(\"Content-type\", \"application/x-www-form-urlencoded\")\n        response = urllib2.urlopen(req).read()\n", "code_toks_joined": "def log_user_out ( ) : <NEWLINE> <INDENT> f = open ( <STRING> , <STRING> ) <NEWLINE> uid = f . read ( ) <NEWLINE> mydata = [ ( <STRING> , uid ) ] <NEWLINE> mydata = urllib . urlencode ( mydata ) <NEWLINE> path = <STRING> <NEWLINE> <INDENT> req = urllib2 . Request ( path , mydata ) <NEWLINE> req . add_header ( <STRING> , <STRING> ) <NEWLINE> response = urllib2 . urlopen ( req ) . read ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'/var/tmp/uid.txt'", "'r'", "'uid'", "'http://www.example.com/offline.php'", "\"Content-type\"", "\"application/x-www-form-urlencoded\""]}, "err_obj": {"msg": "unexpected indent"}}], ["2ad57261eb8a27c9e76a14aeaa857ebd", {"code_string": "def AjaxRelationleft(request):\n    global rlist\n    rlist = {}\n    idenid = request.GET[\"id\"]\n    rts = Relationtype.objects.filter(id = idenid)\n    for each in rts:\n        subj = str(each.left_subjecttype.title)\n        appltype = each.left_applicable_nodetypes\n        fnname = \"selectionlist_\" + appltype + \"('\" + subj + \"')\"\n        exec fnname\n    returndict = rlist\n    jsonobject = json.dumps(returndict)\n    return HttpResponse(jsonobject, \"application/json\")\n", "code_toks_joined": "def AjaxRelationleft ( request ) : <NEWLINE> <INDENT> global rlist <NEWLINE> rlist = { } <NEWLINE> idenid = request . GET [ <STRING> ] <NEWLINE> rts = Relationtype . objects . filter ( id = idenid ) <NEWLINE> for each in rts : <NEWLINE> <INDENT> subj = str ( each . left_subjecttype . title ) <NEWLINE> appltype = each . left_applicable_nodetypes <NEWLINE> fnname = <STRING> + appltype + <STRING> + subj + <STRING> <NEWLINE> exec fnname <NEWLINE> <DEDENT> returndict = rlist <NEWLINE> jsonobject = json . dumps ( returndict ) <NEWLINE> return HttpResponse ( jsonobject , <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"id\"", "\"selectionlist_\"", "\"('\"", "\"')\"", "\"application/json\""]}, "err_obj": {"msg": "invalid syntax"}}], ["162d3ba0a19369eb8719f33f24592ec2", {"code_string": "def open_settings():\n    try:\n        exec \"import platformcode.\" + PLATFORM_NAME + \".config as platformconfig\"\n    except:\n        exec \"import \" + PLATFORM_NAME + \"config as platformconfig\"\n    return platformconfig.open_settings()\n", "code_toks_joined": "def open_settings ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> exec <STRING> + PLATFORM_NAME + <STRING> <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> exec <STRING> + PLATFORM_NAME + <STRING> <NEWLINE> <DEDENT> return platformconfig . open_settings ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"import platformcode.\"", "\".config as platformconfig\"", "\"import \"", "\"config as platformconfig\""]}, "err_obj": {"msg": "invalid syntax"}}], ["6c89b6fd542ac63529923328078e7c6a", {"code_string": "def produced_quantity(product_name, file_id):\n    for(id, ) in db_session.query(Product.id).filter_by(\n        product_name = product_name):\n        for(produced_quantity, ) in db_session.query(\n            ProductInFile.produced_quantity).filter_by(\n            product_id = id, input_file_id = file_id):\n        return produced_quantity\n", "code_toks_joined": "def produced_quantity ( product_name , file_id ) : <NEWLINE> <INDENT> for ( id , ) in db_session . query ( Product . id ) . filter_by ( <NEWLINE> <INDENT> product_name = product_name ) : <NEWLINE> for ( produced_quantity , ) in db_session . query ( <NEWLINE> <INDENT> ProductInFile . produced_quantity ) . filter_by ( <NEWLINE> product_id = id , input_file_id = file_id ) : <NEWLINE> <DEDENT> return produced_quantity <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["5a7b4b5cfd5954a34cccfaaad3559c9d", {"code_string": "def dfs(node, val):\n    if node != none:\n        if node.data == val\n            return node.data\n        dfs(node.left)\n        dfs(node.right)\n    return 0\n", "code_toks_joined": "def dfs ( node , val ) : <NEWLINE> <INDENT> if node != none : <NEWLINE> <INDENT> if node . data == val <NEWLINE> <INDENT> return node . data <NEWLINE> <DEDENT> dfs ( node . left ) <NEWLINE> dfs ( node . right ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["2e514b6d1088bed9df60ca7d97e90d8c", {"code_string": "class Pemasukan(models.Model):\n    user = models.ForeignKey(User)\n    nama = models.CharField(max_length = 255)\n    kategori = models.ForeignKey('Kategori')\n    tgl_buat = models.DateTimeField(auto_now_add = True)\n    jumlah = models.PositiveIntegerField()\n    keterangan = models.TextField(blank = True, null = True)\n    class Meta:\n    verbose_name_plural = 'Daftar Pemasukan'\n    verbose_name = 'Pemasukan'\n    def __unicode__(self):\n    return self.nama\n", "code_toks_joined": "class Pemasukan ( models . Model ) : <NEWLINE> <INDENT> user = models . ForeignKey ( User ) <NEWLINE> nama = models . CharField ( max_length = 255 ) <NEWLINE> kategori = models . ForeignKey ( <STRING> ) <NEWLINE> tgl_buat = models . DateTimeField ( auto_now_add = True ) <NEWLINE> jumlah = models . PositiveIntegerField ( ) <NEWLINE> keterangan = models . TextField ( blank = True , null = True ) <NEWLINE> class Meta : <NEWLINE> verbose_name_plural = <STRING> <NEWLINE> verbose_name = <STRING> <NEWLINE> def __unicode__ ( self ) : <NEWLINE> return self . nama <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Kategori'", "'Daftar Pemasukan'", "'Pemasukan'"]}, "err_obj": {"msg": "expected an indented block"}}], ["58d09dca9cc8c5ca644a1dc7aa416aaf", {"code_string": "class Ui_MainProcess_dock(object):\n    def setupUi(self, MainProcess_dock):\n        MainProcess_dock.setObjectName(_fromUtf8(\"MainProcess_dock\"))\n        MainProcess_dock.resize(374, 516)\n        MainProcess_dock.setMinimumSize(QtCore.QSize(374, 500))\n        MainProcess_dock.setStyleSheet(_fromUtf8(\"QStackedWidget QWidget {\\n\"\n", "code_toks_joined": "class Ui_MainProcess_dock ( object ) : <NEWLINE> <INDENT> def setupUi ( self , MainProcess_dock ) : <NEWLINE> <INDENT> MainProcess_dock . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> MainProcess_dock . resize ( 374 , 516 ) <NEWLINE> MainProcess_dock . setMinimumSize ( QtCore . QSize ( 374 , 500 ) ) <NEWLINE> MainProcess_dock . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"MainProcess_dock\"", "\"QStackedWidget QWidget {\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["13cf4d8992fc32d93add585a9df983aa", {"code_string": "def orig_instruction_to_function_map(mapfile):\n    m = {}\n    for line in open(mapfile, \"r\"):\n    (addr_16, fun) = line.split(\",\")\n    m[int(addr_16, base = 16)] = fun\n    return m\n", "code_toks_joined": "def orig_instruction_to_function_map ( mapfile ) : <NEWLINE> <INDENT> m = { } <NEWLINE> for line in open ( mapfile , <STRING> ) : <NEWLINE> ( addr_16 , fun ) = line . split ( <STRING> ) <NEWLINE> m [ int ( addr_16 , base = 16 ) ] = fun <NEWLINE> return m <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"r\"", "\",\""]}, "err_obj": {"msg": "expected an indented block"}}], ["57ba8dfdc5094655f14b8beda4dc8670", {"code_string": "def test_simple_c_code():\n    x, y, z = symbols('xyz')\n    expr = (x + y) * z\n    routine = Routine(\"test\", [InputArgument(symbol) for symbol in x, y, z], [Result(expr)])\n    code_gen = CCodeGen()\n    source = get_string(code_gen.dump_c, [routine])\n    expected = (\n        \"#include \\\"file.h\\\"\\n\"\n        \"#include <math.h>\\n\"\n        \"double test(double x, double y, double z) {\\n\"\n        \"  return z*(x + y);\\n\"\n        \"}\\n\"\n    )\n    assert source == expected\n", "code_toks_joined": "def test_simple_c_code ( ) : <NEWLINE> <INDENT> x , y , z = symbols ( <STRING> ) <NEWLINE> expr = ( x + y ) * z <NEWLINE> routine = Routine ( <STRING> , [ InputArgument ( symbol ) for symbol in x , y , z ] , [ Result ( expr ) ] ) <NEWLINE> code_gen = CCodeGen ( ) <NEWLINE> source = get_string ( code_gen . dump_c , [ routine ] ) <NEWLINE> expected = ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> assert source == expected <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'xyz'", "\"test\"", "\"#include \\\"file.h\\\"\\n\"", "\"#include <math.h>\\n\"", "\"double test(double x, double y, double z) {\\n\"", "\"  return z*(x + y);\\n\"", "\"}\\n\""]}, "err_obj": {"msg": "invalid syntax"}}], ["f5abcbc42216a091e0213990ec49a4a3", {"code_string": "def score_numeric(omega_a, omega_b):\n    \"\"\"Return the tableau matching score between two Omega matrix entries\"\"\"\n    delta = min(abs(omega_a - omega_b), 2 * pi - abs(omega_a - omega_b)\n    score = pi / 4 - delta;\n    return score\n", "code_toks_joined": "def score_numeric ( omega_a , omega_b ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> delta = min ( abs ( omega_a - omega_b ) , 2 * pi - abs ( omega_a - omega_b ) <NEWLINE> score = pi / 4 - delta ; <NEWLINE> return score <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return the tableau matching score between two Omega matrix entries\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["4d68eb5ccb76887c5398ab0269963fb4", {"code_string": "def setup_env():\n    \"\"\"Try to increase resource limits of the OS. Move PYTHON_EGG_CACHE to /tmp\"\"\"\n    try:\n        resource.setrlimit(resource.RLIMIT_NOFILE,\n            (MAX_DESCRIPTORS, MAX_DESCRIPTORS))\n        resource.setrlimit(resource.RLIMIT_DATA,\n            (MAX_MEMORY, MAX_MEMORY))\n    except ValueError:\n        print(_(\"WARNING: Unable to increase file descriptor limit.  \")\n            \"Running as non-root?\")\n    os.environ.setdefault('PYTHON_EGG_CACHE', '/tmp')\n", "code_toks_joined": "def setup_env ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> resource . setrlimit ( resource . RLIMIT_NOFILE , <NEWLINE> <INDENT> ( MAX_DESCRIPTORS , MAX_DESCRIPTORS ) ) <NEWLINE> <DEDENT> resource . setrlimit ( resource . RLIMIT_DATA , <NEWLINE> <INDENT> ( MAX_MEMORY , MAX_MEMORY ) ) <NEWLINE> <DEDENT> <DEDENT> except ValueError : <NEWLINE> <INDENT> print ( _ ( <STRING> ) <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> os . environ . setdefault ( <STRING> , <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Try to increase resource limits of the OS. Move PYTHON_EGG_CACHE to /tmp\"\"\"", "\"WARNING: Unable to increase file descriptor limit.  \"", "\"Running as non-root?\"", "'PYTHON_EGG_CACHE'", "'/tmp'"]}, "err_obj": {"msg": "invalid syntax"}}], ["23836fd362860e0dbfacaffb16048ce4", {"code_string": "def test_query_query__facet_group_off2(self):\n    qm = SolrQueryManager(FakeSolrDoc)\n    qm = qm.filter(id__eq = 999).group_by('city', group_limit = 2) params = qm.query\n    assert 'group.facet' not in params\n", "code_toks_joined": "def test_query_query__facet_group_off2 ( self ) : <NEWLINE> <INDENT> qm = SolrQueryManager ( FakeSolrDoc ) <NEWLINE> qm = qm . filter ( id__eq = 999 ) . group_by ( <STRING> , group_limit = 2 ) params = qm . query <NEWLINE> assert <STRING> not in params <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'city'", "'group.facet'"]}, "err_obj": {"msg": "invalid syntax"}}], ["dea76f3a298a77ad2b303f7f3b01783a", {"code_string": "def validate_password(password, user = None, password_validators = None)\n    \"\"\"Validate whether the password meets all validator requirements.\"\"\"\n    errors = []\n    if password_validators is None:\n        password_validators = get_default_password_validators()\n    for validator in password_validators:\n        try:\n            validator.validate(password, user)\n        except ValidationError as error:\n            errors.append(error)\n    if errors:\n        raise ValidationError(errors)\n", "code_toks_joined": "def validate_password ( password , user = None , password_validators = None ) <NEWLINE> <INDENT> <STRING> <NEWLINE> errors = [ ] <NEWLINE> if password_validators is None : <NEWLINE> <INDENT> password_validators = get_default_password_validators ( ) <NEWLINE> <DEDENT> for validator in password_validators : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> validator . validate ( password , user ) <NEWLINE> <DEDENT> except ValidationError as error : <NEWLINE> <INDENT> errors . append ( error ) <NEWLINE> <DEDENT> <DEDENT> if errors : <NEWLINE> <INDENT> raise ValidationError ( errors ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Validate whether the password meets all validator requirements.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["11c96e029296068e2d1bf77b23d633f3", {"code_string": "def damp_operations(filename):\n    hall_symbols = read_spg_csv(filename)\n    count = 0\n    print(\"  0       ,  /* dummy */\")\n    for i in range(530):\n        hs = HallSymbol(hall_symbols[i][0])\n        G_R, G_T = hs.get_full_operations()\n        for j, (r, t) in enumerate(zip(G_R, G_T)):\n            count += 1\n            r_encode = encode_rotation(r)\n            x = (t * 12 + 0.1).astype(int)\n            t_encode = x[0] * 144 + x[1] * 12 + x[2]\n            total = t_encode * 3 ** 9 + r_encode\n            print(\"  %-8d,\" %(total), )\n            print(\" /* %4d (%3d) [\" %(count, i + 1),\n            print(\"%2d,\" * 9 % tuple(decode_rotation(total %(3 ** 9))), )\n            print(\"%2d,%2d,%2d] */\" % tuple(decode_trans(total //(3 ** 9))))\n", "code_toks_joined": "def damp_operations ( filename ) : <NEWLINE> <INDENT> hall_symbols = read_spg_csv ( filename ) <NEWLINE> count = 0 <NEWLINE> print ( <STRING> ) <NEWLINE> for i in range ( 530 ) : <NEWLINE> <INDENT> hs = HallSymbol ( hall_symbols [ i ] [ 0 ] ) <NEWLINE> G_R , G_T = hs . get_full_operations ( ) <NEWLINE> for j , ( r , t ) in enumerate ( zip ( G_R , G_T ) ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> r_encode = encode_rotation ( r ) <NEWLINE> x = ( t * 12 + 0.1 ) . astype ( int ) <NEWLINE> t_encode = x [ 0 ] * 144 + x [ 1 ] * 12 + x [ 2 ] <NEWLINE> total = t_encode * 3 ** 9 + r_encode <NEWLINE> print ( <STRING> % ( total ) , ) <NEWLINE> print ( <STRING> % ( count , i + 1 ) , <NEWLINE> print ( <STRING> * 9 % tuple ( decode_rotation ( total % ( 3 ** 9 ) ) ) , ) <NEWLINE> print ( <STRING> % tuple ( decode_trans ( total // ( 3 ** 9 ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"  0       ,  /* dummy */\"", "\"  %-8d,\"", "\" /* %4d (%3d) [\"", "\"%2d,\"", "\"%2d,%2d,%2d] */\""]}, "window_span": [146, 202], "err_obj": {"msg": "unbalanced (){}[]"}}], ["266f562787fe234b7c2635dfafeb0262", {"code_string": "def __set__(self, instance, value):\n    if instance is None:\n        raise AttributeError, \"Manager must be accessed via instance\"\n    manager = self.__get__(instance)\n    if self.related.field.null:\n        manager.clear()\n    manager.add(* value)\n", "code_toks_joined": "def __set__ ( self , instance , value ) : <NEWLINE> <INDENT> if instance is None : <NEWLINE> <INDENT> raise AttributeError , <STRING> <NEWLINE> <DEDENT> manager = self . __get__ ( instance ) <NEWLINE> if self . related . field . null : <NEWLINE> <INDENT> manager . clear ( ) <NEWLINE> <DEDENT> manager . add ( * value ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Manager must be accessed via instance\""]}, "err_obj": {"msg": "invalid syntax"}}], ["dd5f97e8247005152ffed97e4d85bb51", {"code_string": "from rest_framework import mixins\nfrom rest_framework.exceptions import APIException\nfrom rest_framework.viewsets import GenericViewSet\nfrom hptrivia_app.models import Question\nfrom serializers import QuestionSerializer\nclass QuestionViewSet(mixins.RetrieveModelMixin,\n    mixins.UpdateModelMixin,\n    mixins.ListModelMixin,\n    GenericViewSet):\n    model = Question\n    lookup_field = 'id'\n    serializer_class = QuestionSerializer\n    def get_queryset(self):\n    return Question.objects.all()\n", "code_toks_joined": "from rest_framework import mixins <NEWLINE> from rest_framework . exceptions import APIException <NEWLINE> from rest_framework . viewsets import GenericViewSet <NEWLINE> from hptrivia_app . models import Question <NEWLINE> from serializers import QuestionSerializer <NEWLINE> class QuestionViewSet ( mixins . RetrieveModelMixin , <NEWLINE> <INDENT> mixins . UpdateModelMixin , <NEWLINE> mixins . ListModelMixin , <NEWLINE> GenericViewSet ) : <NEWLINE> model = Question <NEWLINE> lookup_field = <STRING> <NEWLINE> serializer_class = QuestionSerializer <NEWLINE> def get_queryset ( self ) : <NEWLINE> return Question . objects . all ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'id'"]}, "err_obj": {"msg": "expected an indented block"}}], ["be144d11c941893018b85c6188427676", {"code_string": "def update(i, one):\n    for n, (lo, hi, new) in enumerate(zip(i.lo, i.hi,\n        i.value(one))):\n        if new > hi:\n        i.hi[n] = new\n        if new < lo:\n        i.lo[n] = new\n", "code_toks_joined": "def update ( i , one ) : <NEWLINE> <INDENT> for n , ( lo , hi , new ) in enumerate ( zip ( i . lo , i . hi , <NEWLINE> <INDENT> i . value ( one ) ) ) : <NEWLINE> if new > hi : <NEWLINE> i . hi [ n ] = new <NEWLINE> if new < lo : <NEWLINE> i . lo [ n ] = new <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["5bcd0d3fc436563aa04081d433570f28", {"code_string": "def get_name(self, width = 'wide', context = 'format'):\n    names = i18n.get_day_names(\n        width,\n        context,\n        ,\n        i18n.get_locale()\n    )\n    return names[self.index]\n", "code_toks_joined": "def get_name ( self , width = <STRING> , context = <STRING> ) : <NEWLINE> <INDENT> names = i18n . get_day_names ( <NEWLINE> <INDENT> width , <NEWLINE> context , <NEWLINE> , <NEWLINE> i18n . get_locale ( ) <NEWLINE> <DEDENT> ) <NEWLINE> return names [ self . index ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'wide'", "'format'"]}, "err_obj": {"msg": "invalid syntax"}}], ["b57eb0dd97a27fa09acceea6414b7e76", {"code_string": "def getColNames(self, tablename):\n    if(tablename == 'next'):\n    if self.next_tbl_schema == \"\":\n        colNames = [\"id\", \"val\"]\n        else:\n        colNames = self.next_tbl_schema.split(\",\")\n    else:\n        colNames = []\n    return colNames\n", "code_toks_joined": "def getColNames ( self , tablename ) : <NEWLINE> <INDENT> if ( tablename == <STRING> ) : <NEWLINE> if self . next_tbl_schema == <STRING> : <NEWLINE> <INDENT> colNames = [ <STRING> , <STRING> ] <NEWLINE> else : <NEWLINE> colNames = self . next_tbl_schema . split ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> colNames = [ ] <NEWLINE> <DEDENT> return colNames <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'next'", "\"\"", "\"id\"", "\"val\"", "\",\""]}, "err_obj": {"msg": "expected an indented block"}}], ["9d13444098576d0b7f84de42ce95d0fe", {"code_string": "def b1282int(st):\n    oneHundredAndTwentyEight = 128 l\n    i = 0\n    place = 0\n    for char in st:\n        num = ord(char)\n        i = i +(num *(oneHundredAndTwentyEight ** place))\n        place = place + 1\n    if i <= 2147483647:\n        return int(i)\n    else:\n        return i\n", "code_toks_joined": "def b1282int ( st ) : <NEWLINE> <INDENT> oneHundredAndTwentyEight = 128 l <NEWLINE> i = 0 <NEWLINE> place = 0 <NEWLINE> for char in st : <NEWLINE> <INDENT> num = ord ( char ) <NEWLINE> i = i + ( num * ( oneHundredAndTwentyEight ** place ) ) <NEWLINE> place = place + 1 <NEWLINE> <DEDENT> if i <= 2147483647 : <NEWLINE> <INDENT> return int ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["78c96757dd36a7b9d182661d47806e93", {"code_string": "def test_processor_xml_parsing(self):\n    oob_processor = CameraOutOfBandProcessor()\n    self.assertIsNotNone(oob_processor)\n    self.assertFalse(oob_processor.parse_oob_xml(None))\n    oob = unittest.mock.Mock()\n    oob.text = None\n    self.assertFalse(oob_processor.parse_oob_xml(oob)\n    oob = unittest.mock.Mock()\n    oob.text = \"on\"\n    self.assertTrue(oob_processor.parse_oob_xml(oob))\n", "code_toks_joined": "def test_processor_xml_parsing ( self ) : <NEWLINE> <INDENT> oob_processor = CameraOutOfBandProcessor ( ) <NEWLINE> self . assertIsNotNone ( oob_processor ) <NEWLINE> self . assertFalse ( oob_processor . parse_oob_xml ( None ) ) <NEWLINE> oob = unittest . mock . Mock ( ) <NEWLINE> oob . text = None <NEWLINE> self . assertFalse ( oob_processor . parse_oob_xml ( oob ) <NEWLINE> oob = unittest . mock . Mock ( ) <NEWLINE> oob . text = <STRING> <NEWLINE> self . assertTrue ( oob_processor . parse_oob_xml ( oob ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"on\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["0442b47187bcc3f34d763319de34b768", {"code_string": "def __init__(self plugin):\n    super(NECPluginV2RPCCallbacks, self).__init__()\n    self.plugin = plugin\n", "code_toks_joined": "def __init__ ( self plugin ) : <NEWLINE> <INDENT> super ( NECPluginV2RPCCallbacks , self ) . __init__ ( ) <NEWLINE> self . plugin = plugin <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["32f50473bb523c19748c01f34345c3f5", {"code_string": "def main():\n    e = 65537\n    n = 18604062125510571031471750649821316329679075240425215155565854406809609668335654053956581181954590620902738575301840213122192524051208433461229187907016997447442571285108109128232900783308909475021812467308548398111895347558651286259631740349426896657319783170302728838343220396488616780511168826294004371666849527520273722614881089052945223370388126979539564867809681914897680522296481279349571443843378935124793042177857000433266432982960332119281263048730048547498134410661972444056093841057496584878791672081540003288714250151610555939149231061629657881570676337865434594411572171750122440981346430244089440952567\n    s = 12626455418792952924024493013198098863512212246301282894118807005086832684489543287165894064859469025233806305193892189559421764939495917348639365119950426589182135875711093564051730704657842999676564205070064606256132658912124853451762683834028889637219143921647861439076750823378709406152722488707110077984370053893449731808240684680979671504757064703764328159125242166255082176828015391850248753018273523440027270913493592693734458075992742191195882811209889628438061441870649244037708043706068407190276646564212746198947056532105881136757836974357801862311991843532484468835666420055033931014325969526594149593232\n    m = 1337\n    flag = \"5ac8379545f36bfd435952e122fd0780f3045e9c897b4681b606e8f0b82c5879c09d208d7111032acf5dc058dc5a4fa3ad2acc0588db728a6564c72f566f9f853ec26d439541886844b967e1d1ce9cff30a74b4a5651ed41cd3c274a66ee962ed9ebc7c4f9f4cb21a29998c7201eb6983da3f8bcb45f8a347cd3f8472e7bb89ae47c3e3e22327c8b48e3216275b5a7d0a6ed02d95a8902cae72adb64bc13add8ff909ff3bb017c740a2772f82b7822638b28b5f5b637975698e93e8b280994baed710e4b9d292550bcd672bcd7f7bce58ee695e1c64b8439f2a7e303e8cb2142948950101ae3361433c5f8d858527c7cca1d562c89321b06c8b846b9571fb576\"\n    p = gcd(pow(s, e) - m, n)\n    q = n // p\n    totn = (p - 1) *(q - 1)\n    d = modinv(e, totn)\n    flag = pow(int(flag, 16), d, n)\n    flag = hex(flag)[2: ]\n    if(len(flag) % 2 == 1):\n        flag = '0' + flag\n    print(binascii.unhexlify(flag)\n", "code_toks_joined": "def main ( ) : <NEWLINE> <INDENT> e = 65537 <NEWLINE> n = 18604062125510571031471750649821316329679075240425215155565854406809609668335654053956581181954590620902738575301840213122192524051208433461229187907016997447442571285108109128232900783308909475021812467308548398111895347558651286259631740349426896657319783170302728838343220396488616780511168826294004371666849527520273722614881089052945223370388126979539564867809681914897680522296481279349571443843378935124793042177857000433266432982960332119281263048730048547498134410661972444056093841057496584878791672081540003288714250151610555939149231061629657881570676337865434594411572171750122440981346430244089440952567 <NEWLINE> s = 12626455418792952924024493013198098863512212246301282894118807005086832684489543287165894064859469025233806305193892189559421764939495917348639365119950426589182135875711093564051730704657842999676564205070064606256132658912124853451762683834028889637219143921647861439076750823378709406152722488707110077984370053893449731808240684680979671504757064703764328159125242166255082176828015391850248753018273523440027270913493592693734458075992742191195882811209889628438061441870649244037708043706068407190276646564212746198947056532105881136757836974357801862311991843532484468835666420055033931014325969526594149593232 <NEWLINE> m = 1337 <NEWLINE> flag = <STRING> <NEWLINE> p = gcd ( pow ( s , e ) - m , n ) <NEWLINE> q = n // p <NEWLINE> totn = ( p - 1 ) * ( q - 1 ) <NEWLINE> d = modinv ( e , totn ) <NEWLINE> flag = pow ( int ( flag , 16 ) , d , n ) <NEWLINE> flag = hex ( flag ) [ 2 : ] <NEWLINE> if ( len ( flag ) % 2 == 1 ) : <NEWLINE> <INDENT> flag = <STRING> + flag <NEWLINE> <DEDENT> print ( binascii . unhexlify ( flag ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"5ac8379545f36bfd435952e122fd0780f3045e9c897b4681b606e8f0b82c5879c09d208d7111032acf5dc058dc5a4fa3ad2acc0588db728a6564c72f566f9f853ec26d439541886844b967e1d1ce9cff30a74b4a5651ed41cd3c274a66ee962ed9ebc7c4f9f4cb21a29998c7201eb6983da3f8bcb45f8a347cd3f8472e7bb89ae47c3e3e22327c8b48e3216275b5a7d0a6ed02d95a8902cae72adb64bc13add8ff909ff3bb017c740a2772f82b7822638b28b5f5b637975698e93e8b280994baed710e4b9d292550bcd672bcd7f7bce58ee695e1c64b8439f2a7e303e8cb2142948950101ae3361433c5f8d858527c7cca1d562c89321b06c8b846b9571fb576\"", "'0'"]}, "window_span": [121, 130], "err_obj": {"msg": "unbalanced (){}[]"}}], ["cba4eaf9c08d8d4619c98dc4623fcc6b", {"code_string": "def TestExit(self):\n    self.write(\"exit\\n\\r\");\n        self.BackspaceNL(2)\n    self.read(length = 8, expect = \"logout\\n\\r\")\n", "code_toks_joined": "def TestExit ( self ) : <NEWLINE> <INDENT> self . write ( <STRING> ) ; <NEWLINE> <INDENT> self . BackspaceNL ( 2 ) <NEWLINE> <DEDENT> self . read ( length = 8 , expect = <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"exit\\n\\r\"", "\"logout\\n\\r\""]}, "err_obj": {"msg": "unexpected indent"}}], ["ec2d6dbb6f47967127c35ba036db699b", {"code_string": "def test_callback(self):\n    with patch(\n        'allauth.socialaccount.providers.draugiem.views'\n        '.draugiem_complete_login') as draugiem_complete_login:\n        self.mock_socialaccount_state()\n        response_json = self.get_draugiem_login_response()\n        token = SocialToken(app = self.app, token = response_json['apikey'])\n        login = self.get_socialaccount(response_json, token)\n        draugiem_complete_login.return_value = login\n        response = self.client.get(\n        reverse(views.callback),\n        {'dr_auth_status': 'ok',\n            'dr_auth_code': '42'})\n            self.assertRedirects(response, '/accounts/profile/',\n                fetch_redirect_response = False)\n", "code_toks_joined": "def test_callback ( self ) : <NEWLINE> <INDENT> with patch ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> ) as draugiem_complete_login : <NEWLINE> self . mock_socialaccount_state ( ) <NEWLINE> response_json = self . get_draugiem_login_response ( ) <NEWLINE> token = SocialToken ( app = self . app , token = response_json [ <STRING> ] ) <NEWLINE> login = self . get_socialaccount ( response_json , token ) <NEWLINE> draugiem_complete_login . return_value = login <NEWLINE> response = self . client . get ( <NEWLINE> reverse ( views . callback ) , <NEWLINE> { <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> } ) <NEWLINE> self . assertRedirects ( response , <STRING> , <NEWLINE> <INDENT> fetch_redirect_response = False ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'allauth.socialaccount.providers.draugiem.views'", "'.draugiem_complete_login'", "'apikey'", "'dr_auth_status'", "'ok'", "'dr_auth_code'", "'42'", "'/accounts/profile/'"]}, "err_obj": {"msg": "unexpected indent"}}], ["a8777e4e67335761343329f38515a69a", {"code_string": "npixels = width * height\n    if len(message_bits) > npixels * 3:\n        raise Exception(\"\"\"The message you want to hide is too long (%s > %s).\"\"\" %(len(message_bits), npixels * 3))\n", "code_toks_joined": "npixels = width * height <NEWLINE> <INDENT> if len ( message_bits ) > npixels * 3 : <NEWLINE> <INDENT> raise Exception ( <STRING> % ( len ( message_bits ) , npixels * 3 ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"The message you want to hide is too long (%s > %s).\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["27a19d64aba13c75dfbf1d35bd79f8ca", {"code_string": "def get_egg_info_files(sp_dir):\n    for fn in os.listdir(sp_dir):\n        if not fn.endswith(('.egg', '.egg-info', '.dist-info')):\n            continue\n        path = join(sp_dir, fn)\n        if isfile(path):\n            yield path\n        elif isdir(path):\n            for path2 in[join(path, 'PKG-INFO'),\n                join(path, 'EGG-INFO', 'PKG-INFO'),\n                join(path, 'METADATA')]:\n                if isfile(path2):\n                yield path2\n", "code_toks_joined": "def get_egg_info_files ( sp_dir ) : <NEWLINE> <INDENT> for fn in os . listdir ( sp_dir ) : <NEWLINE> <INDENT> if not fn . endswith ( ( <STRING> , <STRING> , <STRING> ) ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> path = join ( sp_dir , fn ) <NEWLINE> if isfile ( path ) : <NEWLINE> <INDENT> yield path <NEWLINE> <DEDENT> elif isdir ( path ) : <NEWLINE> <INDENT> for path2 in [ join ( path , <STRING> ) , <NEWLINE> <INDENT> join ( path , <STRING> , <STRING> ) , <NEWLINE> join ( path , <STRING> ) ] : <NEWLINE> if isfile ( path2 ) : <NEWLINE> yield path2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'.egg'", "'.egg-info'", "'.dist-info'", "'PKG-INFO'", "'EGG-INFO'", "'PKG-INFO'", "'METADATA'"]}, "err_obj": {"msg": "expected an indented block"}}], ["36313b2ff3ab7ae9fe9e2ef668fd2a98", {"code_string": "def parallel_coutputs(model, data, parallel = multiprocessing.cpu_count(), verbose = 1):\n    results = [None] * len(data)\n    for i, j, outs in common.parallel_map(coutputs_chunk, datachunks(data, model = model), parallel = parallel):\n        if verbose: print \"parallel_coutputs\", i, j, \"(%d)\" % parallel\n        for k in range(j - i): results[i + k] = outs[k]\n    return results\n", "code_toks_joined": "def parallel_coutputs ( model , data , parallel = multiprocessing . cpu_count ( ) , verbose = 1 ) : <NEWLINE> <INDENT> results = [ None ] * len ( data ) <NEWLINE> for i , j , outs in common . parallel_map ( coutputs_chunk , datachunks ( data , model = model ) , parallel = parallel ) : <NEWLINE> <INDENT> if verbose : print <STRING> , i , j , <STRING> % parallel <NEWLINE> for k in range ( j - i ) : results [ i + k ] = outs [ k ] <NEWLINE> <DEDENT> return results <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"parallel_coutputs\"", "\"(%d)\""]}, "err_obj": {"msg": "invalid syntax"}}], ["80fb7029e6dc0f8fc149bf5afce8fdae", {"code_string": "def draw_rectangle(self, (point1, point2), width = 1, color = 'brown'):\n    (x1, y1) = self.pixel_from_point(point1)\n    (x2, y2) = self.pixel_from_point(point2)\n    self.canvas.create_rectangle(x1, y1, x2, y2, fill = color, width = 2)\n", "code_toks_joined": "def draw_rectangle ( self , ( point1 , point2 ) , width = 1 , color = <STRING> ) : <NEWLINE> <INDENT> ( x1 , y1 ) = self . pixel_from_point ( point1 ) <NEWLINE> ( x2 , y2 ) = self . pixel_from_point ( point2 ) <NEWLINE> self . canvas . create_rectangle ( x1 , y1 , x2 , y2 , fill = color , width = 2 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'brown'"]}, "err_obj": {"msg": "invalid syntax"}}], ["6a1fd2467aed109ffcc1677dcdac6025", {"code_string": "def ftpFetchFile(self):\n    offset = 0\n    if self.file is None:\n        try:\n            self.file, offset = self.openFile()\n        except IOError, ie:\n            self.connectionFailed()\n            return\n    offset = self.resume and offset or 0\n    d = self.ftpclient.retrieveFile(self.path, self, offset = offset)\n    d.addCallback(self.ftpFinish).addErrback(self.connectionFailed)\n", "code_toks_joined": "def ftpFetchFile ( self ) : <NEWLINE> <INDENT> offset = 0 <NEWLINE> if self . file is None : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . file , offset = self . openFile ( ) <NEWLINE> <DEDENT> except IOError , ie : <NEWLINE> <INDENT> self . connectionFailed ( ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> offset = self . resume and offset or 0 <NEWLINE> d = self . ftpclient . retrieveFile ( self . path , self , offset = offset ) <NEWLINE> d . addCallback ( self . ftpFinish ) . addErrback ( self . connectionFailed ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["e533dc970837c93db5904ddd8468151e", {"code_string": "def suite():\n    suite = unittest.TestSuite()\n    suite.addTest(TestProjectToDiscreteGenotype('test_no_threshold'))\n    suite.addTest(TestProjectToDiscreteGenotype('test_threshold')\n    suite.addTest(TestCountHomozigotes('test_no_threshold'))\n    suite.addTest(TestGenerateData('runTest'))\n    return suite\n", "code_toks_joined": "def suite ( ) : <NEWLINE> <INDENT> suite = unittest . TestSuite ( ) <NEWLINE> suite . addTest ( TestProjectToDiscreteGenotype ( <STRING> ) ) <NEWLINE> suite . addTest ( TestProjectToDiscreteGenotype ( <STRING> ) <NEWLINE> suite . addTest ( TestCountHomozigotes ( <STRING> ) ) <NEWLINE> suite . addTest ( TestGenerateData ( <STRING> ) ) <NEWLINE> return suite <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'test_no_threshold'", "'test_threshold'", "'test_no_threshold'", "'runTest'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["9b7bb2bf6161a41526afc58c3107bc68", {"code_string": "def troveBuilt(self, (jobId, troveTuple), binaryTroveList):\n    self._hadEvent = True\n    t = self.job.getTrove(* troveTuple)\n    self.server.stopTroveLogger(t)\n    t.troveBuilt(binaryTroveList)\n    t.own()\n", "code_toks_joined": "def troveBuilt ( self , ( jobId , troveTuple ) , binaryTroveList ) : <NEWLINE> <INDENT> self . _hadEvent = True <NEWLINE> t = self . job . getTrove ( * troveTuple ) <NEWLINE> self . server . stopTroveLogger ( t ) <NEWLINE> t . troveBuilt ( binaryTroveList ) <NEWLINE> t . own ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["cf26f8ebb86ae159cbfd3ae9a0ed40c5", {"code_string": "def _cbLogin(self, (iface, avatar, logout)):\n    assert iface is iwords.IUser, \"Realm is buggy, got %r\" %(iface, )\n    del self.irc_PRIVMSG\n    self.avatar = avatar\n    self.logout = logout\n    self.realm = avatar.realm\n    self.hostname = self.realm.name\n    info = {\n        \"serviceName\": self.hostname,\n        \"serviceVersion\": copyright.version,\n        \"creationDate\": ctime(),\n        }\n    for code, text in self._welcomeMessages:\n        self.sendMessage(code, text % info)\n", "code_toks_joined": "def _cbLogin ( self , ( iface , avatar , logout ) ) : <NEWLINE> <INDENT> assert iface is iwords . IUser , <STRING> % ( iface , ) <NEWLINE> del self . irc_PRIVMSG <NEWLINE> self . avatar = avatar <NEWLINE> self . logout = logout <NEWLINE> self . realm = avatar . realm <NEWLINE> self . hostname = self . realm . name <NEWLINE> info = { <NEWLINE> <INDENT> <STRING> : self . hostname , <NEWLINE> <STRING> : copyright . version , <NEWLINE> <STRING> : ctime ( ) , <NEWLINE> } <NEWLINE> <DEDENT> for code , text in self . _welcomeMessages : <NEWLINE> <INDENT> self . sendMessage ( code , text % info ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Realm is buggy, got %r\"", "\"serviceName\"", "\"serviceVersion\"", "\"creationDate\""]}, "err_obj": {"msg": "invalid syntax"}}], ["c5e68d889391055b466c3ecd4d16c7d2", {"code_string": "class TestHeadsUp(unittest.TestCase):\n    \"\"\"Test class for heads up play between two given players.\"\"\"\n    def versus_test(self, player_1, player_2, expected_actions1,\n        expected_actions2, random_seed = None):\n        \"\"\"Tests a sequence of outcomes for two given players.\"\"\"\n        if random_seed:\n        random.seed(random_seed)\n        for outcome_1, outcome_2 in zip(expected_actions1, expected_actions2):\n        player_1.play(player_2)\n        self.assertEqual(player_1.history[- 1], outcome_1)\n        self.assertEqual(player_2.history[- 1], outcome_2)\n", "code_toks_joined": "class TestHeadsUp ( unittest . TestCase ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def versus_test ( self , player_1 , player_2 , expected_actions1 , <NEWLINE> <INDENT> expected_actions2 , random_seed = None ) : <NEWLINE> <STRING> <NEWLINE> if random_seed : <NEWLINE> random . seed ( random_seed ) <NEWLINE> for outcome_1 , outcome_2 in zip ( expected_actions1 , expected_actions2 ) : <NEWLINE> player_1 . play ( player_2 ) <NEWLINE> self . assertEqual ( player_1 . history [ - 1 ] , outcome_1 ) <NEWLINE> self . assertEqual ( player_2 . history [ - 1 ] , outcome_2 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Test class for heads up play between two given players.\"\"\"", "\"\"\"Tests a sequence of outcomes for two given players.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["1198e1a9ea68dda214bc10a4764ea453", {"code_string": "def test_get_coord_connected(self):\n    geocode.connect()\n    coords = geocode.code('2200 Kraft Drive Blacksburg VA')\n    self.assertTrue(isinstance(coords, dict)\n    self.assertTrue('latitude' in coords)\n    self.assertTrue('longitude' in coords)\n", "code_toks_joined": "def test_get_coord_connected ( self ) : <NEWLINE> <INDENT> geocode . connect ( ) <NEWLINE> coords = geocode . code ( <STRING> ) <NEWLINE> self . assertTrue ( isinstance ( coords , dict ) <NEWLINE> self . assertTrue ( <STRING> in coords ) <NEWLINE> self . assertTrue ( <STRING> in coords ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'2200 Kraft Drive Blacksburg VA'", "'latitude'", "'longitude'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["6b57869202590a0b6d42050864ddd0a8", {"code_string": "def mnemonic_to_seed(self, mnemonic, passphrase):\n    import pbkdf2, hashlib, hmac\n    PBKDF2_ROUNDS = 2048\n    mnemonic = unicodedata.normalize('NFKD', ' '.join(mnemonic.split())\n    passphrase = unicodedata.normalize('NFKD', passphrase)\n    return pbkdf2.PBKDF2(mnemonic, 'mnemonic' + passphrase, iterations = PBKDF2_ROUNDS, macmodule = hmac, digestmodule = hashlib.sha512).read(64)\n", "code_toks_joined": "def mnemonic_to_seed ( self , mnemonic , passphrase ) : <NEWLINE> <INDENT> import pbkdf2 , hashlib , hmac <NEWLINE> PBKDF2_ROUNDS = 2048 <NEWLINE> mnemonic = unicodedata . normalize ( <STRING> , <STRING> . join ( mnemonic . split ( ) ) <NEWLINE> passphrase = unicodedata . normalize ( <STRING> , passphrase ) <NEWLINE> return pbkdf2 . PBKDF2 ( mnemonic , <STRING> + passphrase , iterations = PBKDF2_ROUNDS , macmodule = hmac , digestmodule = hashlib . sha512 ) . read ( 64 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'NFKD'", "' '", "'NFKD'", "'mnemonic'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["a36515b4a07a5db8c035220e4bf66f4d", {"code_string": "class StudentAdmin(admin.ModelAdmin):\n    search_fields = ('ID', )\n    list_display = ('ID', 'running', 'match', 'club', 'others')\n    actions = [runningadd, matchadd, clubadd, othersadd]\n    def get_actions(self, request):\n        actions = super(StudentAdmin, self).get_actions(request)\n            if request.user.username != 'sadmin':\n                if 'delete_selected' in actions:\n                    del actions['delete_selected']\n            return actions\n", "code_toks_joined": "class StudentAdmin ( admin . ModelAdmin ) : <NEWLINE> <INDENT> search_fields = ( <STRING> , ) <NEWLINE> list_display = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> actions = [ runningadd , matchadd , clubadd , othersadd ] <NEWLINE> def get_actions ( self , request ) : <NEWLINE> <INDENT> actions = super ( StudentAdmin , self ) . get_actions ( request ) <NEWLINE> <INDENT> if request . user . username != <STRING> : <NEWLINE> <INDENT> if <STRING> in actions : <NEWLINE> <INDENT> del actions [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT> return actions <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'ID'", "'ID'", "'running'", "'match'", "'club'", "'others'", "'sadmin'", "'delete_selected'", "'delete_selected'"]}, "err_obj": {"msg": "unexpected indent"}}], ["fceb6412d566424223a1119ec006b744", {"code_string": "def __getitem__(self, key):\n    with self.lock:\n        x = self.items[key]\n        if time.time() x[0] > self.maxAge and self.maxAge:\n            raise KeyError(\"Cache object contains key, but it expired\")\n        return x[1]\n", "code_toks_joined": "def __getitem__ ( self , key ) : <NEWLINE> <INDENT> with self . lock : <NEWLINE> <INDENT> x = self . items [ key ] <NEWLINE> if time . time ( ) x [ 0 ] > self . maxAge and self . maxAge : <NEWLINE> <INDENT> raise KeyError ( <STRING> ) <NEWLINE> <DEDENT> return x [ 1 ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Cache object contains key, but it expired\""]}, "err_obj": {"msg": "invalid syntax"}}], ["1bbeac7bf3406a4102213b9edf855b49", {"code_string": "import logging\nimport sys\nimport thinrpc\nimport thinrpc.client as client\nthinrpc.logger.setLevel(logging.DEBUG)\nport = int(sys.argv[1])\nrn = client.RpcRemote((\"localhost\", port)\nprint(rn.hello())\n", "code_toks_joined": "import logging <NEWLINE> import sys <NEWLINE> import thinrpc <NEWLINE> import thinrpc . client as client <NEWLINE> thinrpc . logger . setLevel ( logging . DEBUG ) <NEWLINE> port = int ( sys . argv [ 1 ] ) <NEWLINE> rn = client . RpcRemote ( ( <STRING> , port ) <NEWLINE> print ( rn . hello ( ) ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"localhost\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["7aef89858989b8b40a9bee18c98b810a", {"code_string": "def parse_command_line(self):\n    \"\"\"Overrides parse_command_line() to validate the '--package' option and\"\"\"\n    ok = Dist.Dist.parse_command_line(self)\n    if ok:\n        if DEBUG: print \"PackageManager.parse_command_line(): \"\n        if self.package and self.package not in self.package_options:\n            raise DistutilsArgError(\n                \"package '%s' is unknown, use --help-packages \"\n                \"to get a complete listing\" % self.package)\n        defaults = self.package_defaults.setdefault('command_options', {})\n        for command, options in self.command_options.items():\n            command_options = defaults.setdefault(command, {})\n            command_options.update(options)\n    return ok\n", "code_toks_joined": "def parse_command_line ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ok = Dist . Dist . parse_command_line ( self ) <NEWLINE> if ok : <NEWLINE> <INDENT> if DEBUG : print <STRING> <NEWLINE> if self . package and self . package not in self . package_options : <NEWLINE> <INDENT> raise DistutilsArgError ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> % self . package ) <NEWLINE> <DEDENT> <DEDENT> defaults = self . package_defaults . setdefault ( <STRING> , { } ) <NEWLINE> for command , options in self . command_options . items ( ) : <NEWLINE> <INDENT> command_options = defaults . setdefault ( command , { } ) <NEWLINE> command_options . update ( options ) <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Overrides parse_command_line() to validate the '--package' option and\"\"\"", "\"PackageManager.parse_command_line(): \"", "\"package '%s' is unknown, use --help-packages \"", "\"to get a complete listing\"", "'command_options'"]}, "err_obj": {"msg": "invalid syntax"}}], ["ce10b3ab6538e8ec72b4c6d3bec7a38b", {"code_string": "def test_extract(self):\n    fivedaysago = datetime.datetime.now() - datetime.timedelta(days = 5)\n    for field, exp in('year', fivedaysago.year), ('month',\n        fivedaysago.month), ('day', fivedaysago.day):\n        r = testing.db.execute(select([extract(field, func.now()\n            + datetime.timedelta(days = - 5))])).scalar()\n            eq_(r, exp)\n", "code_toks_joined": "def test_extract ( self ) : <NEWLINE> <INDENT> fivedaysago = datetime . datetime . now ( ) - datetime . timedelta ( days = 5 ) <NEWLINE> for field , exp in ( <STRING> , fivedaysago . year ) , ( <STRING> , <NEWLINE> <INDENT> fivedaysago . month ) , ( <STRING> , fivedaysago . day ) : <NEWLINE> r = testing . db . execute ( select ( [ extract ( field , func . now ( ) <NEWLINE> <INDENT> + datetime . timedelta ( days = - 5 ) ) ] ) ) . scalar ( ) <NEWLINE> eq_ ( r , exp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'year'", "'month'", "'day'"]}, "err_obj": {"msg": "unexpected indent"}}], ["ff44f15f00b2adb19f09d11c1a69f7ea", {"code_string": "def test_default_exception_message_if_empty_error_message_from_api():\n    httpretty.register_uri(httpretty.GET, 'http://api.local/v3/test', status = 500, body = None)\n    client = GavagaiClient('foo' host = 'http://api.local')\n    with pytest.raises(GavagaiHttpException) as excinfo:\n        client.request('test', method = 'get')\n    assert excinfo.value.status_code == 500\n    assert 'Unable to complete HTTP request' in excinfo.value.message\n", "code_toks_joined": "def test_default_exception_message_if_empty_error_message_from_api ( ) : <NEWLINE> <INDENT> httpretty . register_uri ( httpretty . GET , <STRING> , status = 500 , body = None ) <NEWLINE> client = GavagaiClient ( <STRING> host = <STRING> ) <NEWLINE> with pytest . raises ( GavagaiHttpException ) as excinfo : <NEWLINE> <INDENT> client . request ( <STRING> , method = <STRING> ) <NEWLINE> <DEDENT> assert excinfo . value . status_code == 500 <NEWLINE> assert <STRING> in excinfo . value . message <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'http://api.local/v3/test'", "'foo'", "'http://api.local'", "'test'", "'get'", "'Unable to complete HTTP request'"]}, "err_obj": {"msg": "invalid syntax"}}], ["66b0bce147aa9688a1b2beb3a5ca662a", {"code_string": "class UnknownDevice(DeviceInfo):\n    '''Unknown device - for example exposed by domain not running currently'''\n    def __init__(self, backend_domain, ident, description = None,\n        frontend_domain = None):\n        if description is None:\n        description = \"Unknown device\"\n        super(UnknownDevice, self).__init__(backend_domain, ident, description,\n        frontend_domain)\n", "code_toks_joined": "class UnknownDevice ( DeviceInfo ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , backend_domain , ident , description = None , <NEWLINE> <INDENT> frontend_domain = None ) : <NEWLINE> if description is None : <NEWLINE> description = <STRING> <NEWLINE> super ( UnknownDevice , self ) . __init__ ( backend_domain , ident , description , <NEWLINE> frontend_domain ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Unknown device - for example exposed by domain not running currently'''", "\"Unknown device\""]}, "err_obj": {"msg": "expected an indented block"}}], ["cadb5c9f52c427a14d3c45f2fbe92e1c", {"code_string": "def Save2Shelf(config, shelfname = 'runs-shelf'):\n    db = shelve.open(shelfname)\n    runname = FindEntry(config)\n    if runname is None:\n        runname = str(int(time.time())))\n    print(runname)\n    db[runname] = config\n    db.close()\n    return runname\n", "code_toks_joined": "def Save2Shelf ( config , shelfname = <STRING> ) : <NEWLINE> <INDENT> db = shelve . open ( shelfname ) <NEWLINE> runname = FindEntry ( config ) <NEWLINE> if runname is None : <NEWLINE> <INDENT> runname = str ( int ( time . time ( ) ) ) ) <NEWLINE> <DEDENT> print ( runname ) <NEWLINE> db [ runname ] = config <NEWLINE> db . close ( ) <NEWLINE> return runname <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'runs-shelf'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["07a72d3ff3885274bf75c802e847ffbe", {"code_string": "class Ui_MainWindow(object):\n    def setupUi(self, MainWindow):\n        MainWindow.setObjectName(\"MainWindow\")\n        MainWindow.resize(1162, 679)\n        font = QtGui.QFont()\n        font.setFamily(\"Droid Sans [unknown]\")\n        MainWindow.setFont(font)\n        self.centralwidget = QtWidgets.QWidget(MainWindow)\n        self.centralwidget.setObjectName(\"centralwidget\")\n        self.label = QtWidgets.QLabel(self.centralwidget)\n        self.label.setGeometry(QtCore.QRect(90, 0, 91, 41))\n        self.label.setStyleSheet(\"QLabel{\\n\"\n", "code_toks_joined": "class Ui_MainWindow ( object ) : <NEWLINE> <INDENT> def setupUi ( self , MainWindow ) : <NEWLINE> <INDENT> MainWindow . setObjectName ( <STRING> ) <NEWLINE> MainWindow . resize ( 1162 , 679 ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setFamily ( <STRING> ) <NEWLINE> MainWindow . setFont ( font ) <NEWLINE> self . centralwidget = QtWidgets . QWidget ( MainWindow ) <NEWLINE> self . centralwidget . setObjectName ( <STRING> ) <NEWLINE> self . label = QtWidgets . QLabel ( self . centralwidget ) <NEWLINE> self . label . setGeometry ( QtCore . QRect ( 90 , 0 , 91 , 41 ) ) <NEWLINE> self . label . setStyleSheet ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"MainWindow\"", "\"Droid Sans [unknown]\"", "\"centralwidget\"", "\"QLabel{\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["ed7c0567e91bc6a056f4600f3a7920e5", {"code_string": "def _getaction(action):\n    if not action:\n        return \"default\"\n    if action == \"all\": return \"always\"\n    for a in('default', 'always', 'ignore', 'module', 'once', 'error'):\n        if a.startswith(action):\n            return a\n    raise _OptionError(\"invalid action: %r\" %(action, )\n", "code_toks_joined": "def _getaction ( action ) : <NEWLINE> <INDENT> if not action : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if action == <STRING> : return <STRING> <NEWLINE> for a in ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> if a . startswith ( action ) : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> <DEDENT> raise _OptionError ( <STRING> % ( action , ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"default\"", "\"all\"", "\"always\"", "'default'", "'always'", "'ignore'", "'module'", "'once'", "'error'", "\"invalid action: %r\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["ca9cfbbed2d05895b75bc51b9ccae733", {"code_string": "def retrieve_network_row_by_ifname(cfg, ifname, filter):\n    data = cfg.dbsess.query(Network).filter(Network.interface == ifname)\n    for k in filter.keys():\n        exec 'data = data.filter(Network.%s==filter[\"%s\"])' %(k, k)\n    if data.count() > 0:\n        return data.one()\n    else:\n        return False\n", "code_toks_joined": "def retrieve_network_row_by_ifname ( cfg , ifname , filter ) : <NEWLINE> <INDENT> data = cfg . dbsess . query ( Network ) . filter ( Network . interface == ifname ) <NEWLINE> for k in filter . keys ( ) : <NEWLINE> <INDENT> exec <STRING> % ( k , k ) <NEWLINE> <DEDENT> if data . count ( ) > 0 : <NEWLINE> <INDENT> return data . one ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'data = data.filter(Network.%s==filter[\"%s\"])'"]}, "err_obj": {"msg": "invalid syntax"}}], ["cebc51dac66aae3fd6ef647eea6a002e", {"code_string": "def getUserTagsTest():\n    push = IGeTui(HOST, APPKEY, MASTERSECRET)\n    dictz = push.getUserTags(APPID, CID)\n    for key in dictz:\n    print(key + \":\" + dictz[key].decode(\"utf-8\"))\n", "code_toks_joined": "def getUserTagsTest ( ) : <NEWLINE> <INDENT> push = IGeTui ( HOST , APPKEY , MASTERSECRET ) <NEWLINE> dictz = push . getUserTags ( APPID , CID ) <NEWLINE> for key in dictz : <NEWLINE> print ( key + <STRING> + dictz [ key ] . decode ( <STRING> ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\":\"", "\"utf-8\""]}, "err_obj": {"msg": "expected an indented block"}}], ["7859fa6bc1b37018bc3fdc531221f4fb", {"code_string": "from cpython cimport array as c_array\nfrom array import array\ncdef c_array.array a = array('i', [1, 2, 3])\ncdef int[: ] ca = a\ncdef int overhead(object a):\n    cdef int[: ] ca = a\n    return ca[0]\ncdef int no_overhead(int[: ] ca):\n    return ca[0]\nprint(overhead(a))\nprint(no_overhead(ca))\n", "code_toks_joined": "from cpython cimport array as c_array <NEWLINE> from array import array <NEWLINE> cdef c_array . array a = array ( <STRING> , [ 1 , 2 , 3 ] ) <NEWLINE> cdef int [ : ] ca = a <NEWLINE> cdef int overhead ( object a ) : <NEWLINE> <INDENT> cdef int [ : ] ca = a <NEWLINE> return ca [ 0 ] <NEWLINE> <DEDENT> cdef int no_overhead ( int [ : ] ca ) : <NEWLINE> <INDENT> return ca [ 0 ] <NEWLINE> <DEDENT> print ( overhead ( a ) ) <NEWLINE> print ( no_overhead ( ca ) ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["'i'"]}, "err_obj": {"msg": "invalid syntax"}}], ["c732922f5538cee4f7efcfeab573b00a", {"code_string": "def get_host_ipv4():\n    all_ifaces = ni.interfaces()\n    host_iface = None\n    for iface in all_ifaces:\n        if \"eth0\" in iface:\n            host_iface = iface\n            break\n    if host_iface == None:\n        print(logging.critical(\"Unable to find an interface ending with\")\n            \" \\'eth0\\'\")\n        sys.exit(1)\n    host_ipv4 = ni.ifaddresses(host_iface)[ni.AF_INET][0][\"addr\"]\n    return host_ipv4\n", "code_toks_joined": "def get_host_ipv4 ( ) : <NEWLINE> <INDENT> all_ifaces = ni . interfaces ( ) <NEWLINE> host_iface = None <NEWLINE> for iface in all_ifaces : <NEWLINE> <INDENT> if <STRING> in iface : <NEWLINE> <INDENT> host_iface = iface <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if host_iface == None : <NEWLINE> <INDENT> print ( logging . critical ( <STRING> ) <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> sys . exit ( 1 ) <NEWLINE> <DEDENT> host_ipv4 = ni . ifaddresses ( host_iface ) [ ni . AF_INET ] [ 0 ] [ <STRING> ] <NEWLINE> return host_ipv4 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"eth0\"", "\"Unable to find an interface ending with\"", "\" \\'eth0\\'\"", "\"addr\""]}, "err_obj": {"msg": "invalid syntax"}}], ["9c94d3e99f15fd7a47131934f3a1e670", {"code_string": "class DragStartEvent extends DragEvent:\n    def __init__(self, context):\n        super(context)\n        assert context.vetoException is None\n        assert context.dropController is None\n        assert context.finalDropController is None\n    \"\"\"** Return a string representation of this event.\"\"\"\n    def toString(self):\n        return \"DragStartEvent(source=\" + getSourceShortTypeName() + \")\"\n", "code_toks_joined": "class DragStartEvent extends DragEvent : <NEWLINE> <INDENT> def __init__ ( self , context ) : <NEWLINE> <INDENT> super ( context ) <NEWLINE> assert context . vetoException is None <NEWLINE> assert context . dropController is None <NEWLINE> assert context . finalDropController is None <NEWLINE> <DEDENT> <STRING> <NEWLINE> def toString ( self ) : <NEWLINE> <INDENT> return <STRING> + getSourceShortTypeName ( ) + <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"** Return a string representation of this event.\"\"\"", "\"DragStartEvent(source=\"", "\")\""]}, "err_obj": {"msg": "invalid syntax"}}], ["9cb95d94e860a3fff8380b8d299180e0", {"code_string": "class Command(BaseCommand):\n    help = 'Creates current_version\\'s for themes that are missing them.'\n    def handle(self, * args, ** options):\n        for addon in Addon.objects.filter(type = amo.ADDON_PERSONA,\n            _current_version__isnull = True):\n            if addon._latest_version:\n            addon.update(_current_version = addon._latest_version,\n            _signal = False)\n            else:\n            version = Version.objects.create(addon = addon, version = '0')\n            addon.update(_current_version = version, _signal = False)\n            log.info('Fixed missing current version for add-on %s' % addon.id)\n", "code_toks_joined": "class Command ( BaseCommand ) : <NEWLINE> <INDENT> help = <STRING> <NEWLINE> def handle ( self , * args , ** options ) : <NEWLINE> <INDENT> for addon in Addon . objects . filter ( type = amo . ADDON_PERSONA , <NEWLINE> <INDENT> _current_version__isnull = True ) : <NEWLINE> if addon . _latest_version : <NEWLINE> addon . update ( _current_version = addon . _latest_version , <NEWLINE> _signal = False ) <NEWLINE> else : <NEWLINE> version = Version . objects . create ( addon = addon , version = <STRING> ) <NEWLINE> addon . update ( _current_version = version , _signal = False ) <NEWLINE> log . info ( <STRING> % addon . id ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Creates current_version\\'s for themes that are missing them.'", "'0'", "'Fixed missing current version for add-on %s'"]}, "err_obj": {"msg": "expected an indented block"}}], ["d49ce601fb9c17e22b2209856b36ab37", {"code_string": "def setUp(self):\n    self.client.login(username = 'super' password = 'secret')\n    e = Episode.objects.create(name = 'This Week in Django')\n    self.episode_pk = e.pk\n    m = Media(content_object = e, url = 'http://example.com/podcast.mp3')\n    m.save()\n    self.mp3_media_pk = m.pk\n    m = Media(content_object = e, url = 'http://example.com/logo.png')\n    m.save()\n    self.png_media_pk = m.pk\n", "code_toks_joined": "def setUp ( self ) : <NEWLINE> <INDENT> self . client . login ( username = <STRING> password = <STRING> ) <NEWLINE> e = Episode . objects . create ( name = <STRING> ) <NEWLINE> self . episode_pk = e . pk <NEWLINE> m = Media ( content_object = e , url = <STRING> ) <NEWLINE> m . save ( ) <NEWLINE> self . mp3_media_pk = m . pk <NEWLINE> m = Media ( content_object = e , url = <STRING> ) <NEWLINE> m . save ( ) <NEWLINE> self . png_media_pk = m . pk <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'super'", "'secret'", "'This Week in Django'", "'http://example.com/podcast.mp3'", "'http://example.com/logo.png'"]}, "err_obj": {"msg": "invalid syntax"}}], ["a4323f790a5e46ef5faa3a72413afbe8", {"code_string": "def plug_removed(self, w, (win, socket)):\n    win.hide()\n    return True\n", "code_toks_joined": "def plug_removed ( self , w , ( win , socket ) ) : <NEWLINE> <INDENT> win . hide ( ) <NEWLINE> return True <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["f7864be6dd051df541e1ef4e81a02028", {"code_string": "def fitting(fn, data, parms = None, steps = None):\n    \"\"\" fitting(fn,data,parms=None,steps=None) -\"\"\"\n    try:\n    f = functions[fn]\n    np = f['NumPar']\n    if parms == None:\n        parms = []\n        for i in range(np):\n    s = data[i]\n        parms.append(s[1])\n        RETS = leastSquaresFit(f['Function'], parms, data, max_iterations = steps)\n        return RETS\n    except:\n    print('fitting failed on data')\n    return None\n", "code_toks_joined": "def fitting ( fn , data , parms = None , steps = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> f = functions [ fn ] <NEWLINE> np = f [ <STRING> ] <NEWLINE> if parms == None : <NEWLINE> <INDENT> parms = [ ] <NEWLINE> for i in range ( np ) : <NEWLINE> <DEDENT> s = data [ i ] <NEWLINE> <INDENT> parms . append ( s [ 1 ] ) <NEWLINE> RETS = leastSquaresFit ( f [ <STRING> ] , parms , data , max_iterations = steps ) <NEWLINE> return RETS <NEWLINE> <DEDENT> except : <NEWLINE> print ( <STRING> ) <NEWLINE> return None <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" fitting(fn,data,parms=None,steps=None) -\"\"\"", "'NumPar'", "'Function'", "'fitting failed on data'"]}, "err_obj": {"msg": "expected an indented block"}}], ["9b64dc162b3cb80691d5f260ca9fa66d", {"code_string": "def terminate(self, graceperiod = 1):\n    \"\"\"Terminate the process, with escalating force as needed.\"\"\"\n    if self.__process.stdin:\n        self.closeinput()\n        try:\n        return with_timeout(graceperiod, self.wait)\n        except Timeout:\n        pass\n    self.kill(signal.SIGTERM)\n    try:\n        return with_timeout(graceperiod, self.wait)\n    except Timeout:\n        pass\n    self.kill(signal.SIGKILL)\n    return self.wait()\n", "code_toks_joined": "def terminate ( self , graceperiod = 1 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . __process . stdin : <NEWLINE> <INDENT> self . closeinput ( ) <NEWLINE> try : <NEWLINE> return with_timeout ( graceperiod , self . wait ) <NEWLINE> except Timeout : <NEWLINE> pass <NEWLINE> <DEDENT> self . kill ( signal . SIGTERM ) <NEWLINE> try : <NEWLINE> <INDENT> return with_timeout ( graceperiod , self . wait ) <NEWLINE> <DEDENT> except Timeout : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> self . kill ( signal . SIGKILL ) <NEWLINE> return self . wait ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Terminate the process, with escalating force as needed.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["8c27ea1980df423a7fc2b2e9ee3387d1", {"code_string": "def _ensure_driver_supports_request(drv, router_body):\n    r = router_body\n    for key, attr in(('distributed', 'distributed_support'),\n        ('ha', 'ha_support')):\n        flag = r.get(key)\n        if flag not in[True, False]:\n        continue\n        if not getattr(drv, attr).is_compatible(flag):\n        raise lib_exc.InvalidInput(error_message = (\n        _(\"Provider %(name)s does not support %(key)s=%(flag)s\")\n        % dict(name = drv.name, key = key, flag = flag)))\n", "code_toks_joined": "def _ensure_driver_supports_request ( drv , router_body ) : <NEWLINE> <INDENT> r = router_body <NEWLINE> for key , attr in ( ( <STRING> , <STRING> ) , <NEWLINE> <INDENT> ( <STRING> , <STRING> ) ) : <NEWLINE> flag = r . get ( key ) <NEWLINE> if flag not in [ True , False ] : <NEWLINE> continue <NEWLINE> if not getattr ( drv , attr ) . is_compatible ( flag ) : <NEWLINE> raise lib_exc . InvalidInput ( error_message = ( <NEWLINE> _ ( <STRING> ) <NEWLINE> % dict ( name = drv . name , key = key , flag = flag ) ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'distributed'", "'distributed_support'", "'ha'", "'ha_support'", "\"Provider %(name)s does not support %(key)s=%(flag)s\""]}, "err_obj": {"msg": "expected an indented block"}}], ["3bf8a42f31ed7b20eb4db76772d87110", {"code_string": "def lookup(the_dict, key):\n    the_dict = json.loads(the_dict)\n    if the_dict.get(key, '')[1] == 'upload':\n        url = reverse('proposals:serve_file', kwargs = {'filename': os.path.basename(the_dict.get(key, '')[0])})\n            return '<a href=\"%s\">Download File</a>' % url\n        else:\n            return linebreaksbr(mark_safe(the_dict.get(key, '')[0]))\n", "code_toks_joined": "def lookup ( the_dict , key ) : <NEWLINE> <INDENT> the_dict = json . loads ( the_dict ) <NEWLINE> if the_dict . get ( key , <STRING> ) [ 1 ] == <STRING> : <NEWLINE> <INDENT> url = reverse ( <STRING> , kwargs = { <STRING> : os . path . basename ( the_dict . get ( key , <STRING> ) [ 0 ] ) } ) <NEWLINE> <INDENT> return <STRING> % url <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return linebreaksbr ( mark_safe ( the_dict . get ( key , <STRING> ) [ 0 ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "'upload'", "'proposals:serve_file'", "'filename'", "''", "'<a href=\"%s\">Download File</a>'", "''"]}, "err_obj": {"msg": "unexpected indent"}}], ["117117a3173642bef17c2ca939f122de", {"code_string": "class Ui_CercaGeo(object):\n    def setupUi(self, CercaGeo):\n        CercaGeo.setObjectName(_fromUtf8(\"CercaGeo\"))\n        CercaGeo.setWindowModality(QtCore.Qt.NonModal)\n        CercaGeo.resize(270, 210)\n        CercaGeo.setMinimumSize(QtCore.QSize(270, 210))\n        CercaGeo.setMaximumSize(QtCore.QSize(270, 210))\n        icon = QtGui.QIcon()\n        icon.addPixmap(QtGui.QPixmap(_fromUtf8(\":/resources/icon.png\")), QtGui.QIcon.Normal, QtGui.QIcon.Off)\n        CercaGeo.setWindowIcon(icon)\n        self.centralWidget = QtGui.QWidget(CercaGeo)\n        self.centralWidget.setStyleSheet(_fromUtf8(\"/* sets background color  */\\n\"\n", "code_toks_joined": "class Ui_CercaGeo ( object ) : <NEWLINE> <INDENT> def setupUi ( self , CercaGeo ) : <NEWLINE> <INDENT> CercaGeo . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> CercaGeo . setWindowModality ( QtCore . Qt . NonModal ) <NEWLINE> CercaGeo . resize ( 270 , 210 ) <NEWLINE> CercaGeo . setMinimumSize ( QtCore . QSize ( 270 , 210 ) ) <NEWLINE> CercaGeo . setMaximumSize ( QtCore . QSize ( 270 , 210 ) ) <NEWLINE> icon = QtGui . QIcon ( ) <NEWLINE> icon . addPixmap ( QtGui . QPixmap ( _fromUtf8 ( <STRING> ) ) , QtGui . QIcon . Normal , QtGui . QIcon . Off ) <NEWLINE> CercaGeo . setWindowIcon ( icon ) <NEWLINE> self . centralWidget = QtGui . QWidget ( CercaGeo ) <NEWLINE> self . centralWidget . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"CercaGeo\"", "\":/resources/icon.png\"", "\"/* sets background color  */\\n\""]}, "window_span": [134, 141], "err_obj": {"msg": "unbalanced (){}[]"}}], ["d0fa4398cd42f957583cd73c495f1991", {"code_string": "def get_data_path():\n    try:\n        exec \"import platformcode.\" + PLATFORM_NAME + \".config as platformconfig\"\n    except:\n        exec \"import \" + PLATFORM_NAME + \"config as platformconfig\"\n    return platformconfig.get_data_path()\n", "code_toks_joined": "def get_data_path ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> exec <STRING> + PLATFORM_NAME + <STRING> <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> exec <STRING> + PLATFORM_NAME + <STRING> <NEWLINE> <DEDENT> return platformconfig . get_data_path ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"import platformcode.\"", "\".config as platformconfig\"", "\"import \"", "\"config as platformconfig\""]}, "err_obj": {"msg": "invalid syntax"}}], ["96816b81fbfb48bb86b1c105f520af5a", {"code_string": "def debug_heroes(GAME):\n    HEROES = GAME['DATA']['heroes']\n    for i in range(len(HEROES)):\n        hero = HEROES[i]\n        if hero['player'] == 0:\n            print(\"hero %i\" % i)\n                for k in hero.keys():\n                    print(\"\t%s: %s\" %(k, hero[k]))\n                print\n", "code_toks_joined": "def debug_heroes ( GAME ) : <NEWLINE> <INDENT> HEROES = GAME [ <STRING> ] [ <STRING> ] <NEWLINE> for i in range ( len ( HEROES ) ) : <NEWLINE> <INDENT> hero = HEROES [ i ] <NEWLINE> if hero [ <STRING> ] == 0 : <NEWLINE> <INDENT> print ( <STRING> % i ) <NEWLINE> <INDENT> for k in hero . keys ( ) : <NEWLINE> <INDENT> print ( <STRING> % ( k , hero [ k ] ) ) <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'DATA'", "'heroes'", "'player'", "\"hero %i\"", "\"\t%s: %s\""]}, "err_obj": {"msg": "unexpected indent"}}], ["f86d8eefe23f4a503fd03e9369b1aa41", {"code_string": "class Loader(collections.namedtuple('Loader', _loader_attrs)):\n    def __new__(cls, field_generator, field_generator_kwargs, converter,\n        legacy_custom_rules = None):\n        \"\"\"Create a definition of a field-based Cube loader.\"\"\"\n        if legacy_custom_rules is not None:\n        warnings.warn('The `legacy_custom_rules` attribute is '\n            'deprecated.')\n            return tuple.__new__(cls, (field_generator, field_generator_kwargs,\n                converter, legacy_custom_rules))\n", "code_toks_joined": "class Loader ( collections . namedtuple ( <STRING> , _loader_attrs ) ) : <NEWLINE> <INDENT> def __new__ ( cls , field_generator , field_generator_kwargs , converter , <NEWLINE> <INDENT> legacy_custom_rules = None ) : <NEWLINE> <STRING> <NEWLINE> if legacy_custom_rules is not None : <NEWLINE> warnings . warn ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> return tuple . __new__ ( cls , ( field_generator , field_generator_kwargs , <NEWLINE> <INDENT> converter , legacy_custom_rules ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Loader'", "\"\"\"Create a definition of a field-based Cube loader.\"\"\"", "'The `legacy_custom_rules` attribute is '", "'deprecated.'"]}, "err_obj": {"msg": "expected an indented block"}}], ["98208a19ec5177e0acba9e6263176154", {"code_string": "def opendir(self, widget, event, index):\n    if Globals.MenuButtonSub[index] == 0:\n        self.Launcher.Launch(Globals.MenuButtonCommands[index])\n        else:\n            self.PGL.CallSpecialMenu(int(Globals.MenuButtonCommands[index]))\n    self.GnomeMenu_unmap(event)\n", "code_toks_joined": "def opendir ( self , widget , event , index ) : <NEWLINE> <INDENT> if Globals . MenuButtonSub [ index ] == 0 : <NEWLINE> <INDENT> self . Launcher . Launch ( Globals . MenuButtonCommands [ index ] ) <NEWLINE> else : <NEWLINE> <INDENT> self . PGL . CallSpecialMenu ( int ( Globals . MenuButtonCommands [ index ] ) ) <NEWLINE> <DEDENT> <DEDENT> self . GnomeMenu_unmap ( event ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["5a6ddf68b1649dc0bfa5be3b2a5d92b9", {"code_string": "def __init__(self, settings, model, agentName, layer, uniqInMap = True):\n    super(Bee, self).__init__(settings, model, agentName, layer, uniqInMap)\n    self.state = _STATE_FLY\n        self.hero = self.layer.getInstance('PC')\n        self.girl = self.layer.getInstance('NPC:girl')\n        self.beekeeper = self.layer.getInstance('beekeeper')\n", "code_toks_joined": "def __init__ ( self , settings , model , agentName , layer , uniqInMap = True ) : <NEWLINE> <INDENT> super ( Bee , self ) . __init__ ( settings , model , agentName , layer , uniqInMap ) <NEWLINE> self . state = _STATE_FLY <NEWLINE> <INDENT> self . hero = self . layer . getInstance ( <STRING> ) <NEWLINE> self . girl = self . layer . getInstance ( <STRING> ) <NEWLINE> self . beekeeper = self . layer . getInstance ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'PC'", "'NPC:girl'", "'beekeeper'"]}, "err_obj": {"msg": "unexpected indent"}}], ["29b60b4eb7dee2b10f1a79a80fda6a0c", {"code_string": "class ScriptModifiedHandler(PatternMatchingEventHandler):\n    patterns = ['*.py']\n    def __init__(self):\n        super(ScriptModifiedHandler, self).__init__()\n    def process(self, event):\n        print(event.src_path, event.event_type)\n    def on_modified(self, event):\n        self.process(event)\n    def on_moved(self, event):\n    pass\n    def on_deleted(self, event):\n    pass\n    def on_created(self, event):\n    pass\n", "code_toks_joined": "class ScriptModifiedHandler ( PatternMatchingEventHandler ) : <NEWLINE> <INDENT> patterns = [ <STRING> ] <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> super ( ScriptModifiedHandler , self ) . __init__ ( ) <NEWLINE> <DEDENT> def process ( self , event ) : <NEWLINE> <INDENT> print ( event . src_path , event . event_type ) <NEWLINE> <DEDENT> def on_modified ( self , event ) : <NEWLINE> <INDENT> self . process ( event ) <NEWLINE> <DEDENT> def on_moved ( self , event ) : <NEWLINE> pass <NEWLINE> def on_deleted ( self , event ) : <NEWLINE> pass <NEWLINE> def on_created ( self , event ) : <NEWLINE> pass <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'*.py'"]}, "err_obj": {"msg": "expected an indented block"}}], ["5fb618fc61bf482b351c66f40e606b4f", {"code_string": "def check_mutated(step, expected_changed, ratio):\n    num = len(world.inds_before_mutation)\n    expected = int(expected_changed)\n    ratio = float(ratio)\n    num_changed = 0\n    for i in xrange(num):\n    is_equals = (world.inds_before_mutation[i] == world.inds_after_mutation[i]).all()\n    if not is_equals:\n        num_changed += 1\n    assert abs(num_changed - expected) <= ratio, \"Solution mutated are too different: %d expected and %d received\" %(expected, num_changed)\n", "code_toks_joined": "def check_mutated ( step , expected_changed , ratio ) : <NEWLINE> <INDENT> num = len ( world . inds_before_mutation ) <NEWLINE> expected = int ( expected_changed ) <NEWLINE> ratio = float ( ratio ) <NEWLINE> num_changed = 0 <NEWLINE> for i in xrange ( num ) : <NEWLINE> is_equals = ( world . inds_before_mutation [ i ] == world . inds_after_mutation [ i ] ) . all ( ) <NEWLINE> if not is_equals : <NEWLINE> <INDENT> num_changed += 1 <NEWLINE> <DEDENT> assert abs ( num_changed - expected ) <= ratio , <STRING> % ( expected , num_changed ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Solution mutated are too different: %d expected and %d received\""]}, "err_obj": {"msg": "expected an indented block"}}], ["6f3c3e9bb5821a95fcb17582f835176e", {"code_string": "def getLabel(l, labelMap):\n    labelC = l\n    while labelC in labelMap:\n        if labelMap[labelC] == labelC\n            return labelC\n        labelC = labelMap[labelC]\n    return labelC\n", "code_toks_joined": "def getLabel ( l , labelMap ) : <NEWLINE> <INDENT> labelC = l <NEWLINE> while labelC in labelMap : <NEWLINE> <INDENT> if labelMap [ labelC ] == labelC <NEWLINE> <INDENT> return labelC <NEWLINE> <DEDENT> labelC = labelMap [ labelC ] <NEWLINE> <DEDENT> return labelC <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["4b8a4f89e94e527b2046fd1b96cabb8b", {"code_string": "def readS8(self, reg):\n    \"Reads a signed byte from the I2C device\"\n    try:\n        result = self.bus.read_byte_data(self.address, reg)\n        if result > 127: result -= 256\n        if self.debug:\n            print(\"I2C: Device 0x%02X returned 0x%02X from reg 0x%02X\" %\n                (self.address, result & 0xFF, reg))\n        return result\n    except IOError, err:\n        return self.errMsg()\n", "code_toks_joined": "def readS8 ( self , reg ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> result = self . bus . read_byte_data ( self . address , reg ) <NEWLINE> if result > 127 : result -= 256 <NEWLINE> if self . debug : <NEWLINE> <INDENT> print ( <STRING> % <NEWLINE> <INDENT> ( self . address , result & 0xFF , reg ) ) <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <DEDENT> except IOError , err : <NEWLINE> <INDENT> return self . errMsg ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Reads a signed byte from the I2C device\"", "\"I2C: Device 0x%02X returned 0x%02X from reg 0x%02X\""]}, "err_obj": {"msg": "invalid syntax"}}], ["c195dc4a5b63dcd5a740d538456fc7d7", {"code_string": "def _contains_dirs(self, dir):\n    for f in os.listdir(dir):\n        if os.path.isdir(os.path.join(dir, f))\n            return True\n    return False\n", "code_toks_joined": "def _contains_dirs ( self , dir ) : <NEWLINE> <INDENT> for f in os . listdir ( dir ) : <NEWLINE> <INDENT> if os . path . isdir ( os . path . join ( dir , f ) ) <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["b4781ed2ec14cb4bd386a004ce74194d", {"code_string": "def judge(self, (dist, hash), (n, )):\n    if dist > n:\n        return 1\n    elif dist == n:\n        return 0\n    else:\n        return - 1\n", "code_toks_joined": "def judge ( self , ( dist , hash ) , ( n , ) ) : <NEWLINE> <INDENT> if dist > n : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif dist == n : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["67f1188b1ca02b046cb7ac3a767c314c", {"code_string": "def MemWrite(self, addr, data):\n    set address(addr)\n    data.setgpio(val)\n    wr = 0\n    mreq = 0\n    wr = 1\n    mreq = 1\n    iodir0 = 0xff\n    return\n", "code_toks_joined": "def MemWrite ( self , addr , data ) : <NEWLINE> <INDENT> set address ( addr ) <NEWLINE> data . setgpio ( val ) <NEWLINE> wr = 0 <NEWLINE> mreq = 0 <NEWLINE> wr = 1 <NEWLINE> mreq = 1 <NEWLINE> iodir0 = 0xff <NEWLINE> return <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["204785b8e91138adf2f00040f209fd9f", {"code_string": "def _registerFontStyleSheet():\n    \"\"\"Get fonts, and register default with StyleSheet and Text class.\"\"\"\n    families = qt4.QFontDatabase().families()\n    deffont = None\n    for f in('Times New Roman', 'Bitstream Vera Serif', 'Times', 'Utopia',\n        'Serif'):\n        if f in families:\n        deffont = f\n        break\n    if deffont is None:\n        print(\"Warning: did not find a sensible default font. Choosing first font.\", file = sys.stderr)\n        deffont = families[0]\n    collections.Text.defaultfamily = deffont\n    collections.Text.families = families\n    StylesheetText.defaultfamily = deffont\n    StylesheetText.families = families\n", "code_toks_joined": "def _registerFontStyleSheet ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> families = qt4 . QFontDatabase ( ) . families ( ) <NEWLINE> deffont = None <NEWLINE> for f in ( <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> if f in families : <NEWLINE> deffont = f <NEWLINE> break <NEWLINE> <DEDENT> if deffont is None : <NEWLINE> <INDENT> print ( <STRING> , file = sys . stderr ) <NEWLINE> deffont = families [ 0 ] <NEWLINE> <DEDENT> collections . Text . defaultfamily = deffont <NEWLINE> collections . Text . families = families <NEWLINE> StylesheetText . defaultfamily = deffont <NEWLINE> StylesheetText . families = families <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get fonts, and register default with StyleSheet and Text class.\"\"\"", "'Times New Roman'", "'Bitstream Vera Serif'", "'Times'", "'Utopia'", "'Serif'", "\"Warning: did not find a sensible default font. Choosing first font.\""]}, "err_obj": {"msg": "expected an indented block"}}], ["1a63f9b39c10e6406aff751858c64d08", {"code_string": "def __init__(self, serv ev, conf = {}, admins = []):\n    self.session = None\n    self.serv = serv\n    self.ev = ev\n    self.conf = conf\n    self.admins = admins\n", "code_toks_joined": "def __init__ ( self , serv ev , conf = { } , admins = [ ] ) : <NEWLINE> <INDENT> self . session = None <NEWLINE> self . serv = serv <NEWLINE> self . ev = ev <NEWLINE> self . conf = conf <NEWLINE> self . admins = admins <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["25e72b6531f3d98099a128ffa161d359", {"code_string": "import pyplot as plt\nimport numpy as np\n    def build_step(self):\n\"\"\"Build and install WRF and testcases using provided compile script.\"\"\"\np = self.cfg['parallel']\nself.par = \"\"\nif p:\nself.par = \"-j %s\" % p\ncmd = \"tcsh ./compile %s wrf\" % self.par\nrun_cmd(cmd, log_all = True, simple = True, log_output = True)\nfor test in[\"em_real\", \"em_b_wave\"]:\ncmd = \"tcsh ./compile %s %s\" %(self.par, test)\nrun_cmd(cmd, log_all = True, simple = True, log_output = True)\n", "code_toks_joined": "import pyplot as plt <NEWLINE> import numpy as np <NEWLINE> <INDENT> def build_step ( self ) : <NEWLINE> <DEDENT> <STRING> <NEWLINE> p = self . cfg [ <STRING> ] <NEWLINE> self . par = <STRING> <NEWLINE> if p : <NEWLINE> self . par = <STRING> % p <NEWLINE> cmd = <STRING> % self . par <NEWLINE> run_cmd ( cmd , log_all = True , simple = True , log_output = True ) <NEWLINE> for test in [ <STRING> , <STRING> ] : <NEWLINE> cmd = <STRING> % ( self . par , test ) <NEWLINE> run_cmd ( cmd , log_all = True , simple = True , log_output = True ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"\"\"Build and install WRF and testcases using provided compile script.\"\"\"", "'parallel'", "\"\"", "\"-j %s\"", "\"tcsh ./compile %s wrf\"", "\"em_real\"", "\"em_b_wave\"", "\"tcsh ./compile %s %s\""]}, "err_obj": {"msg": "unexpected indent"}}], ["00362a2830d91de4844e9e2e59e57c6d", {"code_string": "def test_create_folder_dupe(self):\n    \"\"\"Tests if creating a folder fails correctly if one already exists\"\"\"\n    path = posixpath.join(self.test_dir, \"new_folder_dupe\")\n    metadata = self.client.file_create_folder(path)\n    self.assertRaises(\n        ErrorResponse\n        lambda: self.client.file_create_folder(path)\n    )\n", "code_toks_joined": "def test_create_folder_dupe ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> path = posixpath . join ( self . test_dir , <STRING> ) <NEWLINE> metadata = self . client . file_create_folder ( path ) <NEWLINE> self . assertRaises ( <NEWLINE> <INDENT> ErrorResponse <NEWLINE> lambda : self . client . file_create_folder ( path ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Tests if creating a folder fails correctly if one already exists\"\"\"", "\"new_folder_dupe\""]}, "err_obj": {"msg": "invalid syntax"}}], ["ec5fcc34a6e8662a330aaaf97c1752f3", {"code_string": "def cambiarEstado(self, mac, estado):\n    if estado == 1:\n        self.latchAux.actualizar_dispositivo(mac, 1)\n        commands.getstatusoutput('ubus call hostapd.wlan0 del_client ' + \"'\" + '{\"addr\":\"' + mac + '\", \"reason\":1, \"deauth\":true, \"ban_time\":5000}' + \"'\")\n        else:\n        self.latchAux.actualizar_dispositivo(mac, 0)\n", "code_toks_joined": "def cambiarEstado ( self , mac , estado ) : <NEWLINE> <INDENT> if estado == 1 : <NEWLINE> <INDENT> self . latchAux . actualizar_dispositivo ( mac , 1 ) <NEWLINE> commands . getstatusoutput ( <STRING> + <STRING> + <STRING> + mac + <STRING> + <STRING> ) <NEWLINE> else : <NEWLINE> self . latchAux . actualizar_dispositivo ( mac , 0 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'ubus call hostapd.wlan0 del_client '", "\"'\"", "'{\"addr\":\"'", "'\", \"reason\":1, \"deauth\":true, \"ban_time\":5000}'", "\"'\""]}, "err_obj": {"msg": "invalid syntax"}}], ["3f55469e7a87c4019c410c392e0282c4", {"code_string": "def test_traffic__not_public(self):\n    subreddit = self.reddit.subreddit('announcements')\n    with self.recorder.use_cassette(\n        'TestSubreddit.test_traffic__not_public'):\n        with pytest.raises(NotFound):\n        subreddit.traffic()\n", "code_toks_joined": "def test_traffic__not_public ( self ) : <NEWLINE> <INDENT> subreddit = self . reddit . subreddit ( <STRING> ) <NEWLINE> with self . recorder . use_cassette ( <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> with pytest . raises ( NotFound ) : <NEWLINE> subreddit . traffic ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'announcements'", "'TestSubreddit.test_traffic__not_public'"]}, "err_obj": {"msg": "expected an indented block"}}], ["677b6a0f13f49440fbac31c613b668c3", {"code_string": "def RunChecks(self, responses):\n    if not responses.success:\n        raise RuntimeError(\"Checks did not run successfully.\")\n    for finding in checks.CheckHost(self.state.host_data,\n        os_type = self.state.knowledge_base.os):\n        self.state.checks_run.append(finding.check_id)\n        if finding.anomaly:\n        self.state.checks_with_findings.append(finding.check_id)\n        self.SendReply(finding)\n", "code_toks_joined": "def RunChecks ( self , responses ) : <NEWLINE> <INDENT> if not responses . success : <NEWLINE> <INDENT> raise RuntimeError ( <STRING> ) <NEWLINE> <DEDENT> for finding in checks . CheckHost ( self . state . host_data , <NEWLINE> <INDENT> os_type = self . state . knowledge_base . os ) : <NEWLINE> self . state . checks_run . append ( finding . check_id ) <NEWLINE> if finding . anomaly : <NEWLINE> self . state . checks_with_findings . append ( finding . check_id ) <NEWLINE> self . SendReply ( finding ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Checks did not run successfully.\""]}, "err_obj": {"msg": "expected an indented block"}}], ["a6b32f33385b151f893bc1575ad5a994", {"code_string": "def answer(intervals):\n    num_splits = len(intervals)\n    t = 0\n    while t < num_splits\n        t += 1\n        time_length = reduce_splits(intervals)\n        if time_length > 0:\n            return time_length\n        if num_splits != len(intervals)\n            num_splits = len(intervals)\n            t = 0\n    time_length = 0\n    for x in intervals:\n        time_length += x[1] - x[0]\n    return time_length\n", "code_toks_joined": "def answer ( intervals ) : <NEWLINE> <INDENT> num_splits = len ( intervals ) <NEWLINE> t = 0 <NEWLINE> while t < num_splits <NEWLINE> <INDENT> t += 1 <NEWLINE> time_length = reduce_splits ( intervals ) <NEWLINE> if time_length > 0 : <NEWLINE> <INDENT> return time_length <NEWLINE> <DEDENT> if num_splits != len ( intervals ) <NEWLINE> <INDENT> num_splits = len ( intervals ) <NEWLINE> t = 0 <NEWLINE> <DEDENT> <DEDENT> time_length = 0 <NEWLINE> for x in intervals : <NEWLINE> <INDENT> time_length += x [ 1 ] - x [ 0 ] <NEWLINE> <DEDENT> return time_length <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["b0b6ee9d9fd8aba60ce89852cbe245b0", {"code_string": "def courses(year):\n    response = session.post(pages['course'], params = {\n        'IN_ACYR': year,\n        'IN_ADLN_OIX': 'X'\n    })\n    document = BeautifulSoup(response.text)\n    for option in(document.find('select', {'name': 'IN_SUBCRSE'})\n        .find_all('option')):\n        if option['value']:\n        yield option['value']\n", "code_toks_joined": "def courses ( year ) : <NEWLINE> <INDENT> response = session . post ( pages [ <STRING> ] , params = { <NEWLINE> <INDENT> <STRING> : year , <NEWLINE> <STRING> : <STRING> <NEWLINE> <DEDENT> } ) <NEWLINE> document = BeautifulSoup ( response . text ) <NEWLINE> for option in ( document . find ( <STRING> , { <STRING> : <STRING> } ) <NEWLINE> <INDENT> . find_all ( <STRING> ) ) : <NEWLINE> if option [ <STRING> ] : <NEWLINE> yield option [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'course'", "'IN_ACYR'", "'IN_ADLN_OIX'", "'X'", "'select'", "'name'", "'IN_SUBCRSE'", "'option'", "'value'", "'value'"]}, "err_obj": {"msg": "expected an indented block"}}], ["6ba3b0353a8392f8ef84e9d69bb2de4b", {"code_string": "def shutdown(self):\n    self.motor_off()\n        if is_debug:\n        print(\"OFF\")\n    else:\n        subprocess.call(powerdown)\n", "code_toks_joined": "def shutdown ( self ) : <NEWLINE> <INDENT> self . motor_off ( ) <NEWLINE> <INDENT> if is_debug : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> subprocess . call ( powerdown ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"OFF\""]}, "err_obj": {"msg": "unexpected indent"}}], ["3446a378ac0e017a0e4016e2bfae65db", {"code_string": "def main():\n    \"\"\"Top level function that draws the final figure: could be one or\"\"\"\n    tair = import_data(\"anuclim_5km_mat.csv\", doSum = False)\n    rain = import_data(\"anuclim_5km_ppt.csv\", doSum = True)\n    tair[\"units\"] = \"degrees Celsius\"\n    rain[\"units\"] = \"mm/year\"\n    fig = plt.figure(figsize = (10, 9), frameon = False)\n    fig.add_axes([0, 0, 1.0, 1.0])\n    n_plots = 2\n    grid = gridspec.GridSpec(n_plots, 1)\n    subaxs = [plt.subplot(grid[i]) for i in range(n_plots)]\n    make_map(subaxs[0], tair, levels = np.arange(15, 32, 0.5), cticks = np.arange(15, 32, 2.5), cmap = get_cmap(MAPCOLOR), title = \"Australian Savanna \\\\\\\\ Mean Annual Temperature (1970-2000)\")\n    make_map(subaxs[1], rain, levels = np.logspace(2, 3.6, 100), cticks = [100, 500, 1000, 1500, 2000, 3000, 4000], cmap = get_cmap(MAPCOLOR), norm = SymLogNorm(linthresh = 0.3, linscale = 0.03),\n    plt.savefig(SAVEPATH)\n", "code_toks_joined": "def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> tair = import_data ( <STRING> , doSum = False ) <NEWLINE> rain = import_data ( <STRING> , doSum = True ) <NEWLINE> tair [ <STRING> ] = <STRING> <NEWLINE> rain [ <STRING> ] = <STRING> <NEWLINE> fig = plt . figure ( figsize = ( 10 , 9 ) , frameon = False ) <NEWLINE> fig . add_axes ( [ 0 , 0 , 1.0 , 1.0 ] ) <NEWLINE> n_plots = 2 <NEWLINE> grid = gridspec . GridSpec ( n_plots , 1 ) <NEWLINE> subaxs = [ plt . subplot ( grid [ i ] ) for i in range ( n_plots ) ] <NEWLINE> make_map ( subaxs [ 0 ] , tair , levels = np . arange ( 15 , 32 , 0.5 ) , cticks = np . arange ( 15 , 32 , 2.5 ) , cmap = get_cmap ( MAPCOLOR ) , title = <STRING> ) <NEWLINE> make_map ( subaxs [ 1 ] , rain , levels = np . logspace ( 2 , 3.6 , 100 ) , cticks = [ 100 , 500 , 1000 , 1500 , 2000 , 3000 , 4000 ] , cmap = get_cmap ( MAPCOLOR ) , norm = SymLogNorm ( linthresh = 0.3 , linscale = 0.03 ) , <NEWLINE> plt . savefig ( SAVEPATH ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Top level function that draws the final figure: could be one or\"\"\"", "\"anuclim_5km_mat.csv\"", "\"anuclim_5km_ppt.csv\"", "\"units\"", "\"degrees Celsius\"", "\"units\"", "\"mm/year\"", "\"Australian Savanna \\\\\\\\ Mean Annual Temperature (1970-2000)\""]}, "window_span": [163, 231], "err_obj": {"msg": "unbalanced (){}[]"}}], ["2bd41b617c159daa5232bf500f570b81", {"code_string": "def update(self):\n    \"\"\" Free's current list of services and repopulates it from the Commotion service manager.\"\"\"\n    if(self.__ptr and self.__len):\n    self.__del__()\n    self.__ptr = c_void_p()\n    self.__len = libCSM.csm_services_fetch(byref(self.__ptr), self.__config.ptr)\n", "code_toks_joined": "def update ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( self . __ptr and self . __len ) : <NEWLINE> self . __del__ ( ) <NEWLINE> self . __ptr = c_void_p ( ) <NEWLINE> self . __len = libCSM . csm_services_fetch ( byref ( self . __ptr ) , self . __config . ptr ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Free's current list of services and repopulates it from the Commotion service manager.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["1eb08f05cc624c8e8261f98c234410d3", {"code_string": "def r_aixssha1(mydata):\n    results = re.search(r'\\{ssha1\\}06\\$\\S{16}\\$\\S{27}', mydata, re.M | re.I)\n    if results:\n        if args.quietmode: print results.group()\n        else: outputhandler.write(str(results.group().rstrip('\\n')) + '\\r\\n')\n", "code_toks_joined": "def r_aixssha1 ( mydata ) : <NEWLINE> <INDENT> results = re . search ( <STRING> , mydata , re . M | re . I ) <NEWLINE> if results : <NEWLINE> <INDENT> if args . quietmode : print results . group ( ) <NEWLINE> else : outputhandler . write ( str ( results . group ( ) . rstrip ( <STRING> ) ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["r'\\{ssha1\\}06\\$\\S{16}\\$\\S{27}'", "'\\n'", "'\\r\\n'"]}, "err_obj": {"msg": "invalid syntax"}}], ["6bf9c043a16e44e789a1e4175ca19442", {"code_string": "def TestConnections():\n    \"\"\"Test connections, printing results\"\"\"\n    if len(Globals.connections) == 1: print \"No remote connections specified\"\n    else:\n        for i in range(1, len(Globals.connections)): test_connection(i)\n", "code_toks_joined": "def TestConnections ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if len ( Globals . connections ) == 1 : print <STRING> <NEWLINE> else : <NEWLINE> <INDENT> for i in range ( 1 , len ( Globals . connections ) ) : test_connection ( i ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Test connections, printing results\"\"\"", "\"No remote connections specified\""]}, "err_obj": {"msg": "invalid syntax"}}], ["2e80a79ea29c1002cbd258822a87fcb6", {"code_string": "\"\"\"A Python implementation of churiso and binary lambda calculus\"\"\"\nfrom run import *\nif __name__ == \"__main__\":\n    from docopt import docopt\n    arguments = docopt(__doc__, version = \"pychuriso 0.001\")\n    condition = 0\n    MAX_FIND = int(arguments['--max-find'])\n    output_data = []\n    for condition in range(0, 8):\n        print(\"CONDITION IS: \" + str(condition))\n        if condition == 3:\n            generalizations = [['f', 'a'], ['f', 'b'], ['f', 'c'], ['f', 'd']]\n        if(condition == 1) or(condition == 7) or(condition == 5):\n            generalizations = [['f', 'a'], ['f', 'b'], ['f', 'c']]\n        if(condition == 0) or(condition == 2) or(condition == 4) or(condition == 6):\n            generalizations = [['f', 'a'], ['f', 'b']]\n        basis = basis_from_argstring(str(arguments['--search-basis']))\n        symbolTable, variables, uniques, facts, shows = {}, [], [], [], []\n        load_source(arguments['--input'] % condition, symbolTable, uniques, facts, shows, basis)\n        seen = set()\n        for nsolution, solution in enumerate(search(symbolTable, facts, uniques, int(arguments['--max-depth']), basis)):\n            if nsolution > MAX_FIND: break\n            fs = frozenset(solution.items())\n            if fs in seen:\n                continue\n            else:\n                seen.add(fs)\n            l = sum(len(v) for v in solution.values())\n            rc = get_reduction_count(solution, facts)\n            for g in generalizations:\n                try:\n                    r = reduce_combinator(substitute(g, solution))\n                except ReductionException:\n                    r = 'NON-HALT'\n                equalset = set([k for k in solution.keys() if solution[k] == r])\n                equalset = equalset - set({'I', 'gs'})\n                if len(equalset) == 0:\n                    if(condition == 0) or(condition == 4) or(condition == 6) or(condition == 5):\n                        equalset = {'c'}\n                    if condition == 3:\n                        equalset = {'e'}\n                    if(condition == 1) or(condition == 2) or(condition == 7):\n                        equalset = {'d'}\n                print(condition, nsolution, solution, arguments['--search-basis'], ''.join(g), l, rc, \"'%s'\" % ''.join(sorted(equalset)))\n                output_data.append([condition, nsolution, arguments['--search-basis'], ''.join(g), l, rc, \"'%s'\" % ''.join(sorted(equalset))])\n    print(\"condition nsolution basis generalization length runtime answer\")\n    for line in output_data:\n        print(' '.join(map(str, line)))\n        print('a'), ' '.join(map(str, line)))\n", "code_toks_joined": "<STRING> <NEWLINE> from run import * <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> from docopt import docopt <NEWLINE> arguments = docopt ( __doc__ , version = <STRING> ) <NEWLINE> condition = 0 <NEWLINE> MAX_FIND = int ( arguments [ <STRING> ] ) <NEWLINE> output_data = [ ] <NEWLINE> for condition in range ( 0 , 8 ) : <NEWLINE> <INDENT> print ( <STRING> + str ( condition ) ) <NEWLINE> if condition == 3 : <NEWLINE> <INDENT> generalizations = [ [ <STRING> , <STRING> ] , [ <STRING> , <STRING> ] , [ <STRING> , <STRING> ] , [ <STRING> , <STRING> ] ] <NEWLINE> <DEDENT> if ( condition == 1 ) or ( condition == 7 ) or ( condition == 5 ) : <NEWLINE> <INDENT> generalizations = [ [ <STRING> , <STRING> ] , [ <STRING> , <STRING> ] , [ <STRING> , <STRING> ] ] <NEWLINE> <DEDENT> if ( condition == 0 ) or ( condition == 2 ) or ( condition == 4 ) or ( condition == 6 ) : <NEWLINE> <INDENT> generalizations = [ [ <STRING> , <STRING> ] , [ <STRING> , <STRING> ] ] <NEWLINE> <DEDENT> basis = basis_from_argstring ( str ( arguments [ <STRING> ] ) ) <NEWLINE> symbolTable , variables , uniques , facts , shows = { } , [ ] , [ ] , [ ] , [ ] <NEWLINE> load_source ( arguments [ <STRING> ] % condition , symbolTable , uniques , facts , shows , basis ) <NEWLINE> seen = set ( ) <NEWLINE> for nsolution , solution in enumerate ( search ( symbolTable , facts , uniques , int ( arguments [ <STRING> ] ) , basis ) ) : <NEWLINE> <INDENT> if nsolution > MAX_FIND : break <NEWLINE> fs = frozenset ( solution . items ( ) ) <NEWLINE> if fs in seen : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> seen . add ( fs ) <NEWLINE> <DEDENT> l = sum ( len ( v ) for v in solution . values ( ) ) <NEWLINE> rc = get_reduction_count ( solution , facts ) <NEWLINE> for g in generalizations : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> r = reduce_combinator ( substitute ( g , solution ) ) <NEWLINE> <DEDENT> except ReductionException : <NEWLINE> <INDENT> r = <STRING> <NEWLINE> <DEDENT> equalset = set ( [ k for k in solution . keys ( ) if solution [ k ] == r ] ) <NEWLINE> equalset = equalset - set ( { <STRING> , <STRING> } ) <NEWLINE> if len ( equalset ) == 0 : <NEWLINE> <INDENT> if ( condition == 0 ) or ( condition == 4 ) or ( condition == 6 ) or ( condition == 5 ) : <NEWLINE> <INDENT> equalset = { <STRING> } <NEWLINE> <DEDENT> if condition == 3 : <NEWLINE> <INDENT> equalset = { <STRING> } <NEWLINE> <DEDENT> if ( condition == 1 ) or ( condition == 2 ) or ( condition == 7 ) : <NEWLINE> <INDENT> equalset = { <STRING> } <NEWLINE> <DEDENT> <DEDENT> print ( condition , nsolution , solution , arguments [ <STRING> ] , <STRING> . join ( g ) , l , rc , <STRING> % <STRING> . join ( sorted ( equalset ) ) ) <NEWLINE> output_data . append ( [ condition , nsolution , arguments [ <STRING> ] , <STRING> . join ( g ) , l , rc , <STRING> % <STRING> . join ( sorted ( equalset ) ) ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for line in output_data : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , line ) ) ) <NEWLINE> print ( <STRING> ) , <STRING> . join ( map ( str , line ) ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"A Python implementation of churiso and binary lambda calculus\"\"\"", "\"__main__\"", "\"pychuriso 0.001\"", "'--max-find'", "\"CONDITION IS: \"", "'f'", "'a'", "'f'", "'b'", "'f'", "'c'", "'f'", "'d'", "'f'", "'a'", "'f'", "'b'", "'f'", "'c'", "'f'", "'a'", "'f'", "'b'", "'--search-basis'", "'--input'", "'--max-depth'", "'NON-HALT'", "'I'", "'gs'", "'c'", "'e'", "'d'", "'--search-basis'", "''", "\"'%s'\"", "''", "'--search-basis'", "''", "\"'%s'\"", "''", "\"condition nsolution basis generalization length runtime answer\"", "' '", "'a'", "' '"]}, "window_span": [619, 637], "err_obj": {"msg": "unbalanced (){}[]"}}], ["9cd8cf863803c1731d335b272ca34c9c", {"code_string": "def setupUi(self, Dialog):\n    Dialog.setObjectName(\"Dialog\")\n    Dialog.resize(268, 323)\n    icon = QtGui.QIcon()\n    icon.addPixmap(QtGui.QPixmap(\":/images/icon.png\"), QtGui.QIcon.Normal, QtGui.QIcon.Off)\n    Dialog.setWindowIcon(icon)\n    self.verticalLayout = QtGui.QVBoxLayout(Dialog)\n    self.verticalLayout.setObjectName(\"verticalLayout\")\n    self.horizontalLayout = QtGui.QHBoxLayout()\n    self.horizontalLayout.setObjectName(\"horizontalLayout\")\n    spacerItem = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)\n    self.horizontalLayout.addItem(spacerItem)\n    self.nameLabel = QtGui.QLabel(Dialog)\n    self.nameLabel.setText(\"AppName\")\n    self.nameLabel.setObjectName(\"nameLabel\")\n    self.horizontalLayout.addWidget(self.nameLabel)\n    self.versionlabel = QtGui.QLabel(Dialog)\n    self.versionlabel.setText(\"Appversion\")\n    self.versionlabel.setObjectName(\"versionlabel\")\n    self.horizontalLayout.addWidget(self.versionlabel)\n    spacerItem1 = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)\n    self.horizontalLayout.addItem(spacerItem1)\n    self.verticalLayout.addLayout(self.horizontalLayout)\n    self.label = QtGui.QLabel(Dialog)\n    self.label.setEnabled(True)\n    self.label.setText(\"\")\n    self.label.setPixmap(QtGui.QPixmap(\":/images/icon.png\"))\n    self.label.setScaledContents(False)\n    self.label.setAlignment(QtCore.Qt.AlignCenter)\n    self.label.setWordWrap(True)\n    self.label.setObjectName(\"label\")\n    self.verticalLayout.addWidget(self.label)\n    spacerItem2 = QtGui.QSpacerItem(20, 40, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Expanding)\n    self.verticalLayout.addItem(spacerItem2)\n    self.label_2 = QtGui.QLabel(Dialog)\n    self.label_2.setText(\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def setupUi ( self , Dialog ) : <NEWLINE> <INDENT> Dialog . setObjectName ( <STRING> ) <NEWLINE> Dialog . resize ( 268 , 323 ) <NEWLINE> icon = QtGui . QIcon ( ) <NEWLINE> icon . addPixmap ( QtGui . QPixmap ( <STRING> ) , QtGui . QIcon . Normal , QtGui . QIcon . Off ) <NEWLINE> Dialog . setWindowIcon ( icon ) <NEWLINE> self . verticalLayout = QtGui . QVBoxLayout ( Dialog ) <NEWLINE> self . verticalLayout . setObjectName ( <STRING> ) <NEWLINE> self . horizontalLayout = QtGui . QHBoxLayout ( ) <NEWLINE> self . horizontalLayout . setObjectName ( <STRING> ) <NEWLINE> spacerItem = QtGui . QSpacerItem ( 40 , 20 , QtGui . QSizePolicy . Expanding , QtGui . QSizePolicy . Minimum ) <NEWLINE> self . horizontalLayout . addItem ( spacerItem ) <NEWLINE> self . nameLabel = QtGui . QLabel ( Dialog ) <NEWLINE> self . nameLabel . setText ( <STRING> ) <NEWLINE> self . nameLabel . setObjectName ( <STRING> ) <NEWLINE> self . horizontalLayout . addWidget ( self . nameLabel ) <NEWLINE> self . versionlabel = QtGui . QLabel ( Dialog ) <NEWLINE> self . versionlabel . setText ( <STRING> ) <NEWLINE> self . versionlabel . setObjectName ( <STRING> ) <NEWLINE> self . horizontalLayout . addWidget ( self . versionlabel ) <NEWLINE> spacerItem1 = QtGui . QSpacerItem ( 40 , 20 , QtGui . QSizePolicy . Expanding , QtGui . QSizePolicy . Minimum ) <NEWLINE> self . horizontalLayout . addItem ( spacerItem1 ) <NEWLINE> self . verticalLayout . addLayout ( self . horizontalLayout ) <NEWLINE> self . label = QtGui . QLabel ( Dialog ) <NEWLINE> self . label . setEnabled ( True ) <NEWLINE> self . label . setText ( <STRING> ) <NEWLINE> self . label . setPixmap ( QtGui . QPixmap ( <STRING> ) ) <NEWLINE> self . label . setScaledContents ( False ) <NEWLINE> self . label . setAlignment ( QtCore . Qt . AlignCenter ) <NEWLINE> self . label . setWordWrap ( True ) <NEWLINE> self . label . setObjectName ( <STRING> ) <NEWLINE> self . verticalLayout . addWidget ( self . label ) <NEWLINE> spacerItem2 = QtGui . QSpacerItem ( 20 , 40 , QtGui . QSizePolicy . Minimum , QtGui . QSizePolicy . Expanding ) <NEWLINE> self . verticalLayout . addItem ( spacerItem2 ) <NEWLINE> self . label_2 = QtGui . QLabel ( Dialog ) <NEWLINE> self . label_2 . setText ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Dialog\"", "\":/images/icon.png\"", "\"verticalLayout\"", "\"horizontalLayout\"", "\"AppName\"", "\"nameLabel\"", "\"Appversion\"", "\"versionlabel\"", "\"\"", "\":/images/icon.png\"", "\"label\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "window_span": [401, 405], "err_obj": {"msg": "unbalanced (){}[]"}}], ["ef71c0873a1eabef6d6fdadd74a42617", {"code_string": "def test_delete_router_interface_fail_contract_create(self):\n    mgr = self.plugin.manager\n    with mock.patch('neutron.db.l3_gwmode_db.L3_NAT_db_mixin.'\n        'remove_router_interface',\n        side_effect = KeyError()):\n        self.plugin.remove_router_interface(self.context, ROUTER,\n            self.interface_info)\n            mgr.set_contract_for_epg.assert_called_once()\n", "code_toks_joined": "def test_delete_router_interface_fail_contract_create ( self ) : <NEWLINE> <INDENT> mgr = self . plugin . manager <NEWLINE> with mock . patch ( <STRING> <NEWLINE> <INDENT> <STRING> , <NEWLINE> side_effect = KeyError ( ) ) : <NEWLINE> self . plugin . remove_router_interface ( self . context , ROUTER , <NEWLINE> <INDENT> self . interface_info ) <NEWLINE> mgr . set_contract_for_epg . assert_called_once ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'neutron.db.l3_gwmode_db.L3_NAT_db_mixin.'", "'remove_router_interface'"]}, "err_obj": {"msg": "unexpected indent"}}], ["0400a324489afe855edebefbdf5defe3", {"code_string": "import alsaaudio, time, audioop\ninp = alsaaudio.PCM(alsaaudio.PCM_CAPTURE, alsaaudio.PCM_NONBLOCK)\ninp.setchannels(1)\ninp.setrate(8000)\ninp.setformat(alsaaudio.PCM_FORMAT_S16_LE)\ninp.setperiodsize(160)\nwhile True:\n    l, data = inp.read()\n    if l:\n        au = audioop.max(data, 2)\n        if au >= 32676:\n        print(au)\n    time.sleep(.001)\n", "code_toks_joined": "import alsaaudio , time , audioop <NEWLINE> inp = alsaaudio . PCM ( alsaaudio . PCM_CAPTURE , alsaaudio . PCM_NONBLOCK ) <NEWLINE> inp . setchannels ( 1 ) <NEWLINE> inp . setrate ( 8000 ) <NEWLINE> inp . setformat ( alsaaudio . PCM_FORMAT_S16_LE ) <NEWLINE> inp . setperiodsize ( 160 ) <NEWLINE> while True : <NEWLINE> <INDENT> l , data = inp . read ( ) <NEWLINE> if l : <NEWLINE> <INDENT> au = audioop . max ( data , 2 ) <NEWLINE> if au >= 32676 : <NEWLINE> print ( au ) <NEWLINE> <DEDENT> time . sleep ( .001 ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["1cc59ea4745543ef5e67f69827fcf646", {"code_string": "def fsoAttributesByKey(self, stype, node):\n    try:\n        val = node.fsoAttributes()[stype]\n        if isinstance(val.value(), vtime):\n        return val.value().get_time()\n        return val\n    except IndexError:\n        return Variant()\n", "code_toks_joined": "def fsoAttributesByKey ( self , stype , node ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> val = node . fsoAttributes ( ) [ stype ] <NEWLINE> if isinstance ( val . value ( ) , vtime ) : <NEWLINE> return val . value ( ) . get_time ( ) <NEWLINE> return val <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> return Variant ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["829374669851c7f48b1eda7d56a6987b", {"code_string": "def make_zip(name, base_dir, skip = []):\n    skip.append(name)\n    with zipfile.ZipFile(os.path.join(base_dir, name),\n        'w', zipfile.ZIP_DEFLATED, allowZip64 = True) as zf:\n        for f in[f for f in os.listdir(base_dir) if f not in skip]:\n        zf.write(os.path.join(base_dir, f))\n", "code_toks_joined": "def make_zip ( name , base_dir , skip = [ ] ) : <NEWLINE> <INDENT> skip . append ( name ) <NEWLINE> with zipfile . ZipFile ( os . path . join ( base_dir , name ) , <NEWLINE> <INDENT> <STRING> , zipfile . ZIP_DEFLATED , allowZip64 = True ) as zf : <NEWLINE> for f in [ f for f in os . listdir ( base_dir ) if f not in skip ] : <NEWLINE> zf . write ( os . path . join ( base_dir , f ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'w'"]}, "err_obj": {"msg": "expected an indented block"}}], ["e4df9f2173b8462a72c917fb68d5a99e", {"code_string": "def test_reset_source(self):\n    '''reset source using send - pass'''\n    with(repack\n        .integer()\n        .iterator(\n            iter(['1', '2', '3']))) as iterator:\n            iterator.send(iter(['11', '22', '33']))\n            r = []\n            for v in iterator:\n        r.append(v)\n    self.assertSequenceEqual([11, 22, 33], r)\n", "code_toks_joined": "def test_reset_source ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with ( repack <NEWLINE> <INDENT> . integer ( ) <NEWLINE> . iterator ( <NEWLINE> <INDENT> iter ( [ <STRING> , <STRING> , <STRING> ] ) ) ) as iterator : <NEWLINE> iterator . send ( iter ( [ <STRING> , <STRING> , <STRING> ] ) ) <NEWLINE> r = [ ] <NEWLINE> for v in iterator : <NEWLINE> <DEDENT> r . append ( v ) <NEWLINE> <DEDENT> self . assertSequenceEqual ( [ 11 , 22 , 33 ] , r ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''reset source using send - pass'''", "'1'", "'2'", "'3'", "'11'", "'22'", "'33'"]}, "err_obj": {"msg": "unindent does not match any outer indentation level"}}], ["92cf56ae8973f850ff9c6334e6015000", {"code_string": "def testBootTimeEmpty(self):\n    with MonkeyPatchScope([(hoststats, '_PROC_STAT_PATH',\n        '/dev/null')]):\n        with self.assertRaises(ValueError):\n        hoststats.get_boot_time()\n", "code_toks_joined": "def testBootTimeEmpty ( self ) : <NEWLINE> <INDENT> with MonkeyPatchScope ( [ ( hoststats , <STRING> , <NEWLINE> <INDENT> <STRING> ) ] ) : <NEWLINE> with self . assertRaises ( ValueError ) : <NEWLINE> hoststats . get_boot_time ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'_PROC_STAT_PATH'", "'/dev/null'"]}, "err_obj": {"msg": "expected an indented block"}}], ["9a8abcc24ce3d2d87b19ef379d04eb3d", {"code_string": "def main():\n    config_file = os.path.join(sys.path[0], '../conf/odinsys.conf')\n    config.read(config_file)\n    factory = protocol.ServerFactory()\n    factory.protocol = OdinSysInfoProtocol\n    factory.clients = []\n    port = int(config.get(\"global\", \"bind_port\")\n    reactor.listenTCP(port, factory)\n    logger.debug(\"ODINSYS: Server started and listen on the port: %i\" %(port))\n    reactor.run()\n", "code_toks_joined": "def main ( ) : <NEWLINE> <INDENT> config_file = os . path . join ( sys . path [ 0 ] , <STRING> ) <NEWLINE> config . read ( config_file ) <NEWLINE> factory = protocol . ServerFactory ( ) <NEWLINE> factory . protocol = OdinSysInfoProtocol <NEWLINE> factory . clients = [ ] <NEWLINE> port = int ( config . get ( <STRING> , <STRING> ) <NEWLINE> reactor . listenTCP ( port , factory ) <NEWLINE> logger . debug ( <STRING> % ( port ) ) <NEWLINE> reactor . run ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'../conf/odinsys.conf'", "\"global\"", "\"bind_port\"", "\"ODINSYS: Server started and listen on the port: %i\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["647f9b55033fe2b0fc7e83b446921453", {"code_string": "def putVarInt64(self, value):\n    if value >= 0x8000000000000000 or value < - 0x8000000000000000:\n        raise ProtocolBuffer.ProtocolBufferEncodeError, 'int64 too big'\n    self._PutVarInt(value)\n", "code_toks_joined": "def putVarInt64 ( self , value ) : <NEWLINE> <INDENT> if value >= 0x8000000000000000 or value < - 0x8000000000000000 : <NEWLINE> <INDENT> raise ProtocolBuffer . ProtocolBufferEncodeError , <STRING> <NEWLINE> <DEDENT> self . _PutVarInt ( value ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'int64 too big'"]}, "err_obj": {"msg": "invalid syntax"}}], ["e48ba8c0bd59128b4537714e3223075f", {"code_string": "def serialize_data(self):\n    ret = dict(token = self.token,\n        sandbox = self.sandbox)\n    for attr in['alert', 'badge', 'extra', 'sound',\n        'identifier', 'expiry']:\n        val = getattr(self, attr)\n        if val is not None:\n        ret[attr] = val\n    return ret\n", "code_toks_joined": "def serialize_data ( self ) : <NEWLINE> <INDENT> ret = dict ( token = self . token , <NEWLINE> <INDENT> sandbox = self . sandbox ) <NEWLINE> <DEDENT> for attr in [ <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> ] : <NEWLINE> val = getattr ( self , attr ) <NEWLINE> if val is not None : <NEWLINE> ret [ attr ] = val <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'alert'", "'badge'", "'extra'", "'sound'", "'identifier'", "'expiry'"]}, "err_obj": {"msg": "expected an indented block"}}], ["94968259baa483c719c00b91798a432a", {"code_string": "def test_ascii(mesh):\n    helpers.write_read('test.vtu', 'vtu-ascii' mesh, 1.0e-11)\n    return\n", "code_toks_joined": "def test_ascii ( mesh ) : <NEWLINE> <INDENT> helpers . write_read ( <STRING> , <STRING> mesh , 1.0e-11 ) <NEWLINE> return <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'test.vtu'", "'vtu-ascii'"]}, "err_obj": {"msg": "invalid syntax"}}], ["a3986e7e60726de3e9c5c858f1bd3751", {"code_string": "class Clock(object):\n    def __init__(self, time):\n    self.time = time\n    def print_time(self):\n    print(self.time)\n", "code_toks_joined": "class Clock ( object ) : <NEWLINE> <INDENT> def __init__ ( self , time ) : <NEWLINE> self . time = time <NEWLINE> def print_time ( self ) : <NEWLINE> print ( self . time ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["eb3f0d5011b8214e38ae2ef6112f10f8", {"code_string": "def drawpaths(self, f, paths):\n    for path in paths:\n        if not path['opacity']:\n            self.drawPolyline(f, path['path'], strokeColor = path['strokeColor'])\n            else:\n            self.drawPolygon(f, path['path'], strokeColor = path['strokeColor'], fillColor = path['fillColor'], fillOpacity = path['opacity'])\n", "code_toks_joined": "def drawpaths ( self , f , paths ) : <NEWLINE> <INDENT> for path in paths : <NEWLINE> <INDENT> if not path [ <STRING> ] : <NEWLINE> <INDENT> self . drawPolyline ( f , path [ <STRING> ] , strokeColor = path [ <STRING> ] ) <NEWLINE> else : <NEWLINE> self . drawPolygon ( f , path [ <STRING> ] , strokeColor = path [ <STRING> ] , fillColor = path [ <STRING> ] , fillOpacity = path [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'opacity'", "'path'", "'strokeColor'", "'path'", "'strokeColor'", "'fillColor'", "'opacity'"]}, "err_obj": {"msg": "invalid syntax"}}], ["1bcb9c65930a4533840e546ff8fe3ebb", {"code_string": "def get_metodos(object, showValor = False):\n    metodos = [metodo for metodo in dir(object) if hasattr(getattr(object, metodo), '__call__')]\n    for metodo in metodos:\n        if showValor:\n            print '%s: %s' %(metodo, str(object[metodo]))\n        else: print metodo\n", "code_toks_joined": "def get_metodos ( object , showValor = False ) : <NEWLINE> <INDENT> metodos = [ metodo for metodo in dir ( object ) if hasattr ( getattr ( object , metodo ) , <STRING> ) ] <NEWLINE> for metodo in metodos : <NEWLINE> <INDENT> if showValor : <NEWLINE> <INDENT> print <STRING> % ( metodo , str ( object [ metodo ] ) ) <NEWLINE> <DEDENT> else : print metodo <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'__call__'", "'%s: %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["ce9f6df3b8b4c97ad6383039876f60d2", {"code_string": "def gdal_config_options(self, cmd = ''):\n    extra_args = []\n    if 'GDAL_CACHEMAX' not in cmd:\n        value = gdal.GetCacheMax()\n        extra_args.extend(('--config', 'GDAL_CACHEMAX', str(value)))\n    for key in('CPL_DEBUG', 'GDAL_SKIP', 'GDAL_DATA',\n        'GDAL_DRIVER_PATH', 'OGR_DRIVER_PATH'):\n        if key not in cmd:\n        value = gdal.GetConfigOption(key, None)\n        if value:\n        extra_args.extend(('--config', key, '\"%s\"' % value))\n    return extra_args\n", "code_toks_joined": "def gdal_config_options ( self , cmd = <STRING> ) : <NEWLINE> <INDENT> extra_args = [ ] <NEWLINE> if <STRING> not in cmd : <NEWLINE> <INDENT> value = gdal . GetCacheMax ( ) <NEWLINE> extra_args . extend ( ( <STRING> , <STRING> , str ( value ) ) ) <NEWLINE> <DEDENT> for key in ( <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> ) : <NEWLINE> if key not in cmd : <NEWLINE> value = gdal . GetConfigOption ( key , None ) <NEWLINE> if value : <NEWLINE> extra_args . extend ( ( <STRING> , key , <STRING> % value ) ) <NEWLINE> <DEDENT> return extra_args <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "'GDAL_CACHEMAX'", "'--config'", "'GDAL_CACHEMAX'", "'CPL_DEBUG'", "'GDAL_SKIP'", "'GDAL_DATA'", "'GDAL_DRIVER_PATH'", "'OGR_DRIVER_PATH'", "'--config'", "'\"%s\"'"]}, "err_obj": {"msg": "expected an indented block"}}], ["01ab083ebe390827dee31cc0cbf7c374", {"code_string": "def finance_logs():\n    info = current_user.finance_information\n    if not info or not info.has_to_pay:\n        abort(404)\n    return render_template('usersuite/finance_logs.html'\n        last_update = info.last_update,\n        balance = info.balance.raw_value,\n        logs = info.history)\n", "code_toks_joined": "def finance_logs ( ) : <NEWLINE> <INDENT> info = current_user . finance_information <NEWLINE> if not info or not info . has_to_pay : <NEWLINE> <INDENT> abort ( 404 ) <NEWLINE> <DEDENT> return render_template ( <STRING> <NEWLINE> <INDENT> last_update = info . last_update , <NEWLINE> balance = info . balance . raw_value , <NEWLINE> logs = info . history ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'usersuite/finance_logs.html'"]}, "err_obj": {"msg": "invalid syntax"}}], ["d2147fb1de2cee47a6d6df16379e0f6c", {"code_string": "def maybe_inject_trace_event(self):\n    if(self.simulation.dataplane_trace and\n        (self.logical_time % self.traffic_inject_interval) == 0):\n        (dp_event, host) = self.simulation.dataplane_trace.peek()\n        if dp_event is not None:\n        self._log_input_event(TrafficInjection(dp_event = dp_event,\n            host_id = host.hid))\n        self.simulation.dataplane_trace.inject_trace_event()\n", "code_toks_joined": "def maybe_inject_trace_event ( self ) : <NEWLINE> <INDENT> if ( self . simulation . dataplane_trace and <NEWLINE> <INDENT> ( self . logical_time % self . traffic_inject_interval ) == 0 ) : <NEWLINE> ( dp_event , host ) = self . simulation . dataplane_trace . peek ( ) <NEWLINE> if dp_event is not None : <NEWLINE> self . _log_input_event ( TrafficInjection ( dp_event = dp_event , <NEWLINE> <INDENT> host_id = host . hid ) ) <NEWLINE> <DEDENT> self . simulation . dataplane_trace . inject_trace_event ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["9ff897535e8041f36977ae87cce0819a", {"code_string": "def get_bridge_for_iface(root_helper, iface):\n    args = [\"ovs-vsctl\", \"--timeout=2\", \"iface-to-br\", iface]\n    try:\n        return utils.execute(args, root_helper = root_helper).strip()\n    except Exception, e:\n        LOG.error(_(\"iface %s not found. Exception: %s\"), iface, e)\n        return None\n", "code_toks_joined": "def get_bridge_for_iface ( root_helper , iface ) : <NEWLINE> <INDENT> args = [ <STRING> , <STRING> , <STRING> , iface ] <NEWLINE> try : <NEWLINE> <INDENT> return utils . execute ( args , root_helper = root_helper ) . strip ( ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> LOG . error ( _ ( <STRING> ) , iface , e ) <NEWLINE> return None <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"ovs-vsctl\"", "\"--timeout=2\"", "\"iface-to-br\"", "\"iface %s not found. Exception: %s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["6b2f9b9542c7631d1d95edae209ac921", {"code_string": "def test_builtin(self):\n    for name in('str', 'str.translate', 'builtins.str',\n        'builtins.str.translate'):\n        self.assertIsNotNone(pydoc.locate(name))\n        try:\n        pydoc.render_doc(name)\n        except ImportError:\n        self.fail('finding the doc of {!r} failed'.format(o))\n    for name in('notbuiltins', 'strrr', 'strr.translate',\n        'str.trrrranslate', 'builtins.strrr',\n        'builtins.str.trrranslate'):\n        self.assertIsNone(pydoc.locate(name))\n        self.assertRaises(ImportError, pydoc.render_doc, name)\n", "code_toks_joined": "def test_builtin ( self ) : <NEWLINE> <INDENT> for name in ( <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> self . assertIsNotNone ( pydoc . locate ( name ) ) <NEWLINE> try : <NEWLINE> pydoc . render_doc ( name ) <NEWLINE> except ImportError : <NEWLINE> self . fail ( <STRING> . format ( o ) ) <NEWLINE> <DEDENT> for name in ( <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> <STRING> ) : <NEWLINE> self . assertIsNone ( pydoc . locate ( name ) ) <NEWLINE> self . assertRaises ( ImportError , pydoc . render_doc , name ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'str'", "'str.translate'", "'builtins.str'", "'builtins.str.translate'", "'finding the doc of {!r} failed'", "'notbuiltins'", "'strrr'", "'strr.translate'", "'str.trrrranslate'", "'builtins.strrr'", "'builtins.str.trrranslate'"]}, "err_obj": {"msg": "expected an indented block"}}], ["9c933758ddd2151e08cf1c30bd7d825b", {"code_string": "class global_config:\n    projects = [\n        ['APR', 'apr/apr/'],\n        ['APR-Util', 'apr/apr-util/'],\n        ['httpd', 'httpd/httpd/']\n        ]\n    repositoryURI = \"http://svn.apache.org/repos/asf/\"\n    server = syntax error\n    debug = 0\n", "code_toks_joined": "class global_config : <NEWLINE> <INDENT> projects = [ <NEWLINE> <INDENT> [ <STRING> , <STRING> ] , <NEWLINE> [ <STRING> , <STRING> ] , <NEWLINE> [ <STRING> , <STRING> ] <NEWLINE> ] <NEWLINE> <DEDENT> repositoryURI = <STRING> <NEWLINE> server = syntax error <NEWLINE> debug = 0 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'APR'", "'apr/apr/'", "'APR-Util'", "'apr/apr-util/'", "'httpd'", "'httpd/httpd/'", "\"http://svn.apache.org/repos/asf/\""]}, "err_obj": {"msg": "invalid syntax"}}], ["12fc1db695d1dc890912df8db7f292ac", {"code_string": "def _log_multivariate_normal_density_tied(X, means covars):\n    \"\"\"Compute Gaussian log-density at X for a tied model.\"\"\"\n    cv = np.tile(covars, (means.shape[0], 1, 1))\n    return _log_multivariate_normal_density_full(X, means, cv)\n", "code_toks_joined": "def _log_multivariate_normal_density_tied ( X , means covars ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> cv = np . tile ( covars , ( means . shape [ 0 ] , 1 , 1 ) ) <NEWLINE> return _log_multivariate_normal_density_full ( X , means , cv ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Compute Gaussian log-density at X for a tied model.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["5914d46b5f00b18e23daed6aebe8150a", {"code_string": "def deploy_cli(argv, config = None):\n    \"\"\"Deploy initial Hatrac DB content and ACLs.\"\"\"\n    if config is not None:\n        deploy_dir = instantiate(config)\n    else:\n        deploy_dir = directory\n    if len(argv) > 1:\n        root_roles = argv[1: ]\n        deploy_dir.deploy_db(root_roles)\n        deploy_dir.schema_upgrade()\n        return 0\n    else:\n        sys.stderr.write(\"\"\"Usage: %(cmd)s role...\"\"\" % dict(\n    cmd = argv[0]\n", "code_toks_joined": "def deploy_cli ( argv , config = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if config is not None : <NEWLINE> <INDENT> deploy_dir = instantiate ( config ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> deploy_dir = directory <NEWLINE> <DEDENT> if len ( argv ) > 1 : <NEWLINE> <INDENT> root_roles = argv [ 1 : ] <NEWLINE> deploy_dir . deploy_db ( root_roles ) <NEWLINE> deploy_dir . schema_upgrade ( ) <NEWLINE> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stderr . write ( <STRING> % dict ( <NEWLINE> <DEDENT> cmd = argv [ 0 ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Deploy initial Hatrac DB content and ACLs.\"\"\"", "\"\"\"Usage: %(cmd)s role...\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["900a64cf9c3f00132adc2822ec44ee2b", {"code_string": "def compile(advanced = \"False\", pretty = \"True\", standalone = \"False\"):\n    files = srcfiles_embedded\n    if standalone == \"True\":\n    files = files + srcfiles_standalone\n    command = \"java -jar ../compiler-latest/compiler.jar \"\n    command = command + \"--language_in=ECMASCRIPT5_STRICT \"\n    for theFile in files:\n        command = command + \"--js=\" + theFile + \" \"\n    if advanced == \"True\":\n        command = (command +\n            \"--compilation_level ADVANCED_OPTIMIZATIONS \")\n            if pretty == \"True\":\n        command = command + \"--formatting=pretty_print \"\n    command = command + \"--js_output_file=js/finvis.js\"\n    local(command)\n", "code_toks_joined": "def compile ( advanced = <STRING> , pretty = <STRING> , standalone = <STRING> ) : <NEWLINE> <INDENT> files = srcfiles_embedded <NEWLINE> if standalone == <STRING> : <NEWLINE> files = files + srcfiles_standalone <NEWLINE> command = <STRING> <NEWLINE> command = command + <STRING> <NEWLINE> for theFile in files : <NEWLINE> <INDENT> command = command + <STRING> + theFile + <STRING> <NEWLINE> <DEDENT> if advanced == <STRING> : <NEWLINE> <INDENT> command = ( command + <NEWLINE> <INDENT> <STRING> ) <NEWLINE> if pretty == <STRING> : <NEWLINE> <DEDENT> command = command + <STRING> <NEWLINE> <DEDENT> command = command + <STRING> <NEWLINE> local ( command ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"False\"", "\"True\"", "\"False\"", "\"True\"", "\"java -jar ../compiler-latest/compiler.jar \"", "\"--language_in=ECMASCRIPT5_STRICT \"", "\"--js=\"", "\" \"", "\"True\"", "\"--compilation_level ADVANCED_OPTIMIZATIONS \"", "\"True\"", "\"--formatting=pretty_print \"", "\"--js_output_file=js/finvis.js\""]}, "err_obj": {"msg": "expected an indented block"}}], ["68841388f9eb5562817b39ecfdd1b1ce", {"code_string": "def visitedWebsite(pkt):\n    try:\n        if pkt.haslayer(Raw):\n            payloadWeb = pkt.getlayer(Raw).load\n                if payloadWeb.startswith(\"GET\") and 'Referer:' in payloadWeb:\n                    print(\"La victime \" + arg_parser().victimIP + \" a ete sur \" + payloadWeb.split('Referer: ')[1].split('\\n', 1)[0])\n    except:\n        print('error visited')\n", "code_toks_joined": "def visitedWebsite ( pkt ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if pkt . haslayer ( Raw ) : <NEWLINE> <INDENT> payloadWeb = pkt . getlayer ( Raw ) . load <NEWLINE> <INDENT> if payloadWeb . startswith ( <STRING> ) and <STRING> in payloadWeb : <NEWLINE> <INDENT> print ( <STRING> + arg_parser ( ) . victimIP + <STRING> + payloadWeb . split ( <STRING> ) [ 1 ] . split ( <STRING> , 1 ) [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"GET\"", "'Referer:'", "\"La victime \"", "\" a ete sur \"", "'Referer: '", "'\\n'", "'error visited'"]}, "err_obj": {"msg": "unexpected indent"}}], ["23d7e681fe98139c101c2daab72979dd", {"code_string": "def test_setup_fails_if_no_connect_broker(hass):\n    \"\"\"Test for setup failure if connection to broker is missing.\"\"\"\n    test_broker_cfg = {mqtt.DOMAIN: {mqtt.CONF_BROKER: 'test-broker'}}\n    with mock.patch('homeassistant.components.mqtt.MQTT',\n        side_effect = socket.error()):\n        result = yield from async_setup_component(hass, mqtt.DOMAIN,\n            test_broker_cfg)\n            assert not result\n    with mock.patch('paho.mqtt.client.Client') as mock_client:\n        mock_client().connect = lambda * args: 1\n        result = yield from async_setup_component(hass, mqtt.DOMAIN,\n            test_broker_cfg)\n        assert not result\n", "code_toks_joined": "def test_setup_fails_if_no_connect_broker ( hass ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> test_broker_cfg = { mqtt . DOMAIN : { mqtt . CONF_BROKER : <STRING> } } <NEWLINE> with mock . patch ( <STRING> , <NEWLINE> <INDENT> side_effect = socket . error ( ) ) : <NEWLINE> result = yield from async_setup_component ( hass , mqtt . DOMAIN , <NEWLINE> <INDENT> test_broker_cfg ) <NEWLINE> assert not result <NEWLINE> <DEDENT> <DEDENT> with mock . patch ( <STRING> ) as mock_client : <NEWLINE> <INDENT> mock_client ( ) . connect = lambda * args : 1 <NEWLINE> result = yield from async_setup_component ( hass , mqtt . DOMAIN , <NEWLINE> <INDENT> test_broker_cfg ) <NEWLINE> <DEDENT> assert not result <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Test for setup failure if connection to broker is missing.\"\"\"", "'test-broker'", "'homeassistant.components.mqtt.MQTT'", "'paho.mqtt.client.Client'"]}, "err_obj": {"msg": "unexpected indent"}}], ["c15645a18d43329373aec3d2729e1a67", {"code_string": "def mouse_on_img_rect(img, (cx, cy)):\n    w2 = img.get_width() / 2\n    h2 = img.get_height() / 2\n    x1 = cx - w2\n    y1 = cy - h2\n    x2 = cx + w2\n    y2 = cy + h2\n    return mouse_in(x1, y1, x2, y2)\n", "code_toks_joined": "def mouse_on_img_rect ( img , ( cx , cy ) ) : <NEWLINE> <INDENT> w2 = img . get_width ( ) / 2 <NEWLINE> h2 = img . get_height ( ) / 2 <NEWLINE> x1 = cx - w2 <NEWLINE> y1 = cy - h2 <NEWLINE> x2 = cx + w2 <NEWLINE> y2 = cy + h2 <NEWLINE> return mouse_in ( x1 , y1 , x2 , y2 ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["63f68d07ca3ac1aae339cf73d8bd3774", {"code_string": "def getAnswerList(self, key):\n    \"\"\"Retrieves a list representing the answer associated with a given answer key, if it exists or None if it doesn't.\"\"\"\n        return self.db[\"answerlist\"].find({\"key\": key}) if key is not None else self.db[\"answerlist\"].find()\n", "code_toks_joined": "def getAnswerList ( self , key ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> return self . db [ <STRING> ] . find ( { <STRING> : key } ) if key is not None else self . db [ <STRING> ] . find ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Retrieves a list representing the answer associated with a given answer key, if it exists or None if it doesn't.\"\"\"", "\"answerlist\"", "\"key\"", "\"answerlist\""]}, "err_obj": {"msg": "unexpected indent"}}], ["609bce08638882eb9a7c918c22239020", {"code_string": "def TranslateHealthCheck(self):\n    \"\"\"Translates <health-check> in appengine-web.xml to yaml.\"\"\"\n    health_check = self.app_engine_web_xml.health_check\n    if not health_check:\n        return[]\n    statements = ['health_check:']\n    for attr in('enable_health_check', 'check_interval_sec', 'timeout_sec',\n        'unhealthy_threshold', 'healthy_threshold',\n        'restart_threshold', 'host'):\n        value = getattr(health_check, attr, None)\n        if value is not None:\n        statements.append('  %s: %s' %(attr, value))\n    return statements\n", "code_toks_joined": "def TranslateHealthCheck ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> health_check = self . app_engine_web_xml . health_check <NEWLINE> if not health_check : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> statements = [ <STRING> ] <NEWLINE> for attr in ( <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> ) : <NEWLINE> value = getattr ( health_check , attr , None ) <NEWLINE> if value is not None : <NEWLINE> statements . append ( <STRING> % ( attr , value ) ) <NEWLINE> <DEDENT> return statements <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Translates <health-check> in appengine-web.xml to yaml.\"\"\"", "'health_check:'", "'enable_health_check'", "'check_interval_sec'", "'timeout_sec'", "'unhealthy_threshold'", "'healthy_threshold'", "'restart_threshold'", "'host'", "'  %s: %s'"]}, "err_obj": {"msg": "expected an indented block"}}], ["e8a8ad8cf16d2db510a29a2c06e3b28f", {"code_string": "def setupUi(self, FileLoaderG):\n    FileLoaderG.setObjectName(_fromUtf8(\"FileLoaderG\"))\n    FileLoaderG.resize(909, 541)\n    self.centralwidget = QtGui.QWidget(FileLoaderG)\n    self.centralwidget.setObjectName(_fromUtf8(\"centralwidget\"))\n    self.frame = QtGui.QFrame(self.centralwidget)\n    self.frame.setGeometry(QtCore.QRect(10, 10, 881, 439))\n    font = QtGui.QFont()\n    font.setBold(False)\n    font.setWeight(50)\n    self.frame.setFont(font)\n    self.frame.setStyleSheet(_fromUtf8(\"background-color: rgb(255, 255, 255);\"))\n    self.frame.setFrameShape(QtGui.QFrame.Box)\n    self.frame.setFrameShadow(QtGui.QFrame.Raised)\n    self.frame.setObjectName(_fromUtf8(\"frame\"))\n    self.gridLayout = QtGui.QGridLayout(self.frame)\n    self.gridLayout.setObjectName(_fromUtf8(\"gridLayout\"))\n    self.Local = PlotWidget(self.frame)\n    font = QtGui.QFont()\n    font.setPointSize(10)\n    self.Local.setFont(font)\n    self.Local.setStyleSheet(_fromUtf8(\"background-color: rgb(255, 255, 255);\\n\"\n", "code_toks_joined": "def setupUi ( self , FileLoaderG ) : <NEWLINE> <INDENT> FileLoaderG . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> FileLoaderG . resize ( 909 , 541 ) <NEWLINE> self . centralwidget = QtGui . QWidget ( FileLoaderG ) <NEWLINE> self . centralwidget . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . frame = QtGui . QFrame ( self . centralwidget ) <NEWLINE> self . frame . setGeometry ( QtCore . QRect ( 10 , 10 , 881 , 439 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setBold ( False ) <NEWLINE> font . setWeight ( 50 ) <NEWLINE> self . frame . setFont ( font ) <NEWLINE> self . frame . setStyleSheet ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . frame . setFrameShape ( QtGui . QFrame . Box ) <NEWLINE> self . frame . setFrameShadow ( QtGui . QFrame . Raised ) <NEWLINE> self . frame . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout = QtGui . QGridLayout ( self . frame ) <NEWLINE> self . gridLayout . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . Local = PlotWidget ( self . frame ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setPointSize ( 10 ) <NEWLINE> self . Local . setFont ( font ) <NEWLINE> self . Local . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"FileLoaderG\"", "\"centralwidget\"", "\"background-color: rgb(255, 255, 255);\"", "\"frame\"", "\"gridLayout\"", "\"background-color: rgb(255, 255, 255);\\n\""]}, "window_span": [231, 237], "err_obj": {"msg": "unbalanced (){}[]"}}], ["4882f2efd83814615673622ce4095c64", {"code_string": "def HasRenderingStats(process):\n    \"\"\" Returns True if the process contains at least one\"\"\"\n    if not process:\n        return False\n    for event in process.IterAllSlicesOfName(\n        'BenchmarkInstrumentation::DisplayRenderingStats'):\n        if 'data' in event.args and event.args['data']['frame_count'] == 1:\n        return True\n    for event in process.IterAllSlicesOfName(\n        'BenchmarkInstrumentation::ImplThreadRenderingStats'):\n        if 'data' in event.args and event.args['data']['frame_count'] == 1:\n        return True\n    return False\n", "code_toks_joined": "def HasRenderingStats ( process ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not process : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for event in process . IterAllSlicesOfName ( <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> if <STRING> in event . args and event . args [ <STRING> ] [ <STRING> ] == 1 : <NEWLINE> return True <NEWLINE> <DEDENT> for event in process . IterAllSlicesOfName ( <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> if <STRING> in event . args and event . args [ <STRING> ] [ <STRING> ] == 1 : <NEWLINE> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Returns True if the process contains at least one\"\"\"", "'BenchmarkInstrumentation::DisplayRenderingStats'", "'data'", "'data'", "'frame_count'", "'BenchmarkInstrumentation::ImplThreadRenderingStats'", "'data'", "'data'", "'frame_count'"]}, "err_obj": {"msg": "expected an indented block"}}], ["3d96ee23adeb6766ed3f0f3c30d97221", {"code_string": "class ExportTestBase(TestBase):\n    \"\"\"Base test class for classes that implement export functionality.\"\"\"\n    def assert_blacklisted_properties_removed(self, original_model, exported):\n        for prop in original_model._get_export_blacklist():\n            self.assertFalse(hasattr(exported, prop.name)))\n    def transform(self, value):\n        return 'transformed_' + value\n", "code_toks_joined": "class ExportTestBase ( TestBase ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def assert_blacklisted_properties_removed ( self , original_model , exported ) : <NEWLINE> <INDENT> for prop in original_model . _get_export_blacklist ( ) : <NEWLINE> <INDENT> self . assertFalse ( hasattr ( exported , prop . name ) ) ) <NEWLINE> <DEDENT> <DEDENT> def transform ( self , value ) : <NEWLINE> <INDENT> return <STRING> + value <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Base test class for classes that implement export functionality.\"\"\"", "'transformed_'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["69a3dd3987e33f5ea6a0dbe31b70316d", {"code_string": "class Migration(migrations.Migration):\n    dependencies = [\n        ('workshops', '0034_auto_20150723_0431'),\n    ]\n    operations = [\n        migrations.RunPython(partial(switch_host_to_tag, 'WISE',\n            'software-carpentry.org', 'WiSE',\n            'Women in Science and Engineering'),\n        migrations.RunPython(partial(switch_host_to_tag, 'online',\n            'software-carpentry.org', 'online',\n            'Events taking place entirely online')),\n    ]\n", "code_toks_joined": "class Migration ( migrations . Migration ) : <NEWLINE> <INDENT> dependencies = [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE> operations = [ <NEWLINE> <INDENT> migrations . RunPython ( partial ( switch_host_to_tag , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> <STRING> ) , <NEWLINE> <DEDENT> migrations . RunPython ( partial ( switch_host_to_tag , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> <STRING> ) ) , <NEWLINE> <DEDENT> <DEDENT> ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'workshops'", "'0034_auto_20150723_0431'", "'WISE'", "'software-carpentry.org'", "'WiSE'", "'Women in Science and Engineering'", "'online'", "'software-carpentry.org'", "'online'", "'Events taking place entirely online'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["d52261d75a5cc5b4b11c8fa4f12d60e2", {"code_string": "def shutdown(self):\n    print(\"SHUTDOWN: unloading the mp3 file in the NAO...\")\n    print(\"SHUTDOWN: checking the video status...\")\n        if self._video_proxy.isRecording() == True:\n        print(\"VIDEO: stopping the video record... \")\n        videoInfo = self._video_proxy.stopRecording()\n        self._is_recording = False\n    print(\"SHUTDOWN: closing hands...\")\n    self._al_motion_proxy.closeHand(\"RHand\");\n    self._al_motion_proxy.closeHand(\"LHand\");\n    print(\"SHUTDOWN: moving to reset position...\")\n    self._al_motion_proxy.rest()\n    print(\"SHUTDOWN: bye bye\")\n", "code_toks_joined": "def shutdown ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <INDENT> if self . _video_proxy . isRecording ( ) == True : <NEWLINE> print ( <STRING> ) <NEWLINE> videoInfo = self . _video_proxy . stopRecording ( ) <NEWLINE> self . _is_recording = False <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> self . _al_motion_proxy . closeHand ( <STRING> ) ; <NEWLINE> self . _al_motion_proxy . closeHand ( <STRING> ) ; <NEWLINE> print ( <STRING> ) <NEWLINE> self . _al_motion_proxy . rest ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"SHUTDOWN: unloading the mp3 file in the NAO...\"", "\"SHUTDOWN: checking the video status...\"", "\"VIDEO: stopping the video record... \"", "\"SHUTDOWN: closing hands...\"", "\"RHand\"", "\"LHand\"", "\"SHUTDOWN: moving to reset position...\"", "\"SHUTDOWN: bye bye\""]}, "err_obj": {"msg": "unexpected indent"}}], ["2c3b41d07e38292129a244da6954668b", {"code_string": "def test_create_metering_label_shared(self):\n    name = 'my label'\n    description = 'my metering label'\n    shared = True\n    keys = [('name', name, ), ('description', description),\n        ('shared', shared)]\n    with self.metering_label(name, description,\n        shared = shared) as metering_label:\n        for k, v, in keys:\n        self.assertEqual(metering_label['metering_label'][k], v)\n", "code_toks_joined": "def test_create_metering_label_shared ( self ) : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> description = <STRING> <NEWLINE> shared = True <NEWLINE> keys = [ ( <STRING> , name , ) , ( <STRING> , description ) , <NEWLINE> <INDENT> ( <STRING> , shared ) ] <NEWLINE> <DEDENT> with self . metering_label ( name , description , <NEWLINE> <INDENT> shared = shared ) as metering_label : <NEWLINE> for k , v , in keys : <NEWLINE> self . assertEqual ( metering_label [ <STRING> ] [ k ] , v ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'my label'", "'my metering label'", "'name'", "'description'", "'shared'", "'metering_label'"]}, "err_obj": {"msg": "expected an indented block"}}], ["2311526945cace528641de0374517b44", {"code_string": "def postimport(self):\n    for rb in RelatedBill.objects.filter(\n        bill__legislative_session__jurisdiction_id = self.jurisdiction_id,\n        related_bill = None):\n        candidates = list(Bill.objects.filter(\n        legislative_session__identifier = rb.legislative_session,\n        legislative_session__jurisdiction_id = self.jurisdiction_id,\n        identifier = rb.identifier)\n        )\n        if len(candidates) == 1:\n        rb.related_bill = candidates[0]\n        rb.save()\n        elif len(candidates) > 1:\n        raise PupaInternalError('multiple related_bill candidates found for {}'.format(rb))\n", "code_toks_joined": "def postimport ( self ) : <NEWLINE> <INDENT> for rb in RelatedBill . objects . filter ( <NEWLINE> <INDENT> bill__legislative_session__jurisdiction_id = self . jurisdiction_id , <NEWLINE> related_bill = None ) : <NEWLINE> candidates = list ( Bill . objects . filter ( <NEWLINE> legislative_session__identifier = rb . legislative_session , <NEWLINE> legislative_session__jurisdiction_id = self . jurisdiction_id , <NEWLINE> identifier = rb . identifier ) <NEWLINE> ) <NEWLINE> if len ( candidates ) == 1 : <NEWLINE> rb . related_bill = candidates [ 0 ] <NEWLINE> rb . save ( ) <NEWLINE> elif len ( candidates ) > 1 : <NEWLINE> raise PupaInternalError ( <STRING> . format ( rb ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'multiple related_bill candidates found for {}'"]}, "err_obj": {"msg": "expected an indented block"}}], ["6c894f4d09d55958782ece4b381ba9a7", {"code_string": "def get_bugcheck_callbacks(self):\n    resolver = self.session.address_resolver\n    for list_head_name, type in[\n        (\"nt!KeBugCheckCallbackListHead\", \"_KBUGCHECK_CALLBACK_RECORD\"),\n        (\"nt!KeBugCheckReasonCallbackListHead\",\n            \"_KBUGCHECK_REASON_CALLBACK_RECORD\")]:\n            list_head = resolver.get_constant_object(\n        list_head_name, \"_LIST_ENTRY\")\n        for record in list_head.list_of_type(type, \"Entry\"):\n        function = record.CallbackRoutine\n        yield(list_head_name,\n            record,\n            function,\n            utils.FormattedAddress(resolver, function),\n            record.Component)\n", "code_toks_joined": "def get_bugcheck_callbacks ( self ) : <NEWLINE> <INDENT> resolver = self . session . address_resolver <NEWLINE> for list_head_name , type in [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <NEWLINE> <INDENT> <STRING> ) ] : <NEWLINE> list_head = resolver . get_constant_object ( <NEWLINE> <DEDENT> list_head_name , <STRING> ) <NEWLINE> for record in list_head . list_of_type ( type , <STRING> ) : <NEWLINE> function = record . CallbackRoutine <NEWLINE> yield ( list_head_name , <NEWLINE> <INDENT> record , <NEWLINE> function , <NEWLINE> utils . FormattedAddress ( resolver , function ) , <NEWLINE> record . Component ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"nt!KeBugCheckCallbackListHead\"", "\"_KBUGCHECK_CALLBACK_RECORD\"", "\"nt!KeBugCheckReasonCallbackListHead\"", "\"_KBUGCHECK_REASON_CALLBACK_RECORD\"", "\"_LIST_ENTRY\"", "\"Entry\""]}, "err_obj": {"msg": "unindent does not match any outer indentation level"}}], ["79f48bded627ea2fce5313436182eb28", {"code_string": "def cur_tok_val(self):\n    if self._idx == len(self._alltoks)\n        return None\n    return self._alltoks[self._idx]['val']\n", "code_toks_joined": "def cur_tok_val ( self ) : <NEWLINE> <INDENT> if self . _idx == len ( self . _alltoks ) <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> return self . _alltoks [ self . _idx ] [ <STRING> ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'val'"]}, "err_obj": {"msg": "invalid syntax"}}], ["f5d1a81ed94666f955e92b4683464387", {"code_string": "def test_get_by_host_and_binary(self):\n    with mock.patch.object(self.dbapi,\n        'get_magnum_service_by_host_and_binary',\n        autospec = True) as mock_get_magnum_service:\n        mock_get_magnum_service.return_value = self.fake_magnum_service\n        ms = objects.MagnumService.get_by_host_and_binary(self.context,\n            'fake-host',\n            'fake-bin')\n            mock_get_magnum_service.assert_called_once_with('fake-host',\n            'fake-bin')\n            self.assertEqual(self.context, ms._context)\n", "code_toks_joined": "def test_get_by_host_and_binary ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( self . dbapi , <NEWLINE> <INDENT> <STRING> , <NEWLINE> autospec = True ) as mock_get_magnum_service : <NEWLINE> mock_get_magnum_service . return_value = self . fake_magnum_service <NEWLINE> ms = objects . MagnumService . get_by_host_and_binary ( self . context , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ) <NEWLINE> mock_get_magnum_service . assert_called_once_with ( <STRING> , <NEWLINE> <STRING> ) <NEWLINE> self . assertEqual ( self . context , ms . _context ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'get_magnum_service_by_host_and_binary'", "'fake-host'", "'fake-bin'", "'fake-host'", "'fake-bin'"]}, "err_obj": {"msg": "unexpected indent"}}], ["481c2b393f6e5f71684446d4d56ac403", {"code_string": "def changeCT(self):\n    'changeCT(self)- change CT dialog and redraw surface with new CT'\n    from viewCT import *\n    self.ct = getCTI(self.interior()\n    self.ctable = 1\n    self.drawsurf2()\n    self.ctable = 0\n    self.drawImage()\n", "code_toks_joined": "def changeCT ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> from viewCT import * <NEWLINE> self . ct = getCTI ( self . interior ( ) <NEWLINE> self . ctable = 1 <NEWLINE> self . drawsurf2 ( ) <NEWLINE> self . ctable = 0 <NEWLINE> self . drawImage ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'changeCT(self)- change CT dialog and redraw surface with new CT'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["211fbd6e30aefb03234937b68aee5849", {"code_string": "def exec_command(self, command):\n    to_exec = command % self.ssl_dictionary\n    LOG.info(to_exec)\n    subprocess.check_call(to_exec.rsplit(' ')\n", "code_toks_joined": "def exec_command ( self , command ) : <NEWLINE> <INDENT> to_exec = command % self . ssl_dictionary <NEWLINE> LOG . info ( to_exec ) <NEWLINE> subprocess . check_call ( to_exec . rsplit ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["' '"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["5503f4d46a5355667df03668974a4c4a", {"code_string": "def executeDeferred(func, * args, ** kwargs):\n    \"\"\"This is a wrap for maya.utils.executeDeferred.  Maya's version does not execute at all when in batch mode, so this\"\"\"\n    import maya.utils\n    import maya.OpenMaya\n    if maya.OpenMaya.MGlobal.mayaState() == maya.OpenMaya.MGlobal.kInteractive:\n        maya.utils.executeDeferred(func, * args, ** kwargs)\n    else:\n        if isinstance(func, basestring):\n            if args or kwargs:\n                raise ValueError('if passing a string to be executed, no additional args may be passed')\n            exec func\n        else:\n            func(* args, ** kwargs)\n", "code_toks_joined": "def executeDeferred ( func , * args , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import maya . utils <NEWLINE> import maya . OpenMaya <NEWLINE> if maya . OpenMaya . MGlobal . mayaState ( ) == maya . OpenMaya . MGlobal . kInteractive : <NEWLINE> <INDENT> maya . utils . executeDeferred ( func , * args , ** kwargs ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if isinstance ( func , basestring ) : <NEWLINE> <INDENT> if args or kwargs : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> exec func <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> func ( * args , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"This is a wrap for maya.utils.executeDeferred.  Maya's version does not execute at all when in batch mode, so this\"\"\"", "'if passing a string to be executed, no additional args may be passed'"]}, "err_obj": {"msg": "invalid syntax"}}], ["9d5bad4ec4d50b9f2a376b1b3f469377", {"code_string": "def testAgendaUnauthorized(self):\n    res = self.client.get(reverse('agenda-detail', kwargs = {'pk' self.agenda_3.id}))\n    self.assertEqual(res.status_code, 403)\n", "code_toks_joined": "def testAgendaUnauthorized ( self ) : <NEWLINE> <INDENT> res = self . client . get ( reverse ( <STRING> , kwargs = { <STRING> self . agenda_3 . id } ) ) <NEWLINE> self . assertEqual ( res . status_code , 403 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'agenda-detail'", "'pk'"]}, "err_obj": {"msg": "invalid syntax"}}], ["6b85bb7ade39ba83514c8c76000960b8", {"code_string": "def __in_box(self, coordinates, box_corner, seg_len):\n    \"\"\"convert normalized coordinates into image coordinates in the given\"\"\"\n    in_box_coords = []\n    for xy in coordinates:\n    in_box_coords.append((\n        box_corner[0] + seg_len * xy[0],\n        box_corner[1] + seg_len * xy[1]\n        ))\n        return in_box_coords\n", "code_toks_joined": "def __in_box ( self , coordinates , box_corner , seg_len ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> in_box_coords = [ ] <NEWLINE> for xy in coordinates : <NEWLINE> in_box_coords . append ( ( <NEWLINE> <INDENT> box_corner [ 0 ] + seg_len * xy [ 0 ] , <NEWLINE> box_corner [ 1 ] + seg_len * xy [ 1 ] <NEWLINE> ) ) <NEWLINE> return in_box_coords <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"convert normalized coordinates into image coordinates in the given\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["8824ec5672d59ceec77305902ef1f96c", {"code_string": "def speaker(request, id):\n    speaker = get_object_or_404(Speaker, id = id)\n    action_search_args = {'puhuja': speaker.id}\n    if 'vuosi' in request.GET:\n        action_search_args['vuosi'] = request.GET['vuosi'];\n    (actions, actions_url_prefix, year) = Action.search(action_search_args)\n    return render_to_response('taysistunto/puhuja.html', {\n        'request': request,\n        'speaker': speaker,\n        'trend_url_prefix': '?vuosi=',\n        'actions': actions[0: ],\n        'actions_url_prefix': actions_url_prefix,\n        'years': range(2006, datetime.datetime.now().year + 1),\n    },\n    context_instance = RequestContext(request)\n", "code_toks_joined": "def speaker ( request , id ) : <NEWLINE> <INDENT> speaker = get_object_or_404 ( Speaker , id = id ) <NEWLINE> action_search_args = { <STRING> : speaker . id } <NEWLINE> if <STRING> in request . GET : <NEWLINE> <INDENT> action_search_args [ <STRING> ] = request . GET [ <STRING> ] ; <NEWLINE> <DEDENT> ( actions , actions_url_prefix , year ) = Action . search ( action_search_args ) <NEWLINE> return render_to_response ( <STRING> , { <NEWLINE> <INDENT> <STRING> : request , <NEWLINE> <STRING> : speaker , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : actions [ 0 : ] , <NEWLINE> <STRING> : actions_url_prefix , <NEWLINE> <STRING> : range ( 2006 , datetime . datetime . now ( ) . year + 1 ) , <NEWLINE> <DEDENT> } , <NEWLINE> context_instance = RequestContext ( request ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'puhuja'", "'vuosi'", "'vuosi'", "'vuosi'", "'taysistunto/puhuja.html'", "'request'", "'speaker'", "'trend_url_prefix'", "'?vuosi='", "'actions'", "'actions_url_prefix'", "'years'"]}, "window_span": [71, 138], "err_obj": {"msg": "unbalanced (){}[]"}}], ["ed48be6dbb0a88e6e64a166a63bf41b6", {"code_string": "import datetime\nfrom django.db import models\nfrom django.db.models import Q\nfrom django.utils.translation import ugettext_lazy as _\nfrom django.template import loader, Context\nfrom django.template.defaultfilters import slugify\nfrom django.core import urlresolvers\nfrom django.conf import settings\nfrom django.utils import translation\ntry:\n    from django.db.models.fields.related_descriptors import ReverseOneToOneDescriptor\nexcept Exception, e:\n    from django.db.models.fields.related import SingleRelatedObjectDescriptor as ReverseOneToOneDescriptor\n", "code_toks_joined": "import datetime <NEWLINE> from django . db import models <NEWLINE> from django . db . models import Q <NEWLINE> from django . utils . translation import ugettext_lazy as _ <NEWLINE> from django . template import loader , Context <NEWLINE> from django . template . defaultfilters import slugify <NEWLINE> from django . core import urlresolvers <NEWLINE> from django . conf import settings <NEWLINE> from django . utils import translation <NEWLINE> try : <NEWLINE> <INDENT> from django . db . models . fields . related_descriptors import ReverseOneToOneDescriptor <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> from django . db . models . fields . related import SingleRelatedObjectDescriptor as ReverseOneToOneDescriptor <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["023affe910f832e7edfce2002b2984b1", {"code_string": "def get_instance(self, class_name, key):\n    c = self.get_class(class_name)\n    key_instance = self.new_instance_from_class(c)\n    for k, v in key.items():\n        key_instance._instance[six.text_type(k)] = v\n    with self._session.get_instance(\n        self._ns, key_instance._instance) as op:\n        instance = op.get_next_instance()\n        if instance:\n        return _Instance(self, instance.clone())\n", "code_toks_joined": "def get_instance ( self , class_name , key ) : <NEWLINE> <INDENT> c = self . get_class ( class_name ) <NEWLINE> key_instance = self . new_instance_from_class ( c ) <NEWLINE> for k , v in key . items ( ) : <NEWLINE> <INDENT> key_instance . _instance [ six . text_type ( k ) ] = v <NEWLINE> <DEDENT> with self . _session . get_instance ( <NEWLINE> <INDENT> self . _ns , key_instance . _instance ) as op : <NEWLINE> instance = op . get_next_instance ( ) <NEWLINE> if instance : <NEWLINE> return _Instance ( self , instance . clone ( ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["eac3e0ad3d7045abc9f4ee4ed4e73521", {"code_string": "def usage():\n    print(\"Usage: \", argv[\n        0], \"--rows label.racol --columns predictions.racol [ --weights seq.length --matrix-form sparse/quadratic\" \" --class-for-missing-predictions \" \" --allow-missing-rows --allow-missing-columns\" \" --multiclass-separator ';']\"\n", "code_toks_joined": "def usage ( ) : <NEWLINE> <INDENT> print ( <STRING> , argv [ <NEWLINE> <INDENT> 0 ] , <STRING> <STRING> <STRING> <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Usage: \"", "\"--rows label.racol --columns predictions.racol [ --weights seq.length --matrix-form sparse/quadratic\"", "\" --class-for-missing-predictions \"", "\" --allow-missing-rows --allow-missing-columns\"", "\" --multiclass-separator ';']\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["3f22b99fdcf8aa158ed9d24a60b27b87", {"code_string": "def forEachLoopMaxInteger(max):\n    sum = 0\n        for n in xrange(0, max):\n        foo = n / 17\n        sum = sum + n\n    return sum\n", "code_toks_joined": "def forEachLoopMaxInteger ( max ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> <INDENT> for n in xrange ( 0 , max ) : <NEWLINE> foo = n / 17 <NEWLINE> sum = sum + n <NEWLINE> <DEDENT> return sum <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["ff0cee22ae452ec3a8529009cf1e5c38", {"code_string": "def test_simple(self):\n    response = self.client.get(reverse('item_chooser')\n    self.assertEqual(response.status_code, 200)\n    self.assertTemplateUsed(response, 'wagtailmodelchooser/chooser/model_chooser.html')\n    self.assertTemplateUsed(response, 'wagtailmodelchooser/chooser/model_chooser.js')\n", "code_toks_joined": "def test_simple ( self ) : <NEWLINE> <INDENT> response = self . client . get ( reverse ( <STRING> ) <NEWLINE> self . assertEqual ( response . status_code , 200 ) <NEWLINE> self . assertTemplateUsed ( response , <STRING> ) <NEWLINE> self . assertTemplateUsed ( response , <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'item_chooser'", "'wagtailmodelchooser/chooser/model_chooser.html'", "'wagtailmodelchooser/chooser/model_chooser.js'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["f3b1d386d0bd8a77bfd45f4fd14e6a10", {"code_string": "def event_callback(self, event_type, ** kwargs):\n    \"\"\"Publish event generated in driver\"\"\"\n    log.debug(\"Publish ResourceAgentIOEvent from publisher_callback\")\n    self._event_publisher.publish_event(\n        event_type = event_type,\n        origin_type = self.ORIGIN_TYPE\n        origin = self.resource_id,\n        ** kwargs\n    )\n", "code_toks_joined": "def event_callback ( self , event_type , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> log . debug ( <STRING> ) <NEWLINE> self . _event_publisher . publish_event ( <NEWLINE> <INDENT> event_type = event_type , <NEWLINE> origin_type = self . ORIGIN_TYPE <NEWLINE> origin = self . resource_id , <NEWLINE> ** kwargs <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Publish event generated in driver\"\"\"", "\"Publish ResourceAgentIOEvent from publisher_callback\""]}, "err_obj": {"msg": "invalid syntax"}}], ["65b5041588aa839ed7b52eb625400028", {"code_string": "def retranslateUi(self, HgQueuesListDialog):\n    _translate = QtCore.QCoreApplication.translate\n    HgQueuesListDialog.setWindowTitle(_translate(\"HgQueuesListDialog\", \"List of Patches\"))\n    HgQueuesListDialog.setWhatsThis(_translate(\"HgQueuesListDialog\", \"<b>List of Patches</b>\\n\"\n", "code_toks_joined": "def retranslateUi ( self , HgQueuesListDialog ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> HgQueuesListDialog . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> HgQueuesListDialog . setWhatsThis ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"HgQueuesListDialog\"", "\"List of Patches\"", "\"HgQueuesListDialog\"", "\"<b>List of Patches</b>\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["45dc8389ad73dcce429185a1d09f455f", {"code_string": "def _format_tag_patterns(self, pattern):\n    for search, replace in[('&', 'AND'), ('AND', ' AND '), ('OR', ' OR '),\n        ('NOT', ' NOT '), ('_', ' ')]:\n        if search in pattern:\n        pattern = pattern.replace(search, replace)\n    while '  ' in pattern:\n        pattern = pattern.replace('  ', ' ')\n    return pattern\n", "code_toks_joined": "def _format_tag_patterns ( self , pattern ) : <NEWLINE> <INDENT> for search , replace in [ ( <STRING> , <STRING> ) , ( <STRING> , <STRING> ) , ( <STRING> , <STRING> ) , <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , ( <STRING> , <STRING> ) ] : <NEWLINE> if search in pattern : <NEWLINE> pattern = pattern . replace ( search , replace ) <NEWLINE> <DEDENT> while <STRING> in pattern : <NEWLINE> <INDENT> pattern = pattern . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> return pattern <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'&'", "'AND'", "'AND'", "' AND '", "'OR'", "' OR '", "'NOT'", "' NOT '", "'_'", "' '", "'  '", "'  '", "' '"]}, "err_obj": {"msg": "expected an indented block"}}], ["a87522b8c1acea4a6fddb028385d2632", {"code_string": "def test_compilers():\n    for module in('ibm', 'gnu'):\n        for test, np, expected_output in[('hello_world', 1, 'hello world'),\n            ('hello_world_mpi', 128, '128.0: hello world')]:\n            for ext, compiler in[('c', '${CC}'),\n            ('cpp', '${CXX}'),\n            ('f', '${FC}'),\n            ('f90', '${F90}')]:\n            source = test + '.' + ext\n            target = test + '_' + ext + '.exe'\n            yield check_build_and_verify, module, compiler, source, target, np, expected_output\n", "code_toks_joined": "def test_compilers ( ) : <NEWLINE> <INDENT> for module in ( <STRING> , <STRING> ) : <NEWLINE> <INDENT> for test , np , expected_output in [ ( <STRING> , 1 , <STRING> ) , <NEWLINE> <INDENT> ( <STRING> , 128 , <STRING> ) ] : <NEWLINE> for ext , compiler in [ ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) ] : <NEWLINE> source = test + <STRING> + ext <NEWLINE> target = test + <STRING> + ext + <STRING> <NEWLINE> yield check_build_and_verify , module , compiler , source , target , np , expected_output <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'ibm'", "'gnu'", "'hello_world'", "'hello world'", "'hello_world_mpi'", "'128.0: hello world'", "'c'", "'${CC}'", "'cpp'", "'${CXX}'", "'f'", "'${FC}'", "'f90'", "'${F90}'", "'.'", "'_'", "'.exe'"]}, "err_obj": {"msg": "expected an indented block"}}], ["45387f417b0bb7a3b038564b2c23479e", {"code_string": "def _loginSucceeded(self, (interface, avatar, logout)):\n    \"\"\"Handle login success by wrapping the resulting L{IResource} avatar\"\"\"\n    class ResourceWrapper(proxyForInterface(IResource, 'resource')):\n        \"\"\"Wrap an L{IResource} so that whenever it or a child of it\"\"\"\n        def getChildWithDefault(self, name, request):\n            \"\"\"Pass through the lookup to the wrapped resource, wrapping\"\"\"\n            return ResourceWrapper(self.resource.getChildWithDefault(name, request))\n        def render(self, request):\n            \"\"\"Hook into response generation so that when rendering has\"\"\"\n            request.notifyFinish().addCallback(lambda ign: logout())\n            return super(ResourceWrapper, self).render(request)\n    return ResourceWrapper(avatar)\n", "code_toks_joined": "def _loginSucceeded ( self , ( interface , avatar , logout ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> class ResourceWrapper ( proxyForInterface ( IResource , <STRING> ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def getChildWithDefault ( self , name , request ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return ResourceWrapper ( self . resource . getChildWithDefault ( name , request ) ) <NEWLINE> <DEDENT> def render ( self , request ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> request . notifyFinish ( ) . addCallback ( lambda ign : logout ( ) ) <NEWLINE> return super ( ResourceWrapper , self ) . render ( request ) <NEWLINE> <DEDENT> <DEDENT> return ResourceWrapper ( avatar ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Handle login success by wrapping the resulting L{IResource} avatar\"\"\"", "'resource'", "\"\"\"Wrap an L{IResource} so that whenever it or a child of it\"\"\"", "\"\"\"Pass through the lookup to the wrapped resource, wrapping\"\"\"", "\"\"\"Hook into response generation so that when rendering has\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["26e54080f64c95a16847197c93b22046", {"code_string": "def test_add_column():\n    setupClass(EventTester)\n    watcher = make_listen(events.AddColumnSignal)\n    events.summarize_events_by_sender()\n    class NewEventTester(EventTester):\n        name2 = StringCol()\n    expect = (\n        NewEventTester, None,\n        'name2', NewEventTester.sqlmeta.columnDefinitions['name2'],\n        False, [])\n    print(zip(watcher.log[1], expect)\n    assert watcher.log[1] == expect\n", "code_toks_joined": "def test_add_column ( ) : <NEWLINE> <INDENT> setupClass ( EventTester ) <NEWLINE> watcher = make_listen ( events . AddColumnSignal ) <NEWLINE> events . summarize_events_by_sender ( ) <NEWLINE> class NewEventTester ( EventTester ) : <NEWLINE> <INDENT> name2 = StringCol ( ) <NEWLINE> <DEDENT> expect = ( <NEWLINE> <INDENT> NewEventTester , None , <NEWLINE> <STRING> , NewEventTester . sqlmeta . columnDefinitions [ <STRING> ] , <NEWLINE> False , [ ] ) <NEWLINE> <DEDENT> print ( zip ( watcher . log [ 1 ] , expect ) <NEWLINE> assert watcher . log [ 1 ] == expect <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'name2'", "'name2'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["de5141872202bd176714095d27403f9a", {"code_string": "def createRaidLevelMenu(self, levels, reqlevel):\n    levelcombo = gtk.combo_box_new_text()\n    defindex = 0\n    if mdraidlib.RAID1 in levels:\n        defindex = levels.index(mdraidlib.RAID1)\n        i = 0\n        for lev in levels:\n        levelcombo.append_text(\"RAID%d\" % lev)\n        if reqlevel is not None and lev == reqlevel:\n        defindex = i\n        i = i + 1\n    levelcombo.set_active(defindex)\n    levelcombo.connect(\"changed\", self.raidlevelchangeCB)\n    return levelcombo\n", "code_toks_joined": "def createRaidLevelMenu ( self , levels , reqlevel ) : <NEWLINE> <INDENT> levelcombo = gtk . combo_box_new_text ( ) <NEWLINE> defindex = 0 <NEWLINE> if mdraidlib . RAID1 in levels : <NEWLINE> <INDENT> defindex = levels . index ( mdraidlib . RAID1 ) <NEWLINE> i = 0 <NEWLINE> for lev in levels : <NEWLINE> levelcombo . append_text ( <STRING> % lev ) <NEWLINE> if reqlevel is not None and lev == reqlevel : <NEWLINE> defindex = i <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> levelcombo . set_active ( defindex ) <NEWLINE> levelcombo . connect ( <STRING> , self . raidlevelchangeCB ) <NEWLINE> return levelcombo <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"RAID%d\"", "\"changed\""]}, "err_obj": {"msg": "expected an indented block"}}], ["113c949cceedd63485b7b177c9063f29", {"code_string": "def _create_player_logic_blocks(self, player, ** kwargs):\n    \"\"\"Creates the game-wide logic blocks for this player.\"\"\"\n    player.uvars['logic_blocks'] = set()\n    if 'logic_blocks' in self.machine.config:\n        self._create_logic_blocks(config = self.machine.config['logic_blocks']\n            player = player,\n            enable = False)\n", "code_toks_joined": "def _create_player_logic_blocks ( self , player , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> player . uvars [ <STRING> ] = set ( ) <NEWLINE> if <STRING> in self . machine . config : <NEWLINE> <INDENT> self . _create_logic_blocks ( config = self . machine . config [ <STRING> ] <NEWLINE> <INDENT> player = player , <NEWLINE> enable = False ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Creates the game-wide logic blocks for this player.\"\"\"", "'logic_blocks'", "'logic_blocks'", "'logic_blocks'"]}, "err_obj": {"msg": "invalid syntax"}}], ["03657cacad4d2006e916afdf1005e2b4", {"code_string": "def updateSerial():\n    global alpha1\n    global alpha2\n    global ser\n    try:\n    msg = NMEA(\"PW1\", alpha1, \"OR\")\n    print(\"Send \" + msg)\n    ser.write(msg)\n        msg = NMEA(\"PW2\", alpha2, \"OR\")\n    print(\"Send \" + msg)\n    ser.write(msg)\n    except Exception, e:\n        print(\"Serial exception: \" + str(e))\n", "code_toks_joined": "def updateSerial ( ) : <NEWLINE> <INDENT> global alpha1 <NEWLINE> global alpha2 <NEWLINE> global ser <NEWLINE> try : <NEWLINE> msg = NMEA ( <STRING> , alpha1 , <STRING> ) <NEWLINE> print ( <STRING> + msg ) <NEWLINE> ser . write ( msg ) <NEWLINE> <INDENT> msg = NMEA ( <STRING> , alpha2 , <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> + msg ) <NEWLINE> ser . write ( msg ) <NEWLINE> except Exception , e : <NEWLINE> <INDENT> print ( <STRING> + str ( e ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"PW1\"", "\"OR\"", "\"Send \"", "\"PW2\"", "\"OR\"", "\"Send \"", "\"Serial exception: \""]}, "err_obj": {"msg": "expected an indented block"}}], ["312d048f77e23b301fa22cd0c06e9ec1", {"code_string": "def te_extraction_tup(args, input = None):\n    if extract.__file__.endswith('.pyc'): yield extract.__file__[: - 1]\n    else: yield extract.__file__\n    for x in('out', 'min_distance', 'min_length', 'max_overlap',\n        'evalue_threshold'):\n        val = getattr(args, x)\n        if val is not None:\n        yield '--{}={}'.format(x.replace('_', '-'), val)\n    yield '-' if input is None else input\n", "code_toks_joined": "def te_extraction_tup ( args , input = None ) : <NEWLINE> <INDENT> if extract . __file__ . endswith ( <STRING> ) : yield extract . __file__ [ : - 1 ] <NEWLINE> else : yield extract . __file__ <NEWLINE> for x in ( <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> val = getattr ( args , x ) <NEWLINE> if val is not None : <NEWLINE> yield <STRING> . format ( x . replace ( <STRING> , <STRING> ) , val ) <NEWLINE> <DEDENT> yield <STRING> if input is None else input <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'.pyc'", "'out'", "'min_distance'", "'min_length'", "'max_overlap'", "'evalue_threshold'", "'--{}={}'", "'_'", "'-'", "'-'"]}, "err_obj": {"msg": "expected an indented block"}}], ["0adcb3d31d488548a8cdda44778545f1", {"code_string": "def _filter_link(self, link, seen)\n    url = link.url\n    if self.url_filterf(link):\n        if url not in seen:\n            seen.add(url)\n            request = Request(url)\n            if link.text:\n                request.meta['link_text'] = link.text\n            return request\n", "code_toks_joined": "def _filter_link ( self , link , seen ) <NEWLINE> <INDENT> url = link . url <NEWLINE> if self . url_filterf ( link ) : <NEWLINE> <INDENT> if url not in seen : <NEWLINE> <INDENT> seen . add ( url ) <NEWLINE> request = Request ( url ) <NEWLINE> if link . text : <NEWLINE> <INDENT> request . meta [ <STRING> ] = link . text <NEWLINE> <DEDENT> return request <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'link_text'"]}, "err_obj": {"msg": "invalid syntax"}}], ["f972d5f3e765d4ce7b5b3bf217b6fec7", {"code_string": "def retranslateUi(self, Form):\n    _translate = QtCore.QCoreApplication.translate\n    Form.setWindowTitle(_translate(\"Form\", \"Form\"))\n    self.label_7.setText(_translate(\"Form\", \"<html><head/><body><p>Measure the distance between two points.</p></body></html>\"))\n    self.label_4.setText(_translate(\"Form\", \"Distance:\"))\n    self.label_5.setText(_translate(\"Form\", \"Max:\"))\n    self.Max_val.setHtml(_translate(\"Form\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , Form ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> Form . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . label_7 . setText ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . label_4 . setText ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . label_5 . setText ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . Max_val . setHtml ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Form\"", "\"Form\"", "\"Form\"", "\"<html><head/><body><p>Measure the distance between two points.</p></body></html>\"", "\"Form\"", "\"Distance:\"", "\"Form\"", "\"Max:\"", "\"Form\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["57e62a5584fb81b09ad7c22fa0a51ddf", {"code_string": "def Warn(self, msg):\n    if GetOption('release_debug'):\n        print 'Warn: %s' % msg\n    self.warns.append(msg)\n", "code_toks_joined": "def Warn ( self , msg ) : <NEWLINE> <INDENT> if GetOption ( <STRING> ) : <NEWLINE> <INDENT> print <STRING> % msg <NEWLINE> <DEDENT> self . warns . append ( msg ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'release_debug'", "'Warn: %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["3cfa43cd0b63c0c52e2f732b51c4c1ed", {"code_string": "def swap(self):\n    tmp = self.__class__(map(lambda(x, y): (y, x), self.items()))\n    self.list, self.dict = tmp.list, tmp.dict\n", "code_toks_joined": "def swap ( self ) : <NEWLINE> <INDENT> tmp = self . __class__ ( map ( lambda ( x , y ) : ( y , x ) , self . items ( ) ) ) <NEWLINE> self . list , self . dict = tmp . list , tmp . dict <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["eb7e5ad9fe3207eb0567f752e0135bb3", {"code_string": "class Ui_Configurazione(object):\n    def setupUi(self, Configurazione):\n        Configurazione.setObjectName(_fromUtf8(\"Configurazione\"))\n        Configurazione.setWindowModality(QtCore.Qt.ApplicationModal)\n        Configurazione.resize(500, 500)\n        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(Configurazione.sizePolicy().hasHeightForWidth())\n        Configurazione.setSizePolicy(sizePolicy)\n        Configurazione.setMinimumSize(QtCore.QSize(500, 500))\n        Configurazione.setMaximumSize(QtCore.QSize(500, 500))\n        Configurazione.setFocusPolicy(QtCore.Qt.NoFocus)\n        icon = QtGui.QIcon()\n        icon.addPixmap(QtGui.QPixmap(_fromUtf8(\":/resources/icon_mmas.png\")), QtGui.QIcon.Normal, QtGui.QIcon.Off)\n        Configurazione.setWindowIcon(icon)\n        Configurazione.setStyleSheet(_fromUtf8(\"QMenu {\\n\"\n", "code_toks_joined": "class Ui_Configurazione ( object ) : <NEWLINE> <INDENT> def setupUi ( self , Configurazione ) : <NEWLINE> <INDENT> Configurazione . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> Configurazione . setWindowModality ( QtCore . Qt . ApplicationModal ) <NEWLINE> Configurazione . resize ( 500 , 500 ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Fixed , QtGui . QSizePolicy . Fixed ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( Configurazione . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> Configurazione . setSizePolicy ( sizePolicy ) <NEWLINE> Configurazione . setMinimumSize ( QtCore . QSize ( 500 , 500 ) ) <NEWLINE> Configurazione . setMaximumSize ( QtCore . QSize ( 500 , 500 ) ) <NEWLINE> Configurazione . setFocusPolicy ( QtCore . Qt . NoFocus ) <NEWLINE> icon = QtGui . QIcon ( ) <NEWLINE> icon . addPixmap ( QtGui . QPixmap ( _fromUtf8 ( <STRING> ) ) , QtGui . QIcon . Normal , QtGui . QIcon . Off ) <NEWLINE> Configurazione . setWindowIcon ( icon ) <NEWLINE> Configurazione . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Configurazione\"", "\":/resources/icon_mmas.png\"", "\"QMenu {\\n\""]}, "window_span": [187, 194], "err_obj": {"msg": "unbalanced (){}[]"}}], ["4b94ba05aefed69a661d9d6c23596f5d", {"code_string": "def setUp(self):\n    self.driver = webdriver.PhantomJS()\n    self.driver.implicitly_wait(30)\n    self.base_url = os.environ['TEST_BASE_URL']\n    if 'http://' not in self.base_url:\n    self.base_url = 'http://' + self.base_url\n    if self.base_url[- 1] != '/':\n        self.base_url += '/'\n    self.verificationErrors = []\n    self.accept_next_alert = True\n", "code_toks_joined": "def setUp ( self ) : <NEWLINE> <INDENT> self . driver = webdriver . PhantomJS ( ) <NEWLINE> self . driver . implicitly_wait ( 30 ) <NEWLINE> self . base_url = os . environ [ <STRING> ] <NEWLINE> if <STRING> not in self . base_url : <NEWLINE> self . base_url = <STRING> + self . base_url <NEWLINE> if self . base_url [ - 1 ] != <STRING> : <NEWLINE> <INDENT> self . base_url += <STRING> <NEWLINE> <DEDENT> self . verificationErrors = [ ] <NEWLINE> self . accept_next_alert = True <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'TEST_BASE_URL'", "'http://'", "'http://'", "'/'", "'/'"]}, "err_obj": {"msg": "expected an indented block"}}], ["447672370dab55f0a7784210839886b0", {"code_string": "import sys\nimport logging\nfrom avocado.utils import process\ntry\n    from avocado.core.plugin_interfaces import CLICmd\nexcept ImportError:\n    from avocado.plugins.base import CLICmd\nfrom virttest import bootstrap\nfrom virttest import defaults\nfrom virttest.standalone_test import SUPPORTED_TEST_TYPES\n", "code_toks_joined": "import sys <NEWLINE> import logging <NEWLINE> from avocado . utils import process <NEWLINE> try <NEWLINE> <INDENT> from avocado . core . plugin_interfaces import CLICmd <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> from avocado . plugins . base import CLICmd <NEWLINE> <DEDENT> from virttest import bootstrap <NEWLINE> from virttest import defaults <NEWLINE> from virttest . standalone_test import SUPPORTED_TEST_TYPES <NEWLINE>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["a99c79a8d8bff2b5c72966c18f3c3607", {"code_string": "def derived_sequence(self, u, coding = False):\n    r\"\"\"Return the derived sequence of according to the return words to a factor of\"\"\"\n    D = {}\n    it = (D.setdefault(w, len(D) for w in self.return_words_iterator(u))\n    W = InfiniteWords(alphabet = NN)\n    w = W(it, datatype = 'iter')\n    if coding:\n        return w, D\n    else:\n        return w\n", "code_toks_joined": "def derived_sequence ( self , u , coding = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> D = { } <NEWLINE> it = ( D . setdefault ( w , len ( D ) for w in self . return_words_iterator ( u ) ) <NEWLINE> W = InfiniteWords ( alphabet = NN ) <NEWLINE> w = W ( it , datatype = <STRING> ) <NEWLINE> if coding : <NEWLINE> <INDENT> return w , D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return w <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["r\"\"\"Return the derived sequence of according to the return words to a factor of\"\"\"", "'iter'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e5641c503a4d934828e0323e0cf720be", {"code_string": "def form_id(self, record):\n    \"\"\" Will bind the form on a existing form with same name \"\"\"\n    form_id = self.env['medical.drug.form'].search([\n        '|',\n        ('code', '=', record['dose'].strip(),\n        ('name', '=', record['gcdf_desc'].strip().title()),\n    ],\n        limit = 1,\n    )\n    if form_id:\n        return{'form_id': form_id.id}\n", "code_toks_joined": "def form_id ( self , record ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> form_id = self . env [ <STRING> ] . search ( [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> ( <STRING> , <STRING> , record [ <STRING> ] . strip ( ) , <NEWLINE> ( <STRING> , <STRING> , record [ <STRING> ] . strip ( ) . title ( ) ) , <NEWLINE> <DEDENT> ] , <NEWLINE> <INDENT> limit = 1 , <NEWLINE> <DEDENT> ) <NEWLINE> if form_id : <NEWLINE> <INDENT> return { <STRING> : form_id . id } <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Will bind the form on a existing form with same name \"\"\"", "'medical.drug.form'", "'|'", "'code'", "'='", "'dose'", "'name'", "'='", "'gcdf_desc'", "'form_id'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["187b5b12aa8406de6c25786d2756f7ca", {"code_string": "def getSetTags():\n    lmodules = loader.loader().modules\n    setags = set()\n    for mod in lmodules:\n        try:\n            setags.add(lmodules[mod].tags)\n        except AttributeError:\n            pass\n        try:\n            setags.remove('')\n    except KeyError:\n        pass\n    return setags\n", "code_toks_joined": "def getSetTags ( ) : <NEWLINE> <INDENT> lmodules = loader . loader ( ) . modules <NEWLINE> setags = set ( ) <NEWLINE> for mod in lmodules : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> setags . add ( lmodules [ mod ] . tags ) <NEWLINE> <DEDENT> except AttributeError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> setags . remove ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except KeyError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> return setags <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''"]}, "err_obj": {"msg": "unexpected unindent"}}], ["cd0db98d94b44eb181fde934ebc3f9fd", {"code_string": "def getresponse(self):\n    class FakeResponse(object):\n        def __init__(self, (code, body, headers)):\n            self.body = six.StringIO(body)\n            self.headers = headers\n            self.status = code\n        def read(self, count = 1000000):\n            return self.body.read(count)\n        def getheaders(self):\n            return self.headers\n    return FakeResponse(self.reqs[self.last_req])\n", "code_toks_joined": "def getresponse ( self ) : <NEWLINE> <INDENT> class FakeResponse ( object ) : <NEWLINE> <INDENT> def __init__ ( self , ( code , body , headers ) ) : <NEWLINE> <INDENT> self . body = six . StringIO ( body ) <NEWLINE> self . headers = headers <NEWLINE> self . status = code <NEWLINE> <DEDENT> def read ( self , count = 1000000 ) : <NEWLINE> <INDENT> return self . body . read ( count ) <NEWLINE> <DEDENT> def getheaders ( self ) : <NEWLINE> <INDENT> return self . headers <NEWLINE> <DEDENT> <DEDENT> return FakeResponse ( self . reqs [ self . last_req ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["4a6f479edf3af9ce5bed1c8dfac7bded", {"code_string": "def close_file_descriptor_if_open(fd):\n    \"\"\" Close a file descriptor if already open.\"\"\"\n    try:\n        os.close(fd)\n    except OSError, exc:\n        if exc.errno == errno.EBADF:\n            pass\n        else:\n            error = DaemonOSEnvironmentError(\n                \"Failed to close file descriptor %(fd)d\"\n                \" (%(exc)s)\"\n                % vars())\n            raise error\n", "code_toks_joined": "def close_file_descriptor_if_open ( fd ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> os . close ( fd ) <NEWLINE> <DEDENT> except OSError , exc : <NEWLINE> <INDENT> if exc . errno == errno . EBADF : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> error = DaemonOSEnvironmentError ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> % vars ( ) ) <NEWLINE> <DEDENT> raise error <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Close a file descriptor if already open.\"\"\"", "\"Failed to close file descriptor %(fd)d\"", "\" (%(exc)s)\""]}, "err_obj": {"msg": "invalid syntax"}}], ["c217a602ff45302ac0ae7e191a9b4ac5", {"code_string": "def check(self, ** kwargs):\n    errors = super(AutoCleanField, self).check(** kwargs)\n    errors.extend(self._check_depends_on_field()))\n    return errors\n", "code_toks_joined": "def check ( self , ** kwargs ) : <NEWLINE> <INDENT> errors = super ( AutoCleanField , self ) . check ( ** kwargs ) <NEWLINE> errors . extend ( self . _check_depends_on_field ( ) ) ) <NEWLINE> return errors <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["7c471966be587ef5bb83a2bfc72e7602", {"code_string": "def NewPush(args):\n    lo, re = BigDirs()\n    for k, v in sorted(lo.items()):\n        mtime, size = v\n        v2 = re.get(k)\n        if v2 == v:\n            continue\n        say 'WRITING', k, mtime, size, v2\n        jname = J(DIR.X, BUND.X, k)\n        client.RWriteFile(BUND.X, k, ioutil.ReadFile(jname), mtime = mtime, pw = PW.X)\n", "code_toks_joined": "def NewPush ( args ) : <NEWLINE> <INDENT> lo , re = BigDirs ( ) <NEWLINE> for k , v in sorted ( lo . items ( ) ) : <NEWLINE> <INDENT> mtime , size = v <NEWLINE> v2 = re . get ( k ) <NEWLINE> if v2 == v : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> say <STRING> , k , mtime , size , v2 <NEWLINE> jname = J ( DIR . X , BUND . X , k ) <NEWLINE> client . RWriteFile ( BUND . X , k , ioutil . ReadFile ( jname ) , mtime = mtime , pw = PW . X ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'WRITING'"]}, "err_obj": {"msg": "invalid syntax"}}], ["12c661748f5eefe0c353210ac5844977", {"code_string": "class Track(models.Model):\n    title = models.CharField(max_length = 255)\n    order = models.PositiveIntegerField()\n    track_file = models.FileField(upload_to = 'tracks')\n    album = models.ForeignKey(Album)\n    artist = models.ForeignKey(Artist)\n    def get_absolute_url(self):\n    return '/tracks/%s/' % self.title\n    def player(self):\n        return \"\"\"<audio controls>\"\"\" % self.track_file.url\n    player.allow_tags = True\n    player.admin_order_field = 'track_file'\n    def __unicode__(self):\n        return self.title\n", "code_toks_joined": "class Track ( models . Model ) : <NEWLINE> <INDENT> title = models . CharField ( max_length = 255 ) <NEWLINE> order = models . PositiveIntegerField ( ) <NEWLINE> track_file = models . FileField ( upload_to = <STRING> ) <NEWLINE> album = models . ForeignKey ( Album ) <NEWLINE> artist = models . ForeignKey ( Artist ) <NEWLINE> def get_absolute_url ( self ) : <NEWLINE> return <STRING> % self . title <NEWLINE> def player ( self ) : <NEWLINE> <INDENT> return <STRING> % self . track_file . url <NEWLINE> <DEDENT> player . allow_tags = True <NEWLINE> player . admin_order_field = <STRING> <NEWLINE> def __unicode__ ( self ) : <NEWLINE> <INDENT> return self . title <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'tracks'", "'/tracks/%s/'", "\"\"\"<audio controls>\"\"\"", "'track_file'"]}, "err_obj": {"msg": "expected an indented block"}}], ["2e36daf701e0cab1c2f757ea01d69f5e", {"code_string": "def proxyarp_host_unload(cls):\n    index = 1\n    for host, _ in cls.hosts_list:\n        iface = cls.port_map[index]\n        index += 1\n        config_cmds = ('ifconfig {} 0'.format(iface), )\n        for cmd in config_cmds:\n        log_test.info('host unload command %s' % cmd)\n            os.system(cmd)\n", "code_toks_joined": "def proxyarp_host_unload ( cls ) : <NEWLINE> <INDENT> index = 1 <NEWLINE> for host , _ in cls . hosts_list : <NEWLINE> <INDENT> iface = cls . port_map [ index ] <NEWLINE> index += 1 <NEWLINE> config_cmds = ( <STRING> . format ( iface ) , ) <NEWLINE> for cmd in config_cmds : <NEWLINE> log_test . info ( <STRING> % cmd ) <NEWLINE> <INDENT> os . system ( cmd ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'ifconfig {} 0'", "'host unload command %s'"]}, "err_obj": {"msg": "expected an indented block"}}], ["d57a0db5d9d0f206fd91668f4604b0d7", {"code_string": "def _get_info_by_testcase(self):\n    \"\"\"Organizes test results by TestCase module. This information is\"\"\"\n    tests_by_testcase = {}\n    for tests in(self.successes, self.failures, self.errors,\n        self.skipped):\n        for test_info in tests:\n        if isinstance(test_info, tuple):\n        test_info = test_info[0]\n        testcase_name = test_info.test_name\n        if testcase_name not in tests_by_testcase:\n        tests_by_testcase[testcase_name] = []\n        tests_by_testcase[testcase_name].append(test_info)\n    return tests_by_testcase\n", "code_toks_joined": "def _get_info_by_testcase ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> tests_by_testcase = { } <NEWLINE> for tests in ( self . successes , self . failures , self . errors , <NEWLINE> <INDENT> self . skipped ) : <NEWLINE> for test_info in tests : <NEWLINE> if isinstance ( test_info , tuple ) : <NEWLINE> test_info = test_info [ 0 ] <NEWLINE> testcase_name = test_info . test_name <NEWLINE> if testcase_name not in tests_by_testcase : <NEWLINE> tests_by_testcase [ testcase_name ] = [ ] <NEWLINE> tests_by_testcase [ testcase_name ] . append ( test_info ) <NEWLINE> <DEDENT> return tests_by_testcase <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Organizes test results by TestCase module. This information is\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["9b32cc90d3b4d924f1c586d29efc4589", {"code_string": "class Translation(Transform):\n    def __init__(self, dx, dy):\n        Transform.__init__(self)\n            self.trans_matrix = [[1, 0, 0], [0, 1, 0], [dx, dy, 1]]\n", "code_toks_joined": "class Translation ( Transform ) : <NEWLINE> <INDENT> def __init__ ( self , dx , dy ) : <NEWLINE> <INDENT> Transform . __init__ ( self ) <NEWLINE> <INDENT> self . trans_matrix = [ [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] , [ dx , dy , 1 ] ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["5d5bc6c8f186995c72de7e094d9c34ad", {"code_string": "def runAction():\n    form = cgi.FieldStorage()\n    if(form.has_key(\"answer\") and form.has_key(\"operanda\") and form.has_key(\"operandb\")):\n        generate_form(form[\"operanda\"].value, form[\"operandb\"].value, form[\"answer\"].value)\n    else:\n        print(formatXml(\"Error\", \"params we got: \" + str(form.list).strip('[]'),\n            \"List Length: \" + str(form.__len__()));\n", "code_toks_joined": "def runAction ( ) : <NEWLINE> <INDENT> form = cgi . FieldStorage ( ) <NEWLINE> if ( form . has_key ( <STRING> ) and form . has_key ( <STRING> ) and form . has_key ( <STRING> ) ) : <NEWLINE> <INDENT> generate_form ( form [ <STRING> ] . value , form [ <STRING> ] . value , form [ <STRING> ] . value ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( formatXml ( <STRING> , <STRING> + str ( form . list ) . strip ( <STRING> ) , <NEWLINE> <INDENT> <STRING> + str ( form . __len__ ( ) ) ) ; <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"answer\"", "\"operanda\"", "\"operandb\"", "\"operanda\"", "\"operandb\"", "\"answer\"", "\"Error\"", "\"params we got: \"", "'[]'", "\"List Length: \""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["cc2f7d3583b14df3e27225f4c63306d5", {"code_string": "class RequestMockBuilder(object):\n    \"\"\"A simple mock of HttpRequest\"\"\"\n    def __init__(self, responses):\n        \"\"\"Constructor for RequestMockBuilder\"\"\"\n        self.responses = responses\n    def __call__(self, http, postproc, uri, method = 'GET', body = None,\n        headers = None, methodId = None):\n        \"\"\"Implements the callable interface that discovery.build() expects\"\"\"\n        if methodId in self.responses:\n        resp, content = self.responses[methodId]\n        return HttpRequestMock(resp, content, postproc)\n        else:\n        model = JsonModel(False)\n        return HttpRequestMock(None, '{}', model.response)\n", "code_toks_joined": "class RequestMockBuilder ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , responses ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . responses = responses <NEWLINE> <DEDENT> def __call__ ( self , http , postproc , uri , method = <STRING> , body = None , <NEWLINE> <INDENT> headers = None , methodId = None ) : <NEWLINE> <STRING> <NEWLINE> if methodId in self . responses : <NEWLINE> resp , content = self . responses [ methodId ] <NEWLINE> return HttpRequestMock ( resp , content , postproc ) <NEWLINE> else : <NEWLINE> model = JsonModel ( False ) <NEWLINE> return HttpRequestMock ( None , <STRING> , model . response ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"A simple mock of HttpRequest\"\"\"", "\"\"\"Constructor for RequestMockBuilder\"\"\"", "'GET'", "\"\"\"Implements the callable interface that discovery.build() expects\"\"\"", "'{}'"]}, "err_obj": {"msg": "expected an indented block"}}], ["176759d9e1eb680650833605e8146cab", {"code_string": "def getusers(request):\n    \"\"\"Return online users\"\"\"\n    try:\n    online_users = get_users()\n    except Exception:\n    online_users = None\n    data = json.dumps(online_users)\n    response = HttpResponse()\n    response['Content-Type'] = \"text/javascript\"\n    response.write(data)\n    return response\n", "code_toks_joined": "def getusers ( request ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> online_users = get_users ( ) <NEWLINE> except Exception : <NEWLINE> online_users = None <NEWLINE> data = json . dumps ( online_users ) <NEWLINE> response = HttpResponse ( ) <NEWLINE> response [ <STRING> ] = <STRING> <NEWLINE> response . write ( data ) <NEWLINE> return response <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return online users\"\"\"", "'Content-Type'", "\"text/javascript\""]}, "err_obj": {"msg": "expected an indented block"}}], ["9c2302f1a76de8ec9ce0b0222c84ac3e", {"code_string": "def get(self, qname, qtype):\n    print(\"get cache %s number\" % len(self.cache))\n        value = self.cache.pop(qname + \"_\" + qtype)\n        self.cache[qname + \"_\" + qtype] = value\n        return self.cache[qname + \"_\" + qtype]\n", "code_toks_joined": "def get ( self , qname , qtype ) : <NEWLINE> <INDENT> print ( <STRING> % len ( self . cache ) ) <NEWLINE> <INDENT> value = self . cache . pop ( qname + <STRING> + qtype ) <NEWLINE> self . cache [ qname + <STRING> + qtype ] = value <NEWLINE> return self . cache [ qname + <STRING> + qtype ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"get cache %s number\"", "\"_\"", "\"_\"", "\"_\""]}, "err_obj": {"msg": "unexpected indent"}}], ["7fdc9ae596518a89294ff9939a629e78", {"code_string": "def finalize(self, result):\n    self.html.append('<div>')\n    self.html.append(\"Ran %d test%s\" %\n        (result.testsRun, result.testsRun != 1 and \"s\"\n", "code_toks_joined": "def finalize ( self , result ) : <NEWLINE> <INDENT> self . html . append ( <STRING> ) <NEWLINE> self . html . append ( <STRING> % <NEWLINE> <INDENT> ( result . testsRun , result . testsRun != 1 and <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'<div>'", "\"Ran %d test%s\"", "\"s\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c5deffdfa252186f1d9734655c94aa48", {"code_string": "class PositionData:\n    def __init__(self, position_str):\n    self.chr, interval = string.split(position_str, '__')\n    self.start, self.end = string.split(interval, '-')\n    def Chr(self): return self.chr\n    def Start(self): return int(self.start)\n    def End(self): return int(self.end)\n", "code_toks_joined": "class PositionData : <NEWLINE> <INDENT> def __init__ ( self , position_str ) : <NEWLINE> self . chr , interval = string . split ( position_str , <STRING> ) <NEWLINE> self . start , self . end = string . split ( interval , <STRING> ) <NEWLINE> def Chr ( self ) : return self . chr <NEWLINE> def Start ( self ) : return int ( self . start ) <NEWLINE> def End ( self ) : return int ( self . end ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'__'", "'-'"]}, "err_obj": {"msg": "expected an indented block"}}], ["748ce9626beb6d0e301b28de49b0ee58", {"code_string": "def localInit(self):\n    ControlledSer.localInit(self)\n    (self._just_born, self._just_dead) = (True, False)\n    self.__start = man.now\n    if self not in Bullet.__IN_FLIGHT:\n    Bullet.__IN_FLIGHT.add(self)\n    if(len(self.__class__.__IN_FLIGHT) % 25 == 0):\n    print('num bullets (more): ' + str(len(self.__class__.__IN_FLIGHT)))\n", "code_toks_joined": "def localInit ( self ) : <NEWLINE> <INDENT> ControlledSer . localInit ( self ) <NEWLINE> ( self . _just_born , self . _just_dead ) = ( True , False ) <NEWLINE> self . __start = man . now <NEWLINE> if self not in Bullet . __IN_FLIGHT : <NEWLINE> Bullet . __IN_FLIGHT . add ( self ) <NEWLINE> if ( len ( self . __class__ . __IN_FLIGHT ) % 25 == 0 ) : <NEWLINE> print ( <STRING> + str ( len ( self . __class__ . __IN_FLIGHT ) ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'num bullets (more): '"]}, "err_obj": {"msg": "expected an indented block"}}], ["fa1ecbad15537c12e33bad7b0c9c5f1a", {"code_string": "def __fetch_from_log(self):\n    logger.info(\"Fetching commits: '%s' git repository from log file %s\"\n        self.uri, self.gitpath)\n    return self.parse_git_log_from_file(self.gitpath)\n", "code_toks_joined": "def __fetch_from_log ( self ) : <NEWLINE> <INDENT> logger . info ( <STRING> <NEWLINE> <INDENT> self . uri , self . gitpath ) <NEWLINE> <DEDENT> return self . parse_git_log_from_file ( self . gitpath ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Fetching commits: '%s' git repository from log file %s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["ea5cac4c0de9465eb26ed998035b4937", {"code_string": "def rebalance(self, * args):\n    clusters = self.cluster_spec.clusters\n    initial_nodes = self.test_config.cluster.initial_nodes\n    failed_nodes = self.rebalance_settings.failed_nodes\n    for(_, servers), initial_nodes in zip(clusters,\n        initial_nodes):\n        master = servers[0]\n        failed = servers[initial_nodes - failed_nodes: initial_nodes]\n        for node in failed:\n        self.rest.graceful_fail_over(master, node)\n        self.monitor_progress(master)\n", "code_toks_joined": "def rebalance ( self , * args ) : <NEWLINE> <INDENT> clusters = self . cluster_spec . clusters <NEWLINE> initial_nodes = self . test_config . cluster . initial_nodes <NEWLINE> failed_nodes = self . rebalance_settings . failed_nodes <NEWLINE> for ( _ , servers ) , initial_nodes in zip ( clusters , <NEWLINE> <INDENT> initial_nodes ) : <NEWLINE> master = servers [ 0 ] <NEWLINE> failed = servers [ initial_nodes - failed_nodes : initial_nodes ] <NEWLINE> for node in failed : <NEWLINE> self . rest . graceful_fail_over ( master , node ) <NEWLINE> self . monitor_progress ( master ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["d5e3ac7dd918bf2b9b300fbd17a6f0f3", {"code_string": "def getOutlineCrvFromSun(geometry sunVector):\n    planeFromSun = rc.Geometry.Plane(rc.Geometry.Point3d.Origin, sunVector)\n    outlineCrvFromSun = []\n    polylines = geometry.GetOutlines(planeFromSun)\n    [outlineCrvFromSun.append(pl.ToNurbsCurve()) for pl in polylines]\n    return outlineCrvFromSun\n", "code_toks_joined": "def getOutlineCrvFromSun ( geometry sunVector ) : <NEWLINE> <INDENT> planeFromSun = rc . Geometry . Plane ( rc . Geometry . Point3d . Origin , sunVector ) <NEWLINE> outlineCrvFromSun = [ ] <NEWLINE> polylines = geometry . GetOutlines ( planeFromSun ) <NEWLINE> [ outlineCrvFromSun . append ( pl . ToNurbsCurve ( ) ) for pl in polylines ] <NEWLINE> return outlineCrvFromSun <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["2fe0fa1442704dd927944051584e2e3a", {"code_string": "def exportReport(reportFile, lines):\n    f = open(reportFile, \"w\")\n    for line in lines:\n    f.write(\"%s\\n\" %(line))\n    f.close()\n", "code_toks_joined": "def exportReport ( reportFile , lines ) : <NEWLINE> <INDENT> f = open ( reportFile , <STRING> ) <NEWLINE> for line in lines : <NEWLINE> f . write ( <STRING> % ( line ) ) <NEWLINE> f . close ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"w\"", "\"%s\\n\""]}, "err_obj": {"msg": "expected an indented block"}}], ["3e19ac326d717bd9bbab62d190e90b59", {"code_string": "def usage():\n    print(\"Join co-occurrence counts with total counts for each field\")\n        print(\"Can then be used in R via phyper()\")\n        print(sys.argv[0], \" <coc_file> <field1_counts> <field2_counts> <total> [-r]\")\n        print(\"<coc_file>: Co-occurrence file with format field1|field2|coc (or coc|field1|field2 if -r is specified)\")\n        print(\"<field1_counts>: File with counts from the field1 with format field1|count1\")\n        print(\"<field2_counts>: File with coutns from field 2 with format field2|count2\")\n        print(\"<total>: Total number of pubmed articles considered\")\n    print(\"-r : reversed input format (coc|field1|field2)\")\n        print(\"\\nOutput is  field1|field2|coc|count1|count2|Total-count2\")\n    print(\"coc = x = white balls drawn from urn\")\n    print(\"count1 = k = number of balls drawn from the urn\")\n    print(\"count2 = m = number of white balls\")\n    print(\"Total-count2 = n = number of black balls\")\n    print(\"Assumes that field1_counts and field2_counts can fit in python dictionaries in memory\")\n", "code_toks_joined": "def usage ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( sys . argv [ 0 ] , <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Join co-occurrence counts with total counts for each field\"", "\"Can then be used in R via phyper()\"", "\" <coc_file> <field1_counts> <field2_counts> <total> [-r]\"", "\"<coc_file>: Co-occurrence file with format field1|field2|coc (or coc|field1|field2 if -r is specified)\"", "\"<field1_counts>: File with counts from the field1 with format field1|count1\"", "\"<field2_counts>: File with coutns from field 2 with format field2|count2\"", "\"<total>: Total number of pubmed articles considered\"", "\"-r : reversed input format (coc|field1|field2)\"", "\"\\nOutput is  field1|field2|coc|count1|count2|Total-count2\"", "\"coc = x = white balls drawn from urn\"", "\"count1 = k = number of balls drawn from the urn\"", "\"count2 = m = number of white balls\"", "\"Total-count2 = n = number of black balls\"", "\"Assumes that field1_counts and field2_counts can fit in python dictionaries in memory\""]}, "err_obj": {"msg": "unexpected indent"}}], ["3bfaaec3328c1515332b5f82b883fb65", {"code_string": "def set_type(self, bounds_type):\n    if not bounds_type in(Bounds.TYPE_RELATIVE_MARGIN,\n        Bounds.TYPE_FIXED_MARGIN, Bounds.TYPE_CUSTOM):\n        raise ValueError, \"failed to create an instance of \" + \"pycam.Toolpath.Bounds due to an invalid value of \" + \"'bounds_type': %s\" % repr(bounds_type)\n    else:\n        self.bounds_type = bounds_type\n", "code_toks_joined": "def set_type ( self , bounds_type ) : <NEWLINE> <INDENT> if not bounds_type in ( Bounds . TYPE_RELATIVE_MARGIN , <NEWLINE> <INDENT> Bounds . TYPE_FIXED_MARGIN , Bounds . TYPE_CUSTOM ) : <NEWLINE> raise ValueError , <STRING> + <STRING> + <STRING> % repr ( bounds_type ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . bounds_type = bounds_type <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"failed to create an instance of \"", "\"pycam.Toolpath.Bounds due to an invalid value of \"", "\"'bounds_type': %s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["78350327c15bbbfaacd5a28a4d8cefb9", {"code_string": "def print_cache(self):\n    \"\"\"Outputs the contents of the cache to the command line.\"\"\"\n    print(\"\\nCache Contents:\")\n    for block in self.cache:\n        print(\"[ \",\n        for word in block:\n            if word == - 1 or word ==[]:\n                output = '--'\n            else:\n                output = word\n            print(\"%s \" %(str(output)), )\n        print(\"]\")\n", "code_toks_joined": "def print_cache ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> ) <NEWLINE> for block in self . cache : <NEWLINE> <INDENT> print ( <STRING> , <NEWLINE> for word in block : <NEWLINE> <INDENT> if word == - 1 or word == [ ] : <NEWLINE> <INDENT> output = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> output = word <NEWLINE> <DEDENT> print ( <STRING> % ( str ( output ) ) , ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Outputs the contents of the cache to the command line.\"\"\"", "\"\\nCache Contents:\"", "\"[ \"", "'--'", "\"%s \"", "\"]\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["3199cb1f5d5e32ea6839de1fcd3ec0fb", {"code_string": "from bs4 import BeautifulSoup\nfrom datetime import date\nimport os.path as path\nimport sys\n_SRC = path.join(path.dirname(path.abspath(__file__)), \"..\", \"..\")\n_COMPILE_JS = path.join(\n    _SRC, \"third_party\", \"closure_compiler\", \"compile_js2.gypi\")\n_POLYMERS = [\"polymer%s.html\" % p for p in \"\", \"-mini\", \"-micro\"]\n_COMPILED_RESOURCES_TEMPLATE = \"\"\"{'targets': [\"\"\".strip()\n", "code_toks_joined": "from bs4 import BeautifulSoup <NEWLINE> from datetime import date <NEWLINE> import os . path as path <NEWLINE> import sys <NEWLINE> _SRC = path . join ( path . dirname ( path . abspath ( __file__ ) ) , <STRING> , <STRING> ) <NEWLINE> _COMPILE_JS = path . join ( <NEWLINE> <INDENT> _SRC , <STRING> , <STRING> , <STRING> ) <NEWLINE> <DEDENT> _POLYMERS = [ <STRING> % p for p in <STRING> , <STRING> , <STRING> ] <NEWLINE> _COMPILED_RESOURCES_TEMPLATE = <STRING> . strip ( ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"..\"", "\"..\"", "\"third_party\"", "\"closure_compiler\"", "\"compile_js2.gypi\"", "\"polymer%s.html\"", "\"\"", "\"-mini\"", "\"-micro\"", "\"\"\"{'targets': [\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["3715c698e1b3d225e2803f925c22228a", {"code_string": "def done_configuring():\n    \"\"\"Check for new config values for auto start\"\"\"\n    global autoStartTimer\n    print(\"[IPTVcreate] Done configuring\")\n    if autoStartTimer is not None:\n    autoStartTimer.update()\n    return\n", "code_toks_joined": "def done_configuring ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> global autoStartTimer <NEWLINE> print ( <STRING> ) <NEWLINE> if autoStartTimer is not None : <NEWLINE> autoStartTimer . update ( ) <NEWLINE> return <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Check for new config values for auto start\"\"\"", "\"[IPTVcreate] Done configuring\""]}, "err_obj": {"msg": "expected an indented block"}}], ["09da86ffae6043f3a22f12d4de6cd02f", {"code_string": "def test_get_app_workdir(self):\n    workdir = utils.get_app_working_dir()\n    self.assertTrue(os.access(os.path.dirname(workdir), os.W_OK)))\n", "code_toks_joined": "def test_get_app_workdir ( self ) : <NEWLINE> <INDENT> workdir = utils . get_app_working_dir ( ) <NEWLINE> self . assertTrue ( os . access ( os . path . dirname ( workdir ) , os . W_OK ) ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["202fe93b3fb757a5516c9247f0002f09", {"code_string": "def lightsOn():\n    if lights != 'on':\n    global lights\n        os.system(\"/var/www/rfoutlet/codesend 5534979\")\n        lights = 'on'\n        pickle.dump(lights, open(\"status.p\", \"wb\"))\n        os.system(\"echo \" \"\"\"696969\"\"\" \" > /dev/rfcomm1\")\n", "code_toks_joined": "def lightsOn ( ) : <NEWLINE> <INDENT> if lights != <STRING> : <NEWLINE> global lights <NEWLINE> <INDENT> os . system ( <STRING> ) <NEWLINE> lights = <STRING> <NEWLINE> pickle . dump ( lights , open ( <STRING> , <STRING> ) ) <NEWLINE> os . system ( <STRING> <STRING> <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'on'", "\"/var/www/rfoutlet/codesend 5534979\"", "'on'", "\"status.p\"", "\"wb\"", "\"echo \"", "\"\"\"696969\"\"\"", "\" > /dev/rfcomm1\""]}, "err_obj": {"msg": "expected an indented block"}}], ["34c0ac1043b33ce8180710d269e39c24", {"code_string": "def getParseCriteriaForUrl(self, urlid):\n    '''find the search criterion associated with a url (there may be many searches associated w/ a url)'''\n    criteria = []\n    try:\n    logging.debug(\"getting searches for url %i\" % urlid)\n        UrlSearchObjs = self.getSearchesforUrl(urlid)\n        logging.debug(\"succeeded\")\n        for s in UrlSearchObjs:\n        logging.debug(\"getting parse criteria for search %i\" % s.searchid)\n            criteria.append(self.getParseCriteriaForSearch(s.searchid))\n            logging.debug(\"succeeded.\")\n        return criteria\n    except: raise\n", "code_toks_joined": "def getParseCriteriaForUrl ( self , urlid ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> criteria = [ ] <NEWLINE> try : <NEWLINE> logging . debug ( <STRING> % urlid ) <NEWLINE> <INDENT> UrlSearchObjs = self . getSearchesforUrl ( urlid ) <NEWLINE> logging . debug ( <STRING> ) <NEWLINE> for s in UrlSearchObjs : <NEWLINE> logging . debug ( <STRING> % s . searchid ) <NEWLINE> <INDENT> criteria . append ( self . getParseCriteriaForSearch ( s . searchid ) ) <NEWLINE> logging . debug ( <STRING> ) <NEWLINE> <DEDENT> return criteria <NEWLINE> <DEDENT> except : raise <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''find the search criterion associated with a url (there may be many searches associated w/ a url)'''", "\"getting searches for url %i\"", "\"succeeded\"", "\"getting parse criteria for search %i\"", "\"succeeded.\""]}, "err_obj": {"msg": "expected an indented block"}}], ["3228aaf987b714cb54dd97c5d7a0a780", {"code_string": "def insistJavaClass(c):\n    jc = getJavaClass(c)\n    if jc is None and isinstance(c, StringType):\n        jc = getJavaClass(\"java.lang.\" + c)\n    if jc is None:\n        raise ValueError, \"can not find class: \" + c\n    return jc\n", "code_toks_joined": "def insistJavaClass ( c ) : <NEWLINE> <INDENT> jc = getJavaClass ( c ) <NEWLINE> if jc is None and isinstance ( c , StringType ) : <NEWLINE> <INDENT> jc = getJavaClass ( <STRING> + c ) <NEWLINE> <DEDENT> if jc is None : <NEWLINE> <INDENT> raise ValueError , <STRING> + c <NEWLINE> <DEDENT> return jc <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"java.lang.\"", "\"can not find class: \""]}, "err_obj": {"msg": "invalid syntax"}}], ["fc31a02c2956e8476d9e0d29f7b910fb", {"code_string": "def getStoredAlarm(self):\n    alarmValue = ''\n    if os.path.isfile(AlarmFile):\n        try:\n            alarmValue = self.execCommand(\"cat \" + AlarmFile)\n        except ValueError:\n            alarmValue = \"0:7:00\"\n    else:\n        log.message(\"Error reading \" + AlarmFile, log.ERROR)\n    return alarmValue\n        def storeAlarm(self, alarmString):\n    self.execCommand(\"echo \" + alarmString + \" > \" + AlarmFile)\n    return\n", "code_toks_joined": "def getStoredAlarm ( self ) : <NEWLINE> <INDENT> alarmValue = <STRING> <NEWLINE> if os . path . isfile ( AlarmFile ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> alarmValue = self . execCommand ( <STRING> + AlarmFile ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> alarmValue = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> log . message ( <STRING> + AlarmFile , log . ERROR ) <NEWLINE> <DEDENT> return alarmValue <NEWLINE> <INDENT> def storeAlarm ( self , alarmString ) : <NEWLINE> <DEDENT> self . execCommand ( <STRING> + alarmString + <STRING> + AlarmFile ) <NEWLINE> return <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "\"cat \"", "\"0:7:00\"", "\"Error reading \"", "\"echo \"", "\" > \""]}, "err_obj": {"msg": "unexpected indent"}}], ["b4b7c1c9aaa3ed7ff48dae0ddb313962", {"code_string": "class SplashFormRequest(SplashRequest, FormRequest):\n    \"\"\"Use SplashFormRequest if you want to make a FormRequest via splash.\"\"\"\n    def __init__(self, url = None, callback = None, method = None, formdata = None,\n        body = None, ** kwargs):\n        if formdata:\n        FormRequest.__init__(\n        self, url = url, method = method, formdata = formdata)\n        url, method, body = self.url, self.method, self.body\n        SplashRequest.__init__(\n        self, url = url, callback = callback, method = method, body = body,\n        ** kwargs)\n", "code_toks_joined": "class SplashFormRequest ( SplashRequest , FormRequest ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , url = None , callback = None , method = None , formdata = None , <NEWLINE> <INDENT> body = None , ** kwargs ) : <NEWLINE> if formdata : <NEWLINE> FormRequest . __init__ ( <NEWLINE> self , url = url , method = method , formdata = formdata ) <NEWLINE> url , method , body = self . url , self . method , self . body <NEWLINE> SplashRequest . __init__ ( <NEWLINE> self , url = url , callback = callback , method = method , body = body , <NEWLINE> ** kwargs ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Use SplashFormRequest if you want to make a FormRequest via splash.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["0977a0fb32d6ab24bed52cedf60dc0b4", {"code_string": "def remove_registry_conf():\n    try:\n        with _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE,\n            WINDOWS_REG_PATH, 0, _winreg.KEY_WRITE) as reg_key:\n            for attribute in config_attributes:\n            try:\n            _winreg.DeleteValue(reg_key, attribute)\n            except Exception as e:\n            log.error(\"Failed to delete value %s %s\", attribute, str(e))\n            pass\n    except Exception:\n        pass\n", "code_toks_joined": "def remove_registry_conf ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> with _winreg . OpenKey ( _winreg . HKEY_LOCAL_MACHINE , <NEWLINE> <INDENT> WINDOWS_REG_PATH , 0 , _winreg . KEY_WRITE ) as reg_key : <NEWLINE> for attribute in config_attributes : <NEWLINE> try : <NEWLINE> _winreg . DeleteValue ( reg_key , attribute ) <NEWLINE> except Exception as e : <NEWLINE> log . error ( <STRING> , attribute , str ( e ) ) <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT> except Exception : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Failed to delete value %s %s\""]}, "err_obj": {"msg": "expected an indented block"}}], ["15faf1c1f29fb17af039000190d7ddbd", {"code_string": "def get_minimum_path_nii(fname):\n    from msct_image import Image\n    data = Image(fname)\n    vesselness_data = data.data\n    raw_orient = data.change_orientation()\n    result, J1, J2 = get_minimum_path(data.data invert = 1)\n    data.data = result\n    data.change_orientation(raw_orient)\n    data.file_name += '_minimalpath'\n    data.save()\n", "code_toks_joined": "def get_minimum_path_nii ( fname ) : <NEWLINE> <INDENT> from msct_image import Image <NEWLINE> data = Image ( fname ) <NEWLINE> vesselness_data = data . data <NEWLINE> raw_orient = data . change_orientation ( ) <NEWLINE> result , J1 , J2 = get_minimum_path ( data . data invert = 1 ) <NEWLINE> data . data = result <NEWLINE> data . change_orientation ( raw_orient ) <NEWLINE> data . file_name += <STRING> <NEWLINE> data . save ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'_minimalpath'"]}, "err_obj": {"msg": "invalid syntax"}}], ["2a2bf86a8c5124808785724e598b24a4", {"code_string": "def _auth_cb(self, creds, (passwordcb, passwordcreds)):\n    for cred in creds:\n        if cred[0] not in passwordcreds:\n            raise RuntimeError(\"Unknown cred type '%s', expected only \"\n                \"%s\" %(cred[0], passwordcreds))\n    return passwordcb(creds)\n", "code_toks_joined": "def _auth_cb ( self , creds , ( passwordcb , passwordcreds ) ) : <NEWLINE> <INDENT> for cred in creds : <NEWLINE> <INDENT> if cred [ 0 ] not in passwordcreds : <NEWLINE> <INDENT> raise RuntimeError ( <STRING> <NEWLINE> <INDENT> <STRING> % ( cred [ 0 ] , passwordcreds ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return passwordcb ( creds ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Unknown cred type '%s', expected only \"", "\"%s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["282c9c62fc66614e993cc87678626d4b", {"code_string": "def isVisible(self, face):\n    \"returns True if the given face points in the view direction\"\n    normal = face[0].normalAt(0, 0)\n    if DEBUG: print \"checking face normal \", normal, \" against \", self.wp.axis, \": \", math.degrees(normal.getAngle(self.wp.axis))\n    if normal.getAngle(self.wp.axis) < math.pi / 2:\n        return True\n    return False\n", "code_toks_joined": "def isVisible ( self , face ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> normal = face [ 0 ] . normalAt ( 0 , 0 ) <NEWLINE> if DEBUG : print <STRING> , normal , <STRING> , self . wp . axis , <STRING> , math . degrees ( normal . getAngle ( self . wp . axis ) ) <NEWLINE> if normal . getAngle ( self . wp . axis ) < math . pi / 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"returns True if the given face points in the view direction\"", "\"checking face normal \"", "\" against \"", "\": \""]}, "err_obj": {"msg": "invalid syntax"}}], ["e66d34f5e2fb0813e669336aceef31c6", {"code_string": "def testRawError(self):\n    with DoStubHttp(400, 'application/json',\n        '{\"error\": {\"code\": 400, \"message\": \"bar\"}}'):\n        with self.assertRaises(ee.ee_exception.EEException) as cm:\n        ee.data.send_('/foo', {}, opt_raw = True)\n        self.assertEqual(u'Server returned HTTP code: 400', cm.exception.message)\n", "code_toks_joined": "def testRawError ( self ) : <NEWLINE> <INDENT> with DoStubHttp ( 400 , <STRING> , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> with self . assertRaises ( ee . ee_exception . EEException ) as cm : <NEWLINE> ee . data . send_ ( <STRING> , { } , opt_raw = True ) <NEWLINE> self . assertEqual ( <STRING> , cm . exception . message ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'application/json'", "'{\"error\": {\"code\": 400, \"message\": \"bar\"}}'", "'/foo'", "u'Server returned HTTP code: 400'"]}, "err_obj": {"msg": "expected an indented block"}}], ["a9f8b4f32135c352b51174a464385d0d", {"code_string": "import wiringpi\nimport time\nPIN = 18\nwiringpi.wiringPiSetupGpio()\nwiringpi.pinMode(PIN, wiringpi.INPUT)\nwiringpi.pullUpDnControl(PIN, wiringpi.PUD_UP)\npulses = 0\namount = 0\nwhile 1:\n    if wiringpi.digitalRead(PIN) == 0:\n        pulses = pulses + 1\n        if pulses == 4:\n        pulses = 0\n        amount = amount + 1\n        print('Total Amount: ' + str(amount))\n    time.sleep(.01)\n", "code_toks_joined": "import wiringpi <NEWLINE> import time <NEWLINE> PIN = 18 <NEWLINE> wiringpi . wiringPiSetupGpio ( ) <NEWLINE> wiringpi . pinMode ( PIN , wiringpi . INPUT ) <NEWLINE> wiringpi . pullUpDnControl ( PIN , wiringpi . PUD_UP ) <NEWLINE> pulses = 0 <NEWLINE> amount = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if wiringpi . digitalRead ( PIN ) == 0 : <NEWLINE> <INDENT> pulses = pulses + 1 <NEWLINE> if pulses == 4 : <NEWLINE> pulses = 0 <NEWLINE> amount = amount + 1 <NEWLINE> print ( <STRING> + str ( amount ) ) <NEWLINE> <DEDENT> time . sleep ( .01 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Total Amount: '"]}, "err_obj": {"msg": "expected an indented block"}}], ["d4d6bf67f95b371e61a5265757cbfc2d", {"code_string": "class OracleNoSQLTestCase_Neo4J_where(unittest.TestCase):\n    def runTest(self):\n        results = Neo4j on connOracleRDFNoSQL \"MATCH(a:emp) WHERE a.deptno = 20 RETURN a.ename\"\n        assert sorted(results) ==[('ADAMS', ), ('FORD', ), ('JONES', ), ('SCOTT', ), ('SMITH', ), ('ename', )], 'OracleNoSQLTestCase_Neo4J_where query failed'\n", "code_toks_joined": "class OracleNoSQLTestCase_Neo4J_where ( unittest . TestCase ) : <NEWLINE> <INDENT> def runTest ( self ) : <NEWLINE> <INDENT> results = Neo4j on connOracleRDFNoSQL <STRING> <NEWLINE> assert sorted ( results ) == [ ( <STRING> , ) , ( <STRING> , ) , ( <STRING> , ) , ( <STRING> , ) , ( <STRING> , ) , ( <STRING> , ) ] , <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"MATCH(a:emp) WHERE a.deptno = 20 RETURN a.ename\"", "'ADAMS'", "'FORD'", "'JONES'", "'SCOTT'", "'SMITH'", "'ename'", "'OracleNoSQLTestCase_Neo4J_where query failed'"]}, "err_obj": {"msg": "invalid syntax"}}], ["1acadd3999c2bc19bf48c4e96f4ba0df", {"code_string": "def finalize_options(self):\n    install.finalize_options(self)\n    for optname in('root_dir', 'config_dir', 'cache_dir', 'sock_dir',\n        'srv_root_dir', 'base_file_roots_dir',\n        'base_pillar_roots_dir', 'base_master_roots_dir',\n        'logs_dir', 'pidfile_dir'):\n        optvalue = getattr(self, 'salt_{0}'.format(optname))\n        if not optvalue:\n        raise RuntimeError(\n        'The value of --salt-{0} needs a proper path value'.format(\n        optname.replace('_', '-')\n        )\n        )\n        setattr(self.distribution, 'salt_{0}'.format(optname), optvalue)\n", "code_toks_joined": "def finalize_options ( self ) : <NEWLINE> <INDENT> install . finalize_options ( self ) <NEWLINE> for optname in ( <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> ) : <NEWLINE> optvalue = getattr ( self , <STRING> . format ( optname ) ) <NEWLINE> if not optvalue : <NEWLINE> raise RuntimeError ( <NEWLINE> <STRING> . format ( <NEWLINE> optname . replace ( <STRING> , <STRING> ) <NEWLINE> ) <NEWLINE> ) <NEWLINE> setattr ( self . distribution , <STRING> . format ( optname ) , optvalue ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'root_dir'", "'config_dir'", "'cache_dir'", "'sock_dir'", "'srv_root_dir'", "'base_file_roots_dir'", "'base_pillar_roots_dir'", "'base_master_roots_dir'", "'logs_dir'", "'pidfile_dir'", "'salt_{0}'", "'The value of --salt-{0} needs a proper path value'", "'_'", "'-'", "'salt_{0}'"]}, "err_obj": {"msg": "expected an indented block"}}], ["31a13ab212388ca873f9a62918a414c7", {"code_string": "def __isKtServerOnTakenPort(dbElem, killSwitchPath, pretest = False):\n    if __isKtServerReorganizing(dbElem) or __isKtServerRunning(dbElem,\n        killSwitchPath):\n        logPath = __getLogPath(dbElem)\n        pidList = __scrapePids([logPath])\n        if pretest is False:\n        thresh = 1\n        else:\n        thresh = 0\n        if len(pidList) > thresh:\n        raise RuntimeError(\"Ktserver already found running with log %s\" %\n        logPath)\n        pidList = __scrapePids(['port %d' % dbElem.getDbPort()])\n        if len(pidList) > thresh:\n        return True\n    return False\n", "code_toks_joined": "def __isKtServerOnTakenPort ( dbElem , killSwitchPath , pretest = False ) : <NEWLINE> <INDENT> if __isKtServerReorganizing ( dbElem ) or __isKtServerRunning ( dbElem , <NEWLINE> <INDENT> killSwitchPath ) : <NEWLINE> logPath = __getLogPath ( dbElem ) <NEWLINE> pidList = __scrapePids ( [ logPath ] ) <NEWLINE> if pretest is False : <NEWLINE> thresh = 1 <NEWLINE> else : <NEWLINE> thresh = 0 <NEWLINE> if len ( pidList ) > thresh : <NEWLINE> raise RuntimeError ( <STRING> % <NEWLINE> logPath ) <NEWLINE> pidList = __scrapePids ( [ <STRING> % dbElem . getDbPort ( ) ] ) <NEWLINE> if len ( pidList ) > thresh : <NEWLINE> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Ktserver already found running with log %s\"", "'port %d'"]}, "err_obj": {"msg": "expected an indented block"}}], ["847e7684f05a709f466dc16b49b7bd04", {"code_string": "def set_temperature(self, temperature):\n    \"\"\"Set new target temperature.\"\"\"\n    for value in self._node.get_values(\n        class_id = COMMAND_CLASS_THERMOSTAT_SETPOINT).values():\n        if value.command_class != 67:\n        continue\n        if self._zxt_120:\n        self._target_temperature = temperature\n        if ZXT_120_SET_TEMP.get(self._current_operation) != value.index:\n            continue\n        value.data = int(round(temperature, 0))\n        else:\n        value.data = int(temperature)\n", "code_toks_joined": "def set_temperature ( self , temperature ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for value in self . _node . get_values ( <NEWLINE> <INDENT> class_id = COMMAND_CLASS_THERMOSTAT_SETPOINT ) . values ( ) : <NEWLINE> if value . command_class != 67 : <NEWLINE> continue <NEWLINE> if self . _zxt_120 : <NEWLINE> self . _target_temperature = temperature <NEWLINE> if ZXT_120_SET_TEMP . get ( self . _current_operation ) != value . index : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> value . data = int ( round ( temperature , 0 ) ) <NEWLINE> else : <NEWLINE> value . data = int ( temperature ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Set new target temperature.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["cda7ecd1b0085bf40808705a29269200", {"code_string": "def test_client_retries_on_retry_after(box_client, mock_box, retry_code, should_apply):\n    should_apply, expected_num_requests = should_apply\n    mock_box.get_folder_info.add_chaos(error(retry_code, headers = {RETRY_AFTER_HEADER: 1}) should_apply)\n    box_client.folder(0).get()\n    assert len(mock_box.requests) == expected_num_requests\n", "code_toks_joined": "def test_client_retries_on_retry_after ( box_client , mock_box , retry_code , should_apply ) : <NEWLINE> <INDENT> should_apply , expected_num_requests = should_apply <NEWLINE> mock_box . get_folder_info . add_chaos ( error ( retry_code , headers = { RETRY_AFTER_HEADER : 1 } ) should_apply ) <NEWLINE> box_client . folder ( 0 ) . get ( ) <NEWLINE> assert len ( mock_box . requests ) == expected_num_requests <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["c564c091e0a735dadc60448b44df74c6", {"code_string": "def two():\n    for arg in sys.argv[1: ]:\n        try:\n            f = open(arg, 'r')\n        except IOError:\n            print('cannot open', arg)\n            else:\n            print(arg, 'has', len(f.readlines()), 'lines')\n            f.close()\n", "code_toks_joined": "def two ( ) : <NEWLINE> <INDENT> for arg in sys . argv [ 1 : ] : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> f = open ( arg , <STRING> ) <NEWLINE> <DEDENT> except IOError : <NEWLINE> <INDENT> print ( <STRING> , arg ) <NEWLINE> else : <NEWLINE> print ( arg , <STRING> , len ( f . readlines ( ) ) , <STRING> ) <NEWLINE> f . close ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'r'", "'cannot open'", "'has'", "'lines'"]}, "err_obj": {"msg": "invalid syntax"}}], ["65990f9dacd795985d5f1609f48ee037", {"code_string": "def __contains__(self, value):\n    if(hasattr(value, \"url\") and hasattr(value, \"id\")\n        and hasattr(value, \"_dic\")):\n        if self._attribute:\n        return value.url in[elto[self._attribute]\n            for elto in self._list]\n            else:\n        return value.url in self._list\n    return False\n", "code_toks_joined": "def __contains__ ( self , value ) : <NEWLINE> <INDENT> if ( hasattr ( value , <STRING> ) and hasattr ( value , <STRING> ) <NEWLINE> <INDENT> and hasattr ( value , <STRING> ) ) : <NEWLINE> if self . _attribute : <NEWLINE> return value . url in [ elto [ self . _attribute ] <NEWLINE> <INDENT> for elto in self . _list ] <NEWLINE> else : <NEWLINE> <DEDENT> return value . url in self . _list <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"url\"", "\"id\"", "\"_dic\""]}, "err_obj": {"msg": "expected an indented block"}}], ["eb2cdafd447e32b26e4ad424e8d70548", {"code_string": "def sendImage(self, jid, path, caption = None, onSuccess = None, onFailure = None):\n    entity = RequestUploadIqProtocolEntity(RequestUploadIqProtocolEntity.MEDIA_TYPE_IMAGE, filePath = path)\n    successFn = lambda successEntity, originalEntity: self.onRequestUploadResult(jid, path, successEntity, originalEntity, caption, onSuccess, onFailure)\n        errorFn = lambda errorEntity, originalEntity: self.onRequestUploadError(jid, path, errorEntity, originalEntity)\n        self.sendIq(entity, successFn, errorFn)\n", "code_toks_joined": "def sendImage ( self , jid , path , caption = None , onSuccess = None , onFailure = None ) : <NEWLINE> <INDENT> entity = RequestUploadIqProtocolEntity ( RequestUploadIqProtocolEntity . MEDIA_TYPE_IMAGE , filePath = path ) <NEWLINE> successFn = lambda successEntity , originalEntity : self . onRequestUploadResult ( jid , path , successEntity , originalEntity , caption , onSuccess , onFailure ) <NEWLINE> <INDENT> errorFn = lambda errorEntity , originalEntity : self . onRequestUploadError ( jid , path , errorEntity , originalEntity ) <NEWLINE> self . sendIq ( entity , successFn , errorFn ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["a118abbf4a5d85c0ae13f943b3bb2873", {"code_string": "class IndexView(views.APIView):\n    template_name = 'market/vms/index.html'\n    def get_data(self, request, context, * args, ** kwargs):\n    vm1 = {'name': 'Matlab', 'compute': 'Dell', 'storage': 'HP'}\n    vm2 = {'name': 'Web Server', 'compute': 'Compute', 'storage': 'Storage'}\n    context['virtualMachines'] = [vm1, vm2]\n        return context\n", "code_toks_joined": "class IndexView ( views . APIView ) : <NEWLINE> <INDENT> template_name = <STRING> <NEWLINE> def get_data ( self , request , context , * args , ** kwargs ) : <NEWLINE> vm1 = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> vm2 = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> context [ <STRING> ] = [ vm1 , vm2 ] <NEWLINE> <INDENT> return context <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'market/vms/index.html'", "'name'", "'Matlab'", "'compute'", "'Dell'", "'storage'", "'HP'", "'name'", "'Web Server'", "'compute'", "'Compute'", "'storage'", "'Storage'", "'virtualMachines'"]}, "err_obj": {"msg": "expected an indented block"}}], ["5ca71b793136622f0c4801ab7ecf8545", {"code_string": "def testAccessAttributeNotExposedByWrapper(self):\n    manager = self.manager\n    with manager.acquireResource(\n        \"string\", \"test\",\n        resourceManager.LockType.exclusive) as resource:\n        try:\n        resource.THERE_IS_NO_WAY_I_EXIST\n        except AttributeError:\n        return\n        except Exception as ex:\n        self.fail(\"Wrong exception was raised. \"\n            \"Expected AttributeError got %s\",\n            ex.__class__.__name__)\n    self.fail(\"Managed to access an attribute not exposed by wrapper\")\n", "code_toks_joined": "def testAccessAttributeNotExposedByWrapper ( self ) : <NEWLINE> <INDENT> manager = self . manager <NEWLINE> with manager . acquireResource ( <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> resourceManager . LockType . exclusive ) as resource : <NEWLINE> try : <NEWLINE> resource . THERE_IS_NO_WAY_I_EXIST <NEWLINE> except AttributeError : <NEWLINE> return <NEWLINE> except Exception as ex : <NEWLINE> self . fail ( <STRING> <NEWLINE> <INDENT> <STRING> , <NEWLINE> ex . __class__ . __name__ ) <NEWLINE> <DEDENT> <DEDENT> self . fail ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"string\"", "\"test\"", "\"Wrong exception was raised. \"", "\"Expected AttributeError got %s\"", "\"Managed to access an attribute not exposed by wrapper\""]}, "err_obj": {"msg": "expected an indented block"}}], ["45d9eca49ff1dd8c7bf381cb680af267", {"code_string": "def scanwifi_actionfn(self, eventObj = None):\n    print(os.system(\"/System/Library/\")\n        \"PrivateFrameworks/Apple80211.framework/Resources/airport --scan\")\n    return\n", "code_toks_joined": "def scanwifi_actionfn ( self , eventObj = None ) : <NEWLINE> <INDENT> print ( os . system ( <STRING> ) <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"/System/Library/\"", "\"PrivateFrameworks/Apple80211.framework/Resources/airport --scan\""]}, "err_obj": {"msg": "invalid syntax"}}], ["7bcccff8fa28fb71a49195d8d5053152", {"code_string": "def _has_run_received(self):\n    debug(1, \"has run received\")\n    if len(self.ifacedirty):\n        for name in self.ifacedirty.keys():\n        if self.devuuid[name]:\n            self.check_and_save(name, self.devuuid[name])\n        self.ifacedirty = {}\n", "code_toks_joined": "def _has_run_received ( self ) : <NEWLINE> <INDENT> debug ( 1 , <STRING> ) <NEWLINE> if len ( self . ifacedirty ) : <NEWLINE> <INDENT> for name in self . ifacedirty . keys ( ) : <NEWLINE> if self . devuuid [ name ] : <NEWLINE> <INDENT> self . check_and_save ( name , self . devuuid [ name ] ) <NEWLINE> <DEDENT> self . ifacedirty = { } <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"has run received\""]}, "err_obj": {"msg": "expected an indented block"}}], ["5e3271d1071bc77fff93a07cf79fa04a", {"code_string": "def retrieve(self, url, name):\n    try:\n        handle = urllib2.urlopen(url)\n            CHUNK = 16384\n        with open(name, 'wb') as fp:\n            while True:\n                chunk = handle.read(CHUNK)\n                if not chunk:\n                    break\n                fp.write(chunk)\n    except:\n        traceback.print_exc()\n", "code_toks_joined": "def retrieve ( self , url , name ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> handle = urllib2 . urlopen ( url ) <NEWLINE> <INDENT> CHUNK = 16384 <NEWLINE> <DEDENT> with open ( name , <STRING> ) as fp : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> chunk = handle . read ( CHUNK ) <NEWLINE> if not chunk : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> fp . write ( chunk ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> traceback . print_exc ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'wb'"]}, "err_obj": {"msg": "unexpected indent"}}], ["c849780cdf3d969aa35beeef2aceed1a", {"code_string": "def pick_best_methods(stochastic):\n    \"\"\"Picks the StepMethods best suited to handle\"\"\"\n    max_competence = 0\n    best_candidates = set([])\n    for method in StepMethodRegistry:\n        try:\n            competence = method.competence(stochastic)\n        except:\n            competence = 0\n        if competence > max_competence:\n            best_candidates = set([method])\n            max_competence = competence\n        elif competence == max_competence:\n            best_candidates.add(method)\n    if max_competence <= 0:\n        raise ValueError, 'Maximum competence reported for stochastic %s is <= 0... you may need to write a custom step method class.' % stochastic.__name__\n    return best_candidates\n", "code_toks_joined": "def pick_best_methods ( stochastic ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> max_competence = 0 <NEWLINE> best_candidates = set ( [ ] ) <NEWLINE> for method in StepMethodRegistry : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> competence = method . competence ( stochastic ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> competence = 0 <NEWLINE> <DEDENT> if competence > max_competence : <NEWLINE> <INDENT> best_candidates = set ( [ method ] ) <NEWLINE> max_competence = competence <NEWLINE> <DEDENT> elif competence == max_competence : <NEWLINE> <INDENT> best_candidates . add ( method ) <NEWLINE> <DEDENT> <DEDENT> if max_competence <= 0 : <NEWLINE> <INDENT> raise ValueError , <STRING> % stochastic . __name__ <NEWLINE> <DEDENT> return best_candidates <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Picks the StepMethods best suited to handle\"\"\"", "'Maximum competence reported for stochastic %s is <= 0... you may need to write a custom step method class.'"]}, "err_obj": {"msg": "invalid syntax"}}], ["8ec3b5343739129d67748473ab09605e", {"code_string": "def retranslateUi(self, MainWindow):\n    MainWindow.setWindowTitle(QtGui.QApplication.translate(\"MainWindow\", \"MainWindow\", None, QtGui.QApplication.UnicodeUTF8))\n    self.textEdit_help.setHtml(QtGui.QApplication.translate(\"MainWindow\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , MainWindow ) : <NEWLINE> <INDENT> MainWindow . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . textEdit_help . setHtml ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"MainWindow\"", "\"MainWindow\"", "\"MainWindow\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["5565a4b5f7423ff049b751430f1ad48b", {"code_string": "class Ui_MainWindow(object):\n    def setupUi(self, MainWindow):\n        MainWindow.setObjectName(_fromUtf8(\"MainWindow\"))\n        MainWindow.resize(704, 447)\n        MainWindow.setMinimumSize(QtCore.QSize(300, 0))\n        MainWindow.setMouseTracking(False)\n        icon = QtGui.QIcon()\n        icon.addPixmap(QtGui.QPixmap(_fromUtf8(\"../../../../../usr/share/pixmaps/cubeview48.png\")), QtGui.QIcon.Normal, QtGui.QIcon.Off)\n        MainWindow.setWindowIcon(icon)\n        MainWindow.setWindowOpacity(1.0)\n        MainWindow.setToolTip(_fromUtf8(\"\"))\n        MainWindow.setAutoFillBackground(False)\n        MainWindow.setStyleSheet(_fromUtf8(\"QPushButton {\\n\"\n", "code_toks_joined": "class Ui_MainWindow ( object ) : <NEWLINE> <INDENT> def setupUi ( self , MainWindow ) : <NEWLINE> <INDENT> MainWindow . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> MainWindow . resize ( 704 , 447 ) <NEWLINE> MainWindow . setMinimumSize ( QtCore . QSize ( 300 , 0 ) ) <NEWLINE> MainWindow . setMouseTracking ( False ) <NEWLINE> icon = QtGui . QIcon ( ) <NEWLINE> icon . addPixmap ( QtGui . QPixmap ( _fromUtf8 ( <STRING> ) ) , QtGui . QIcon . Normal , QtGui . QIcon . Off ) <NEWLINE> MainWindow . setWindowIcon ( icon ) <NEWLINE> MainWindow . setWindowOpacity ( 1.0 ) <NEWLINE> MainWindow . setToolTip ( _fromUtf8 ( <STRING> ) ) <NEWLINE> MainWindow . setAutoFillBackground ( False ) <NEWLINE> MainWindow . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"MainWindow\"", "\"../../../../../usr/share/pixmaps/cubeview48.png\"", "\"\"", "\"QPushButton {\\n\""]}, "window_span": [127, 134], "err_obj": {"msg": "unbalanced (){}[]"}}], ["7509163a011d80337db6e3c81edecceb", {"code_string": "def open_h2(fname, lists):\n    f = open(fname, 'w')\n    write_license(f)\n    d = nz_fname(fname).replace('.', '_').upper()\n    f.write('''''' %(d, d))\n    for i in lists:\n        f.write('''if len(lists) > 0: f.write('nn')'''\n", "code_toks_joined": "def open_h2 ( fname , lists ) : <NEWLINE> <INDENT> f = open ( fname , <STRING> ) <NEWLINE> write_license ( f ) <NEWLINE> d = nz_fname ( fname ) . replace ( <STRING> , <STRING> ) . upper ( ) <NEWLINE> f . write ( <STRING> % ( d , d ) ) <NEWLINE> for i in lists : <NEWLINE> <INDENT> f . write ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'w'", "'.'", "'_'", "''''''", "'''if len(lists) > 0: f.write('nn')'''"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["233d60bfbea49c0a10c50894f6ec4c4c", {"code_string": "def encodeAllRecords(self, records = None, toBeAdded = True):\n    \"\"\"Encodes a list of records.\"\"\"\n    if records is None:\n        records = self.getAllRecords()\n    if self.verbosity > 0: print 'Encoding', len(records), 'records.'\n    encodings = [self.encodeRecord(record, toBeAdded) for record in records]\n    return encodings\n", "code_toks_joined": "def encodeAllRecords ( self , records = None , toBeAdded = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if records is None : <NEWLINE> <INDENT> records = self . getAllRecords ( ) <NEWLINE> <DEDENT> if self . verbosity > 0 : print <STRING> , len ( records ) , <STRING> <NEWLINE> encodings = [ self . encodeRecord ( record , toBeAdded ) for record in records ] <NEWLINE> return encodings <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Encodes a list of records.\"\"\"", "'Encoding'", "'records.'"]}, "err_obj": {"msg": "invalid syntax"}}], ["8c7700bcecffaff0cde91020ba7c3914", {"code_string": "def __init__(self):\n    BasePlugin.__init__(self)\n    try:\n    print(self.kbase[\"grep.regex\"])\n    self.regex = re.compile(self.kbase[\"grep.regex\"][0], re.MULTILINE | re.DOTALL)\n    except Exception, e:\n    raise FuzzExceptPluginBadParams(\"Incorrect regex or missing regex parameter.\")\n", "code_toks_joined": "def __init__ ( self ) : <NEWLINE> <INDENT> BasePlugin . __init__ ( self ) <NEWLINE> try : <NEWLINE> print ( self . kbase [ <STRING> ] ) <NEWLINE> self . regex = re . compile ( self . kbase [ <STRING> ] [ 0 ] , re . MULTILINE | re . DOTALL ) <NEWLINE> except Exception , e : <NEWLINE> raise FuzzExceptPluginBadParams ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"grep.regex\"", "\"grep.regex\"", "\"Incorrect regex or missing regex parameter.\""]}, "err_obj": {"msg": "expected an indented block"}}], ["76216326f5c230cac6bc541e6fa22774", {"code_string": "def odb(odbcmd, odbkey, val):\n    if odbcmd == \"get\":\n        command = \"odbedit -c 'ls -l \\\"\" + odbkey + \"\\\"'\"\n        print(command)\n    elif odbcmd == \"set\":\n        command = \"odbedit -c 'set \\\"\" + odbkey + \"\\\" \\\"\" + val + \"\\\"'\"\n            elif odbcmd == \"test\":\n        command = \"odbedit -c 'ls -v \\\"\" + odbkey + \"\\\"'\"\n    p = Popen(command, shell = True, stdout = PIPE, stderr = PIPE)\n    stdout, stderr = p.communicate()\n    print(stderr)\n    return stdout\n", "code_toks_joined": "def odb ( odbcmd , odbkey , val ) : <NEWLINE> <INDENT> if odbcmd == <STRING> : <NEWLINE> <INDENT> command = <STRING> + odbkey + <STRING> <NEWLINE> print ( command ) <NEWLINE> <DEDENT> elif odbcmd == <STRING> : <NEWLINE> <INDENT> command = <STRING> + odbkey + <STRING> + val + <STRING> <NEWLINE> <INDENT> elif odbcmd == <STRING> : <NEWLINE> <DEDENT> command = <STRING> + odbkey + <STRING> <NEWLINE> <DEDENT> p = Popen ( command , shell = True , stdout = PIPE , stderr = PIPE ) <NEWLINE> stdout , stderr = p . communicate ( ) <NEWLINE> print ( stderr ) <NEWLINE> return stdout <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"get\"", "\"odbedit -c 'ls -l \\\"\"", "\"\\\"'\"", "\"set\"", "\"odbedit -c 'set \\\"\"", "\"\\\" \\\"\"", "\"\\\"'\"", "\"test\"", "\"odbedit -c 'ls -v \\\"\"", "\"\\\"'\""]}, "err_obj": {"msg": "unexpected indent"}}], ["9eb9259bd15ab23d2691d595064f138d", {"code_string": "def cairo_disable_antialias(cr):\n    '''Disable cairo antialias temporary.'''\n    antialias = cr.get_antialias()\n    cr.set_antialias(cairo.ANTIALIAS_NONE)\n    try:\n        yield\n    except Exception, e:\n        print('function cairo_disable_antialias got error: %s' % e)\n        traceback.print_exc(file = sys.stdout)\n    else:\n        cr.set_antialias(antialias)\n", "code_toks_joined": "def cairo_disable_antialias ( cr ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> antialias = cr . get_antialias ( ) <NEWLINE> cr . set_antialias ( cairo . ANTIALIAS_NONE ) <NEWLINE> try : <NEWLINE> <INDENT> yield <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> print ( <STRING> % e ) <NEWLINE> traceback . print_exc ( file = sys . stdout ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cr . set_antialias ( antialias ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Disable cairo antialias temporary.'''", "'function cairo_disable_antialias got error: %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["cb1f715c61462ea316fbce929370f865", {"code_string": "def __init__(self, server = 'localhost', port = 5434)\n    self.__server = server\n    self.__port = port\n", "code_toks_joined": "def __init__ ( self , server = <STRING> , port = 5434 ) <NEWLINE> <INDENT> self . __server = server <NEWLINE> self . __port = port <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'localhost'"]}, "err_obj": {"msg": "invalid syntax"}}], ["956f71360dc53b6540c936da1dafeaa5", {"code_string": "def CmdLineFindIndex(tag):\n    for i in range(len(sys.argv))\n        if sys.argv[i] == tag:\n            return i\n    return - 1\n", "code_toks_joined": "def CmdLineFindIndex ( tag ) : <NEWLINE> <INDENT> for i in range ( len ( sys . argv ) ) <NEWLINE> <INDENT> if sys . argv [ i ] == tag : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT> return - 1 <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["c61ace2f0cd79acd37874e6f66fb4ec9", {"code_string": "class Serializer(PythonSerializer):\n    \"\"\"Convert a queryset to JSON.\"\"\"\n    def end_serialization(self):\n        \"\"\"Output a JSON encoded queryset.\"\"\"\n        self.options.pop('subclass', None)\n        simplejson.dump(self.objects, self.stream, cls = DjangoJSONEncoder,\n            ** self.options)\n    def getvalue(self):\n        \"\"\"Return the fully serialized queryset(or None if the output stream\"\"\"\n        if callable(getattr(self.stream, 'getvalue', None):\n            return self.stream.getvalue()\n", "code_toks_joined": "class Serializer ( PythonSerializer ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def end_serialization ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . options . pop ( <STRING> , None ) <NEWLINE> simplejson . dump ( self . objects , self . stream , cls = DjangoJSONEncoder , <NEWLINE> <INDENT> ** self . options ) <NEWLINE> <DEDENT> <DEDENT> def getvalue ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if callable ( getattr ( self . stream , <STRING> , None ) : <NEWLINE> <INDENT> return self . stream . getvalue ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Convert a queryset to JSON.\"\"\"", "\"\"\"Output a JSON encoded queryset.\"\"\"", "'subclass'", "\"\"\"Return the fully serialized queryset(or None if the output stream\"\"\"", "'getvalue'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["02a26d729105878206798bac29b723da", {"code_string": "class cambioClave(forms.Form):\n    claveV = forms.CharField(widget = forms.PasswordInput())\n    clave = forms.CharField(widget = forms.PasswordInput()\n    claveO = forms.CharField(widget = forms.PasswordInput())\n", "code_toks_joined": "class cambioClave ( forms . Form ) : <NEWLINE> <INDENT> claveV = forms . CharField ( widget = forms . PasswordInput ( ) ) <NEWLINE> clave = forms . CharField ( widget = forms . PasswordInput ( ) <NEWLINE> claveO = forms . CharField ( widget = forms . PasswordInput ( ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["59ab97dd3217537f1cf8e9a9637605ee", {"code_string": "def to_json_dict(self):\n    \"\"\"Answer the json dictionary representation of the receiver.\"\"\"\n    json_dict = {}\n    ffn = self.prefix + '-apply_sed'\n    apply_sed = ffn in self.data and self.data[ffn]\n    json_dict[ffn] = apply_sed\n    if apply_sed:\n        for fn in['single_stellar_population_model', 'apply_dust',\n            'select_dust_model', 'band_pass_filters']:\n            ffn = self.prefix + '-' + fn\n            val = self.data.get(ffn)\n            if val is not None:\n            json_dict[ffn] = val\n    return json_dict\n", "code_toks_joined": "def to_json_dict ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> json_dict = { } <NEWLINE> ffn = self . prefix + <STRING> <NEWLINE> apply_sed = ffn in self . data and self . data [ ffn ] <NEWLINE> json_dict [ ffn ] = apply_sed <NEWLINE> if apply_sed : <NEWLINE> <INDENT> for fn in [ <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> ] : <NEWLINE> ffn = self . prefix + <STRING> + fn <NEWLINE> val = self . data . get ( ffn ) <NEWLINE> if val is not None : <NEWLINE> json_dict [ ffn ] = val <NEWLINE> <DEDENT> <DEDENT> return json_dict <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Answer the json dictionary representation of the receiver.\"\"\"", "'-apply_sed'", "'single_stellar_population_model'", "'apply_dust'", "'select_dust_model'", "'band_pass_filters'", "'-'"]}, "err_obj": {"msg": "expected an indented block"}}], ["d2dd53c19321fa41a7ad1ae41521148b", {"code_string": "def plotRes(res, feat = None, imgFile = None):\n    \"\"\"Takes in the res which can contain ghte pkl file or the data in the file itself and the feature that is\"\"\"\n    if imgFile is None:\n        imgFile = 'figure.png'\n    bottom = 30.0\n    left = 30.0\n    if isinstance(res, str):\n        resFile = open(res, 'rb')\n        res = pkl.load(resFile)\n        resFile.close()\n    if feat is None:\n        tmplt = '{0}'\n    else:\n        tmplt = feat + '_{0}'\n    labels = [tmplt.format(i[0]) for i in res]\n    precList = [1 - i[1][0] / 100.0 for i in res]\n    recList = [i[1][1] / 100.0 for i in res]\n    fig = plt.figure()\n    fig.subplots_adjust(bottom = 0.1)\n    ax1 = fig.add_subplot(111)\n    ax1.scatter(precList, recList, marker = 'o')\n    ax1.set_xlabel('False Positive Rate')\n    ax1.set_ylabel('True Positive rate')\n    for label, tup in zip(labels, res):\n        ax1.annotate(label, xy = (1 - tup[1][0] / 100.0, tup[1][1] / 100.0), textcoords = 'offset points', ha = 'right', va = 'bottom',\n    fig.savefig(imgFile)\n", "code_toks_joined": "def plotRes ( res , feat = None , imgFile = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if imgFile is None : <NEWLINE> <INDENT> imgFile = <STRING> <NEWLINE> <DEDENT> bottom = 30.0 <NEWLINE> left = 30.0 <NEWLINE> if isinstance ( res , str ) : <NEWLINE> <INDENT> resFile = open ( res , <STRING> ) <NEWLINE> res = pkl . load ( resFile ) <NEWLINE> resFile . close ( ) <NEWLINE> <DEDENT> if feat is None : <NEWLINE> <INDENT> tmplt = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmplt = feat + <STRING> <NEWLINE> <DEDENT> labels = [ tmplt . format ( i [ 0 ] ) for i in res ] <NEWLINE> precList = [ 1 - i [ 1 ] [ 0 ] / 100.0 for i in res ] <NEWLINE> recList = [ i [ 1 ] [ 1 ] / 100.0 for i in res ] <NEWLINE> fig = plt . figure ( ) <NEWLINE> fig . subplots_adjust ( bottom = 0.1 ) <NEWLINE> ax1 = fig . add_subplot ( 111 ) <NEWLINE> ax1 . scatter ( precList , recList , marker = <STRING> ) <NEWLINE> ax1 . set_xlabel ( <STRING> ) <NEWLINE> ax1 . set_ylabel ( <STRING> ) <NEWLINE> for label , tup in zip ( labels , res ) : <NEWLINE> <INDENT> ax1 . annotate ( label , xy = ( 1 - tup [ 1 ] [ 0 ] / 100.0 , tup [ 1 ] [ 1 ] / 100.0 ) , textcoords = <STRING> , ha = <STRING> , va = <STRING> , <NEWLINE> <DEDENT> fig . savefig ( imgFile ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Takes in the res which can contain ghte pkl file or the data in the file itself and the feature that is\"\"\"", "'figure.png'", "'rb'", "'{0}'", "'_{0}'", "'o'", "'False Positive Rate'", "'True Positive rate'", "'offset points'", "'right'", "'bottom'"]}, "window_span": [222, 273], "err_obj": {"msg": "unbalanced (){}[]"}}], ["b5012ef7f32a14cf6d5d53ed941bee75", {"code_string": "def connect(host, port, user, password, source, expression):\n    with manager.connect(\n        host = host, port = port,\n        username = user, password = password\n        ) as m:\n        assert(\":xpath\" in m.server_capabilities)\n        c = m.get_config(source, filter = ('xpath', expression)).data_xml\n        with open(\"%s.xml\" % host, 'w') as f:\n        f.write(c)\n", "code_toks_joined": "def connect ( host , port , user , password , source , expression ) : <NEWLINE> <INDENT> with manager . connect ( <NEWLINE> <INDENT> host = host , port = port , <NEWLINE> username = user , password = password <NEWLINE> ) as m : <NEWLINE> assert ( <STRING> in m . server_capabilities ) <NEWLINE> c = m . get_config ( source , filter = ( <STRING> , expression ) ) . data_xml <NEWLINE> with open ( <STRING> % host , <STRING> ) as f : <NEWLINE> f . write ( c ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\":xpath\"", "'xpath'", "\"%s.xml\"", "'w'"]}, "err_obj": {"msg": "expected an indented block"}}], ["a552b52e442c0f7420109c976d240baa", {"code_string": "def remove_adjacent(nums):\n    lst = []\n    if len(nums) == 0:\n    return lst\n    lst.append(nums[0])\n    for num in nums[1: ]:\n        if lst[- 1] != num:\n            lst.append(num)\n    return lst\n", "code_toks_joined": "def remove_adjacent ( nums ) : <NEWLINE> <INDENT> lst = [ ] <NEWLINE> if len ( nums ) == 0 : <NEWLINE> return lst <NEWLINE> lst . append ( nums [ 0 ] ) <NEWLINE> for num in nums [ 1 : ] : <NEWLINE> <INDENT> if lst [ - 1 ] != num : <NEWLINE> <INDENT> lst . append ( num ) <NEWLINE> <DEDENT> <DEDENT> return lst <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["a359cfaec4bc9f7b1c8781518b04825e", {"code_string": "def _block_piece(self, index, df):\n    self.blocking_pieces[index] = df\n    df.addCallback(lambda x: self.blocking_pieces.pop(index)\n    return df\n", "code_toks_joined": "def _block_piece ( self , index , df ) : <NEWLINE> <INDENT> self . blocking_pieces [ index ] = df <NEWLINE> df . addCallback ( lambda x : self . blocking_pieces . pop ( index ) <NEWLINE> return df <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e23a94c84e30548a618eea9f47e08713", {"code_string": "def _GetWin32ProcessInfo(self, func, pid):\n    mask = (win32con.PROCESS_QUERY_INFORMATION |\n        win32con.PROCESS_VM_READ)\n    handle = None\n    try:\n        handle = win32api.OpenProcess(mask, False, pid)\n        return func(handle)\n    except pywintypes.error, e:\n        errcode = e[0]\n        if errcode == 87:\n            raise exceptions.ProcessGoneException()\n        raise\n    finally:\n        if handle:\n            win32api.CloseHandle(handle)\n", "code_toks_joined": "def _GetWin32ProcessInfo ( self , func , pid ) : <NEWLINE> <INDENT> mask = ( win32con . PROCESS_QUERY_INFORMATION | <NEWLINE> <INDENT> win32con . PROCESS_VM_READ ) <NEWLINE> <DEDENT> handle = None <NEWLINE> try : <NEWLINE> <INDENT> handle = win32api . OpenProcess ( mask , False , pid ) <NEWLINE> return func ( handle ) <NEWLINE> <DEDENT> except pywintypes . error , e : <NEWLINE> <INDENT> errcode = e [ 0 ] <NEWLINE> if errcode == 87 : <NEWLINE> <INDENT> raise exceptions . ProcessGoneException ( ) <NEWLINE> <DEDENT> raise <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> if handle : <NEWLINE> <INDENT> win32api . CloseHandle ( handle ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["77f4957ac3f920ba1968367be9241a84", {"code_string": "def test_create_route_no_cidr_raises(self):\n    subnet = dict(id = 2, ip_policy = [], cidr = \"192.168.0.0/24\")\n    create_route = dict(id = 1, gateway = \"192.168.0.1\",\n        subnet_id = subnet[\"id\"])\n    with self._stubs(create_route = create_route, find_routes = [],\n        subnet = subnet):\n        with self.assertRaises(\n        exceptions.BadRequest):\n        self.plugin.create_route(self.context,\n            dict(route = create_route))\n", "code_toks_joined": "def test_create_route_no_cidr_raises ( self ) : <NEWLINE> <INDENT> subnet = dict ( id = 2 , ip_policy = [ ] , cidr = <STRING> ) <NEWLINE> create_route = dict ( id = 1 , gateway = <STRING> , <NEWLINE> <INDENT> subnet_id = subnet [ <STRING> ] ) <NEWLINE> <DEDENT> with self . _stubs ( create_route = create_route , find_routes = [ ] , <NEWLINE> <INDENT> subnet = subnet ) : <NEWLINE> with self . assertRaises ( <NEWLINE> exceptions . BadRequest ) : <NEWLINE> self . plugin . create_route ( self . context , <NEWLINE> <INDENT> dict ( route = create_route ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"192.168.0.0/24\"", "\"192.168.0.1\"", "\"id\""]}, "err_obj": {"msg": "expected an indented block"}}], ["a767b3d78f6f4fa33df630f388ecf419", {"code_string": "def bytes(self):\n    URL_extension_count = 0\n    for url in self.URL_extensions:\n        URL_extension_count = URL_extension_count + 1\n    fmt = \"!HBB%dsB\" % len(self.URL_base)\n    result = pack(fmt,\n        self.protocol_id,\n        self.transport_protocol_label,\n    len(self.URL_base),\n    self.URL_base,\n    URL_extension_count\n        )\n    for url in self.URL_extensions:\n        result = result + pack(\n            \"!B%ds\" % len(url),\n            len(url),\n            url,\n            )\n            return result\n", "code_toks_joined": "def bytes ( self ) : <NEWLINE> <INDENT> URL_extension_count = 0 <NEWLINE> for url in self . URL_extensions : <NEWLINE> <INDENT> URL_extension_count = URL_extension_count + 1 <NEWLINE> <DEDENT> fmt = <STRING> % len ( self . URL_base ) <NEWLINE> result = pack ( fmt , <NEWLINE> <INDENT> self . protocol_id , <NEWLINE> self . transport_protocol_label , <NEWLINE> <DEDENT> len ( self . URL_base ) , <NEWLINE> self . URL_base , <NEWLINE> URL_extension_count <NEWLINE> <INDENT> ) <NEWLINE> <DEDENT> for url in self . URL_extensions : <NEWLINE> <INDENT> result = result + pack ( <NEWLINE> <INDENT> <STRING> % len ( url ) , <NEWLINE> len ( url ) , <NEWLINE> url , <NEWLINE> ) <NEWLINE> return result <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"!HBB%dsB\"", "\"!B%ds\""]}, "err_obj": {"msg": "unexpected indent"}}], ["f34f6cbf6747c7614a79a2a1e34dc86d", {"code_string": "def checkBC(self):\n    xtemp = self.x.copy()\n    if self.RW.domain.typ == 'circle' and self.BCtyp in[0, 1]:\n    self.x = self.BCs[0].hit(self.xold, self.x)\n    else:\n    for i, BC in enumerate(self.BCs):\n    self.x = BC.hit(self.xold, self.x)\n    if not(self.x == xtemp).all():\n    break\n    return self.x\n", "code_toks_joined": "def checkBC ( self ) : <NEWLINE> <INDENT> xtemp = self . x . copy ( ) <NEWLINE> if self . RW . domain . typ == <STRING> and self . BCtyp in [ 0 , 1 ] : <NEWLINE> self . x = self . BCs [ 0 ] . hit ( self . xold , self . x ) <NEWLINE> else : <NEWLINE> for i , BC in enumerate ( self . BCs ) : <NEWLINE> self . x = BC . hit ( self . xold , self . x ) <NEWLINE> if not ( self . x == xtemp ) . all ( ) : <NEWLINE> break <NEWLINE> return self . x <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'circle'"]}, "err_obj": {"msg": "expected an indented block"}}], ["735d01121c67bb79b88a05d0d92ba3fa", {"code_string": "def timeGetBlocksGrid():\n    x, y, z = numpy.mgrid[\n        box.minx: box.maxx,\n        box.miny: box.maxy,\n        box.minz: box.maxz,\n    ]\n    x, y, z = [numpy.ravel(a) for a in x, y, z]\n    result = dim.getBlocks(x, y, z, return_Data = True)\n", "code_toks_joined": "def timeGetBlocksGrid ( ) : <NEWLINE> <INDENT> x , y , z = numpy . mgrid [ <NEWLINE> <INDENT> box . minx : box . maxx , <NEWLINE> box . miny : box . maxy , <NEWLINE> box . minz : box . maxz , <NEWLINE> <DEDENT> ] <NEWLINE> x , y , z = [ numpy . ravel ( a ) for a in x , y , z ] <NEWLINE> result = dim . getBlocks ( x , y , z , return_Data = True ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["e024e2525119cc8e14fcdbf00233b8b0", {"code_string": "def main():\n    if len(sys.argv) > 4:\n    sd = len(sys.argv)\n    print('her', sd)\n    else:\n    f = len(sys.argv)\n    print('say', f)\n    if len(sys.argv) >= 2:\n        name = sys.argv[1]\n    else:\n        name = 'World'\n    print('Hello', name)\n", "code_toks_joined": "def main ( ) : <NEWLINE> <INDENT> if len ( sys . argv ) > 4 : <NEWLINE> sd = len ( sys . argv ) <NEWLINE> print ( <STRING> , sd ) <NEWLINE> else : <NEWLINE> f = len ( sys . argv ) <NEWLINE> print ( <STRING> , f ) <NEWLINE> if len ( sys . argv ) >= 2 : <NEWLINE> <INDENT> name = sys . argv [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> <DEDENT> print ( <STRING> , name ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'her'", "'say'", "'World'", "'Hello'"]}, "err_obj": {"msg": "expected an indented block"}}], ["e2a82907f0413dd5720d0e1fea5de7c2", {"code_string": "class MockSuite(_Mock):\n    def __init__(self, name, mediumname = None, longname = None, visible = True,\n        suites = [], tests = []):\n        _Mock.__init__(self, name, mediumname, longname, visible)\n        for suite in suites:\n        suite.parent = self\n        self.suites = suites\n        for test in tests:\n        test.parent = self\n        self.tests = tests\n", "code_toks_joined": "class MockSuite ( _Mock ) : <NEWLINE> <INDENT> def __init__ ( self , name , mediumname = None , longname = None , visible = True , <NEWLINE> <INDENT> suites = [ ] , tests = [ ] ) : <NEWLINE> _Mock . __init__ ( self , name , mediumname , longname , visible ) <NEWLINE> for suite in suites : <NEWLINE> suite . parent = self <NEWLINE> self . suites = suites <NEWLINE> for test in tests : <NEWLINE> test . parent = self <NEWLINE> self . tests = tests <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["53e04c1120b2c9b2982204f99e793f84", {"code_string": "def __setattr__(self, key, value):\n    \"\"\"Whenever the data for this object is updated, a number of\"\"\"\n    if(key == 'id'):\n        return self.set_id(value)\n    if(key.startswith('_'):\n        _dict = object.__getattribute__(self, '__dict__')\n        _dict[key] = value\n    else:\n        self[key] = value\n", "code_toks_joined": "def __setattr__ ( self , key , value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( key == <STRING> ) : <NEWLINE> <INDENT> return self . set_id ( value ) <NEWLINE> <DEDENT> if ( key . startswith ( <STRING> ) : <NEWLINE> <INDENT> _dict = object . __getattribute__ ( self , <STRING> ) <NEWLINE> _dict [ key ] = value <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self [ key ] = value <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Whenever the data for this object is updated, a number of\"\"\"", "'id'", "'_'", "'__dict__'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["1646b3e92ef67f20e52978e2161612d0", {"code_string": "def ListBookmarks(conn):\n    val = conn.execute('''SELECT * FROM BOOKMARKS''').fetchall()\n    if len(val) == 0: print bcolors.WARNING + \"No bookmarks exist\" + bcolors.ENDC\n    for Row in val:\n        print(bcolors.OKBLUE + Row[3] + bcolors.OKGREEN + ': ' + Row[2] + bcolors.ENDC)\n", "code_toks_joined": "def ListBookmarks ( conn ) : <NEWLINE> <INDENT> val = conn . execute ( <STRING> ) . fetchall ( ) <NEWLINE> if len ( val ) == 0 : print bcolors . WARNING + <STRING> + bcolors . ENDC <NEWLINE> for Row in val : <NEWLINE> <INDENT> print ( bcolors . OKBLUE + Row [ 3 ] + bcolors . OKGREEN + <STRING> + Row [ 2 ] + bcolors . ENDC ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''SELECT * FROM BOOKMARKS'''", "\"No bookmarks exist\"", "': '"]}, "err_obj": {"msg": "invalid syntax"}}], ["f8368742d2a5e8f5fb811faf3b2b34d0", {"code_string": "def test_on_settings_changed(self):\n    body = {\"action\": \"update\", \"Prev\": \"Prev1\", \"Curr\": \"Curr1\"}\n    event_type = \"ObjectSettingChanged\"\n    with patch('org.o3project.odenos.remoteobject.remote_object.'\n        'RemoteObject._publish_event_async',\n        ) as m_publish_event_async:\n        self.result = self.target.on_settings_changed(\"update\",\n            \"Prev1\",\n            \"Curr1\")\n            m_publish_event_async.assert_called_one_with(event_type,\n            body)\n", "code_toks_joined": "def test_on_settings_changed ( self ) : <NEWLINE> <INDENT> body = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> event_type = <STRING> <NEWLINE> with patch ( <STRING> <NEWLINE> <INDENT> <STRING> , <NEWLINE> ) as m_publish_event_async : <NEWLINE> self . result = self . target . on_settings_changed ( <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ) <NEWLINE> m_publish_event_async . assert_called_one_with ( event_type , <NEWLINE> body ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"action\"", "\"update\"", "\"Prev\"", "\"Prev1\"", "\"Curr\"", "\"Curr1\"", "\"ObjectSettingChanged\"", "'org.o3project.odenos.remoteobject.remote_object.'", "'RemoteObject._publish_event_async'", "\"update\"", "\"Prev1\"", "\"Curr1\""]}, "err_obj": {"msg": "unexpected indent"}}], ["9c79839eba17625a284fd1a2d769a75b", {"code_string": "def run_sossrv(target, ):\n    ''' start up sossrv.  for targets mica2 or micaz, it will run sossrv on the listen port specified.'''\n    if target != 'avrora' and prog != 'stk500':\n    cmd_run = ['sossrv.exe', '-s', listen_port]\n    elif prog == 'stk500':\n    cmd_run = ['sossrv.exe', '-n', '%s:10002' % listen_ip]\n    else:\n    cmd_run = ['sossrv.exe', '-n', '127.0.0.1:2390']\n    print(cmd_run)\n    time.sleep(10)\n    ret = os.fork()\n    if ret == 0:\n    run_and_redirect(cmd_run, os.environ['SOSTESTDIR'] + '/../python/sossrv.log')\n    time.sleep(20)\n    return ret\n", "code_toks_joined": "def run_sossrv ( target , ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if target != <STRING> and prog != <STRING> : <NEWLINE> cmd_run = [ <STRING> , <STRING> , listen_port ] <NEWLINE> elif prog == <STRING> : <NEWLINE> cmd_run = [ <STRING> , <STRING> , <STRING> % listen_ip ] <NEWLINE> else : <NEWLINE> cmd_run = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> print ( cmd_run ) <NEWLINE> time . sleep ( 10 ) <NEWLINE> ret = os . fork ( ) <NEWLINE> if ret == 0 : <NEWLINE> run_and_redirect ( cmd_run , os . environ [ <STRING> ] + <STRING> ) <NEWLINE> time . sleep ( 20 ) <NEWLINE> return ret <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''' start up sossrv.  for targets mica2 or micaz, it will run sossrv on the listen port specified.'''", "'avrora'", "'stk500'", "'sossrv.exe'", "'-s'", "'stk500'", "'sossrv.exe'", "'-n'", "'%s:10002'", "'sossrv.exe'", "'-n'", "'127.0.0.1:2390'", "'SOSTESTDIR'", "'/../python/sossrv.log'"]}, "err_obj": {"msg": "expected an indented block"}}], ["75ea5087f79962922a00c4861b6bcfb7", {"code_string": "def nr7(_sec, _media, _desv):\n    print(\"Regla 7\")\n    quince = np.array([])\n    for i in range(len(_sec)):\n    if((_sec[i] > _media - _desv) &(_sec[i] < _media + _desv)): quince = np.append(quince, i)\n    consec = np.array_split(quince, np.where(np.diff(quince) != 1)[0] + 1)\n    imp_nr(consec, _sec, 15)\n", "code_toks_joined": "def nr7 ( _sec , _media , _desv ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quince = np . array ( [ ] ) <NEWLINE> for i in range ( len ( _sec ) ) : <NEWLINE> if ( ( _sec [ i ] > _media - _desv ) & ( _sec [ i ] < _media + _desv ) ) : quince = np . append ( quince , i ) <NEWLINE> consec = np . array_split ( quince , np . where ( np . diff ( quince ) != 1 ) [ 0 ] + 1 ) <NEWLINE> imp_nr ( consec , _sec , 15 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Regla 7\""]}, "err_obj": {"msg": "expected an indented block"}}], ["28746c987c6195213e0ab11bf8900966", {"code_string": "class TestExtractBadArchive(unittest.TestCase):\n    def verifyFailed(self, (exitcode, stdout, stderr)):\n        self.assertEqual(exitcode, 1)\n        self.assertTrue('Error' in stderr)\n    def test_extract_missing_file(self):\n        self.verifyFailed(run(['-x', 'missing']));\n", "code_toks_joined": "class TestExtractBadArchive ( unittest . TestCase ) : <NEWLINE> <INDENT> def verifyFailed ( self , ( exitcode , stdout , stderr ) ) : <NEWLINE> <INDENT> self . assertEqual ( exitcode , 1 ) <NEWLINE> self . assertTrue ( <STRING> in stderr ) <NEWLINE> <DEDENT> def test_extract_missing_file ( self ) : <NEWLINE> <INDENT> self . verifyFailed ( run ( [ <STRING> , <STRING> ] ) ) ; <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Error'", "'-x'", "'missing'"]}, "err_obj": {"msg": "invalid syntax"}}], ["b808c8889b26bae1e606748eab030462", {"code_string": "def get_option_order(self):\n    \"\"\"Returns the list of (option, value) tuples processed by the\"\"\"\n    if self.option_order is None:\n        raise RuntimeError, \"'getopt()' hasn't been called yet\"\n    else:\n        return self.option_order\n", "code_toks_joined": "def get_option_order ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . option_order is None : <NEWLINE> <INDENT> raise RuntimeError , <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . option_order <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns the list of (option, value) tuples processed by the\"\"\"", "\"'getopt()' hasn't been called yet\""]}, "err_obj": {"msg": "invalid syntax"}}], ["dccc7f3717950e8b8c8ce9c3a48715fa", {"code_string": "def add_interpretation(self, interp: Interpretation) -> None\n    '''Register a new Interpretation object'''\n    assert interp.name not in self.interpretations_byname, \"Duplicate\"\n    self.interpretations.append(interp)\n    self.interpretations_byname[interp.name] = interp\n", "code_toks_joined": "def add_interpretation ( self , interp : Interpretation ) -> None <NEWLINE> <INDENT> <STRING> <NEWLINE> assert interp . name not in self . interpretations_byname , <STRING> <NEWLINE> self . interpretations . append ( interp ) <NEWLINE> self . interpretations_byname [ interp . name ] = interp <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Register a new Interpretation object'''", "\"Duplicate\""]}, "err_obj": {"msg": "invalid syntax"}}], ["f10d50e0362f425398905a233a311db9", {"code_string": "def setUp(self):\n    super(TestFirewallAgentApi, self).setUp()\n    self.api = fwaas_plugin.FirewallAgentApi('topic', 'host')\n    self.mock_fanoutcast = mock.patch.object(self.api\n        'fanout_cast').start()\n    self.mock_msg = mock.patch.object(self.api, 'make_msg').start()\n", "code_toks_joined": "def setUp ( self ) : <NEWLINE> <INDENT> super ( TestFirewallAgentApi , self ) . setUp ( ) <NEWLINE> self . api = fwaas_plugin . FirewallAgentApi ( <STRING> , <STRING> ) <NEWLINE> self . mock_fanoutcast = mock . patch . object ( self . api <NEWLINE> <INDENT> <STRING> ) . start ( ) <NEWLINE> <DEDENT> self . mock_msg = mock . patch . object ( self . api , <STRING> ) . start ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'topic'", "'host'", "'fanout_cast'", "'make_msg'"]}, "err_obj": {"msg": "invalid syntax"}}], ["ba0a9ee8935041e5a0541b2c2199c16e", {"code_string": "def layer1(self):\n    \"\"\"Get all layer1 information from device.\"\"\"\n    data = defaultdict(lambda: defaultdict(dict))\n    processed = False\n    for item in[\n        Query(self.snmp_object)\n        for Query in get_queries('layer1')]:\n        if item.supported():\n        processed = True\n        data = _add_layer1(item, data)\n    if processed is True:\n        return data\n    else:\n        return None\n", "code_toks_joined": "def layer1 ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> data = defaultdict ( lambda : defaultdict ( dict ) ) <NEWLINE> processed = False <NEWLINE> for item in [ <NEWLINE> <INDENT> Query ( self . snmp_object ) <NEWLINE> for Query in get_queries ( <STRING> ) ] : <NEWLINE> if item . supported ( ) : <NEWLINE> processed = True <NEWLINE> data = _add_layer1 ( item , data ) <NEWLINE> <DEDENT> if processed is True : <NEWLINE> <INDENT> return data <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get all layer1 information from device.\"\"\"", "'layer1'"]}, "err_obj": {"msg": "expected an indented block"}}], ["479b7c4ba853c335f92a4522dacab639", {"code_string": "def drag(self, (x0, y0), (x1, y1), duration = 0.5):\n    '''Drap screen'''\n    log.debug('drap position %s -> %s', (x0, y0), (x1, y1))\n", "code_toks_joined": "def drag ( self , ( x0 , y0 ) , ( x1 , y1 ) , duration = 0.5 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> log . debug ( <STRING> , ( x0 , y0 ) , ( x1 , y1 ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Drap screen'''", "'drap position %s -> %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["bebacbc690a7f22f1fd543dc351c0297", {"code_string": "def test_hardware_updates_does_nothing_when_exit_status_is_not_zero(self):\n    logger = self.useFixture(FakeLogger()\n    update_hardware_details(factory.make_node(), b\"garbage\", exit_status = 1)\n    self.assertEqual(\"\", logger.output)\n", "code_toks_joined": "def test_hardware_updates_does_nothing_when_exit_status_is_not_zero ( self ) : <NEWLINE> <INDENT> logger = self . useFixture ( FakeLogger ( ) <NEWLINE> update_hardware_details ( factory . make_node ( ) , <STRING> , exit_status = 1 ) <NEWLINE> self . assertEqual ( <STRING> , logger . output ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["b\"garbage\"", "\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["9089b499ce2dcd004044c3cfe792a625", {"code_string": "def main():\n    a = [] int(1, 2, 3)\n    print(a)\n    assert a[0] == 1\n    assert len(a) == 3\n    a.append(4)\n    assert len(a) == 4\n    test_pass_array_as_arg(a)\n    assert len(a) == 5\n    b = [2] int(100, 200)\n    assert b[0] == 100\n    assert b[1] == 200\n", "code_toks_joined": "def main ( ) : <NEWLINE> <INDENT> a = [ ] int ( 1 , 2 , 3 ) <NEWLINE> print ( a ) <NEWLINE> assert a [ 0 ] == 1 <NEWLINE> assert len ( a ) == 3 <NEWLINE> a . append ( 4 ) <NEWLINE> assert len ( a ) == 4 <NEWLINE> test_pass_array_as_arg ( a ) <NEWLINE> assert len ( a ) == 5 <NEWLINE> b = [ 2 ] int ( 100 , 200 ) <NEWLINE> assert b [ 0 ] == 100 <NEWLINE> assert b [ 1 ] == 200 <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["d7730bcfe5327a2fa7720902373d6f94", {"code_string": "import sys\nBaseModuleStr = \"ShareYourSystem.Standards.Objects.Initiator\")\nDecorationModule = BaseModule\n", "code_toks_joined": "import sys <NEWLINE> BaseModuleStr = <STRING> ) <NEWLINE> DecorationModule = BaseModule <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"ShareYourSystem.Standards.Objects.Initiator\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["d9bde853e2f6e35483518a072231c651", {"code_string": "def test_start(self):\n    test_interval = 120\n    cfg.CONF.set_override('evaluation_interval',\n        test_interval,\n        group = 'alarm')\n    with mock.patch('ceilometerclient.client.get_client',\n        return_value = self.api_client):\n        self.singleton.start()\n        expected = [\n        mock.call(test_interval,\n            self.singleton._evaluate_assigned_alarms,\n            0),\n            mock.call(604800, mock.ANY),\n            ]\n            actual = self.singleton.tg.add_timer.call_args_list\n            self.assertEqual(expected, actual)\n", "code_toks_joined": "def test_start ( self ) : <NEWLINE> <INDENT> test_interval = 120 <NEWLINE> cfg . CONF . set_override ( <STRING> , <NEWLINE> <INDENT> test_interval , <NEWLINE> group = <STRING> ) <NEWLINE> <DEDENT> with mock . patch ( <STRING> , <NEWLINE> <INDENT> return_value = self . api_client ) : <NEWLINE> self . singleton . start ( ) <NEWLINE> expected = [ <NEWLINE> mock . call ( test_interval , <NEWLINE> <INDENT> self . singleton . _evaluate_assigned_alarms , <NEWLINE> 0 ) , <NEWLINE> mock . call ( 604800 , mock . ANY ) , <NEWLINE> ] <NEWLINE> actual = self . singleton . tg . add_timer . call_args_list <NEWLINE> self . assertEqual ( expected , actual ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'evaluation_interval'", "'alarm'", "'ceilometerclient.client.get_client'"]}, "err_obj": {"msg": "unexpected indent"}}], ["ede68054f553f23d2e4cefb7a7a71311", {"code_string": "def get_raw_data(self, endpoint):\n    req = urllib2.urlopen(urlparse.urljoin(self.base_url, endpoint))\n        res = req.read()\n        req.close()\n        data = json.loads(res)\n        return data\n", "code_toks_joined": "def get_raw_data ( self , endpoint ) : <NEWLINE> <INDENT> req = urllib2 . urlopen ( urlparse . urljoin ( self . base_url , endpoint ) ) <NEWLINE> <INDENT> res = req . read ( ) <NEWLINE> req . close ( ) <NEWLINE> data = json . loads ( res ) <NEWLINE> return data <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["afc86e6c016f388b1af204530369267c", {"code_string": "def _unlock(self, req, id, body):\n    \"\"\"Unlock a server instance.\"\"\"\n    context = req.environ['nova.context']\n    authorize(context, 'unlock')\n    try:\n        instance = self.compute_api.get(context, id, want_objects = True)\n        self.compute_api.unlock(context, instance)\n    except exception.InstanceNotFound as e:\n        raise exc.HTTPNotFound(explanation = e.format_message()\n    return webob.Response(status_int = 202)\n", "code_toks_joined": "def _unlock ( self , req , id , body ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> context = req . environ [ <STRING> ] <NEWLINE> authorize ( context , <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> instance = self . compute_api . get ( context , id , want_objects = True ) <NEWLINE> self . compute_api . unlock ( context , instance ) <NEWLINE> <DEDENT> except exception . InstanceNotFound as e : <NEWLINE> <INDENT> raise exc . HTTPNotFound ( explanation = e . format_message ( ) <NEWLINE> <DEDENT> return webob . Response ( status_int = 202 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Unlock a server instance.\"\"\"", "'nova.context'", "'unlock'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["862b572e388c6da1b695b4083730633a", {"code_string": "def run_server_cmds(self):\n    self.server = Oneline_V2_CommandLine_Server()\n    for i in self.server_cmds:\n    self.process_cmd(self.server, i)\n", "code_toks_joined": "def run_server_cmds ( self ) : <NEWLINE> <INDENT> self . server = Oneline_V2_CommandLine_Server ( ) <NEWLINE> for i in self . server_cmds : <NEWLINE> self . process_cmd ( self . server , i ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["6b5c87c14e171d97a1f9f705d67fd6b5", {"code_string": "def test_help(self):\n    \"\"\"Test that client is not created for help and bash complete\"\"\"\n    for command in('-h',\n        '--help',\n        'help',\n        'help workbook-list',\n        'bash-completion'):\n        with mock.patch('mistralclient.api.client.client') as client_mock:\n        self.shell(command)\n        self.assertFalse(client_mock.called)\n", "code_toks_joined": "def test_help ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for command in ( <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ) : <NEWLINE> with mock . patch ( <STRING> ) as client_mock : <NEWLINE> self . shell ( command ) <NEWLINE> self . assertFalse ( client_mock . called ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Test that client is not created for help and bash complete\"\"\"", "'-h'", "'--help'", "'help'", "'help workbook-list'", "'bash-completion'", "'mistralclient.api.client.client'"]}, "err_obj": {"msg": "expected an indented block"}}], ["c6fb07828e7a547bdbb3e4999a167153", {"code_string": "def move_right(i, pos, car):\n    free_col = car.length + i\n    if free_col < dimension:\n    mk_transition(car.base, free_col, i, i + 1, pos)\n", "code_toks_joined": "def move_right ( i , pos , car ) : <NEWLINE> <INDENT> free_col = car . length + i <NEWLINE> if free_col < dimension : <NEWLINE> mk_transition ( car . base , free_col , i , i + 1 , pos ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["c5c7557eb973dae22a735d5c99bbd47e", {"code_string": "def next_tasks(self):\n    \"\"\"Find the list of tasks and associated media eligible for processing.\"\"\"\n    LOG.debug('finding next tasks...')\n    for task in self.tasks:\n        LOG.debug('checking task: %s', task)\n        for mf in list(self.dbapi.get_medias_by(self.torrent.torrent_id,\n            missing = False,\n            skipped = False)):\n            LOG.debug('test media actionable %s', mf)\n            if task.is_actionable(mf):\n            LOG.debug('task actionable for media: %s', mf)\n            yield task(mf)\n", "code_toks_joined": "def next_tasks ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> LOG . debug ( <STRING> ) <NEWLINE> for task in self . tasks : <NEWLINE> <INDENT> LOG . debug ( <STRING> , task ) <NEWLINE> for mf in list ( self . dbapi . get_medias_by ( self . torrent . torrent_id , <NEWLINE> <INDENT> missing = False , <NEWLINE> skipped = False ) ) : <NEWLINE> LOG . debug ( <STRING> , mf ) <NEWLINE> if task . is_actionable ( mf ) : <NEWLINE> LOG . debug ( <STRING> , mf ) <NEWLINE> yield task ( mf ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Find the list of tasks and associated media eligible for processing.\"\"\"", "'finding next tasks...'", "'checking task: %s'", "'test media actionable %s'", "'task actionable for media: %s'"]}, "err_obj": {"msg": "expected an indented block"}}], ["41f456e28cf2beedb71e4e59cbc2206c", {"code_string": "def _onCharsetError(self):\n    self.newDialog.statusNotificationLabel.setText(QApplication.translate('GeoCsvNewController', 'not utf8 encoded'))\n    self.newDialog.charsetDropDown.addItems(CharsetList.charsetList)\n    self.newDialog.charsetDropDown.setCurrentIndex(CharsetList.charsetList.index(\"latin_1\")\n    self._showCharsetWidget()\n", "code_toks_joined": "def _onCharsetError ( self ) : <NEWLINE> <INDENT> self . newDialog . statusNotificationLabel . setText ( QApplication . translate ( <STRING> , <STRING> ) ) <NEWLINE> self . newDialog . charsetDropDown . addItems ( CharsetList . charsetList ) <NEWLINE> self . newDialog . charsetDropDown . setCurrentIndex ( CharsetList . charsetList . index ( <STRING> ) <NEWLINE> self . _showCharsetWidget ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'GeoCsvNewController'", "'not utf8 encoded'", "\"latin_1\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["1e78fb7f2383e6d2c93f3df93acde725", {"code_string": "def haptrans((e, d)):\n    if e[0] == d[1]:\n        return float(e[3]['weight']) / float(sum(T[0].node[e[0]]['hap'].itervalues()))\n    else:\n        return 0.0\n", "code_toks_joined": "def haptrans ( ( e , d ) ) : <NEWLINE> <INDENT> if e [ 0 ] == d [ 1 ] : <NEWLINE> <INDENT> return float ( e [ 3 ] [ <STRING> ] ) / float ( sum ( T [ 0 ] . node [ e [ 0 ] ] [ <STRING> ] . itervalues ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0.0 <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'weight'", "'hap'"]}, "err_obj": {"msg": "invalid syntax"}}], ["5559de0f262e844bf4501771e0291dd5", {"code_string": "class AutoRestParameterFlatteningConfiguration(Configuration):\n    \"\"\"Configuration for AutoRestParameterFlattening\"\"\"\n    def __init__(\n        self, base_url = None, filepath = None):\n        if not base_url:\n        base_url = 'http://localhost'\n        super(AutoRestParameterFlatteningConfiguration, self).__init__(base_url, filepath)\n        self.add_user_agent('autorestparameterflattening/{}'.format(VERSION))\n", "code_toks_joined": "class AutoRestParameterFlatteningConfiguration ( Configuration ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( <NEWLINE> <INDENT> self , base_url = None , filepath = None ) : <NEWLINE> if not base_url : <NEWLINE> base_url = <STRING> <NEWLINE> super ( AutoRestParameterFlatteningConfiguration , self ) . __init__ ( base_url , filepath ) <NEWLINE> self . add_user_agent ( <STRING> . format ( VERSION ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Configuration for AutoRestParameterFlattening\"\"\"", "'http://localhost'", "'autorestparameterflattening/{}'"]}, "err_obj": {"msg": "expected an indented block"}}], ["23a8fc8bf443ed50be3fe246ebe15974", {"code_string": "def load_image(filename, cache = 1):\n    if type(filename) == StringType:\n    image = get_cached(filename)\n    if image:\n        return image\n    image = PIL.Image.open(filename)\n    if type(filename) != StringType:\n    filename = ''\n    return ImageData(image, filename = filename, cache = cache)\n", "code_toks_joined": "def load_image ( filename , cache = 1 ) : <NEWLINE> <INDENT> if type ( filename ) == StringType : <NEWLINE> image = get_cached ( filename ) <NEWLINE> if image : <NEWLINE> <INDENT> return image <NEWLINE> <DEDENT> image = PIL . Image . open ( filename ) <NEWLINE> if type ( filename ) != StringType : <NEWLINE> filename = <STRING> <NEWLINE> return ImageData ( image , filename = filename , cache = cache ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''"]}, "err_obj": {"msg": "expected an indented block"}}], ["b917f2a12598fedf47533409223c5a2b", {"code_string": "def __init__(self)\n    self.steppableTemplatesDict = {}\n    self.initSteppableTemplates()\n", "code_toks_joined": "def __init__ ( self ) <NEWLINE> <INDENT> self . steppableTemplatesDict = { } <NEWLINE> self . initSteppableTemplates ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["14c68138f2c91feaedbb29234fa88082", {"code_string": "def upload_pypi():\n    import os\n    file = '~/.pypi-password'\n    try:\n        with open(os.path.abspath(os.path.expanduser(file))) as f\n            password = f.read()\n    except FileNotFoundError:\n        password = None\n    finally:\n        if not password:\n            raise Exception(\"Could not find the pypi password in \" + file)\n        else:\n            run('twine upload --config .pypirc build/dist/* -p ' + password)\n", "code_toks_joined": "def upload_pypi ( ) : <NEWLINE> <INDENT> import os <NEWLINE> file = <STRING> <NEWLINE> try : <NEWLINE> <INDENT> with open ( os . path . abspath ( os . path . expanduser ( file ) ) ) as f <NEWLINE> <INDENT> password = f . read ( ) <NEWLINE> <DEDENT> <DEDENT> except FileNotFoundError : <NEWLINE> <INDENT> password = None <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> if not password : <NEWLINE> <INDENT> raise Exception ( <STRING> + file ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> run ( <STRING> + password ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'~/.pypi-password'", "\"Could not find the pypi password in \"", "'twine upload --config .pypirc build/dist/* -p '"]}, "err_obj": {"msg": "invalid syntax"}}], ["eb661214a68924441accc5e9e1de4663", {"code_string": "def _heard(self, line):\n    \"\"\"show console ui heard contents\"\"\"\n    print(\"\\033[%dm\\033[%dm\" %(self.heard_fg, self.heard_bg),\n    print(\"%s\" % line.rjust(self.ui_width), )\n    print(\"\\033[0m\")\n", "code_toks_joined": "def _heard ( self , line ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> % ( self . heard_fg , self . heard_bg ) , <NEWLINE> print ( <STRING> % line . rjust ( self . ui_width ) , ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"show console ui heard contents\"\"\"", "\"\\033[%dm\\033[%dm\"", "\"%s\"", "\"\\033[0m\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["6fcfc98fdd7e271d861a1298cc785cc0", {"code_string": "def openFile(self, metainfo):\n    'Create/Open File to Write'\n    self.file_pointer = open(metainfo.info['name'], \"wb+\")\n    while True:\n        self.data_buffer = self.file_pointer.read(self.piece_size)\n        if len(self.data_buffer) < self.piece_size:\n        break\n        hash_obj = hashlib.sha1()\n        hash_obj.update(self.data_buffer)\n        temp_piece = hash_obj.digest()\n        if temp_piece == self.piece_hash[self.piece_index]:\n            self.piece_index += 1\n", "code_toks_joined": "def openFile ( self , metainfo ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . file_pointer = open ( metainfo . info [ <STRING> ] , <STRING> ) <NEWLINE> while True : <NEWLINE> <INDENT> self . data_buffer = self . file_pointer . read ( self . piece_size ) <NEWLINE> if len ( self . data_buffer ) < self . piece_size : <NEWLINE> break <NEWLINE> hash_obj = hashlib . sha1 ( ) <NEWLINE> hash_obj . update ( self . data_buffer ) <NEWLINE> temp_piece = hash_obj . digest ( ) <NEWLINE> if temp_piece == self . piece_hash [ self . piece_index ] : <NEWLINE> <INDENT> self . piece_index += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Create/Open File to Write'", "'name'", "\"wb+\""]}, "err_obj": {"msg": "expected an indented block"}}], ["42e3ec57eae4a2bf7e5f1992f79d43a6", {"code_string": "def GetFileSystemTypeIndicators(cls, path_spec, resolver_context = None):\n    \"\"\"Determines if a file contains a supported file system types.\"\"\"\n    if(cls._file_system_remainder_list is None or\n        cls._file_system_store is None):\n        specification_store, remainder_list = cls._GetSpecificationStore(\n            definitions.FORMAT_CATEGORY_FILE_SYSTEM)\n            cls._file_system_remainder_list = remainder_list\n            cls._file_system_store = specification_store\n    if cls._file_system_scanner is None:\n        cls._file_system_scanner = cls._GetSignatureScanner(\n            cls._file_system_store)\n    return cls._GetTypeIndicators(\n        cls._file_system_scanner, cls._file_system_store,\n        cls._file_system_remainder_list, path_spec,\n        resolver_context = resolver_context)\n", "code_toks_joined": "def GetFileSystemTypeIndicators ( cls , path_spec , resolver_context = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( cls . _file_system_remainder_list is None or <NEWLINE> <INDENT> cls . _file_system_store is None ) : <NEWLINE> specification_store , remainder_list = cls . _GetSpecificationStore ( <NEWLINE> <INDENT> definitions . FORMAT_CATEGORY_FILE_SYSTEM ) <NEWLINE> cls . _file_system_remainder_list = remainder_list <NEWLINE> cls . _file_system_store = specification_store <NEWLINE> <DEDENT> <DEDENT> if cls . _file_system_scanner is None : <NEWLINE> <INDENT> cls . _file_system_scanner = cls . _GetSignatureScanner ( <NEWLINE> <INDENT> cls . _file_system_store ) <NEWLINE> <DEDENT> <DEDENT> return cls . _GetTypeIndicators ( <NEWLINE> <INDENT> cls . _file_system_scanner , cls . _file_system_store , <NEWLINE> cls . _file_system_remainder_list , path_spec , <NEWLINE> resolver_context = resolver_context ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Determines if a file contains a supported file system types.\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["6d46c07f34914ef14e2e16c1e90fc932", {"code_string": "def display(uri, response):\n    \"\"\"Prints the uri and HSTS header.\"\"\"\n    print({uri: list(response.headers.getRawHeaders(\n        'Strict-Transport-Security', []))}\n", "code_toks_joined": "def display ( uri , response ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( { uri : list ( response . headers . getRawHeaders ( <NEWLINE> <INDENT> <STRING> , [ ] ) ) } <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Prints the uri and HSTS header.\"\"\"", "'Strict-Transport-Security'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["0f0948e4cf6cec59b438fcc82247a7ab", {"code_string": "def listen(self, namespace):\n    res = sniff(lfilter = lambda(packet): IPv6 in packet,\n        prn = lambda(packet): self.callback(packet, namespace),\n        stop_filter = self.stopfilter,\n        store = 0)\n    return res\n", "code_toks_joined": "def listen ( self , namespace ) : <NEWLINE> <INDENT> res = sniff ( lfilter = lambda ( packet ) : IPv6 in packet , <NEWLINE> <INDENT> prn = lambda ( packet ) : self . callback ( packet , namespace ) , <NEWLINE> stop_filter = self . stopfilter , <NEWLINE> store = 0 ) <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["10fbc77fd0ad42278893f8be1727672a", {"code_string": "def process_data_events(self, to_tuple = False, auto_decode = False):\n    \"\"\"Consume inbound messages.\"\"\"\n    if not self.consumer_callback:\n        raise AMQPChannelError('no consumer_callback defined')\n    for message in self.build_inbound_messages(break_on_empty = True,\n        to_tuple = to_tuple,\n        auto_decode = auto_decode):\n        if self._die.value != 0:\n        return\n        if to_tuple:\n        self.consumer_callback(* message)\n        continue\n        self.consumer_callback(message)\n    sleep(IDLE_WAIT)\n", "code_toks_joined": "def process_data_events ( self , to_tuple = False , auto_decode = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not self . consumer_callback : <NEWLINE> <INDENT> raise AMQPChannelError ( <STRING> ) <NEWLINE> <DEDENT> for message in self . build_inbound_messages ( break_on_empty = True , <NEWLINE> <INDENT> to_tuple = to_tuple , <NEWLINE> auto_decode = auto_decode ) : <NEWLINE> if self . _die . value != 0 : <NEWLINE> return <NEWLINE> if to_tuple : <NEWLINE> self . consumer_callback ( * message ) <NEWLINE> continue <NEWLINE> self . consumer_callback ( message ) <NEWLINE> <DEDENT> sleep ( IDLE_WAIT ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Consume inbound messages.\"\"\"", "'no consumer_callback defined'"]}, "err_obj": {"msg": "expected an indented block"}}], ["718a8681c617f13cfa6fdfed07a95c7f", {"code_string": "__author__ = 'Administrator'\nimport string\nN = 16\nM = 24\nA = [([0.0] * N) for i in range(N)]\nB = [([0.0] * M) for i in range(N)]\nPI = [0.0 for i in range(N)]\nfr = open(\"E:\\\\PyProj\\\\Others\\\\9-1\\\\rite_HMM_data_train.txt\")\nsentence = fr.readline()\npos = fr.readline()\nevent = fr.readline()\nwhile(sentence):\n    poss = pos.strip().split(' ')\n    events = event.strip().split(' ')\n    lp = len(poss)\n    le = len(events)\n    if(lp != le):\n        print(sentence)\n    length = lp\n    PI[string.atoi(events[0])] += 1\n    for i in range(length - 1):\n        A[string.atoi(events[i])][string.atoi(events[i + 1])] += 1\n    for i in range(length):\n        B[string.atoi(events[i])][string.atoi(poss[i])] += 1\n    sentence = fr.readline()\n    pos = fr.readline()\n    event = fr.readline()\nfr.close()\nfor i in range(N):\n    s = sum(A[i])\n    for j in range(N):\n        A[i][j] /= s\nfor i in range(N):\n    s = sum(B[i])\n    for j in range(M):\n        B[i][j] /= s\ns = sum(PI)\nfor i in range(N):\n    PI[i] /= s\nfor i in range(N):\n    print('State')\n    print('Pi ', PI[i])\n    print('A', )\n    for j in range(N):\n        print(' ' + str(A[i][j]), )\n    print('\\nIntegerOPDF [',\n    for j in range(M):\n        print(' ' + str(B[i][j]), )\n    print(' ]\\n')\n", "code_toks_joined": "__author__ = <STRING> <NEWLINE> import string <NEWLINE> N = 16 <NEWLINE> M = 24 <NEWLINE> A = [ ( [ 0.0 ] * N ) for i in range ( N ) ] <NEWLINE> B = [ ( [ 0.0 ] * M ) for i in range ( N ) ] <NEWLINE> PI = [ 0.0 for i in range ( N ) ] <NEWLINE> fr = open ( <STRING> ) <NEWLINE> sentence = fr . readline ( ) <NEWLINE> pos = fr . readline ( ) <NEWLINE> event = fr . readline ( ) <NEWLINE> while ( sentence ) : <NEWLINE> <INDENT> poss = pos . strip ( ) . split ( <STRING> ) <NEWLINE> events = event . strip ( ) . split ( <STRING> ) <NEWLINE> lp = len ( poss ) <NEWLINE> le = len ( events ) <NEWLINE> if ( lp != le ) : <NEWLINE> <INDENT> print ( sentence ) <NEWLINE> <DEDENT> length = lp <NEWLINE> PI [ string . atoi ( events [ 0 ] ) ] += 1 <NEWLINE> for i in range ( length - 1 ) : <NEWLINE> <INDENT> A [ string . atoi ( events [ i ] ) ] [ string . atoi ( events [ i + 1 ] ) ] += 1 <NEWLINE> <DEDENT> for i in range ( length ) : <NEWLINE> <INDENT> B [ string . atoi ( events [ i ] ) ] [ string . atoi ( poss [ i ] ) ] += 1 <NEWLINE> <DEDENT> sentence = fr . readline ( ) <NEWLINE> pos = fr . readline ( ) <NEWLINE> event = fr . readline ( ) <NEWLINE> <DEDENT> fr . close ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = sum ( A [ i ] ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> A [ i ] [ j ] /= s <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> s = sum ( B [ i ] ) <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> B [ i ] [ j ] /= s <NEWLINE> <DEDENT> <DEDENT> s = sum ( PI ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> PI [ i ] /= s <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> , PI [ i ] ) <NEWLINE> print ( <STRING> , ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> print ( <STRING> + str ( A [ i ] [ j ] ) , ) <NEWLINE> <DEDENT> print ( <STRING> , <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> print ( <STRING> + str ( B [ i ] [ j ] ) , ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Administrator'", "\"E:\\\\PyProj\\\\Others\\\\9-1\\\\rite_HMM_data_train.txt\"", "' '", "' '", "'State'", "'Pi '", "'A'", "' '", "'\\nIntegerOPDF ['", "' '", "' ]\\n'"]}, "window_span": [456, 494], "err_obj": {"msg": "unbalanced (){}[]"}}], ["8a6660b8ebc41329252b9046b2c8f278", {"code_string": "def test_config_check_success(self):\n    '''Test that a 0-config passes'''\n    proc = test_base.TimeoutRunner([\n        self.binary,\n        \"--config_check\",\n        \"--database_path=%s\" %(self.dbpath),\n        \"--config_path=%s/test.config\" % test_base.SCRIPT_DIR\n", "code_toks_joined": "def test_config_check_success ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> proc = test_base . TimeoutRunner ( [ <NEWLINE> <INDENT> self . binary , <NEWLINE> <STRING> , <NEWLINE> <STRING> % ( self . dbpath ) , <NEWLINE> <STRING> % test_base . SCRIPT_DIR <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Test that a 0-config passes'''", "\"--config_check\"", "\"--database_path=%s\"", "\"--config_path=%s/test.config\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c62a8427dcfabb230b4beeb0438b9ba1", {"code_string": "def download(url, filename, to_dir):\n    \"\"\"Actually does the call and download given a URL and desired output\"\"\"\n    new_file = os.path.join(to_dir, filename)\n    try:\n        conn = PLOTEXTRACTOR_OPENER.open(url)\n        response = conn.read()\n        conn.close()\n        new_file_fd = open(new_file, 'w')\n        new_file_fd.write(response)\n        new_file_fd.close()\n        write_message('Downloaded to ' + new_file)\n        return True\n    except(IOError, urllib2.URLError), e:\n        write_message('Error downloading from %s: \\n%s\\n' %(url, str(e)))\n        return False\n", "code_toks_joined": "def download ( url , filename , to_dir ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> new_file = os . path . join ( to_dir , filename ) <NEWLINE> try : <NEWLINE> <INDENT> conn = PLOTEXTRACTOR_OPENER . open ( url ) <NEWLINE> response = conn . read ( ) <NEWLINE> conn . close ( ) <NEWLINE> new_file_fd = open ( new_file , <STRING> ) <NEWLINE> new_file_fd . write ( response ) <NEWLINE> new_file_fd . close ( ) <NEWLINE> write_message ( <STRING> + new_file ) <NEWLINE> return True <NEWLINE> <DEDENT> except ( IOError , urllib2 . URLError ) , e : <NEWLINE> <INDENT> write_message ( <STRING> % ( url , str ( e ) ) ) <NEWLINE> return False <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Actually does the call and download given a URL and desired output\"\"\"", "'w'", "'Downloaded to '", "'Error downloading from %s: \\n%s\\n'"]}, "err_obj": {"msg": "invalid syntax"}}], ["45fe541fc006ce77ad88e2fb1aa0de13", {"code_string": "def _shutdown(self, * args, ** kwargs):\n    try:\n        os.remove(deluge.configmanager.get_config_dir(\"deluged.pid\"))\n    except Exception, e:\n        log.exception(e)\n        log.error(\"Error removing deluged.pid!\")\n    component.shutdown()\n    try:\n        reactor.stop()\n    except twisted.internet.error.ReactorNotRunning:\n        log.debug(\"Tried to stop the reactor but it is not running..\")\n", "code_toks_joined": "def _shutdown ( self , * args , ** kwargs ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> os . remove ( deluge . configmanager . get_config_dir ( <STRING> ) ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> log . exception ( e ) <NEWLINE> log . error ( <STRING> ) <NEWLINE> <DEDENT> component . shutdown ( ) <NEWLINE> try : <NEWLINE> <INDENT> reactor . stop ( ) <NEWLINE> <DEDENT> except twisted . internet . error . ReactorNotRunning : <NEWLINE> <INDENT> log . debug ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"deluged.pid\"", "\"Error removing deluged.pid!\"", "\"Tried to stop the reactor but it is not running..\""]}, "err_obj": {"msg": "invalid syntax"}}], ["8307806d41c84a787d28d293c0dd1f5b", {"code_string": "def getLiveMergeSupport():\n    \"\"\"Determine if libvirt provides the necessary features to enable live merge.\"\"\"\n    for flag in('VIR_DOMAIN_BLOCK_COMMIT_RELATIVE',\n        'VIR_DOMAIN_EVENT_ID_BLOCK_JOB_2',\n        'VIR_DOMAIN_BLOCK_COMMIT_ACTIVE'):\n        if not hasattr(libvirt, flag):\n        logging.debug(\"libvirt is missing '%s': live merge disabled\", flag)\n        return False\n    return True\n", "code_toks_joined": "def getLiveMergeSupport ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for flag in ( <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ) : <NEWLINE> if not hasattr ( libvirt , flag ) : <NEWLINE> logging . debug ( <STRING> , flag ) <NEWLINE> return False <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Determine if libvirt provides the necessary features to enable live merge.\"\"\"", "'VIR_DOMAIN_BLOCK_COMMIT_RELATIVE'", "'VIR_DOMAIN_EVENT_ID_BLOCK_JOB_2'", "'VIR_DOMAIN_BLOCK_COMMIT_ACTIVE'", "\"libvirt is missing '%s': live merge disabled\""]}, "err_obj": {"msg": "expected an indented block"}}], ["ea9d8a3af3820f087ec3a764fd5aef2f", {"code_string": "class Flag1(smach.State):\n    def __init__(self):\n        smach.State.__init__(self, outcomes = ['outcome1', 'outcome2'])\n    def execute(self, userdata):\n    global receivedflag1\n    receivedflag1 = 0\n    rospy.sleep(0.05)\n    rospy.Subscriber(\"robot_gripper\", Int8, callback1)\n    if receivedflag1 == 1:\n    return 'outcome1'\n        else:\n    return 'outcome2'\n", "code_toks_joined": "class Flag1 ( smach . State ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> smach . State . __init__ ( self , outcomes = [ <STRING> , <STRING> ] ) <NEWLINE> <DEDENT> def execute ( self , userdata ) : <NEWLINE> global receivedflag1 <NEWLINE> receivedflag1 = 0 <NEWLINE> rospy . sleep ( 0.05 ) <NEWLINE> rospy . Subscriber ( <STRING> , Int8 , callback1 ) <NEWLINE> if receivedflag1 == 1 : <NEWLINE> return <STRING> <NEWLINE> <INDENT> else : <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'outcome1'", "'outcome2'", "\"robot_gripper\"", "'outcome1'", "'outcome2'"]}, "err_obj": {"msg": "expected an indented block"}}], ["5a70b6b39300101e4191ff6b84b3a4de", {"code_string": "def indirectTrust(sn, userA, userB):\n    count = 0\n    length = 1\n    while length < maxLength:\n    path = sn.getSimplePath(userA, userB, 3)\n    print(path)\n    for a in path:\n        print(a)\n", "code_toks_joined": "def indirectTrust ( sn , userA , userB ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> length = 1 <NEWLINE> while length < maxLength : <NEWLINE> path = sn . getSimplePath ( userA , userB , 3 ) <NEWLINE> print ( path ) <NEWLINE> for a in path : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["b1d0dfba05edb2a139526d5c7f5cbd05", {"code_string": "def detach(self, sr_uuid):\n    if self._checkmount():\n        try:\n            util.SMlog(\"Aborting GC/coalesce\")\n            cleanup.abort(self.uuid)\n            os.chdir(SR.MOUNT_BASE)\n            util.pread([\"umount\", self.path])\n            os.rmdir(self.path)\n        except Exception, e:\n            raise xs_errors.XenError('SRInUse', opterr = str(e))\n    self.attached = False\n", "code_toks_joined": "def detach ( self , sr_uuid ) : <NEWLINE> <INDENT> if self . _checkmount ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> util . SMlog ( <STRING> ) <NEWLINE> cleanup . abort ( self . uuid ) <NEWLINE> os . chdir ( SR . MOUNT_BASE ) <NEWLINE> util . pread ( [ <STRING> , self . path ] ) <NEWLINE> os . rmdir ( self . path ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> raise xs_errors . XenError ( <STRING> , opterr = str ( e ) ) <NEWLINE> <DEDENT> <DEDENT> self . attached = False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Aborting GC/coalesce\"", "\"umount\"", "'SRInUse'"]}, "err_obj": {"msg": "invalid syntax"}}], ["4b73a7d8cb9962ffbaab4831b802f858", {"code_string": "def zip_annotations(procedure, default = UNDEFINED):\n    \"\"\"Zip each argument name of procedure to its annotation.\"\"\"\n    if default is not UNDEFINED:\n    ann = annotations(procedure)\n    return((n, ann.get(n, default)) for n in annotatable_names(procedure))\n    else:\n    ann = annotations(procedure)\n    return(\n        (n, ann[n])\n        for n in annotatable_names(procedure)\n        if n in ann\n        )\n", "code_toks_joined": "def zip_annotations ( procedure , default = UNDEFINED ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if default is not UNDEFINED : <NEWLINE> ann = annotations ( procedure ) <NEWLINE> return ( ( n , ann . get ( n , default ) ) for n in annotatable_names ( procedure ) ) <NEWLINE> else : <NEWLINE> ann = annotations ( procedure ) <NEWLINE> return ( <NEWLINE> <INDENT> ( n , ann [ n ] ) <NEWLINE> for n in annotatable_names ( procedure ) <NEWLINE> if n in ann <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Zip each argument name of procedure to its annotation.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["d00ef72e98b3bfb9ee1d9a678acec45c", {"code_string": "class TestChannelModelCreator(SingleSlopeChannelModelCreator):\n    def __init__(self):\n    SingleSlopeChannelModelCreator.__init__(self, \"41.9 dB\", \"23.8 dB\")\n", "code_toks_joined": "class TestChannelModelCreator ( SingleSlopeChannelModelCreator ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> SingleSlopeChannelModelCreator . __init__ ( self , <STRING> , <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"41.9 dB\"", "\"23.8 dB\""]}, "err_obj": {"msg": "expected an indented block"}}], ["cfd049bac3555508c309db6b5b352e00", {"code_string": "def test_curricula_for_term(self):\n    with self.settings(\n        RESTCLIENTS_SWS_DAO_CLASS = 'restclients.dao_implementation.sws.File',\n        RESTCLIENTS_PWS_DAO_CLASS = 'restclients.dao_implementation.pws.File'):\n        term = Term(quarter = 'winter', year = 2013)\n        curricula = get_curricula_by_term(term)\n        self.assertEquals(len(curricula), 423)\n        self.assertRaises(DataFailureException,\n            get_curricula_by_term,\n            Term(quarter = 'spring', year = 2012))\n            self.assertRaises(DataFailureException,\n            get_curricula_by_term,\n            Term(quarter = 'autumn', year = 2012))\n", "code_toks_joined": "def test_curricula_for_term ( self ) : <NEWLINE> <INDENT> with self . settings ( <NEWLINE> <INDENT> RESTCLIENTS_SWS_DAO_CLASS = <STRING> , <NEWLINE> RESTCLIENTS_PWS_DAO_CLASS = <STRING> ) : <NEWLINE> term = Term ( quarter = <STRING> , year = 2013 ) <NEWLINE> curricula = get_curricula_by_term ( term ) <NEWLINE> self . assertEquals ( len ( curricula ) , 423 ) <NEWLINE> self . assertRaises ( DataFailureException , <NEWLINE> <INDENT> get_curricula_by_term , <NEWLINE> Term ( quarter = <STRING> , year = 2012 ) ) <NEWLINE> self . assertRaises ( DataFailureException , <NEWLINE> get_curricula_by_term , <NEWLINE> Term ( quarter = <STRING> , year = 2012 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'restclients.dao_implementation.sws.File'", "'restclients.dao_implementation.pws.File'", "'winter'", "'spring'", "'autumn'"]}, "err_obj": {"msg": "unexpected indent"}}], ["5a28c435508c6e89a38763d0b1b1068b", {"code_string": "def setup(self):\n    self.bug_id = 1221569\n    self.bug_description = 'need to back out the gecko version number bump from b2g44'\n    file_path = os.path.dirname(os.path.abspath(__file__) + '/resources/test.config.ok.yml'\n    with open(file_path) as f:\n        self.config = Config(f)\n", "code_toks_joined": "def setup ( self ) : <NEWLINE> <INDENT> self . bug_id = 1221569 <NEWLINE> self . bug_description = <STRING> <NEWLINE> file_path = os . path . dirname ( os . path . abspath ( __file__ ) + <STRING> <NEWLINE> with open ( file_path ) as f : <NEWLINE> <INDENT> self . config = Config ( f ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'need to back out the gecko version number bump from b2g44'", "'/resources/test.config.ok.yml'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["047af8e9c16a901702b88398c5cd71da", {"code_string": "class WebLocParser(QCoreApplication):\n    def __init__(self):\n        super(QCoreApplication, self).__init__(sys.argv)\n        self.reset()\n    def parseAndOpen(self, fileName):\n        try:\n        plist = plistlib.readPlist(fileName)\n        if 'URL' in plist:\n            KToolInvocation.invokeBrowser(plist['URL'])\n        except:\n            sys.stderr.write(\"Invalid webloc file: %s\\n\" % fileName)\n    def reset(self):\n    pass\n", "code_toks_joined": "class WebLocParser ( QCoreApplication ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> super ( QCoreApplication , self ) . __init__ ( sys . argv ) <NEWLINE> self . reset ( ) <NEWLINE> <DEDENT> def parseAndOpen ( self , fileName ) : <NEWLINE> <INDENT> try : <NEWLINE> plist = plistlib . readPlist ( fileName ) <NEWLINE> if <STRING> in plist : <NEWLINE> <INDENT> KToolInvocation . invokeBrowser ( plist [ <STRING> ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> sys . stderr . write ( <STRING> % fileName ) <NEWLINE> <DEDENT> <DEDENT> def reset ( self ) : <NEWLINE> pass <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'URL'", "'URL'", "\"Invalid webloc file: %s\\n\""]}, "err_obj": {"msg": "expected an indented block"}}], ["6031614c221ff2e0dc57948a4dcd76e9", {"code_string": "def thumbnails(self):\n    _thumbnails = {}\n    for name, opts in Image.DEFAULT_THUMBNAILS.items():\n        try:\n            opts.update({'subject_location': self.subject_location})\n            thumb = self.file.get_thumbnail(opts)\n            _thumbnails[name] = thumb.url\n        except Exception, e:\n            if filer_settings.FILER_ENABLE_LOGGING:\n                logger.error('Error while generating thumbnail: %s', e)\n            if filer_settings.FILER_DEBUG:\n                raise e\n    return _thumbnails\n", "code_toks_joined": "def thumbnails ( self ) : <NEWLINE> <INDENT> _thumbnails = { } <NEWLINE> for name , opts in Image . DEFAULT_THUMBNAILS . items ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> opts . update ( { <STRING> : self . subject_location } ) <NEWLINE> thumb = self . file . get_thumbnail ( opts ) <NEWLINE> _thumbnails [ name ] = thumb . url <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> if filer_settings . FILER_ENABLE_LOGGING : <NEWLINE> <INDENT> logger . error ( <STRING> , e ) <NEWLINE> <DEDENT> if filer_settings . FILER_DEBUG : <NEWLINE> <INDENT> raise e <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return _thumbnails <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'subject_location'", "'Error while generating thumbnail: %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["84ec8cb67e2e6580a9e6c10d0feb7182", {"code_string": "def AutoReload(self, event):\n    reload = os.listdir(Variables.playonlinux_rep + \"/configurations/installed\")\n    if(reload != self.oldreload):\n    self.Reload(self)\n    self.oldreload = reload\n    reloadimg = os.listdir(Variables.playonlinux_rep + \"/icones/32\")\n    if(reloadimg != self.oldimg):\n    self.Reload(self)\n    self.oldimg = reloadimg\n", "code_toks_joined": "def AutoReload ( self , event ) : <NEWLINE> <INDENT> reload = os . listdir ( Variables . playonlinux_rep + <STRING> ) <NEWLINE> if ( reload != self . oldreload ) : <NEWLINE> self . Reload ( self ) <NEWLINE> self . oldreload = reload <NEWLINE> reloadimg = os . listdir ( Variables . playonlinux_rep + <STRING> ) <NEWLINE> if ( reloadimg != self . oldimg ) : <NEWLINE> self . Reload ( self ) <NEWLINE> self . oldimg = reloadimg <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"/configurations/installed\"", "\"/icones/32\""]}, "err_obj": {"msg": "expected an indented block"}}], ["c8166c3c30b3b56556d792d2d1d04708", {"code_string": "def get_ijv(self):\n    '''Get the segmentation in IJV object format'''\n    from cellprofiler.utilities.hdf5_dict import HDF5ObjectSet\n    sparse = self.__segmented.get_sparse()\n    return np.column_stack(\n        [sparse[axis] for axis in\n            HDF5ObjectSet.AXIS_Y, HDF5ObjectSet.AXIS_X,\n            HDF5ObjectSet.AXIS_LABELS])\n", "code_toks_joined": "def get_ijv ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> from cellprofiler . utilities . hdf5_dict import HDF5ObjectSet <NEWLINE> sparse = self . __segmented . get_sparse ( ) <NEWLINE> return np . column_stack ( <NEWLINE> <INDENT> [ sparse [ axis ] for axis in <NEWLINE> <INDENT> HDF5ObjectSet . AXIS_Y , HDF5ObjectSet . AXIS_X , <NEWLINE> HDF5ObjectSet . AXIS_LABELS ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Get the segmentation in IJV object format'''"]}, "err_obj": {"msg": "invalid syntax"}}], ["77ee0ea6066b2cca310922912ae8d6bd", {"code_string": "def evaluate(model, data, bptt):\n    m = len(data)\n    for j in xrange(m):\n        l, s = data[j]\n        count = [0]\n        X = s[: - 1]\n        Y = s[1: ]\n        def progress(k, n):\n            count[0] += k\n            if count[0] > 10000:\n                util.progress.print_progress_bar(\"Evaluating\", j + float(k * X.shape[1]) / n, m)\n                count[0] = count[0] % 10000\n        err, acc = util.model.validate(model, X, Y, bptt, callback = progress)\n        model.reset()\n        print(\"\\r\\033[K\",\n        print(\"{}: error={}, accuracy={}\".format(l, err, acc))\n", "code_toks_joined": "def evaluate ( model , data , bptt ) : <NEWLINE> <INDENT> m = len ( data ) <NEWLINE> for j in xrange ( m ) : <NEWLINE> <INDENT> l , s = data [ j ] <NEWLINE> count = [ 0 ] <NEWLINE> X = s [ : - 1 ] <NEWLINE> Y = s [ 1 : ] <NEWLINE> def progress ( k , n ) : <NEWLINE> <INDENT> count [ 0 ] += k <NEWLINE> if count [ 0 ] > 10000 : <NEWLINE> <INDENT> util . progress . print_progress_bar ( <STRING> , j + float ( k * X . shape [ 1 ] ) / n , m ) <NEWLINE> count [ 0 ] = count [ 0 ] % 10000 <NEWLINE> <DEDENT> <DEDENT> err , acc = util . model . validate ( model , X , Y , bptt , callback = progress ) <NEWLINE> model . reset ( ) <NEWLINE> print ( <STRING> , <NEWLINE> print ( <STRING> . format ( l , err , acc ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Evaluating\"", "\"\\r\\033[K\"", "\"{}: error={}, accuracy={}\""]}, "window_span": [159, 179], "err_obj": {"msg": "unbalanced (){}[]"}}], ["6a0167c0d4397632aaac160d2376e115", {"code_string": "def nnz_obs_names(self):\n    \"\"\"non-zero weight obs names\"\"\"\n    nz_names = []\n    for w, n in zip(self.observation_data.weight,\n        self.observation_data.obsnme):\n        if w > 0.0:\n        nz_names.append(n)\n    return nz_names\n", "code_toks_joined": "def nnz_obs_names ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> nz_names = [ ] <NEWLINE> for w , n in zip ( self . observation_data . weight , <NEWLINE> <INDENT> self . observation_data . obsnme ) : <NEWLINE> if w > 0.0 : <NEWLINE> nz_names . append ( n ) <NEWLINE> <DEDENT> return nz_names <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"non-zero weight obs names\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["08abd7c54a3d4e37c7fcf50120d2dd82", {"code_string": "class MyApplication(Gtk.Application):\n    def __init__(self):\n    Gtk.Application.__init__(self)\n    def do_activate(self):\n    try:\n        win = MyWindow(self)\n        if not win.failed:\n    win.show_all()\n    except:\n        traceback.print_exc()\n        sys.exit(1)\n        else:\n        if win.failed:\n    sys.exit(1)\n    def do_startup(self):\n        Gtk.Application.do_startup(self)\n", "code_toks_joined": "class MyApplication ( Gtk . Application ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> Gtk . Application . __init__ ( self ) <NEWLINE> def do_activate ( self ) : <NEWLINE> try : <NEWLINE> <INDENT> win = MyWindow ( self ) <NEWLINE> if not win . failed : <NEWLINE> <DEDENT> win . show_all ( ) <NEWLINE> except : <NEWLINE> <INDENT> traceback . print_exc ( ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> else : <NEWLINE> if win . failed : <NEWLINE> <DEDENT> sys . exit ( 1 ) <NEWLINE> def do_startup ( self ) : <NEWLINE> <INDENT> Gtk . Application . do_startup ( self ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["a3d3d7bded2221100dea2d4ce76c4f7c", {"code_string": "def dependency_loop(loops, t, target):\n    '''add a dependency loop to the loops dictionary'''\n    if t.sname == target:\n        return\n    if not target in loops:\n        loops[target] = set()\n    if not t.sname in loops[target]\n        loops[target].add(t.sname)\n", "code_toks_joined": "def dependency_loop ( loops , t , target ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if t . sname == target : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if not target in loops : <NEWLINE> <INDENT> loops [ target ] = set ( ) <NEWLINE> <DEDENT> if not t . sname in loops [ target ] <NEWLINE> <INDENT> loops [ target ] . add ( t . sname ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''add a dependency loop to the loops dictionary'''"]}, "err_obj": {"msg": "invalid syntax"}}], ["99ef21e24d10a42452161b56ab8c5c45", {"code_string": "def saveConnections(self):\n    self.connections.extend(self.tempconnections)\n        self.tempconnections = []\n        def discardChanges(self):\n    self.tempconnections = []\n", "code_toks_joined": "def saveConnections ( self ) : <NEWLINE> <INDENT> self . connections . extend ( self . tempconnections ) <NEWLINE> <INDENT> self . tempconnections = [ ] <NEWLINE> def discardChanges ( self ) : <NEWLINE> <DEDENT> self . tempconnections = [ ] <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["842238165e83eba80679fe532fcdc36f", {"code_string": "def test_bad_argument(self):\n    try:\n        zen.generating.barabasi_albert(10, 3, blah = 10)\n        self.fail('blah should not be accepted as a keyword argument')\n    except zen.ZenException, e:\n        pass\n", "code_toks_joined": "def test_bad_argument ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> zen . generating . barabasi_albert ( 10 , 3 , blah = 10 ) <NEWLINE> self . fail ( <STRING> ) <NEWLINE> <DEDENT> except zen . ZenException , e : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'blah should not be accepted as a keyword argument'"]}, "err_obj": {"msg": "invalid syntax"}}], ["47a23108d86726dabc71b352df136196", {"code_string": "class ApiError(Exception):\n    def __init__(self, method, route, status_code, server_message):\n        message = \"\"\"{method}{route}Return code: {status_code}n\"\"\".format(** locals()\n        super(ApiError, self).__init__(message)\n", "code_toks_joined": "class ApiError ( Exception ) : <NEWLINE> <INDENT> def __init__ ( self , method , route , status_code , server_message ) : <NEWLINE> <INDENT> message = <STRING> . format ( ** locals ( ) <NEWLINE> super ( ApiError , self ) . __init__ ( message ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"{method}{route}Return code: {status_code}n\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["b8c855b15073a0cc3e5e95bb8afda257", {"code_string": "def putline(self, line):\n    line = line + CRLF\n    if self.debugging > 1: print '*put*', self.sanitize(line)\n    self.sock.sendall(line)\n", "code_toks_joined": "def putline ( self , line ) : <NEWLINE> <INDENT> line = line + CRLF <NEWLINE> if self . debugging > 1 : print <STRING> , self . sanitize ( line ) <NEWLINE> self . sock . sendall ( line ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'*put*'"]}, "err_obj": {"msg": "invalid syntax"}}], ["d8b9dcb77f7706472df2da2e36cc7049", {"code_string": "def __init__(self, (sizeX, sizeY), kmlFile, cacheUrl, zoomlevel):\n    TileLoader.__init__(self, (sizeX, sizeY), cacheUrl)\n    self.zoomLevel = zoomlevel\n    self.kmlFile = kmlFile\n    self.kmlPoints = {}\n    self.kmlShapes = {}\n    self.initKML()\n", "code_toks_joined": "def __init__ ( self , ( sizeX , sizeY ) , kmlFile , cacheUrl , zoomlevel ) : <NEWLINE> <INDENT> TileLoader . __init__ ( self , ( sizeX , sizeY ) , cacheUrl ) <NEWLINE> self . zoomLevel = zoomlevel <NEWLINE> self . kmlFile = kmlFile <NEWLINE> self . kmlPoints = { } <NEWLINE> self . kmlShapes = { } <NEWLINE> self . initKML ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["1f222a7357f037a4a227cecd67cae741", {"code_string": "try:\n    from socket import AF_INET6\nexcept:\n    AF_INET6 = None\nfrom pysnmp_tornado.carrier.tornado.dgram.base import DgramSocketTransport import DgramSocketTransport\ndomainName = snmpUDP6Domain = (1, 3, 6, 1, 2, 1, 100, 1, 2)\n", "code_toks_joined": "try : <NEWLINE> <INDENT> from socket import AF_INET6 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> AF_INET6 = None <NEWLINE> <DEDENT> from pysnmp_tornado . carrier . tornado . dgram . base import DgramSocketTransport import DgramSocketTransport <NEWLINE> domainName = snmpUDP6Domain = ( 1 , 3 , 6 , 1 , 2 , 1 , 100 , 1 , 2 ) <NEWLINE>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["3f4fcfcbd4197d8532c4ae5aa116c579", {"code_string": "def printMe(self):\n    for cell in self.cell_list:\n    cell.printMe()\n", "code_toks_joined": "def printMe ( self ) : <NEWLINE> <INDENT> for cell in self . cell_list : <NEWLINE> cell . printMe ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["d6df657b3f6ac905b0d234196409bef0", {"code_string": "def __init__(self, session):\n    Screen.__init__(self, session)\n    self.skinName = \"Settings\"\n        title = \"Setup Skin\"\n        self.setTitle(title)\n        self[\"list\"] = MenuList([])\n    self[\"info\"] = Label()\n        self[\"actions\"] = ActionMap([\"OkCancelActions\"], {\"ok\": self.okClicked, \"cancel\": self.close}, - 1)\n        txt = _(\"Here you can change skin, configure mainmenu, configure second-infobar or configure TechniHD skin.\")\n        self[\"info\"].setText(txt)\n        self.onShown.append(self.startSession)\n", "code_toks_joined": "def __init__ ( self , session ) : <NEWLINE> <INDENT> Screen . __init__ ( self , session ) <NEWLINE> self . skinName = <STRING> <NEWLINE> <INDENT> title = <STRING> <NEWLINE> self . setTitle ( title ) <NEWLINE> self [ <STRING> ] = MenuList ( [ ] ) <NEWLINE> <DEDENT> self [ <STRING> ] = Label ( ) <NEWLINE> <INDENT> self [ <STRING> ] = ActionMap ( [ <STRING> ] , { <STRING> : self . okClicked , <STRING> : self . close } , - 1 ) <NEWLINE> txt = _ ( <STRING> ) <NEWLINE> self [ <STRING> ] . setText ( txt ) <NEWLINE> self . onShown . append ( self . startSession ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Settings\"", "\"Setup Skin\"", "\"list\"", "\"info\"", "\"actions\"", "\"OkCancelActions\"", "\"ok\"", "\"cancel\"", "\"Here you can change skin, configure mainmenu, configure second-infobar or configure TechniHD skin.\"", "\"info\""]}, "err_obj": {"msg": "unexpected indent"}}], ["212badfe5b3fcbae7c8c917f640b349f", {"code_string": "def test_emulate_secs_left_unknown(self):\n    with mock.patch(\"psutil._pswindows.cext.sensors_battery\",\n        return_value = (0, 0, 0, - 1)) as m:\n        self.assertEqual(psutil.sensors_battery().secsleft,\n            psutil.POWER_TIME_UNKNOWN)\n            assert m.called\n", "code_toks_joined": "def test_emulate_secs_left_unknown ( self ) : <NEWLINE> <INDENT> with mock . patch ( <STRING> , <NEWLINE> <INDENT> return_value = ( 0 , 0 , 0 , - 1 ) ) as m : <NEWLINE> self . assertEqual ( psutil . sensors_battery ( ) . secsleft , <NEWLINE> <INDENT> psutil . POWER_TIME_UNKNOWN ) <NEWLINE> assert m . called <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"psutil._pswindows.cext.sensors_battery\""]}, "err_obj": {"msg": "unexpected indent"}}], ["10a66cf58d3e2438f6322004dfaeff12", {"code_string": "def process_token(t):\n    with open(t, 'r') as fin:\n        for line in fin:\n            tokens = line.split()\n            for token in tokens:\n                parts = token.split('_')\n                word = '_'.join(parts[: - 1])\n                pos = parts[- 1]\n                print(\"%s\\t%s\" %(word, pos)\n            print(\"\")\n", "code_toks_joined": "def process_token ( t ) : <NEWLINE> <INDENT> with open ( t , <STRING> ) as fin : <NEWLINE> <INDENT> for line in fin : <NEWLINE> <INDENT> tokens = line . split ( ) <NEWLINE> for token in tokens : <NEWLINE> <INDENT> parts = token . split ( <STRING> ) <NEWLINE> word = <STRING> . join ( parts [ : - 1 ] ) <NEWLINE> pos = parts [ - 1 ] <NEWLINE> print ( <STRING> % ( word , pos ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'r'", "'_'", "'_'", "\"%s\\t%s\"", "\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["ace4805159363df5228f9ae3725c9d36", {"code_string": "class DvdPlayer(object):\n    def on(self): print \"dvd player turned on\"\n    def off(self): print \"dvd player turned off\"\n    def play(self):\n        print \"dvd player playing\"\n", "code_toks_joined": "class DvdPlayer ( object ) : <NEWLINE> <INDENT> def on ( self ) : print <STRING> <NEWLINE> def off ( self ) : print <STRING> <NEWLINE> def play ( self ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"dvd player turned on\"", "\"dvd player turned off\"", "\"dvd player playing\""]}, "err_obj": {"msg": "invalid syntax"}}], ["eab0ce320b3aa0725493475bc7c174bf", {"code_string": "def event_kicked(bot, (presence, room, nick, actor, reason)):\n    actor = actor and ' by %s' %(actor) or ''\n    reason = reason and ' (%s)' %(reason) or ''\n    bot.writelog(room + '.txt', '*** %s has been kicked%s%s' %(nick, actor, reason))\n    \"None has been\"\n", "code_toks_joined": "def event_kicked ( bot , ( presence , room , nick , actor , reason ) ) : <NEWLINE> <INDENT> actor = actor and <STRING> % ( actor ) or <STRING> <NEWLINE> reason = reason and <STRING> % ( reason ) or <STRING> <NEWLINE> bot . writelog ( room + <STRING> , <STRING> % ( nick , actor , reason ) ) <NEWLINE> <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["' by %s'", "''", "' (%s)'", "''", "'.txt'", "'*** %s has been kicked%s%s'", "\"None has been\""]}, "err_obj": {"msg": "invalid syntax"}}], ["f8a1899287cac4b989ce95f7e946f67e", {"code_string": "from ete_dev import Tree\nt = Tree('(A: 1, (B: 1, (E: 1, D: 1)Internal_1: 0.5)Internal_2: 0.5)Root; ', format = 1)\nprint(t.write(format = 100)))\nt.write(format = 100, outfile = \"/tmp/tree.new\")\n", "code_toks_joined": "from ete_dev import Tree <NEWLINE> t = Tree ( <STRING> , format = 1 ) <NEWLINE> print ( t . write ( format = 100 ) ) ) <NEWLINE> t . write ( format = 100 , outfile = <STRING> ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["'(A: 1, (B: 1, (E: 1, D: 1)Internal_1: 0.5)Internal_2: 0.5)Root; '", "\"/tmp/tree.new\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["bbea67f7332b637fcfa450d0275c1040", {"code_string": "def test_argument_order(self):\n    try:\n        exec 'def f(a=1, (b, c)): pass'\n        self.fail(\"non-default args after default\")\n    except SyntaxError:\n        pass\n", "code_toks_joined": "def test_argument_order ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> exec <STRING> <NEWLINE> self . fail ( <STRING> ) <NEWLINE> <DEDENT> except SyntaxError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'def f(a=1, (b, c)): pass'", "\"non-default args after default\""]}, "err_obj": {"msg": "invalid syntax"}}], ["677f1b3c61ce4cf42468cc3d844927d3", {"code_string": "def loadPendingSubs(self):\n    '''Loads the subs from the supplied file'''\n    if os.path.isfile(self.filename):\n        subfile = open(self.filename)\n        while True:\n        line = subfile.readline()\n        if not line:\n        break\n        parts = line.split(',')\n        self.subpending.append([parts[0], int(parts[1]), int(parts[2])])\n        subfile.close()\n", "code_toks_joined": "def loadPendingSubs ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if os . path . isfile ( self . filename ) : <NEWLINE> <INDENT> subfile = open ( self . filename ) <NEWLINE> while True : <NEWLINE> line = subfile . readline ( ) <NEWLINE> if not line : <NEWLINE> break <NEWLINE> parts = line . split ( <STRING> ) <NEWLINE> self . subpending . append ( [ parts [ 0 ] , int ( parts [ 1 ] ) , int ( parts [ 2 ] ) ] ) <NEWLINE> subfile . close ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Loads the subs from the supplied file'''", "','"]}, "err_obj": {"msg": "expected an indented block"}}], ["e60d7112fb413b751e00c5aa9c9f4dea", {"code_string": "def test_skip_no_such_backend(self):\n    class FakeDatabaseOpportunisticFixture(\n        test_fixtures.OpportunisticDbFixture):\n        DRIVER = 'postgresql+nosuchdbapi'\n    class SomeTest(test_fixtures.OpportunisticDBTestMixin,\n        oslo_test_base.BaseTestCase):\n        FIXTURE = FakeDatabaseOpportunisticFixture\n        def runTest(self):\n        pass\n    st = SomeTest()\n    ex = self.assertRaises(\n        self.skipException,\n        st.setUp\n    )\n    self.assertEqual(\n        \"Backend 'postgresql+nosuchdbapi' is unavailable: No such backend\",\n        str(ex)\n    )\n", "code_toks_joined": "def test_skip_no_such_backend ( self ) : <NEWLINE> <INDENT> class FakeDatabaseOpportunisticFixture ( <NEWLINE> <INDENT> test_fixtures . OpportunisticDbFixture ) : <NEWLINE> DRIVER = <STRING> <NEWLINE> <DEDENT> class SomeTest ( test_fixtures . OpportunisticDBTestMixin , <NEWLINE> <INDENT> oslo_test_base . BaseTestCase ) : <NEWLINE> FIXTURE = FakeDatabaseOpportunisticFixture <NEWLINE> def runTest ( self ) : <NEWLINE> pass <NEWLINE> <DEDENT> st = SomeTest ( ) <NEWLINE> ex = self . assertRaises ( <NEWLINE> <INDENT> self . skipException , <NEWLINE> st . setUp <NEWLINE> <DEDENT> ) <NEWLINE> self . assertEqual ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> str ( ex ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'postgresql+nosuchdbapi'", "\"Backend 'postgresql+nosuchdbapi' is unavailable: No such backend\""]}, "err_obj": {"msg": "expected an indented block"}}], ["5c5a8078aa749e228eaaf9919944efde", {"code_string": "def check_version(self):\n    if not self.available:\n        raise FFmpegPostProcessorError('ffmpeg or avconv not found. Please install one.')\n    required_version = '10-0' if self.basename == 'avconv' else '1.0'\n    if is_outdated_version(\n        self._versions[self.basename], required_version):\n        warning = 'Your copy of %s is outdated, update %s to version %s or newer if you encounter any errors.' %(\n        self.basename, self.basename, required_version)\n        if self._downloader:\n        self._downloader.report_warning(warning)\n", "code_toks_joined": "def check_version ( self ) : <NEWLINE> <INDENT> if not self . available : <NEWLINE> <INDENT> raise FFmpegPostProcessorError ( <STRING> ) <NEWLINE> <DEDENT> required_version = <STRING> if self . basename == <STRING> else <STRING> <NEWLINE> if is_outdated_version ( <NEWLINE> <INDENT> self . _versions [ self . basename ] , required_version ) : <NEWLINE> warning = <STRING> % ( <NEWLINE> self . basename , self . basename , required_version ) <NEWLINE> if self . _downloader : <NEWLINE> self . _downloader . report_warning ( warning ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'ffmpeg or avconv not found. Please install one.'", "'10-0'", "'avconv'", "'1.0'", "'Your copy of %s is outdated, update %s to version %s or newer if you encounter any errors.'"]}, "err_obj": {"msg": "expected an indented block"}}], ["2c257b2bc637dea02ee8a8970397e4e8", {"code_string": "import os\nvirtenv = os.environ['OPENSHIFT_PYTHON_DIR'] + '/virtenv/'\nvirtualenv = os.path.join(virtenv, 'bin/activate_this.py')\ntry:\n    execfile(virtualenv, dict(__file__ = virtualenv)))\nexcept IOError:\n    pass\n", "code_toks_joined": "import os <NEWLINE> virtenv = os . environ [ <STRING> ] + <STRING> <NEWLINE> virtualenv = os . path . join ( virtenv , <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> execfile ( virtualenv , dict ( __file__ = virtualenv ) ) ) <NEWLINE> <DEDENT> except IOError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'OPENSHIFT_PYTHON_DIR'", "'/virtenv/'", "'bin/activate_this.py'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["f2203a8502b264eda1fdc1f5a3d20f65", {"code_string": "def mkcert_selfsigned(id_xmpp, webid):\n    \"\"\"Create an x509 self-signed certificate\"\"\"\n    req, pk = mkreq_client(id_xmpp, webid)\n    cert = mkcert_defaults(req)\n    ext = X509.new_extension('subjectAltName', 'URI: %s, otherName: %s; UTF8: %s' %(webid, ID_ON_XMPPADDR_OID, id_xmpp))\n    ext.set_critical(0)\n    cert.add_ext(ext)\n    cert.sign(pk, 'sha1')\n    print(\"Generated new self-signed client certificate\")\n    if DEBUG:\n        print cert.as_pem()\n    return cert, pk\n", "code_toks_joined": "def mkcert_selfsigned ( id_xmpp , webid ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> req , pk = mkreq_client ( id_xmpp , webid ) <NEWLINE> cert = mkcert_defaults ( req ) <NEWLINE> ext = X509 . new_extension ( <STRING> , <STRING> % ( webid , ID_ON_XMPPADDR_OID , id_xmpp ) ) <NEWLINE> ext . set_critical ( 0 ) <NEWLINE> cert . add_ext ( ext ) <NEWLINE> cert . sign ( pk , <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> if DEBUG : <NEWLINE> <INDENT> print cert . as_pem ( ) <NEWLINE> <DEDENT> return cert , pk <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Create an x509 self-signed certificate\"\"\"", "'subjectAltName'", "'URI: %s, otherName: %s; UTF8: %s'", "'sha1'", "\"Generated new self-signed client certificate\""]}, "err_obj": {"msg": "invalid syntax"}}], ["fdcdba7e0aebaecb31613344774d3780", {"code_string": "def home():\n    if current_user.is_authenticated:\n        return redirect(url_for('user_shelf'))\n    else:\n    return redirect(url_for('login'))\n", "code_toks_joined": "def home ( ) : <NEWLINE> <INDENT> if current_user . is_authenticated : <NEWLINE> <INDENT> return redirect ( url_for ( <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> return redirect ( url_for ( <STRING> ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'user_shelf'", "'login'"]}, "err_obj": {"msg": "expected an indented block"}}], ["7d521b0332da249b535c9451d9dfb931", {"code_string": "def check_tree(t):\n    for node in t.traverse():\n        if node.name == \"sex\":\n            print(node.name, node.dist)\n            if node.name == \"movies\":\n            print(node.name, node.dist)\n            if node.name == \"crime\":\n            print(node.name, node.dist)\n            if \"entertainment\" in node.name:\n            print(node.name, node.dist)\n", "code_toks_joined": "def check_tree ( t ) : <NEWLINE> <INDENT> for node in t . traverse ( ) : <NEWLINE> <INDENT> if node . name == <STRING> : <NEWLINE> <INDENT> print ( node . name , node . dist ) <NEWLINE> if node . name == <STRING> : <NEWLINE> print ( node . name , node . dist ) <NEWLINE> if node . name == <STRING> : <NEWLINE> print ( node . name , node . dist ) <NEWLINE> if <STRING> in node . name : <NEWLINE> print ( node . name , node . dist ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"sex\"", "\"movies\"", "\"crime\"", "\"entertainment\""]}, "err_obj": {"msg": "expected an indented block"}}], ["c502a5d7badfef66c86060e996733a2f", {"code_string": "def module_detail(request, group_id, _id):\n    try:\n        group_id = ObjectId(group_id)\n    except:\n        group_name, group_id = get_group_name_id(group_id)\n    course_node = node_collection.one({\"_id\": ObjectId(_id)})\n    if course_node._type == \"GSystemType\":\n    return module(request, group_id, _id)\n    return render_to_response(\"ndf/module_detail.html\",\n        {'node': course_node,\n            'appId': app._id,\n            'groupid': group_id,\n            'group_id': group_id\n        },\n        context_instance = RequestContext(request)\n        )\n", "code_toks_joined": "def module_detail ( request , group_id , _id ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> group_id = ObjectId ( group_id ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> group_name , group_id = get_group_name_id ( group_id ) <NEWLINE> <DEDENT> course_node = node_collection . one ( { <STRING> : ObjectId ( _id ) } ) <NEWLINE> if course_node . _type == <STRING> : <NEWLINE> return module ( request , group_id , _id ) <NEWLINE> return render_to_response ( <STRING> , <NEWLINE> <INDENT> { <STRING> : course_node , <NEWLINE> <INDENT> <STRING> : app . _id , <NEWLINE> <STRING> : group_id , <NEWLINE> <STRING> : group_id <NEWLINE> <DEDENT> } , <NEWLINE> context_instance = RequestContext ( request ) <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"_id\"", "\"GSystemType\"", "\"ndf/module_detail.html\"", "'node'", "'appId'", "'groupid'", "'group_id'"]}, "err_obj": {"msg": "expected an indented block"}}], ["535a97eb559958f24fd1d89230433802", {"code_string": "def test():\n    g = Generator(pi, ())\n    g.kill()\n    g = Generator(pi, ())\n    for i in range(10):\n        print g.get(),\n    print\n    h = g.clone()\n    g.kill()\n    while 1:\n        print(h.get(), )\n        sys.stdout.flush()\n", "code_toks_joined": "def test ( ) : <NEWLINE> <INDENT> g = Generator ( pi , ( ) ) <NEWLINE> g . kill ( ) <NEWLINE> g = Generator ( pi , ( ) ) <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> print g . get ( ) , <NEWLINE> <DEDENT> print <NEWLINE> h = g . clone ( ) <NEWLINE> g . kill ( ) <NEWLINE> while 1 : <NEWLINE> <INDENT> print ( h . get ( ) , ) <NEWLINE> sys . stdout . flush ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["74dd9265f54c5560d4e53139b363e7e6", {"code_string": "def run(self):\n    if not self.distribution.dist_files:\n        raise DistutilsOptionError(\"No dist file created in earlier command\")\n    for command, pyversion, filename in self.distribution.dist_files\n        self.upload_file(command, pyversion, filename)\n", "code_toks_joined": "def run ( self ) : <NEWLINE> <INDENT> if not self . distribution . dist_files : <NEWLINE> <INDENT> raise DistutilsOptionError ( <STRING> ) <NEWLINE> <DEDENT> for command , pyversion , filename in self . distribution . dist_files <NEWLINE> <INDENT> self . upload_file ( command , pyversion , filename ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"No dist file created in earlier command\""]}, "err_obj": {"msg": "invalid syntax"}}], ["ecbfec8c68a4f5161a77bd01af1a8e32", {"code_string": "class VelocityVerletOnGroupLocal(MDIntegratorLocal, integrator_VelocityVerletOnGroup):\n    def __init__(self, system, group):\n    if not(pmi._PMIComm and pmi._PMIComm.isActive()) or pmi._MPIcomm.rank in pmi._PMIComm.getMPIcpugroup():\n        cxxinit(self, integrator_VelocityVerletOnGroup, system, group)\n", "code_toks_joined": "class VelocityVerletOnGroupLocal ( MDIntegratorLocal , integrator_VelocityVerletOnGroup ) : <NEWLINE> <INDENT> def __init__ ( self , system , group ) : <NEWLINE> if not ( pmi . _PMIComm and pmi . _PMIComm . isActive ( ) ) or pmi . _MPIcomm . rank in pmi . _PMIComm . getMPIcpugroup ( ) : <NEWLINE> <INDENT> cxxinit ( self , integrator_VelocityVerletOnGroup , system , group ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["ebaff4779d11c19fb9868700e5487bf0", {"code_string": "def LoadAndVerifyJson(raw, verify_fn):\n    \"\"\"Parses and verifies JSON data.\"\"\"\n    try:\n        data = LoadJson(raw)\n    except Exception, err:\n        raise errors.ParseError(\"Can't parse input data: %s\" % err)\n    if not verify_fn(data):\n        raise errors.ParseError(\"Data does not match expected format: %s\" %\n            verify_fn)\n    return data\n", "code_toks_joined": "def LoadAndVerifyJson ( raw , verify_fn ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> data = LoadJson ( raw ) <NEWLINE> <DEDENT> except Exception , err : <NEWLINE> <INDENT> raise errors . ParseError ( <STRING> % err ) <NEWLINE> <DEDENT> if not verify_fn ( data ) : <NEWLINE> <INDENT> raise errors . ParseError ( <STRING> % <NEWLINE> <INDENT> verify_fn ) <NEWLINE> <DEDENT> <DEDENT> return data <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Parses and verifies JSON data.\"\"\"", "\"Can't parse input data: %s\"", "\"Data does not match expected format: %s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["bc8164d34f0a50da6118f0b250fb8be3", {"code_string": "def handle_file_complete(self, old_field_name, counters):\n    \"\"\"Handle all the signalling that takes place when a file is complete.\"\"\"\n    for i, handler in enumerate(self._upload_handlers):\n        file_obj = handler.file_complete(counters[i])\n        if file_obj:\n            self._files.appendlist(force_unicode(old_field_name,\n                self._encoding,\n                errors = 'replace')\n                file_obj)\n            break\n", "code_toks_joined": "def handle_file_complete ( self , old_field_name , counters ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for i , handler in enumerate ( self . _upload_handlers ) : <NEWLINE> <INDENT> file_obj = handler . file_complete ( counters [ i ] ) <NEWLINE> if file_obj : <NEWLINE> <INDENT> self . _files . appendlist ( force_unicode ( old_field_name , <NEWLINE> <INDENT> self . _encoding , <NEWLINE> errors = <STRING> ) <NEWLINE> file_obj ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Handle all the signalling that takes place when a file is complete.\"\"\"", "'replace'"]}, "err_obj": {"msg": "invalid syntax"}}], ["8c083d66bcaba0d33489cdaf57031979", {"code_string": "def test_checkout(_client, _repo, _local_test_dir):\n    \"\"\" checkout our test tree \"\"\"\n    try:\n        _client.checkout(_repo, _local_test_dir)\n    except pysvn._pysvn.ClientError, error:\n        print(error)\n        sys.exit()\n", "code_toks_joined": "def test_checkout ( _client , _repo , _local_test_dir ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> _client . checkout ( _repo , _local_test_dir ) <NEWLINE> <DEDENT> except pysvn . _pysvn . ClientError , error : <NEWLINE> <INDENT> print ( error ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" checkout our test tree \"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["cf1c8ba5f6990dfcad8b95ead24b9d14", {"code_string": "def test_terminate_connection_no_decorator(self, utils_mock):\n    utils_mock.return_value = True\n    with mock.patch.object(fc_zone_manager.ZoneManager,\n        'delete_connection') as remove_zone_mock:\n        with mock.patch.object(conf.Configuration, 'safe_get') as mock_safe_get:\n        mock_safe_get.return_value = 'fabric'\n        self.driver.no_zone_terminate_connection(None, None)\n        remove_zone_mock.assert_not_called()\n", "code_toks_joined": "def test_terminate_connection_no_decorator ( self , utils_mock ) : <NEWLINE> <INDENT> utils_mock . return_value = True <NEWLINE> with mock . patch . object ( fc_zone_manager . ZoneManager , <NEWLINE> <INDENT> <STRING> ) as remove_zone_mock : <NEWLINE> with mock . patch . object ( conf . Configuration , <STRING> ) as mock_safe_get : <NEWLINE> mock_safe_get . return_value = <STRING> <NEWLINE> self . driver . no_zone_terminate_connection ( None , None ) <NEWLINE> remove_zone_mock . assert_not_called ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'delete_connection'", "'safe_get'", "'fabric'"]}, "err_obj": {"msg": "expected an indented block"}}], ["cdc06f73e556f651818e02291535d05a", {"code_string": "def main():\n    input = HEADERFILES\n    output = SHORT + \"gen.py\"\n    defsoutput = TOOLBOXDIR + LONG + \".py\"\n    scanner = MyScanner(input, output, defsoutput)\n    scanner.scan()\n    scanner.close()\n    scanner.gentypetest(SHORT + \"typetest.py\")\n    print(\"=== Testing definitions output code ===\")\n    execfile(defsoutput, {}, {})\n    print(\"=== Done scanning and generating, now importing the generated code... ===\")\n    exec \"import \" + SHORT + \"support\"\n    print(\"=== Done.  It's up to you to compile it now! ===\")\n", "code_toks_joined": "def main ( ) : <NEWLINE> <INDENT> input = HEADERFILES <NEWLINE> output = SHORT + <STRING> <NEWLINE> defsoutput = TOOLBOXDIR + LONG + <STRING> <NEWLINE> scanner = MyScanner ( input , output , defsoutput ) <NEWLINE> scanner . scan ( ) <NEWLINE> scanner . close ( ) <NEWLINE> scanner . gentypetest ( SHORT + <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> execfile ( defsoutput , { } , { } ) <NEWLINE> print ( <STRING> ) <NEWLINE> exec <STRING> + SHORT + <STRING> <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"gen.py\"", "\".py\"", "\"typetest.py\"", "\"=== Testing definitions output code ===\"", "\"=== Done scanning and generating, now importing the generated code... ===\"", "\"import \"", "\"support\"", "\"=== Done.  It's up to you to compile it now! ===\""]}, "err_obj": {"msg": "invalid syntax"}}], ["08402b78b710f7f3cdb125d1acfcacd1", {"code_string": "def plotmap(G, fileref = 'ukgds2nxFigure', graphprogram = 'neato', tag = ''):\n    \"\"\" Generates node positions and plots UKGDS NetworkX Graph. No indication for parallel edges (lines) between nodes. Saves as a .png\"\"\"\n    voltages = np.unique([G.node[x]['BBV'] for x, y in G.edges()])\n    colours = ['b', 'b', 'k', '#808000', 'g', 'r', 'r', 'r', 'y']\n    thickness = [0.5 * x for x in[1, 1, 1, 1, 1, 1, 1, 1, 1]]\n    alpha = [0.5 * x for x in[1, 1, 1, 1, 1, 1, 1, 1, 1]]\n    colourmaps = [plt.cm.Blues, plt.cm.Blues, plt.cm.Greys, plt.cm.OrRd, plt.cm.summer, plt.cm.autumn, plt.cm.autumn, plt.cm.autumn, plt.cm.autumn]\n    pos = nx.graphviz_layout(G, prog = graphprogram)\n    for p, q in pos.iteritems():\n        G.add_node(p, pos = q)\n    notxedges = [(x, y, d) for x, y, d in G.edges(data = True) if 'CLE' in d]\n    labels = dict(((x, y), str(d['CLE']) + 'km') for x, y, d in G.edges(data = True) if 'CLE' in d)\n    nodes = [x for x, d in G.nodes(data = True) if d['BBV'] == 11]\n    SG = G.subgraph(nodes)\n    poslabels = {}\n    for sgn in SG.nodes():\n        x, y = pos[sgn]\n        poslabels[sgn] = (x, y + 100)\n    nodelabels = dict((x, x) for x, y in SG.nodes(data = True))\n    nx.draw_networkx_edges(SG, nx.get_node_attributes(SG, 'pos'), edgelist = SG.edges(), edge_color = 'r', style = '-', width = 3, with_labels = False, alpha = 0.4)\n    nx.draw(SG, nx.get_node_attributes(SG, 'pos'), node_size = 10, with_labels = False, node_color = 'r', alpha = 0.4)\n    nodes = [x for x, d in G.nodes(data = True) if d['BBV'] == 33]\n    SG = G.subgraph(nodes)\n    poslabels = {}\n    for sgn in SG.nodes():\n        x, y = pos[sgn]\n        poslabels[sgn] = (x, y - 100)\n    nodelabels = dict((x, x) for x, y in SG.nodes(data = True))\n    nx.draw_networkx_labels(SG, pos = poslabels, labels = nodelabels, font_size = 8, alpha = 0.8)\n    nx.draw(SG, nx.get_node_attributes(SG, 'pos'), node_size = 20, with_labels = False, node_color = 'g', edge_color = 'g', style = '-', width = 3, alpha = 0.4)\n    nodes = [x for x, d in G.nodes(data = True) if d['BBV'] == 132]\n    SG = G.subgraph(nodes)\n    poslabels = {}\n    for sgn in SG.nodes():\n        x, y = pos[sgn]\n        poslabels[sgn] = (x, y + 100)\n    nodelabels = dict((x, x) for x, y in SG.nodes(data = True))\n    nx.draw_networkx_labels(SG, pos = poslabels, labels = nodelabels, font_size = 10, alpha = 0.8)\n    nx.draw_networkx_edges(SG, nx.get_node_attributes(SG, 'pos'), edgelist = SG.edges(), edge_color = 'k', style = '-', width = 3, with_labels = False, alpha = 0.4)\n    nx.draw(SG, nx.get_node_attributes(SG, 'pos'), node_size = 30, with_labels = False, node_color = 'k', alpha = 0.4)\n    plt.savefig(fileref + str(graphprogram) + str(tag) + '.png', dpi = 300))\n", "code_toks_joined": "def plotmap ( G , fileref = <STRING> , graphprogram = <STRING> , tag = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> voltages = np . unique ( [ G . node [ x ] [ <STRING> ] for x , y in G . edges ( ) ] ) <NEWLINE> colours = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> thickness = [ 0.5 * x for x in [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] ] <NEWLINE> alpha = [ 0.5 * x for x in [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] ] <NEWLINE> colourmaps = [ plt . cm . Blues , plt . cm . Blues , plt . cm . Greys , plt . cm . OrRd , plt . cm . summer , plt . cm . autumn , plt . cm . autumn , plt . cm . autumn , plt . cm . autumn ] <NEWLINE> pos = nx . graphviz_layout ( G , prog = graphprogram ) <NEWLINE> for p , q in pos . iteritems ( ) : <NEWLINE> <INDENT> G . add_node ( p , pos = q ) <NEWLINE> <DEDENT> notxedges = [ ( x , y , d ) for x , y , d in G . edges ( data = True ) if <STRING> in d ] <NEWLINE> labels = dict ( ( ( x , y ) , str ( d [ <STRING> ] ) + <STRING> ) for x , y , d in G . edges ( data = True ) if <STRING> in d ) <NEWLINE> nodes = [ x for x , d in G . nodes ( data = True ) if d [ <STRING> ] == 11 ] <NEWLINE> SG = G . subgraph ( nodes ) <NEWLINE> poslabels = { } <NEWLINE> for sgn in SG . nodes ( ) : <NEWLINE> <INDENT> x , y = pos [ sgn ] <NEWLINE> poslabels [ sgn ] = ( x , y + 100 ) <NEWLINE> <DEDENT> nodelabels = dict ( ( x , x ) for x , y in SG . nodes ( data = True ) ) <NEWLINE> nx . draw_networkx_edges ( SG , nx . get_node_attributes ( SG , <STRING> ) , edgelist = SG . edges ( ) , edge_color = <STRING> , style = <STRING> , width = 3 , with_labels = False , alpha = 0.4 ) <NEWLINE> nx . draw ( SG , nx . get_node_attributes ( SG , <STRING> ) , node_size = 10 , with_labels = False , node_color = <STRING> , alpha = 0.4 ) <NEWLINE> nodes = [ x for x , d in G . nodes ( data = True ) if d [ <STRING> ] == 33 ] <NEWLINE> SG = G . subgraph ( nodes ) <NEWLINE> poslabels = { } <NEWLINE> for sgn in SG . nodes ( ) : <NEWLINE> <INDENT> x , y = pos [ sgn ] <NEWLINE> poslabels [ sgn ] = ( x , y - 100 ) <NEWLINE> <DEDENT> nodelabels = dict ( ( x , x ) for x , y in SG . nodes ( data = True ) ) <NEWLINE> nx . draw_networkx_labels ( SG , pos = poslabels , labels = nodelabels , font_size = 8 , alpha = 0.8 ) <NEWLINE> nx . draw ( SG , nx . get_node_attributes ( SG , <STRING> ) , node_size = 20 , with_labels = False , node_color = <STRING> , edge_color = <STRING> , style = <STRING> , width = 3 , alpha = 0.4 ) <NEWLINE> nodes = [ x for x , d in G . nodes ( data = True ) if d [ <STRING> ] == 132 ] <NEWLINE> SG = G . subgraph ( nodes ) <NEWLINE> poslabels = { } <NEWLINE> for sgn in SG . nodes ( ) : <NEWLINE> <INDENT> x , y = pos [ sgn ] <NEWLINE> poslabels [ sgn ] = ( x , y + 100 ) <NEWLINE> <DEDENT> nodelabels = dict ( ( x , x ) for x , y in SG . nodes ( data = True ) ) <NEWLINE> nx . draw_networkx_labels ( SG , pos = poslabels , labels = nodelabels , font_size = 10 , alpha = 0.8 ) <NEWLINE> nx . draw_networkx_edges ( SG , nx . get_node_attributes ( SG , <STRING> ) , edgelist = SG . edges ( ) , edge_color = <STRING> , style = <STRING> , width = 3 , with_labels = False , alpha = 0.4 ) <NEWLINE> nx . draw ( SG , nx . get_node_attributes ( SG , <STRING> ) , node_size = 30 , with_labels = False , node_color = <STRING> , alpha = 0.4 ) <NEWLINE> plt . savefig ( fileref + str ( graphprogram ) + str ( tag ) + <STRING> , dpi = 300 ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'ukgds2nxFigure'", "'neato'", "''", "\"\"\" Generates node positions and plots UKGDS NetworkX Graph. No indication for parallel edges (lines) between nodes. Saves as a .png\"\"\"", "'BBV'", "'b'", "'b'", "'k'", "'#808000'", "'g'", "'r'", "'r'", "'r'", "'y'", "'CLE'", "'CLE'", "'km'", "'CLE'", "'BBV'", "'pos'", "'r'", "'-'", "'pos'", "'r'", "'BBV'", "'pos'", "'g'", "'g'", "'-'", "'BBV'", "'pos'", "'k'", "'-'", "'pos'", "'k'", "'.png'"]}, "window_span": [838, 862], "err_obj": {"msg": "unbalanced (){}[]"}}], ["202f32c362b4ebafe2031f698a63d8bc", {"code_string": "class Ufunc(object):\n    \"\"\"Description of a ufunc.\"\"\"\n    def __init__(self, nin, nout, identity, docstring,\n        * type_descriptions):\n        self.nin = nin\n        self.nout = nout\n        if identity is None:\n        identity = None_\n        self.identity = identity\n        self.docstring = docstring\n        self.type_descriptions = []\n        for td in type_descriptions:\n        self.type_descriptions.extend(td)\n        for td in self.type_descriptions:\n        td.finish_signature(self.nin, self.nout)\n", "code_toks_joined": "class Ufunc ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , nin , nout , identity , docstring , <NEWLINE> <INDENT> * type_descriptions ) : <NEWLINE> self . nin = nin <NEWLINE> self . nout = nout <NEWLINE> if identity is None : <NEWLINE> identity = None_ <NEWLINE> self . identity = identity <NEWLINE> self . docstring = docstring <NEWLINE> self . type_descriptions = [ ] <NEWLINE> for td in type_descriptions : <NEWLINE> self . type_descriptions . extend ( td ) <NEWLINE> for td in self . type_descriptions : <NEWLINE> td . finish_signature ( self . nin , self . nout ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Description of a ufunc.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["27287d5774e57f42516326d5a60f137d", {"code_string": "def setUp(self):\n    Database().clean()\n        self.b = Backport()\n        self.b.pkg = 'libgig'\n        self.b.dist = 'lenny'\n", "code_toks_joined": "def setUp ( self ) : <NEWLINE> <INDENT> Database ( ) . clean ( ) <NEWLINE> <INDENT> self . b = Backport ( ) <NEWLINE> self . b . pkg = <STRING> <NEWLINE> self . b . dist = <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'libgig'", "'lenny'"]}, "err_obj": {"msg": "unexpected indent"}}], ["609d0b42b9e8a984b12df52bb4b9c32b", {"code_string": "def setup_app(name, config = 'config'):\n    app = Flask(name)\n    app.config['MONGODB_SETTINGS'] = {\n        'db': 'NIST_test',\n        'host': 'localhost',\n        'port': 27017\n", "code_toks_joined": "def setup_app ( name , config = <STRING> ) : <NEWLINE> <INDENT> app = Flask ( name ) <NEWLINE> app . config [ <STRING> ] = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : 27017 <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'config'", "'MONGODB_SETTINGS'", "'db'", "'NIST_test'", "'host'", "'localhost'", "'port'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e9e6f2057ff4c58bc24ec4a7a90888fc", {"code_string": "def test_token_no_data(self):\n    with self.settings(SOCIAL_AUTH_FACEBOOK_SECRET = 'test-invalid'):\n        with mock.patch(\n            'social.apps.django_app.utils.BACKENDS',\n            ['bluebottle.social.backends.NoStateFacebookOAuth2']):\n            with httmock.HTTMock(facebook_me_mock):\n            response = self.client.post(self.token_url,\n                token = self.user_token)\n            self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n", "code_toks_joined": "def test_token_no_data ( self ) : <NEWLINE> <INDENT> with self . settings ( SOCIAL_AUTH_FACEBOOK_SECRET = <STRING> ) : <NEWLINE> <INDENT> with mock . patch ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> [ <STRING> ] ) : <NEWLINE> with httmock . HTTMock ( facebook_me_mock ) : <NEWLINE> response = self . client . post ( self . token_url , <NEWLINE> <INDENT> token = self . user_token ) <NEWLINE> <DEDENT> self . assertEqual ( response . status_code , status . HTTP_400_BAD_REQUEST ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'test-invalid'", "'social.apps.django_app.utils.BACKENDS'", "'bluebottle.social.backends.NoStateFacebookOAuth2'"]}, "err_obj": {"msg": "expected an indented block"}}], ["d489e545c57eed3cc1a4bbc522d3d3cf", {"code_string": "def retranslateUi(self, HgNewProjectOptionsDialog):\n    _translate = QtCore.QCoreApplication.translate\n    HgNewProjectOptionsDialog.setWindowTitle(_translate(\"HgNewProjectOptionsDialog\", \"New Project from Repository\"))\n    HgNewProjectOptionsDialog.setWhatsThis(_translate(\"HgNewProjectOptionsDialog\", \"<b>New Project from Repository Dialog</b>\\n\"\n", "code_toks_joined": "def retranslateUi ( self , HgNewProjectOptionsDialog ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> HgNewProjectOptionsDialog . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> HgNewProjectOptionsDialog . setWhatsThis ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"HgNewProjectOptionsDialog\"", "\"New Project from Repository\"", "\"HgNewProjectOptionsDialog\"", "\"<b>New Project from Repository Dialog</b>\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["f6a66665e5c7917dc3d38f239b3e32e1", {"code_string": "def connectionMade(self, instance):\n    self.instance = instance\n    if pipeline_debug: print 'connection made %s' % str(instance.peer)\n    while self.anyQueries():\n        self.instance.sendQuery()\n", "code_toks_joined": "def connectionMade ( self , instance ) : <NEWLINE> <INDENT> self . instance = instance <NEWLINE> if pipeline_debug : print <STRING> % str ( instance . peer ) <NEWLINE> while self . anyQueries ( ) : <NEWLINE> <INDENT> self . instance . sendQuery ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'connection made %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["7399c7c3e17bc9002002a659f6237aea", {"code_string": "def _checkcrc(self):\n    filecrc = struct.unpack('>h', self.ifp.read(2))[0] & 0xffff\n    self.crc = self.crc & 0xffff\n    if filecrc != self.crc:\n        raise Error, 'CRC error, computed %x, read %x' %(self.crc, filecrc)\n    self.crc = 0\n", "code_toks_joined": "def _checkcrc ( self ) : <NEWLINE> <INDENT> filecrc = struct . unpack ( <STRING> , self . ifp . read ( 2 ) ) [ 0 ] & 0xffff <NEWLINE> self . crc = self . crc & 0xffff <NEWLINE> if filecrc != self . crc : <NEWLINE> <INDENT> raise Error , <STRING> % ( self . crc , filecrc ) <NEWLINE> <DEDENT> self . crc = 0 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'>h'", "'CRC error, computed %x, read %x'"]}, "err_obj": {"msg": "invalid syntax"}}], ["eafc040aa0d27619f567be18b621653e", {"code_string": "class SSHCommandResult(object):\n    \"\"\"Structure that returns in all ssh commands results.\"\"\"\n    def __init__(\n        self, stdout = None, stderr = None, return_code = 0, output_format = None):\n        self.stdout = stdout\n        self.stderr = stderr\n        self.return_code = return_code\n        self.output_format = output_format\n        if output_format and self.return_code == 0:\n        if output_format == 'csv':\n            self.stdout = hammer.parse_csv(stdout) if stdout else{}\n        if output_format == 'json':\n            self.stdout = json.loads(stdout) if stdout else None\n", "code_toks_joined": "class SSHCommandResult ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( <NEWLINE> <INDENT> self , stdout = None , stderr = None , return_code = 0 , output_format = None ) : <NEWLINE> self . stdout = stdout <NEWLINE> self . stderr = stderr <NEWLINE> self . return_code = return_code <NEWLINE> self . output_format = output_format <NEWLINE> if output_format and self . return_code == 0 : <NEWLINE> if output_format == <STRING> : <NEWLINE> <INDENT> self . stdout = hammer . parse_csv ( stdout ) if stdout else { } <NEWLINE> <DEDENT> if output_format == <STRING> : <NEWLINE> <INDENT> self . stdout = json . loads ( stdout ) if stdout else None <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Structure that returns in all ssh commands results.\"\"\"", "'csv'", "'json'"]}, "err_obj": {"msg": "expected an indented block"}}], ["2fbb2d49e297656cb629e9b3aca7d3d3", {"code_string": "def breathe(color):\n    while True:\n        millis = int(round(time.time() * 1000))\n        brightness = (math.exp(math.sin(millis / 2000.0 * math.pi)) - 0.36787944) * 108.0;\n        for i in range(0, numPixels):\n            strip.setPixelColor(i, scale(color, brightness))\n        strip.show()\n            time.sleep(0.02)\n", "code_toks_joined": "def breathe ( color ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> millis = int ( round ( time . time ( ) * 1000 ) ) <NEWLINE> brightness = ( math . exp ( math . sin ( millis / 2000.0 * math . pi ) ) - 0.36787944 ) * 108.0 ; <NEWLINE> for i in range ( 0 , numPixels ) : <NEWLINE> <INDENT> strip . setPixelColor ( i , scale ( color , brightness ) ) <NEWLINE> <DEDENT> strip . show ( ) <NEWLINE> <INDENT> time . sleep ( 0.02 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["d4bdc539db651f920816e6afa53b8503", {"code_string": "def sniff(self, sample, delimiters = None):\n    \"\"\"Returns a dialect (or None) corresponding to the sample\"\"\"\n    quotechar, doublequote, delimiter, skipinitialspace = self._guess_quote_and_delimiter(sample, delimiters)\n    if not delimiter:\n        delimiter, skipinitialspace = self._guess_delimiter(sample,\n            delimiters)\n    if not delimiter:\n        raise Error, \"Could not determine delimiter\"\n    class dialect(Dialect):\n        _name = \"sniffed\"\n        lineterminator = '\\r\\n'\n        quoting = QUOTE_MINIMAL\n    dialect.doublequote = doublequote\n    dialect.delimiter = delimiter\n    dialect.quotechar = quotechar or '\"'\n    dialect.skipinitialspace = skipinitialspace\n    return dialect\n", "code_toks_joined": "def sniff ( self , sample , delimiters = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> quotechar , doublequote , delimiter , skipinitialspace = self . _guess_quote_and_delimiter ( sample , delimiters ) <NEWLINE> if not delimiter : <NEWLINE> <INDENT> delimiter , skipinitialspace = self . _guess_delimiter ( sample , <NEWLINE> <INDENT> delimiters ) <NEWLINE> <DEDENT> <DEDENT> if not delimiter : <NEWLINE> <INDENT> raise Error , <STRING> <NEWLINE> <DEDENT> class dialect ( Dialect ) : <NEWLINE> <INDENT> _name = <STRING> <NEWLINE> lineterminator = <STRING> <NEWLINE> quoting = QUOTE_MINIMAL <NEWLINE> <DEDENT> dialect . doublequote = doublequote <NEWLINE> dialect . delimiter = delimiter <NEWLINE> dialect . quotechar = quotechar or <STRING> <NEWLINE> dialect . skipinitialspace = skipinitialspace <NEWLINE> return dialect <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns a dialect (or None) corresponding to the sample\"\"\"", "\"Could not determine delimiter\"", "\"sniffed\"", "'\\r\\n'", "'\"'"]}, "err_obj": {"msg": "invalid syntax"}}], ["ea534f2d0f3069f09def9a3ac8ee3643", {"code_string": "def performable_embed(hostname, page_id):\n    \"\"\"Include a Performable landing page.\"\"\"\n    return mark_safe(EMBED_CODE %{\n        'hostname': hostname,\n        'page_id': page_id,\n        ,\n    })\n", "code_toks_joined": "def performable_embed ( hostname , page_id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return mark_safe ( EMBED_CODE % { <NEWLINE> <INDENT> <STRING> : hostname , <NEWLINE> <STRING> : page_id , <NEWLINE> , <NEWLINE> <DEDENT> } ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Include a Performable landing page.\"\"\"", "'hostname'", "'page_id'"]}, "err_obj": {"msg": "invalid syntax"}}], ["9a6a766357e026053c71e0add0acd6a9", {"code_string": "from visualape import INCLUDE_JAVASCRIPT, INCLUDE_P5\nprint(INCLUDE_P5)\nprint(INCLUDE_JAVASCRIPT.format('follow_mouse.js')\nprint(INCLUDE_JAVASCRIPT.format('easing.js'))\nprint(INCLUDE_JAVASCRIPT.format('follow_line.js'))\n", "code_toks_joined": "from visualape import INCLUDE_JAVASCRIPT , INCLUDE_P5 <NEWLINE> print ( INCLUDE_P5 ) <NEWLINE> print ( INCLUDE_JAVASCRIPT . format ( <STRING> ) <NEWLINE> print ( INCLUDE_JAVASCRIPT . format ( <STRING> ) ) <NEWLINE> print ( INCLUDE_JAVASCRIPT . format ( <STRING> ) ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["'follow_mouse.js'", "'easing.js'", "'follow_line.js'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["8b3c2817dd43ea7a749d35c02b6519a3", {"code_string": "def maskToString(self num_of_bits = None):\n    \"\"\" A string, with the function mask in binary form (DRAFT...)\"\"\"\n    t_str, k = '', 0\n    num = self.funmask\n    while num > 0:\n        if num & 1 == 1:\n            t_str = t_str + '1'\n        else:\n            t_str = t_str + '0'\n        num >>= 1\n        k += 1\n    if num_of_bits != None and num_of_bits > k:\n        t_str += '0' *(num_of_bits - k)\n    return t_str\n", "code_toks_joined": "def maskToString ( self num_of_bits = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> t_str , k = <STRING> , 0 <NEWLINE> num = self . funmask <NEWLINE> while num > 0 : <NEWLINE> <INDENT> if num & 1 == 1 : <NEWLINE> <INDENT> t_str = t_str + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t_str = t_str + <STRING> <NEWLINE> <DEDENT> num >>= 1 <NEWLINE> k += 1 <NEWLINE> <DEDENT> if num_of_bits != None and num_of_bits > k : <NEWLINE> <INDENT> t_str += <STRING> * ( num_of_bits - k ) <NEWLINE> <DEDENT> return t_str <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" A string, with the function mask in binary form (DRAFT...)\"\"\"", "''", "'1'", "'0'", "'0'"]}, "err_obj": {"msg": "invalid syntax"}}], ["c59376737f0d43e8480817efe6dbfaa2", {"code_string": "def __init__(self, * args, ** kwargs):\n    if wx.GetApp() is None:\n        self.app = wx.App(False)\n    self.args = False\n    if kwargs.has_key('args'):\n        self.args = kwargs['args']\n        del kwargs['args']\n        dotfile = None\n    if 'dotfile' in kwargs:\n    dotfile = kwargs['dotfile']\n    del kwargs['dotfile']\n    OptionParser.__init__(self, * args, ** kwargs)\n    self.dotfile = self.find_dotfile(dotfile)\n", "code_toks_joined": "def __init__ ( self , * args , ** kwargs ) : <NEWLINE> <INDENT> if wx . GetApp ( ) is None : <NEWLINE> <INDENT> self . app = wx . App ( False ) <NEWLINE> <DEDENT> self . args = False <NEWLINE> if kwargs . has_key ( <STRING> ) : <NEWLINE> <INDENT> self . args = kwargs [ <STRING> ] <NEWLINE> del kwargs [ <STRING> ] <NEWLINE> dotfile = None <NEWLINE> <DEDENT> if <STRING> in kwargs : <NEWLINE> dotfile = kwargs [ <STRING> ] <NEWLINE> del kwargs [ <STRING> ] <NEWLINE> OptionParser . __init__ ( self , * args , ** kwargs ) <NEWLINE> self . dotfile = self . find_dotfile ( dotfile ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'args'", "'args'", "'args'", "'dotfile'", "'dotfile'", "'dotfile'"]}, "err_obj": {"msg": "expected an indented block"}}], ["42c92bb7a4e4093d664af79836dea003", {"code_string": "def get_mathjax_header(https = False):\n    \"\"\"Return the snippet of HTML code to put in HTML HEAD tag, in order to\"\"\"\n    if CFG_MATHJAX_HOSTING.lower() == 'cdn':\n        if https:\n            mathjax_path = \"https://d3eoax9i5htok0.cloudfront.net/mathjax/1.1-latest\"\n        else:\n            mathjax_path = \"http://cdn.mathjax.org/mathjax/1.1-latest\"\n    else:\n        mathjax_path = \"/MathJax\"\n    return \"\"\"<script type=\"text/x-mathjax-config\">\"\"\" %{\n    'mathjax_path': mathjax_path\n", "code_toks_joined": "def get_mathjax_header ( https = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if CFG_MATHJAX_HOSTING . lower ( ) == <STRING> : <NEWLINE> <INDENT> if https : <NEWLINE> <INDENT> mathjax_path = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mathjax_path = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> mathjax_path = <STRING> <NEWLINE> <DEDENT> return <STRING> % { <NEWLINE> <STRING> : mathjax_path <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return the snippet of HTML code to put in HTML HEAD tag, in order to\"\"\"", "'cdn'", "\"https://d3eoax9i5htok0.cloudfront.net/mathjax/1.1-latest\"", "\"http://cdn.mathjax.org/mathjax/1.1-latest\"", "\"/MathJax\"", "\"\"\"<script type=\"text/x-mathjax-config\">\"\"\"", "'mathjax_path'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["5f8d7ab00a34b28ed3a000049724c05a", {"code_string": "def __init__(self, publisher, source_id, app_id = \"WikipediaSensor\"):\n    self.API_URL = \"http://en.wikipedia.org/w/api.php?action=query&list=recentchanges&redirects&format=json&rcnamespace=0&rclimit=500\"\n    self.NS = Namespace(\"http://webtlab.it.uc3m.es/\")\n    self.DC = Namespace(\"http://purl.org/dc/elements/1.1/\")\n        self.http = httplib2.Http()\n        self.publisher = publisher\n        self.app_id = app_id\n        self.source_id = source_id\n        self.last_change = 0\n", "code_toks_joined": "def __init__ ( self , publisher , source_id , app_id = <STRING> ) : <NEWLINE> <INDENT> self . API_URL = <STRING> <NEWLINE> self . NS = Namespace ( <STRING> ) <NEWLINE> self . DC = Namespace ( <STRING> ) <NEWLINE> <INDENT> self . http = httplib2 . Http ( ) <NEWLINE> self . publisher = publisher <NEWLINE> self . app_id = app_id <NEWLINE> self . source_id = source_id <NEWLINE> self . last_change = 0 <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"WikipediaSensor\"", "\"http://en.wikipedia.org/w/api.php?action=query&list=recentchanges&redirects&format=json&rcnamespace=0&rclimit=500\"", "\"http://webtlab.it.uc3m.es/\"", "\"http://purl.org/dc/elements/1.1/\""]}, "err_obj": {"msg": "unexpected indent"}}], ["bd9514b8bf579b77a371e085955829ae", {"code_string": "def rename_models(cr, model_spec):\n    \"\"\"Rename models. Typically called in the pre script.\"\"\"\n    for(old, new) in model_spec:\n        logger.info(\"model %s: renaming to %s\"\n            old, new)\n        cr.execute('UPDATE ir_model SET model = %s '\n            'WHERE model = %s', (new, old, ))\n        cr.execute('UPDATE ir_model_fields SET relation = %s '\n            'WHERE relation = %s', (new, old, ))\n        cr.execute('UPDATE ir_model_data SET model = %s '\n            'WHERE model = %s', (new, old, ))\n", "code_toks_joined": "def rename_models ( cr , model_spec ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for ( old , new ) in model_spec : <NEWLINE> <INDENT> logger . info ( <STRING> <NEWLINE> <INDENT> old , new ) <NEWLINE> <DEDENT> cr . execute ( <STRING> <NEWLINE> <INDENT> <STRING> , ( new , old , ) ) <NEWLINE> <DEDENT> cr . execute ( <STRING> <NEWLINE> <INDENT> <STRING> , ( new , old , ) ) <NEWLINE> <DEDENT> cr . execute ( <STRING> <NEWLINE> <INDENT> <STRING> , ( new , old , ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Rename models. Typically called in the pre script.\"\"\"", "\"model %s: renaming to %s\"", "'UPDATE ir_model SET model = %s '", "'WHERE model = %s'", "'UPDATE ir_model_fields SET relation = %s '", "'WHERE relation = %s'", "'UPDATE ir_model_data SET model = %s '", "'WHERE model = %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["52e6ae71b3d9bf2ae438cced3fb8369b", {"code_string": "def load_embeddings(file_name):\n    with codecs.open(file_name, 'r', 'utf-8') as f_in:\n        vocabulary, wv = zip(*[line.strip().split(' ', 1) for line in\n", "code_toks_joined": "def load_embeddings ( file_name ) : <NEWLINE> <INDENT> with codecs . open ( file_name , <STRING> , <STRING> ) as f_in : <NEWLINE> <INDENT> vocabulary , wv = zip ( * [ line . strip ( ) . split ( <STRING> , 1 ) for line in <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'r'", "'utf-8'", "' '"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["37f0e5942c8c553a386b21d59f29d003", {"code_string": "def save(universe):\n    stamp = re.sub(\"[: \\.]\", \"-\", str(datetime.datetime.now()))[: - 7]\n    f = codecs.open(\"output-{}.graphml\".format(stamp), \"w\", encoding = \"utf-8\")\n    fn = codecs.open(\"fresh-output.graphml\", \"w\", encoding = \"utf-8\")\n    nx.write_graphml(universe, f)\n    nx.write_graphml(universe, fn)\n    print(\"Saved in{}\".format(f)\n", "code_toks_joined": "def save ( universe ) : <NEWLINE> <INDENT> stamp = re . sub ( <STRING> , <STRING> , str ( datetime . datetime . now ( ) ) ) [ : - 7 ] <NEWLINE> f = codecs . open ( <STRING> . format ( stamp ) , <STRING> , encoding = <STRING> ) <NEWLINE> fn = codecs . open ( <STRING> , <STRING> , encoding = <STRING> ) <NEWLINE> nx . write_graphml ( universe , f ) <NEWLINE> nx . write_graphml ( universe , fn ) <NEWLINE> print ( <STRING> . format ( f ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"[: \\.]\"", "\"-\"", "\"output-{}.graphml\"", "\"w\"", "\"utf-8\"", "\"fresh-output.graphml\"", "\"w\"", "\"utf-8\"", "\"Saved in{}\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["d30da398f7349fe8844aa895185fbcbd", {"code_string": "def get_secret_by_name(name, lsakey):\n    global xp\n    r = regkey(\"HKEY_LOCAL_MACHINE\\\\SECURITY\\\\Policy\\\\Secrets\\\\%s\\\\CurrVal\" % name)\n    if not r.is_present():\n        return None\n    enc_secret = r.get_value(\"\")\n    if xp:\n    encryptedSecretSize = unpack('<I', enc_secret[: 4])[0]\n    offset = len(enc_secret) - encryptedSecretSize\n    secret = decrypt_secret(enc_secret[offset: ], lsakey)\n    return decrypt_secret(enc_secret[0xC: ], lsakey)\n    else:\n    return decrypt_lsa2(enc_secret, lsakey)\n", "code_toks_joined": "def get_secret_by_name ( name , lsakey ) : <NEWLINE> <INDENT> global xp <NEWLINE> r = regkey ( <STRING> % name ) <NEWLINE> if not r . is_present ( ) : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> enc_secret = r . get_value ( <STRING> ) <NEWLINE> if xp : <NEWLINE> encryptedSecretSize = unpack ( <STRING> , enc_secret [ : 4 ] ) [ 0 ] <NEWLINE> offset = len ( enc_secret ) - encryptedSecretSize <NEWLINE> secret = decrypt_secret ( enc_secret [ offset : ] , lsakey ) <NEWLINE> return decrypt_secret ( enc_secret [ 0xC : ] , lsakey ) <NEWLINE> else : <NEWLINE> return decrypt_lsa2 ( enc_secret , lsakey ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"HKEY_LOCAL_MACHINE\\\\SECURITY\\\\Policy\\\\Secrets\\\\%s\\\\CurrVal\"", "\"\"", "'<I'"]}, "err_obj": {"msg": "expected an indented block"}}], ["95b9e7fbd37dc749867578ccecaa0965", {"code_string": "def remove_label(self, to_remove):\n    \"\"\"Remove a label from the document. (-> rewrite the label file)\"\"\"\n    if to_remove not in self.labels:\n        return\n    labels = self.labels\n    labels.remove(to_remove)\n    with codecs.open(os.path.join(self.path, self.LABEL_FILE), 'w',\n        encoding = 'utf-8') as file_desc:\n        for label in labels:\n        file_desc.write(\"%s,%s\\n\" %(label.name,\n            label.get_color_str()))\n    self.drop_cache()\n", "code_toks_joined": "def remove_label ( self , to_remove ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if to_remove not in self . labels : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> labels = self . labels <NEWLINE> labels . remove ( to_remove ) <NEWLINE> with codecs . open ( os . path . join ( self . path , self . LABEL_FILE ) , <STRING> , <NEWLINE> <INDENT> encoding = <STRING> ) as file_desc : <NEWLINE> for label in labels : <NEWLINE> file_desc . write ( <STRING> % ( label . name , <NEWLINE> <INDENT> label . get_color_str ( ) ) ) <NEWLINE> <DEDENT> <DEDENT> self . drop_cache ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Remove a label from the document. (-> rewrite the label file)\"\"\"", "'w'", "'utf-8'", "\"%s,%s\\n\""]}, "err_obj": {"msg": "expected an indented block"}}], ["54f0af3d332b66f8cfa695a66d5ff6e6", {"code_string": "def doBackup(self):\n    self.getLocalDirectoryList()\n        self.getRemoteDirectoryList()\n    f = open(PATH + '/fileList.txt', 'r')\n        directories = f.read().split('\\n')\n    del directories[0: 2]\n        f.close()\n        for dir in directories:\n        self.syncDirectory(dir)\n", "code_toks_joined": "def doBackup ( self ) : <NEWLINE> <INDENT> self . getLocalDirectoryList ( ) <NEWLINE> <INDENT> self . getRemoteDirectoryList ( ) <NEWLINE> <DEDENT> f = open ( PATH + <STRING> , <STRING> ) <NEWLINE> <INDENT> directories = f . read ( ) . split ( <STRING> ) <NEWLINE> <DEDENT> del directories [ 0 : 2 ] <NEWLINE> <INDENT> f . close ( ) <NEWLINE> for dir in directories : <NEWLINE> self . syncDirectory ( dir ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'/fileList.txt'", "'r'", "'\\n'"]}, "err_obj": {"msg": "unexpected indent"}}], ["d9575c7a6bff992e13b6abf9e0f71819", {"code_string": "import smbus\nimport time\nfrom ctypes import c_short\nDEVICE = 0x77 uses 0\nbus = smbus.SMBus(1)\n", "code_toks_joined": "import smbus <NEWLINE> import time <NEWLINE> from ctypes import c_short <NEWLINE> DEVICE = 0x77 uses 0 <NEWLINE> bus = smbus . SMBus ( 1 ) <NEWLINE>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["24a47f3f12d2df67e45c8270af3f17ea", {"code_string": "class Ui_MainWindow(object):\n    def setupUi(self, MainWindow):\n        MainWindow.setObjectName(_fromUtf8(\"MainWindow\"))\n        MainWindow.resize(804, 628)\n        MainWindow.setStyleSheet(_fromUtf8(\"QPushButton {\\n\"\n", "code_toks_joined": "class Ui_MainWindow ( object ) : <NEWLINE> <INDENT> def setupUi ( self , MainWindow ) : <NEWLINE> <INDENT> MainWindow . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> MainWindow . resize ( 804 , 628 ) <NEWLINE> MainWindow . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"MainWindow\"", "\"QPushButton {\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["59c23622d05d37c63fc463ea723a9b93", {"code_string": "def _checkpath(self, path):\n    try:\n        if not util.ioretry(lambda: util.pathexists(path)):\n            return False\n        return True\n    except util.CommandException, inst:\n        raise xs_errors.XenError('EIO', opterr = 'IO error checking path %s' % path)\n", "code_toks_joined": "def _checkpath ( self , path ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if not util . ioretry ( lambda : util . pathexists ( path ) ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT> except util . CommandException , inst : <NEWLINE> <INDENT> raise xs_errors . XenError ( <STRING> , opterr = <STRING> % path ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'EIO'", "'IO error checking path %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["7d7069472f99a1204db6c460896bdbc5", {"code_string": "def prog_grab(code):\n    kod = code.lower()\n    req = urllib2.Request('http://tv.yandex.ru/?mode=print&channel=' + kod)\n    r = urllib2.urlopen(req)\n    radky = r.readlines()\n        program = \"\"\n    for x in radky:\n        if x.find('<div>') != - 1:\n            if re.search('<.*?>\\d', x):\n                program += \"\\n\" + re.sub(r'<.*?>', '', x).replace(\"\\n\", '')\n                    return program\n", "code_toks_joined": "def prog_grab ( code ) : <NEWLINE> <INDENT> kod = code . lower ( ) <NEWLINE> req = urllib2 . Request ( <STRING> + kod ) <NEWLINE> r = urllib2 . urlopen ( req ) <NEWLINE> radky = r . readlines ( ) <NEWLINE> <INDENT> program = <STRING> <NEWLINE> <DEDENT> for x in radky : <NEWLINE> <INDENT> if x . find ( <STRING> ) != - 1 : <NEWLINE> <INDENT> if re . search ( <STRING> , x ) : <NEWLINE> <INDENT> program += <STRING> + re . sub ( <STRING> , <STRING> , x ) . replace ( <STRING> , <STRING> ) <NEWLINE> <INDENT> return program <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'http://tv.yandex.ru/?mode=print&channel='", "\"\"", "'<div>'", "'<.*?>\\d'", "\"\\n\"", "r'<.*?>'", "''", "\"\\n\"", "''"]}, "err_obj": {"msg": "unexpected indent"}}], ["55a00d48290c2ba7e0270cc22aca7e25", {"code_string": "def KeypadCallback(self, data):\n    if data ==(0, 0, 0, 0, , 0, 0, 0, 0):\n        self.EndLastEvent()\n    else:\n        self.TriggerEnduringEvent(KEYPAD_CODES[data])\n", "code_toks_joined": "def KeypadCallback ( self , data ) : <NEWLINE> <INDENT> if data == ( 0 , 0 , 0 , 0 , , 0 , 0 , 0 , 0 ) : <NEWLINE> <INDENT> self . EndLastEvent ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . TriggerEnduringEvent ( KEYPAD_CODES [ data ] ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["73209efb608a3773dda4310d1ee0298b", {"code_string": "def hypernym_distances(self):\n    '''Returns a list of synsets on the path from this synset to the root'''\n    retval = dict()\n    for(synset, dist) in reduce(\n        set.union,\n        [[(synset, idx) for(idx, synset) in enumerate(reversed(path))]\n            for path in self.hypernym_paths],\n        set()):\n        if synset not in retval or dist < retval[synset]:\n        retval[synset] = dist\n    return set(retval.items())\n", "code_toks_joined": "def hypernym_distances ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> retval = dict ( ) <NEWLINE> for ( synset , dist ) in reduce ( <NEWLINE> <INDENT> set . union , <NEWLINE> [ [ ( synset , idx ) for ( idx , synset ) in enumerate ( reversed ( path ) ) ] <NEWLINE> <INDENT> for path in self . hypernym_paths ] , <NEWLINE> <DEDENT> set ( ) ) : <NEWLINE> if synset not in retval or dist < retval [ synset ] : <NEWLINE> retval [ synset ] = dist <NEWLINE> <DEDENT> return set ( retval . items ( ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Returns a list of synsets on the path from this synset to the root'''"]}, "err_obj": {"msg": "expected an indented block"}}], ["d8f74a0dcdf92adde6d78b40a111d76b", {"code_string": "def start(self):\n    for g, f in dict(gen = 'udpreceiver', gentcp = 'tcpreceiver', genmcast = 'mcastreceiver').items():\n        exec 'if self.%s is None: self.%s = self.%s(); multitask.add(self.%s)' %(g, g, f, g)\n    return self\n", "code_toks_joined": "def start ( self ) : <NEWLINE> <INDENT> for g , f in dict ( gen = <STRING> , gentcp = <STRING> , genmcast = <STRING> ) . items ( ) : <NEWLINE> <INDENT> exec <STRING> % ( g , g , f , g ) <NEWLINE> <DEDENT> return self <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'udpreceiver'", "'tcpreceiver'", "'mcastreceiver'", "'if self.%s is None: self.%s = self.%s(); multitask.add(self.%s)'"]}, "err_obj": {"msg": "invalid syntax"}}], ["03c7bb3f4ef87cf3548ebbbe5f592ee8", {"code_string": "import distutils\nfrom distutils.core import setup, Extension\nimport distutils.dep_util\nimport os, string\ndef fortran_extension(module_name, c_files, fortran_files, library_dirs,\n    libraries):\n    fcompiler = f90_compiler()\n    library_name = module_name + '_fortran'\n    fcompiler.build_library(library_name, fortran_files)\n    libraries.append(library_name)\n    ext = Extension(module_name, c_files,\n        library_dirs = library_dirs_list,\n        libraries = libraries_list)\n        return ext\n", "code_toks_joined": "import distutils <NEWLINE> from distutils . core import setup , Extension <NEWLINE> import distutils . dep_util <NEWLINE> import os , string <NEWLINE> def fortran_extension ( module_name , c_files , fortran_files , library_dirs , <NEWLINE> <INDENT> libraries ) : <NEWLINE> fcompiler = f90_compiler ( ) <NEWLINE> library_name = module_name + <STRING> <NEWLINE> fcompiler . build_library ( library_name , fortran_files ) <NEWLINE> libraries . append ( library_name ) <NEWLINE> ext = Extension ( module_name , c_files , <NEWLINE> <INDENT> library_dirs = library_dirs_list , <NEWLINE> libraries = libraries_list ) <NEWLINE> return ext <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'_fortran'"]}, "err_obj": {"msg": "unexpected indent"}}], ["76ff145bf78336853380353b75e35f6b", {"code_string": "def get_encryption(cell):\n    \"\"\" Gets the encryption type of a network / cell.\"\"\"\n    enc = \"\"\n    if matching_line(cell, \"Encryption key:\") == \"off\":\n        enc = \"Open\"\n    else:\n        for line in cell:\n            matching = match(line, \"IE:\")\n            if matching is not None:\n    wpa = re.search(\"WPA[2]*\", matching)\n        if wpa is not None:\n            enc = wpa.group(0)\n            if enc == \"\":\n            enc = \"WEP\"\n    return enc\n", "code_toks_joined": "def get_encryption ( cell ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> enc = <STRING> <NEWLINE> if matching_line ( cell , <STRING> ) == <STRING> : <NEWLINE> <INDENT> enc = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for line in cell : <NEWLINE> <INDENT> matching = match ( line , <STRING> ) <NEWLINE> if matching is not None : <NEWLINE> <DEDENT> <DEDENT> wpa = re . search ( <STRING> , matching ) <NEWLINE> <INDENT> if wpa is not None : <NEWLINE> <INDENT> enc = wpa . group ( 0 ) <NEWLINE> if enc == <STRING> : <NEWLINE> enc = <STRING> <NEWLINE> <DEDENT> <DEDENT> return enc <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Gets the encryption type of a network / cell.\"\"\"", "\"\"", "\"Encryption key:\"", "\"off\"", "\"Open\"", "\"IE:\"", "\"WPA[2]*\"", "\"\"", "\"WEP\""]}, "err_obj": {"msg": "expected an indented block"}}], ["75424dce4080ad47cfb4d0f1fda70789", {"code_string": "def get_fs_type(self, drive_num):\n    volume = self.get_device_with_udi(drive_num)\n        return volume.GetProperty('volume.fsversion')\n", "code_toks_joined": "def get_fs_type ( self , drive_num ) : <NEWLINE> <INDENT> volume = self . get_device_with_udi ( drive_num ) <NEWLINE> <INDENT> return volume . GetProperty ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'volume.fsversion'"]}, "err_obj": {"msg": "unexpected indent"}}], ["f5b7000002487270332f72e93291603b", {"code_string": "def uisetup(ui):\n    'Replace pull with a decorator to provide --rebase option'\n    entry = extensions.wrapcommand(commands.table, 'pull', pullrebase)\n    entry[1].append(('', 'rebase', None,\n        _(\"rebase working directory to branch head\"))\n", "code_toks_joined": "def uisetup ( ui ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> entry = extensions . wrapcommand ( commands . table , <STRING> , pullrebase ) <NEWLINE> entry [ 1 ] . append ( ( <STRING> , <STRING> , None , <NEWLINE> <INDENT> _ ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Replace pull with a decorator to provide --rebase option'", "'pull'", "''", "'rebase'", "\"rebase working directory to branch head\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["57b0877cea49f5103173d14ad5db2225", {"code_string": "def write_heading(self, heading):\n    print(\"<h%(level)i>%(str)s</h%(level)i>\" %{\n        'level': heading.m_level,\n        'str': heading.m_text}\n", "code_toks_joined": "def write_heading ( self , heading ) : <NEWLINE> <INDENT> print ( <STRING> % { <NEWLINE> <INDENT> <STRING> : heading . m_level , <NEWLINE> <STRING> : heading . m_text } <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"<h%(level)i>%(str)s</h%(level)i>\"", "'level'", "'str'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["039f7b61c1acd93d3548ed1c2f78d1f5", {"code_string": "\"\"\"WSGI config for pizzaria project.\"\"\"\nimport os\nfrom django.core.wsgi import get_wsgi_application\nfrom dj static import Cling\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"pizzaria.settings\")\napplication = Cling(get_wsgi_application())\n", "code_toks_joined": "<STRING> <NEWLINE> import os <NEWLINE> from django . core . wsgi import get_wsgi_application <NEWLINE> from dj static import Cling <NEWLINE> os . environ . setdefault ( <STRING> , <STRING> ) <NEWLINE> application = Cling ( get_wsgi_application ( ) ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"\"\"WSGI config for pizzaria project.\"\"\"", "\"DJANGO_SETTINGS_MODULE\"", "\"pizzaria.settings\""]}, "err_obj": {"msg": "invalid syntax"}}], ["3984eafee946fa0b091259c319be042e", {"code_string": "def _select_pattern(self, event):\n    for pattern in self._context.hook_client_patterns_list(\n        patterns.patterns_list):\n        if pattern.accept_answer(event):\n        return pattern\n    return None\n", "code_toks_joined": "def _select_pattern ( self , event ) : <NEWLINE> <INDENT> for pattern in self . _context . hook_client_patterns_list ( <NEWLINE> <INDENT> patterns . patterns_list ) : <NEWLINE> if pattern . accept_answer ( event ) : <NEWLINE> return pattern <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["f8babeb5a9b86e37ca176b9626792184", {"code_string": "def when_i_fill_in_the_new_values_for_the_indicator(step):\n    world.form_data = {'survey': world.survey.id,\n        'batch': world.batch_1.id,\n        ,\n        'module': world.indicator_1.module.id,\n        'name': \"Indicator new nme \",\n        'description': \"Hoho description\",\n        'measure': '%'}\n    world.page.fill_valid_values(world.form_data)\n", "code_toks_joined": "def when_i_fill_in_the_new_values_for_the_indicator ( step ) : <NEWLINE> <INDENT> world . form_data = { <STRING> : world . survey . id , <NEWLINE> <INDENT> <STRING> : world . batch_1 . id , <NEWLINE> , <NEWLINE> <STRING> : world . indicator_1 . module . id , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> } <NEWLINE> <DEDENT> world . page . fill_valid_values ( world . form_data ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'survey'", "'batch'", "'module'", "'name'", "\"Indicator new nme \"", "'description'", "\"Hoho description\"", "'measure'", "'%'"]}, "err_obj": {"msg": "invalid syntax"}}], ["374db63ed0389714435123f7df1b9306", {"code_string": "def run(self):\n    '''Handle device timeouts.  Runs in the context of the Plugins'''\n    now = time.time()\n    for wallet in self.device_manager().paired_wallets():\n        if(isinstance(wallet, self.wallet_class)\n            and hasattr(wallet, 'last_operation')\n            and now > wallet.last_operation + wallet.session_timeout):\n            client = self.get_client(wallet, force_pair = False)\n            if client:\n            client.clear_session()\n            wallet.last_operation = self.prevent_timeout\n            wallet.timeout()\n", "code_toks_joined": "def run ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> now = time . time ( ) <NEWLINE> for wallet in self . device_manager ( ) . paired_wallets ( ) : <NEWLINE> <INDENT> if ( isinstance ( wallet , self . wallet_class ) <NEWLINE> <INDENT> and hasattr ( wallet , <STRING> ) <NEWLINE> and now > wallet . last_operation + wallet . session_timeout ) : <NEWLINE> client = self . get_client ( wallet , force_pair = False ) <NEWLINE> if client : <NEWLINE> client . clear_session ( ) <NEWLINE> wallet . last_operation = self . prevent_timeout <NEWLINE> wallet . timeout ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Handle device timeouts.  Runs in the context of the Plugins'''", "'last_operation'"]}, "err_obj": {"msg": "expected an indented block"}}], ["3b13b6ae1c74ce3ed227e0a7214779d1", {"code_string": "def connect(self, server = '127.0.0.1', port = 6379 db = 6):\n    self.redis = redis.Redis(server, port, db)\n    self.__is_connected__ = True\n", "code_toks_joined": "def connect ( self , server = <STRING> , port = 6379 db = 6 ) : <NEWLINE> <INDENT> self . redis = redis . Redis ( server , port , db ) <NEWLINE> self . __is_connected__ = True <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'127.0.0.1'"]}, "err_obj": {"msg": "invalid syntax"}}], ["591660482d69a9a32c989ac5fc926291", {"code_string": "def scatter(self, * args, ** properties):\n    markeredgecolor = properties.pop('color', 'r')\n    markersize = properties.pop('size', 6)\n    _properties = {'marker': 's', 'markersize': markersize, 'linewidth': 0,\n        'markerfacecolor': 'none', 'markeredgecolor': markeredgecolor, 'markeredgewidth': 2\n        }\n        _properties.update(** properties)\n        self.plot(* args, ** _properties)\n", "code_toks_joined": "def scatter ( self , * args , ** properties ) : <NEWLINE> <INDENT> markeredgecolor = properties . pop ( <STRING> , <STRING> ) <NEWLINE> markersize = properties . pop ( <STRING> , 6 ) <NEWLINE> _properties = { <STRING> : <STRING> , <STRING> : markersize , <STRING> : 0 , <NEWLINE> <INDENT> <STRING> : <STRING> , <STRING> : markeredgecolor , <STRING> : 2 <NEWLINE> } <NEWLINE> _properties . update ( ** properties ) <NEWLINE> self . plot ( * args , ** _properties ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'color'", "'r'", "'size'", "'marker'", "'s'", "'markersize'", "'linewidth'", "'markerfacecolor'", "'none'", "'markeredgecolor'", "'markeredgewidth'"]}, "err_obj": {"msg": "unexpected indent"}}], ["b9d4d8b6f5d9c32084dcf89436a22fba", {"code_string": "def display_image(window_name, img, reduction = 2, text = ''):\n    \"\"\"Resize image and display using imshow. Mainly for debugging\"\"\"\n    reduction = constrain(reduction, 1.2, 6)\n    newx, newy = int(img.shape[1] / reduction), int(img.shape[0] / reduction)\n    newimg = cv2.resize(img, (newx, newy))\n    if text != '':\n    display_shadow_text(newimg, 20, 25, text)\n    cv2.imshow(window_name, newimg)\n", "code_toks_joined": "def display_image ( window_name , img , reduction = 2 , text = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> reduction = constrain ( reduction , 1.2 , 6 ) <NEWLINE> newx , newy = int ( img . shape [ 1 ] / reduction ) , int ( img . shape [ 0 ] / reduction ) <NEWLINE> newimg = cv2 . resize ( img , ( newx , newy ) ) <NEWLINE> if text != <STRING> : <NEWLINE> display_shadow_text ( newimg , 20 , 25 , text ) <NEWLINE> cv2 . imshow ( window_name , newimg ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "\"\"\"Resize image and display using imshow. Mainly for debugging\"\"\"", "''"]}, "err_obj": {"msg": "expected an indented block"}}], ["7d9a2dcd76cc546394034f9c2afd8cad", {"code_string": "def test_delete_all_ports(self):\n    with mock.patch.object(self.br, 'get_port_name_list',\n        return_value = ['port1']) as get_port:\n        with mock.patch.object(self.br, 'delete_port') as delete_port:\n        self.br.delete_ports(all_ports = True)\n    get_port.assert_called_once_with()\n    delete_port.assert_called_once_with('port1')\n", "code_toks_joined": "def test_delete_all_ports ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( self . br , <STRING> , <NEWLINE> <INDENT> return_value = [ <STRING> ] ) as get_port : <NEWLINE> with mock . patch . object ( self . br , <STRING> ) as delete_port : <NEWLINE> self . br . delete_ports ( all_ports = True ) <NEWLINE> <DEDENT> get_port . assert_called_once_with ( ) <NEWLINE> delete_port . assert_called_once_with ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'get_port_name_list'", "'port1'", "'delete_port'", "'port1'"]}, "err_obj": {"msg": "expected an indented block"}}], ["4772f697c1d0fbb113f4c8e54ed874e2", {"code_string": "class _CSMSchemaFieldString(_CSMSchemaField):\n    def __init__(self, ptr, name = None):\n    _CSMSchemaField.__init__(self, ptr, name)\n    length = libCSM.csm_schema_field_get_string_length(self.ptr)\n    if length:\n        self.length = length\n", "code_toks_joined": "class _CSMSchemaFieldString ( _CSMSchemaField ) : <NEWLINE> <INDENT> def __init__ ( self , ptr , name = None ) : <NEWLINE> _CSMSchemaField . __init__ ( self , ptr , name ) <NEWLINE> length = libCSM . csm_schema_field_get_string_length ( self . ptr ) <NEWLINE> if length : <NEWLINE> <INDENT> self . length = length <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["646a88c9c8a2c787bb72f09237038b82", {"code_string": "class ChartsApplication(WApplication):\n    def __init__(self, env):\n        WApplication.__init__(self, env)\n            self.setTitle(WString(\"Charts example\"));\n                self.setCssTheme(\"polished\");\n            self.messageResourceBundle().use(\"charts\");\n            self.root().setPadding(WLength(10));\n            self.root().resize(WLength.Auto, WLength.Auto);\n            ChartsExample(self.root());\n            self.useStyleSheet(WLink(\"charts.css\"));\n", "code_toks_joined": "class ChartsApplication ( WApplication ) : <NEWLINE> <INDENT> def __init__ ( self , env ) : <NEWLINE> <INDENT> WApplication . __init__ ( self , env ) <NEWLINE> <INDENT> self . setTitle ( WString ( <STRING> ) ) ; <NEWLINE> <INDENT> self . setCssTheme ( <STRING> ) ; <NEWLINE> <DEDENT> self . messageResourceBundle ( ) . use ( <STRING> ) ; <NEWLINE> self . root ( ) . setPadding ( WLength ( 10 ) ) ; <NEWLINE> self . root ( ) . resize ( WLength . Auto , WLength . Auto ) ; <NEWLINE> ChartsExample ( self . root ( ) ) ; <NEWLINE> self . useStyleSheet ( WLink ( <STRING> ) ) ; <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Charts example\"", "\"polished\"", "\"charts\"", "\"charts.css\""]}, "err_obj": {"msg": "unexpected indent"}}], ["8852cf55789d1ae4c5597bf48850c7fe", {"code_string": "def get_pc(self, (n, vcount), tag = None):\n    pc_env = self.get_node_pc_env((n, vcount), tag = tag)\n    if pc_env == None:\n        trace('Warning: unreachable n_vc, tag: %s, %s' %((n, vcount), tag))\n        return false_term\n    (pc, env) = pc_env\n    return to_smt_expr(pc, env, self.solv)\n", "code_toks_joined": "def get_pc ( self , ( n , vcount ) , tag = None ) : <NEWLINE> <INDENT> pc_env = self . get_node_pc_env ( ( n , vcount ) , tag = tag ) <NEWLINE> if pc_env == None : <NEWLINE> <INDENT> trace ( <STRING> % ( ( n , vcount ) , tag ) ) <NEWLINE> return false_term <NEWLINE> <DEDENT> ( pc , env ) = pc_env <NEWLINE> return to_smt_expr ( pc , env , self . solv ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Warning: unreachable n_vc, tag: %s, %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["ff5d845a5a4cfddc764ef30ae82451d4", {"code_string": "import sublime\nimport json\nst_version = int(sublime.version()\n", "code_toks_joined": "import sublime <NEWLINE> import json <NEWLINE> st_version = int ( sublime . version ( ) <NEWLINE>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["58dcf51cdbff0b35d5c6d562b8cb63c2", {"code_string": "class TestTemplateLoader(loader.BaseLoader):\n    \"A custom template loader that loads templates from a dictionary.\"\n    is_usable = True\n    def __init__(self, templates_dict):\n        self.templates_dict = templates_dict\n    def load_template_source(self, template_name, template_dirs = None,\n        skip_template = None):\n        try:\n        return(self.templates_dict[template_name],\n        \"test:%s\" % template_name)\n        except KeyError:\n        raise TemplateDoesNotExist(template_name)\n", "code_toks_joined": "class TestTemplateLoader ( loader . BaseLoader ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> is_usable = True <NEWLINE> def __init__ ( self , templates_dict ) : <NEWLINE> <INDENT> self . templates_dict = templates_dict <NEWLINE> <DEDENT> def load_template_source ( self , template_name , template_dirs = None , <NEWLINE> <INDENT> skip_template = None ) : <NEWLINE> try : <NEWLINE> return ( self . templates_dict [ template_name ] , <NEWLINE> <STRING> % template_name ) <NEWLINE> except KeyError : <NEWLINE> raise TemplateDoesNotExist ( template_name ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"A custom template loader that loads templates from a dictionary.\"", "\"test:%s\""]}, "err_obj": {"msg": "expected an indented block"}}], ["70da61b78b7f71a43333d0a77af2fd55", {"code_string": "def setTempo(self, t):\n    if(Config.DEBUG > 3):\n        print 'INFO: loop tempo: %f -> %f' %(t, 60.0 /(Config.TICKS_PER_BEAT * t))\n    sc_setTickDuration(60.0 /(Config.TICKS_PER_BEAT * t))\n", "code_toks_joined": "def setTempo ( self , t ) : <NEWLINE> <INDENT> if ( Config . DEBUG > 3 ) : <NEWLINE> <INDENT> print <STRING> % ( t , 60.0 / ( Config . TICKS_PER_BEAT * t ) ) <NEWLINE> <DEDENT> sc_setTickDuration ( 60.0 / ( Config . TICKS_PER_BEAT * t ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'INFO: loop tempo: %f -> %f'"]}, "err_obj": {"msg": "invalid syntax"}}], ["5f5661af4f6493d317279b43861e800f", {"code_string": "def OnEnter(self, x, y, d):\n    if self.debug:\n        print \"OnEnter: %d, %d, %d\\n\" %(x, y, d)\n    return d\n", "code_toks_joined": "def OnEnter ( self , x , y , d ) : <NEWLINE> <INDENT> if self . debug : <NEWLINE> <INDENT> print <STRING> % ( x , y , d ) <NEWLINE> <DEDENT> return d <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"OnEnter: %d, %d, %d\\n\""]}, "err_obj": {"msg": "invalid syntax"}}], ["0f7e28b020b7f45c03c84a73bc0becca", {"code_string": "class RunLengthAdapter(Adapter):\n    def _encode(self, obj):\n        return len(obj), obj[0]\n    def _decode(self, (length, value)):\n        return[value] * length\n", "code_toks_joined": "class RunLengthAdapter ( Adapter ) : <NEWLINE> <INDENT> def _encode ( self , obj ) : <NEWLINE> <INDENT> return len ( obj ) , obj [ 0 ] <NEWLINE> <DEDENT> def _decode ( self , ( length , value ) ) : <NEWLINE> <INDENT> return [ value ] * length <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["91cc4ecee959f646e2183fd3ee627609", {"code_string": "def go(comm, ngpts, repeat, narrays, out, prec):\n    N_c = np.array((ngpts, ngpts, ngpts))\n    a = 10.0\n    gd = GridDescriptor(N_c, (a, a, a), comm = comm))\n    gdcoarse = gd.coarsen()\n    gdfine = gd.refine()\n    kin1 = Laplace(gd, - 0.5, 1).apply\n    laplace = Laplace(gd, - 0.5, 2)\n    kin2 = laplace.apply\n    restrict = Transformer(gd, gdcoarse, 1).apply\n    interpolate = Transformer(gd, gdfine, 1).apply\n    precondition = Preconditioner(gd, laplace, np_float)\n    a1 = gd.empty(narrays)\n    a1[: ] = 1.0\n    a2 = gd.empty(narrays)\n    c = gdcoarse.empty(narrays)\n    f = gdfine.empty(narrays)\n    T = [0, 0, 0, 0, 0]\n    for i in range(repeat):\n        comm.barrier()\n        kin1(a1, a2)\n        comm.barrier()\n        t0a = time()\n        kin1(a1, a2)\n        t0b = time()\n        comm.barrier()\n        t1a = time()\n        kin2(a1, a2)\n        t1b = time()\n        comm.barrier()\n        t2a = time()\n        for A, C in zip(a1, c):\n            restrict(A, C)\n        t2b = time()\n        comm.barrier()\n        t3a = time()\n        for A, F in zip(a1, f):\n            interpolate(A, F)\n        t3b = time()\n        comm.barrier()\n        if prec:\n            t4a = time()\n            for A in a1:\n                precondition(A, None, None, None)\n            t4b = time()\n            comm.barrier()\n        T[0] += t0b - t0a\n        T[1] += t1b - t1a\n        T[2] += t2b - t2a\n        T[3] += t3b - t3a\n        if prec:\n            T[4] += t4b - t4a\n    if mpi.rank == 0:\n        out.write(' %2d %2d %2d' % tuple(gd.parsize_c))\n        out.write(' %12.6f %12.6f %12.6f %12.6f %12.6f\\n' %\n            tuple([t / repeat / narrays for t in T]))\n        out.flush()\n", "code_toks_joined": "def go ( comm , ngpts , repeat , narrays , out , prec ) : <NEWLINE> <INDENT> N_c = np . array ( ( ngpts , ngpts , ngpts ) ) <NEWLINE> a = 10.0 <NEWLINE> gd = GridDescriptor ( N_c , ( a , a , a ) , comm = comm ) ) <NEWLINE> gdcoarse = gd . coarsen ( ) <NEWLINE> gdfine = gd . refine ( ) <NEWLINE> kin1 = Laplace ( gd , - 0.5 , 1 ) . apply <NEWLINE> laplace = Laplace ( gd , - 0.5 , 2 ) <NEWLINE> kin2 = laplace . apply <NEWLINE> restrict = Transformer ( gd , gdcoarse , 1 ) . apply <NEWLINE> interpolate = Transformer ( gd , gdfine , 1 ) . apply <NEWLINE> precondition = Preconditioner ( gd , laplace , np_float ) <NEWLINE> a1 = gd . empty ( narrays ) <NEWLINE> a1 [ : ] = 1.0 <NEWLINE> a2 = gd . empty ( narrays ) <NEWLINE> c = gdcoarse . empty ( narrays ) <NEWLINE> f = gdfine . empty ( narrays ) <NEWLINE> T = [ 0 , 0 , 0 , 0 , 0 ] <NEWLINE> for i in range ( repeat ) : <NEWLINE> <INDENT> comm . barrier ( ) <NEWLINE> kin1 ( a1 , a2 ) <NEWLINE> comm . barrier ( ) <NEWLINE> t0a = time ( ) <NEWLINE> kin1 ( a1 , a2 ) <NEWLINE> t0b = time ( ) <NEWLINE> comm . barrier ( ) <NEWLINE> t1a = time ( ) <NEWLINE> kin2 ( a1 , a2 ) <NEWLINE> t1b = time ( ) <NEWLINE> comm . barrier ( ) <NEWLINE> t2a = time ( ) <NEWLINE> for A , C in zip ( a1 , c ) : <NEWLINE> <INDENT> restrict ( A , C ) <NEWLINE> <DEDENT> t2b = time ( ) <NEWLINE> comm . barrier ( ) <NEWLINE> t3a = time ( ) <NEWLINE> for A , F in zip ( a1 , f ) : <NEWLINE> <INDENT> interpolate ( A , F ) <NEWLINE> <DEDENT> t3b = time ( ) <NEWLINE> comm . barrier ( ) <NEWLINE> if prec : <NEWLINE> <INDENT> t4a = time ( ) <NEWLINE> for A in a1 : <NEWLINE> <INDENT> precondition ( A , None , None , None ) <NEWLINE> <DEDENT> t4b = time ( ) <NEWLINE> comm . barrier ( ) <NEWLINE> <DEDENT> T [ 0 ] += t0b - t0a <NEWLINE> T [ 1 ] += t1b - t1a <NEWLINE> T [ 2 ] += t2b - t2a <NEWLINE> T [ 3 ] += t3b - t3a <NEWLINE> if prec : <NEWLINE> <INDENT> T [ 4 ] += t4b - t4a <NEWLINE> <DEDENT> <DEDENT> if mpi . rank == 0 : <NEWLINE> <INDENT> out . write ( <STRING> % tuple ( gd . parsize_c ) ) <NEWLINE> out . write ( <STRING> % <NEWLINE> <INDENT> tuple ( [ t / repeat / narrays for t in T ] ) ) <NEWLINE> <DEDENT> out . flush ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["' %2d %2d %2d'", "' %12.6f %12.6f %12.6f %12.6f %12.6f\\n'"]}, "window_span": [37, 57], "err_obj": {"msg": "unbalanced (){}[]"}}], ["f90ab72f9c41b7506b99fbbded900966", {"code_string": "def test_invalid_metaclass(self):\n    module = astroid.parse('''import six''')\n    for class_obj, metaclass_name in(('ThirdInvalid', '2'),\n        ('SecondInvalid', 'InvalidAsMetaclass'),\n        ('FirstInvalid', 'int')):\n        classdef = module[class_obj]\n        message = Message('invalid-metaclass', node = classdef, args = (metaclass_name, ))\n        with self.assertAddsMessages(message):\n        self.checker.visit_classdef(classdef)\n", "code_toks_joined": "def test_invalid_metaclass ( self ) : <NEWLINE> <INDENT> module = astroid . parse ( <STRING> ) <NEWLINE> for class_obj , metaclass_name in ( ( <STRING> , <STRING> ) , <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) ) : <NEWLINE> classdef = module [ class_obj ] <NEWLINE> message = Message ( <STRING> , node = classdef , args = ( metaclass_name , ) ) <NEWLINE> with self . assertAddsMessages ( message ) : <NEWLINE> self . checker . visit_classdef ( classdef ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''import six'''", "'ThirdInvalid'", "'2'", "'SecondInvalid'", "'InvalidAsMetaclass'", "'FirstInvalid'", "'int'", "'invalid-metaclass'"]}, "err_obj": {"msg": "expected an indented block"}}], ["dcfb998a0327ab5ff70c3d0e58ba9aaf", {"code_string": "def temporal_relation(self, map):\n    \"\"\"Return the temporal relation of this and the provided temporal map\"\"\"\n    if self.is_time_absolute() and map.is_time_absolute():\n        return self.absolute_time.temporal_relation(map.absolute_time)\n            if self.is_time_relative() and map.is_time_relative():\n        return self.relative_time.temporal_relation(map.relative_time)\n        return None\n", "code_toks_joined": "def temporal_relation ( self , map ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . is_time_absolute ( ) and map . is_time_absolute ( ) : <NEWLINE> <INDENT> return self . absolute_time . temporal_relation ( map . absolute_time ) <NEWLINE> <INDENT> if self . is_time_relative ( ) and map . is_time_relative ( ) : <NEWLINE> <DEDENT> return self . relative_time . temporal_relation ( map . relative_time ) <NEWLINE> return None <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return the temporal relation of this and the provided temporal map\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["ba809d08ea457059636f11f5b3dd276c", {"code_string": "def get_individual_info(p_filename, p_info):\n    info = None\n    with open(p_filename, 'rb') as f:\n        for line in f:\n        columns = line.split()\n            if columns[0] == p_info:\n                info = columns[2]\n                break\n    return info\n", "code_toks_joined": "def get_individual_info ( p_filename , p_info ) : <NEWLINE> <INDENT> info = None <NEWLINE> with open ( p_filename , <STRING> ) as f : <NEWLINE> <INDENT> for line in f : <NEWLINE> columns = line . split ( ) <NEWLINE> <INDENT> if columns [ 0 ] == p_info : <NEWLINE> <INDENT> info = columns [ 2 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return info <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'rb'"]}, "err_obj": {"msg": "expected an indented block"}}], ["446e6a1dfa147d8d122012db7b6a94c2", {"code_string": "def pad(string, length):\n    '''Pad a string with spaces.'''\n    if len(string) <= length:\n        return string + ' ' *(length - len(string)))\n    else:\n        return string[: length - 3] + '...'\n", "code_toks_joined": "def pad ( string , length ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if len ( string ) <= length : <NEWLINE> <INDENT> return string + <STRING> * ( length - len ( string ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return string [ : length - 3 ] + <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Pad a string with spaces.'''", "' '", "'...'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e4b033b3e76846509a5c9baab8731945", {"code_string": "def test_cannot_see_forms_without_permission(self):\n    self.client.login(username = 'eventeditor', password = 'password')\n    response = self.client.get(reverse('wagtailforms_index')\n    self.assertFalse(self.form_page in response.context['form_pages'])\n", "code_toks_joined": "def test_cannot_see_forms_without_permission ( self ) : <NEWLINE> <INDENT> self . client . login ( username = <STRING> , password = <STRING> ) <NEWLINE> response = self . client . get ( reverse ( <STRING> ) <NEWLINE> self . assertFalse ( self . form_page in response . context [ <STRING> ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'eventeditor'", "'password'", "'wagtailforms_index'", "'form_pages'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["8e617e6b6c4bfa948acb26afd030c004", {"code_string": "def pytest_configure(config):\n    from django.conf import settings\n        settings.INSTALLED_APPS = filter(lambda s: s != 'devserver', settings.INSTALLED_APPS)\n", "code_toks_joined": "def pytest_configure ( config ) : <NEWLINE> <INDENT> from django . conf import settings <NEWLINE> <INDENT> settings . INSTALLED_APPS = filter ( lambda s : s != <STRING> , settings . INSTALLED_APPS ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'devserver'"]}, "err_obj": {"msg": "unexpected indent"}}], ["0b4d412d86bb119d3b925de86e5c9efe", {"code_string": "def retranslateUi(self, dlgAlarmistGreeter):\n    dlgAlarmistGreeter.setWindowTitle(_translate(\"dlgAlarmistGreeter\", \"Greeter\", None))\n    self.btnMoreoptions.setText(_translate(\"dlgAlarmistGreeter\", \"^\", None))\n    self.btnContinue.setToolTip(_translate(\"dlgAlarmistGreeter\", \"Click here to boot\", None))\n    self.btnContinue.setText(_translate(\"dlgAlarmistGreeter\", \"Continue\", None))\n    self.radSpoofYes.setText(_translate(\"dlgAlarmistGreeter\", \"Yes\", None))\n    self.radSpoofNo.setText(_translate(\"dlgAlarmistGreeter\", \"No\", None))\n    self.label_3.setToolTip(_translate(\"dlgAlarmistGreeter\", \"Spoofing MAC addresses hides the serial number of your network cards\\n\"\n", "code_toks_joined": "def retranslateUi ( self , dlgAlarmistGreeter ) : <NEWLINE> <INDENT> dlgAlarmistGreeter . setWindowTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . btnMoreoptions . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . btnContinue . setToolTip ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . btnContinue . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . radSpoofYes . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . radSpoofNo . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_3 . setToolTip ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"dlgAlarmistGreeter\"", "\"Greeter\"", "\"dlgAlarmistGreeter\"", "\"^\"", "\"dlgAlarmistGreeter\"", "\"Click here to boot\"", "\"dlgAlarmistGreeter\"", "\"Continue\"", "\"dlgAlarmistGreeter\"", "\"Yes\"", "\"dlgAlarmistGreeter\"", "\"No\"", "\"dlgAlarmistGreeter\"", "\"Spoofing MAC addresses hides the serial number of your network cards\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["b9d15d831540b35af3aa860fc6591a88", {"code_string": "def render(self, cur_time):\n    if cur_time >(self.last_update\n        + datetime.timedelta(minutes = self.REFRESH_TIME_MINUTES)):\n        try:\n        self.forecast = forecastio.load_forecast(self.api_key,\n            self.lat,\n            self.lon)\n            except:\n        print(\"Error retrieving forecast, check Forecast.io key\")\n        self.last_update = cur_time\n    self.renderForecast()\n", "code_toks_joined": "def render ( self , cur_time ) : <NEWLINE> <INDENT> if cur_time > ( self . last_update <NEWLINE> <INDENT> + datetime . timedelta ( minutes = self . REFRESH_TIME_MINUTES ) ) : <NEWLINE> try : <NEWLINE> self . forecast = forecastio . load_forecast ( self . api_key , <NEWLINE> <INDENT> self . lat , <NEWLINE> self . lon ) <NEWLINE> except : <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> self . last_update = cur_time <NEWLINE> <DEDENT> self . renderForecast ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Error retrieving forecast, check Forecast.io key\""]}, "err_obj": {"msg": "expected an indented block"}}], ["2be300243c0c8470d3567a01dd704ef8", {"code_string": "def simulateTreeConstruction(self, t):\n    \"\"\"^(A B C): emit create A, create B, add child, ...\"\"\"\n        self.dbg.createNode(t)\n        for i in range(self.adaptor.getChildCount(t)):\n            child = self.adaptor.getChild(t, i)\n            self.simulateTreeConstruction(child)\n            self.dbg.addChild(t, child)\n", "code_toks_joined": "def simulateTreeConstruction ( self , t ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> self . dbg . createNode ( t ) <NEWLINE> for i in range ( self . adaptor . getChildCount ( t ) ) : <NEWLINE> <INDENT> child = self . adaptor . getChild ( t , i ) <NEWLINE> self . simulateTreeConstruction ( child ) <NEWLINE> self . dbg . addChild ( t , child ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"^(A B C): emit create A, create B, add child, ...\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["702be90d661fe2711231d8096d7618e3", {"code_string": "def retranslateUi(self, Form):\n    Form.setWindowTitle(QApplication.translate(\"Form\", \"Form\", None, - 1))\n    self.ControlObjectGroupBox.setTitle(QApplication.translate(\"Form\", \"Control Object\", None, - 1))\n    self.LoadSelectionAsCntrlObjPushBtn.setText(QApplication.translate(\"Form\", \"LoadSelection as Control Object\", None, - 1))\n    self.VisibilitySwitchGroupBox.setTitle(QApplication.translate(\"Form\", \"Visibility Switch\", None, - 1))\n    self.label.setText(QApplication.translate(\"Form\", \"Visibility Switch Name\", None, - 1))\n    self.CreateVisibilitySwitchBtn.setText(QApplication.translate(\"Form\", \"Create Visibility Switch\", None, - 1))\n    self.VisibilityGroup.setTitle(QApplication.translate(\"Form\", \"Visibility Switchs\", None, - 1))\n    self.RemoveEnumBtn.setText(QApplication.translate(\"Form\", \"Remove Visibility \\n\"\n", "code_toks_joined": "def retranslateUi ( self , Form ) : <NEWLINE> <INDENT> Form . setWindowTitle ( QApplication . translate ( <STRING> , <STRING> , None , - 1 ) ) <NEWLINE> self . ControlObjectGroupBox . setTitle ( QApplication . translate ( <STRING> , <STRING> , None , - 1 ) ) <NEWLINE> self . LoadSelectionAsCntrlObjPushBtn . setText ( QApplication . translate ( <STRING> , <STRING> , None , - 1 ) ) <NEWLINE> self . VisibilitySwitchGroupBox . setTitle ( QApplication . translate ( <STRING> , <STRING> , None , - 1 ) ) <NEWLINE> self . label . setText ( QApplication . translate ( <STRING> , <STRING> , None , - 1 ) ) <NEWLINE> self . CreateVisibilitySwitchBtn . setText ( QApplication . translate ( <STRING> , <STRING> , None , - 1 ) ) <NEWLINE> self . VisibilityGroup . setTitle ( QApplication . translate ( <STRING> , <STRING> , None , - 1 ) ) <NEWLINE> self . RemoveEnumBtn . setText ( QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Form\"", "\"Form\"", "\"Form\"", "\"Control Object\"", "\"Form\"", "\"LoadSelection as Control Object\"", "\"Form\"", "\"Visibility Switch\"", "\"Form\"", "\"Visibility Switch Name\"", "\"Form\"", "\"Create Visibility Switch\"", "\"Form\"", "\"Visibility Switchs\"", "\"Form\"", "\"Remove Visibility \\n\""]}, "window_span": [160, 170], "err_obj": {"msg": "unbalanced (){}[]"}}], ["2de56b476a608f098b52d1afdd9edfb9", {"code_string": "def is_arbiter_required(tags = {}, debug = False):\n    \"\"\"is_arbiter_required\"\"\"\n    if debug:\n        print(\"in is_arbiter_required()\")\n    slave_tags = tags[\"SLAVES\"]\n    for slave in slave_tags:\n        if debug:\n            print \"found slave \" + str(slave)\n        if(\"BUS\" in slave_tags[slave]):\n            if(len(slave_tags[slave][\"BUS\"]) > 0):\n                return True\n    return False\n", "code_toks_joined": "def is_arbiter_required ( tags = { } , debug = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if debug : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> slave_tags = tags [ <STRING> ] <NEWLINE> for slave in slave_tags : <NEWLINE> <INDENT> if debug : <NEWLINE> <INDENT> print <STRING> + str ( slave ) <NEWLINE> <DEDENT> if ( <STRING> in slave_tags [ slave ] ) : <NEWLINE> <INDENT> if ( len ( slave_tags [ slave ] [ <STRING> ] ) > 0 ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"is_arbiter_required\"\"\"", "\"in is_arbiter_required()\"", "\"SLAVES\"", "\"found slave \"", "\"BUS\"", "\"BUS\""]}, "err_obj": {"msg": "invalid syntax"}}], ["7106b48230cf34d5e37ecaa43b331433", {"code_string": "def _get_new_ticket_values(self, req):\n    \"\"\"Pull all of the new values out of the post data.\"\"\"\n    values = {}\n    for field in TicketSystem(self.env).get_ticket_fields():\n        name = field['name']\n        if name not in('id', 'resolution', 'status', 'owner', 'time',\n            'changetime', 'summary', 'reporter',\n            'description') and field['type'] != 'textarea':\n            value = req.args.get('batchmod_value_' + name)\n            if value is not None:\n            values[name] = self._parse_field_value(req, field, value)\n    return values\n", "code_toks_joined": "def _get_new_ticket_values ( self , req ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> values = { } <NEWLINE> for field in TicketSystem ( self . env ) . get_ticket_fields ( ) : <NEWLINE> <INDENT> name = field [ <STRING> ] <NEWLINE> if name not in ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> ) and field [ <STRING> ] != <STRING> : <NEWLINE> value = req . args . get ( <STRING> + name ) <NEWLINE> if value is not None : <NEWLINE> values [ name ] = self . _parse_field_value ( req , field , value ) <NEWLINE> <DEDENT> <DEDENT> return values <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Pull all of the new values out of the post data.\"\"\"", "'name'", "'id'", "'resolution'", "'status'", "'owner'", "'time'", "'changetime'", "'summary'", "'reporter'", "'description'", "'type'", "'textarea'", "'batchmod_value_'"]}, "err_obj": {"msg": "expected an indented block"}}], ["65a7c566ce7337a13e9f7f250ac8b982", {"code_string": "def stop(self):\n    def cb():\n        self.parent.back()\n        if self.view:\n        self.view.hide(cb)\n", "code_toks_joined": "def stop ( self ) : <NEWLINE> <INDENT> def cb ( ) : <NEWLINE> <INDENT> self . parent . back ( ) <NEWLINE> if self . view : <NEWLINE> self . view . hide ( cb ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["9173d5caca245035b33f59caf89bcedf", {"code_string": "def _print_tagged_ner(tagged_sents):\n    \"\"\"Prints one token per line as token\\ttag\"\"\"\n    for sent in tagged_sents:\n        for tok, tag in sent:\n            print(tok[0] + '\\t' + tag\n        print()\n", "code_toks_joined": "def _print_tagged_ner ( tagged_sents ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for sent in tagged_sents : <NEWLINE> <INDENT> for tok , tag in sent : <NEWLINE> <INDENT> print ( tok [ 0 ] + <STRING> + tag <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Prints one token per line as token\\ttag\"\"\"", "'\\t'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["459fadecaa4cf6570e875f54a164d9d4", {"code_string": "def __get__(self, instance, instance_type = None):\n    if instance is None:\n        raise AttributeError, \"%s must be accessed via instance\" % self.related.opts.object_name\n    try:\n        return getattr(instance, self.cache_name)\n    except AttributeError:\n        params = {'%s__pk' % self.related.field.name: instance._get_pk_val()}\n        rel_obj = self.related.model._default_manager.get(** params)\n        setattr(instance, self.cache_name, rel_obj)\n        return rel_obj\n", "code_toks_joined": "def __get__ ( self , instance , instance_type = None ) : <NEWLINE> <INDENT> if instance is None : <NEWLINE> <INDENT> raise AttributeError , <STRING> % self . related . opts . object_name <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> return getattr ( instance , self . cache_name ) <NEWLINE> <DEDENT> except AttributeError : <NEWLINE> <INDENT> params = { <STRING> % self . related . field . name : instance . _get_pk_val ( ) } <NEWLINE> rel_obj = self . related . model . _default_manager . get ( ** params ) <NEWLINE> setattr ( instance , self . cache_name , rel_obj ) <NEWLINE> return rel_obj <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"%s must be accessed via instance\"", "'%s__pk'"]}, "err_obj": {"msg": "invalid syntax"}}], ["ed8c719755fb87c8f8a17012ae4d42c6", {"code_string": "def control_get_light_cb(self, control, err, vals):\n    print(\"Control %s err = %s, light value = %s\"\n        %(control.get_name(), str(err), vals))\n        return\n", "code_toks_joined": "def control_get_light_cb ( self , control , err , vals ) : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <INDENT> % ( control . get_name ( ) , str ( err ) , vals ) ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Control %s err = %s, light value = %s\""]}, "err_obj": {"msg": "unexpected indent"}}], ["51e3814fcdad3b09e0ff7f1401e318c5", {"code_string": "def inject_default_directories(request):\n    parent_dir = os.path.dirname(__file__)\n    orca.add_injectable(\"configs_dir\", os.path.join(parent_dir, 'configs'))\n    orca.add_injectable(\"data_dir\", os.path.join(parent_dir, 'data')\n    orca.add_injectable(\"output_dir\", os.path.join(parent_dir, 'output'))\n    request.addfinalizer(orca.clear_cache)\n", "code_toks_joined": "def inject_default_directories ( request ) : <NEWLINE> <INDENT> parent_dir = os . path . dirname ( __file__ ) <NEWLINE> orca . add_injectable ( <STRING> , os . path . join ( parent_dir , <STRING> ) ) <NEWLINE> orca . add_injectable ( <STRING> , os . path . join ( parent_dir , <STRING> ) <NEWLINE> orca . add_injectable ( <STRING> , os . path . join ( parent_dir , <STRING> ) ) <NEWLINE> request . addfinalizer ( orca . clear_cache ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"configs_dir\"", "'configs'", "\"data_dir\"", "'data'", "\"output_dir\"", "'output'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["6c3b06eb62e0cf8a30a5dc930652fdf5", {"code_string": "class MyProtocol(protocol.DatagramProtocol):\n    def __init__(self, expecting):\n        self.expecting = list(expecting)\n    def datagramReceived(self, data, (host, port)):\n        assert self.expecting, 'Got a packet when not expecting anymore.'\n        expectData, expectHost, expectPort = self.expecting.pop(0)\n        assert expectData == data, \"Expected data %r, got %r\" %(expectData, data)\n        assert expectHost == host, \"Expected host %r, got %r\" %(expectHost, host)\n        assert expectPort == port, \"Expected port %d=0x%04x, got %d=0x%04x\" %(expectPort, expectPort, port, port)\n", "code_toks_joined": "class MyProtocol ( protocol . DatagramProtocol ) : <NEWLINE> <INDENT> def __init__ ( self , expecting ) : <NEWLINE> <INDENT> self . expecting = list ( expecting ) <NEWLINE> <DEDENT> def datagramReceived ( self , data , ( host , port ) ) : <NEWLINE> <INDENT> assert self . expecting , <STRING> <NEWLINE> expectData , expectHost , expectPort = self . expecting . pop ( 0 ) <NEWLINE> assert expectData == data , <STRING> % ( expectData , data ) <NEWLINE> assert expectHost == host , <STRING> % ( expectHost , host ) <NEWLINE> assert expectPort == port , <STRING> % ( expectPort , expectPort , port , port ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Got a packet when not expecting anymore.'", "\"Expected data %r, got %r\"", "\"Expected host %r, got %r\"", "\"Expected port %d=0x%04x, got %d=0x%04x\""]}, "err_obj": {"msg": "invalid syntax"}}], ["92bf3459687caf50a3c19b983267604f", {"code_string": "def checkBookAvailability(bookTitle):\n    \"\"\"Checks if the book name is available or not.\"\"\"\n    url_title = bookiSlugify(bookTitle[: 100])\n    if url_title == '':\n        return False\n    try:\n        book = models.Book.objects.get(Q(title = bookTitle) | Q(url_title = url_title)))\n    except models.Book.DoesNotExist:\n        return True\n    return False\n", "code_toks_joined": "def checkBookAvailability ( bookTitle ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> url_title = bookiSlugify ( bookTitle [ : 100 ] ) <NEWLINE> if url_title == <STRING> : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> book = models . Book . objects . get ( Q ( title = bookTitle ) | Q ( url_title = url_title ) ) ) <NEWLINE> <DEDENT> except models . Book . DoesNotExist : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Checks if the book name is available or not.\"\"\"", "''"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["a34d88e278c53551aa25742d41df314c", {"code_string": "def latinquote(s):\n    \"\"\"Escapes all characters >=160 to numeric escape.\"\"\"\n    l = []\n    for i in s:\n    if ord(i) >= 160: l.append(\"&#%03d;\" % ord(i))\n    else: l.append(i)\n    return string.join(l, '')\n", "code_toks_joined": "def latinquote ( s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> l = [ ] <NEWLINE> for i in s : <NEWLINE> if ord ( i ) >= 160 : l . append ( <STRING> % ord ( i ) ) <NEWLINE> else : l . append ( i ) <NEWLINE> return string . join ( l , <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Escapes all characters >=160 to numeric escape.\"\"\"", "\"&#%03d;\"", "''"]}, "err_obj": {"msg": "expected an indented block"}}], ["7a83de912bd9238d37e0de23c9be2730", {"code_string": "class CCGenerator(object):\n    def __init__(self, type_generator, cpp_namespace):\n        self._type_generator = type_generator\n        self._cpp_namespace = cpp_namespace\n    def Generate(self, namespace):\n        return _Generator(namespace\n            self._type_generator,\n            self._cpp_namespace).Generate()\n", "code_toks_joined": "class CCGenerator ( object ) : <NEWLINE> <INDENT> def __init__ ( self , type_generator , cpp_namespace ) : <NEWLINE> <INDENT> self . _type_generator = type_generator <NEWLINE> self . _cpp_namespace = cpp_namespace <NEWLINE> <DEDENT> def Generate ( self , namespace ) : <NEWLINE> <INDENT> return _Generator ( namespace <NEWLINE> <INDENT> self . _type_generator , <NEWLINE> self . _cpp_namespace ) . Generate ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["efbc6dd66031ff7f06052e38681e285b", {"code_string": "class QStrictCustomBus(QSparseBus):\n    \"\"\"Similar to QSparseBus. The address starts with 1 and addr is always set\"\"\"\n    def __init__(self, bus_item, addr_spec, busid, bus_type = None, aobject = None,\n        atype = None, first_port = None):\n        super(QStrictCustomBus, self).__init__(bus_item, addr_spec, busid,\n            bus_type, aobject, atype)\n            if first_port:\n            self.first_port = first_port\n    def _update_device_props(self, device, addr):\n        \"\"\" in case this is usb-hub update the child port_prefix \"\"\"\n        self._set_device_props(device, addr)\n", "code_toks_joined": "class QStrictCustomBus ( QSparseBus ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , bus_item , addr_spec , busid , bus_type = None , aobject = None , <NEWLINE> <INDENT> atype = None , first_port = None ) : <NEWLINE> super ( QStrictCustomBus , self ) . __init__ ( bus_item , addr_spec , busid , <NEWLINE> <INDENT> bus_type , aobject , atype ) <NEWLINE> if first_port : <NEWLINE> self . first_port = first_port <NEWLINE> <DEDENT> <DEDENT> def _update_device_props ( self , device , addr ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . _set_device_props ( device , addr ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Similar to QSparseBus. The address starts with 1 and addr is always set\"\"\"", "\"\"\" in case this is usb-hub update the child port_prefix \"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["b54716c201bca8d61eec47e4815f986d", {"code_string": "def rta_uint16(self, rta, value = None):\n    data = RTA_DATA(rta)\n    if value:\n        c_uint16.from_address(data).value = value\n        rta.rta_len = RTA_LENGTH(sizeof(c_uint16))\n        return rta.rta_len\n        else:\n        return c_uint16.from_address(data).value\n", "code_toks_joined": "def rta_uint16 ( self , rta , value = None ) : <NEWLINE> <INDENT> data = RTA_DATA ( rta ) <NEWLINE> if value : <NEWLINE> <INDENT> c_uint16 . from_address ( data ) . value = value <NEWLINE> rta . rta_len = RTA_LENGTH ( sizeof ( c_uint16 ) ) <NEWLINE> return rta . rta_len <NEWLINE> else : <NEWLINE> return c_uint16 . from_address ( data ) . value <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["026e7fe81f542cef179d549ac63e1fb9", {"code_string": "def _init_station_with_retries(self):\n    for cnt in xrange(self.max_tries):\n        try:\n            self._init_station()\n            return\n        except(serial.serialutil.SerialException, WeeWxIOError), e:\n            logerr(\"Failed attempt %d of %d to initialize station: %s\" %\n                (cnt + 1, self.max_tries, e))\n            logdbg(\"Waiting %d seconds before retry\" % self.retry_wait)\n            time.sleep(self.retry_wait)\n    else:\n        raise RetriesExceeded(\"Max retries (%d) exceeded while initializing station\" % self.max_tries)\n", "code_toks_joined": "def _init_station_with_retries ( self ) : <NEWLINE> <INDENT> for cnt in xrange ( self . max_tries ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . _init_station ( ) <NEWLINE> return <NEWLINE> <DEDENT> except ( serial . serialutil . SerialException , WeeWxIOError ) , e : <NEWLINE> <INDENT> logerr ( <STRING> % <NEWLINE> <INDENT> ( cnt + 1 , self . max_tries , e ) ) <NEWLINE> <DEDENT> logdbg ( <STRING> % self . retry_wait ) <NEWLINE> time . sleep ( self . retry_wait ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> raise RetriesExceeded ( <STRING> % self . max_tries ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Failed attempt %d of %d to initialize station: %s\"", "\"Waiting %d seconds before retry\"", "\"Max retries (%d) exceeded while initializing station\""]}, "err_obj": {"msg": "invalid syntax"}}], ["c9e105d4042e05452311d2fcc75e8b64", {"code_string": "def make_illegal_xml_regex():\n    \"\"\"I want to define a regexp to match *illegal* characters.\"\"\"\n    re_xml_illegal = u'([\\u0000-\\u0008\\u000b-\\u000c\\u000e-\\u0019\\ufffe-\\uffff])'\n    re_xml_illegal += u\"|\"\n    re_xml_illegal += u'([%s-%s][^%s-%s])|([^%s-%s][%s-%s])|([%s-%s]$)|(^[%s-%s])' %(unichr(0xd800), unichr(0xdbff), unichr(0xdc00), unichr(0xdfff)\n        unichr(0xd800), unichr(0xdbff), unichr(0xdc00), unichr(0xdfff),\n        unichr(0xd800), unichr(0xdbff), unichr(0xdc00), unichr(0xdfff))\n    return re.compile(re_xml_illegal)\n", "code_toks_joined": "def make_illegal_xml_regex ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> re_xml_illegal = <STRING> <NEWLINE> re_xml_illegal += <STRING> <NEWLINE> re_xml_illegal += <STRING> % ( unichr ( 0xd800 ) , unichr ( 0xdbff ) , unichr ( 0xdc00 ) , unichr ( 0xdfff ) <NEWLINE> <INDENT> unichr ( 0xd800 ) , unichr ( 0xdbff ) , unichr ( 0xdc00 ) , unichr ( 0xdfff ) , <NEWLINE> unichr ( 0xd800 ) , unichr ( 0xdbff ) , unichr ( 0xdc00 ) , unichr ( 0xdfff ) ) <NEWLINE> <DEDENT> return re . compile ( re_xml_illegal ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"I want to define a regexp to match *illegal* characters.\"\"\"", "u'([\\u0000-\\u0008\\u000b-\\u000c\\u000e-\\u0019\\ufffe-\\uffff])'", "u\"|\"", "u'([%s-%s][^%s-%s])|([^%s-%s][%s-%s])|([%s-%s]$)|(^[%s-%s])'"]}, "err_obj": {"msg": "invalid syntax"}}], ["9e5ed343e8f773479af5c0c03b79ac15", {"code_string": "class NbspValue(Value):\n    def __init__(self):\n    self.value = '&nbsp;'\n", "code_toks_joined": "class NbspValue ( Value ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> self . value = <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'&nbsp;'"]}, "err_obj": {"msg": "expected an indented block"}}], ["f47401c669fe02658704225367b447b0", {"code_string": "def convert_image_to_ascii(image, new_width = 100):\n    image = scale_image(image, new_width)\n    image = convert_to_grayscale(image)\n    pixels_to_chars = map_pixels_to_ascii_chars(image)\n    len_pixels_to_chars = len(pixels_to_chars)\n    image_ascii = [pixels_to_chars[index index + new_width] for index in\n        xrange(0, len_pixels_to_chars, new_width)]\n    return \"\\n\".join(image_ascii)\n", "code_toks_joined": "def convert_image_to_ascii ( image , new_width = 100 ) : <NEWLINE> <INDENT> image = scale_image ( image , new_width ) <NEWLINE> image = convert_to_grayscale ( image ) <NEWLINE> pixels_to_chars = map_pixels_to_ascii_chars ( image ) <NEWLINE> len_pixels_to_chars = len ( pixels_to_chars ) <NEWLINE> image_ascii = [ pixels_to_chars [ index index + new_width ] for index in <NEWLINE> <INDENT> xrange ( 0 , len_pixels_to_chars , new_width ) ] <NEWLINE> <DEDENT> return <STRING> . join ( image_ascii ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\\n\""]}, "err_obj": {"msg": "invalid syntax"}}], ["06195ebc115dafddc8b19d82e645f5d1", {"code_string": "class NoRedirectHandler(urllib2.HTTPRedirectHandler):\n    def http_error_302(self, req, fp, code, msg, headers):\n        infourl = urllib.addinfourl(fp, headers, req.get_full_url()\n        infourl.status = code\n        infourl.code = code\n        return infourl\n    http_error_300 = http_error_302\n    http_error_301 = http_error_302\n    http_error_303 = http_error_302\n    http_error_307 = http_error_302\n", "code_toks_joined": "class NoRedirectHandler ( urllib2 . HTTPRedirectHandler ) : <NEWLINE> <INDENT> def http_error_302 ( self , req , fp , code , msg , headers ) : <NEWLINE> <INDENT> infourl = urllib . addinfourl ( fp , headers , req . get_full_url ( ) <NEWLINE> infourl . status = code <NEWLINE> infourl . code = code <NEWLINE> return infourl <NEWLINE> <DEDENT> http_error_300 = http_error_302 <NEWLINE> http_error_301 = http_error_302 <NEWLINE> http_error_303 = http_error_302 <NEWLINE> http_error_307 = http_error_302 <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["fd4f18664b3d32f18e58e6e6788147b7", {"code_string": "def getRequestInfo(self, url):\n    \"\"\"\u83b7\u53d6\u8bf7\u6c42\u7684\u4fe1\u606f\"\"\"\n    try:\n        request = requests.get(self.getServiceURL(url), headers = self._headers, verify = False)\n        if request.ok:\n            return request.json()\n        else:\n            log.logger.error(\"RequestError\" + url + \" \" + request.content)\n            raise RequestError(url + \" \" + request.content)\n    except requests.exceptions.ConnectionError, e:\n        raise CServerConnectionError()\n", "code_toks_joined": "def getRequestInfo ( self , url ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> request = requests . get ( self . getServiceURL ( url ) , headers = self . _headers , verify = False ) <NEWLINE> if request . ok : <NEWLINE> <INDENT> return request . json ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> log . logger . error ( <STRING> + url + <STRING> + request . content ) <NEWLINE> raise RequestError ( url + <STRING> + request . content ) <NEWLINE> <DEDENT> <DEDENT> except requests . exceptions . ConnectionError , e : <NEWLINE> <INDENT> raise CServerConnectionError ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"\u83b7\u53d6\u8bf7\u6c42\u7684\u4fe1\u606f\"\"\"", "\"RequestError\"", "\" \"", "\" \""]}, "err_obj": {"msg": "invalid syntax"}}], ["bbce136610edaf9324d46e9241b9b2ef", {"code_string": "def backup_volume(self, context, backup, backup_service):\n    \"\"\"Create a new backup from an existing volume.\"\"\"\n    volume = self.db.volume_get(context, backup['volume_id'])\n    with RBDVolumeProxy(self, volume['name'],\n        self.configuration.rbd_pool) as rbd_image:\n        rbd_meta = RBDImageMetadata(rbd_image, self.configuration.rbd_pool,\n            self.configuration.rbd_user,\n            self.configuration.rbd_ceph_conf)\n            rbd_fd = RBDImageIOWrapper(rbd_meta)\n            backup_service.backup(backup, rbd_fd)\n    LOG.debug(\"volume backup complete.\")\n", "code_toks_joined": "def backup_volume ( self , context , backup , backup_service ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> volume = self . db . volume_get ( context , backup [ <STRING> ] ) <NEWLINE> with RBDVolumeProxy ( self , volume [ <STRING> ] , <NEWLINE> <INDENT> self . configuration . rbd_pool ) as rbd_image : <NEWLINE> rbd_meta = RBDImageMetadata ( rbd_image , self . configuration . rbd_pool , <NEWLINE> <INDENT> self . configuration . rbd_user , <NEWLINE> self . configuration . rbd_ceph_conf ) <NEWLINE> rbd_fd = RBDImageIOWrapper ( rbd_meta ) <NEWLINE> backup_service . backup ( backup , rbd_fd ) <NEWLINE> <DEDENT> <DEDENT> LOG . debug ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Create a new backup from an existing volume.\"\"\"", "'volume_id'", "'name'", "\"volume backup complete.\""]}, "err_obj": {"msg": "unexpected indent"}}], ["a43bfa93b9233a7b84a2100cecd2e3d3", {"code_string": "def _parse_website_config(self, (response, xml_bytes)):\n    \"\"\"Parse a C{WebsiteConfiguration} XML document.\"\"\"\n    root = XML(xml_bytes)\n    index_suffix = root.findtext(\"IndexDocument/Suffix\")\n    error_key = root.findtext(\"ErrorDocument/Key\")\n    return WebsiteConfiguration(index_suffix, error_key)\n", "code_toks_joined": "def _parse_website_config ( self , ( response , xml_bytes ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> root = XML ( xml_bytes ) <NEWLINE> index_suffix = root . findtext ( <STRING> ) <NEWLINE> error_key = root . findtext ( <STRING> ) <NEWLINE> return WebsiteConfiguration ( index_suffix , error_key ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Parse a C{WebsiteConfiguration} XML document.\"\"\"", "\"IndexDocument/Suffix\"", "\"ErrorDocument/Key\""]}, "err_obj": {"msg": "invalid syntax"}}], ["de78774eb79c566a5a62932c9131d631", {"code_string": "def save_screenshot_img(self, input_path, out_path, box)\n    from PIL import Image\n    img = Image.open(input_path)\n    area = img.crop(box)\n    area.save(out_path, 'png')\n    pass\n", "code_toks_joined": "def save_screenshot_img ( self , input_path , out_path , box ) <NEWLINE> <INDENT> from PIL import Image <NEWLINE> img = Image . open ( input_path ) <NEWLINE> area = img . crop ( box ) <NEWLINE> area . save ( out_path , <STRING> ) <NEWLINE> pass <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'png'"]}, "err_obj": {"msg": "invalid syntax"}}], ["fc9eddd4b2b4ef5e8230d748e87e81bb", {"code_string": "def getFilename(url):\n    truncatedUrl = url.replace(siteBase, \"\")\n    if truncatedUrl:\n    return dirlocation + truncatedUrl\n    else:\n    return dirlocation + \"index.html\"\n", "code_toks_joined": "def getFilename ( url ) : <NEWLINE> <INDENT> truncatedUrl = url . replace ( siteBase , <STRING> ) <NEWLINE> if truncatedUrl : <NEWLINE> return dirlocation + truncatedUrl <NEWLINE> else : <NEWLINE> return dirlocation + <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"", "\"index.html\""]}, "err_obj": {"msg": "expected an indented block"}}], ["d1e68327a4fef34bfc532310d5e6e998", {"code_string": "class Condition public:\n    Condition(){\n    virtual ~ Condition(){\n    virtual bool check(Flow * f) = 0\n    virtual std.string to_string() = 0\n", "code_toks_joined": "class Condition public : <NEWLINE> <INDENT> Condition ( ) { <NEWLINE> virtual ~ Condition ( ) { <NEWLINE> virtual bool check ( Flow * f ) = 0 <NEWLINE> virtual std . string to_string ( ) = 0 <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["4a32a2d4c07106ceed61693995a15b99", {"code_string": "def stochpick(elems, prop_func = (lambda x: x), sum = 0):\n    if sum == 0: sum = general_sum(elems, prop_func)\n    randnum = random.uniform(0, sum)\n    running_sum = 0\n    for elem in elems:\n    running_sum += prop_func(elem)\n    if running_sum >= randnum: return elem\n", "code_toks_joined": "def stochpick ( elems , prop_func = ( lambda x : x ) , sum = 0 ) : <NEWLINE> <INDENT> if sum == 0 : sum = general_sum ( elems , prop_func ) <NEWLINE> randnum = random . uniform ( 0 , sum ) <NEWLINE> running_sum = 0 <NEWLINE> for elem in elems : <NEWLINE> running_sum += prop_func ( elem ) <NEWLINE> if running_sum >= randnum : return elem <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["c40b216c83fd73517f918624e714e125", {"code_string": "def dump(self):\n    for i in range(self.NO_ROWS):\n        print('Row %s == [' % i,\n        if self.arr[i] == None:\n            pass\n        else:\n            for j in range(self.NO_COLS):\n                print(self.arr[i][j], )\n        print(\"]\")\n", "code_toks_joined": "def dump ( self ) : <NEWLINE> <INDENT> for i in range ( self . NO_ROWS ) : <NEWLINE> <INDENT> print ( <STRING> % i , <NEWLINE> if self . arr [ i ] == None : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( self . NO_COLS ) : <NEWLINE> <INDENT> print ( self . arr [ i ] [ j ] , ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Row %s == ['", "\"]\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["18211ac2b7fb4c41bd287835b0c64a1b", {"code_string": "def openAddonSettings(addonId, id1 = None, id2 = None):\n    xbmc.executebuiltin('Addon.OpenSettings(%s)' % addonId)\n    if id1 != None:\n        xbmc.executebuiltin('SetFocus(%i)' %(id1 + 200))\n    if id2 != None:\n        xbmc.executebuiltin('SetFocus(%i)' %(id2 + 100)))\n", "code_toks_joined": "def openAddonSettings ( addonId , id1 = None , id2 = None ) : <NEWLINE> <INDENT> xbmc . executebuiltin ( <STRING> % addonId ) <NEWLINE> if id1 != None : <NEWLINE> <INDENT> xbmc . executebuiltin ( <STRING> % ( id1 + 200 ) ) <NEWLINE> <DEDENT> if id2 != None : <NEWLINE> <INDENT> xbmc . executebuiltin ( <STRING> % ( id2 + 100 ) ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Addon.OpenSettings(%s)'", "'SetFocus(%i)'", "'SetFocus(%i)'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["1a4ca8f63e6d3edde2dddea572cf1a95", {"code_string": "class JyDTDHandlerWrapper(javasax.DTDHandler):\n    def __init__(self, dtdHandler):\n    self._handler = dtdHandler\n    def notationDecl(self, name, publicId, systemId):\n    self._handler.notationDecl(name, publicId, systemId)\n    def unparsedEntityDecl(self, name, publicId, systemId, notationName):\n    self._handler.unparsedEntityDecl(name, publicId, systemId, notationName)\n", "code_toks_joined": "class JyDTDHandlerWrapper ( javasax . DTDHandler ) : <NEWLINE> <INDENT> def __init__ ( self , dtdHandler ) : <NEWLINE> self . _handler = dtdHandler <NEWLINE> def notationDecl ( self , name , publicId , systemId ) : <NEWLINE> self . _handler . notationDecl ( name , publicId , systemId ) <NEWLINE> def unparsedEntityDecl ( self , name , publicId , systemId , notationName ) : <NEWLINE> self . _handler . unparsedEntityDecl ( name , publicId , systemId , notationName ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["d54d6508ffd9bb922fbc074681f317c0", {"code_string": "from bachutil import *\nimport initbach\nfrom Bach import *\nfrom PyQt4.QtCore import *\nimport os\nimport sha\nassets = BachAsset.select(\"exclude=false AND hash IS NULL\")\nprint(\"found %s assets\" % assets.size())\nfor asset in assets:\n    path = asset.path()\n    asset.setHash(assetHash(path))\n    asset.commit()\n    try: print \"%s %s\" %(asset.hash(), path)\n    except UnicodeDecodeError: pass\n", "code_toks_joined": "from bachutil import * <NEWLINE> import initbach <NEWLINE> from Bach import * <NEWLINE> from PyQt4 . QtCore import * <NEWLINE> import os <NEWLINE> import sha <NEWLINE> assets = BachAsset . select ( <STRING> ) <NEWLINE> print ( <STRING> % assets . size ( ) ) <NEWLINE> for asset in assets : <NEWLINE> <INDENT> path = asset . path ( ) <NEWLINE> asset . setHash ( assetHash ( path ) ) <NEWLINE> asset . commit ( ) <NEWLINE> try : print <STRING> % ( asset . hash ( ) , path ) <NEWLINE> except UnicodeDecodeError : pass <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"exclude=false AND hash IS NULL\"", "\"found %s assets\"", "\"%s %s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["d20945869e003bc8c582105dd8d2390c", {"code_string": "def get(self, request, ** kwargs):\n    success = None\n    try:\n        success = kwargs['success']\n    except KeyError:\n        pass\n    return render(request, self.template_name\n        {\n            'developer': True,\n            'plugin_add': True,\n            'plugins': Plugin.all(owner = request.user),\n            'request': request,\n            'breadcrumb': True,\n            'success': success\n        })\n", "code_toks_joined": "def get ( self , request , ** kwargs ) : <NEWLINE> <INDENT> success = None <NEWLINE> try : <NEWLINE> <INDENT> success = kwargs [ <STRING> ] <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> return render ( request , self . template_name <NEWLINE> <INDENT> { <NEWLINE> <INDENT> <STRING> : True , <NEWLINE> <STRING> : True , <NEWLINE> <STRING> : Plugin . all ( owner = request . user ) , <NEWLINE> <STRING> : request , <NEWLINE> <STRING> : True , <NEWLINE> <STRING> : success <NEWLINE> <DEDENT> } ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'success'", "'developer'", "'plugin_add'", "'plugins'", "'request'", "'breadcrumb'", "'success'"]}, "err_obj": {"msg": "invalid syntax"}}], ["9bd6a1f53e1811845f6df47c71ce66bd", {"code_string": "def showarray(a, fmt = 'jpeg'):\n    a = np.uint8(np.clip(a, 0, 255))\n    f = StringIO()\n    PIL.Image.fromarray(a).save(f, fmt)\n    display(Image(data = f.getvalue())\n", "code_toks_joined": "def showarray ( a , fmt = <STRING> ) : <NEWLINE> <INDENT> a = np . uint8 ( np . clip ( a , 0 , 255 ) ) <NEWLINE> f = StringIO ( ) <NEWLINE> PIL . Image . fromarray ( a ) . save ( f , fmt ) <NEWLINE> display ( Image ( data = f . getvalue ( ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'jpeg'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["a86569484e4ac8c9d64a100a3f062ec3", {"code_string": "def test_send_request_message_response_None(self):\n    with patch(\"org.o3project.odenos.remoteobject.transport.\" +\n        \"remote_message_transport.RemoteMessageTransport.\" +\n        \"SynchronousQueue.get\") as q_get:\n        self.value01 = ObjectProperty(\"object_type\", \"object_id\")\n        q_get.return_value = None\n        self.target.dispatcher.get_source_dispatcher_id = Mock(\n        return_value = \"dispatcher_id\")\n        try:\n        self.result = self.target.send_request_message(self.value01)\n        except:\n        pass\n", "code_toks_joined": "def test_send_request_message_response_None ( self ) : <NEWLINE> <INDENT> with patch ( <STRING> + <NEWLINE> <INDENT> <STRING> + <NEWLINE> <STRING> ) as q_get : <NEWLINE> self . value01 = ObjectProperty ( <STRING> , <STRING> ) <NEWLINE> q_get . return_value = None <NEWLINE> self . target . dispatcher . get_source_dispatcher_id = Mock ( <NEWLINE> return_value = <STRING> ) <NEWLINE> try : <NEWLINE> self . result = self . target . send_request_message ( self . value01 ) <NEWLINE> except : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"org.o3project.odenos.remoteobject.transport.\"", "\"remote_message_transport.RemoteMessageTransport.\"", "\"SynchronousQueue.get\"", "\"object_type\"", "\"object_id\"", "\"dispatcher_id\""]}, "err_obj": {"msg": "expected an indented block"}}], ["97bdd3dfc0e449e9da03f7f003241d09", {"code_string": "def supportedDatabases():\n    result = []\n    for name, module in _supportedDatabases.items():\n        try:\n            exec 'import %s' % module\n        except ImportError:\n            pass\n        else:\n            result.append(name)\n    return result\n", "code_toks_joined": "def supportedDatabases ( ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> for name , module in _supportedDatabases . items ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> exec <STRING> % module <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . append ( name ) <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'import %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["002150c8ad5ace142db4db614fddf5c3", {"code_string": "class Forex(Contract):\n    def __init__(self, pair = '', exchange = 'IDEALPRO',\n        symbol = '', currency = '', ** kwargs):\n        if pair:\n        assert len(pair) == 6\n        symbol = symbol or pair[: 3]\n        currency = currency or pair[3: ]\n        Contract.__init__(self, secType = 'CASH', symbol = symbol,\n            exchange = exchange, currency = currency, ** kwargs)\n", "code_toks_joined": "class Forex ( Contract ) : <NEWLINE> <INDENT> def __init__ ( self , pair = <STRING> , exchange = <STRING> , <NEWLINE> <INDENT> symbol = <STRING> , currency = <STRING> , ** kwargs ) : <NEWLINE> if pair : <NEWLINE> assert len ( pair ) == 6 <NEWLINE> symbol = symbol or pair [ : 3 ] <NEWLINE> currency = currency or pair [ 3 : ] <NEWLINE> Contract . __init__ ( self , secType = <STRING> , symbol = symbol , <NEWLINE> <INDENT> exchange = exchange , currency = currency , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "'IDEALPRO'", "''", "''", "'CASH'"]}, "err_obj": {"msg": "expected an indented block"}}], ["e59c32fbf3c1bb2fc938c13efcf7120b", {"code_string": "def retranslateUi(self, NameFormatDialog):\n    NameFormatDialog.setWindowTitle(QtGui.QApplication.translate(\"NameFormatDialog\", \"Name Format\", None, QtGui.QApplication.UnicodeUTF8))\n    self.groupBox.setTitle(QtGui.QApplication.translate(\"NameFormatDialog\", \"Description\", None, QtGui.QApplication.UnicodeUTF8))\n    self.textBrowser.setHtml(QtGui.QApplication.translate(\"NameFormatDialog\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , NameFormatDialog ) : <NEWLINE> <INDENT> NameFormatDialog . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . groupBox . setTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . textBrowser . setHtml ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"NameFormatDialog\"", "\"Name Format\"", "\"NameFormatDialog\"", "\"Description\"", "\"NameFormatDialog\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["b46da617079691c804212ae2e2375ee1", {"code_string": "def overlaps(self, other):\n    \"\"\"Returns true if the network overlaps with OTHER.\"\"\"\n    if self.network_intrep == None:\n        return 0\n    if isinstance(other, ipaddr):\n        if other.intrep == None:\n        return 0\n        return(self.mask.intrep & other.intrep) == self.network_intrep\n    else:\n        if other.network_intrep == None:\n        return 0\n        mask = self.mask.intrep & other.mask.intrep\n        return(mask & self.ip.intrep) ==(mask & other.ip.intrep)\n", "code_toks_joined": "def overlaps ( self , other ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . network_intrep == None : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if isinstance ( other , ipaddr ) : <NEWLINE> <INDENT> if other . intrep == None : <NEWLINE> return 0 <NEWLINE> return ( self . mask . intrep & other . intrep ) == self . network_intrep <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if other . network_intrep == None : <NEWLINE> return 0 <NEWLINE> mask = self . mask . intrep & other . mask . intrep <NEWLINE> return ( mask & self . ip . intrep ) == ( mask & other . ip . intrep ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns true if the network overlaps with OTHER.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["dee59eb63a1a9312cda3d8a91aee5120", {"code_string": "class SingleCertHttpsProxyServer(HttpProxyServer):\n    \"\"\"SSL server.\"\"\"\n    def __init__(self, http_archive_fetch, custom_handlers, rules,\n        https_root_ca_cert_path, ** kwargs):\n        HttpProxyServer.__init__(self, http_archive_fetch, custom_handlers, rules,\n            is_ssl = True, protocol = 'HTTPS', ** kwargs)\n            self.socket = ssl.wrap_socket(\n            self.socket, certfile = https_root_ca_cert_path, server_side = True,\n            do_handshake_on_connect = False)\n    def handle_error(self, request, client_address):\n        _HandleSSLCertificateError()\n", "code_toks_joined": "class SingleCertHttpsProxyServer ( HttpProxyServer ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , http_archive_fetch , custom_handlers , rules , <NEWLINE> <INDENT> https_root_ca_cert_path , ** kwargs ) : <NEWLINE> HttpProxyServer . __init__ ( self , http_archive_fetch , custom_handlers , rules , <NEWLINE> <INDENT> is_ssl = True , protocol = <STRING> , ** kwargs ) <NEWLINE> self . socket = ssl . wrap_socket ( <NEWLINE> self . socket , certfile = https_root_ca_cert_path , server_side = True , <NEWLINE> do_handshake_on_connect = False ) <NEWLINE> <DEDENT> <DEDENT> def handle_error ( self , request , client_address ) : <NEWLINE> <INDENT> _HandleSSLCertificateError ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"SSL server.\"\"\"", "'HTTPS'"]}, "err_obj": {"msg": "unexpected indent"}}], ["f1831865a06cde8ae938823a90cb59f4", {"code_string": "def get(self, iuid):\n    reference = self.get_entry(iuid)\n    if reference is None:\n        raise tornado.web.HTTPError(404)\n    self.render('reference.html',\n        reference = reference,\n        source = self.get_source(reference)\n        target = self.get_target(reference),\n        notes = self.get_notes(reference),\n        xrefs = self.get_xrefs(reference))\n", "code_toks_joined": "def get ( self , iuid ) : <NEWLINE> <INDENT> reference = self . get_entry ( iuid ) <NEWLINE> if reference is None : <NEWLINE> <INDENT> raise tornado . web . HTTPError ( 404 ) <NEWLINE> <DEDENT> self . render ( <STRING> , <NEWLINE> <INDENT> reference = reference , <NEWLINE> source = self . get_source ( reference ) <NEWLINE> target = self . get_target ( reference ) , <NEWLINE> notes = self . get_notes ( reference ) , <NEWLINE> xrefs = self . get_xrefs ( reference ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'reference.html'"]}, "err_obj": {"msg": "invalid syntax"}}], ["357667a099cd5e990ca950ee9330fd14", {"code_string": "def explained_variance(self):\n    \"\"\"Se calcula la varianza explicada en la predicci\u00f3n sobre los valores reales, tal que:\"\"\"\n    var_error = np.var(self.error)\n    var_actual = np.var(map(lambda(p, a): a, self.predicted_actual))\n    return 1 - float(var_error / var_actual)\n", "code_toks_joined": "def explained_variance ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> var_error = np . var ( self . error ) <NEWLINE> var_actual = np . var ( map ( lambda ( p , a ) : a , self . predicted_actual ) ) <NEWLINE> return 1 - float ( var_error / var_actual ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Se calcula la varianza explicada en la predicci\u00f3n sobre los valores reales, tal que:\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["5fb3cc2c48e7fe730f78c65e262c8766", {"code_string": "def hexToSalt(s):\n    def chunkify(s):\n        rest = s\n        while rest:\n            chunk, rest = rest[: 2], rest[2: ]\n            yield chunk\n    return ''.join(chr(int(i, 16) for i in chunkify(s))\n", "code_toks_joined": "def hexToSalt ( s ) : <NEWLINE> <INDENT> def chunkify ( s ) : <NEWLINE> <INDENT> rest = s <NEWLINE> while rest : <NEWLINE> <INDENT> chunk , rest = rest [ : 2 ] , rest [ 2 : ] <NEWLINE> yield chunk <NEWLINE> <DEDENT> <DEDENT> return <STRING> . join ( chr ( int ( i , 16 ) for i in chunkify ( s ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["af2b11a3b13846a7ce547453bf8e7d34", {"code_string": "def addShapes(self, shapes, color = (0.9, 0.9, 0.9, 1.0)):\n    \"add shapes to this renderer, optionally with a color.Warning, these will get lost if using join()\"\n    if DEBUG: print \"adding \", len(shapes), \" shapes\"\n    for s in shapes:\n        if s.Faces:\n            self.shapes.append([s, color])\n            for f in s.Faces:\n                self.faces.append([f, color])\n    self.resetFlags()\n", "code_toks_joined": "def addShapes ( self , shapes , color = ( 0.9 , 0.9 , 0.9 , 1.0 ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if DEBUG : print <STRING> , len ( shapes ) , <STRING> <NEWLINE> for s in shapes : <NEWLINE> <INDENT> if s . Faces : <NEWLINE> <INDENT> self . shapes . append ( [ s , color ] ) <NEWLINE> for f in s . Faces : <NEWLINE> <INDENT> self . faces . append ( [ f , color ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> self . resetFlags ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"add shapes to this renderer, optionally with a color.Warning, these will get lost if using join()\"", "\"adding \"", "\" shapes\""]}, "err_obj": {"msg": "invalid syntax"}}], ["340d4b28033f8655b49147514f060fc2", {"code_string": "def requestDelete(self, task = None):\n    DistributedPetAI.notify.info('PetAI.requestDelete: %s, owner=%s' %(self.doId, self.ownerId))\n    if self.hasRequestedDelete():\n        DistributedPetAI.notify.info('PetAI.requestDelete: %s, owner=%s returning immediately' %(self.doId, self.ownerId)\n        return\n    self.setHasRequestedDelete(True)\n    self.b_setLastSeenTimestamp(self.getCurEpochTimestamp())\n    DistributedSmoothNodeAI.DistributedSmoothNodeAI.requestDelete(self)\n", "code_toks_joined": "def requestDelete ( self , task = None ) : <NEWLINE> <INDENT> DistributedPetAI . notify . info ( <STRING> % ( self . doId , self . ownerId ) ) <NEWLINE> if self . hasRequestedDelete ( ) : <NEWLINE> <INDENT> DistributedPetAI . notify . info ( <STRING> % ( self . doId , self . ownerId ) <NEWLINE> return <NEWLINE> <DEDENT> self . setHasRequestedDelete ( True ) <NEWLINE> self . b_setLastSeenTimestamp ( self . getCurEpochTimestamp ( ) ) <NEWLINE> DistributedSmoothNodeAI . DistributedSmoothNodeAI . requestDelete ( self ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'PetAI.requestDelete: %s, owner=%s'", "'PetAI.requestDelete: %s, owner=%s returning immediately'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c6f7b4f0df826204db424e3c2a2667e5", {"code_string": "def jassign(old, new, base_env = {}):\n    res = new\n    for vs in jeevesState.pathenv.conditions:\n        (var, val) = (vs.var, vs.val)\n        if var.name not in base_env:\n        if val:\n    res = Facet(var, res, old)\n        else:\n            res = Facet(var, old, res)\n    if isinstance(res, FExpr):\n        return res.partialEval({}, True)\n    else:\n    return res\n", "code_toks_joined": "def jassign ( old , new , base_env = { } ) : <NEWLINE> <INDENT> res = new <NEWLINE> for vs in jeevesState . pathenv . conditions : <NEWLINE> <INDENT> ( var , val ) = ( vs . var , vs . val ) <NEWLINE> if var . name not in base_env : <NEWLINE> if val : <NEWLINE> <DEDENT> res = Facet ( var , res , old ) <NEWLINE> <INDENT> else : <NEWLINE> <INDENT> res = Facet ( var , old , res ) <NEWLINE> <DEDENT> <DEDENT> if isinstance ( res , FExpr ) : <NEWLINE> <INDENT> return res . partialEval ( { } , True ) <NEWLINE> <DEDENT> else : <NEWLINE> return res <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["a596a67241cb0493aba962f8440b9161", {"code_string": "def __init__(self, d, dl):\n    self.doc, self.doclist = d, dl\n        def test_data(self): pass\n", "code_toks_joined": "def __init__ ( self , d , dl ) : <NEWLINE> <INDENT> self . doc , self . doclist = d , dl <NEWLINE> <INDENT> def test_data ( self ) : pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["c7f781f5f4bf8c1c6ae177ef41d185fd", {"code_string": "def remove_debug_info(self):\n    \"\"\"Function removes debug information from report\"\"\"\n    re_expr = r'^preupg.log.DEBUG.*'\n    for rule in self.get_all_result_rules():\n        for check_import in self.filter_grandchildren(rule,\n            \"check\",\n            \"check-import\"):\n            if check_import.text is not None:\n            new_check = []\n            for check in check_import.text.split('\\n'):\n            matched = re.match(re_expr, check)\n            if not matched:\n            new_check.append(check)\n            check_import.text = '\\n'.join(new_check)\n    self.write_xml()\n", "code_toks_joined": "def remove_debug_info ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> re_expr = <STRING> <NEWLINE> for rule in self . get_all_result_rules ( ) : <NEWLINE> <INDENT> for check_import in self . filter_grandchildren ( rule , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ) : <NEWLINE> if check_import . text is not None : <NEWLINE> new_check = [ ] <NEWLINE> for check in check_import . text . split ( <STRING> ) : <NEWLINE> matched = re . match ( re_expr , check ) <NEWLINE> if not matched : <NEWLINE> new_check . append ( check ) <NEWLINE> check_import . text = <STRING> . join ( new_check ) <NEWLINE> <DEDENT> <DEDENT> self . write_xml ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Function removes debug information from report\"\"\"", "r'^preupg.log.DEBUG.*'", "\"check\"", "\"check-import\"", "'\\n'", "'\\n'"]}, "err_obj": {"msg": "expected an indented block"}}], ["6e61ccca8e210a7083a095826f512611", {"code_string": "class next:\n    def GET(self, num):\n        number = int(num)\n        todos = db.select('testcsv', limit = 20, offset = 20 * number)\n        number = number + 1\n            return render.next(todos, number)\n", "code_toks_joined": "class next : <NEWLINE> <INDENT> def GET ( self , num ) : <NEWLINE> <INDENT> number = int ( num ) <NEWLINE> todos = db . select ( <STRING> , limit = 20 , offset = 20 * number ) <NEWLINE> number = number + 1 <NEWLINE> <INDENT> return render . next ( todos , number ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'testcsv'"]}, "err_obj": {"msg": "unexpected indent"}}], ["c7ba40614bc2dc4937029a2f330a638e", {"code_string": "def get_type(column):\n    '''determine column type'''\n    a = set(map(type, column))\n    types = [int, float, str]\n    i = max(map(lambda(t, n): (t in a) *(n + 1), zip(types, range(len(types)))))\n    return types[i - 1]\n", "code_toks_joined": "def get_type ( column ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> a = set ( map ( type , column ) ) <NEWLINE> types = [ int , float , str ] <NEWLINE> i = max ( map ( lambda ( t , n ) : ( t in a ) * ( n + 1 ) , zip ( types , range ( len ( types ) ) ) ) ) <NEWLINE> return types [ i - 1 ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''determine column type'''"]}, "err_obj": {"msg": "invalid syntax"}}], ["48931ec1c5683662a00d4c6a14f99c9b", {"code_string": "def subjects(request):\n    return{\n    'subjects': Subject.objects.all()\n", "code_toks_joined": "def subjects ( request ) : <NEWLINE> <INDENT> return { <NEWLINE> <STRING> : Subject . objects . all ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'subjects'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["361a0c0cf62aac888351a500c9515e52", {"code_string": "class Bucket:\n    def __init__(self, bucket, conn = None):\n        self.conn = conn if conn else Connection()\n        self.bucket = bucket\n    _s = \"\"\"def %s(self, *args, **kws):\"\"\"\n    for _m in('put', 'post', 'stat', 'delete', 'list'):\n        exec _s %(_m, _m)\n    _s = \"\"\"def %s(self, *args, **kws):\"\"\"\n    for _m in('get_object', 'get_object_contents', 'put_object',\n        'post_object', 'stat_object', 'delete_object',\n        'generate_url'):\n        exec _s %(_m, _m)\n    del _m, _s\n", "code_toks_joined": "class Bucket : <NEWLINE> <INDENT> def __init__ ( self , bucket , conn = None ) : <NEWLINE> <INDENT> self . conn = conn if conn else Connection ( ) <NEWLINE> self . bucket = bucket <NEWLINE> <DEDENT> _s = <STRING> <NEWLINE> for _m in ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> exec _s % ( _m , _m ) <NEWLINE> <DEDENT> _s = <STRING> <NEWLINE> for _m in ( <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> ) : <NEWLINE> exec _s % ( _m , _m ) <NEWLINE> <DEDENT> del _m , _s <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"def %s(self, *args, **kws):\"\"\"", "'put'", "'post'", "'stat'", "'delete'", "'list'", "\"\"\"def %s(self, *args, **kws):\"\"\"", "'get_object'", "'get_object_contents'", "'put_object'", "'post_object'", "'stat_object'", "'delete_object'", "'generate_url'"]}, "err_obj": {"msg": "invalid syntax"}}], ["7bef5763c10444ac9b4f0f798eb30327", {"code_string": "class TestAnalyzer:\n    analyzer = timeside.analyzer.Level()\n    def __init__(self, path):\n        self.source = path\n        print(\"Processing %s\" % self.source)\n        self.decoder = timeside.decoder.FileDecoder(self.source)\n        print('format: ', self.decoder.format())\n        self.pipe = self.decoder\n        self.sub_pipe = self.analyzer\n    def process(self):\n        self.pipe = self.pipe | self.sub_pipe\n        self.pipe.run()\n    def results(self):\n        print({'name': self.analyzer.name(),\n            'id': self.analyzer.id(),\n            'unit': self.analyzer.unit(),\n            'value': str(self.analyzer.value)}\n", "code_toks_joined": "class TestAnalyzer : <NEWLINE> <INDENT> analyzer = timeside . analyzer . Level ( ) <NEWLINE> def __init__ ( self , path ) : <NEWLINE> <INDENT> self . source = path <NEWLINE> print ( <STRING> % self . source ) <NEWLINE> self . decoder = timeside . decoder . FileDecoder ( self . source ) <NEWLINE> print ( <STRING> , self . decoder . format ( ) ) <NEWLINE> self . pipe = self . decoder <NEWLINE> self . sub_pipe = self . analyzer <NEWLINE> <DEDENT> def process ( self ) : <NEWLINE> <INDENT> self . pipe = self . pipe | self . sub_pipe <NEWLINE> self . pipe . run ( ) <NEWLINE> <DEDENT> def results ( self ) : <NEWLINE> <INDENT> print ( { <STRING> : self . analyzer . name ( ) , <NEWLINE> <INDENT> <STRING> : self . analyzer . id ( ) , <NEWLINE> <STRING> : self . analyzer . unit ( ) , <NEWLINE> <STRING> : str ( self . analyzer . value ) } <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Processing %s\"", "'format: '", "'name'", "'id'", "'unit'", "'value'"]}, "window_span": [123, 174], "err_obj": {"msg": "unbalanced (){}[]"}}], ["5e194d4ed1be05754cc92e66627a45f6", {"code_string": "def setUp(self):\n    from featchat.agents.connection import connection_agent\n    config = connection_agent.ConnectionAgentConfiguration(\n        doc_id = 'test-connection-config'\n        connections_limit = 2)\n    featchat.initial_data(config)\n    self.override_config('connection_agent', config)\n    return common.SimulationTest.setUp(self)\n", "code_toks_joined": "def setUp ( self ) : <NEWLINE> <INDENT> from featchat . agents . connection import connection_agent <NEWLINE> config = connection_agent . ConnectionAgentConfiguration ( <NEWLINE> <INDENT> doc_id = <STRING> <NEWLINE> connections_limit = 2 ) <NEWLINE> <DEDENT> featchat . initial_data ( config ) <NEWLINE> self . override_config ( <STRING> , config ) <NEWLINE> return common . SimulationTest . setUp ( self ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'test-connection-config'", "'connection_agent'"]}, "err_obj": {"msg": "invalid syntax"}}], ["dee79ada733bd3212b8442a2cf162e58", {"code_string": "def url_for_page(page = None, query = None)\n    args = request.args.to_dict(flat = False)\n    if page:\n        args['page'] = page\n    if query:\n        args['query'] = query\n    return url_for(request.endpoint, ** args)\n", "code_toks_joined": "def url_for_page ( page = None , query = None ) <NEWLINE> <INDENT> args = request . args . to_dict ( flat = False ) <NEWLINE> if page : <NEWLINE> <INDENT> args [ <STRING> ] = page <NEWLINE> <DEDENT> if query : <NEWLINE> <INDENT> args [ <STRING> ] = query <NEWLINE> <DEDENT> return url_for ( request . endpoint , ** args ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'page'", "'query'"]}, "err_obj": {"msg": "invalid syntax"}}], ["cc6d3dd694d4baa86fd8fc9d63fbd3f7", {"code_string": "def getenv(s):\n    if os.environ.has_key(s):\n    return os.environ[s]\n    return None\n", "code_toks_joined": "def getenv ( s ) : <NEWLINE> <INDENT> if os . environ . has_key ( s ) : <NEWLINE> return os . environ [ s ] <NEWLINE> return None <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["9e19c84bb256875bbc7f841b8a6efb92", {"code_string": "import datetime\nfrom..models import ProjectEvent, Project\ndef create_project_event(project: Project, text,\n    data_json: dict = None, event_type: str = None) -> ProjectEvent:\n    event = ProjectEvent(project = project, human_text = text)\n    event.created_on = datetime.datetime.utcnow()\n    if data_json:\n    event.optional_data_json = data_json\n    if event_type:\n    event.optional_event_type = event_type\n    return event\n", "code_toks_joined": "import datetime <NEWLINE> from . . models import ProjectEvent , Project <NEWLINE> def create_project_event ( project : Project , text , <NEWLINE> <INDENT> data_json : dict = None , event_type : str = None ) -> ProjectEvent : <NEWLINE> event = ProjectEvent ( project = project , human_text = text ) <NEWLINE> event . created_on = datetime . datetime . utcnow ( ) <NEWLINE> if data_json : <NEWLINE> event . optional_data_json = data_json <NEWLINE> if event_type : <NEWLINE> event . optional_event_type = event_type <NEWLINE> return event <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["a777ba7e1bb8d81b8cf58ebb05e744e0", {"code_string": "def backup_config(self, destination = '.config.old'):\n    if path.isfile(path.join(self.location, '.config'):\n        shutil.copy2(path.join(self.location, '.config'),\n            path.join(self.location, destination))\n", "code_toks_joined": "def backup_config ( self , destination = <STRING> ) : <NEWLINE> <INDENT> if path . isfile ( path . join ( self . location , <STRING> ) : <NEWLINE> <INDENT> shutil . copy2 ( path . join ( self . location , <STRING> ) , <NEWLINE> <INDENT> path . join ( self . location , destination ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'.config.old'", "'.config'", "'.config'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["1adeec30bf7c7950097bce8bdf422cde", {"code_string": "def isHome(sSiteName, sFunction):\n    if(sSiteName == 'cHome'):\n        oHome = cHome()\n        exec \"oHome.\" + sFunction + \"()\"\n        return True\n    return False\n", "code_toks_joined": "def isHome ( sSiteName , sFunction ) : <NEWLINE> <INDENT> if ( sSiteName == <STRING> ) : <NEWLINE> <INDENT> oHome = cHome ( ) <NEWLINE> exec <STRING> + sFunction + <STRING> <NEWLINE> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'cHome'", "\"oHome.\"", "\"()\""]}, "err_obj": {"msg": "invalid syntax"}}], ["514a39cb07186b4b5538271f25b89628", {"code_string": "def role_get(self, context, auth = None):\n    aws_access_key_id = context['environment']['openstack.params']['auth']['AWS_ACCESS_KEY_ID']\n    aws_access_secret_key = context['environment']['openstack.params']['auth']['AWS_ACCESS_SECRET_KEY']\n    role_name = context['environment']['openstack.params']['auth']['AWS_ROLE_NAME']\n        response = aws_sip.role_get(aws_access_key_id, aws_access_secret_key, role_name)\n    print(\"response: \", response)\n    print(\"\")\n        return response\n", "code_toks_joined": "def role_get ( self , context , auth = None ) : <NEWLINE> <INDENT> aws_access_key_id = context [ <STRING> ] [ <STRING> ] [ <STRING> ] [ <STRING> ] <NEWLINE> aws_access_secret_key = context [ <STRING> ] [ <STRING> ] [ <STRING> ] [ <STRING> ] <NEWLINE> role_name = context [ <STRING> ] [ <STRING> ] [ <STRING> ] [ <STRING> ] <NEWLINE> <INDENT> response = aws_sip . role_get ( aws_access_key_id , aws_access_secret_key , role_name ) <NEWLINE> <DEDENT> print ( <STRING> , response ) <NEWLINE> print ( <STRING> ) <NEWLINE> <INDENT> return response <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'environment'", "'openstack.params'", "'auth'", "'AWS_ACCESS_KEY_ID'", "'environment'", "'openstack.params'", "'auth'", "'AWS_ACCESS_SECRET_KEY'", "'environment'", "'openstack.params'", "'auth'", "'AWS_ROLE_NAME'", "\"response: \"", "\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["8f8ed0e35eeca55acfebd966b2308dfd", {"code_string": "def test_set_boot_device_ok(self, get_ilo_object_mock):\n    ilo_object_mock = get_ilo_object_mock.return_value\n    with task_manager.acquire(self.context, self.node.uuid,\n        shared = False) as task:\n        task.driver.management.set_boot_device(task, boot_devices.CDROM,\n            False)\n            get_ilo_object_mock.assert_called_once_with(task.node)\n            ilo_object_mock.set_one_time_boot.assert_called_once_with('CDROM')\n", "code_toks_joined": "def test_set_boot_device_ok ( self , get_ilo_object_mock ) : <NEWLINE> <INDENT> ilo_object_mock = get_ilo_object_mock . return_value <NEWLINE> with task_manager . acquire ( self . context , self . node . uuid , <NEWLINE> <INDENT> shared = False ) as task : <NEWLINE> task . driver . management . set_boot_device ( task , boot_devices . CDROM , <NEWLINE> <INDENT> False ) <NEWLINE> get_ilo_object_mock . assert_called_once_with ( task . node ) <NEWLINE> ilo_object_mock . set_one_time_boot . assert_called_once_with ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'CDROM'"]}, "err_obj": {"msg": "unexpected indent"}}], ["2bcfa23c602a243e79dc84d775bb982b", {"code_string": "def retranslateUi(self, MainWindow):\n    _translate = QtCore.QCoreApplication.translate\n    MainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\"))\n    self.tabWidget.setTabText(self.tabWidget.indexOf(self.widget), _translate(\"MainWindow\", \"File list\"))\n    self.textBrowser_4.setHtml(_translate(\"MainWindow\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , MainWindow ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> MainWindow . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . tabWidget . setTabText ( self . tabWidget . indexOf ( self . widget ) , _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . textBrowser_4 . setHtml ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"MainWindow\"", "\"MainWindow\"", "\"MainWindow\"", "\"File list\"", "\"MainWindow\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["54265f0f5bf1236c8c216ba7fff56e91", {"code_string": "def GetRecentAlbums(self, limit = 5):\n    \"\"\" Get a list of recently added music \"\"\"\n    self.logger.debug(\"Fetching recently added Music\")\n    try:\n        xbmc = Server(self.url('/jsonrpc', True))\n        properties = ['artist', 'albumlabel', 'year', 'description', 'thumbnail']\n        limits = {'start': 0, 'end': int(limit)}\n        return xbmc.AudioLibrary.GetRecentlyAddedAlbums(properties = properties, limits = limits)\n    except Exception, e:\n        self.logger.exception(e)\n        self.logger.error(\"Unable to fetch recently added Music!\")\n        return\n", "code_toks_joined": "def GetRecentAlbums ( self , limit = 5 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . logger . debug ( <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> xbmc = Server ( self . url ( <STRING> , True ) ) <NEWLINE> properties = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> limits = { <STRING> : 0 , <STRING> : int ( limit ) } <NEWLINE> return xbmc . AudioLibrary . GetRecentlyAddedAlbums ( properties = properties , limits = limits ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> self . logger . exception ( e ) <NEWLINE> self . logger . error ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Get a list of recently added music \"\"\"", "\"Fetching recently added Music\"", "'/jsonrpc'", "'artist'", "'albumlabel'", "'year'", "'description'", "'thumbnail'", "'start'", "'end'", "\"Unable to fetch recently added Music!\""]}, "err_obj": {"msg": "invalid syntax"}}], ["e17abe1c0ec97ea0a7cb2c14b38b6783", {"code_string": "def _init_service(self, ** kw):\n    r\"\"\"protected method def;\"\"\"\n    from..core import services as SM\n    self.services = SM.get_service_manager()\n    self.services.register_service(\n        tools.choose_str(kw.get(\"app_service\"), \"app\"),\n        self\n    )\n        \"application\",\n        self,\n        silent_mode = True,\n    )\n", "code_toks_joined": "def _init_service ( self , ** kw ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> from . . core import services as SM <NEWLINE> self . services = SM . get_service_manager ( ) <NEWLINE> self . services . register_service ( <NEWLINE> <INDENT> tools . choose_str ( kw . get ( <STRING> ) , <STRING> ) , <NEWLINE> self <NEWLINE> <DEDENT> ) <NEWLINE> <INDENT> <STRING> , <NEWLINE> self , <NEWLINE> silent_mode = True , <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["r\"\"\"protected method def;\"\"\"", "\"app_service\"", "\"app\"", "\"application\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["cc5e5f03a16c07abb088e298471f95e2", {"code_string": "def diff(self):\n    d1 = self._initial\n    d2 = self._dict\n    diffs = [(k, (v, d2[k]) for k, v in d1.items() if self.fields_differ(v, d2[k])]\n    return dict(diffs)\n", "code_toks_joined": "def diff ( self ) : <NEWLINE> <INDENT> d1 = self . _initial <NEWLINE> d2 = self . _dict <NEWLINE> diffs = [ ( k , ( v , d2 [ k ] ) for k , v in d1 . items ( ) if self . fields_differ ( v , d2 [ k ] ) ] <NEWLINE> return dict ( diffs ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["f6600120dbbad7cf30c52e26f5e0b7e1", {"code_string": "def new_view(request, * args, ** kwargs):\n    user = get_user(request)\n    if user.is_authenticated():\n        return view(request, * args, ** kwargs)\n    else:\n        url = '{}?next={}' format(settings.LOGIN_URL,\n            request.path)\n        return redirect(url)\n    return new_view\n", "code_toks_joined": "def new_view ( request , * args , ** kwargs ) : <NEWLINE> <INDENT> user = get_user ( request ) <NEWLINE> if user . is_authenticated ( ) : <NEWLINE> <INDENT> return view ( request , * args , ** kwargs ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> url = <STRING> format ( settings . LOGIN_URL , <NEWLINE> <INDENT> request . path ) <NEWLINE> <DEDENT> return redirect ( url ) <NEWLINE> <DEDENT> return new_view <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'{}?next={}'"]}, "err_obj": {"msg": "invalid syntax"}}], ["89952ba35b7af5dd5ec1d23070d78fe4", {"code_string": "def __run_adb_cmd(self, cmd):\n    try:\n        args = [\"adb\"]\n        args.extend(cmd)\n        process = subprocess.Popen(args, stdin = subprocess.PIPE, stdout = subprocess.PIPE, stderr = subprocess.PIPE)\n        ret = process.communicate()\n        return ret\n    except Exception, ex:\n        print(ret)\n        raise Exception(ex)\n", "code_toks_joined": "def __run_adb_cmd ( self , cmd ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> args = [ <STRING> ] <NEWLINE> args . extend ( cmd ) <NEWLINE> process = subprocess . Popen ( args , stdin = subprocess . PIPE , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) <NEWLINE> ret = process . communicate ( ) <NEWLINE> return ret <NEWLINE> <DEDENT> except Exception , ex : <NEWLINE> <INDENT> print ( ret ) <NEWLINE> raise Exception ( ex ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"adb\""]}, "err_obj": {"msg": "invalid syntax"}}], ["f0611a5a73043af1c965d2694c09a302", {"code_string": "def main():\n    entities = []\n    fin = open(sys.argv[1])\n        for line in fin.readlines():\n            if(len(line.strip()) > 0 and(line[0] != '#')):\n            entities.append(line.strip())\n    fin.close()\n    print('<labels xmlns=\\\"http://mulan.sourceforge.net/labels\\\">')\n    for entity in entities:\n        print('\\t<label name=\\\"' + entity + '\\\"></label>')\n    print('</labels>')\n", "code_toks_joined": "def main ( ) : <NEWLINE> <INDENT> entities = [ ] <NEWLINE> fin = open ( sys . argv [ 1 ] ) <NEWLINE> <INDENT> for line in fin . readlines ( ) : <NEWLINE> <INDENT> if ( len ( line . strip ( ) ) > 0 and ( line [ 0 ] != <STRING> ) ) : <NEWLINE> entities . append ( line . strip ( ) ) <NEWLINE> <DEDENT> <DEDENT> fin . close ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> for entity in entities : <NEWLINE> <INDENT> print ( <STRING> + entity + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'#'", "'<labels xmlns=\\\"http://mulan.sourceforge.net/labels\\\">'", "'\\t<label name=\\\"'", "'\\\"></label>'", "'</labels>'"]}, "err_obj": {"msg": "unexpected indent"}}], ["5b1ac473fff72a3ea6d33f14707a5171", {"code_string": "def _FindNthChildNamed(self, node, name, n = 1):\n    for i, child in enumerate(\n        py3compat.ifilter(lambda c: pytree_utils.NodeName(c) == name,\n            node.pre_order())):\n            if i == n - 1:\n        return child\n    raise RuntimeError('No Nth child for n={0}'.format(n))\n", "code_toks_joined": "def _FindNthChildNamed ( self , node , name , n = 1 ) : <NEWLINE> <INDENT> for i , child in enumerate ( <NEWLINE> <INDENT> py3compat . ifilter ( lambda c : pytree_utils . NodeName ( c ) == name , <NEWLINE> <INDENT> node . pre_order ( ) ) ) : <NEWLINE> if i == n - 1 : <NEWLINE> <DEDENT> return child <NEWLINE> <DEDENT> raise RuntimeError ( <STRING> . format ( n ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'No Nth child for n={0}'"]}, "err_obj": {"msg": "unindent does not match any outer indentation level"}}], ["4b11d06b044ea287c7c200ac4eec8d08", {"code_string": "def save(self, * args, ** kwargs):\n    if not self.pk:\n        self.amount = self.points_table[self.ttype]\n            super(Transaction, self).save(* args, ** kwargs)\n", "code_toks_joined": "def save ( self , * args , ** kwargs ) : <NEWLINE> <INDENT> if not self . pk : <NEWLINE> <INDENT> self . amount = self . points_table [ self . ttype ] <NEWLINE> <INDENT> super ( Transaction , self ) . save ( * args , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["1deba968ea5aaefed6d63de4e92ac3ac", {"code_string": "class Foo:\n    def __init__(self):\n    self.i = 10\n    self.j = 20\n", "code_toks_joined": "class Foo : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> self . i = 10 <NEWLINE> self . j = 20 <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["d2be35799e340bf73afbe762a2213428", {"code_string": "def train(self, episode_len, episode_nbr, behavior = 'balance'):\n    tau = 0.001\n    speedup = 0.1\n    self.pos_log = []\n    for j in range(episode_nbr):\n        self.run_episode(episode_len, tau, behavior, 'train')\n        if(j + 1) % 100 == 0: print \"%i episodes run\" %(j + 1)\n    self.run_episode(episode_len, tau, behavior, 'show')\n    show(behavior + '.html', self.pos_log, tau / speedup)\n", "code_toks_joined": "def train ( self , episode_len , episode_nbr , behavior = <STRING> ) : <NEWLINE> <INDENT> tau = 0.001 <NEWLINE> speedup = 0.1 <NEWLINE> self . pos_log = [ ] <NEWLINE> for j in range ( episode_nbr ) : <NEWLINE> <INDENT> self . run_episode ( episode_len , tau , behavior , <STRING> ) <NEWLINE> if ( j + 1 ) % 100 == 0 : print <STRING> % ( j + 1 ) <NEWLINE> <DEDENT> self . run_episode ( episode_len , tau , behavior , <STRING> ) <NEWLINE> show ( behavior + <STRING> , self . pos_log , tau / speedup ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'balance'", "'train'", "\"%i episodes run\"", "'show'", "'.html'"]}, "err_obj": {"msg": "invalid syntax"}}], ["f85d7af4472be4701bb01a75e780d44a", {"code_string": "def OnComplete(self, event):\n    num = self.todo_list.GetItemCount()\n    for i in range(num):\n        if i == 0: pass\n        if self.todo_list.IsChecked(i):\n        qry = 'UPDATE todo SET complete = 1 WHERE todo_number = %s;' %(self.todo_list.GetItem(i, 7).GetText())\n        EMR_utilities.updateData(qry)\n        self.todo_list.DeleteItem(i)\n", "code_toks_joined": "def OnComplete ( self , event ) : <NEWLINE> <INDENT> num = self . todo_list . GetItemCount ( ) <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> if i == 0 : pass <NEWLINE> if self . todo_list . IsChecked ( i ) : <NEWLINE> qry = <STRING> % ( self . todo_list . GetItem ( i , 7 ) . GetText ( ) ) <NEWLINE> EMR_utilities . updateData ( qry ) <NEWLINE> self . todo_list . DeleteItem ( i ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'UPDATE todo SET complete = 1 WHERE todo_number = %s;'"]}, "err_obj": {"msg": "expected an indented block"}}], ["91e60b9d33e53a418703539f5bd813ad", {"code_string": "from hyperv.neutron.ml2 import mech_hyperv\nfrom neutron.common import constants\nfrom neutron.extensions import portbindings\nfrom neutron.plugins.ml2.drivers import mech_agent\nclass HypervMechanismDriver(mech_hyperv.HypervMechanismDriver,\n    mech_agent.SimpleAgentMechanismDriverBase):\n    \"\"\"Attach to networks using hyperv L2 agent.\"\"\"\n    def __init__(self):\n    super(HypervMechanismDriver, self).__init__(\n    constants.AGENT_TYPE_HYPERV,\n    portbindings.VIF_TYPE_HYPERV,\n    {portbindings.CAP_PORT_FILTER: False})\n", "code_toks_joined": "from hyperv . neutron . ml2 import mech_hyperv <NEWLINE> from neutron . common import constants <NEWLINE> from neutron . extensions import portbindings <NEWLINE> from neutron . plugins . ml2 . drivers import mech_agent <NEWLINE> class HypervMechanismDriver ( mech_hyperv . HypervMechanismDriver , <NEWLINE> <INDENT> mech_agent . SimpleAgentMechanismDriverBase ) : <NEWLINE> <STRING> <NEWLINE> def __init__ ( self ) : <NEWLINE> super ( HypervMechanismDriver , self ) . __init__ ( <NEWLINE> constants . AGENT_TYPE_HYPERV , <NEWLINE> portbindings . VIF_TYPE_HYPERV , <NEWLINE> { portbindings . CAP_PORT_FILTER : False } ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Attach to networks using hyperv L2 agent.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["95e8a5f40246575605ea187a9a785d54", {"code_string": "def create_cost_fun(self):\n    what_to_predict = self.input_mat[: , 1: ]\n    for_how_long = self.for_how_long - 1\n    starting_when = T.zeros_like(self.for_how_long)\n    self.lstm_cost = masked_loss(self.lstm_predictions,\n        what_to_predict,\n        for_how_long,\n        starting_when).sum()\n    self.final_cost = masked_loss(self.final_predictions\n        what_to_predict,\n        for_how_long,\n        starting_when).sum()\n", "code_toks_joined": "def create_cost_fun ( self ) : <NEWLINE> <INDENT> what_to_predict = self . input_mat [ : , 1 : ] <NEWLINE> for_how_long = self . for_how_long - 1 <NEWLINE> starting_when = T . zeros_like ( self . for_how_long ) <NEWLINE> self . lstm_cost = masked_loss ( self . lstm_predictions , <NEWLINE> <INDENT> what_to_predict , <NEWLINE> for_how_long , <NEWLINE> starting_when ) . sum ( ) <NEWLINE> <DEDENT> self . final_cost = masked_loss ( self . final_predictions <NEWLINE> <INDENT> what_to_predict , <NEWLINE> for_how_long , <NEWLINE> starting_when ) . sum ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["e584877f3a92f82015e6b151bdadc2f7", {"code_string": "def Thread7214(MSG_Tuple, SenderInfo):\n    MSG = dict(map(None, MSG_Tuple))\n        SensorData = ReadTransducerBlockDataFromMultipleChannelsOfATIM(MSG['timId'], MSG['channelId'], MSG['timeout'], MSG['numberOfSamples'], MSG['sampleInterval'], MSG['startTime'])\n        response = MSG['functionId'] + ',' + MSG['ncapId'] + ',' + MSG['timId'] + ',' + MSG['channelId'] + ',' + str(SensorData['data'])\n        xmpp_send(str(SenderInfo[1]), response)\n", "code_toks_joined": "def Thread7214 ( MSG_Tuple , SenderInfo ) : <NEWLINE> <INDENT> MSG = dict ( map ( None , MSG_Tuple ) ) <NEWLINE> <INDENT> SensorData = ReadTransducerBlockDataFromMultipleChannelsOfATIM ( MSG [ <STRING> ] , MSG [ <STRING> ] , MSG [ <STRING> ] , MSG [ <STRING> ] , MSG [ <STRING> ] , MSG [ <STRING> ] ) <NEWLINE> response = MSG [ <STRING> ] + <STRING> + MSG [ <STRING> ] + <STRING> + MSG [ <STRING> ] + <STRING> + MSG [ <STRING> ] + <STRING> + str ( SensorData [ <STRING> ] ) <NEWLINE> xmpp_send ( str ( SenderInfo [ 1 ] ) , response ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'timId'", "'channelId'", "'timeout'", "'numberOfSamples'", "'sampleInterval'", "'startTime'", "'functionId'", "','", "'ncapId'", "','", "'timId'", "','", "'channelId'", "','", "'data'"]}, "err_obj": {"msg": "unexpected indent"}}], ["b62b655acd5435cc16faf7f373915c2b", {"code_string": "def _parse_opcode(self, opcode):\n    nibbles = opcode.split(' ')\n    opcode_size = len(nibbles)\n    opcode_string = ''.join(nibbles)\n    printopcode_string)\n", "code_toks_joined": "def _parse_opcode ( self , opcode ) : <NEWLINE> <INDENT> nibbles = opcode . split ( <STRING> ) <NEWLINE> opcode_size = len ( nibbles ) <NEWLINE> opcode_string = <STRING> . join ( nibbles ) <NEWLINE> printopcode_string ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["' '", "''"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["77043af81ad093713f897bcfddaa6d91", {"code_string": "class EmailFeedSettingManager(models.Manager):\n    def filter_subscribers(\n        self,\n        potential_subscribers = None,\n        feed_type = None,\n        frequency = None\n        ):\n        \"\"\"returns set of users who have matching subscriptions\"\"\"\n        matching_feeds = self.filter(\n            feed_type = feed_type,\n            frequency = frequency\n            )\n            if potential_subscribers is not None:\n            matching_feeds = matching_feeds.filter(\n            subscriber__in = potential_subscribers\n        )\n        subscriber_set = set()\n        for feed in matching_feeds:\n        subscriber_set.add(feed.subscriber)\n        return subscriber_set\n", "code_toks_joined": "class EmailFeedSettingManager ( models . Manager ) : <NEWLINE> <INDENT> def filter_subscribers ( <NEWLINE> <INDENT> self , <NEWLINE> potential_subscribers = None , <NEWLINE> feed_type = None , <NEWLINE> frequency = None <NEWLINE> ) : <NEWLINE> <STRING> <NEWLINE> matching_feeds = self . filter ( <NEWLINE> <INDENT> feed_type = feed_type , <NEWLINE> frequency = frequency <NEWLINE> ) <NEWLINE> if potential_subscribers is not None : <NEWLINE> matching_feeds = matching_feeds . filter ( <NEWLINE> subscriber__in = potential_subscribers <NEWLINE> <DEDENT> ) <NEWLINE> subscriber_set = set ( ) <NEWLINE> for feed in matching_feeds : <NEWLINE> subscriber_set . add ( feed . subscriber ) <NEWLINE> return subscriber_set <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"returns set of users who have matching subscriptions\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["57f772bd64dcfcd396b68bc57ebdde31", {"code_string": "def _listing_iter(self, account_name, lcontainer, lprefix, env):\n    for page in self._listing_pages_iter(account_name,\n        lcontainer, lprefix, env):\n        for item in page:\n        yield item\n", "code_toks_joined": "def _listing_iter ( self , account_name , lcontainer , lprefix , env ) : <NEWLINE> <INDENT> for page in self . _listing_pages_iter ( account_name , <NEWLINE> <INDENT> lcontainer , lprefix , env ) : <NEWLINE> for item in page : <NEWLINE> yield item <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["e1b66f40d5271aaa21028f5445ccd189", {"code_string": "def getstat(xax, yax):\n    cdf = np.cumsum(yax)\n        ppf = interp1d(cdf, xax)\n        p16, med, p84 = ppf([0.16, 0.50, 0.84])\n        emed1 = med - p16\n        emed2 = p84 - med\n        return med, emed2, emed1\n", "code_toks_joined": "def getstat ( xax , yax ) : <NEWLINE> <INDENT> cdf = np . cumsum ( yax ) <NEWLINE> <INDENT> ppf = interp1d ( cdf , xax ) <NEWLINE> p16 , med , p84 = ppf ( [ 0.16 , 0.50 , 0.84 ] ) <NEWLINE> emed1 = med - p16 <NEWLINE> emed2 = p84 - med <NEWLINE> return med , emed2 , emed1 <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["ba8bda7ebfaec80327e718e99879eb5a", {"code_string": "def __initiate_values(self):\n    self.__override_table_final = ''\n    self.__state = 'default'\n    self.__override_list = []\n    self.__state_dict = {\n        'default': self.__default_func\n        'override': self.__override_func,\n        'unsure_ob': self.__after_bracket_func,\n    }\n    self.__override_dict = {\n        'cw<ls<lis-tbl-id': 'list-table-id',\n        'cw<ls<list-id___': 'list-id',\n    }\n", "code_toks_joined": "def __initiate_values ( self ) : <NEWLINE> <INDENT> self . __override_table_final = <STRING> <NEWLINE> self . __state = <STRING> <NEWLINE> self . __override_list = [ ] <NEWLINE> self . __state_dict = { <NEWLINE> <INDENT> <STRING> : self . __default_func <NEWLINE> <STRING> : self . __override_func , <NEWLINE> <STRING> : self . __after_bracket_func , <NEWLINE> <DEDENT> } <NEWLINE> self . __override_dict = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "'default'", "'default'", "'override'", "'unsure_ob'", "'cw<ls<lis-tbl-id'", "'list-table-id'", "'cw<ls<list-id___'", "'list-id'"]}, "err_obj": {"msg": "invalid syntax"}}], ["753f86bd004e82c9af6ebad266dd0ada", {"code_string": "def setupUi(self, SingleFileUpload):\n    SingleFileUpload.setObjectName(_fromUtf8(\"SingleFileUpload\"))\n    SingleFileUpload.resize(980, 611)\n    palette = QtGui.QPalette()\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)\n    SingleFileUpload.setPalette(palette)\n    SingleFileUpload.setAutoFillBackground(False)\n    SingleFileUpload.setLocale(QtCore.QLocale(QtCore.QLocale.English, QtCore.QLocale.UnitedStates))\n    self.start_upload_bt = QtGui.QPushButton(SingleFileUpload)\n    self.start_upload_bt.setGeometry(QtCore.QRect(840, 571, 121, 31))\n    font = QtGui.QFont()\n    font.setFamily(_fromUtf8(\"Lato\"))\n    font.setPointSize(12)\n    font.setBold(True)\n    font.setWeight(75)\n    self.start_upload_bt.setFont(font)\n    self.start_upload_bt.setStyleSheet(_fromUtf8(\"QPushButton:hover{\\n\"\n", "code_toks_joined": "def setupUi ( self , SingleFileUpload ) : <NEWLINE> <INDENT> SingleFileUpload . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> SingleFileUpload . resize ( 980 , 611 ) <NEWLINE> palette = QtGui . QPalette ( ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Base , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Window , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Base , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Window , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Base , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Window , brush ) <NEWLINE> SingleFileUpload . setPalette ( palette ) <NEWLINE> SingleFileUpload . setAutoFillBackground ( False ) <NEWLINE> SingleFileUpload . setLocale ( QtCore . QLocale ( QtCore . QLocale . English , QtCore . QLocale . UnitedStates ) ) <NEWLINE> self . start_upload_bt = QtGui . QPushButton ( SingleFileUpload ) <NEWLINE> self . start_upload_bt . setGeometry ( QtCore . QRect ( 840 , 571 , 121 , 31 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setFamily ( _fromUtf8 ( <STRING> ) ) <NEWLINE> font . setPointSize ( 12 ) <NEWLINE> font . setBold ( True ) <NEWLINE> font . setWeight ( 75 ) <NEWLINE> self . start_upload_bt . setFont ( font ) <NEWLINE> self . start_upload_bt . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"SingleFileUpload\"", "\"Lato\"", "\"QPushButton:hover{\\n\""]}, "window_span": [445, 451], "err_obj": {"msg": "unbalanced (){}[]"}}], ["ba097bbda65a957e40a22edb6cb686ee", {"code_string": "class HTTPS(HTTP):\n    \"\"\"Compatibility with 1.5 httplib interface\"\"\"\n    _connection_class = HTTPSConnection\n    def __init__(self, host = '', port = None, key_file = None, cert_file = None,\n        strict = None):\n        if key_file is not None or cert_file is not None:\n        raise NotImplementedError(\n        \"key_file and cert_file arguments are not implemented\")\n        if port == 0:\n        port = None\n        self._setup(self._connection_class(host, port, key_file,\n            cert_file, strict))\n            self.key_file = key_file\n            self.cert_file = cert_file\n", "code_toks_joined": "class HTTPS ( HTTP ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> _connection_class = HTTPSConnection <NEWLINE> def __init__ ( self , host = <STRING> , port = None , key_file = None , cert_file = None , <NEWLINE> <INDENT> strict = None ) : <NEWLINE> if key_file is not None or cert_file is not None : <NEWLINE> raise NotImplementedError ( <NEWLINE> <STRING> ) <NEWLINE> if port == 0 : <NEWLINE> port = None <NEWLINE> self . _setup ( self . _connection_class ( host , port , key_file , <NEWLINE> <INDENT> cert_file , strict ) ) <NEWLINE> self . key_file = key_file <NEWLINE> self . cert_file = cert_file <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Compatibility with 1.5 httplib interface\"\"\"", "''", "\"key_file and cert_file arguments are not implemented\""]}, "err_obj": {"msg": "expected an indented block"}}], ["306c8abbdf14c292fcdacd71ff5d972a", {"code_string": "def file_len(self, fname):\n    with open(fname) as f:\n        i = 0\n            for i, l in enumerate(f):\n                pass\n    if i == 0:\n        return i\n    else:\n        return i + 1\n", "code_toks_joined": "def file_len ( self , fname ) : <NEWLINE> <INDENT> with open ( fname ) as f : <NEWLINE> <INDENT> i = 0 <NEWLINE> <INDENT> for i , l in enumerate ( f ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if i == 0 : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return i + 1 <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["34c4ef3303a9f1c8aa644c81149df529", {"code_string": "def logout(request):\n    auth.logout(request)\n    return render_to_response(\n        'account/logout.html'\n        {},\n        RequestContext(request))\n", "code_toks_joined": "def logout ( request ) : <NEWLINE> <INDENT> auth . logout ( request ) <NEWLINE> return render_to_response ( <NEWLINE> <INDENT> <STRING> <NEWLINE> { } , <NEWLINE> RequestContext ( request ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'account/logout.html'"]}, "err_obj": {"msg": "invalid syntax"}}], ["5ea3ace3391ad24c2afb4ce978c6098c", {"code_string": "def cleanUpFit():\n    \"\"\"Clean up workspaces created by calibration fitting \"\"\"\n    for ws_name in('TubePlot', 'RefittedPeaks', 'PolyFittingWorkspace',\n        'QF_NormalisedCovarianceMatrix', 'QF_Parameters',\n        'QF_Workspace'):\n        try:\n        DeleteWorkspace(ws_name)\n        except:\n        pass\n", "code_toks_joined": "def cleanUpFit ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for ws_name in ( <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> <STRING> ) : <NEWLINE> try : <NEWLINE> DeleteWorkspace ( ws_name ) <NEWLINE> except : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Clean up workspaces created by calibration fitting \"\"\"", "'TubePlot'", "'RefittedPeaks'", "'PolyFittingWorkspace'", "'QF_NormalisedCovarianceMatrix'", "'QF_Parameters'", "'QF_Workspace'"]}, "err_obj": {"msg": "expected an indented block"}}], ["1ca89f2f6c8e5c20f93929ca8dfafbca", {"code_string": "def UploadFiles():\n    command = ([rclone copy / gdrive / googledrive: gdrive /])\n    result = subprocess.Popen(command)\n    result.communicate()\n    \"\"\"command = ([RCLONE, 'move', '--log-file=rclone_upload.log', '--transfers', RCLONE_TRANSFERS, '--drive-chunk-size=16M', '--exclude', 'filepart', LOCAL_DIR + dir + '/', REMOTE_NAME  + REMOTE_DIR + dir + '/'])\"\"\"\n", "code_toks_joined": "def UploadFiles ( ) : <NEWLINE> <INDENT> command = ( [ rclone copy / gdrive / googledrive : gdrive / ] ) <NEWLINE> result = subprocess . Popen ( command ) <NEWLINE> result . communicate ( ) <NEWLINE> <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"command = ([RCLONE, 'move', '--log-file=rclone_upload.log', '--transfers', RCLONE_TRANSFERS, '--drive-chunk-size=16M', '--exclude', 'filepart', LOCAL_DIR + dir + '/', REMOTE_NAME  + REMOTE_DIR + dir + '/'])\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["f40245fa78909368d647add07710b3bb", {"code_string": "def test_wrapUnWrapPrecision(self):\n    \"\"\"Wrap and unwrap should have no rounding errors at least up to\"\"\"\n    for p in range(5, 13):\n        for i in range(1000):\n            self._wrapUnWrap(p)\n    with self.assertRaisesRegex(\n        FontMathWarning,\n        \"Matrix round-tripping failed for precision value\"):\n        for p in range(14, 16):\n        for i in range(1000):\n            self._wrapUnWrap(p)\n", "code_toks_joined": "def test_wrapUnWrapPrecision ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for p in range ( 5 , 13 ) : <NEWLINE> <INDENT> for i in range ( 1000 ) : <NEWLINE> <INDENT> self . _wrapUnWrap ( p ) <NEWLINE> <DEDENT> <DEDENT> with self . assertRaisesRegex ( <NEWLINE> <INDENT> FontMathWarning , <NEWLINE> <STRING> ) : <NEWLINE> for p in range ( 14 , 16 ) : <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> self . _wrapUnWrap ( p ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Wrap and unwrap should have no rounding errors at least up to\"\"\"", "\"Matrix round-tripping failed for precision value\""]}, "err_obj": {"msg": "expected an indented block"}}], ["d04c41904a3d62321590bf84188ff42c", {"code_string": "def validate_item_type_for_reorder(self):\n    if self.doc.re_order_level or len(self.doclist.get({\"parentfield\": \"item_reorder\",\n        \"material_request_type\": \"Purchase\"})):\n        if not self.doc.is_purchase_item:\n        webnotes.msgprint(_(\"\"\"To set reorder level, item must be Purchase Item\"\"\"),\n            raise_exception = 1)\n", "code_toks_joined": "def validate_item_type_for_reorder ( self ) : <NEWLINE> <INDENT> if self . doc . re_order_level or len ( self . doclist . get ( { <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> } ) ) : <NEWLINE> if not self . doc . is_purchase_item : <NEWLINE> webnotes . msgprint ( _ ( <STRING> ) , <NEWLINE> <INDENT> raise_exception = 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"parentfield\"", "\"item_reorder\"", "\"material_request_type\"", "\"Purchase\"", "\"\"\"To set reorder level, item must be Purchase Item\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["a92fac5db3ccfff500cbaa5a15493fb8", {"code_string": "def change(self, socket = None, flags = 0):\n    \"\"\"Commit changes made to the link object\"\"\"\n        if not socket:\n            socket = netlink.lookup_socket(netlink.NETLINK_ROUTE)\n    if not self._orig:\n        raise NetlinkError(\"Original link not available\")\n            ret = capi.rtnl_link_change(socket._sock, self._orig, self._rtnl_link, flags)\n                if ret < 0:\n                    raise netlink.KernelError(ret)\n", "code_toks_joined": "def change ( self , socket = None , flags = 0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> if not socket : <NEWLINE> <INDENT> socket = netlink . lookup_socket ( netlink . NETLINK_ROUTE ) <NEWLINE> <DEDENT> <DEDENT> if not self . _orig : <NEWLINE> <INDENT> raise NetlinkError ( <STRING> ) <NEWLINE> <INDENT> ret = capi . rtnl_link_change ( socket . _sock , self . _orig , self . _rtnl_link , flags ) <NEWLINE> <INDENT> if ret < 0 : <NEWLINE> <INDENT> raise netlink . KernelError ( ret ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Commit changes made to the link object\"\"\"", "\"Original link not available\""]}, "err_obj": {"msg": "unexpected indent"}}], ["0dc93dcdc7204a98ad8d7613af770e6a", {"code_string": "class Ui_MainWindow(QtGui.QMainWindow):\n    def __init__(self):\n        QtGui.QWidget.__init__(self)\n        self.setupUi(self)\n    def setupUi(self, MainWindow):\n        MainWindow.setObjectName(_fromUtf8(\"MainWindow\"))\n        MainWindow.resize(1160, 600)\n        MainWindow.setStyleSheet(_fromUtf8(\"QMainWindow{\\n\"\n", "code_toks_joined": "class Ui_MainWindow ( QtGui . QMainWindow ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> QtGui . QWidget . __init__ ( self ) <NEWLINE> self . setupUi ( self ) <NEWLINE> <DEDENT> def setupUi ( self , MainWindow ) : <NEWLINE> <INDENT> MainWindow . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> MainWindow . resize ( 1160 , 600 ) <NEWLINE> MainWindow . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"MainWindow\"", "\"QMainWindow{\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["b84de2bee03a408043722c93608e124f", {"code_string": "def info(self, path = \".\"):\n    \"\"\"Get information on an IOTile component.\"\"\"\n    tile = IOTile(path)\n    info = {\n        'is_development_version': not tile.release\n        'dependencies': tile.dependencies\n    }\n    return info\n", "code_toks_joined": "def info ( self , path = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> tile = IOTile ( path ) <NEWLINE> info = { <NEWLINE> <INDENT> <STRING> : not tile . release <NEWLINE> <STRING> : tile . dependencies <NEWLINE> <DEDENT> } <NEWLINE> return info <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\".\"", "\"\"\"Get information on an IOTile component.\"\"\"", "'is_development_version'", "'dependencies'"]}, "err_obj": {"msg": "invalid syntax"}}], ["76e80eab81a5bbd19ebcad06b2d8f1bf", {"code_string": "def implements(* abc):\n    def decorator(cls):\n    implement(cls, * abc)\n    return cls\n    return decorator\n", "code_toks_joined": "def implements ( * abc ) : <NEWLINE> <INDENT> def decorator ( cls ) : <NEWLINE> implement ( cls , * abc ) <NEWLINE> return cls <NEWLINE> return decorator <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["69afbe6fdd83320cf96fc3ab5093c128", {"code_string": "def prepareAddress(self):\n    host, port = self.addr\n    if iocpdebug.debug:\n        print(\"connecting to (%s, %s)\" %(host, port))\n    if isinstance(port, types.StringTypes):\n        try:\n            port = socket.getservbyname(port, 'tcp')\n        except socket.error, e:\n            raise error.ServiceNameUnknownError(string = str(e))\n    self.addr = (host, port)\n", "code_toks_joined": "def prepareAddress ( self ) : <NEWLINE> <INDENT> host , port = self . addr <NEWLINE> if iocpdebug . debug : <NEWLINE> <INDENT> print ( <STRING> % ( host , port ) ) <NEWLINE> <DEDENT> if isinstance ( port , types . StringTypes ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> port = socket . getservbyname ( port , <STRING> ) <NEWLINE> <DEDENT> except socket . error , e : <NEWLINE> <INDENT> raise error . ServiceNameUnknownError ( string = str ( e ) ) <NEWLINE> <DEDENT> <DEDENT> self . addr = ( host , port ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"connecting to (%s, %s)\"", "'tcp'"]}, "err_obj": {"msg": "invalid syntax"}}], ["51262650dfcc3f676496ab9f9a60f224", {"code_string": "def reset():\n    global com_vel\n    global com_acc\n    global vels\n    global accs\n    global a_s\n    global path\n    com_vel = [0., 0., 0.]\n    com_acc = [0., 0., 0.]\n    clean_path();\n    vels = []\n    accs = []\n    path = []\n    a_s = []\n    for i, config in enumerate(configs):\n    fullBody.setConfigAtState(i, config)\n", "code_toks_joined": "def reset ( ) : <NEWLINE> <INDENT> global com_vel <NEWLINE> global com_acc <NEWLINE> global vels <NEWLINE> global accs <NEWLINE> global a_s <NEWLINE> global path <NEWLINE> com_vel = [ 0. , 0. , 0. ] <NEWLINE> com_acc = [ 0. , 0. , 0. ] <NEWLINE> clean_path ( ) ; <NEWLINE> vels = [ ] <NEWLINE> accs = [ ] <NEWLINE> path = [ ] <NEWLINE> a_s = [ ] <NEWLINE> for i , config in enumerate ( configs ) : <NEWLINE> fullBody . setConfigAtState ( i , config ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["b311a01f18a8ce6ce687ca7617c3567f", {"code_string": "def __init__(self, parent, hhid = 0):\n    ''' Set up the dialog box interface '''\n    QDialog.__init__(self)\n    self.setupUi(self)\n    self.parent = parent\n    self.stlitem = \"\"\n    self.stlmodelprice = 0\n    self.stlprice = 0\n    self.connector = ReportsSettingsManager()\n    myReferenceVal = QDoubleValidator(0, 100000000, 2, self.txtIncomeDefaultValues)\n        self.txtIncomeDefaultValues.setValidator(myReferenceVal)\n    self.getPorjects()\n    self.insertDietHeader()\n    self.insertStandardOfLivingHeader()\n    self.insertIncomeSourcesHeader()\n", "code_toks_joined": "def __init__ ( self , parent , hhid = 0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> QDialog . __init__ ( self ) <NEWLINE> self . setupUi ( self ) <NEWLINE> self . parent = parent <NEWLINE> self . stlitem = <STRING> <NEWLINE> self . stlmodelprice = 0 <NEWLINE> self . stlprice = 0 <NEWLINE> self . connector = ReportsSettingsManager ( ) <NEWLINE> myReferenceVal = QDoubleValidator ( 0 , 100000000 , 2 , self . txtIncomeDefaultValues ) <NEWLINE> <INDENT> self . txtIncomeDefaultValues . setValidator ( myReferenceVal ) <NEWLINE> <DEDENT> self . getPorjects ( ) <NEWLINE> self . insertDietHeader ( ) <NEWLINE> self . insertStandardOfLivingHeader ( ) <NEWLINE> self . insertIncomeSourcesHeader ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''' Set up the dialog box interface '''", "\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["0ba1854e29a81c3ecd043ffc0cb15c69", {"code_string": "def is_skipped_function(name):\n    for fun in skipped_functions:\n        if fun == name:\n        return 1\n    if string.find(name, 'Free') != - 1:\n        return 1\n    return 0\n", "code_toks_joined": "def is_skipped_function ( name ) : <NEWLINE> <INDENT> for fun in skipped_functions : <NEWLINE> <INDENT> if fun == name : <NEWLINE> return 1 <NEWLINE> <DEDENT> if string . find ( name , <STRING> ) != - 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Free'"]}, "err_obj": {"msg": "expected an indented block"}}], ["f398852019f8bc1cecc1ed3361754816", {"code_string": "class Ward(AgglomerativeClustering):\n    \"\"\"Ward hierarchical clustering: constructs a tree and cuts it.\"\"\"\n    linkage = 'ward'\n    def __init__(self, n_clusters = 2, memory = Memory(cachedir = None, verbose = 0),\n        connectivity = None, n_components = None,\n        compute_full_tree = 'auto', pooling_func = np.mean):\n        warnings.warn(\"The Ward class is deprecated since 0.14 and will be \"\n            \"removed in 0.17. Use the AgglomerativeClustering \"\n            \"instead.\", DeprecationWarning)\n            self.n_clusters = n_clusters\n            self.memory = memory\n            self.n_components = n_components\n            self.connectivity = connectivity\n            self.compute_full_tree = compute_full_tree\n            self.affinity = \"euclidean\"\n            self.pooling_func = pooling_func\n", "code_toks_joined": "class Ward ( AgglomerativeClustering ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> linkage = <STRING> <NEWLINE> def __init__ ( self , n_clusters = 2 , memory = Memory ( cachedir = None , verbose = 0 ) , <NEWLINE> <INDENT> connectivity = None , n_components = None , <NEWLINE> compute_full_tree = <STRING> , pooling_func = np . mean ) : <NEWLINE> warnings . warn ( <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> , DeprecationWarning ) <NEWLINE> self . n_clusters = n_clusters <NEWLINE> self . memory = memory <NEWLINE> self . n_components = n_components <NEWLINE> self . connectivity = connectivity <NEWLINE> self . compute_full_tree = compute_full_tree <NEWLINE> self . affinity = <STRING> <NEWLINE> self . pooling_func = pooling_func <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Ward hierarchical clustering: constructs a tree and cuts it.\"\"\"", "'ward'", "'auto'", "\"The Ward class is deprecated since 0.14 and will be \"", "\"removed in 0.17. Use the AgglomerativeClustering \"", "\"instead.\"", "\"euclidean\""]}, "err_obj": {"msg": "unexpected indent"}}], ["8963ccd5e8091046907967d6e2f49d53", {"code_string": "class SFlowSetting(base.BaseV30):\n    url_prefix = \"/sflow/setting\"\n    def create(self, max_header, source_ip_use_mgmt,\n        packet_sampling_rate, counter_polling_interval, ** kwargs):\n        params = {\n        \"setting\": {\n            \"counter-polling-interval\": counter_polling_interval\n            }\n            }\n            return self._post(self.url_prefix, params, ** kwargs)\n    def get(self):\n        return self._get(self.url_prefix)\n", "code_toks_joined": "class SFlowSetting ( base . BaseV30 ) : <NEWLINE> <INDENT> url_prefix = <STRING> <NEWLINE> def create ( self , max_header , source_ip_use_mgmt , <NEWLINE> <INDENT> packet_sampling_rate , counter_polling_interval , ** kwargs ) : <NEWLINE> params = { <NEWLINE> <STRING> : { <NEWLINE> <INDENT> <STRING> : counter_polling_interval <NEWLINE> } <NEWLINE> } <NEWLINE> return self . _post ( self . url_prefix , params , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT> def get ( self ) : <NEWLINE> <INDENT> return self . _get ( self . url_prefix ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"/sflow/setting\"", "\"setting\"", "\"counter-polling-interval\""]}, "err_obj": {"msg": "unexpected indent"}}], ["f78b1ac19e0da1e8b95b6957b2e0c5f0", {"code_string": "def InitializeDevice(devNum):\n    base_dir = '/sys/bus/w1/devices'\n    device_folder = glob.glob(base_dir + '28*')[sensors]\n        device_file = device_folder + '/w1_slave'\n    return device_file\n", "code_toks_joined": "def InitializeDevice ( devNum ) : <NEWLINE> <INDENT> base_dir = <STRING> <NEWLINE> device_folder = glob . glob ( base_dir + <STRING> ) [ sensors ] <NEWLINE> <INDENT> device_file = device_folder + <STRING> <NEWLINE> <DEDENT> return device_file <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'/sys/bus/w1/devices'", "'28*'", "'/w1_slave'"]}, "err_obj": {"msg": "unexpected indent"}}], ["1d36745a4c8c6cbaf876a0095edd0290", {"code_string": "class DocumentScripts(plugins.Action):\n    def setUpApplication(self, app):\n        modNames = [\"batch\", \"comparetest\", \"default\", \"performance\"]\n        for modName in modNames:\n            importCommand = \"import \" + modName\n            exec importCommand\n            module = eval(modName)\n            names = dir(module)\n            for name in names:\n                scriptName = modName + \".\" + name\n                try:\n                    docString = getattr(eval(scriptName), \"scriptDoc\")\n                    print(scriptName + \"|\" + docString)\n                except AttributeError:\n                    pass\n", "code_toks_joined": "class DocumentScripts ( plugins . Action ) : <NEWLINE> <INDENT> def setUpApplication ( self , app ) : <NEWLINE> <INDENT> modNames = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for modName in modNames : <NEWLINE> <INDENT> importCommand = <STRING> + modName <NEWLINE> exec importCommand <NEWLINE> module = eval ( modName ) <NEWLINE> names = dir ( module ) <NEWLINE> for name in names : <NEWLINE> <INDENT> scriptName = modName + <STRING> + name <NEWLINE> try : <NEWLINE> <INDENT> docString = getattr ( eval ( scriptName ) , <STRING> ) <NEWLINE> print ( scriptName + <STRING> + docString ) <NEWLINE> <DEDENT> except AttributeError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"batch\"", "\"comparetest\"", "\"default\"", "\"performance\"", "\"import \"", "\".\"", "\"scriptDoc\"", "\"|\""]}, "err_obj": {"msg": "invalid syntax"}}], ["5340683234699a0fb43cdf83eee195a6", {"code_string": "def getQ(acteur):\n    try:\n        page = pywikibot.Page(site, acteur)\n        if page.isRedirectPage():\n            return getQ(page.getRedirectTarget().title())\n        else:\n            data = pywikibot.ItemPage.fromPage(page)\n            return data.getID()\n    except pywikibot.NoPage:\n        return 0\n    except:\n        print(\"Unexpected error:\", sys.exc_info()[0])\n        sys.exit()\n            raise\n", "code_toks_joined": "def getQ ( acteur ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> page = pywikibot . Page ( site , acteur ) <NEWLINE> if page . isRedirectPage ( ) : <NEWLINE> <INDENT> return getQ ( page . getRedirectTarget ( ) . title ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> data = pywikibot . ItemPage . fromPage ( page ) <NEWLINE> return data . getID ( ) <NEWLINE> <DEDENT> <DEDENT> except pywikibot . NoPage : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> , sys . exc_info ( ) [ 0 ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Unexpected error:\""]}, "err_obj": {"msg": "unexpected indent"}}], ["e3314b7170ddd142e2e53d5ddcd9e955", {"code_string": "def greetUser(self, name = None):\n    if name:\n        if trunk in local_zips:\n            return \"%s found!\" % name\n        else\n            return \"%s not downloaded yet!\" % name\n    else:\n        if name is None:\n            return 'Please enter your url <a href=\"./\">here</a>.'\n        else:\n            return 'No, really, enter your url <a href=\"./\">here</a>.'\n", "code_toks_joined": "def greetUser ( self , name = None ) : <NEWLINE> <INDENT> if name : <NEWLINE> <INDENT> if trunk in local_zips : <NEWLINE> <INDENT> return <STRING> % name <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> return <STRING> % name <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if name is None : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"%s found!\"", "\"%s not downloaded yet!\"", "'Please enter your url <a href=\"./\">here</a>.'", "'No, really, enter your url <a href=\"./\">here</a>.'"]}, "err_obj": {"msg": "invalid syntax"}}], ["9f39e67a04dc659142b03ce866e1b78a", {"code_string": "def remove(args):\n    \"\"\"Deletes all inventory files for a deployment from ~/vars/f5aws/env/<env name>\"\"\"\n    exec_results = EnvironmentManager(args).remove()\n    print_playbook_results(exec_results)\n    try:\n        if exec_results[\"playbook_results\"].statuscode == 0:\n            print(\"\")\n            display(\" The environment '{}' has been successfully removed\".format(args.env_name),\n                color = \"green\", stderr = False)\n    except KeyError, e:\n        raise ExecutionError(\"Failed due to KeyError while removing {}\".format(args.env_name))\n", "code_toks_joined": "def remove ( args ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> exec_results = EnvironmentManager ( args ) . remove ( ) <NEWLINE> print_playbook_results ( exec_results ) <NEWLINE> try : <NEWLINE> <INDENT> if exec_results [ <STRING> ] . statuscode == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> display ( <STRING> . format ( args . env_name ) , <NEWLINE> <INDENT> color = <STRING> , stderr = False ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except KeyError , e : <NEWLINE> <INDENT> raise ExecutionError ( <STRING> . format ( args . env_name ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Deletes all inventory files for a deployment from ~/vars/f5aws/env/<env name>\"\"\"", "\"playbook_results\"", "\"\"", "\" The environment '{}' has been successfully removed\"", "\"green\"", "\"Failed due to KeyError while removing {}\""]}, "err_obj": {"msg": "invalid syntax"}}], ["e83de52dcfd94a7df7a6c42917411baf", {"code_string": "def generateRecords(self, records):\n    \"\"\"Generate multiple records.Refer to definition for generateRecord\"\"\"\n    if self.verbosity > 0:\n        print 'Generating', len(records), 'records...'\n    for record in records:\n        self.generateRecord(record)\n", "code_toks_joined": "def generateRecords ( self , records ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . verbosity > 0 : <NEWLINE> <INDENT> print <STRING> , len ( records ) , <STRING> <NEWLINE> <DEDENT> for record in records : <NEWLINE> <INDENT> self . generateRecord ( record ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Generate multiple records.Refer to definition for generateRecord\"\"\"", "'Generating'", "'records...'"]}, "err_obj": {"msg": "invalid syntax"}}], ["5fe5cf4d3a9990f964954add5a460add", {"code_string": "def ehelp(name, imports):\n    \"\"\"Get help on string NAME.\"\"\"\n    locls = {}\n    if imports:\n    try: exec imports in locls\n    except: pass\n    try: help(eval(name, globals(), locls))\n    except: help(name)\n", "code_toks_joined": "def ehelp ( name , imports ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> locls = { } <NEWLINE> if imports : <NEWLINE> try : exec imports in locls <NEWLINE> except : pass <NEWLINE> try : help ( eval ( name , globals ( ) , locls ) ) <NEWLINE> except : help ( name ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get help on string NAME.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["8aaac4516e6293801bb648918ab08218", {"code_string": "def noDoubleKeys(self, keylist, key):\n    if keylist ==[]:\n        return key\n    if key == \"\":\n        return \"\"\n    for x in keylist:\n        if x == key:\n        return \"\"\n    else:\n        return key\n", "code_toks_joined": "def noDoubleKeys ( self , keylist , key ) : <NEWLINE> <INDENT> if keylist == [ ] : <NEWLINE> <INDENT> return key <NEWLINE> <DEDENT> if key == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> for x in keylist : <NEWLINE> <INDENT> if x == key : <NEWLINE> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return key <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"", "\"\"", "\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["5bb09bcc00c0bd606a68ab1f65699198", {"code_string": "class ParseError(Exception):\n    \"\"\"Parsing failure converted to an exception.\"\"\"\n    def __init__(self, message: str):\n        self.message = message\n    def __str__(self):\n        return self.message\n    def __repr__(self):\n        return 'ParseError({})'.format(repr(self.message)))\n", "code_toks_joined": "class ParseError ( Exception ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , message : str ) : <NEWLINE> <INDENT> self . message = message <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return self . message <NEWLINE> <DEDENT> def __repr__ ( self ) : <NEWLINE> <INDENT> return <STRING> . format ( repr ( self . message ) ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Parsing failure converted to an exception.\"\"\"", "'ParseError({})'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["69e833ff5517b3461b0b3f7712a2b4b4", {"code_string": "def executeCommand(cmdLine):\n    writeOutput(cmdLine)\n    startTime = time.time()\n        writeOutput(commands.getoutput(cmdLine))\n    writeOutput('command took %s' %(time.time() - startTime))\n", "code_toks_joined": "def executeCommand ( cmdLine ) : <NEWLINE> <INDENT> writeOutput ( cmdLine ) <NEWLINE> startTime = time . time ( ) <NEWLINE> <INDENT> writeOutput ( commands . getoutput ( cmdLine ) ) <NEWLINE> <DEDENT> writeOutput ( <STRING> % ( time . time ( ) - startTime ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'command took %s'"]}, "err_obj": {"msg": "unexpected indent"}}], ["71bfd90960cfbd51b35a6929cd7ee896", {"code_string": "def cleanup(self):\n    try:\n        for root, dirs, files in walk_storage(\n            self.dest, storage = private_storage):\n            for fname in files:\n            private_storage.delete(os.path.join(root, fname))\n    except OSError as e:\n        if e.errno == 2:\n            return\n        raise\n", "code_toks_joined": "def cleanup ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> for root , dirs , files in walk_storage ( <NEWLINE> <INDENT> self . dest , storage = private_storage ) : <NEWLINE> for fname in files : <NEWLINE> private_storage . delete ( os . path . join ( root , fname ) ) <NEWLINE> <DEDENT> <DEDENT> except OSError as e : <NEWLINE> <INDENT> if e . errno == 2 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> raise <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["c440131aa0e92ea910168a4877908207", {"code_string": "def deser_uint256(f):\n    r = 0 l\n    for i in xrange(8):\n        t = struct.unpack(\"<i\", f.read(4))[0]\n        r += t <<(i * 32)\n    return r\n", "code_toks_joined": "def deser_uint256 ( f ) : <NEWLINE> <INDENT> r = 0 l <NEWLINE> for i in xrange ( 8 ) : <NEWLINE> <INDENT> t = struct . unpack ( <STRING> , f . read ( 4 ) ) [ 0 ] <NEWLINE> r += t << ( i * 32 ) <NEWLINE> <DEDENT> return r <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"<i\""]}, "err_obj": {"msg": "invalid syntax"}}], ["15fb316e936da77a2343e71805533f11", {"code_string": "def get_uid(user_name):\n    try:\n        return pwd.getpwnam(user_name)[2]\n    except KeyError, exp:\n        return None\n", "code_toks_joined": "def get_uid ( user_name ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return pwd . getpwnam ( user_name ) [ 2 ] <NEWLINE> <DEDENT> except KeyError , exp : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["049d89fc57d0757974f25086b6c326bb", {"code_string": "def load_y(y_path):\n    file = open(y_path, 'rb')\n    y_ = np.array(\n        [elem for elem in[\n            row.replace('  ', ' ').strip().split(' ') for row in file\n            ],\n        dtype = np.int32\n    )\n    file.close()\n    return y_ - 1\n", "code_toks_joined": "def load_y ( y_path ) : <NEWLINE> <INDENT> file = open ( y_path , <STRING> ) <NEWLINE> y_ = np . array ( <NEWLINE> <INDENT> [ elem for elem in [ <NEWLINE> <INDENT> row . replace ( <STRING> , <STRING> ) . strip ( ) . split ( <STRING> ) for row in file <NEWLINE> ] , <NEWLINE> <DEDENT> dtype = np . int32 <NEWLINE> <DEDENT> ) <NEWLINE> file . close ( ) <NEWLINE> return y_ - 1 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'rb'", "'  '", "' '", "' '"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["4bb9a097e5c6ded057ddfc2e42cd6dcc", {"code_string": "def _setup_logging(env)\n    env.logger = logging.getLogger(\"cloudbiolinux\")\n    env.logger.setLevel(logging.DEBUG)\n    ch = logging.StreamHandler()\n    ch.setLevel(logging.DEBUG)\n    ch.setFormatter(ColorFormatter())\n    env.logger.addHandler(ch)\n", "code_toks_joined": "def _setup_logging ( env ) <NEWLINE> <INDENT> env . logger = logging . getLogger ( <STRING> ) <NEWLINE> env . logger . setLevel ( logging . DEBUG ) <NEWLINE> ch = logging . StreamHandler ( ) <NEWLINE> ch . setLevel ( logging . DEBUG ) <NEWLINE> ch . setFormatter ( ColorFormatter ( ) ) <NEWLINE> env . logger . addHandler ( ch ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"cloudbiolinux\""]}, "err_obj": {"msg": "invalid syntax"}}], ["abc1ad24842ad3883d42c80ba6ab9b5b", {"code_string": "def fetch_money(self, count, passwd):\n    \"\"\"\u63d0\u73b0\"\"\"\n    totalfee = count + count * self.feerate\n    check_result = self._pay_check(totalfee, passwd)\n    if check_result == errorcode.NO_ERROR:\n        self.card_pay(count, 3, common.create_serialno()\n        self.card_pay(count * self.feerate, 4, common.create_serialno())\n        return errorcode.NO_ERROR\n    else:\n        return check_result\n", "code_toks_joined": "def fetch_money ( self , count , passwd ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> totalfee = count + count * self . feerate <NEWLINE> check_result = self . _pay_check ( totalfee , passwd ) <NEWLINE> if check_result == errorcode . NO_ERROR : <NEWLINE> <INDENT> self . card_pay ( count , 3 , common . create_serialno ( ) <NEWLINE> self . card_pay ( count * self . feerate , 4 , common . create_serialno ( ) ) <NEWLINE> return errorcode . NO_ERROR <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return check_result <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"\u63d0\u73b0\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["3332688e229ea0dc3142e839325a468f", {"code_string": "def element_space(self):\n    \"\"\"Verify `LinearSpaceElement.space`.\"\"\"\n    with FailCounter(\n        test_name = 'Verify `LinearSpaceElement.space`',\n        logger = self.log) as counter:\n        for[n_x, x] in samples(self.space):\n        if x.space != self.space:\n            counter.fail('failed with x={:25s}'.format(n_x))\n", "code_toks_joined": "def element_space ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with FailCounter ( <NEWLINE> <INDENT> test_name = <STRING> , <NEWLINE> logger = self . log ) as counter : <NEWLINE> for [ n_x , x ] in samples ( self . space ) : <NEWLINE> if x . space != self . space : <NEWLINE> <INDENT> counter . fail ( <STRING> . format ( n_x ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Verify `LinearSpaceElement.space`.\"\"\"", "'Verify `LinearSpaceElement.space`'", "'failed with x={:25s}'"]}, "err_obj": {"msg": "expected an indented block"}}], ["35a62bda01dc5eaf90d4f18cd7482d00", {"code_string": "def sw_enter_active(self, sw):\n    return True\n        def format_time(self, time):\n            hrs = int(time / 3600)\n            mins = int((time -(hrs * 3600)) / 60)\n            secs = int(time -(mins * 60))\n            if hrs > 0:\n                return str(hrs) + \" Hrs \" + str(mins) + \" Mins\"\n            else:\n                return str(mins) + \" Mins \" + str(secs) + \" Secs\"\n", "code_toks_joined": "def sw_enter_active ( self , sw ) : <NEWLINE> <INDENT> return True <NEWLINE> <INDENT> def format_time ( self , time ) : <NEWLINE> <INDENT> hrs = int ( time / 3600 ) <NEWLINE> mins = int ( ( time - ( hrs * 3600 ) ) / 60 ) <NEWLINE> secs = int ( time - ( mins * 60 ) ) <NEWLINE> if hrs > 0 : <NEWLINE> <INDENT> return str ( hrs ) + <STRING> + str ( mins ) + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return str ( mins ) + <STRING> + str ( secs ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\" Hrs \"", "\" Mins\"", "\" Mins \"", "\" Secs\""]}, "err_obj": {"msg": "unexpected indent"}}], ["0f59bf3926789eabff130a02bf8465a1", {"code_string": "def flatten(l):\n    \"\"\"flatten an irregular list of lists\"\"\"\n    for el in l:\n        if isinstance(el, collections.Iterable) and not isinstance(el,\n            basestring):\n            for sub in flatten(el):\n            yield sub\n        else:\n            yield el\n", "code_toks_joined": "def flatten ( l ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for el in l : <NEWLINE> <INDENT> if isinstance ( el , collections . Iterable ) and not isinstance ( el , <NEWLINE> <INDENT> basestring ) : <NEWLINE> for sub in flatten ( el ) : <NEWLINE> yield sub <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> yield el <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"flatten an irregular list of lists\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["998a181f45a93b16fbee546a6c094d88", {"code_string": "def enumerate_dictioary():\n    x = {1: 'a', 2, 'z'}\n    for count, key in enumerate(x):\n        print(\"{}: {} -> {}\".format(count, key, x[key])\n", "code_toks_joined": "def enumerate_dictioary ( ) : <NEWLINE> <INDENT> x = { 1 : <STRING> , 2 , <STRING> } <NEWLINE> for count , key in enumerate ( x ) : <NEWLINE> <INDENT> print ( <STRING> . format ( count , key , x [ key ] ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'a'", "'z'", "\"{}: {} -> {}\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["d806827c924d7aba4c652728b382a0a4", {"code_string": "class AuthnQuery(Request):\n    msgtype = \"authn_query\"\n    def __init__(self, sec_context, receiver_addrs, attribute_converters,\n        timeslack = 0):\n        Request.__init__(self, sec_context, receiver_addrs,\n            attribute_converters, timeslack)\n            self.signature_check = self.sec.correctly_signed_authn_query\n    def attributes(self):\n        return to_local(self.attribute_converters, self.message)\n", "code_toks_joined": "class AuthnQuery ( Request ) : <NEWLINE> <INDENT> msgtype = <STRING> <NEWLINE> def __init__ ( self , sec_context , receiver_addrs , attribute_converters , <NEWLINE> <INDENT> timeslack = 0 ) : <NEWLINE> Request . __init__ ( self , sec_context , receiver_addrs , <NEWLINE> <INDENT> attribute_converters , timeslack ) <NEWLINE> self . signature_check = self . sec . correctly_signed_authn_query <NEWLINE> <DEDENT> <DEDENT> def attributes ( self ) : <NEWLINE> <INDENT> return to_local ( self . attribute_converters , self . message ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"authn_query\""]}, "err_obj": {"msg": "unexpected indent"}}], ["14be01121e9424cc861d92b99cab3c64", {"code_string": "def readCommand(self):\n    \"\"\"Processes the command used to run the game from command line\"\"\"\n        cmd = raw_input(\"Enter move >> \")\n        if cmd is None or not ' ' in cmd:\n            raise Exception(\"Improper format\")\n        command_string = cmd.split(' ')\n        src = command_string[0]\n        dst = command_string[1]\n        src_coordinates = ConvertToIndex(src)\n        dst_coordinates = ConvertToIndex(dst)\n        return src_coordinates, dst_coordinates\n", "code_toks_joined": "def readCommand ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> cmd = raw_input ( <STRING> ) <NEWLINE> if cmd is None or not <STRING> in cmd : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> command_string = cmd . split ( <STRING> ) <NEWLINE> src = command_string [ 0 ] <NEWLINE> dst = command_string [ 1 ] <NEWLINE> src_coordinates = ConvertToIndex ( src ) <NEWLINE> dst_coordinates = ConvertToIndex ( dst ) <NEWLINE> return src_coordinates , dst_coordinates <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Processes the command used to run the game from command line\"\"\"", "\"Enter move >> \"", "' '", "\"Improper format\"", "' '"]}, "err_obj": {"msg": "unexpected indent"}}], ["49fdd15a96c35e2df658cbc5002583dd", {"code_string": "def intersect(self, other):\n    \"\"\"Return a new RangeSet representing the intersection of this\"\"\"\n    out = []\n    z = 0\n    for p, d in heapq.merge(zip(self.data, itertools.cycle((+ 1, - 1))),\n        zip(other.data, itertools.cycle((+ 1, - 1)))):\n        if(z == 1 and d == 1) or(z == 2 and d == - 1):\n        out.append(p)\n        z += d\n    return RangeSet(data = out)\n", "code_toks_joined": "def intersect ( self , other ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> out = [ ] <NEWLINE> z = 0 <NEWLINE> for p , d in heapq . merge ( zip ( self . data , itertools . cycle ( ( + 1 , - 1 ) ) ) , <NEWLINE> <INDENT> zip ( other . data , itertools . cycle ( ( + 1 , - 1 ) ) ) ) : <NEWLINE> if ( z == 1 and d == 1 ) or ( z == 2 and d == - 1 ) : <NEWLINE> out . append ( p ) <NEWLINE> z += d <NEWLINE> <DEDENT> return RangeSet ( data = out ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return a new RangeSet representing the intersection of this\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["79eed7e7ae97c6ad9c0423a453585193", {"code_string": "def acc_get_authorized_emails(name_action, ** arguments):\n    \"\"\"Given the action and its arguments, try to retireve all the matching\"\"\"\n    roles = acc_find_possible_roles(name_action, always_add_superadmin = False, ** arguments)\n    authorized_emails = acc_get_roles_emails(roles)\n    for id_role in roles:\n        firerole = load_role_definition(id_role)\n        authorized_emails = authorized_emails.union(acc_firerole_extract_emails(firerole)))\n    return authorized_emails\n", "code_toks_joined": "def acc_get_authorized_emails ( name_action , ** arguments ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> roles = acc_find_possible_roles ( name_action , always_add_superadmin = False , ** arguments ) <NEWLINE> authorized_emails = acc_get_roles_emails ( roles ) <NEWLINE> for id_role in roles : <NEWLINE> <INDENT> firerole = load_role_definition ( id_role ) <NEWLINE> authorized_emails = authorized_emails . union ( acc_firerole_extract_emails ( firerole ) ) ) <NEWLINE> <DEDENT> return authorized_emails <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Given the action and its arguments, try to retireve all the matching\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["72d5f87f1426e37f85675e62276823b4", {"code_string": "def Update(self):\n    if self.current_is_plugin():\n        object = self.current_object()\n        for var in self.vars:\n        var(getattr(object, capwords(var.name))())\n", "code_toks_joined": "def Update ( self ) : <NEWLINE> <INDENT> if self . current_is_plugin ( ) : <NEWLINE> <INDENT> object = self . current_object ( ) <NEWLINE> for var in self . vars : <NEWLINE> var ( getattr ( object , capwords ( var . name ) ) ( ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["831f7576a19d9219dc1df1663bb8d65f", {"code_string": "def test_login_by_token(self):\n    resp = self.client.get(reverse('account_login'))\n    with patch('allauth.socialaccount.providers.facebook.views'\n        '.requests') as requests_mock:\n        mocks = [self.get_mocked_response().json()]\n        requests_mock.get.return_value.json = lambda: mocks.pop()\n        resp = self.client.post(reverse('facebook_login_by_token'),\n            data = {'access_token': 'dummy'})\n            self.assertRedirects(resp, 'http://testserver/accounts/profile/',\n            fetch_redirect_response = False)\n", "code_toks_joined": "def test_login_by_token ( self ) : <NEWLINE> <INDENT> resp = self . client . get ( reverse ( <STRING> ) ) <NEWLINE> with patch ( <STRING> <NEWLINE> <INDENT> <STRING> ) as requests_mock : <NEWLINE> mocks = [ self . get_mocked_response ( ) . json ( ) ] <NEWLINE> requests_mock . get . return_value . json = lambda : mocks . pop ( ) <NEWLINE> resp = self . client . post ( reverse ( <STRING> ) , <NEWLINE> <INDENT> data = { <STRING> : <STRING> } ) <NEWLINE> self . assertRedirects ( resp , <STRING> , <NEWLINE> fetch_redirect_response = False ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'account_login'", "'allauth.socialaccount.providers.facebook.views'", "'.requests'", "'facebook_login_by_token'", "'access_token'", "'dummy'", "'http://testserver/accounts/profile/'"]}, "err_obj": {"msg": "unexpected indent"}}], ["bf3e01fe16998137d021b56da8be2210", {"code_string": "def all_permutations(seq):\n    \"\"\" Borrowed from http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/252178 \"\"\"\n    \"\"\" Produces all permutations of the items of a list \"\"\"\n        if len(seq) <= 1:\n            yield seq\n        else:\n            for perm in all_permutations(seq[1: ]):\n                for i in range(len(perm) + 1):\n                    yield perm[: i] + seq[0: 1] + perm[i: ]\n", "code_toks_joined": "def all_permutations ( seq ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> <INDENT> if len ( seq ) <= 1 : <NEWLINE> <INDENT> yield seq <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for perm in all_permutations ( seq [ 1 : ] ) : <NEWLINE> <INDENT> for i in range ( len ( perm ) + 1 ) : <NEWLINE> <INDENT> yield perm [ : i ] + seq [ 0 : 1 ] + perm [ i : ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Borrowed from http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/252178 \"\"\"", "\"\"\" Produces all permutations of the items of a list \"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["8289fcfcec5234c8a18dccdd9d7d61e3", {"code_string": "def report():\n    dataset_id = request.args.get(\"id\", None)\n    if not dataset_id:\n        raise\n    dataset = Dataset.by_id(dataset_id)\n    if not dataset:\n        raise\n    lr = LoadReport(dataset)\n    return Response(lr.get_output()\n        mimetype = 'application/zip',\n        headers = {'Content-Disposition': 'attachment;filename=%s.zip' % dataset.name})\n", "code_toks_joined": "def report ( ) : <NEWLINE> <INDENT> dataset_id = request . args . get ( <STRING> , None ) <NEWLINE> if not dataset_id : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> dataset = Dataset . by_id ( dataset_id ) <NEWLINE> if not dataset : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> lr = LoadReport ( dataset ) <NEWLINE> return Response ( lr . get_output ( ) <NEWLINE> <INDENT> mimetype = <STRING> , <NEWLINE> headers = { <STRING> : <STRING> % dataset . name } ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"id\"", "'application/zip'", "'Content-Disposition'", "'attachment;filename=%s.zip'"]}, "err_obj": {"msg": "invalid syntax"}}], ["87a5f1d57d1fc58c716b83b72401bb19", {"code_string": "class Ui_SnapshotForm(object):\n    def setupUi(self, SnapshotForm):\n        SnapshotForm.setObjectName(\"SnapshotForm\")\n        SnapshotForm.resize(500, 316)\n        SnapshotForm.setMinimumSize(QtCore.QSize(500, 0))\n        SnapshotForm.setFocusPolicy(QtCore.Qt.TabFocus)\n        self.verticalLayout = QtGui.QVBoxLayout(SnapshotForm)\n        self.verticalLayout.setObjectName(\"verticalLayout\")\n        self.page_stack = QtGui.QStackedWidget(SnapshotForm)\n        self.page_stack.setObjectName(\"page_stack\")\n        self.snapshot_page = QtGui.QWidget()\n        self.snapshot_page.setObjectName(\"snapshot_page\")\n        self.verticalLayout_2 = QtGui.QVBoxLayout(self.snapshot_page)\n        self.verticalLayout_2.setContentsMargins(0, 0, 0, 0)\n        self.verticalLayout_2.setObjectName(\"verticalLayout_2\")\n        self.header_frame = QtGui.QFrame(self.snapshot_page)\n        self.header_frame.setStyleSheet(\"#header_frame {\\n\"\n", "code_toks_joined": "class Ui_SnapshotForm ( object ) : <NEWLINE> <INDENT> def setupUi ( self , SnapshotForm ) : <NEWLINE> <INDENT> SnapshotForm . setObjectName ( <STRING> ) <NEWLINE> SnapshotForm . resize ( 500 , 316 ) <NEWLINE> SnapshotForm . setMinimumSize ( QtCore . QSize ( 500 , 0 ) ) <NEWLINE> SnapshotForm . setFocusPolicy ( QtCore . Qt . TabFocus ) <NEWLINE> self . verticalLayout = QtGui . QVBoxLayout ( SnapshotForm ) <NEWLINE> self . verticalLayout . setObjectName ( <STRING> ) <NEWLINE> self . page_stack = QtGui . QStackedWidget ( SnapshotForm ) <NEWLINE> self . page_stack . setObjectName ( <STRING> ) <NEWLINE> self . snapshot_page = QtGui . QWidget ( ) <NEWLINE> self . snapshot_page . setObjectName ( <STRING> ) <NEWLINE> self . verticalLayout_2 = QtGui . QVBoxLayout ( self . snapshot_page ) <NEWLINE> self . verticalLayout_2 . setContentsMargins ( 0 , 0 , 0 , 0 ) <NEWLINE> self . verticalLayout_2 . setObjectName ( <STRING> ) <NEWLINE> self . header_frame = QtGui . QFrame ( self . snapshot_page ) <NEWLINE> self . header_frame . setStyleSheet ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"SnapshotForm\"", "\"verticalLayout\"", "\"page_stack\"", "\"snapshot_page\"", "\"verticalLayout_2\"", "\"#header_frame {\\n\""]}, "window_span": [173, 178], "err_obj": {"msg": "unbalanced (){}[]"}}], ["8af34243c291a6b373291870de177e6e", {"code_string": "def test_bad_modules(self):\n    '''Test SystemError is raised for misbehaving extensions'''\n    for name_base in[\n        'bad_slot_large',\n        'bad_slot_negative',\n        'create_int_with_state',\n        'negative_size',\n        'export_null',\n        'export_uninitialized',\n        'export_raise',\n        'export_unreported_exception',\n        'create_null',\n        'create_raise',\n        'create_unreported_exception',\n        'nonmodule_with_exec_slots',\n        'exec_err',\n        'exec_raise',\n        'exec_unreported_exception',\n        ]:\n        with self.subTest(name_base):\n        name = self.name + '_' + name_base\n        with self.assertRaises(SystemError):\n            self.load_module_by_name(name)\n", "code_toks_joined": "def test_bad_modules ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for name_base in [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> ] : <NEWLINE> with self . subTest ( name_base ) : <NEWLINE> name = self . name + <STRING> + name_base <NEWLINE> with self . assertRaises ( SystemError ) : <NEWLINE> <INDENT> self . load_module_by_name ( name ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Test SystemError is raised for misbehaving extensions'''", "'bad_slot_large'", "'bad_slot_negative'", "'create_int_with_state'", "'negative_size'", "'export_null'", "'export_uninitialized'", "'export_raise'", "'export_unreported_exception'", "'create_null'", "'create_raise'", "'create_unreported_exception'", "'nonmodule_with_exec_slots'", "'exec_err'", "'exec_raise'", "'exec_unreported_exception'", "'_'"]}, "err_obj": {"msg": "expected an indented block"}}], ["28414ca4c887ffa50e6c727841912ca3", {"code_string": "def main():\n    if os.path.isdir(target):\n        dir_listing = os.listdir(target)\n        for item in dir_listing:\n            print('\\t' + item)\n        backups_listing = sorted(filter(is_a_backup, dir_listing),\n            reverse = True)\n        for item in backups_listing:\n            rename(item)\n            ))\n", "code_toks_joined": "def main ( ) : <NEWLINE> <INDENT> if os . path . isdir ( target ) : <NEWLINE> <INDENT> dir_listing = os . listdir ( target ) <NEWLINE> for item in dir_listing : <NEWLINE> <INDENT> print ( <STRING> + item ) <NEWLINE> <DEDENT> backups_listing = sorted ( filter ( is_a_backup , dir_listing ) , <NEWLINE> <INDENT> reverse = True ) <NEWLINE> <DEDENT> for item in backups_listing : <NEWLINE> <INDENT> rename ( item ) <NEWLINE> ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'\\t'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["1d7df3fdacc6feab8f567bab752bae50", {"code_string": "def doTest(self, num, default = ''):\n    file = mkpath('query%d.sql' % num)\n        psql.runfile(file, default)\n    self.checkResult(file)\n", "code_toks_joined": "def doTest ( self , num , default = <STRING> ) : <NEWLINE> <INDENT> file = mkpath ( <STRING> % num ) <NEWLINE> <INDENT> psql . runfile ( file , default ) <NEWLINE> <DEDENT> self . checkResult ( file ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "'query%d.sql'"]}, "err_obj": {"msg": "unexpected indent"}}], ["0785cdd1a18870d27a73c826cb59c4eb", {"code_string": "def __init__(self, cm_host, cm_cluster_name, username, password):\n    self.cm_api = ApiResource(cm_host, username = username, password = password)\n    self.hosts = dict()\n    self.services = list()\n    self.cluster = self.cm_api.get_cluster(cm_cluster_name)\n    if self.cluster is None:\n        raise RuntimeError, 'Cluster name \"%s\" not found' % cm_cluster_name\n    self.__load_hosts()\n    self.__impala_service = ImpalaService(self)\n", "code_toks_joined": "def __init__ ( self , cm_host , cm_cluster_name , username , password ) : <NEWLINE> <INDENT> self . cm_api = ApiResource ( cm_host , username = username , password = password ) <NEWLINE> self . hosts = dict ( ) <NEWLINE> self . services = list ( ) <NEWLINE> self . cluster = self . cm_api . get_cluster ( cm_cluster_name ) <NEWLINE> if self . cluster is None : <NEWLINE> <INDENT> raise RuntimeError , <STRING> % cm_cluster_name <NEWLINE> <DEDENT> self . __load_hosts ( ) <NEWLINE> self . __impala_service = ImpalaService ( self ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Cluster name \"%s\" not found'"]}, "err_obj": {"msg": "invalid syntax"}}], ["e11c1df35269fb918db0e7760a1d079f", {"code_string": "def build(self):\n    \"\"\"Build the process tree from the list of top samples.\"\"\"\n    self.process_tree = []\n    for proc in self.process_list:\n        if not proc.parent:\n            self.process_tree.append(proc)\n            else:\n            proc.parent.child_list.append(proc)\n", "code_toks_joined": "def build ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . process_tree = [ ] <NEWLINE> for proc in self . process_list : <NEWLINE> <INDENT> if not proc . parent : <NEWLINE> <INDENT> self . process_tree . append ( proc ) <NEWLINE> else : <NEWLINE> proc . parent . child_list . append ( proc ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Build the process tree from the list of top samples.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["b4eac26546ce494dfccf49d474a6ab66", {"code_string": "def addAtomtoHisto(self, atom, addvalue):\n    distance = atom[4]\n    value = int(self.histobins *(float(distance) - float(self.histomin)) /(float(self.histomax - self.histomin)))\n    if value < len(self.histo):\n        self.histo[value] += addvalue\n        self.count[value] += 1\n        else:\n        print(\"weird value\")\n        print(value)\n        print(distance)\n", "code_toks_joined": "def addAtomtoHisto ( self , atom , addvalue ) : <NEWLINE> <INDENT> distance = atom [ 4 ] <NEWLINE> value = int ( self . histobins * ( float ( distance ) - float ( self . histomin ) ) / ( float ( self . histomax - self . histomin ) ) ) <NEWLINE> if value < len ( self . histo ) : <NEWLINE> <INDENT> self . histo [ value ] += addvalue <NEWLINE> self . count [ value ] += 1 <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> print ( value ) <NEWLINE> print ( distance ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"weird value\""]}, "err_obj": {"msg": "invalid syntax"}}], ["a3060a691b08243a322d6e83138160b5", {"code_string": "def retranslateUi2(self, Wizard):\n    _translate = QtCore.QCoreApplication.translate\n    Wizard.setWindowTitle(_translate(\"Wizard\", \"           Ida Pro Plugin Wizard\"))\n    self.textBrowser_2.setHtml(_translate(\"Wizard\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def retranslateUi2 ( self , Wizard ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> Wizard . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . textBrowser_2 . setHtml ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Wizard\"", "\"           Ida Pro Plugin Wizard\"", "\"Wizard\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["9d341e064c45342ff54d54fa921e9ab7", {"code_string": "def _check_for_duplicate_rules(self, context, security_group_rules):\n    for i in security_group_rules:\n        found_self = False\n        for j in security_group_rules:\n            if self._rules_equal(i['security_group_rule'],\n                j['security_group_rule']):\n                if found_self:\n                raise ext_sg.DuplicateSecurityGroupRuleInPost(rule = i)\n                found_self = True\n        self._check_for_duplicate_rules_in_db(context, i)\n", "code_toks_joined": "def _check_for_duplicate_rules ( self , context , security_group_rules ) : <NEWLINE> <INDENT> for i in security_group_rules : <NEWLINE> <INDENT> found_self = False <NEWLINE> for j in security_group_rules : <NEWLINE> <INDENT> if self . _rules_equal ( i [ <STRING> ] , <NEWLINE> <INDENT> j [ <STRING> ] ) : <NEWLINE> if found_self : <NEWLINE> raise ext_sg . DuplicateSecurityGroupRuleInPost ( rule = i ) <NEWLINE> found_self = True <NEWLINE> <DEDENT> <DEDENT> self . _check_for_duplicate_rules_in_db ( context , i ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'security_group_rule'", "'security_group_rule'"]}, "err_obj": {"msg": "expected an indented block"}}], ["07bcfad098e10d19b2e53a3f6f93bcc2", {"code_string": "class HistogramSampled4dRGBA(HistogramRGB):\n    u\"\"\"An histogram sampled image descriptor\"\"\"\n    name = \"histogram Sampled 4d RGBA\"\n    description = __doc__\n    def get(self, image):\n        b = [0, 64, 128, 192, 255]\n        r, g, b, a = HistogramRGB.get(self, image, bins = b)\n        result = [h[0] for h in r, g, b, a]\n        if self.mass_normed:\n            nb_pixels = image.width * image.height * 1.0\n            result = [h / nb_pixels for h in result]\n        return result\n", "code_toks_joined": "class HistogramSampled4dRGBA ( HistogramRGB ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> name = <STRING> <NEWLINE> description = __doc__ <NEWLINE> def get ( self , image ) : <NEWLINE> <INDENT> b = [ 0 , 64 , 128 , 192 , 255 ] <NEWLINE> r , g , b , a = HistogramRGB . get ( self , image , bins = b ) <NEWLINE> result = [ h [ 0 ] for h in r , g , b , a ] <NEWLINE> if self . mass_normed : <NEWLINE> <INDENT> nb_pixels = image . width * image . height * 1.0 <NEWLINE> result = [ h / nb_pixels for h in result ] <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["u\"\"\"An histogram sampled image descriptor\"\"\"", "\"histogram Sampled 4d RGBA\""]}, "err_obj": {"msg": "invalid syntax"}}], ["11bdf230629b6af0dfc8714a5c9a01d6", {"code_string": "def course_config_advanced_page(request, org, course, name):\n    \"\"\"Send models and views as well as html for editing the advanced course settings to the client.\"\"\"\n    location = get_location_and_verify_access(request, org, course, name)\n    course_module = modulestore().get_item(location)\n    return render_to_response('settings_advanced.html', {\n        'context_course': course_module,\n        'course_location': location,\n        'advanced_dict': json.dumps(CourseMetadata.fetch(location))),\n    })\n", "code_toks_joined": "def course_config_advanced_page ( request , org , course , name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> location = get_location_and_verify_access ( request , org , course , name ) <NEWLINE> course_module = modulestore ( ) . get_item ( location ) <NEWLINE> return render_to_response ( <STRING> , { <NEWLINE> <INDENT> <STRING> : course_module , <NEWLINE> <STRING> : location , <NEWLINE> <STRING> : json . dumps ( CourseMetadata . fetch ( location ) ) ) , <NEWLINE> <DEDENT> } ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Send models and views as well as html for editing the advanced course settings to the client.\"\"\"", "'settings_advanced.html'", "'context_course'", "'course_location'", "'advanced_dict'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c86d04be451ee867e24d07ff1b916ba5", {"code_string": "def processTable(tName):\n    global cursor\n    colNames = getColumns(tName)\n    cursor.execute(\"SELECT * FROM \" + tName)\n    result = cursor.fetchall()\n    print(\"[\")\n    for r in result:\n        print(\"{\",\n        for index, c in enumerate(r):\n            print(colNames[index], )\n            print(u\":\\\"\" + unicode(c) + u\"\\\",\", )\n        print(\"},\")\n    print(\"]\")\n", "code_toks_joined": "def processTable ( tName ) : <NEWLINE> <INDENT> global cursor <NEWLINE> colNames = getColumns ( tName ) <NEWLINE> cursor . execute ( <STRING> + tName ) <NEWLINE> result = cursor . fetchall ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> for r in result : <NEWLINE> <INDENT> print ( <STRING> , <NEWLINE> for index , c in enumerate ( r ) : <NEWLINE> <INDENT> print ( colNames [ index ] , ) <NEWLINE> print ( <STRING> + unicode ( c ) + <STRING> , ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"SELECT * FROM \"", "\"[\"", "\"{\"", "u\":\\\"\"", "u\"\\\",\"", "\"},\"", "\"]\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["03128336721cdad0f585066acaaaf69b", {"code_string": "def KLabelFold(labels, n_folds = 3, shuffle = False, random_state = None):\n    kfold = KFold(labels.nunique(), n_folds = n_folds, shuffle = shuffle, random_state = random_state)\n    unique_labels = labels.unique()\n    return PredefinedSplit(pd.concat(map(lambda(i, x): labels.isin(x) * i,\n        enumerate([unique_labels[mask[1]] for mask in kfold])\n        ), axis = 1).sum(axis = 1))\n", "code_toks_joined": "def KLabelFold ( labels , n_folds = 3 , shuffle = False , random_state = None ) : <NEWLINE> <INDENT> kfold = KFold ( labels . nunique ( ) , n_folds = n_folds , shuffle = shuffle , random_state = random_state ) <NEWLINE> unique_labels = labels . unique ( ) <NEWLINE> return PredefinedSplit ( pd . concat ( map ( lambda ( i , x ) : labels . isin ( x ) * i , <NEWLINE> <INDENT> enumerate ( [ unique_labels [ mask [ 1 ] ] for mask in kfold ] ) <NEWLINE> ) , axis = 1 ) . sum ( axis = 1 ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["b4617c8b581f2529bc1f68bbe822af76", {"code_string": "def _WaitForThermalThrottlingIfNeeded(platform):\n    if not platform.CanMonitorThermalThrottling():\n        return\n    thermal_throttling_retry = 0\n    while(platform.IsThermallyThrottled() and\n        thermal_throttling_retry < 3):\n        logging.warning('Thermally throttled, waiting (%d)...',\n            thermal_throttling_retry)\n            thermal_throttling_retry += 1\n            time.sleep(thermal_throttling_retry * 2)\n    if thermal_throttling_retry and platform.IsThermallyThrottled():\n        logging.warning('Device is thermally throttled before running '\n            'performance tests, results will vary.')\n", "code_toks_joined": "def _WaitForThermalThrottlingIfNeeded ( platform ) : <NEWLINE> <INDENT> if not platform . CanMonitorThermalThrottling ( ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> thermal_throttling_retry = 0 <NEWLINE> while ( platform . IsThermallyThrottled ( ) and <NEWLINE> <INDENT> thermal_throttling_retry < 3 ) : <NEWLINE> logging . warning ( <STRING> , <NEWLINE> <INDENT> thermal_throttling_retry ) <NEWLINE> thermal_throttling_retry += 1 <NEWLINE> time . sleep ( thermal_throttling_retry * 2 ) <NEWLINE> <DEDENT> <DEDENT> if thermal_throttling_retry and platform . IsThermallyThrottled ( ) : <NEWLINE> <INDENT> logging . warning ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Thermally throttled, waiting (%d)...'", "'Device is thermally throttled before running '", "'performance tests, results will vary.'"]}, "err_obj": {"msg": "unexpected indent"}}], ["6b394bfd1a40f75dd667202bcfe3dcac", {"code_string": "def test20_bad_response_codes(self):\n    \"\"\"Response codes.\"\"\"\n    for(path, code) in[(\"id/b\", 400),\n        (\"id/b/c\", 400),\n        (\"id/b/c/d\", 400),\n        (\"id/full/full/0/default.jpg/extra\", 400)]:\n        got_code = None\n        try:\n        IIIFRequest(api_version = '2.0').split_url(path)\n        except IIIFError as e:\n        got_code = e.code\n        self.assertEqual(got_code, code,\n        \"Bad code %s, expected %d, for path %s\" %\n        (str(got_code), code, path))\n", "code_toks_joined": "def test20_bad_response_codes ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for ( path , code ) in [ ( <STRING> , 400 ) , <NEWLINE> <INDENT> ( <STRING> , 400 ) , <NEWLINE> ( <STRING> , 400 ) , <NEWLINE> ( <STRING> , 400 ) ] : <NEWLINE> got_code = None <NEWLINE> try : <NEWLINE> IIIFRequest ( api_version = <STRING> ) . split_url ( path ) <NEWLINE> except IIIFError as e : <NEWLINE> got_code = e . code <NEWLINE> self . assertEqual ( got_code , code , <NEWLINE> <STRING> % <NEWLINE> ( str ( got_code ) , code , path ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Response codes.\"\"\"", "\"id/b\"", "\"id/b/c\"", "\"id/b/c/d\"", "\"id/full/full/0/default.jpg/extra\"", "'2.0'", "\"Bad code %s, expected %d, for path %s\""]}, "err_obj": {"msg": "expected an indented block"}}], ["350915b87e97172a81fdf2cc8ce5790f", {"code_string": "def _reordered_platform(value):\n    ''' reordered if is not a supported platform '''\n    if value == 'None' or value == '':\n        return False\n    for prefix in(\n        'linux',\n        'win32',\n        'cygwin',\n        'darwin',\n        'os2',\n        'os2emx',\n        'riscos',\n        'atheos',\n        'freebsd',\n        'openbsd',\n        'netbsd',\n        ):\n        if value.startswith(prefix):\n        return False\n    return True\n", "code_toks_joined": "def _reordered_platform ( value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if value == <STRING> or value == <STRING> : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for prefix in ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> ) : <NEWLINE> if value . startswith ( prefix ) : <NEWLINE> return False <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''' reordered if is not a supported platform '''", "'None'", "''", "'linux'", "'win32'", "'cygwin'", "'darwin'", "'os2'", "'os2emx'", "'riscos'", "'atheos'", "'freebsd'", "'openbsd'", "'netbsd'"]}, "err_obj": {"msg": "expected an indented block"}}], ["86e4645ad53008ec547fbe969a50e307", {"code_string": "def read_inventory(self, f, revision_id = None):\n    try:\n        try:\n            return self._unpack_inventory(self._read_element(f),\n                revision_id = None)\n        finally:\n            f.close()\n    except ParseError, e:\n        raise errors.UnexpectedInventoryFormat(e)\n", "code_toks_joined": "def read_inventory ( self , f , revision_id = None ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return self . _unpack_inventory ( self . _read_element ( f ) , <NEWLINE> <INDENT> revision_id = None ) <NEWLINE> <DEDENT> <DEDENT> finally : <NEWLINE> <INDENT> f . close ( ) <NEWLINE> <DEDENT> <DEDENT> except ParseError , e : <NEWLINE> <INDENT> raise errors . UnexpectedInventoryFormat ( e ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["e0d9590f872e21055502a5991c46c77f", {"code_string": "def leftOuterJoin(self, other, left_keys = None, right_keys = None):\n    o = other.indexBy(right_keys).collectAsMap()\n    r = self.indexBy(left_keys).map(lambda(k, v): (k, (v, o.get(k))))\n    r.mem +=(sys.getsizeof(o) * 10) >> 20\n    return r\n", "code_toks_joined": "def leftOuterJoin ( self , other , left_keys = None , right_keys = None ) : <NEWLINE> <INDENT> o = other . indexBy ( right_keys ) . collectAsMap ( ) <NEWLINE> r = self . indexBy ( left_keys ) . map ( lambda ( k , v ) : ( k , ( v , o . get ( k ) ) ) ) <NEWLINE> r . mem += ( sys . getsizeof ( o ) * 10 ) >> 20 <NEWLINE> return r <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["d0e2cc8ca4bd6885fce7870a4242f99b", {"code_string": "def test34(self):\n    H = MutNodeSet\n    e1 = []\n    class X(H):\n        def extend(self, y):\n        for e in y:\n            self.append(e)\n    s = X()\n    assert e1 not in s\n    s.extend([e1])\n    assert e1 in s\n", "code_toks_joined": "def test34 ( self ) : <NEWLINE> <INDENT> H = MutNodeSet <NEWLINE> e1 = [ ] <NEWLINE> class X ( H ) : <NEWLINE> <INDENT> def extend ( self , y ) : <NEWLINE> for e in y : <NEWLINE> <INDENT> self . append ( e ) <NEWLINE> <DEDENT> <DEDENT> s = X ( ) <NEWLINE> assert e1 not in s <NEWLINE> s . extend ( [ e1 ] ) <NEWLINE> assert e1 in s <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["a93d35a1190eee53128636e92e492022", {"code_string": "def generate_modes():\n    for align_desc, align in[('left', pango.ALIGN_LEFT),\n        ('center', pango.ALIGN_CENTER), ('right', pango.ALIGN_RIGHT)]:\n        for extent_desc, extentindex in[('logical', 1), ('ink', 0)]:\n        for name in['line', 'run', 'cluster', 'char']:\n            if name == 'char' and extent_desc == 'ink':\n                continue\n            desc = '%s %s %s' %(align_desc, extent_desc, name)\n            yield extentindex, name, align, desc\n", "code_toks_joined": "def generate_modes ( ) : <NEWLINE> <INDENT> for align_desc , align in [ ( <STRING> , pango . ALIGN_LEFT ) , <NEWLINE> <INDENT> ( <STRING> , pango . ALIGN_CENTER ) , ( <STRING> , pango . ALIGN_RIGHT ) ] : <NEWLINE> for extent_desc , extentindex in [ ( <STRING> , 1 ) , ( <STRING> , 0 ) ] : <NEWLINE> for name in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> if name == <STRING> and extent_desc == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> desc = <STRING> % ( align_desc , extent_desc , name ) <NEWLINE> yield extentindex , name , align , desc <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'left'", "'center'", "'right'", "'logical'", "'ink'", "'line'", "'run'", "'cluster'", "'char'", "'char'", "'ink'", "'%s %s %s'"]}, "err_obj": {"msg": "expected an indented block"}}], ["c2e63a1f1b6e1cfcb1e408bba90a903f", {"code_string": "def __init__(self):\n    oparser = OptionParser()\n    oparser.add_option('-d', '--dir', dest = 'dir'\n        help = 'input directory (mandatory)')\n    (self.opts, self.args) = oparser.parse_args()\n    if not self.opts.dir:\n        oparser.print_help()\n        sys.exit(- 1)\n    self.loc = 0\n    self.checkFiles()\n", "code_toks_joined": "def __init__ ( self ) : <NEWLINE> <INDENT> oparser = OptionParser ( ) <NEWLINE> oparser . add_option ( <STRING> , <STRING> , dest = <STRING> <NEWLINE> <INDENT> help = <STRING> ) <NEWLINE> <DEDENT> ( self . opts , self . args ) = oparser . parse_args ( ) <NEWLINE> if not self . opts . dir : <NEWLINE> <INDENT> oparser . print_help ( ) <NEWLINE> sys . exit ( - 1 ) <NEWLINE> <DEDENT> self . loc = 0 <NEWLINE> self . checkFiles ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'-d'", "'--dir'", "'dir'", "'input directory (mandatory)'"]}, "err_obj": {"msg": "invalid syntax"}}], ["16d4b5f907743351fd2e837a7a5fc2c4", {"code_string": "def __getMovieTitle(sHtmlContent):\n    sPattern = '<h1 style=\"font-size:18px;\">(.*?)<img'\n    oParser = cParser()\n    aResult = oParser.parse(sHtmlContent, sPattern)\n    if(aResult[0] == True):\n    return str(aResult[1][0]).strip()\n    return False\n", "code_toks_joined": "def __getMovieTitle ( sHtmlContent ) : <NEWLINE> <INDENT> sPattern = <STRING> <NEWLINE> oParser = cParser ( ) <NEWLINE> aResult = oParser . parse ( sHtmlContent , sPattern ) <NEWLINE> if ( aResult [ 0 ] == True ) : <NEWLINE> return str ( aResult [ 1 ] [ 0 ] ) . strip ( ) <NEWLINE> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'<h1 style=\"font-size:18px;\">(.*?)<img'"]}, "err_obj": {"msg": "expected an indented block"}}], ["6f84ea28d07bba0f6f7fab25cc593920", {"code_string": "def _item_key_to_dict(self, key):\n    if utils.is_dict_like(key):\n        return key\n    else:\n        key = indexing.expanded_indexer(key, self.ndim)\n        return dict(zip(self.dims, key)\n", "code_toks_joined": "def _item_key_to_dict ( self , key ) : <NEWLINE> <INDENT> if utils . is_dict_like ( key ) : <NEWLINE> <INDENT> return key <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> key = indexing . expanded_indexer ( key , self . ndim ) <NEWLINE> return dict ( zip ( self . dims , key ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["1132016f1ddf2162f11c99eb65dd40dd", {"code_string": "def parse_DL(self, indent):\n    i = 0\n    while self.parse_DI_helper(indent): i = i + 1\n    if i == 0:\n        print \"Error\", sys.exit(1)\n    self.reduce(DL, i, indent)\n", "code_toks_joined": "def parse_DL ( self , indent ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> while self . parse_DI_helper ( indent ) : i = i + 1 <NEWLINE> if i == 0 : <NEWLINE> <INDENT> print <STRING> , sys . exit ( 1 ) <NEWLINE> <DEDENT> self . reduce ( DL , i , indent ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Error\""]}, "err_obj": {"msg": "invalid syntax"}}], ["20b70b8cc2012ebf4e867b2ab639d310", {"code_string": "class MyModel(gtkmvc3.Model):\n    name = \"Roberto\"\n    age = 0\n    __observables__ = (\"name\", \"age\")\n    def show(self): print \"MyModel: name=\", self.name, \"age=\", self.age\n    pass\n", "code_toks_joined": "class MyModel ( gtkmvc3 . Model ) : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> age = 0 <NEWLINE> __observables__ = ( <STRING> , <STRING> ) <NEWLINE> def show ( self ) : print <STRING> , self . name , <STRING> , self . age <NEWLINE> pass <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Roberto\"", "\"name\"", "\"age\"", "\"MyModel: name=\"", "\"age=\""]}, "err_obj": {"msg": "invalid syntax"}}], ["071847ed30a8769820cc1c98f1f10021", {"code_string": "def signal_handler(signal, frame):\n    print('You pressed Ctrl+C!')\n    if gaugeSocket:\n    print(' sending termination to enymate')\n    gaugeSocket.send(str(\"\\xF6\"))\n    gaugeSocket.close()\n    sys.exit(0)\n", "code_toks_joined": "def signal_handler ( signal , frame ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> if gaugeSocket : <NEWLINE> print ( <STRING> ) <NEWLINE> gaugeSocket . send ( str ( <STRING> ) ) <NEWLINE> gaugeSocket . close ( ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'You pressed Ctrl+C!'", "' sending termination to enymate'", "\"\\xF6\""]}, "err_obj": {"msg": "expected an indented block"}}], ["9504987cb6dcd2a8bd6b8ee1d647af37", {"code_string": "def member_functioneelbeheerder_group(user):\n    \"\"\"Return true is the user is a member of\"\"\"\n    functioneelbeheerder_groups = user.user_group_memberships.filter(\n    name__contains = 'functioneel beheerder')\n    if functioneelbeheerder_groups.exists():\n    return True\n    return False\n", "code_toks_joined": "def member_functioneelbeheerder_group ( user ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> functioneelbeheerder_groups = user . user_group_memberships . filter ( <NEWLINE> name__contains = <STRING> ) <NEWLINE> if functioneelbeheerder_groups . exists ( ) : <NEWLINE> return True <NEWLINE> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return true is the user is a member of\"\"\"", "'functioneel beheerder'"]}, "err_obj": {"msg": "expected an indented block"}}], ["705414a127846cb3f8542fcc07585423", {"code_string": "class CppFileTest(unittest2.TestCase):\n    def test(self):\n    comment_counter = __test_extension__(\"/resources/commented_file.cpp\", \"cpp\")\n    self.assertEqual(comment_counter, 25)\n", "code_toks_joined": "class CppFileTest ( unittest2 . TestCase ) : <NEWLINE> <INDENT> def test ( self ) : <NEWLINE> comment_counter = __test_extension__ ( <STRING> , <STRING> ) <NEWLINE> self . assertEqual ( comment_counter , 25 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"/resources/commented_file.cpp\"", "\"cpp\""]}, "err_obj": {"msg": "expected an indented block"}}], ["cf8c797d4e0121719d27b711de8eaa64", {"code_string": "class Address(Base):\n    __tablename__ = 'addresses'\n    id = Column(Integer, primary_key = True)\n    email = Column(String(60))\n    worker_id = Column(Integer, ForeignKey('workers.id')\n    user = relationship('User', back_populates = 'addresses')\n", "code_toks_joined": "class Address ( Base ) : <NEWLINE> <INDENT> __tablename__ = <STRING> <NEWLINE> id = Column ( Integer , primary_key = True ) <NEWLINE> email = Column ( String ( 60 ) ) <NEWLINE> worker_id = Column ( Integer , ForeignKey ( <STRING> ) <NEWLINE> user = relationship ( <STRING> , back_populates = <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'addresses'", "'workers.id'", "'User'", "'addresses'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c62632c92fb1526412a6111ded663bf7", {"code_string": "def retranslateUi(self, Dialog):\n    Dialog.setWindowTitle(_(\"Add custom news source\"))\n    self.groupBox.setTitle(_(\"Available user recipes\"))\n    self.add_profile_button.setText(_(\"Add/Update &recipe\"))\n    self.remove_profile_button.setText(_(\"&Remove recipe\"))\n    self.share_button.setText(_(\"&Share recipe\"))\n    self.show_recipe_files_button.setText(_(\"S&how recipe files\"))\n    self.builtin_recipe_button.setText(_(\"Customize &builtin recipe\"))\n    self.load_button.setText(_(\"&Load recipe from file\"))\n    self.toggle_mode_button.setText(_(\"Switch to Advanced mode\"))\n    self.label.setText(_(\"<html><head><meta name=\\\"qrichtext\\\" content=\\\"1\\\" /><style type=\\\"text/css\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , Dialog ) : <NEWLINE> <INDENT> Dialog . setWindowTitle ( _ ( <STRING> ) ) <NEWLINE> self . groupBox . setTitle ( _ ( <STRING> ) ) <NEWLINE> self . add_profile_button . setText ( _ ( <STRING> ) ) <NEWLINE> self . remove_profile_button . setText ( _ ( <STRING> ) ) <NEWLINE> self . share_button . setText ( _ ( <STRING> ) ) <NEWLINE> self . show_recipe_files_button . setText ( _ ( <STRING> ) ) <NEWLINE> self . builtin_recipe_button . setText ( _ ( <STRING> ) ) <NEWLINE> self . load_button . setText ( _ ( <STRING> ) ) <NEWLINE> self . toggle_mode_button . setText ( _ ( <STRING> ) ) <NEWLINE> self . label . setText ( _ ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Add custom news source\"", "\"Available user recipes\"", "\"Add/Update &recipe\"", "\"&Remove recipe\"", "\"&Share recipe\"", "\"S&how recipe files\"", "\"Customize &builtin recipe\"", "\"&Load recipe from file\"", "\"Switch to Advanced mode\"", "\"<html><head><meta name=\\\"qrichtext\\\" content=\\\"1\\\" /><style type=\\\"text/css\\\">\\n\""]}, "window_span": [121, 127], "err_obj": {"msg": "unbalanced (){}[]"}}], ["f3950235a973f37a581eae0b4f927624", {"code_string": "def matrix_multiply(A, B):\n    C = [[0] * len(B[0]) for i in range(len(A)]\n    for i in range(A):\n        for j in range(len(B[0]):\n            for k in range(len(A)):\n                C[i][j] += A[i][k] * B[k][j]\n", "code_toks_joined": "def matrix_multiply ( A , B ) : <NEWLINE> <INDENT> C = [ [ 0 ] * len ( B [ 0 ] ) for i in range ( len ( A ) ] <NEWLINE> for i in range ( A ) : <NEWLINE> <INDENT> for j in range ( len ( B [ 0 ] ) : <NEWLINE> <INDENT> for k in range ( len ( A ) ) : <NEWLINE> <INDENT> C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["956dd9a31d787fd8166878af8cc102e0", {"code_string": "def splitChars(s):\n    temp = [s[i] for i in range(0, len(s))]\n    try:\n    idx = temp.index(\":\")\n    temp[idx] = \"colon\"\n    except:\n    pass\n    return temp\n", "code_toks_joined": "def splitChars ( s ) : <NEWLINE> <INDENT> temp = [ s [ i ] for i in range ( 0 , len ( s ) ) ] <NEWLINE> try : <NEWLINE> idx = temp . index ( <STRING> ) <NEWLINE> temp [ idx ] = <STRING> <NEWLINE> except : <NEWLINE> pass <NEWLINE> return temp <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\":\"", "\"colon\""]}, "err_obj": {"msg": "expected an indented block"}}], ["b01d3cfeedd6863cc7cf2097972cf8d6", {"code_string": "def do_set(self, line):\n    \"\"\"Set an attribute of an mbean\"\"\"\n        if JmxCmd.jmxClient:\n            JmxCmd.setArgs = line.split(' ')\n            try:\n                if len(JmxCmd.setArgs) < 2:\n                    raise SetAttributeError\n                JmxCmd.jmxClient.set(JmxCmd.setArgs[0], JmxCmd.setArgs[1])\n            except SetAttributeError:\n                print(\"Error: failed to set attrbute value.\")\n", "code_toks_joined": "def do_set ( self , line ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> if JmxCmd . jmxClient : <NEWLINE> <INDENT> JmxCmd . setArgs = line . split ( <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> if len ( JmxCmd . setArgs ) < 2 : <NEWLINE> <INDENT> raise SetAttributeError <NEWLINE> <DEDENT> JmxCmd . jmxClient . set ( JmxCmd . setArgs [ 0 ] , JmxCmd . setArgs [ 1 ] ) <NEWLINE> <DEDENT> except SetAttributeError : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Set an attribute of an mbean\"\"\"", "' '", "\"Error: failed to set attrbute value.\""]}, "err_obj": {"msg": "unexpected indent"}}], ["22e54aa0b49bbff73a0da195acc5d177", {"code_string": "def make_runtime_storage(data, * generators):\n    _add_generated_records(data, * generators)\n    runtime_storage_inst = TestStorage(data)\n    setattr(web.app, 'stackalytics_vault', None)\n    with mock.patch('stackalytics.processor.runtime_storage.'\n        'get_runtime_storage') as get_runtime_storage_mock:\n        get_runtime_storage_mock.return_value = runtime_storage_inst\n        try:\n        yield runtime_storage_inst\n        finally:\n        pass\n", "code_toks_joined": "def make_runtime_storage ( data , * generators ) : <NEWLINE> <INDENT> _add_generated_records ( data , * generators ) <NEWLINE> runtime_storage_inst = TestStorage ( data ) <NEWLINE> setattr ( web . app , <STRING> , None ) <NEWLINE> with mock . patch ( <STRING> <NEWLINE> <INDENT> <STRING> ) as get_runtime_storage_mock : <NEWLINE> get_runtime_storage_mock . return_value = runtime_storage_inst <NEWLINE> try : <NEWLINE> yield runtime_storage_inst <NEWLINE> finally : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'stackalytics_vault'", "'stackalytics.processor.runtime_storage.'", "'get_runtime_storage'"]}, "err_obj": {"msg": "expected an indented block"}}], ["d9867cbbaab24827bbf0d763604b7ea8", {"code_string": "def _absurl(self url):\n    \"\"\"Returns an absolute url for the (possibly) relative\"\"\"\n    if len(self._incstack) == 0:\n        return url\n    else:\n        return urlparse.urljoin(self.geturl(), url)\n", "code_toks_joined": "def _absurl ( self url ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if len ( self . _incstack ) == 0 : <NEWLINE> <INDENT> return url <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return urlparse . urljoin ( self . geturl ( ) , url ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns an absolute url for the (possibly) relative\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["2879d6efb484ab158ae153d026dbe724", {"code_string": "def mark_link(self, reference):\n    \"\"\" Create markup to indicate the link.\"\"\"\n    if not reference: return ''\n    postfix = ''\n    if reference.startswith('http'):\n        pass\n    elif reference.startswith(\"/\"):\n        path = normpath(\"%s\" %(reference))\n        reference = \"%s://%s%s\" %(self.method, self.host, path)\n    elif self.method:\n        reference = \"%s/%s\" %(self.base_url, reference)\n        if reference.startswith(\"http://\"):\n            reference = 'http:/' + FlagFramework.normpath(reference[6: ])\n    reference = url_unquote(decode_entity(unquote(reference)))\n    dbh = DB.DBO(self.case)\n    dbh.execute(\"select mtime from inode where inode_id=%r\", self.inode_id)\n    row = dbh.fetch()\n    dbh.execute(\"select inode.inode_id, inode.mtime, datediff(inode.mtime, %r) as diff, url \" \"from http join inode on \" \"inode.inode_id=http.inode_id where url=%r and not \"\n        reference, ))\n    row = dbh.fetch()\n    if row:\n        print(\"Fetched %s %s ago\" %(row['url'], row['diff']))\n        postfix = \"<div class='overlay'>Linked <a href=%s>%s</a><br>After %s</div>\" %(\n            self.make_reference_to_inode(row['inode_id'], None),\n            row['url'][: 50],\n            row['diff'])\n    return postfix\n", "code_toks_joined": "def mark_link ( self , reference ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not reference : return <STRING> <NEWLINE> postfix = <STRING> <NEWLINE> if reference . startswith ( <STRING> ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif reference . startswith ( <STRING> ) : <NEWLINE> <INDENT> path = normpath ( <STRING> % ( reference ) ) <NEWLINE> reference = <STRING> % ( self . method , self . host , path ) <NEWLINE> <DEDENT> elif self . method : <NEWLINE> <INDENT> reference = <STRING> % ( self . base_url , reference ) <NEWLINE> if reference . startswith ( <STRING> ) : <NEWLINE> <INDENT> reference = <STRING> + FlagFramework . normpath ( reference [ 6 : ] ) <NEWLINE> <DEDENT> <DEDENT> reference = url_unquote ( decode_entity ( unquote ( reference ) ) ) <NEWLINE> dbh = DB . DBO ( self . case ) <NEWLINE> dbh . execute ( <STRING> , self . inode_id ) <NEWLINE> row = dbh . fetch ( ) <NEWLINE> dbh . execute ( <STRING> <STRING> <STRING> <NEWLINE> <INDENT> reference , ) ) <NEWLINE> <DEDENT> row = dbh . fetch ( ) <NEWLINE> if row : <NEWLINE> <INDENT> print ( <STRING> % ( row [ <STRING> ] , row [ <STRING> ] ) ) <NEWLINE> postfix = <STRING> % ( <NEWLINE> <INDENT> self . make_reference_to_inode ( row [ <STRING> ] , None ) , <NEWLINE> row [ <STRING> ] [ : 50 ] , <NEWLINE> row [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT> return postfix <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Create markup to indicate the link.\"\"\"", "''", "''", "'http'", "\"/\"", "\"%s\"", "\"%s://%s%s\"", "\"%s/%s\"", "\"http://\"", "'http:/'", "\"select mtime from inode where inode_id=%r\"", "\"select inode.inode_id, inode.mtime, datediff(inode.mtime, %r) as diff, url \"", "\"from http join inode on \"", "\"inode.inode_id=http.inode_id where url=%r and not \"", "\"Fetched %s %s ago\"", "'url'", "'diff'", "\"<div class='overlay'>Linked <a href=%s>%s</a><br>After %s</div>\"", "'inode_id'", "'url'", "'diff'"]}, "window_span": [163, 177], "err_obj": {"msg": "unbalanced (){}[]"}}], ["a7d39f9a1ddf88d0e5992fc81c79c8b6", {"code_string": "def run_rdfcat(x, file):\n    cmd = 'rdfcat -n ' + file + ' -out N3 >> /dev/null'\n    output = Popen(cmd, stderr = PIPE, shell = True)\n    errorCounter = 0\n    for line in output.stderr:\n        if \"RiotException\" in line:\n        errorCounter = errorCounter + 1\n    print('rdfcat: commit: ' + str(x) + ', file:' + file + ', errors found: ' + str(errorCounter))\n", "code_toks_joined": "def run_rdfcat ( x , file ) : <NEWLINE> <INDENT> cmd = <STRING> + file + <STRING> <NEWLINE> output = Popen ( cmd , stderr = PIPE , shell = True ) <NEWLINE> errorCounter = 0 <NEWLINE> for line in output . stderr : <NEWLINE> <INDENT> if <STRING> in line : <NEWLINE> errorCounter = errorCounter + 1 <NEWLINE> <DEDENT> print ( <STRING> + str ( x ) + <STRING> + file + <STRING> + str ( errorCounter ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'rdfcat -n '", "' -out N3 >> /dev/null'", "\"RiotException\"", "'rdfcat: commit: '", "', file:'", "', errors found: '"]}, "err_obj": {"msg": "expected an indented block"}}], ["e004fc9cad74b297c1f686a8686a88c5", {"code_string": "def cifarnet_arg_scope(weight_decay = 0.004):\n    \"\"\"Defines the default cifarnet argument scope.\"\"\"\n    with slim.arg_scope(\n        [slim.conv2d],\n        weights_initializer = tf.truncated_normal_initializer(stddev = 5e-2),\n        activation_fn = tf.nn.relu):\n        with slim.arg_scope(\n            [slim.fully_connected],\n            biases_initializer = tf.constant_initializer(0.1),\n            weights_initializer = trunc_normal(0.04),\n            weights_regularizer = slim.l2_regularizer(weight_decay),\n            activation_fn = tf.nn.relu) as sc:\n        return sc\n", "code_toks_joined": "def cifarnet_arg_scope ( weight_decay = 0.004 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with slim . arg_scope ( <NEWLINE> <INDENT> [ slim . conv2d ] , <NEWLINE> weights_initializer = tf . truncated_normal_initializer ( stddev = 5e-2 ) , <NEWLINE> activation_fn = tf . nn . relu ) : <NEWLINE> with slim . arg_scope ( <NEWLINE> <INDENT> [ slim . fully_connected ] , <NEWLINE> biases_initializer = tf . constant_initializer ( 0.1 ) , <NEWLINE> weights_initializer = trunc_normal ( 0.04 ) , <NEWLINE> weights_regularizer = slim . l2_regularizer ( weight_decay ) , <NEWLINE> activation_fn = tf . nn . relu ) as sc : <NEWLINE> <DEDENT> return sc <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Defines the default cifarnet argument scope.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["836293711f8ac8afb2a8ead86db038b7", {"code_string": "def children(cls, source = None):\n    \"\"\"Recursively collect all subclasses of ``cls``, not just direct\"\"\"\n    source = source or cls\n    result = source.__subclasses__()\n    for child in result:\n        result.extend(cls.children(source = child)\n    return result\n", "code_toks_joined": "def children ( cls , source = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> source = source or cls <NEWLINE> result = source . __subclasses__ ( ) <NEWLINE> for child in result : <NEWLINE> <INDENT> result . extend ( cls . children ( source = child ) <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Recursively collect all subclasses of ``cls``, not just direct\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["0c25f78483f48074b4bc21611b245ebc", {"code_string": "def set_freq(self, target_freq):\n    \"\"\"Set the center frequency we're interested in.\"\"\"\n    r = self.u.set_center_freq(target_freq)\n    if r:\n        self.myform['freq'].set_value(target_freq)\n        if self.show_debug_info:\n            self.myform['baseband'].set_value(r.baseband_freq)\n            self.myform['ddc'].set_value(r.dxc_freq)\n            if not self.options.oscilloscope:\n            self.scope.set_baseband_freq(target_freq)\n            return True\n    return False\n", "code_toks_joined": "def set_freq ( self , target_freq ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> r = self . u . set_center_freq ( target_freq ) <NEWLINE> if r : <NEWLINE> <INDENT> self . myform [ <STRING> ] . set_value ( target_freq ) <NEWLINE> if self . show_debug_info : <NEWLINE> <INDENT> self . myform [ <STRING> ] . set_value ( r . baseband_freq ) <NEWLINE> self . myform [ <STRING> ] . set_value ( r . dxc_freq ) <NEWLINE> if not self . options . oscilloscope : <NEWLINE> self . scope . set_baseband_freq ( target_freq ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Set the center frequency we're interested in.\"\"\"", "'freq'", "'baseband'", "'ddc'"]}, "err_obj": {"msg": "expected an indented block"}}], ["f5a3d27f58af059de90c989e98c97fae", {"code_string": "def install_exceptions(module):\n    for exception in(Error, Warning, DatabaseError, InternalError,\n        OperationalError, ProgrammingError, IntegrityError,\n        DataError, NotSupportedError, InterfaceError):\n        module_exception = getattr(module, exception.__name__, None)\n        if module_exception is not None:\n        try:\n        module_exception.__bases__ +=(exception, )\n        except TypeError:\n        pass\n", "code_toks_joined": "def install_exceptions ( module ) : <NEWLINE> <INDENT> for exception in ( Error , Warning , DatabaseError , InternalError , <NEWLINE> <INDENT> OperationalError , ProgrammingError , IntegrityError , <NEWLINE> DataError , NotSupportedError , InterfaceError ) : <NEWLINE> module_exception = getattr ( module , exception . __name__ , None ) <NEWLINE> if module_exception is not None : <NEWLINE> try : <NEWLINE> module_exception . __bases__ += ( exception , ) <NEWLINE> except TypeError : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["ed6d715afb912f2a218f089f9dbb155a", {"code_string": "def get(self, key):\n    try:\n        return self.__getProxy().get(self.__convertKey(key))\n    except redis.exceptions.ConnectionError, e:\n        return self.__getProxy().get(self.__convertKey(key))\n", "code_toks_joined": "def get ( self , key ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return self . __getProxy ( ) . get ( self . __convertKey ( key ) ) <NEWLINE> <DEDENT> except redis . exceptions . ConnectionError , e : <NEWLINE> <INDENT> return self . __getProxy ( ) . get ( self . __convertKey ( key ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["692741c061afa0abfc47e08f216d07ca", {"code_string": "def testShowNoProduct(self):\n    handle = self.handle\n    mock.mockMethod(handle.facade.rbuilder.getImages)\n    mock.mockMethod(handle.Images._getProductStage)\n    handle.Images._getProductStage._mock.raiseErrorOnAccess(\n        errors.MissingProductStoreError(path = '/foo')\n    self.assertRaises(errors.MissingProductStoreError,\n        handle.Images.delete, 10)\n    handle.facade.rbuilder.getImages._mock.assertNotCalled()\n", "code_toks_joined": "def testShowNoProduct ( self ) : <NEWLINE> <INDENT> handle = self . handle <NEWLINE> mock . mockMethod ( handle . facade . rbuilder . getImages ) <NEWLINE> mock . mockMethod ( handle . Images . _getProductStage ) <NEWLINE> handle . Images . _getProductStage . _mock . raiseErrorOnAccess ( <NEWLINE> <INDENT> errors . MissingProductStoreError ( path = <STRING> ) <NEWLINE> <DEDENT> self . assertRaises ( errors . MissingProductStoreError , <NEWLINE> <INDENT> handle . Images . delete , 10 ) <NEWLINE> <DEDENT> handle . facade . rbuilder . getImages . _mock . assertNotCalled ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'/foo'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["6b5563e3825a57b4a3898794ca38102e", {"code_string": "def test_getargspec_sublistofone(self):\n    with check_py3k_warnings(\n        (\"tuple parameter unpacking has been removed\", SyntaxWarning),\n        (\"parenthesized argument names are invalid\", SyntaxWarning)):\n        exec 'def sublistOfOne((foo,)): return 1'\n        self.assertArgSpecEquals(sublistOfOne, [['foo']])\n        exec 'def fakeSublistOfOne((foo)): return 1'\n        self.assertArgSpecEquals(fakeSublistOfOne, ['foo'])\n", "code_toks_joined": "def test_getargspec_sublistofone ( self ) : <NEWLINE> <INDENT> with check_py3k_warnings ( <NEWLINE> <INDENT> ( <STRING> , SyntaxWarning ) , <NEWLINE> ( <STRING> , SyntaxWarning ) ) : <NEWLINE> exec <STRING> <NEWLINE> self . assertArgSpecEquals ( sublistOfOne , [ [ <STRING> ] ] ) <NEWLINE> exec <STRING> <NEWLINE> self . assertArgSpecEquals ( fakeSublistOfOne , [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"tuple parameter unpacking has been removed\"", "\"parenthesized argument names are invalid\"", "'def sublistOfOne((foo,)): return 1'", "'foo'", "'def fakeSublistOfOne((foo)): return 1'", "'foo'"]}, "err_obj": {"msg": "invalid syntax"}}], ["ef8af8cbbe17be171f309d5e34be292d", {"code_string": "def projectID(con, project):\n    \"\"\" Get the ID of the project \"\"\"\n    cursor = con.cursor()\n    query = \"\"\"SELECT id FROM Project WHERE webname = %s\"\"\"\n    cursor.execute(query, (project, )))\n    rows = cursor.fetchall()\n    id = 0\n    for row in rows:\n        id = int(row[0])\n    return id\n", "code_toks_joined": "def projectID ( con , project ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> cursor = con . cursor ( ) <NEWLINE> query = <STRING> <NEWLINE> cursor . execute ( query , ( project , ) ) ) <NEWLINE> rows = cursor . fetchall ( ) <NEWLINE> id = 0 <NEWLINE> for row in rows : <NEWLINE> <INDENT> id = int ( row [ 0 ] ) <NEWLINE> <DEDENT> return id <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Get the ID of the project \"\"\"", "\"\"\"SELECT id FROM Project WHERE webname = %s\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["064cfb0af8ae36261242d5d28734d8b1", {"code_string": "def gamma11_B_910(f):\n    if f != 5:\n        raise ValueError('Only implemented for 5 flavours')\n    return np.array([[\n    -((8) /(9)), 0\n", "code_toks_joined": "def gamma11_B_910 ( f ) : <NEWLINE> <INDENT> if f != 5 : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> return np . array ( [ [ <NEWLINE> - ( ( 8 ) / ( 9 ) ) , 0 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Only implemented for 5 flavours'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["cf80ed02e448479ce79f50f60bacd963", {"code_string": "def _log_etree_elem(elem, level = logging.DEBUG):\n    '''Helper function - Log serialisation of an ElementTree Element'''\n    if log.getEffectiveLevel() <= level:\n        log.debug(ET.tostring(elem)\n", "code_toks_joined": "def _log_etree_elem ( elem , level = logging . DEBUG ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if log . getEffectiveLevel ( ) <= level : <NEWLINE> <INDENT> log . debug ( ET . tostring ( elem ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Helper function - Log serialisation of an ElementTree Element'''"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["d2ccf1c92a84f51aa943fce053f9beb1", {"code_string": "def ramp_down(self, temperature):\n    \"\"\"Ramp down to variale temp\"\"\"\n    print('Ramp down to ' + str(temperature) + 'C')\n    self.set_temp(temperature)\n    time.sleep(0.1)\n    current_temp = self.get_temp()\n    time.sleep(0.1)\n    while current_temp != temperature:\n    current_temp = self.get_temp()\n", "code_toks_joined": "def ramp_down ( self , temperature ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> + str ( temperature ) + <STRING> ) <NEWLINE> self . set_temp ( temperature ) <NEWLINE> time . sleep ( 0.1 ) <NEWLINE> current_temp = self . get_temp ( ) <NEWLINE> time . sleep ( 0.1 ) <NEWLINE> while current_temp != temperature : <NEWLINE> current_temp = self . get_temp ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Ramp down to variale temp\"\"\"", "'Ramp down to '", "'C'"]}, "err_obj": {"msg": "expected an indented block"}}], ["bd81aa3f848f6c56c2f45a17d7a8e084", {"code_string": "def handle_noargs(self, ** options):\n    self.set_options(** options)\n    if(isinstance(self.storage, FileSystemStorage) and\n        self.storage.location):\n        destination_path = self.storage.location\n        destination_display = ':\\n\\n    %s' % destination_path\n    else:\n        destination_path = None\n        destination_display = '.'\n    if self.clear:\n        clear_display = 'This will DELETE EXISTING FILES!'\n    else:\n        clear_display = 'This will overwrite existing files!'\n    if self.interactive:\n        confirm = input(\"\"\"You have requested to collect static files at the destination\"\"\"\n", "code_toks_joined": "def handle_noargs ( self , ** options ) : <NEWLINE> <INDENT> self . set_options ( ** options ) <NEWLINE> if ( isinstance ( self . storage , FileSystemStorage ) and <NEWLINE> <INDENT> self . storage . location ) : <NEWLINE> destination_path = self . storage . location <NEWLINE> destination_display = <STRING> % destination_path <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> destination_path = None <NEWLINE> destination_display = <STRING> <NEWLINE> <DEDENT> if self . clear : <NEWLINE> <INDENT> clear_display = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> clear_display = <STRING> <NEWLINE> <DEDENT> if self . interactive : <NEWLINE> <INDENT> confirm = input ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["':\\n\\n    %s'", "'.'", "'This will DELETE EXISTING FILES!'", "'This will overwrite existing files!'", "\"\"\"You have requested to collect static files at the destination\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["482f316cae3172de68c09a67afbbaec6", {"code_string": "def check_docstring_missing(self, definition, docstring):\n    \"\"\"D10{0,1,2,3}: Public definitions should have docstrings.\"\"\"\n    if(not docstring and definition.is_public or\n        docstring and is_blank(eval(docstring))):\n        codes = {Module: 'D100', Class: 'D101', NestedClass: 'D101',\n            Method: 'D102', Function: 'D103', NestedFunction: 'D103'}\n            return Error('%s: Docstring missing' % codes[type(definition)])\n", "code_toks_joined": "def check_docstring_missing ( self , definition , docstring ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( not docstring and definition . is_public or <NEWLINE> <INDENT> docstring and is_blank ( eval ( docstring ) ) ) : <NEWLINE> codes = { Module : <STRING> , Class : <STRING> , NestedClass : <STRING> , <NEWLINE> <INDENT> Method : <STRING> , Function : <STRING> , NestedFunction : <STRING> } <NEWLINE> return Error ( <STRING> % codes [ type ( definition ) ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"D10{0,1,2,3}: Public definitions should have docstrings.\"\"\"", "'D100'", "'D101'", "'D101'", "'D102'", "'D103'", "'D103'", "'%s: Docstring missing'"]}, "err_obj": {"msg": "unexpected indent"}}], ["8cab9f5e57998d6d7ba850a71f553997", {"code_string": "def propagate_queries(settings, db, requests_session):\n    entity_statuses = settings['cached_tables']['entity_status']\n    dbc = db.execute(\"\"\"SELECT\"\"\")\n    for r in dbc.fetchall():\n        db.execute(\"\"\"UPDATE\"\"\" %(\n    r['id']\n", "code_toks_joined": "def propagate_queries ( settings , db , requests_session ) : <NEWLINE> <INDENT> entity_statuses = settings [ <STRING> ] [ <STRING> ] <NEWLINE> dbc = db . execute ( <STRING> ) <NEWLINE> for r in dbc . fetchall ( ) : <NEWLINE> <INDENT> db . execute ( <STRING> % ( <NEWLINE> <DEDENT> r [ <STRING> ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'cached_tables'", "'entity_status'", "\"\"\"SELECT\"\"\"", "\"\"\"UPDATE\"\"\"", "'id'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["30edd467f711875b951d6d9d9470ea06", {"code_string": "def got_addr(self, (host, port), services, timestamp):\n    if(host, port) in self.addr_store:\n        old_services, old_first_seen, old_last_seen = self.addr_store[host, port]\n        self.addr_store[host, port] = services, old_first_seen, max(old_last_seen, timestamp)\n    else:\n        if len(self.addr_store) < 10000:\n            self.addr_store[host, port] = services, timestamp, timestamp\n", "code_toks_joined": "def got_addr ( self , ( host , port ) , services , timestamp ) : <NEWLINE> <INDENT> if ( host , port ) in self . addr_store : <NEWLINE> <INDENT> old_services , old_first_seen , old_last_seen = self . addr_store [ host , port ] <NEWLINE> self . addr_store [ host , port ] = services , old_first_seen , max ( old_last_seen , timestamp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( self . addr_store ) < 10000 : <NEWLINE> <INDENT> self . addr_store [ host , port ] = services , timestamp , timestamp <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["b724e0ce449147f2a502167f34c39b1c", {"code_string": "def convert(self, (r, g, b)):\n    i = self.inxsearch(r, g, b)\n    return self.colormap[i, : 3]\n", "code_toks_joined": "def convert ( self , ( r , g , b ) ) : <NEWLINE> <INDENT> i = self . inxsearch ( r , g , b ) <NEWLINE> return self . colormap [ i , : 3 ] <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["e5d1b638e0a98513220283828d086dcd", {"code_string": "def getlanguage(self, sCode):\n    if(self.__bIsDharma):\n        return self.__aLanguage(sCode).encode(\"utf-8\")\n    else:\n        try:\n        return xbmc.getLocalizedString(sCode).encode(\"utf-8\")\n        except:\n        return ''\n", "code_toks_joined": "def getlanguage ( self , sCode ) : <NEWLINE> <INDENT> if ( self . __bIsDharma ) : <NEWLINE> <INDENT> return self . __aLanguage ( sCode ) . encode ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> return xbmc . getLocalizedString ( sCode ) . encode ( <STRING> ) <NEWLINE> except : <NEWLINE> return <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"utf-8\"", "\"utf-8\"", "''"]}, "err_obj": {"msg": "expected an indented block"}}], ["ab8e8373a7eab10d1fa00c07ba307ece", {"code_string": "def merge(self, other):\n    \"\"\"Merge another object as needed.\"\"\"\n    other.qualify()\n    for n in(\"default\", \"max\", \"min\", \"name\", \"nillable\", \"qname\",\n        \"type\"):\n        if getattr(self, n) is not None:\n        continue\n        v = getattr(other, n)\n        if v is None:\n        continue\n        setattr(self, n, v)\n", "code_toks_joined": "def merge ( self , other ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> other . qualify ( ) <NEWLINE> for n in ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> if getattr ( self , n ) is not None : <NEWLINE> continue <NEWLINE> v = getattr ( other , n ) <NEWLINE> if v is None : <NEWLINE> continue <NEWLINE> setattr ( self , n , v ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Merge another object as needed.\"\"\"", "\"default\"", "\"max\"", "\"min\"", "\"name\"", "\"nillable\"", "\"qname\"", "\"type\""]}, "err_obj": {"msg": "expected an indented block"}}], ["2e053774bf77d88fa900d9227cf14d90", {"code_string": "def save(self):\n    oConfig = CNBConfig.getInstance()\n    sFile = oConfig.get('global', 'log-dir') + self.TRIVIA_SAVE_FILE\n    aObj = {'curQtId': self.curQtId, 'startDateTime': self.startDateTime, 'beginDateTime': self.beginDateTime, 'qtDateTime': self.qtDateTime, 'autoSave': self.autoSave,\n    self.log.info('Saving state to ' + sFile)\n    pickle.dump(aObj, open(sFile, 'w'))\n    return 'State was successfuly saved'\n", "code_toks_joined": "def save ( self ) : <NEWLINE> <INDENT> oConfig = CNBConfig . getInstance ( ) <NEWLINE> sFile = oConfig . get ( <STRING> , <STRING> ) + self . TRIVIA_SAVE_FILE <NEWLINE> aObj = { <STRING> : self . curQtId , <STRING> : self . startDateTime , <STRING> : self . beginDateTime , <STRING> : self . qtDateTime , <STRING> : self . autoSave , <NEWLINE> self . log . info ( <STRING> + sFile ) <NEWLINE> pickle . dump ( aObj , open ( sFile , <STRING> ) ) <NEWLINE> return <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'global'", "'log-dir'", "'curQtId'", "'startDateTime'", "'beginDateTime'", "'qtDateTime'", "'autoSave'", "'Saving state to '", "'w'", "'State was successfuly saved'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["34ef5403da7b741a1ff3c53e1a140461", {"code_string": "def GypNotSet(cls flag):\n    \"\"\"Returns condition that tests a gyp flag is not set.\"\"\"\n    return functools.partial(cls._GypNotSet, flag)\n", "code_toks_joined": "def GypNotSet ( cls flag ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return functools . partial ( cls . _GypNotSet , flag ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns condition that tests a gyp flag is not set.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["d93de314817eb4649eebb6f4b009ab8a", {"code_string": "def __init__(self, uiApplication):\n    '''for RevitSnoop to function properly, it needs to be instantiated'''\n    try:\n    rlapp = [app for app in uiApplication.LoadedApplications\n        if app.GetType().Namespace == 'RevitLookup'\n        and app.GetType().Name == 'App'][0]\n    except IndexError:\n        self.RevitLookup = None\n        return\n    clr.AddReference(rlapp.GetType().Assembly)\n    import RevitLookup\n    self.RevitLookup = RevitLookup\n    self.RevitLookup.Snoop.CollectorExts.CollectorExt.m_app = uiApplication\n    self.revit = uiApplication\n", "code_toks_joined": "def __init__ ( self , uiApplication ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> rlapp = [ app for app in uiApplication . LoadedApplications <NEWLINE> <INDENT> if app . GetType ( ) . Namespace == <STRING> <NEWLINE> and app . GetType ( ) . Name == <STRING> ] [ 0 ] <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> self . RevitLookup = None <NEWLINE> return <NEWLINE> <DEDENT> clr . AddReference ( rlapp . GetType ( ) . Assembly ) <NEWLINE> import RevitLookup <NEWLINE> self . RevitLookup = RevitLookup <NEWLINE> self . RevitLookup . Snoop . CollectorExts . CollectorExt . m_app = uiApplication <NEWLINE> self . revit = uiApplication <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''for RevitSnoop to function properly, it needs to be instantiated'''", "'RevitLookup'", "'App'"]}, "err_obj": {"msg": "expected an indented block"}}], ["6372ab88adcc01ab7a64f19b92bc5bc5", {"code_string": "def collect_bears_by_aspects(aspects, kinds):\n    \"\"\"Collect bear based on aspects.\"\"\"\n    all_bears = get_all_bears()\n    bears_found = tuple([] for i in range(len(kinds)))\n    for aspect in aspects.get_leaf_aspects():\n        for bear in all_bears:\n            if(aspect in bear.aspects['detect'] or\n                aspect in bear.aspects['fix']):\n                index = kinds.index(_get_kind(bear))\n                if bear not in bears_found[index]:\n                bears_found[index].append(bear)\n                break\n    return bears_found\n", "code_toks_joined": "def collect_bears_by_aspects ( aspects , kinds ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> all_bears = get_all_bears ( ) <NEWLINE> bears_found = tuple ( [ ] for i in range ( len ( kinds ) ) ) <NEWLINE> for aspect in aspects . get_leaf_aspects ( ) : <NEWLINE> <INDENT> for bear in all_bears : <NEWLINE> <INDENT> if ( aspect in bear . aspects [ <STRING> ] or <NEWLINE> <INDENT> aspect in bear . aspects [ <STRING> ] ) : <NEWLINE> index = kinds . index ( _get_kind ( bear ) ) <NEWLINE> if bear not in bears_found [ index ] : <NEWLINE> bears_found [ index ] . append ( bear ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return bears_found <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Collect bear based on aspects.\"\"\"", "'detect'", "'fix'"]}, "err_obj": {"msg": "expected an indented block"}}], ["75c1ff389f3e188bb1204cfaaff8ea87", {"code_string": "def ligand_validation_metrics_gui_list_wrapper(stats_list):\n    ls = ligand_stats()\n    for metric in stats_list:\n    metric_name = metric[0]\n    percentile = metric[1]\n    value = metric[2]\n    ls.add_metric(metric_name, percentile, value)\n    ligand_validation_metrics_gui(ls)\n", "code_toks_joined": "def ligand_validation_metrics_gui_list_wrapper ( stats_list ) : <NEWLINE> <INDENT> ls = ligand_stats ( ) <NEWLINE> for metric in stats_list : <NEWLINE> metric_name = metric [ 0 ] <NEWLINE> percentile = metric [ 1 ] <NEWLINE> value = metric [ 2 ] <NEWLINE> ls . add_metric ( metric_name , percentile , value ) <NEWLINE> ligand_validation_metrics_gui ( ls ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["8bcae1619b140066a7f5477f6c1c070a", {"code_string": "def test_ac_linear_constraints(self):\n    \"\"\" Test linear OPF constraints.\"\"\"\n    self.opf.dc = False\n    om = self.opf._construct_opf_model(self.case)\n    A, l, u = om.linear_constraints()\n    self.assertEqual(A, None)\n    self.assertEqual(l.shape, (0, )\n    self.assertEqual(u.shape, (0, ))\n", "code_toks_joined": "def test_ac_linear_constraints ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . opf . dc = False <NEWLINE> om = self . opf . _construct_opf_model ( self . case ) <NEWLINE> A , l , u = om . linear_constraints ( ) <NEWLINE> self . assertEqual ( A , None ) <NEWLINE> self . assertEqual ( l . shape , ( 0 , ) <NEWLINE> self . assertEqual ( u . shape , ( 0 , ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Test linear OPF constraints.\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["75a500cb08d03d2ffa3185d210af4ab3", {"code_string": "def centre_blit(screen, img, (cx, cy), angle = 0):\n    img1 = img\n    if angle != 0:\n        img1 = pygame.transform.rotate(img, - angle)\n    rect = img1.get_rect()\n    screen.blit(img1, (cx - rect.width / 2, cy - rect.height / 2))\n", "code_toks_joined": "def centre_blit ( screen , img , ( cx , cy ) , angle = 0 ) : <NEWLINE> <INDENT> img1 = img <NEWLINE> if angle != 0 : <NEWLINE> <INDENT> img1 = pygame . transform . rotate ( img , - angle ) <NEWLINE> <DEDENT> rect = img1 . get_rect ( ) <NEWLINE> screen . blit ( img1 , ( cx - rect . width / 2 , cy - rect . height / 2 ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["79934f29bd37c2973da540e0bdf1f286", {"code_string": "class Ui_widStrip(object):\n    def setupUi(self, widStrip):\n        widStrip.setObjectName(_fromUtf8(\"widStrip\"))\n        widStrip.resize(335, 63)\n        self.horizontalLayout = QtGui.QHBoxLayout(widStrip)\n        self.horizontalLayout.setSpacing(5)\n        self.horizontalLayout.setMargin(1)\n        self.horizontalLayout.setObjectName(_fromUtf8(\"horizontalLayout\"))\n        self.widget_5 = QtGui.QWidget(widStrip)\n        self.widget_5.setStyleSheet(_fromUtf8(\"background-color: rgb(255, 170, 0);\"))\n        self.widget_5.setObjectName(_fromUtf8(\"widget_5\"))\n        self.horizontalLayout_5 = QtGui.QHBoxLayout(self.widget_5)\n        self.horizontalLayout_5.setSpacing(5)\n        self.horizontalLayout_5.setMargin(1)\n        self.horizontalLayout_5.setObjectName(_fromUtf8(\"horizontalLayout_5\"))\n        self.lblCallsign = QtGui.QLabel(self.widget_5)\n        self.lblCallsign.setStyleSheet(_fromUtf8(\"color: rgb(0, 0, 0);\\n\"\n", "code_toks_joined": "class Ui_widStrip ( object ) : <NEWLINE> <INDENT> def setupUi ( self , widStrip ) : <NEWLINE> <INDENT> widStrip . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> widStrip . resize ( 335 , 63 ) <NEWLINE> self . horizontalLayout = QtGui . QHBoxLayout ( widStrip ) <NEWLINE> self . horizontalLayout . setSpacing ( 5 ) <NEWLINE> self . horizontalLayout . setMargin ( 1 ) <NEWLINE> self . horizontalLayout . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . widget_5 = QtGui . QWidget ( widStrip ) <NEWLINE> self . widget_5 . setStyleSheet ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . widget_5 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . horizontalLayout_5 = QtGui . QHBoxLayout ( self . widget_5 ) <NEWLINE> self . horizontalLayout_5 . setSpacing ( 5 ) <NEWLINE> self . horizontalLayout_5 . setMargin ( 1 ) <NEWLINE> self . horizontalLayout_5 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . lblCallsign = QtGui . QLabel ( self . widget_5 ) <NEWLINE> self . lblCallsign . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"widStrip\"", "\"horizontalLayout\"", "\"background-color: rgb(255, 170, 0);\"", "\"widget_5\"", "\"horizontalLayout_5\"", "\"color: rgb(0, 0, 0);\\n\""]}, "window_span": [174, 181], "err_obj": {"msg": "unbalanced (){}[]"}}], ["a1c2ca49caefb32fb9cb8a8824d963ee", {"code_string": "class JSONStringDownload(StringDownload, WorkerAPICompatMixin):\n    name = \"json_download\"\n    def __init__(self, o, workerdest = None,\n        slavedest = None,\n        ** buildstep_kwargs):\n        if slavedest is not None:\n        reportDeprecatedWorkerNameUsage(\n        \"'slavedest' keyword argument is deprecated, \"\n        \"use 'workerdest' instead\")\n        assert workerdest is None\n        workerdest = slavedest\n        if workerdest is None:\n        raise TypeError(\"__init__() takes at least 3 arguments\")\n        if 's' in buildstep_kwargs:\n        del buildstep_kwargs['s']\n        s = json.dumps(o)\n        StringDownload.__init__(\n        self, s = s, workerdest = workerdest, ** buildstep_kwargs)\n", "code_toks_joined": "class JSONStringDownload ( StringDownload , WorkerAPICompatMixin ) : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> def __init__ ( self , o , workerdest = None , <NEWLINE> <INDENT> slavedest = None , <NEWLINE> ** buildstep_kwargs ) : <NEWLINE> if slavedest is not None : <NEWLINE> reportDeprecatedWorkerNameUsage ( <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> assert workerdest is None <NEWLINE> workerdest = slavedest <NEWLINE> if workerdest is None : <NEWLINE> raise TypeError ( <STRING> ) <NEWLINE> if <STRING> in buildstep_kwargs : <NEWLINE> del buildstep_kwargs [ <STRING> ] <NEWLINE> s = json . dumps ( o ) <NEWLINE> StringDownload . __init__ ( <NEWLINE> self , s = s , workerdest = workerdest , ** buildstep_kwargs ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"json_download\"", "\"'slavedest' keyword argument is deprecated, \"", "\"use 'workerdest' instead\"", "\"__init__() takes at least 3 arguments\"", "'s'", "'s'"]}, "err_obj": {"msg": "expected an indented block"}}], ["2adb3e515f5b22ccd6879751ef23b04a", {"code_string": "class Logger(object):\n    \"\"\"Logger Class.\"\"\"\n    def __init__(self,\n        name = __name__,\n        logfile = \"/tmp/pystats.log\"):\n        \"\"\"Symphony logger:\"\"\"\n        if hasattr(Logger, 'logger'):\n        self.logger = Logger.logger\n        self.logger.debug(\"Logger already initialized. Return instance\")\n        return\n        formatstr = '[%(asctime)s %(levelname)5s' ' %(process)d %(name)s]: %(message)s'\n        logging.basicConfig(\n        level = logging.DEBUG,\n        format = formatstr,\n        datefmt = '%m-%d-%y %H:%M',\n        filename = logfile,\n        filemode = 'a')\n        self.logger = logging.getLogger(name)\n        Logger.logger = self.logger\n", "code_toks_joined": "class Logger ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , <NEWLINE> <INDENT> name = __name__ , <NEWLINE> logfile = <STRING> ) : <NEWLINE> <STRING> <NEWLINE> if hasattr ( Logger , <STRING> ) : <NEWLINE> self . logger = Logger . logger <NEWLINE> self . logger . debug ( <STRING> ) <NEWLINE> return <NEWLINE> formatstr = <STRING> <STRING> <NEWLINE> logging . basicConfig ( <NEWLINE> level = logging . DEBUG , <NEWLINE> format = formatstr , <NEWLINE> datefmt = <STRING> , <NEWLINE> filename = logfile , <NEWLINE> filemode = <STRING> ) <NEWLINE> self . logger = logging . getLogger ( name ) <NEWLINE> Logger . logger = self . logger <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Logger Class.\"\"\"", "\"/tmp/pystats.log\"", "\"\"\"Symphony logger:\"\"\"", "'logger'", "\"Logger already initialized. Return instance\"", "'[%(asctime)s %(levelname)5s'", "' %(process)d %(name)s]: %(message)s'", "'%m-%d-%y %H:%M'", "'a'"]}, "err_obj": {"msg": "expected an indented block"}}], ["af04d4ca3de4571942d379023e18c7c8", {"code_string": "def makeFileToSort(fileName, lines = 10, maxLineLength = 10):\n    fileHandle = open(fileName, 'w')\n    for line in xrange(lines):\n        fileHandle.write(getRandomLine(maxLineLength)))\n    fileHandle.close()\n", "code_toks_joined": "def makeFileToSort ( fileName , lines = 10 , maxLineLength = 10 ) : <NEWLINE> <INDENT> fileHandle = open ( fileName , <STRING> ) <NEWLINE> for line in xrange ( lines ) : <NEWLINE> <INDENT> fileHandle . write ( getRandomLine ( maxLineLength ) ) ) <NEWLINE> <DEDENT> fileHandle . close ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'w'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["f44d80411759fe921d892318a11b5836", {"code_string": "def main(args):\n    if len(args) > 1:\n        command = args[1]\n        if 'help' == command:\n            usage()\n        elif 'clean' == command:\n            clean(CONFIG)\n        elif 'build' == command:\n            build(CONFIG)\n        elif 'rebuild' == command:\n            clean(CONFIG)\n            build(CONFIG)\n        elif 'run' == command:\n            if len(args) > 2:\n                java_class = args[2]\n                java_params = args[3: ]\n                run(CONFIG, java_class, java_params)\n            else:\n                print('Run command requires a java class to run.')\n                usage();\n        else:\n            print('Unknown command: [',\n            for x in args:\n                print(x, )\n            print(']')\n            usage();\n    else:\n        print('No parameters provided.')\n        usage()\n", "code_toks_joined": "def main ( args ) : <NEWLINE> <INDENT> if len ( args ) > 1 : <NEWLINE> <INDENT> command = args [ 1 ] <NEWLINE> if <STRING> == command : <NEWLINE> <INDENT> usage ( ) <NEWLINE> <DEDENT> elif <STRING> == command : <NEWLINE> <INDENT> clean ( CONFIG ) <NEWLINE> <DEDENT> elif <STRING> == command : <NEWLINE> <INDENT> build ( CONFIG ) <NEWLINE> <DEDENT> elif <STRING> == command : <NEWLINE> <INDENT> clean ( CONFIG ) <NEWLINE> build ( CONFIG ) <NEWLINE> <DEDENT> elif <STRING> == command : <NEWLINE> <INDENT> if len ( args ) > 2 : <NEWLINE> <INDENT> java_class = args [ 2 ] <NEWLINE> java_params = args [ 3 : ] <NEWLINE> run ( CONFIG , java_class , java_params ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> usage ( ) ; <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , <NEWLINE> for x in args : <NEWLINE> <INDENT> print ( x , ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> usage ( ) ; <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> usage ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'help'", "'clean'", "'build'", "'rebuild'", "'run'", "'Run command requires a java class to run.'", "'Unknown command: ['", "']'", "'No parameters provided.'"]}, "window_span": [144, 189], "err_obj": {"msg": "unbalanced (){}[]"}}], ["41bc556b089a3188575f4d3d525572fe", {"code_string": "def _RunJUnitTests(args):\n    \"\"\"Subcommand of RunTestsCommand which runs junit tests.\"\"\"\n    runner_factory, tests = junit_setup.Setup(args)\n    results, exit_code = junit_dispatcher.RunTests(tests, runner_factory)\n    report_results.LogFull(\n        results = results\n        test_type = 'JUnit',\n        test_package = args.test_suite)\n    if args.json_results_file:\n        json_results.GenerateJsonResultsFile(results, args.json_results_file)\n    return exit_code\n", "code_toks_joined": "def _RunJUnitTests ( args ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> runner_factory , tests = junit_setup . Setup ( args ) <NEWLINE> results , exit_code = junit_dispatcher . RunTests ( tests , runner_factory ) <NEWLINE> report_results . LogFull ( <NEWLINE> <INDENT> results = results <NEWLINE> test_type = <STRING> , <NEWLINE> test_package = args . test_suite ) <NEWLINE> <DEDENT> if args . json_results_file : <NEWLINE> <INDENT> json_results . GenerateJsonResultsFile ( results , args . json_results_file ) <NEWLINE> <DEDENT> return exit_code <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Subcommand of RunTestsCommand which runs junit tests.\"\"\"", "'JUnit'"]}, "err_obj": {"msg": "invalid syntax"}}], ["4000a491de2130697f024e0f88f6baa9", {"code_string": "def initialize(self):\n    NormalTUISpoke.initialize(self)\n    for f in[\"services\", \"protocols\", \"group\", \"man.config\",\n        \"nsswitch.conf\", \"selinux\", \"mke2fs.conf\"]:\n        try:\n        os.symlink('/mnt/runtime/etc/' + f, '/etc/' + f)\n        except OSError:\n        pass\n", "code_toks_joined": "def initialize ( self ) : <NEWLINE> <INDENT> NormalTUISpoke . initialize ( self ) <NEWLINE> for f in [ <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> ] : <NEWLINE> try : <NEWLINE> os . symlink ( <STRING> + f , <STRING> + f ) <NEWLINE> except OSError : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"services\"", "\"protocols\"", "\"group\"", "\"man.config\"", "\"nsswitch.conf\"", "\"selinux\"", "\"mke2fs.conf\"", "'/mnt/runtime/etc/'", "'/etc/'"]}, "err_obj": {"msg": "expected an indented block"}}], ["5cff1f65ef827ed2f33b13778e06f751", {"code_string": "def encode_sentence_batch(self, sentence_array):\n    vectors_array = []\n    for sentence in sentence_array:\n    vectors_array.append(self.encode_sentence(sentence))\n    return vectors_array\n", "code_toks_joined": "def encode_sentence_batch ( self , sentence_array ) : <NEWLINE> <INDENT> vectors_array = [ ] <NEWLINE> for sentence in sentence_array : <NEWLINE> vectors_array . append ( self . encode_sentence ( sentence ) ) <NEWLINE> return vectors_array <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["5e05e53aef08a18cee131df1113df29e", {"code_string": "def retranslateUi(self, Dialog):\n    _translate = QtCore.QCoreApplication.translate\n    Dialog.setWindowTitle(_translate(\"Dialog\", \"Insert Point\"))\n    self.label.setText(_translate(\"Dialog\", \"Enter the values of the point you want to insert. \\n\"\n", "code_toks_joined": "def retranslateUi ( self , Dialog ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> Dialog . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . label . setText ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Dialog\"", "\"Insert Point\"", "\"Dialog\"", "\"Enter the values of the point you want to insert. \\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["02ce62374af4a8174f2d9fd297699459", {"code_string": "from django.template import RequestContext\nfrom django.shortcuts import render_to_response\nfrom django.http import HttpResponse\nfrom analytics.models VitalsAnalytics\nfrom analytics.models PatientAnalytic\n", "code_toks_joined": "from django . template import RequestContext <NEWLINE> from django . shortcuts import render_to_response <NEWLINE> from django . http import HttpResponse <NEWLINE> from analytics . models VitalsAnalytics <NEWLINE> from analytics . models PatientAnalytic <NEWLINE>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["a546d62e7e53a356327e3b794c60898a", {"code_string": "def _dispatch(self, msg):\n    for part in msg.walk():\n        maintype = part.get_content_maintype()\n        if maintype == 'text':\n            print(part.get_payload(decode = True))\n        elif maintype == 'multipart':\n            pass\n        else:\n            print(self._fmt %{\n                'type': part.get_content_type(),\n                'maintype': part.get_content_maintype(),\n                'subtype': part.get_content_subtype(),\n                'filename': part.get_filename('[no filename]'),\n                'description': part.get('Content-Description',\n                    '[no description]'),\n                'encoding': part.get('Content-Transfer-Encoding',\n                    '[no encoding]'),\n                }\n", "code_toks_joined": "def _dispatch ( self , msg ) : <NEWLINE> <INDENT> for part in msg . walk ( ) : <NEWLINE> <INDENT> maintype = part . get_content_maintype ( ) <NEWLINE> if maintype == <STRING> : <NEWLINE> <INDENT> print ( part . get_payload ( decode = True ) ) <NEWLINE> <DEDENT> elif maintype == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( self . _fmt % { <NEWLINE> <INDENT> <STRING> : part . get_content_type ( ) , <NEWLINE> <STRING> : part . get_content_maintype ( ) , <NEWLINE> <STRING> : part . get_content_subtype ( ) , <NEWLINE> <STRING> : part . get_filename ( <STRING> ) , <NEWLINE> <STRING> : part . get ( <STRING> , <NEWLINE> <INDENT> <STRING> ) , <NEWLINE> <DEDENT> <STRING> : part . get ( <STRING> , <NEWLINE> <INDENT> <STRING> ) , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'text'", "'multipart'", "'type'", "'maintype'", "'subtype'", "'filename'", "'[no filename]'", "'description'", "'Content-Description'", "'[no description]'", "'encoding'", "'Content-Transfer-Encoding'", "'[no encoding]'"]}, "window_span": [64, 145], "err_obj": {"msg": "unbalanced (){}[]"}}], ["f93ea3520300eaa31e7bf0559eeac980", {"code_string": "def saveAnimationVideo(self):\n    print('calling ArtistAnimation.save()')\n    filename = 'Bes2d_{}_{}ms.mp4'.format(\n        self.shot,\n        np.int(self.tmin * 1e3)\n    writer = animation.FFMpegWriter(fps = 30,\n        bitrate = 1e5)\n    self.animation.save(filename, writer = writer)\n", "code_toks_joined": "def saveAnimationVideo ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> filename = <STRING> . format ( <NEWLINE> <INDENT> self . shot , <NEWLINE> np . int ( self . tmin * 1e3 ) <NEWLINE> <DEDENT> writer = animation . FFMpegWriter ( fps = 30 , <NEWLINE> <INDENT> bitrate = 1e5 ) <NEWLINE> <DEDENT> self . animation . save ( filename , writer = writer ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'calling ArtistAnimation.save()'", "'Bes2d_{}_{}ms.mp4'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["fe0f420122ffdc727a2b7af492d97039", {"code_string": "def languageChange(self):\n    self.setCaption(self.__tr(\"HP Device Manager - Color Calibration\"))\n    self.CancelButton.setText(self.__tr(\"Cancel\"))\n    self.ContinueButton.setText(self.__tr(\"Next >\"))\n    self.buttonGroup.setTitle(QString.null)\n    self.textLabel2_2.setText(self.__tr(\"<b>A page of color patches is printing. When it is complete, follow these steps:</b>\\n\"\n", "code_toks_joined": "def languageChange ( self ) : <NEWLINE> <INDENT> self . setCaption ( self . __tr ( <STRING> ) ) <NEWLINE> self . CancelButton . setText ( self . __tr ( <STRING> ) ) <NEWLINE> self . ContinueButton . setText ( self . __tr ( <STRING> ) ) <NEWLINE> self . buttonGroup . setTitle ( QString . null ) <NEWLINE> self . textLabel2_2 . setText ( self . __tr ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"HP Device Manager - Color Calibration\"", "\"Cancel\"", "\"Next >\"", "\"<b>A page of color patches is printing. When it is complete, follow these steps:</b>\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["50ff6408c6d2cfba930a4662726fbc69", {"code_string": "def on_post_save(self, view):\n    \"\"\"Called post file save event\"\"\"\n    if check_linting(\n        view, NOT_SCRATCH | LINTING_ENABLED, code = self.lang.lower()):\n        if self.lang in view.settings().get('syntax'):\n        if get_settings(\n            view, \"anaconda_linter_show_errors_on_save\", False):\n            self.run_linter(view, self._show_errors_list)\n        else:\n            self.run_linter(view)\n    else:\n        self._erase_marks_if_no_linting(view)\n", "code_toks_joined": "def on_post_save ( self , view ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if check_linting ( <NEWLINE> <INDENT> view , NOT_SCRATCH | LINTING_ENABLED , code = self . lang . lower ( ) ) : <NEWLINE> if self . lang in view . settings ( ) . get ( <STRING> ) : <NEWLINE> if get_settings ( <NEWLINE> <INDENT> view , <STRING> , False ) : <NEWLINE> self . run_linter ( view , self . _show_errors_list ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . run_linter ( view ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> self . _erase_marks_if_no_linting ( view ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Called post file save event\"\"\"", "'syntax'", "\"anaconda_linter_show_errors_on_save\""]}, "err_obj": {"msg": "expected an indented block"}}], ["01ff71fcad48e427513f0f2c97f5bc53", {"code_string": "class Test_GUI(TestCase):\n    def basic_run_test(self:\n        pass\n", "code_toks_joined": "class Test_GUI ( TestCase ) : <NEWLINE> <INDENT> def basic_run_test ( self : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["b2abf963e1d187343892299fe6e48dbf", {"code_string": "def _wd(obj, filename, dirname, comment = \"\"):\n    if obj:\n        import os.path\n        if os.path.isdir(dirname):\n            if os.path.exists(os.path.join(filename, dirname):\n                raise OSError(\"File overwriting options are not yet supported.\")\n            with open(os.path.join(dirname, filename), 'wb') as f:\n                write_hlines(f)\n    raise TypeError(\"'obj' contains no writable data or is an invalid Type.\")\n", "code_toks_joined": "def _wd ( obj , filename , dirname , comment = <STRING> ) : <NEWLINE> <INDENT> if obj : <NEWLINE> <INDENT> import os . path <NEWLINE> if os . path . isdir ( dirname ) : <NEWLINE> <INDENT> if os . path . exists ( os . path . join ( filename , dirname ) : <NEWLINE> <INDENT> raise OSError ( <STRING> ) <NEWLINE> <DEDENT> with open ( os . path . join ( dirname , filename ) , <STRING> ) as f : <NEWLINE> <INDENT> write_hlines ( f ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> raise TypeError ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"", "\"File overwriting options are not yet supported.\"", "'wb'", "\"'obj' contains no writable data or is an invalid Type.\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["50aff0a5a5e7be42626cca3be80d384f", {"code_string": "def test_offset_commit(self):\n    \"\"\"Check fetched offsets match pre-commit internal state\"\"\"\n    with self._get_simple_consumer(\n        consumer_group = 'test_offset_commit') as consumer:\n        [consumer.consume() for _ in xrange(100)]\n        offsets_committed = self._currently_held_offsets(consumer)\n        consumer.commit_offsets()\n        offsets_fetched = dict((r[0], r[1].offset)\n            for r in consumer.fetch_offsets())\n            self.assertEquals(offsets_fetched, offsets_committed)\n", "code_toks_joined": "def test_offset_commit ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with self . _get_simple_consumer ( <NEWLINE> <INDENT> consumer_group = <STRING> ) as consumer : <NEWLINE> [ consumer . consume ( ) for _ in xrange ( 100 ) ] <NEWLINE> offsets_committed = self . _currently_held_offsets ( consumer ) <NEWLINE> consumer . commit_offsets ( ) <NEWLINE> offsets_fetched = dict ( ( r [ 0 ] , r [ 1 ] . offset ) <NEWLINE> <INDENT> for r in consumer . fetch_offsets ( ) ) <NEWLINE> self . assertEquals ( offsets_fetched , offsets_committed ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Check fetched offsets match pre-commit internal state\"\"\"", "'test_offset_commit'"]}, "err_obj": {"msg": "unexpected indent"}}], ["bb42db8ea0b840e6afad889182babba0", {"code_string": "def perform(self):\n    try:\n        with MySQLdb.connect(db = 'wasp', user = 'sw', host = '127.0.0.1',\n            cursorclass = SSDictCursor) as cursor:\n            cursor.execute(str(self))\n            for row in cursor:\n            yield row\n    except MySQLdb.OperationalError as err:\n        if \"Can't connect to MySQL server\" in str(err):\n            self.ssh_tunnel_usage()\n            sys.exit(1)\n", "code_toks_joined": "def perform ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> with MySQLdb . connect ( db = <STRING> , user = <STRING> , host = <STRING> , <NEWLINE> <INDENT> cursorclass = SSDictCursor ) as cursor : <NEWLINE> cursor . execute ( str ( self ) ) <NEWLINE> for row in cursor : <NEWLINE> yield row <NEWLINE> <DEDENT> <DEDENT> except MySQLdb . OperationalError as err : <NEWLINE> <INDENT> if <STRING> in str ( err ) : <NEWLINE> <INDENT> self . ssh_tunnel_usage ( ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'wasp'", "'sw'", "'127.0.0.1'", "\"Can't connect to MySQL server\""]}, "err_obj": {"msg": "expected an indented block"}}], ["c2f3d792d629395afa460ff822caedd0", {"code_string": "def test_slack_post_message_failed_cached(self):\n    \"\"\"url in cache and slack returns failure\"\"\"\n    with mock.patch.object(slack_notifier.SlackNotifier,\n        '_raw_data_url_caches',\n        ['http://test.slack:3333']):\n        response_list = [RequestsResponse(200, '{\"ok\":false,\"error\":\"failure\"}',\n            {'Content-Type': 'application/json'})]\n            mock_method, result = self._notify(response_list)\n            self.assertFalse(result)\n            mock_method.assert_called_once()\n            self._validate_post_args(mock_method.call_args_list[0][1], 'data')\n            self.assertEqual(['http://test.slack:3333'],\n            slack_notifier.SlackNotifier._raw_data_url_caches)\n", "code_toks_joined": "def test_slack_post_message_failed_cached ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with mock . patch . object ( slack_notifier . SlackNotifier , <NEWLINE> <INDENT> <STRING> , <NEWLINE> [ <STRING> ] ) : <NEWLINE> response_list = [ RequestsResponse ( 200 , <STRING> , <NEWLINE> <INDENT> { <STRING> : <STRING> } ) ] <NEWLINE> mock_method , result = self . _notify ( response_list ) <NEWLINE> self . assertFalse ( result ) <NEWLINE> mock_method . assert_called_once ( ) <NEWLINE> self . _validate_post_args ( mock_method . call_args_list [ 0 ] [ 1 ] , <STRING> ) <NEWLINE> self . assertEqual ( [ <STRING> ] , <NEWLINE> slack_notifier . SlackNotifier . _raw_data_url_caches ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"url in cache and slack returns failure\"\"\"", "'_raw_data_url_caches'", "'http://test.slack:3333'", "'{\"ok\":false,\"error\":\"failure\"}'", "'Content-Type'", "'application/json'", "'data'", "'http://test.slack:3333'"]}, "err_obj": {"msg": "unexpected indent"}}], ["0b5b6a99ccd5f161caacd9217dca8226", {"code_string": "def index():\n    try:\n        return[{\n            'label': name\n            'path': plugin.url_for(slug)\n        } for slug, name in api.get_path('index')]\n    except Exception as e:\n        plugin.log.error(e, exc_info = 1)\n        plugin.notify(plugin.get_string(32003) % e.message)\n", "code_toks_joined": "def index ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return [ { <NEWLINE> <INDENT> <STRING> : name <NEWLINE> <STRING> : plugin . url_for ( slug ) <NEWLINE> <DEDENT> } for slug , name in api . get_path ( <STRING> ) ] <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> <INDENT> plugin . log . error ( e , exc_info = 1 ) <NEWLINE> plugin . notify ( plugin . get_string ( 32003 ) % e . message ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'label'", "'path'", "'index'"]}, "err_obj": {"msg": "invalid syntax"}}], ["844397c34311f2ba6deedf323a5c59af", {"code_string": "def get_bin_size_data(file):\n    data = \"\"\n    try:\n        data = subprocess.check_output([\"size\", \"-B\", \"-t\", file], stderr = subprocess.STDOUT)\n    except Exception, e:\n        data = e.output\n    res = re.split(r'\\s+', data.split(\"\\n\")[- 2])\n    if len(res[0].strip()) == 0:\n        return res[1: - 3]\n    else:\n        return res[: - 3]\n", "code_toks_joined": "def get_bin_size_data ( file ) : <NEWLINE> <INDENT> data = <STRING> <NEWLINE> try : <NEWLINE> <INDENT> data = subprocess . check_output ( [ <STRING> , <STRING> , <STRING> , file ] , stderr = subprocess . STDOUT ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> data = e . output <NEWLINE> <DEDENT> res = re . split ( <STRING> , data . split ( <STRING> ) [ - 2 ] ) <NEWLINE> if len ( res [ 0 ] . strip ( ) ) == 0 : <NEWLINE> <INDENT> return res [ 1 : - 3 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return res [ : - 3 ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"", "\"size\"", "\"-B\"", "\"-t\"", "r'\\s+'", "\"\\n\""]}, "err_obj": {"msg": "invalid syntax"}}], ["479fb433b4571cdbc8551ff8875a867a", {"code_string": "def test00(self):\n    \"\"\"Check Tag origin.\"\"\"\n    tag = Tag(77, 13, 4, 5, 90, True)\n    self.assertCoincide(tag.originAt(3), Vector(77, 13, 3)\n", "code_toks_joined": "def test00 ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> tag = Tag ( 77 , 13 , 4 , 5 , 90 , True ) <NEWLINE> self . assertCoincide ( tag . originAt ( 3 ) , Vector ( 77 , 13 , 3 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Check Tag origin.\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["b12426a1a50f450fa303da87de636256", {"code_string": "def putline(self, line):\n    \"\"\"Internal: send one line to the server, appending CRLF.\"\"\"\n    line = line + CRLF\n    if self.debugging > 1: print '*put*', repr(line)\n    self.sock.sendall(line)\n", "code_toks_joined": "def putline ( self , line ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> line = line + CRLF <NEWLINE> if self . debugging > 1 : print <STRING> , repr ( line ) <NEWLINE> self . sock . sendall ( line ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Internal: send one line to the server, appending CRLF.\"\"\"", "'*put*'"]}, "err_obj": {"msg": "invalid syntax"}}], ["fd29a1502cca4fff671fc7f2b8c9816a", {"code_string": "def populateComboBox(self):\n    servers = []\n    servers.append(\"'x', '127.0.0.1', '10010'\")\n        servers.append(\"'X', '127.0.0.1', '10010'\")\n    self.connectionDialogui.comboBoxPredef.addItems(servers)\n", "code_toks_joined": "def populateComboBox ( self ) : <NEWLINE> <INDENT> servers = [ ] <NEWLINE> servers . append ( <STRING> ) <NEWLINE> <INDENT> servers . append ( <STRING> ) <NEWLINE> <DEDENT> self . connectionDialogui . comboBoxPredef . addItems ( servers ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"'x', '127.0.0.1', '10010'\"", "\"'X', '127.0.0.1', '10010'\""]}, "err_obj": {"msg": "unexpected indent"}}], ["459719cf81fad1256f162ef308bdf91e", {"code_string": "def start(self):\n    \"\"\"Initialize state.\"\"\"\n    DEBUG = GLOBAL_DEBUG and True\n    if DEBUG: print \"start()\"\n    self.state['exit_allowed'] = False\n    self.state['seq'] = randint(0, 0xFFFFFFFF)\n    self.state['scratch'] = ['\\0'] * SZ_SCRATCH\n    self.state['static_switch'] = open(os.path.join(os.path.dirname(os.path.realpath(__file__)),\n        \"..\", \"..\", \"support\", \"switch.blob\"), \"rb\").read()\n", "code_toks_joined": "def start ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> DEBUG = GLOBAL_DEBUG and True <NEWLINE> if DEBUG : print <STRING> <NEWLINE> self . state [ <STRING> ] = False <NEWLINE> self . state [ <STRING> ] = randint ( 0 , 0xFFFFFFFF ) <NEWLINE> self . state [ <STRING> ] = [ <STRING> ] * SZ_SCRATCH <NEWLINE> self . state [ <STRING> ] = open ( os . path . join ( os . path . dirname ( os . path . realpath ( __file__ ) ) , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> ) , <STRING> ) . read ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Initialize state.\"\"\"", "\"start()\"", "'exit_allowed'", "'seq'", "'scratch'", "'\\0'", "'static_switch'", "\"..\"", "\"..\"", "\"support\"", "\"switch.blob\"", "\"rb\""]}, "err_obj": {"msg": "invalid syntax"}}], ["29acd7be9ac4c2c3721b7288c021a052", {"code_string": "class NetworkManagementClientConfiguration(AzureConfiguration):\n    \"\"\"Configuration for NetworkManagementClient\"\"\"\n    def __init__(\n        self, credentials, subscription_id, base_url = None):\n        if credentials is None:\n        raise ValueError(\"Parameter 'credentials' must not be None.\")\n        if subscription_id is None:\n        raise ValueError(\"Parameter 'subscription_id' must not be None.\")\n        if not base_url:\n        base_url = 'https://management.azure.com'\n        super(NetworkManagementClientConfiguration, self).__init__(base_url)\n        self.add_user_agent('networkmanagementclient/{}'.format(VERSION))\n        self.add_user_agent('Azure-SDK-For-Python')\n        self.credentials = credentials\n        self.subscription_id = subscription_id\n", "code_toks_joined": "class NetworkManagementClientConfiguration ( AzureConfiguration ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( <NEWLINE> <INDENT> self , credentials , subscription_id , base_url = None ) : <NEWLINE> if credentials is None : <NEWLINE> raise ValueError ( <STRING> ) <NEWLINE> if subscription_id is None : <NEWLINE> raise ValueError ( <STRING> ) <NEWLINE> if not base_url : <NEWLINE> base_url = <STRING> <NEWLINE> super ( NetworkManagementClientConfiguration , self ) . __init__ ( base_url ) <NEWLINE> self . add_user_agent ( <STRING> . format ( VERSION ) ) <NEWLINE> self . add_user_agent ( <STRING> ) <NEWLINE> self . credentials = credentials <NEWLINE> self . subscription_id = subscription_id <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Configuration for NetworkManagementClient\"\"\"", "\"Parameter 'credentials' must not be None.\"", "\"Parameter 'subscription_id' must not be None.\"", "'https://management.azure.com'", "'networkmanagementclient/{}'", "'Azure-SDK-For-Python'"]}, "err_obj": {"msg": "expected an indented block"}}], ["586bbd7bef429f4bcf6b9bb2e558466b", {"code_string": "def feed_data(self, data, size):\n    has_waiter = self._waiter is not None and not self._waiter.cancelled()\n    super().feed_data(data, size)\n    if(not self._stream.paused and\n        not has_waiter and self._size > self._limit):\n        try:\n        self._stream.transport.pause_reading()\n        except(AttributeError, NotImplementedError):\n        pass\n        else:\n        self._stream.paused = True\n", "code_toks_joined": "def feed_data ( self , data , size ) : <NEWLINE> <INDENT> has_waiter = self . _waiter is not None and not self . _waiter . cancelled ( ) <NEWLINE> super ( ) . feed_data ( data , size ) <NEWLINE> if ( not self . _stream . paused and <NEWLINE> <INDENT> not has_waiter and self . _size > self . _limit ) : <NEWLINE> try : <NEWLINE> self . _stream . transport . pause_reading ( ) <NEWLINE> except ( AttributeError , NotImplementedError ) : <NEWLINE> pass <NEWLINE> else : <NEWLINE> self . _stream . paused = True <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["2addfd6e5e31f7e0e447f7453648f27e", {"code_string": "class Clade(BaseTree.Clade):\n    \"\"\"NeXML Clade (sub-tree) object.\"\"\"\n    def __init__(self, branch_length = 1.0, name = None, clades = None,\n        confidence = None, comment = None, ** kwargs):\n        BaseTree.Clade.__init__(self, branch_length = branch_length,\n            name = name, clades = clades, confidence = confidence)\n            self.comment = comment\n            for key, value in kwargs.items():\n            setattr(self, key, value)\n", "code_toks_joined": "class Clade ( BaseTree . Clade ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , branch_length = 1.0 , name = None , clades = None , <NEWLINE> <INDENT> confidence = None , comment = None , ** kwargs ) : <NEWLINE> BaseTree . Clade . __init__ ( self , branch_length = branch_length , <NEWLINE> <INDENT> name = name , clades = clades , confidence = confidence ) <NEWLINE> self . comment = comment <NEWLINE> for key , value in kwargs . items ( ) : <NEWLINE> setattr ( self , key , value ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"NeXML Clade (sub-tree) object.\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["fb50df4551045cfa2c7047f33d2709b0", {"code_string": "import random\na = []\nb = []\nfirst = \"10\"\nsecond = \"50\"\niplist = []\nc = \".\"\nfor x in range(800):\n    a.append(random.randint(1, 256))\nfor x in range(800):\n    b.append(random.randint(1, 256))\ndict = {255: 8, 254: 7, 252: 6, 248: 5, 240: 4, 224: 3, 192: 2, 128: 1, 0: 0}\nmasks = [255, 254, 252, 252, 255, 248, 248, 240, 255, 240, 224, 255, 255, 224, 192, 192, 128, 128, 0, 0, 255, 255]\nmasks1 = [255, 254, 252, 252, 248, 248, 240, 255, 240, 224, 224, 192, 192, 128, 255]\nfor x in range(800):\n    temp = random.choice(masks)\n    a1 = a[x] & temp\n    if temp == 255:\n        temp1 = random.choice(masks1)\n        b1 = b[x] & temp1\n        subnet = 24 + dict[temp1]\n    else:\n        b1 = 0\n        subnet = 16 + dict[temp]\n    iplist.append(c.join([first, second, str(a1), str(b1)]) + \"/\" + str(subnet))\nfor x in range(200):\n    c.append(random.randint(1, 256))\nfor x in range(200):\n    c.append(random.randint(1, 256))\nfor x in range(200):\n    iplist.append(c.join([str(a[x]), str(b[x]), str(c[x]), str(d[x])] + \"/32\")\nfor x in range(1000):\n    print(iplist[x])\n", "code_toks_joined": "import random <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> first = <STRING> <NEWLINE> second = <STRING> <NEWLINE> iplist = [ ] <NEWLINE> c = <STRING> <NEWLINE> for x in range ( 800 ) : <NEWLINE> <INDENT> a . append ( random . randint ( 1 , 256 ) ) <NEWLINE> <DEDENT> for x in range ( 800 ) : <NEWLINE> <INDENT> b . append ( random . randint ( 1 , 256 ) ) <NEWLINE> <DEDENT> dict = { 255 : 8 , 254 : 7 , 252 : 6 , 248 : 5 , 240 : 4 , 224 : 3 , 192 : 2 , 128 : 1 , 0 : 0 } <NEWLINE> masks = [ 255 , 254 , 252 , 252 , 255 , 248 , 248 , 240 , 255 , 240 , 224 , 255 , 255 , 224 , 192 , 192 , 128 , 128 , 0 , 0 , 255 , 255 ] <NEWLINE> masks1 = [ 255 , 254 , 252 , 252 , 248 , 248 , 240 , 255 , 240 , 224 , 224 , 192 , 192 , 128 , 255 ] <NEWLINE> for x in range ( 800 ) : <NEWLINE> <INDENT> temp = random . choice ( masks ) <NEWLINE> a1 = a [ x ] & temp <NEWLINE> if temp == 255 : <NEWLINE> <INDENT> temp1 = random . choice ( masks1 ) <NEWLINE> b1 = b [ x ] & temp1 <NEWLINE> subnet = 24 + dict [ temp1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b1 = 0 <NEWLINE> subnet = 16 + dict [ temp ] <NEWLINE> <DEDENT> iplist . append ( c . join ( [ first , second , str ( a1 ) , str ( b1 ) ] ) + <STRING> + str ( subnet ) ) <NEWLINE> <DEDENT> for x in range ( 200 ) : <NEWLINE> <INDENT> c . append ( random . randint ( 1 , 256 ) ) <NEWLINE> <DEDENT> for x in range ( 200 ) : <NEWLINE> <INDENT> c . append ( random . randint ( 1 , 256 ) ) <NEWLINE> <DEDENT> for x in range ( 200 ) : <NEWLINE> <INDENT> iplist . append ( c . join ( [ str ( a [ x ] ) , str ( b [ x ] ) , str ( c [ x ] ) , str ( d [ x ] ) ] + <STRING> ) <NEWLINE> <DEDENT> for x in range ( 1000 ) : <NEWLINE> <INDENT> print ( iplist [ x ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"10\"", "\"50\"", "\".\"", "\"/\"", "\"/32\""]}, "window_span": [380, 442], "err_obj": {"msg": "unbalanced (){}[]"}}], ["9c7f31be99e8b2159fe5a66edd299a13", {"code_string": "def get_va_id_from_recid_and_nameid(bibrec, authornamesid):\n    '''Finds all the virtual author ids that belong to a certain name on a record'''\n    va_ids = set()\n    for possible_va_id in[row['virtualauthorid'] for row in dat.VIRTUALAUTHORS\n        if row['authornamesid'] == authornamesid]:\n        for va_id in[row['virtualauthorid'] for row in dat.VIRTUALAUTHOR_DATA\n        if((row['virtualauthorid'] == possible_va_id) and\n        (row['tag'] == 'bibrec_id') and\n        (row['value'] == bibrec))]:\n        va_ids.add(va_id)\n    return list(va_ids)\n", "code_toks_joined": "def get_va_id_from_recid_and_nameid ( bibrec , authornamesid ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> va_ids = set ( ) <NEWLINE> for possible_va_id in [ row [ <STRING> ] for row in dat . VIRTUALAUTHORS <NEWLINE> <INDENT> if row [ <STRING> ] == authornamesid ] : <NEWLINE> for va_id in [ row [ <STRING> ] for row in dat . VIRTUALAUTHOR_DATA <NEWLINE> if ( ( row [ <STRING> ] == possible_va_id ) and <NEWLINE> ( row [ <STRING> ] == <STRING> ) and <NEWLINE> ( row [ <STRING> ] == bibrec ) ) ] : <NEWLINE> va_ids . add ( va_id ) <NEWLINE> <DEDENT> return list ( va_ids ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Finds all the virtual author ids that belong to a certain name on a record'''", "'virtualauthorid'", "'authornamesid'", "'virtualauthorid'", "'virtualauthorid'", "'tag'", "'bibrec_id'", "'value'"]}, "err_obj": {"msg": "expected an indented block"}}], ["aabc9256c7eba4ddbc21d1b711611094", {"code_string": "def test_with_short_kwargs(self):\n    with self._args_test([0, 1, 2], [0, 1, 8],\n        i = [0, 1], i2 = [0, 1, 4]) as dummy:\n        for i in range(2):\n        dummy.do_step(1, i, i * i, i = i, i2 = i * i)\n", "code_toks_joined": "def test_with_short_kwargs ( self ) : <NEWLINE> <INDENT> with self . _args_test ( [ 0 , 1 , 2 ] , [ 0 , 1 , 8 ] , <NEWLINE> <INDENT> i = [ 0 , 1 ] , i2 = [ 0 , 1 , 4 ] ) as dummy : <NEWLINE> for i in range ( 2 ) : <NEWLINE> dummy . do_step ( 1 , i , i * i , i = i , i2 = i * i ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["fd9ee8be1c436fe27aa6bb501db2a31a", {"code_string": "def __init__(self, APP_PUBLIC_KEY, APP_PRIVATE_KEY):\n    if isinstance(APP_PUBLIC_KEY, basestring):\n        public_key_long = long(APP_PUBLIC_KEY, 16)\n    else:\n        public_key_long = APP_PUBLIC_KEY\n    if isinstance(APP_PRIVATE_KEY, basestring):\n        private_key_long = long(APP_PRIVATE_KEY, 16)\n    else:\n        private_key_long = APP_PRIVATE_KEY\n    rsa_n_bit_length = 2048\n    self.em = (rsa_n_bit_length + 7) / 8\n    exponent = 65537 l\n    self.private_key = RSA.construct((public_key_long, exponent, private_key_long))\n", "code_toks_joined": "def __init__ ( self , APP_PUBLIC_KEY , APP_PRIVATE_KEY ) : <NEWLINE> <INDENT> if isinstance ( APP_PUBLIC_KEY , basestring ) : <NEWLINE> <INDENT> public_key_long = long ( APP_PUBLIC_KEY , 16 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> public_key_long = APP_PUBLIC_KEY <NEWLINE> <DEDENT> if isinstance ( APP_PRIVATE_KEY , basestring ) : <NEWLINE> <INDENT> private_key_long = long ( APP_PRIVATE_KEY , 16 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> private_key_long = APP_PRIVATE_KEY <NEWLINE> <DEDENT> rsa_n_bit_length = 2048 <NEWLINE> self . em = ( rsa_n_bit_length + 7 ) / 8 <NEWLINE> exponent = 65537 l <NEWLINE> self . private_key = RSA . construct ( ( public_key_long , exponent , private_key_long ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["a5f39dd3f5791bc69bb75524e18ed184", {"code_string": "def setupUi(self, RaceWindow):\n    RaceWindow.setObjectName(\"RaceWindow\")\n    RaceWindow.resize(462, 456)\n    icon = QtGui.QIcon()\n    icon.addPixmap(QtGui.QPixmap(\"logo.png\"), QtGui.QIcon.Normal, QtGui.QIcon.Off)\n    RaceWindow.setWindowIcon(icon)\n    self.centralwidget = QtWidgets.QWidget(RaceWindow)\n    self.centralwidget.setObjectName(\"centralwidget\")\n    self.position_frame = QtWidgets.QFrame(self.centralwidget)\n    self.position_frame.setGeometry(QtCore.QRect(0, 0, 457, 235))\n    font = QtGui.QFont()\n    font.setFamily(\"Segoe UI Semibold\")\n    font.setPointSize(12)\n    font.setBold(True)\n    font.setWeight(75)\n    self.position_frame.setFont(font)\n    self.position_frame.setFrameShape(QtWidgets.QFrame.StyledPanel)\n    self.position_frame.setFrameShadow(QtWidgets.QFrame.Raised)\n    self.position_frame.setLineWidth(3)\n    self.position_frame.setMidLineWidth(3)\n    self.position_frame.setObjectName(\"position_frame\")\n    self.label = QtWidgets.QLabel(self.position_frame)\n    self.label.setGeometry(QtCore.QRect(10, 6, 31, 16))\n    self.label.setObjectName(\"label\")\n    self.pos_label_p1 = QtWidgets.QLabel(self.position_frame)\n    self.pos_label_p1.setGeometry(QtCore.QRect(8, 28, 31, 16))\n    self.pos_label_p1.setLayoutDirection(QtCore.Qt.LeftToRight)\n    self.pos_label_p1.setAlignment(QtCore.Qt.AlignCenter)\n    self.pos_label_p1.setObjectName(\"pos_label_p1\")\n    self.pos_label_p2 = QtWidgets.QLabel(self.position_frame)\n    self.pos_label_p2.setGeometry(QtCore.QRect(8, 53, 31, 16))\n    self.pos_label_p2.setAlignment(QtCore.Qt.AlignCenter)\n    self.pos_label_p2.setObjectName(\"pos_label_p2\")\n    self.pos_label_p3 = QtWidgets.QLabel(self.position_frame)\n    self.pos_label_p3.setGeometry(QtCore.QRect(8, 78, 31, 16))\n    self.pos_label_p3.setAlignment(QtCore.Qt.AlignCenter)\n    self.pos_label_p3.setObjectName(\"pos_label_p3\")\n    self.pos_label_p4 = QtWidgets.QLabel(self.position_frame)\n    self.pos_label_p4.setGeometry(QtCore.QRect(8, 103, 31, 16))\n    self.pos_label_p4.setAlignment(QtCore.Qt.AlignCenter)\n    self.pos_label_p4.setObjectName(\"pos_label_p4\")\n    self.pos_label_p5 = QtWidgets.QLabel(self.position_frame)\n    self.pos_label_p5.setGeometry(QtCore.QRect(8, 128, 31, 16))\n    self.pos_label_p5.setAlignment(QtCore.Qt.AlignCenter)\n    self.pos_label_p5.setObjectName(\"pos_label_p5\")\n    self.pos_label_p6 = QtWidgets.QLabel(self.position_frame)\n    self.pos_label_p6.setGeometry(QtCore.QRect(8, 153, 31, 16))\n    self.pos_label_p6.setAlignment(QtCore.Qt.AlignCenter)\n    self.pos_label_p6.setObjectName(\"pos_label_p6\")\n    self.pos_label_p7 = QtWidgets.QLabel(self.position_frame)\n    self.pos_label_p7.setGeometry(QtCore.QRect(8, 178, 31, 16))\n    self.pos_label_p7.setAlignment(QtCore.Qt.AlignCenter)\n    self.pos_label_p7.setObjectName(\"pos_label_p7\")\n    self.line = QtWidgets.QFrame(self.position_frame)\n    self.line.setGeometry(QtCore.QRect(0, 18, 601, 16))\n    self.line.setFrameShape(QtWidgets.QFrame.HLine)\n    self.line.setFrameShadow(QtWidgets.QFrame.Sunken)\n    self.line.setObjectName(\"line\")\n    self.line_2 = QtWidgets.QFrame(self.position_frame)\n    self.line_2.setGeometry(QtCore.QRect(0, 43, 601, 16))\n    self.line_2.setFrameShape(QtWidgets.QFrame.HLine)\n    self.line_2.setFrameShadow(QtWidgets.QFrame.Sunken)\n    self.line_2.setObjectName(\"line_2\")\n    self.line_3 = QtWidgets.QFrame(self.position_frame)\n    self.line_3.setGeometry(QtCore.QRect(0, 68, 601, 16))\n    self.line_3.setFrameShape(QtWidgets.QFrame.HLine)\n    self.line_3.setFrameShadow(QtWidgets.QFrame.Sunken)\n    self.line_3.setObjectName(\"line_3\")\n    self.line_4 = QtWidgets.QFrame(self.position_frame)\n    self.line_4.setGeometry(QtCore.QRect(0, 93, 601, 16))\n    self.line_4.setFrameShape(QtWidgets.QFrame.HLine)\n    self.line_4.setFrameShadow(QtWidgets.QFrame.Sunken)\n    self.line_4.setObjectName(\"line_4\")\n    self.line_5 = QtWidgets.QFrame(self.position_frame)\n    self.line_5.setGeometry(QtCore.QRect(0, 118, 601, 16))\n    self.line_5.setFrameShape(QtWidgets.QFrame.HLine)\n    self.line_5.setFrameShadow(QtWidgets.QFrame.Sunken)\n    self.line_5.setObjectName(\"line_5\")\n    self.line_6 = QtWidgets.QFrame(self.position_frame)\n    self.line_6.setGeometry(QtCore.QRect(0, 143, 601, 16))\n    self.line_6.setFrameShape(QtWidgets.QFrame.HLine)\n    self.line_6.setFrameShadow(QtWidgets.QFrame.Sunken)\n    self.line_6.setObjectName(\"line_6\")\n    self.line_8 = QtWidgets.QFrame(self.position_frame)\n    self.line_8.setGeometry(QtCore.QRect(0, 168, 601, 16))\n    self.line_8.setFrameShape(QtWidgets.QFrame.HLine)\n    self.line_8.setFrameShadow(QtWidgets.QFrame.Sunken)\n    self.line_8.setObjectName(\"line_8\")\n    self.line_7 = QtWidgets.QFrame(self.position_frame)\n    self.line_7.setGeometry(QtCore.QRect(0, 193, 601, 16))\n    self.line_7.setFrameShape(QtWidgets.QFrame.HLine)\n    self.line_7.setFrameShadow(QtWidgets.QFrame.Sunken)\n    self.line_7.setObjectName(\"line_7\")\n    self.line_9 = QtWidgets.QFrame(self.position_frame)\n    self.line_9.setGeometry(QtCore.QRect(33, 25, 20, 175))\n    self.line_9.setFrameShape(QtWidgets.QFrame.VLine)\n    self.line_9.setFrameShadow(QtWidgets.QFrame.Sunken)\n    self.line_9.setObjectName(\"line_9\")\n    self.label_2 = QtWidgets.QLabel(self.position_frame)\n    self.label_2.setGeometry(QtCore.QRect(50, 6, 61, 16))\n    self.label_2.setObjectName(\"label_2\")\n    self.name_label_p1 = QtWidgets.QLabel(self.position_frame)\n    self.name_label_p1.setGeometry(QtCore.QRect(48, 24, 181, 25))\n    font = QtGui.QFont()\n    font.setBold(False)\n    font.setWeight(50)\n    self.name_label_p1.setFont(font)\n    self.name_label_p1.setObjectName(\"name_label_p1\")\n    self.name_label_p2 = QtWidgets.QLabel(self.position_frame)\n    self.name_label_p2.setGeometry(QtCore.QRect(48, 49, 181, 25))\n    font = QtGui.QFont()\n    font.setBold(False)\n    font.setWeight(50)\n    self.name_label_p2.setFont(font)\n    self.name_label_p2.setObjectName(\"name_label_p2\")\n    self.name_label_p3 = QtWidgets.QLabel(self.position_frame)\n    self.name_label_p3.setGeometry(QtCore.QRect(48, 74, 181, 25))\n    font = QtGui.QFont()\n    font.setBold(False)\n    font.setWeight(50)\n    self.name_label_p3.setFont(font)\n    self.name_label_p3.setObjectName(\"name_label_p3\")\n    self.name_label_p4 = QtWidgets.QLabel(self.position_frame)\n    self.name_label_p4.setGeometry(QtCore.QRect(48, 99, 181, 25))\n    font = QtGui.QFont()\n    font.setBold(False)\n    font.setWeight(50)\n    self.name_label_p4.setFont(font)\n    self.name_label_p4.setObjectName(\"name_label_p4\")\n    self.name_label_p5 = QtWidgets.QLabel(self.position_frame)\n    self.name_label_p5.setGeometry(QtCore.QRect(48, 124, 181, 25))\n    font = QtGui.QFont()\n    font.setBold(False)\n    font.setWeight(50)\n    self.name_label_p5.setFont(font)\n    self.name_label_p5.setObjectName(\"name_label_p5\")\n    self.name_label_p6 = QtWidgets.QLabel(self.position_frame)\n    self.name_label_p6.setGeometry(QtCore.QRect(48, 149, 181, 25))\n    font = QtGui.QFont()\n    font.setBold(False)\n    font.setWeight(50)\n    self.name_label_p6.setFont(font)\n    self.name_label_p6.setObjectName(\"name_label_p6\")\n    self.name_label_p7 = QtWidgets.QLabel(self.position_frame)\n    self.name_label_p7.setGeometry(QtCore.QRect(48, 174, 181, 25))\n    font = QtGui.QFont()\n    font.setBold(False)\n    font.setWeight(50)\n    self.name_label_p7.setFont(font)\n    self.name_label_p7.setObjectName(\"name_label_p7\")\n    self.line_10 = QtWidgets.QFrame(self.position_frame)\n    self.line_10.setGeometry(QtCore.QRect(216, 25, 20, 175))\n    self.line_10.setFrameShape(QtWidgets.QFrame.VLine)\n    self.line_10.setFrameShadow(QtWidgets.QFrame.Sunken)\n    self.line_10.setObjectName(\"line_10\")\n    self.label_10 = QtWidgets.QLabel(self.position_frame)\n    self.label_10.setGeometry(QtCore.QRect(234, 0, 79, 25))\n    self.label_10.setObjectName(\"label_10\")\n    self.lap_label_p1 = QtWidgets.QLabel(self.position_frame)\n    self.lap_label_p1.setGeometry(QtCore.QRect(234, 30, 61, 16))\n    self.lap_label_p1.setAlignment(QtCore.Qt.AlignCenter)\n    self.lap_label_p1.setObjectName(\"lap_label_p1\")\n    self.line_11 = QtWidgets.QFrame(self.position_frame)\n    self.line_11.setGeometry(QtCore.QRect(288, 25, 20, 175))\n    self.line_11.setFrameShape(QtWidgets.QFrame.VLine)\n    self.line_11.setFrameShadow(QtWidgets.QFrame.Sunken)\n    self.line_11.setObjectName(\"line_11\")\n    self.label_12 = QtWidgets.QLabel(self.position_frame)\n    self.label_12.setGeometry(QtCore.QRect(312, 0, 37, 25))\n    self.label_12.setObjectName(\"label_12\")\n    self.lap_diff_p1 = QtWidgets.QLabel(self.position_frame)\n    self.lap_diff_p1.setGeometry(QtCore.QRect(306, 28, 67, 19))\n    self.lap_diff_p1.setToolTipDuration(0)\n    self.lap_diff_p1.setAlignment(QtCore.Qt.AlignLeading | QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter)\n    self.lap_diff_p1.setObjectName(\"lap_diff_p1\")\n    self.lap_label_p2 = QtWidgets.QLabel(self.position_frame)\n    self.lap_label_p2.setGeometry(QtCore.QRect(234, 55, 61, 16))\n    self.lap_label_p2.setAlignment(QtCore.Qt.AlignCenter)\n    self.lap_label_p2.setObjectName(\"lap_label_p2\")\n    self.lap_label_p3 = QtWidgets.QLabel(self.position_frame)\n    self.lap_label_p3.setGeometry(QtCore.QRect(234, 80, 61, 16))\n    self.lap_label_p3.setAlignment(QtCore.Qt.AlignCenter)\n    self.lap_label_p3.setObjectName(\"lap_label_p3\")\n    self.lap_label_p4 = QtWidgets.QLabel(self.position_frame)\n    self.lap_label_p4.setGeometry(QtCore.QRect(234, 105, 61, 16))\n    self.lap_label_p4.setAlignment(QtCore.Qt.AlignCenter)\n    self.lap_label_p4.setObjectName(\"lap_label_p4\")\n    self.lap_label_p5 = QtWidgets.QLabel(self.position_frame)\n    self.lap_label_p5.setGeometry(QtCore.QRect(234, 130, 61, 16))\n    self.lap_label_p5.setAlignment(QtCore.Qt.AlignCenter)\n    self.lap_label_p5.setObjectName(\"lap_label_p5\")\n    self.lap_label_p6 = QtWidgets.QLabel(self.position_frame)\n    self.lap_label_p6.setGeometry(QtCore.QRect(234, 155, 61, 16))\n    self.lap_label_p6.setAlignment(QtCore.Qt.AlignCenter)\n    self.lap_label_p6.setObjectName(\"lap_label_p6\")\n    self.lap_label_p7 = QtWidgets.QLabel(self.position_frame)\n    self.lap_label_p7.setGeometry(QtCore.QRect(234, 180, 61, 16))\n    self.lap_label_p7.setAlignment(QtCore.Qt.AlignCenter)\n    self.lap_label_p7.setObjectName(\"lap_label_p7\")\n    self.lap_diff_p2 = QtWidgets.QLabel(self.position_frame)\n    self.lap_diff_p2.setGeometry(QtCore.QRect(306, 53, 67, 19))\n    self.lap_diff_p2.setToolTipDuration(0)\n    self.lap_diff_p2.setAlignment(QtCore.Qt.AlignLeading | QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter)\n    self.lap_diff_p2.setObjectName(\"lap_diff_p2\")\n    self.lap_diff_p3 = QtWidgets.QLabel(self.position_frame)\n    self.lap_diff_p3.setGeometry(QtCore.QRect(306, 78, 67, 19))\n    self.lap_diff_p3.setToolTipDuration(0)\n    self.lap_diff_p3.setAlignment(QtCore.Qt.AlignLeading | QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter)\n    self.lap_diff_p3.setObjectName(\"lap_diff_p3\")\n    self.lap_diff_p4 = QtWidgets.QLabel(self.position_frame)\n    self.lap_diff_p4.setGeometry(QtCore.QRect(306, 103, 67, 19))\n    self.lap_diff_p4.setToolTipDuration(0)\n    self.lap_diff_p4.setAlignment(QtCore.Qt.AlignLeading | QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter)\n    self.lap_diff_p4.setObjectName(\"lap_diff_p4\")\n    self.lap_diff_p5 = QtWidgets.QLabel(self.position_frame)\n    self.lap_diff_p5.setGeometry(QtCore.QRect(306, 128, 67, 19))\n    self.lap_diff_p5.setToolTipDuration(0)\n    self.lap_diff_p5.setAlignment(QtCore.Qt.AlignLeading | QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter)\n    self.lap_diff_p5.setObjectName(\"lap_diff_p5\")\n    self.lap_diff_p6 = QtWidgets.QLabel(self.position_frame)\n    self.lap_diff_p6.setGeometry(QtCore.QRect(306, 153, 67, 19))\n    self.lap_diff_p6.setToolTipDuration(0)\n    self.lap_diff_p6.setAlignment(QtCore.Qt.AlignLeading | QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter)\n    self.lap_diff_p6.setObjectName(\"lap_diff_p6\")\n    self.lap_diff_p7 = QtWidgets.QLabel(self.position_frame)\n    self.lap_diff_p7.setGeometry(QtCore.QRect(306, 178, 67, 19))\n    self.lap_diff_p7.setToolTipDuration(0)\n    self.lap_diff_p7.setAlignment(QtCore.Qt.AlignLeading | QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter)\n    self.lap_diff_p7.setObjectName(\"lap_diff_p7\")\n    self.status_label = QtWidgets.QLabel(self.position_frame)\n    self.status_label.setGeometry(QtCore.QRect(6, 204, 337, 25))\n    font = QtGui.QFont()\n    font.setFamily(\"Segoe UI Semibold\")\n    font.setPointSize(10)\n    font.setBold(True)\n    font.setWeight(75)\n    self.status_label.setFont(font)\n    self.status_label.setText(\"\")\n    self.status_label.setObjectName(\"status_label\")\n    self.label_7 = QtWidgets.QLabel(self.position_frame)\n    self.label_7.setGeometry(QtCore.QRect(372, 0, 37, 25))\n    self.label_7.setObjectName(\"label_7\")\n    self.line_12 = QtWidgets.QFrame(self.position_frame)\n    self.line_12.setGeometry(QtCore.QRect(360, 25, 13, 175))\n    self.line_12.setFrameShape(QtWidgets.QFrame.VLine)\n    self.line_12.setFrameShadow(QtWidgets.QFrame.Sunken)\n    self.line_12.setObjectName(\"line_12\")\n    self.lap_complete_label_p1 = QtWidgets.QLabel(self.position_frame)\n    self.lap_complete_label_p1.setGeometry(QtCore.QRect(372, 28, 37, 19))\n    self.lap_complete_label_p1.setObjectName(\"lap_complete_label_p1\")\n    self.lap_complete_label_p2 = QtWidgets.QLabel(self.position_frame)\n    self.lap_complete_label_p2.setGeometry(QtCore.QRect(372, 53, 37, 19))\n    self.lap_complete_label_p2.setObjectName(\"lap_complete_label_p2\")\n    self.lap_complete_label_p3 = QtWidgets.QLabel(self.position_frame)\n    self.lap_complete_label_p3.setGeometry(QtCore.QRect(372, 78, 37, 19))\n    self.lap_complete_label_p3.setObjectName(\"lap_complete_label_p3\")\n    self.lap_complete_label_p4 = QtWidgets.QLabel(self.position_frame)\n    self.lap_complete_label_p4.setGeometry(QtCore.QRect(372, 103, 37, 19))\n    self.lap_complete_label_p4.setObjectName(\"lap_complete_label_p4\")\n    self.lap_complete_label_p5 = QtWidgets.QLabel(self.position_frame)\n    self.lap_complete_label_p5.setGeometry(QtCore.QRect(372, 128, 37, 19))\n    self.lap_complete_label_p5.setObjectName(\"lap_complete_label_p5\")\n    self.lap_complete_label_p6 = QtWidgets.QLabel(self.position_frame)\n    self.lap_complete_label_p6.setGeometry(QtCore.QRect(372, 153, 37, 19))\n    self.lap_complete_label_p6.setObjectName(\"lap_complete_label_p6\")\n    self.lap_complete_label_p7 = QtWidgets.QLabel(self.position_frame)\n    self.lap_complete_label_p7.setGeometry(QtCore.QRect(372, 178, 37, 19))\n    self.lap_complete_label_p7.setObjectName(\"lap_complete_label_p7\")\n    self.time_label = QtWidgets.QLabel(self.position_frame)\n    self.time_label.setGeometry(QtCore.QRect(348, 204, 85, 25))\n    font = QtGui.QFont()\n    font.setFamily(\"Tahoma\")\n    font.setPointSize(10)\n    font.setBold(True)\n    font.setWeight(75)\n    self.time_label.setFont(font)\n    self.time_label.setObjectName(\"time_label\")\n    self.ok_button = QtWidgets.QPushButton(self.position_frame)\n    self.ok_button.setGeometry(QtCore.QRect(192, 204, 85, 25))\n    self.ok_button.setStyleSheet(\"background-color: rgb(255, 0, 0);\\n\"\n", "code_toks_joined": "def setupUi ( self , RaceWindow ) : <NEWLINE> <INDENT> RaceWindow . setObjectName ( <STRING> ) <NEWLINE> RaceWindow . resize ( 462 , 456 ) <NEWLINE> icon = QtGui . QIcon ( ) <NEWLINE> icon . addPixmap ( QtGui . QPixmap ( <STRING> ) , QtGui . QIcon . Normal , QtGui . QIcon . Off ) <NEWLINE> RaceWindow . setWindowIcon ( icon ) <NEWLINE> self . centralwidget = QtWidgets . QWidget ( RaceWindow ) <NEWLINE> self . centralwidget . setObjectName ( <STRING> ) <NEWLINE> self . position_frame = QtWidgets . QFrame ( self . centralwidget ) <NEWLINE> self . position_frame . setGeometry ( QtCore . QRect ( 0 , 0 , 457 , 235 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setFamily ( <STRING> ) <NEWLINE> font . setPointSize ( 12 ) <NEWLINE> font . setBold ( True ) <NEWLINE> font . setWeight ( 75 ) <NEWLINE> self . position_frame . setFont ( font ) <NEWLINE> self . position_frame . setFrameShape ( QtWidgets . QFrame . StyledPanel ) <NEWLINE> self . position_frame . setFrameShadow ( QtWidgets . QFrame . Raised ) <NEWLINE> self . position_frame . setLineWidth ( 3 ) <NEWLINE> self . position_frame . setMidLineWidth ( 3 ) <NEWLINE> self . position_frame . setObjectName ( <STRING> ) <NEWLINE> self . label = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . label . setGeometry ( QtCore . QRect ( 10 , 6 , 31 , 16 ) ) <NEWLINE> self . label . setObjectName ( <STRING> ) <NEWLINE> self . pos_label_p1 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . pos_label_p1 . setGeometry ( QtCore . QRect ( 8 , 28 , 31 , 16 ) ) <NEWLINE> self . pos_label_p1 . setLayoutDirection ( QtCore . Qt . LeftToRight ) <NEWLINE> self . pos_label_p1 . setAlignment ( QtCore . Qt . AlignCenter ) <NEWLINE> self . pos_label_p1 . setObjectName ( <STRING> ) <NEWLINE> self . pos_label_p2 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . pos_label_p2 . setGeometry ( QtCore . QRect ( 8 , 53 , 31 , 16 ) ) <NEWLINE> self . pos_label_p2 . setAlignment ( QtCore . Qt . AlignCenter ) <NEWLINE> self . pos_label_p2 . setObjectName ( <STRING> ) <NEWLINE> self . pos_label_p3 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . pos_label_p3 . setGeometry ( QtCore . QRect ( 8 , 78 , 31 , 16 ) ) <NEWLINE> self . pos_label_p3 . setAlignment ( QtCore . Qt . AlignCenter ) <NEWLINE> self . pos_label_p3 . setObjectName ( <STRING> ) <NEWLINE> self . pos_label_p4 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . pos_label_p4 . setGeometry ( QtCore . QRect ( 8 , 103 , 31 , 16 ) ) <NEWLINE> self . pos_label_p4 . setAlignment ( QtCore . Qt . AlignCenter ) <NEWLINE> self . pos_label_p4 . setObjectName ( <STRING> ) <NEWLINE> self . pos_label_p5 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . pos_label_p5 . setGeometry ( QtCore . QRect ( 8 , 128 , 31 , 16 ) ) <NEWLINE> self . pos_label_p5 . setAlignment ( QtCore . Qt . AlignCenter ) <NEWLINE> self . pos_label_p5 . setObjectName ( <STRING> ) <NEWLINE> self . pos_label_p6 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . pos_label_p6 . setGeometry ( QtCore . QRect ( 8 , 153 , 31 , 16 ) ) <NEWLINE> self . pos_label_p6 . setAlignment ( QtCore . Qt . AlignCenter ) <NEWLINE> self . pos_label_p6 . setObjectName ( <STRING> ) <NEWLINE> self . pos_label_p7 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . pos_label_p7 . setGeometry ( QtCore . QRect ( 8 , 178 , 31 , 16 ) ) <NEWLINE> self . pos_label_p7 . setAlignment ( QtCore . Qt . AlignCenter ) <NEWLINE> self . pos_label_p7 . setObjectName ( <STRING> ) <NEWLINE> self . line = QtWidgets . QFrame ( self . position_frame ) <NEWLINE> self . line . setGeometry ( QtCore . QRect ( 0 , 18 , 601 , 16 ) ) <NEWLINE> self . line . setFrameShape ( QtWidgets . QFrame . HLine ) <NEWLINE> self . line . setFrameShadow ( QtWidgets . QFrame . Sunken ) <NEWLINE> self . line . setObjectName ( <STRING> ) <NEWLINE> self . line_2 = QtWidgets . QFrame ( self . position_frame ) <NEWLINE> self . line_2 . setGeometry ( QtCore . QRect ( 0 , 43 , 601 , 16 ) ) <NEWLINE> self . line_2 . setFrameShape ( QtWidgets . QFrame . HLine ) <NEWLINE> self . line_2 . setFrameShadow ( QtWidgets . QFrame . Sunken ) <NEWLINE> self . line_2 . setObjectName ( <STRING> ) <NEWLINE> self . line_3 = QtWidgets . QFrame ( self . position_frame ) <NEWLINE> self . line_3 . setGeometry ( QtCore . QRect ( 0 , 68 , 601 , 16 ) ) <NEWLINE> self . line_3 . setFrameShape ( QtWidgets . QFrame . HLine ) <NEWLINE> self . line_3 . setFrameShadow ( QtWidgets . QFrame . Sunken ) <NEWLINE> self . line_3 . setObjectName ( <STRING> ) <NEWLINE> self . line_4 = QtWidgets . QFrame ( self . position_frame ) <NEWLINE> self . line_4 . setGeometry ( QtCore . QRect ( 0 , 93 , 601 , 16 ) ) <NEWLINE> self . line_4 . setFrameShape ( QtWidgets . QFrame . HLine ) <NEWLINE> self . line_4 . setFrameShadow ( QtWidgets . QFrame . Sunken ) <NEWLINE> self . line_4 . setObjectName ( <STRING> ) <NEWLINE> self . line_5 = QtWidgets . QFrame ( self . position_frame ) <NEWLINE> self . line_5 . setGeometry ( QtCore . QRect ( 0 , 118 , 601 , 16 ) ) <NEWLINE> self . line_5 . setFrameShape ( QtWidgets . QFrame . HLine ) <NEWLINE> self . line_5 . setFrameShadow ( QtWidgets . QFrame . Sunken ) <NEWLINE> self . line_5 . setObjectName ( <STRING> ) <NEWLINE> self . line_6 = QtWidgets . QFrame ( self . position_frame ) <NEWLINE> self . line_6 . setGeometry ( QtCore . QRect ( 0 , 143 , 601 , 16 ) ) <NEWLINE> self . line_6 . setFrameShape ( QtWidgets . QFrame . HLine ) <NEWLINE> self . line_6 . setFrameShadow ( QtWidgets . QFrame . Sunken ) <NEWLINE> self . line_6 . setObjectName ( <STRING> ) <NEWLINE> self . line_8 = QtWidgets . QFrame ( self . position_frame ) <NEWLINE> self . line_8 . setGeometry ( QtCore . QRect ( 0 , 168 , 601 , 16 ) ) <NEWLINE> self . line_8 . setFrameShape ( QtWidgets . QFrame . HLine ) <NEWLINE> self . line_8 . setFrameShadow ( QtWidgets . QFrame . Sunken ) <NEWLINE> self . line_8 . setObjectName ( <STRING> ) <NEWLINE> self . line_7 = QtWidgets . QFrame ( self . position_frame ) <NEWLINE> self . line_7 . setGeometry ( QtCore . QRect ( 0 , 193 , 601 , 16 ) ) <NEWLINE> self . line_7 . setFrameShape ( QtWidgets . QFrame . HLine ) <NEWLINE> self . line_7 . setFrameShadow ( QtWidgets . QFrame . Sunken ) <NEWLINE> self . line_7 . setObjectName ( <STRING> ) <NEWLINE> self . line_9 = QtWidgets . QFrame ( self . position_frame ) <NEWLINE> self . line_9 . setGeometry ( QtCore . QRect ( 33 , 25 , 20 , 175 ) ) <NEWLINE> self . line_9 . setFrameShape ( QtWidgets . QFrame . VLine ) <NEWLINE> self . line_9 . setFrameShadow ( QtWidgets . QFrame . Sunken ) <NEWLINE> self . line_9 . setObjectName ( <STRING> ) <NEWLINE> self . label_2 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . label_2 . setGeometry ( QtCore . QRect ( 50 , 6 , 61 , 16 ) ) <NEWLINE> self . label_2 . setObjectName ( <STRING> ) <NEWLINE> self . name_label_p1 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . name_label_p1 . setGeometry ( QtCore . QRect ( 48 , 24 , 181 , 25 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setBold ( False ) <NEWLINE> font . setWeight ( 50 ) <NEWLINE> self . name_label_p1 . setFont ( font ) <NEWLINE> self . name_label_p1 . setObjectName ( <STRING> ) <NEWLINE> self . name_label_p2 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . name_label_p2 . setGeometry ( QtCore . QRect ( 48 , 49 , 181 , 25 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setBold ( False ) <NEWLINE> font . setWeight ( 50 ) <NEWLINE> self . name_label_p2 . setFont ( font ) <NEWLINE> self . name_label_p2 . setObjectName ( <STRING> ) <NEWLINE> self . name_label_p3 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . name_label_p3 . setGeometry ( QtCore . QRect ( 48 , 74 , 181 , 25 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setBold ( False ) <NEWLINE> font . setWeight ( 50 ) <NEWLINE> self . name_label_p3 . setFont ( font ) <NEWLINE> self . name_label_p3 . setObjectName ( <STRING> ) <NEWLINE> self . name_label_p4 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . name_label_p4 . setGeometry ( QtCore . QRect ( 48 , 99 , 181 , 25 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setBold ( False ) <NEWLINE> font . setWeight ( 50 ) <NEWLINE> self . name_label_p4 . setFont ( font ) <NEWLINE> self . name_label_p4 . setObjectName ( <STRING> ) <NEWLINE> self . name_label_p5 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . name_label_p5 . setGeometry ( QtCore . QRect ( 48 , 124 , 181 , 25 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setBold ( False ) <NEWLINE> font . setWeight ( 50 ) <NEWLINE> self . name_label_p5 . setFont ( font ) <NEWLINE> self . name_label_p5 . setObjectName ( <STRING> ) <NEWLINE> self . name_label_p6 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . name_label_p6 . setGeometry ( QtCore . QRect ( 48 , 149 , 181 , 25 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setBold ( False ) <NEWLINE> font . setWeight ( 50 ) <NEWLINE> self . name_label_p6 . setFont ( font ) <NEWLINE> self . name_label_p6 . setObjectName ( <STRING> ) <NEWLINE> self . name_label_p7 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . name_label_p7 . setGeometry ( QtCore . QRect ( 48 , 174 , 181 , 25 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setBold ( False ) <NEWLINE> font . setWeight ( 50 ) <NEWLINE> self . name_label_p7 . setFont ( font ) <NEWLINE> self . name_label_p7 . setObjectName ( <STRING> ) <NEWLINE> self . line_10 = QtWidgets . QFrame ( self . position_frame ) <NEWLINE> self . line_10 . setGeometry ( QtCore . QRect ( 216 , 25 , 20 , 175 ) ) <NEWLINE> self . line_10 . setFrameShape ( QtWidgets . QFrame . VLine ) <NEWLINE> self . line_10 . setFrameShadow ( QtWidgets . QFrame . Sunken ) <NEWLINE> self . line_10 . setObjectName ( <STRING> ) <NEWLINE> self . label_10 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . label_10 . setGeometry ( QtCore . QRect ( 234 , 0 , 79 , 25 ) ) <NEWLINE> self . label_10 . setObjectName ( <STRING> ) <NEWLINE> self . lap_label_p1 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . lap_label_p1 . setGeometry ( QtCore . QRect ( 234 , 30 , 61 , 16 ) ) <NEWLINE> self . lap_label_p1 . setAlignment ( QtCore . Qt . AlignCenter ) <NEWLINE> self . lap_label_p1 . setObjectName ( <STRING> ) <NEWLINE> self . line_11 = QtWidgets . QFrame ( self . position_frame ) <NEWLINE> self . line_11 . setGeometry ( QtCore . QRect ( 288 , 25 , 20 , 175 ) ) <NEWLINE> self . line_11 . setFrameShape ( QtWidgets . QFrame . VLine ) <NEWLINE> self . line_11 . setFrameShadow ( QtWidgets . QFrame . Sunken ) <NEWLINE> self . line_11 . setObjectName ( <STRING> ) <NEWLINE> self . label_12 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . label_12 . setGeometry ( QtCore . QRect ( 312 , 0 , 37 , 25 ) ) <NEWLINE> self . label_12 . setObjectName ( <STRING> ) <NEWLINE> self . lap_diff_p1 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . lap_diff_p1 . setGeometry ( QtCore . QRect ( 306 , 28 , 67 , 19 ) ) <NEWLINE> self . lap_diff_p1 . setToolTipDuration ( 0 ) <NEWLINE> self . lap_diff_p1 . setAlignment ( QtCore . Qt . AlignLeading | QtCore . Qt . AlignLeft | QtCore . Qt . AlignVCenter ) <NEWLINE> self . lap_diff_p1 . setObjectName ( <STRING> ) <NEWLINE> self . lap_label_p2 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . lap_label_p2 . setGeometry ( QtCore . QRect ( 234 , 55 , 61 , 16 ) ) <NEWLINE> self . lap_label_p2 . setAlignment ( QtCore . Qt . AlignCenter ) <NEWLINE> self . lap_label_p2 . setObjectName ( <STRING> ) <NEWLINE> self . lap_label_p3 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . lap_label_p3 . setGeometry ( QtCore . QRect ( 234 , 80 , 61 , 16 ) ) <NEWLINE> self . lap_label_p3 . setAlignment ( QtCore . Qt . AlignCenter ) <NEWLINE> self . lap_label_p3 . setObjectName ( <STRING> ) <NEWLINE> self . lap_label_p4 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . lap_label_p4 . setGeometry ( QtCore . QRect ( 234 , 105 , 61 , 16 ) ) <NEWLINE> self . lap_label_p4 . setAlignment ( QtCore . Qt . AlignCenter ) <NEWLINE> self . lap_label_p4 . setObjectName ( <STRING> ) <NEWLINE> self . lap_label_p5 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . lap_label_p5 . setGeometry ( QtCore . QRect ( 234 , 130 , 61 , 16 ) ) <NEWLINE> self . lap_label_p5 . setAlignment ( QtCore . Qt . AlignCenter ) <NEWLINE> self . lap_label_p5 . setObjectName ( <STRING> ) <NEWLINE> self . lap_label_p6 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . lap_label_p6 . setGeometry ( QtCore . QRect ( 234 , 155 , 61 , 16 ) ) <NEWLINE> self . lap_label_p6 . setAlignment ( QtCore . Qt . AlignCenter ) <NEWLINE> self . lap_label_p6 . setObjectName ( <STRING> ) <NEWLINE> self . lap_label_p7 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . lap_label_p7 . setGeometry ( QtCore . QRect ( 234 , 180 , 61 , 16 ) ) <NEWLINE> self . lap_label_p7 . setAlignment ( QtCore . Qt . AlignCenter ) <NEWLINE> self . lap_label_p7 . setObjectName ( <STRING> ) <NEWLINE> self . lap_diff_p2 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . lap_diff_p2 . setGeometry ( QtCore . QRect ( 306 , 53 , 67 , 19 ) ) <NEWLINE> self . lap_diff_p2 . setToolTipDuration ( 0 ) <NEWLINE> self . lap_diff_p2 . setAlignment ( QtCore . Qt . AlignLeading | QtCore . Qt . AlignLeft | QtCore . Qt . AlignVCenter ) <NEWLINE> self . lap_diff_p2 . setObjectName ( <STRING> ) <NEWLINE> self . lap_diff_p3 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . lap_diff_p3 . setGeometry ( QtCore . QRect ( 306 , 78 , 67 , 19 ) ) <NEWLINE> self . lap_diff_p3 . setToolTipDuration ( 0 ) <NEWLINE> self . lap_diff_p3 . setAlignment ( QtCore . Qt . AlignLeading | QtCore . Qt . AlignLeft | QtCore . Qt . AlignVCenter ) <NEWLINE> self . lap_diff_p3 . setObjectName ( <STRING> ) <NEWLINE> self . lap_diff_p4 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . lap_diff_p4 . setGeometry ( QtCore . QRect ( 306 , 103 , 67 , 19 ) ) <NEWLINE> self . lap_diff_p4 . setToolTipDuration ( 0 ) <NEWLINE> self . lap_diff_p4 . setAlignment ( QtCore . Qt . AlignLeading | QtCore . Qt . AlignLeft | QtCore . Qt . AlignVCenter ) <NEWLINE> self . lap_diff_p4 . setObjectName ( <STRING> ) <NEWLINE> self . lap_diff_p5 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . lap_diff_p5 . setGeometry ( QtCore . QRect ( 306 , 128 , 67 , 19 ) ) <NEWLINE> self . lap_diff_p5 . setToolTipDuration ( 0 ) <NEWLINE> self . lap_diff_p5 . setAlignment ( QtCore . Qt . AlignLeading | QtCore . Qt . AlignLeft | QtCore . Qt . AlignVCenter ) <NEWLINE> self . lap_diff_p5 . setObjectName ( <STRING> ) <NEWLINE> self . lap_diff_p6 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . lap_diff_p6 . setGeometry ( QtCore . QRect ( 306 , 153 , 67 , 19 ) ) <NEWLINE> self . lap_diff_p6 . setToolTipDuration ( 0 ) <NEWLINE> self . lap_diff_p6 . setAlignment ( QtCore . Qt . AlignLeading | QtCore . Qt . AlignLeft | QtCore . Qt . AlignVCenter ) <NEWLINE> self . lap_diff_p6 . setObjectName ( <STRING> ) <NEWLINE> self . lap_diff_p7 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . lap_diff_p7 . setGeometry ( QtCore . QRect ( 306 , 178 , 67 , 19 ) ) <NEWLINE> self . lap_diff_p7 . setToolTipDuration ( 0 ) <NEWLINE> self . lap_diff_p7 . setAlignment ( QtCore . Qt . AlignLeading | QtCore . Qt . AlignLeft | QtCore . Qt . AlignVCenter ) <NEWLINE> self . lap_diff_p7 . setObjectName ( <STRING> ) <NEWLINE> self . status_label = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . status_label . setGeometry ( QtCore . QRect ( 6 , 204 , 337 , 25 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setFamily ( <STRING> ) <NEWLINE> font . setPointSize ( 10 ) <NEWLINE> font . setBold ( True ) <NEWLINE> font . setWeight ( 75 ) <NEWLINE> self . status_label . setFont ( font ) <NEWLINE> self . status_label . setText ( <STRING> ) <NEWLINE> self . status_label . setObjectName ( <STRING> ) <NEWLINE> self . label_7 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . label_7 . setGeometry ( QtCore . QRect ( 372 , 0 , 37 , 25 ) ) <NEWLINE> self . label_7 . setObjectName ( <STRING> ) <NEWLINE> self . line_12 = QtWidgets . QFrame ( self . position_frame ) <NEWLINE> self . line_12 . setGeometry ( QtCore . QRect ( 360 , 25 , 13 , 175 ) ) <NEWLINE> self . line_12 . setFrameShape ( QtWidgets . QFrame . VLine ) <NEWLINE> self . line_12 . setFrameShadow ( QtWidgets . QFrame . Sunken ) <NEWLINE> self . line_12 . setObjectName ( <STRING> ) <NEWLINE> self . lap_complete_label_p1 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . lap_complete_label_p1 . setGeometry ( QtCore . QRect ( 372 , 28 , 37 , 19 ) ) <NEWLINE> self . lap_complete_label_p1 . setObjectName ( <STRING> ) <NEWLINE> self . lap_complete_label_p2 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . lap_complete_label_p2 . setGeometry ( QtCore . QRect ( 372 , 53 , 37 , 19 ) ) <NEWLINE> self . lap_complete_label_p2 . setObjectName ( <STRING> ) <NEWLINE> self . lap_complete_label_p3 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . lap_complete_label_p3 . setGeometry ( QtCore . QRect ( 372 , 78 , 37 , 19 ) ) <NEWLINE> self . lap_complete_label_p3 . setObjectName ( <STRING> ) <NEWLINE> self . lap_complete_label_p4 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . lap_complete_label_p4 . setGeometry ( QtCore . QRect ( 372 , 103 , 37 , 19 ) ) <NEWLINE> self . lap_complete_label_p4 . setObjectName ( <STRING> ) <NEWLINE> self . lap_complete_label_p5 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . lap_complete_label_p5 . setGeometry ( QtCore . QRect ( 372 , 128 , 37 , 19 ) ) <NEWLINE> self . lap_complete_label_p5 . setObjectName ( <STRING> ) <NEWLINE> self . lap_complete_label_p6 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . lap_complete_label_p6 . setGeometry ( QtCore . QRect ( 372 , 153 , 37 , 19 ) ) <NEWLINE> self . lap_complete_label_p6 . setObjectName ( <STRING> ) <NEWLINE> self . lap_complete_label_p7 = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . lap_complete_label_p7 . setGeometry ( QtCore . QRect ( 372 , 178 , 37 , 19 ) ) <NEWLINE> self . lap_complete_label_p7 . setObjectName ( <STRING> ) <NEWLINE> self . time_label = QtWidgets . QLabel ( self . position_frame ) <NEWLINE> self . time_label . setGeometry ( QtCore . QRect ( 348 , 204 , 85 , 25 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setFamily ( <STRING> ) <NEWLINE> font . setPointSize ( 10 ) <NEWLINE> font . setBold ( True ) <NEWLINE> font . setWeight ( 75 ) <NEWLINE> self . time_label . setFont ( font ) <NEWLINE> self . time_label . setObjectName ( <STRING> ) <NEWLINE> self . ok_button = QtWidgets . QPushButton ( self . position_frame ) <NEWLINE> self . ok_button . setGeometry ( QtCore . QRect ( 192 , 204 , 85 , 25 ) ) <NEWLINE> self . ok_button . setStyleSheet ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"RaceWindow\"", "\"logo.png\"", "\"centralwidget\"", "\"Segoe UI Semibold\"", "\"position_frame\"", "\"label\"", "\"pos_label_p1\"", "\"pos_label_p2\"", "\"pos_label_p3\"", "\"pos_label_p4\"", "\"pos_label_p5\"", "\"pos_label_p6\"", "\"pos_label_p7\"", "\"line\"", "\"line_2\"", "\"line_3\"", "\"line_4\"", "\"line_5\"", "\"line_6\"", "\"line_8\"", "\"line_7\"", "\"line_9\"", "\"label_2\"", "\"name_label_p1\"", "\"name_label_p2\"", "\"name_label_p3\"", "\"name_label_p4\"", "\"name_label_p5\"", "\"name_label_p6\"", "\"name_label_p7\"", "\"line_10\"", "\"label_10\"", "\"lap_label_p1\"", "\"line_11\"", "\"label_12\"", "\"lap_diff_p1\"", "\"lap_label_p2\"", "\"lap_label_p3\"", "\"lap_label_p4\"", "\"lap_label_p5\"", "\"lap_label_p6\"", "\"lap_label_p7\"", "\"lap_diff_p2\"", "\"lap_diff_p3\"", "\"lap_diff_p4\"", "\"lap_diff_p5\"", "\"lap_diff_p6\"", "\"lap_diff_p7\"", "\"Segoe UI Semibold\"", "\"\"", "\"status_label\"", "\"label_7\"", "\"line_12\"", "\"lap_complete_label_p1\"", "\"lap_complete_label_p2\"", "\"lap_complete_label_p3\"", "\"lap_complete_label_p4\"", "\"lap_complete_label_p5\"", "\"lap_complete_label_p6\"", "\"lap_complete_label_p7\"", "\"Tahoma\"", "\"time_label\"", "\"background-color: rgb(255, 0, 0);\\n\""]}, "window_span": [3583, 3587], "err_obj": {"msg": "unbalanced (){}[]"}}], ["80137fc763ef8e31424b23423344c015", {"code_string": "def testForceGPU(self):\n    with self.assertRaisesRegexp(errors.InvalidArgumentError,\n        \"Cannot assign a device to node\"):\n        with self.test_session(force_gpu = True):\n        x = [True]\n        y = [15]\n        logging_ops.Assert(x, y).run()\n", "code_toks_joined": "def testForceGPU ( self ) : <NEWLINE> <INDENT> with self . assertRaisesRegexp ( errors . InvalidArgumentError , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> with self . test_session ( force_gpu = True ) : <NEWLINE> x = [ True ] <NEWLINE> y = [ 15 ] <NEWLINE> logging_ops . Assert ( x , y ) . run ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Cannot assign a device to node\""]}, "err_obj": {"msg": "expected an indented block"}}], ["ae7e68cdeae9d2e0d7d0aa0bc6d1dc0c", {"code_string": "def test_del_components_success(self):\n    with patch('org.o3project.odenos.core.util.remote_object_interface.'\n        'RemoteObjectInterface._del_object_to_remote_object'\n        ) as m_del_object:\n        self.result = self.target.del_components(\"CompId1\")\n        self.assertEqual(m_del_object.call_count, 1)\n        m_del_object.assert_any_call(SystemManagerInterface.\n            COMP_PATH % \"CompId1\")\n            self.assertNotEqual(self.result, None)\n", "code_toks_joined": "def test_del_components_success ( self ) : <NEWLINE> <INDENT> with patch ( <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> ) as m_del_object : <NEWLINE> self . result = self . target . del_components ( <STRING> ) <NEWLINE> self . assertEqual ( m_del_object . call_count , 1 ) <NEWLINE> m_del_object . assert_any_call ( SystemManagerInterface . <NEWLINE> <INDENT> COMP_PATH % <STRING> ) <NEWLINE> self . assertNotEqual ( self . result , None ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'org.o3project.odenos.core.util.remote_object_interface.'", "'RemoteObjectInterface._del_object_to_remote_object'", "\"CompId1\"", "\"CompId1\""]}, "err_obj": {"msg": "unexpected indent"}}], ["6cc3676a485d35b511c599d27c67b701", {"code_string": "def docs():\n    sort_docs = '<br><br>'.join(sorted([' '.join(('<b>' + k + '</b>', v) for k, v in hmserv.sort_docs.items()]))\n    base_url = 'http: //' + request.host\n    page = \"\"\"<!doctype html>\"\"\".format(prov_url = base_url + ext_path + '/prov/',\n        explore_url = base_url + ext_path + '/explore/',\n        sort_docs = sort_docs)\n    return page\n", "code_toks_joined": "def docs ( ) : <NEWLINE> <INDENT> sort_docs = <STRING> . join ( sorted ( [ <STRING> . join ( ( <STRING> + k + <STRING> , v ) for k , v in hmserv . sort_docs . items ( ) ] ) ) <NEWLINE> base_url = <STRING> + request . host <NEWLINE> page = <STRING> . format ( prov_url = base_url + ext_path + <STRING> , <NEWLINE> <INDENT> explore_url = base_url + ext_path + <STRING> , <NEWLINE> sort_docs = sort_docs ) <NEWLINE> <DEDENT> return page <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'<br><br>'", "' '", "'<b>'", "'</b>'", "'http: //'", "\"\"\"<!doctype html>\"\"\"", "'/prov/'", "'/explore/'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["5934ae6d621f6113791fb2688c546b23", {"code_string": "def validate(data):\n    data = data.lower()\n    print(data)\n    if data.startswith('insert '):\n        cmd_type = 'insert'\n            return bool(insertValidator.match(data))\n    if data.startswith('select '):\n        cmd_type = 'select'\n            return bool(selectValidator.match(data))\n    return False\n", "code_toks_joined": "def validate ( data ) : <NEWLINE> <INDENT> data = data . lower ( ) <NEWLINE> print ( data ) <NEWLINE> if data . startswith ( <STRING> ) : <NEWLINE> <INDENT> cmd_type = <STRING> <NEWLINE> <INDENT> return bool ( insertValidator . match ( data ) ) <NEWLINE> <DEDENT> <DEDENT> if data . startswith ( <STRING> ) : <NEWLINE> <INDENT> cmd_type = <STRING> <NEWLINE> <INDENT> return bool ( selectValidator . match ( data ) ) <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'insert '", "'insert'", "'select '", "'select'"]}, "err_obj": {"msg": "unexpected indent"}}], ["8e079631fcacac2d9c6c7e87ebe6fc99", {"code_string": "def getNamed(type, name):\n    \"\"\"Get a texture of the particular type\"\"\"\n    for t in ptextures[type]:\n    if t.getName() == name:\n        return t\n    return None\n", "code_toks_joined": "def getNamed ( type , name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for t in ptextures [ type ] : <NEWLINE> if t . getName ( ) == name : <NEWLINE> <INDENT> return t <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get a texture of the particular type\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["3b4f7876f78236f9a7d8f6c629d753b9", {"code_string": "def _GetDebugInfoPostbuilds(self, configname, output, output_binary, quiet):\n    \"\"\"Returns a list of shell commands that contain the shell commands\"\"\"\n    self.configname = configname\n    result = []\n    if(self._Test('GCC_GENERATE_DEBUGGING_SYMBOLS', 'YES', default = 'YES') and\n        self._Test(\n            'DEBUG_INFORMATION_FORMAT', 'dwarf-with-dsym', default = 'dwarf') and\n        self.spec['type'] != 'static_library'):\n        if not quiet:\n        result.append('echo DSYMUTIL\\\\(%s\\\\)' % self.spec['target_name'])\n        result.append('dsymutil %s -o %s' %(output_binary, output + '.dSYM'))\n    self.configname = None\n    return result\n", "code_toks_joined": "def _GetDebugInfoPostbuilds ( self , configname , output , output_binary , quiet ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . configname = configname <NEWLINE> result = [ ] <NEWLINE> if ( self . _Test ( <STRING> , <STRING> , default = <STRING> ) and <NEWLINE> <INDENT> self . _Test ( <NEWLINE> <INDENT> <STRING> , <STRING> , default = <STRING> ) and <NEWLINE> <DEDENT> self . spec [ <STRING> ] != <STRING> ) : <NEWLINE> if not quiet : <NEWLINE> result . append ( <STRING> % self . spec [ <STRING> ] ) <NEWLINE> result . append ( <STRING> % ( output_binary , output + <STRING> ) ) <NEWLINE> <DEDENT> self . configname = None <NEWLINE> return result <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns a list of shell commands that contain the shell commands\"\"\"", "'GCC_GENERATE_DEBUGGING_SYMBOLS'", "'YES'", "'YES'", "'DEBUG_INFORMATION_FORMAT'", "'dwarf-with-dsym'", "'dwarf'", "'type'", "'static_library'", "'echo DSYMUTIL\\\\(%s\\\\)'", "'target_name'", "'dsymutil %s -o %s'", "'.dSYM'"]}, "err_obj": {"msg": "expected an indented block"}}], ["42c3743da37876647f8aeb0359cf65e6", {"code_string": "class AutoRestParameterFlatteningConfiguration(Configuration):\n    \"\"\"Configuration for AutoRestParameterFlattening\"\"\"\n    def __init__(\n        self, base_url = None):\n        if not base_url:\n        base_url = 'http://localhost'\n        super(AutoRestParameterFlatteningConfiguration, self).__init__(base_url)\n        self.add_user_agent('autorestparameterflattening/{}'.format(VERSION))\n", "code_toks_joined": "class AutoRestParameterFlatteningConfiguration ( Configuration ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( <NEWLINE> <INDENT> self , base_url = None ) : <NEWLINE> if not base_url : <NEWLINE> base_url = <STRING> <NEWLINE> super ( AutoRestParameterFlatteningConfiguration , self ) . __init__ ( base_url ) <NEWLINE> self . add_user_agent ( <STRING> . format ( VERSION ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Configuration for AutoRestParameterFlattening\"\"\"", "'http://localhost'", "'autorestparameterflattening/{}'"]}, "err_obj": {"msg": "expected an indented block"}}], ["67210a1ca34b746b073f710bf63a821b", {"code_string": "class TestMl2BulkToggleWithoutBulkless(Ml2PluginV2TestCase):\n    _mechanism_drivers = ['logger', 'test']\n    def test_bulk_enabled_with_bulk_drivers(self)\n        self.assertFalse(self._skip_native_bulk)\n", "code_toks_joined": "class TestMl2BulkToggleWithoutBulkless ( Ml2PluginV2TestCase ) : <NEWLINE> <INDENT> _mechanism_drivers = [ <STRING> , <STRING> ] <NEWLINE> def test_bulk_enabled_with_bulk_drivers ( self ) <NEWLINE> <INDENT> self . assertFalse ( self . _skip_native_bulk ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'logger'", "'test'"]}, "err_obj": {"msg": "invalid syntax"}}], ["38a2820003eee9bbfa56c38d664a3c82", {"code_string": "def _map_trans((ds, img, ylo, yhi)):\n    print('computing transformation in PID', os.getpid())\n    return ds._computeTransformation(img, ylo, yhi)\n", "code_toks_joined": "def _map_trans ( ( ds , img , ylo , yhi ) ) : <NEWLINE> <INDENT> print ( <STRING> , os . getpid ( ) ) <NEWLINE> return ds . _computeTransformation ( img , ylo , yhi ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'computing transformation in PID'"]}, "err_obj": {"msg": "invalid syntax"}}], ["13375f1cc26a098035708c700e70f92e", {"code_string": "def init_1wire():\n    cmd = \"digitemp -i -q -o\\\"T %R %N %.2C\\\" -O\\\"C %R %N %n %C\\\"\"\n    for outline in os.popen(cmd).readlines()\n        outline = outline[: - 1];\n        print(outline)\n", "code_toks_joined": "def init_1wire ( ) : <NEWLINE> <INDENT> cmd = <STRING> <NEWLINE> for outline in os . popen ( cmd ) . readlines ( ) <NEWLINE> <INDENT> outline = outline [ : - 1 ] ; <NEWLINE> print ( outline ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"digitemp -i -q -o\\\"T %R %N %.2C\\\" -O\\\"C %R %N %n %C\\\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["e6e33f4b943f120858d00a642705b557", {"code_string": "def htmlBalloonTallyRow(party, who):\n    candidate = reader.candidates['byname'][party][who['name']]\n    return '''<tr>''' %(\n    formatNumber(who['votes']),\n    candidate['color'],\n    iconBaseUrl + who['name'] + '-border.png',\n    candidate['fullName']\n", "code_toks_joined": "def htmlBalloonTallyRow ( party , who ) : <NEWLINE> <INDENT> candidate = reader . candidates [ <STRING> ] [ party ] [ who [ <STRING> ] ] <NEWLINE> return <STRING> % ( <NEWLINE> formatNumber ( who [ <STRING> ] ) , <NEWLINE> candidate [ <STRING> ] , <NEWLINE> iconBaseUrl + who [ <STRING> ] + <STRING> , <NEWLINE> candidate [ <STRING> ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'byname'", "'name'", "'''<tr>'''", "'votes'", "'color'", "'name'", "'-border.png'", "'fullName'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["de2ba6930dff8d0bc683e4db16729f17", {"code_string": "def analyzeHTMLText(doc, resource, p, section, id):\n    words = 0\n    try:\n    content = p.content\n    words = words + addStringHTML(content, resource, id, section, 5)\n    except:\n        return - 1\n    return words\n", "code_toks_joined": "def analyzeHTMLText ( doc , resource , p , section , id ) : <NEWLINE> <INDENT> words = 0 <NEWLINE> try : <NEWLINE> content = p . content <NEWLINE> words = words + addStringHTML ( content , resource , id , section , 5 ) <NEWLINE> except : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> return words <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["bea1c18c3cefdf425868c2cc776f4810", {"code_string": "def setup_frame_w_accel_label(txt, target_widget = None):\n    '''Return a frame with a mnemonic label'''\n    l = gtk.Label(txt)\n    l.set_use_underline(True)\n    f = gtk.Frame()\n    f.set_label_widget(l); l.show()\n    if target_widget:\n    l.set_mnemonic_widget(target_widget)\n    return f\n", "code_toks_joined": "def setup_frame_w_accel_label ( txt , target_widget = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> l = gtk . Label ( txt ) <NEWLINE> l . set_use_underline ( True ) <NEWLINE> f = gtk . Frame ( ) <NEWLINE> f . set_label_widget ( l ) ; l . show ( ) <NEWLINE> if target_widget : <NEWLINE> l . set_mnemonic_widget ( target_widget ) <NEWLINE> return f <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Return a frame with a mnemonic label'''"]}, "err_obj": {"msg": "expected an indented block"}}], ["2173326bf986ba26a20899adfa4bc05f", {"code_string": "def deploy():\n    with lcd('/path/to/prod/area')\n        local('git checkout master && git pull')\n        local('python manage.py migrate')\n        local('python manage.py test')\n        local('sudo restart httpd graceful')\n", "code_toks_joined": "def deploy ( ) : <NEWLINE> <INDENT> with lcd ( <STRING> ) <NEWLINE> <INDENT> local ( <STRING> ) <NEWLINE> local ( <STRING> ) <NEWLINE> local ( <STRING> ) <NEWLINE> local ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'/path/to/prod/area'", "'git checkout master && git pull'", "'python manage.py migrate'", "'python manage.py test'", "'sudo restart httpd graceful'"]}, "err_obj": {"msg": "invalid syntax"}}], ["07f21ba89508db29b9ebd3ee38925109", {"code_string": "class AutoRestSwaggerBATServiceConfiguration(Configuration):\n    \"\"\"Configuration for AutoRestSwaggerBATService\"\"\"\n    def __init__(\n        self, base_url = None):\n        if not base_url:\n        base_url = 'http://localhost'\n        super(AutoRestSwaggerBATServiceConfiguration, self).__init__(base_url)\n        self.add_user_agent('autorestswaggerbatservice/{}'.format(VERSION))\n", "code_toks_joined": "class AutoRestSwaggerBATServiceConfiguration ( Configuration ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( <NEWLINE> <INDENT> self , base_url = None ) : <NEWLINE> if not base_url : <NEWLINE> base_url = <STRING> <NEWLINE> super ( AutoRestSwaggerBATServiceConfiguration , self ) . __init__ ( base_url ) <NEWLINE> self . add_user_agent ( <STRING> . format ( VERSION ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Configuration for AutoRestSwaggerBATService\"\"\"", "'http://localhost'", "'autorestswaggerbatservice/{}'"]}, "err_obj": {"msg": "expected an indented block"}}], ["85cd40f62763a40b8cba41f010a4f1e2", {"code_string": "def usermgt_sendmail(to_users, key):\n    send_mail('Reset Your Password!', 'click the url http://%s/cgi-bin/usermgt/regain/?active_key=%s' %(DOMAIN_NAME, key)\n        EMAIL_HOST_USER, to_users)\n    thread.exit_thread()\n", "code_toks_joined": "def usermgt_sendmail ( to_users , key ) : <NEWLINE> <INDENT> send_mail ( <STRING> , <STRING> % ( DOMAIN_NAME , key ) <NEWLINE> <INDENT> EMAIL_HOST_USER , to_users ) <NEWLINE> <DEDENT> thread . exit_thread ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Reset Your Password!'", "'click the url http://%s/cgi-bin/usermgt/regain/?active_key=%s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["f4e673a09965f18efbb87852da0b2dac", {"code_string": "def IsSupported(self):\n    \"\"\"Ensure that we support the given platform.\"\"\"\n    if(self.operating_system == OperatingSystem.CYGWIN and\n        self.architecture == Architecture.x86_64):\n        sys.stderr.write('ERROR: Cygwin 64 bit is not supported by the Google '\n            'Cloud SDK.  Please use a 32 bit version of Cygwin.')\n            return False\n    return True\n", "code_toks_joined": "def IsSupported ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( self . operating_system == OperatingSystem . CYGWIN and <NEWLINE> <INDENT> self . architecture == Architecture . x86_64 ) : <NEWLINE> sys . stderr . write ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Ensure that we support the given platform.\"\"\"", "'ERROR: Cygwin 64 bit is not supported by the Google '", "'Cloud SDK.  Please use a 32 bit version of Cygwin.'"]}, "err_obj": {"msg": "unexpected indent"}}], ["f2db9366175d42fd0f0bdbac22685413", {"code_string": "class GroupMember(db.Model):\n    name = db.StringProperty()\n    group = db.StringProperty()\n    def todict(s, d):\n    d['name'] = s.name\n    d['group'] = s.group\n", "code_toks_joined": "class GroupMember ( db . Model ) : <NEWLINE> <INDENT> name = db . StringProperty ( ) <NEWLINE> group = db . StringProperty ( ) <NEWLINE> def todict ( s , d ) : <NEWLINE> d [ <STRING> ] = s . name <NEWLINE> d [ <STRING> ] = s . group <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'name'", "'group'"]}, "err_obj": {"msg": "expected an indented block"}}], ["64ad7939ff33e59849bf8483aa474c06", {"code_string": "def check_command_line_args():\n    if len(sys.argv) < 3:\n    print_usage_and_exit()\n    if not os.path.isfile(sys.argv[1]):\n        print_err(\"ERROR: \" + sys.argv[1] + \" is not a file\")\n        print_usage_and_exit()\n    if not is_number(sys.argv[2]):\n        print_err(\"ERROR: \" + sys.argv[2] + \" is not a number\")\n        print_usage_and_exit()\n    return sys.argv[1], float(sys.argv[2])\n", "code_toks_joined": "def check_command_line_args ( ) : <NEWLINE> <INDENT> if len ( sys . argv ) < 3 : <NEWLINE> print_usage_and_exit ( ) <NEWLINE> if not os . path . isfile ( sys . argv [ 1 ] ) : <NEWLINE> <INDENT> print_err ( <STRING> + sys . argv [ 1 ] + <STRING> ) <NEWLINE> print_usage_and_exit ( ) <NEWLINE> <DEDENT> if not is_number ( sys . argv [ 2 ] ) : <NEWLINE> <INDENT> print_err ( <STRING> + sys . argv [ 2 ] + <STRING> ) <NEWLINE> print_usage_and_exit ( ) <NEWLINE> <DEDENT> return sys . argv [ 1 ] , float ( sys . argv [ 2 ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"ERROR: \"", "\" is not a file\"", "\"ERROR: \"", "\" is not a number\""]}, "err_obj": {"msg": "expected an indented block"}}], ["3fc58ab3e7708f458945eae590278067", {"code_string": "def __setstate__(self, (subject, items)):\n    self.clear()\n    self.update(dict(items))\n    self.subject = mkRef(subject)\n", "code_toks_joined": "def __setstate__ ( self , ( subject , items ) ) : <NEWLINE> <INDENT> self . clear ( ) <NEWLINE> self . update ( dict ( items ) ) <NEWLINE> self . subject = mkRef ( subject ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["bdaa1be2274540dcec878f92bd3c3a64", {"code_string": "def judge(self, (share_count, weights_list, total_weight, total_donation_weight), (max_shares, desired_weight)):\n    if share_count > max_shares or total_weight > desired_weight:\n        return 1\n    elif share_count == max_shares or total_weight == desired_weight:\n        return 0\n    else:\n        return - 1\n", "code_toks_joined": "def judge ( self , ( share_count , weights_list , total_weight , total_donation_weight ) , ( max_shares , desired_weight ) ) : <NEWLINE> <INDENT> if share_count > max_shares or total_weight > desired_weight : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif share_count == max_shares or total_weight == desired_weight : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["0f46b9cfbf700696c1aaf1414164c785", {"code_string": "def mult_matrix((a1, b1, c1, d1, e1, f1), (a0, b0, c0, d0, e0, f0)):\n    '''Multiplies two matrices.'''\n    return(a0 * a1 + c0 * b1, b0 * a1 + d0 * b1,\n        a0 * c1 + c0 * d1, b0 * c1 + d0 * d1,\n        a0 * e1 + c0 * f1 + e0, b0 * e1 + d0 * f1 + f0)\n", "code_toks_joined": "def mult_matrix ( ( a1 , b1 , c1 , d1 , e1 , f1 ) , ( a0 , b0 , c0 , d0 , e0 , f0 ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return ( a0 * a1 + c0 * b1 , b0 * a1 + d0 * b1 , <NEWLINE> <INDENT> a0 * c1 + c0 * d1 , b0 * c1 + d0 * d1 , <NEWLINE> a0 * e1 + c0 * f1 + e0 , b0 * e1 + d0 * f1 + f0 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Multiplies two matrices.'''"]}, "err_obj": {"msg": "invalid syntax"}}], ["48ca7ee037ff2062a0d891045c439081", {"code_string": "def pinEntered(self, result4):\n    if result4 is None:\n        self.closeProtectedScreen()\n    elif not result4:\n        self.session.openWithCallback(self.close(), MessageBox, _(\"The pin code you entered is wrong.\"), MessageBox.TYPE_ERROR, timeout = 3)\n            else:\n                self.checkNetworkState()\n", "code_toks_joined": "def pinEntered ( self , result4 ) : <NEWLINE> <INDENT> if result4 is None : <NEWLINE> <INDENT> self . closeProtectedScreen ( ) <NEWLINE> <DEDENT> elif not result4 : <NEWLINE> <INDENT> self . session . openWithCallback ( self . close ( ) , MessageBox , _ ( <STRING> ) , MessageBox . TYPE_ERROR , timeout = 3 ) <NEWLINE> <INDENT> else : <NEWLINE> <INDENT> self . checkNetworkState ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"The pin code you entered is wrong.\""]}, "err_obj": {"msg": "unexpected indent"}}], ["cc9e3bceb2336aa1370e20de807a6c59", {"code_string": "def VerifyEditablePaths(cls, paths):\n    \"\"\"Returns true if source already opened for editing.\"\"\"\n    for doc in appdata.documents:\n        for p in doc.paths:\n            if p in paths:\n                Notify(cls.msg_cantedit.format(p)\n                return False\n    return True\n", "code_toks_joined": "def VerifyEditablePaths ( cls , paths ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for doc in appdata . documents : <NEWLINE> <INDENT> for p in doc . paths : <NEWLINE> <INDENT> if p in paths : <NEWLINE> <INDENT> Notify ( cls . msg_cantedit . format ( p ) <NEWLINE> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns true if source already opened for editing.\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["06c0085fe8d57aa93fd1d7d6dd581898", {"code_string": "def initialize(self, test_path = ''):\n    \"\"\"Sets the overall failure counter for the test.\"\"\"\n    self.nfail = 0\n    os.system(\"yum install rpcbind-devel -y\")\n    ret_val = subprocess.Popen(['make', 'all'], cwd = \"%s/rpcbind\" %(test_path))\n    ret_val.communicate()\n    if ret_val.returncode != 0:\n    self.nfail += 1\n    logging.info('\\n Test initialize successfully')\n", "code_toks_joined": "def initialize ( self , test_path = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . nfail = 0 <NEWLINE> os . system ( <STRING> ) <NEWLINE> ret_val = subprocess . Popen ( [ <STRING> , <STRING> ] , cwd = <STRING> % ( test_path ) ) <NEWLINE> ret_val . communicate ( ) <NEWLINE> if ret_val . returncode != 0 : <NEWLINE> self . nfail += 1 <NEWLINE> logging . info ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "\"\"\"Sets the overall failure counter for the test.\"\"\"", "\"yum install rpcbind-devel -y\"", "'make'", "'all'", "\"%s/rpcbind\"", "'\\n Test initialize successfully'"]}, "err_obj": {"msg": "expected an indented block"}}], ["12b6b3463dc195f554b3bfec55b1b461", {"code_string": "def calculate_rmsd_for_atoms(self, at1, at2):\n    \"\"\"calculates rmsd for any two atoms\"\"\"\n        rmsd_mat = at1 - at2\n        rmsd_mat = rmsd_mat ** 2\n        return rmsd_mat\n", "code_toks_joined": "def calculate_rmsd_for_atoms ( self , at1 , at2 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> rmsd_mat = at1 - at2 <NEWLINE> rmsd_mat = rmsd_mat ** 2 <NEWLINE> return rmsd_mat <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"calculates rmsd for any two atoms\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["22093861be3906310a49f971d2a63273", {"code_string": "class complex(multicast):\n    def send(self, data):\n    import pickle\n    multicast.send(self, pickle.dumps(data))\n    def recvfrom(self, size):\n    d, sender = multicast.recvfrom(self, size)\n    try:\n        import pickle\n        return pickle.loads(d), sender\n        except:\n        return d, sender\n", "code_toks_joined": "class complex ( multicast ) : <NEWLINE> <INDENT> def send ( self , data ) : <NEWLINE> import pickle <NEWLINE> multicast . send ( self , pickle . dumps ( data ) ) <NEWLINE> def recvfrom ( self , size ) : <NEWLINE> d , sender = multicast . recvfrom ( self , size ) <NEWLINE> try : <NEWLINE> <INDENT> import pickle <NEWLINE> return pickle . loads ( d ) , sender <NEWLINE> except : <NEWLINE> return d , sender <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["74683bfa6df6ac068fc56376878c9cf1", {"code_string": "class CreateAndDeleteStack(utils.HeatScenario):\n    def run(self, template_path, parameters = None,\n        files = None, environment = None):\n        \"\"\"Create and then delete a stack.\"\"\"\n        stack = self._create_stack(template_path, parameters,\n            files, environment)\n            self._delete_stack(stack)\n", "code_toks_joined": "class CreateAndDeleteStack ( utils . HeatScenario ) : <NEWLINE> <INDENT> def run ( self , template_path , parameters = None , <NEWLINE> <INDENT> files = None , environment = None ) : <NEWLINE> <STRING> <NEWLINE> stack = self . _create_stack ( template_path , parameters , <NEWLINE> <INDENT> files , environment ) <NEWLINE> self . _delete_stack ( stack ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Create and then delete a stack.\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["a345f4cbdd7b1cd6efe7c96c2177e908", {"code_string": "def _give_missions(self):\n    \"\"\"Randomly give one mission to each player.\"\"\"\n    world = self.game.world\n    missions = create_missions(world)\n    random.shuffle(missions)\n    for p in world.players.itervalues():\n    p.mission = missions.pop()\n", "code_toks_joined": "def _give_missions ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> world = self . game . world <NEWLINE> missions = create_missions ( world ) <NEWLINE> random . shuffle ( missions ) <NEWLINE> for p in world . players . itervalues ( ) : <NEWLINE> p . mission = missions . pop ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Randomly give one mission to each player.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["506d45bebd0eeb8136334ec11e850e05", {"code_string": "def can_bind(host, port):\n    \"\"\"Checks we can bind to specified host and port\"\"\"\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.bind((host, port)\n        s.close()\n    except socket.error:\n        return False\n    return True\n", "code_toks_joined": "def can_bind ( host , port ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) <NEWLINE> s . bind ( ( host , port ) <NEWLINE> s . close ( ) <NEWLINE> <DEDENT> except socket . error : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Checks we can bind to specified host and port\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["4814a0bf0a7674627444ee692034d52a", {"code_string": "def get_timezone(name):\n    \"\"\"Given a timezone name, returns the corresponding\"\"\"\n    if not _tzdict.has_key(name):\n    raise ValueError, \"Timezone %s not valid\" % repr(name)\n    return _tzdict[name]\n", "code_toks_joined": "def get_timezone ( name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not _tzdict . has_key ( name ) : <NEWLINE> raise ValueError , <STRING> % repr ( name ) <NEWLINE> return _tzdict [ name ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Given a timezone name, returns the corresponding\"\"\"", "\"Timezone %s not valid\""]}, "err_obj": {"msg": "expected an indented block"}}], ["aafda70bf1f13d4d2a47e188041c5aaa", {"code_string": "def is_server_enabled(server)\n    server = scrapertools.find_single_match(server, '([^\\.]+)')\n    return server in ENABLED_SERVERS\n", "code_toks_joined": "def is_server_enabled ( server ) <NEWLINE> <INDENT> server = scrapertools . find_single_match ( server , <STRING> ) <NEWLINE> return server in ENABLED_SERVERS <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'([^\\.]+)'"]}, "err_obj": {"msg": "invalid syntax"}}], ["9336500621397a0f82ce94d4ac0676a7", {"code_string": "def recalc(self):\n    n = 0\n    for i in range(self.total):\n    if self.buttons[i].GetValue():\n        n += 1\n    self.value = n\n    if headerdata.options.debug:\n    print(self.value)\n", "code_toks_joined": "def recalc ( self ) : <NEWLINE> <INDENT> n = 0 <NEWLINE> for i in range ( self . total ) : <NEWLINE> if self . buttons [ i ] . GetValue ( ) : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> self . value = n <NEWLINE> if headerdata . options . debug : <NEWLINE> print ( self . value ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["d07db5ac21c86f7dd84d905abdbbd23e", {"code_string": "def test__check_for_duplicate_rules_in_db_does_not_drop_protocol(self):\n    with mock.patch.object(self.mixin, 'get_security_group_rules',\n        return_value = [mock.Mock()]):\n        context = mock.Mock()\n        rule_dict = {\n        'security_group_rule': {'protocol': None,\n            'tenant_id': 'fake',\n            'security_group_id': 'fake',\n            'direction': 'fake'}\n            }\n            self.mixin._check_for_duplicate_rules_in_db(context, rule_dict)\n    self.assertIn('protocol', rule_dict['security_group_rule'])\n", "code_toks_joined": "def test__check_for_duplicate_rules_in_db_does_not_drop_protocol ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( self . mixin , <STRING> , <NEWLINE> <INDENT> return_value = [ mock . Mock ( ) ] ) : <NEWLINE> context = mock . Mock ( ) <NEWLINE> rule_dict = { <NEWLINE> <STRING> : { <STRING> : None , <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> } <NEWLINE> } <NEWLINE> self . mixin . _check_for_duplicate_rules_in_db ( context , rule_dict ) <NEWLINE> <DEDENT> <DEDENT> self . assertIn ( <STRING> , rule_dict [ <STRING> ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'get_security_group_rules'", "'security_group_rule'", "'protocol'", "'tenant_id'", "'fake'", "'security_group_id'", "'fake'", "'direction'", "'fake'", "'protocol'", "'security_group_rule'"]}, "err_obj": {"msg": "unexpected indent"}}], ["429e195b20bc711403aebc98fd2fed11", {"code_string": "import asyncio\nimport datetime\nimport jwe\nimport jwt\nimport aiohttp\nfrom waterbutler.core import auth\nfrom waterbutler.core import exceptions\nfrom waterbutler.auth.osf import settings\nJWE_KEY = jwe.kdf(settings.JWE_SECRET.encode(), settings.JWE_SALT.encode()\n", "code_toks_joined": "import asyncio <NEWLINE> import datetime <NEWLINE> import jwe <NEWLINE> import jwt <NEWLINE> import aiohttp <NEWLINE> from waterbutler . core import auth <NEWLINE> from waterbutler . core import exceptions <NEWLINE> from waterbutler . auth . osf import settings <NEWLINE> JWE_KEY = jwe . kdf ( settings . JWE_SECRET . encode ( ) , settings . JWE_SALT . encode ( ) <NEWLINE>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["430c9e1368dbe2ca0b5b14d8a22d7b66", {"code_string": "def run(self):\n    if(self.cursor):\n        from util import cursor_wait\n        cursor_wait(self.cfg, True)\n    self.cond.acquire()\n    self.run_func()\n        self.cond.notify()\n        self.cond.release()\n    if(self.cursor):\n        cursor_wait(self.cfg, False)\n", "code_toks_joined": "def run ( self ) : <NEWLINE> <INDENT> if ( self . cursor ) : <NEWLINE> <INDENT> from util import cursor_wait <NEWLINE> cursor_wait ( self . cfg , True ) <NEWLINE> <DEDENT> self . cond . acquire ( ) <NEWLINE> self . run_func ( ) <NEWLINE> <INDENT> self . cond . notify ( ) <NEWLINE> self . cond . release ( ) <NEWLINE> <DEDENT> if ( self . cursor ) : <NEWLINE> <INDENT> cursor_wait ( self . cfg , False ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["20ea8e4340b9959f9a7cbcfe6154b2fd", {"code_string": "class iterator_product(itertools.product):\n    text = \"product\"\n    def __init__(self, * i):\n    itertools.product.__init__(self, * i)\n    self.__count = reduce(lambda x, y: x * y.count(), i[1: ], i[0].count())\n    def count(self):\n    return self.__count\n", "code_toks_joined": "class iterator_product ( itertools . product ) : <NEWLINE> <INDENT> text = <STRING> <NEWLINE> def __init__ ( self , * i ) : <NEWLINE> itertools . product . __init__ ( self , * i ) <NEWLINE> self . __count = reduce ( lambda x , y : x * y . count ( ) , i [ 1 : ] , i [ 0 ] . count ( ) ) <NEWLINE> def count ( self ) : <NEWLINE> return self . __count <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"product\""]}, "err_obj": {"msg": "expected an indented block"}}], ["fa48d8ec8f9094acadcc3707d994ec63", {"code_string": "def main(backend):\n    \"\"\"Main\"\"\"\n    health = subprocess.check_output(\"varnishadm debug.health | grep \" + backend + \" | awk '{print $4}'\", shell = True)\n    health = set(health.split(\"\\n\"))\n    if 'Sick' in health:\n        print('false')\n    elif 'Healthy' in health\n        print('true')\n", "code_toks_joined": "def main ( backend ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> health = subprocess . check_output ( <STRING> + backend + <STRING> , shell = True ) <NEWLINE> health = set ( health . split ( <STRING> ) ) <NEWLINE> if <STRING> in health : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif <STRING> in health <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Main\"\"\"", "\"varnishadm debug.health | grep \"", "\" | awk '{print $4}'\"", "\"\\n\"", "'Sick'", "'false'", "'Healthy'", "'true'"]}, "err_obj": {"msg": "invalid syntax"}}], ["686e29e56b750b1d92f3fd51f0cb18e7", {"code_string": "def __create_start_up_script_if_not_exist(self):\n    if not os.path.exists(self.start_up_file_name):\n        try:\n            os.makedirs(os.path.dirname(self.start_up_file_name))\n                return self.__create_default_start_up_script_and_save_to_disk()\n        except OSError as exc:\n            if exc.errno == errno.EEXIST:\n                return self.__create_default_start_up_script_and_save_to_disk()\n            if exc.errno != errno.EEXIST:\n                raise\n    else:\n        return self.__load_start_up_script_from_disk()\n", "code_toks_joined": "def __create_start_up_script_if_not_exist ( self ) : <NEWLINE> <INDENT> if not os . path . exists ( self . start_up_file_name ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> os . makedirs ( os . path . dirname ( self . start_up_file_name ) ) <NEWLINE> <INDENT> return self . __create_default_start_up_script_and_save_to_disk ( ) <NEWLINE> <DEDENT> <DEDENT> except OSError as exc : <NEWLINE> <INDENT> if exc . errno == errno . EEXIST : <NEWLINE> <INDENT> return self . __create_default_start_up_script_and_save_to_disk ( ) <NEWLINE> <DEDENT> if exc . errno != errno . EEXIST : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return self . __load_start_up_script_from_disk ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["73bd0bbc50cf51d017e470a04fceea95", {"code_string": "import constants\nimport sys, urllib, os.path\ndef reporthook(* a): print a\nfor url in constants.defines._REGISTRY_DATA:\n    i = url.rfind('/')\n    file = os.path.join(constants.defines._DATA_DIR, url[i + 1: ])\n    print(url, \"->\", file)\n    urllib.urlretrieve(url, file, reporthook)\n", "code_toks_joined": "import constants <NEWLINE> import sys , urllib , os . path <NEWLINE> def reporthook ( * a ) : print a <NEWLINE> for url in constants . defines . _REGISTRY_DATA : <NEWLINE> <INDENT> i = url . rfind ( <STRING> ) <NEWLINE> file = os . path . join ( constants . defines . _DATA_DIR , url [ i + 1 : ] ) <NEWLINE> print ( url , <STRING> , file ) <NEWLINE> urllib . urlretrieve ( url , file , reporthook ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'/'", "\"->\""]}, "err_obj": {"msg": "invalid syntax"}}], ["bd33d55d726bd21abbfe49e36cf9c598", {"code_string": "def test_client_socket_timeout(self):\n    self.flags(client_socket_timeout = 5)\n    with mock.patch.object(eventlet,\n        'spawn') as mock_spawn:\n        server = patron.wsgi.Server(\"test_app\", None,\n            host = \"127.0.0.1\", port = 0)\n            server.start()\n            _, kwargs = mock_spawn.call_args\n            self.assertEqual(CONF.client_socket_timeout,\n            kwargs['socket_timeout'])\n            server.stop()\n", "code_toks_joined": "def test_client_socket_timeout ( self ) : <NEWLINE> <INDENT> self . flags ( client_socket_timeout = 5 ) <NEWLINE> with mock . patch . object ( eventlet , <NEWLINE> <INDENT> <STRING> ) as mock_spawn : <NEWLINE> server = patron . wsgi . Server ( <STRING> , None , <NEWLINE> <INDENT> host = <STRING> , port = 0 ) <NEWLINE> server . start ( ) <NEWLINE> _ , kwargs = mock_spawn . call_args <NEWLINE> self . assertEqual ( CONF . client_socket_timeout , <NEWLINE> kwargs [ <STRING> ] ) <NEWLINE> server . stop ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'spawn'", "\"test_app\"", "\"127.0.0.1\"", "'socket_timeout'"]}, "err_obj": {"msg": "unexpected indent"}}], ["8cc75a7fda3942164e8c74df9729e115", {"code_string": "def mousePressEvent(self, e):\n    \"\"\"Override mousePressEvent to close tabs if configured.\"\"\"\n    button = config.get('tabs', 'close-mouse-button')\n    if(e.button() == Qt.RightButton and button == 'right' or\n        e.button() == Qt.MiddleButton and button == 'middle'):\n        idx = self.tabAt(e.pos())\n        if idx != - 1:\n        e.accept()\n        self.tabCloseRequested.emit(idx)\n        return\n    super().mousePressEvent(e)\n", "code_toks_joined": "def mousePressEvent ( self , e ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> button = config . get ( <STRING> , <STRING> ) <NEWLINE> if ( e . button ( ) == Qt . RightButton and button == <STRING> or <NEWLINE> <INDENT> e . button ( ) == Qt . MiddleButton and button == <STRING> ) : <NEWLINE> idx = self . tabAt ( e . pos ( ) ) <NEWLINE> if idx != - 1 : <NEWLINE> e . accept ( ) <NEWLINE> self . tabCloseRequested . emit ( idx ) <NEWLINE> return <NEWLINE> <DEDENT> super ( ) . mousePressEvent ( e ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Override mousePressEvent to close tabs if configured.\"\"\"", "'tabs'", "'close-mouse-button'", "'right'", "'middle'"]}, "err_obj": {"msg": "expected an indented block"}}], ["c4aaa80268a9ea75c2066e9a920cbd02", {"code_string": "def validate_type((t, v)):\n    \"\"\"check that the value matches the type\"\"\"\n    if v == 'NULL':\n        return True\n    if t in[datetime.datetime, datetime.date, datetime.time]:\n        if '0000-00-00' == v:\n            return False\n    try:\n        if t in[int, float]:\n            t(v)\n    except:\n        return False\n    return True\n", "code_toks_joined": "def validate_type ( ( t , v ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if v == <STRING> : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if t in [ datetime . datetime , datetime . date , datetime . time ] : <NEWLINE> <INDENT> if <STRING> == v : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> try : <NEWLINE> <INDENT> if t in [ int , float ] : <NEWLINE> <INDENT> t ( v ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"check that the value matches the type\"\"\"", "'NULL'", "'0000-00-00'"]}, "err_obj": {"msg": "invalid syntax"}}], ["f0daefa66bf46f823b92bbab8bb36f21", {"code_string": "def config():\n    conf = base.BaseConfig('data', '2012', analysis = 'ee')\n    conf[\"InputFiles\"] = \"/storage/a/dhaitz/skims/2014_06_23_zee_data/*.root\"\n    conf = base.expand(conf, ['all', 'zcuts', 'incut'])\n    if socket.gethostname().startswith('naf'):\n    conf['InputFiles'] = \"/pnfs/desy.de/cms/tier2/store/user/dhaitz/2014_06_23_ee-data\"\n    return conf\n", "code_toks_joined": "def config ( ) : <NEWLINE> <INDENT> conf = base . BaseConfig ( <STRING> , <STRING> , analysis = <STRING> ) <NEWLINE> conf [ <STRING> ] = <STRING> <NEWLINE> conf = base . expand ( conf , [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> if socket . gethostname ( ) . startswith ( <STRING> ) : <NEWLINE> conf [ <STRING> ] = <STRING> <NEWLINE> return conf <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'data'", "'2012'", "'ee'", "\"InputFiles\"", "\"/storage/a/dhaitz/skims/2014_06_23_zee_data/*.root\"", "'all'", "'zcuts'", "'incut'", "'naf'", "'InputFiles'", "\"/pnfs/desy.de/cms/tier2/store/user/dhaitz/2014_06_23_ee-data\""]}, "err_obj": {"msg": "expected an indented block"}}], ["5fb803188b7b7b60d5168878b85dc13f", {"code_string": "def _check_process_resources(self):\n    \"\"\"Check if the process is still is abusing resources & should continue\"\"\"\n    resource_data = resource.getrusage(resource.RUSAGE_SELF)\n    if resource_data.ru_maxrss <(\n        settings.DIE_ON_RESIDENT_SET_SIZE_MB * 1024):\n        if self._dirty:\n        logger.info('Worker process data.')\n        return True\n    settings.ON_WORKER_SHUTDOWN()\n    self._on_exceeding_memory_limit(resource_data.ru_maxrss)\n    sys.exit(1)\n", "code_toks_joined": "def _check_process_resources ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> resource_data = resource . getrusage ( resource . RUSAGE_SELF ) <NEWLINE> if resource_data . ru_maxrss < ( <NEWLINE> <INDENT> settings . DIE_ON_RESIDENT_SET_SIZE_MB * 1024 ) : <NEWLINE> if self . _dirty : <NEWLINE> logger . info ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> settings . ON_WORKER_SHUTDOWN ( ) <NEWLINE> self . _on_exceeding_memory_limit ( resource_data . ru_maxrss ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Check if the process is still is abusing resources & should continue\"\"\"", "'Worker process data.'"]}, "err_obj": {"msg": "expected an indented block"}}], ["d4420228c2752546498f1323999545c7", {"code_string": "def includeme(config):\n    \"\"\"This function is detected by Pyramid so that you can easily include\"\"\"\n    settings = config.registry.settings\n    for option in('client_callable', 'serialize', 'deserialize',\n        'id_generator'):\n        key = 'mongo.sessions.%s' % option\n        if key in settings:\n        settings[key] = config.maybe_dotted(settings[key])\n    session_factory = session_factory_from_settings(settings)\n    config.set_session_factory(session_factory)\n", "code_toks_joined": "def includeme ( config ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> settings = config . registry . settings <NEWLINE> for option in ( <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> key = <STRING> % option <NEWLINE> if key in settings : <NEWLINE> settings [ key ] = config . maybe_dotted ( settings [ key ] ) <NEWLINE> <DEDENT> session_factory = session_factory_from_settings ( settings ) <NEWLINE> config . set_session_factory ( session_factory ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"This function is detected by Pyramid so that you can easily include\"\"\"", "'client_callable'", "'serialize'", "'deserialize'", "'id_generator'", "'mongo.sessions.%s'"]}, "err_obj": {"msg": "expected an indented block"}}], ["b6260087a9c8e817534cf1f27ed01738", {"code_string": "def _xray_marker_closed(self, obj):\n    marker = obj\n    for xray_line, line_markers in reversed(list(\n        self._xray_markers.items())):\n        if marker in line_markers:\n        line_markers.remove(marker)\n        if not line_markers:\n        self._xray_markers.pop(xray_line)\n", "code_toks_joined": "def _xray_marker_closed ( self , obj ) : <NEWLINE> <INDENT> marker = obj <NEWLINE> for xray_line , line_markers in reversed ( list ( <NEWLINE> <INDENT> self . _xray_markers . items ( ) ) ) : <NEWLINE> if marker in line_markers : <NEWLINE> line_markers . remove ( marker ) <NEWLINE> if not line_markers : <NEWLINE> self . _xray_markers . pop ( xray_line ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["e42507db286451e81a347b216173c640", {"code_string": "def __init__(self, port):\n    if MultiHTTPServer.__single:\n        raise RuntimeError, \"MultiHTTPServer is Singleton\"\n    MultiHTTPServer.__single = self\n    self.port = port\n    BaseHTTPServer.HTTPServer.__init__(self, (\"127.0.0.1\", self.port), SimpleServer)\n    self.daemon_threads = True\n    self.allow_reuse_address = True\n    self.lock = RLock()\n    self.urlpath2streaminfo = {}\n    self.mappers = []\n    self.errorcallback = None\n    self.statuscallback = None\n", "code_toks_joined": "def __init__ ( self , port ) : <NEWLINE> <INDENT> if MultiHTTPServer . __single : <NEWLINE> <INDENT> raise RuntimeError , <STRING> <NEWLINE> <DEDENT> MultiHTTPServer . __single = self <NEWLINE> self . port = port <NEWLINE> BaseHTTPServer . HTTPServer . __init__ ( self , ( <STRING> , self . port ) , SimpleServer ) <NEWLINE> self . daemon_threads = True <NEWLINE> self . allow_reuse_address = True <NEWLINE> self . lock = RLock ( ) <NEWLINE> self . urlpath2streaminfo = { } <NEWLINE> self . mappers = [ ] <NEWLINE> self . errorcallback = None <NEWLINE> self . statuscallback = None <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"MultiHTTPServer is Singleton\"", "\"127.0.0.1\""]}, "err_obj": {"msg": "invalid syntax"}}], ["eb97ef1f560b946a2a63a388ef713f89", {"code_string": "def info(self, path):\n    \"\"\"Dump info (retrieved from flickr) about the identified photos.\"\"\"\n    for p in utils.paths_from_path_patterns([path],\n        dirs = \"if-not-recursive\",\n        recursive = False,\n        on_error = \"yield\"):\n        for dir, id in self._local_photo_dirs_and_ids_from_target(p):\n        log.debug(\"dump info for photo\", id)\n        info = self.api.photos_getInfo(photo_id = id)\n        xpprint(info)\n", "code_toks_joined": "def info ( self , path ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for p in utils . paths_from_path_patterns ( [ path ] , <NEWLINE> <INDENT> dirs = <STRING> , <NEWLINE> recursive = False , <NEWLINE> on_error = <STRING> ) : <NEWLINE> for dir , id in self . _local_photo_dirs_and_ids_from_target ( p ) : <NEWLINE> log . debug ( <STRING> , id ) <NEWLINE> info = self . api . photos_getInfo ( photo_id = id ) <NEWLINE> xpprint ( info ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Dump info (retrieved from flickr) about the identified photos.\"\"\"", "\"if-not-recursive\"", "\"yield\"", "\"dump info for photo\""]}, "err_obj": {"msg": "expected an indented block"}}], ["d56fe2202b5d92237acc37bfe0d30ad4", {"code_string": "def ziip(tozip):\n    filenames = os.listdir(os.path.abspath(tozip))\n    cmd = 'zip -j zipfile '\n    for filename in filenames:\n        cmd = cmd + filename + ' '\n    print('Command to run: ', cmd)\n    filenames = os.listdir(os.path.abspath(tozip))\n    for filename in filenames:\n        print(os.path.abspath(filename)))\n    output = commands.getoutput(cmd)\n", "code_toks_joined": "def ziip ( tozip ) : <NEWLINE> <INDENT> filenames = os . listdir ( os . path . abspath ( tozip ) ) <NEWLINE> cmd = <STRING> <NEWLINE> for filename in filenames : <NEWLINE> <INDENT> cmd = cmd + filename + <STRING> <NEWLINE> <DEDENT> print ( <STRING> , cmd ) <NEWLINE> filenames = os . listdir ( os . path . abspath ( tozip ) ) <NEWLINE> for filename in filenames : <NEWLINE> <INDENT> print ( os . path . abspath ( filename ) ) ) <NEWLINE> <DEDENT> output = commands . getoutput ( cmd ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'zip -j zipfile '", "' '", "'Command to run: '"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["46ae74c318c6af6a3ddbac168c8b9a91", {"code_string": "class Share(models.Model):\n    share = models.CharField(max_length = 30, unique = True)\n    read = models.ManyToManyField(SambaUser, blank = True, limit_choices_to = {'is_disabled': False}, related_name = \"readonly\")\n    write = models.ManyToManyField(SambaUser, limit_choices_to = {'is_disabled': False}, related_name = \"write\")\n    old_shares = models.CharField(max_length = 200, default = '  ', editable = False, null = True, blank = True)\n    def __str__(self):\n    return self.share\n", "code_toks_joined": "class Share ( models . Model ) : <NEWLINE> <INDENT> share = models . CharField ( max_length = 30 , unique = True ) <NEWLINE> read = models . ManyToManyField ( SambaUser , blank = True , limit_choices_to = { <STRING> : False } , related_name = <STRING> ) <NEWLINE> write = models . ManyToManyField ( SambaUser , limit_choices_to = { <STRING> : False } , related_name = <STRING> ) <NEWLINE> old_shares = models . CharField ( max_length = 200 , default = <STRING> , editable = False , null = True , blank = True ) <NEWLINE> def __str__ ( self ) : <NEWLINE> return self . share <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'is_disabled'", "\"readonly\"", "'is_disabled'", "\"write\"", "'  '"]}, "err_obj": {"msg": "expected an indented block"}}], ["eff55d678cb56d5ec07221e5c4a3d37e", {"code_string": "def get_check(check_id):\n    package = s2t_check\n    prefix = package.__name__ + \".\"\n    for importer, modname, ispkg in pkgutil.iter_modules(package.__path__,\n        prefix):\n        module = __import__(modname, fromlist = \"dummy\")\n        chk = module.factory(check_id)\n        if chk:\n        return chk\n    return aa_check.factory(check_id)\n", "code_toks_joined": "def get_check ( check_id ) : <NEWLINE> <INDENT> package = s2t_check <NEWLINE> prefix = package . __name__ + <STRING> <NEWLINE> for importer , modname , ispkg in pkgutil . iter_modules ( package . __path__ , <NEWLINE> <INDENT> prefix ) : <NEWLINE> module = __import__ ( modname , fromlist = <STRING> ) <NEWLINE> chk = module . factory ( check_id ) <NEWLINE> if chk : <NEWLINE> return chk <NEWLINE> <DEDENT> return aa_check . factory ( check_id ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\".\"", "\"dummy\""]}, "err_obj": {"msg": "expected an indented block"}}], ["f455c5ac0547526faa43f595b867b09d", {"code_string": "def twitter_datestring_to_datetime_utc(twitter_datestring):\n    \"\"\" Return a datetime from a twitter date string.\"\"\"\n    time_tuple = email_utils_parsedate_tz(twitter_datestring.strip()))\n    dt = datetime(* time_tuple[: 6])\n    return dt - timedelta(seconds = time_tuple[- 1])\n", "code_toks_joined": "def twitter_datestring_to_datetime_utc ( twitter_datestring ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> time_tuple = email_utils_parsedate_tz ( twitter_datestring . strip ( ) ) ) <NEWLINE> dt = datetime ( * time_tuple [ : 6 ] ) <NEWLINE> return dt - timedelta ( seconds = time_tuple [ - 1 ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Return a datetime from a twitter date string.\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c3287335fcba6bf143625caaaaff2220", {"code_string": "def setUp(self):\n    self.plugin = DocPlugin()\n    self.plugin.set_site(FakeSite()))\n    try:\n        f = docutils.parsers.rst.roles.role('doc', None, None, None)[0]\n        f.site = FakeSite()\n    except AttributeError:\n        pass\n    return super(DocTestCase, self).setUp()\n", "code_toks_joined": "def setUp ( self ) : <NEWLINE> <INDENT> self . plugin = DocPlugin ( ) <NEWLINE> self . plugin . set_site ( FakeSite ( ) ) ) <NEWLINE> try : <NEWLINE> <INDENT> f = docutils . parsers . rst . roles . role ( <STRING> , None , None , None ) [ 0 ] <NEWLINE> f . site = FakeSite ( ) <NEWLINE> <DEDENT> except AttributeError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> return super ( DocTestCase , self ) . setUp ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'doc'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["ffbbb65afdab199d88175ea5e433e9ce", {"code_string": "class create_content_opf:\n    def create_content(self, items, book_id, title, creator):\n        manifest_items = []\n        for each in items['file_id']:\n            index = items['file_id'].index(each)\n            item = ('\\n<item id=\"item{item_identifier}\" href=\"{item_href}\"'\n            '\\nmedia-type=\"application/xhtml+xml\"/>').format(item_identifier = each,\n                item_href = items['file_href'][index])\n            manifest_items.append(item)\n        manifest_items = ''.join(manifest_items)\n        spine_items = []\n        for each in items['file_id']:\n            id_item = '<itemref idref=\"item{id}\"/>'.format(id = each)\n            spine_items.append(id_item)\n        spine_items = ''.join(spine_items)\n        content = ('<?xml version=\"1.0\" encoding=\"utf-8\"?>'\n", "code_toks_joined": "class create_content_opf : <NEWLINE> <INDENT> def create_content ( self , items , book_id , title , creator ) : <NEWLINE> <INDENT> manifest_items = [ ] <NEWLINE> for each in items [ <STRING> ] : <NEWLINE> <INDENT> index = items [ <STRING> ] . index ( each ) <NEWLINE> item = ( <STRING> <NEWLINE> <STRING> ) . format ( item_identifier = each , <NEWLINE> <INDENT> item_href = items [ <STRING> ] [ index ] ) <NEWLINE> <DEDENT> manifest_items . append ( item ) <NEWLINE> <DEDENT> manifest_items = <STRING> . join ( manifest_items ) <NEWLINE> spine_items = [ ] <NEWLINE> for each in items [ <STRING> ] : <NEWLINE> <INDENT> id_item = <STRING> . format ( id = each ) <NEWLINE> spine_items . append ( id_item ) <NEWLINE> <DEDENT> spine_items = <STRING> . join ( spine_items ) <NEWLINE> content = ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'file_id'", "'file_id'", "'\\n<item id=\"item{item_identifier}\" href=\"{item_href}\"'", "'\\nmedia-type=\"application/xhtml+xml\"/>'", "'file_href'", "''", "'file_id'", "'<itemref idref=\"item{id}\"/>'", "''", "'<?xml version=\"1.0\" encoding=\"utf-8\"?>'"]}, "window_span": [138, 143], "err_obj": {"msg": "unbalanced (){}[]"}}], ["153ae77811f14c4b8294186f7cc9960b", {"code_string": "def __boundary_term(graph, label_image, (boundary_term_args)):\n    \"The boundary term function used for this tests.\"\n    dic = TestCut.__get_mapping()\n    for key, value in dic.iteritems():\n        dic[key] = (value, value)\n    return dic\n", "code_toks_joined": "def __boundary_term ( graph , label_image , ( boundary_term_args ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> dic = TestCut . __get_mapping ( ) <NEWLINE> for key , value in dic . iteritems ( ) : <NEWLINE> <INDENT> dic [ key ] = ( value , value ) <NEWLINE> <DEDENT> return dic <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"The boundary term function used for this tests.\""]}, "err_obj": {"msg": "invalid syntax"}}], ["eb485121eaa5e4eeee65bedf0eca52fb", {"code_string": "def test_network_create_with_bad_vlan_transparent_attr(self):\n    vlantrans = {'vlan_transparent': \"abc\"}\n    with testlib_api.ExpectedException(\n        web_exc.HTTPClientError) as ctx_manager:\n        with self.network(name = 'net1', ** vlantrans):\n        pass\n    self.assertEqual(web_exc.HTTPClientError.code,\n        ctx_manager.exception.code)\n", "code_toks_joined": "def test_network_create_with_bad_vlan_transparent_attr ( self ) : <NEWLINE> <INDENT> vlantrans = { <STRING> : <STRING> } <NEWLINE> with testlib_api . ExpectedException ( <NEWLINE> <INDENT> web_exc . HTTPClientError ) as ctx_manager : <NEWLINE> with self . network ( name = <STRING> , ** vlantrans ) : <NEWLINE> pass <NEWLINE> <DEDENT> self . assertEqual ( web_exc . HTTPClientError . code , <NEWLINE> <INDENT> ctx_manager . exception . code ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'vlan_transparent'", "\"abc\"", "'net1'"]}, "err_obj": {"msg": "expected an indented block"}}], ["0e4e09201b8f1131b5f405e3a9bb709f", {"code_string": "class NoneLengthHint(object):\n    def __iter__(self):\n        return iter(range(10)\n    def __length_hint__(self):\n        return NotImplemented\n", "code_toks_joined": "class NoneLengthHint ( object ) : <NEWLINE> <INDENT> def __iter__ ( self ) : <NEWLINE> <INDENT> return iter ( range ( 10 ) <NEWLINE> <DEDENT> def __length_hint__ ( self ) : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["3ea5de895130b2cebec2690282dfe86e", {"code_string": "def setUp(self):\n    \"\"\"Setup for the test\"\"\"\n        pass\n", "code_toks_joined": "def setUp ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Setup for the test\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["80d1018ceaa5ebc3fea4a20025b3be86", {"code_string": "def zero(self):\n    self.title = ''\n    self.artist = ''\n    self.album = ''\n    self.year = ''\n    self.comment = ''\n        self.track = None\n    self.genre = 255\n        self.setup_dict()\n", "code_toks_joined": "def zero ( self ) : <NEWLINE> <INDENT> self . title = <STRING> <NEWLINE> self . artist = <STRING> <NEWLINE> self . album = <STRING> <NEWLINE> self . year = <STRING> <NEWLINE> self . comment = <STRING> <NEWLINE> <INDENT> self . track = None <NEWLINE> <DEDENT> self . genre = 255 <NEWLINE> <INDENT> self . setup_dict ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "''", "''", "''", "''"]}, "err_obj": {"msg": "unexpected indent"}}], ["4cc406368bfc4ae74877566ec10f2a08", {"code_string": "def send(self, name = None):\n    try:\n        if name is None:\n            name = self.EOF\n        name += os.linesep\n        bytes = self.socket.send(name)\n        print(\"sent: %s(%d bytes of %d)\" %(name, bytes, len(name))\n        return True\n    except socket.error:\n        pass\n    return False\n", "code_toks_joined": "def send ( self , name = None ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if name is None : <NEWLINE> <INDENT> name = self . EOF <NEWLINE> <DEDENT> name += os . linesep <NEWLINE> bytes = self . socket . send ( name ) <NEWLINE> print ( <STRING> % ( name , bytes , len ( name ) ) <NEWLINE> return True <NEWLINE> <DEDENT> except socket . error : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"sent: %s(%d bytes of %d)\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["7dd4e801632c82e3f2f87e60b2560fc7", {"code_string": "def group_members(self, groupname):\n    '''Return a list of people approved for a group.'''\n    request = self.send_request('/group/dump/%s' %\n        quote(groupname), auth = True)\n    return[Munch(username = user[0],\n        role_type = user[3]) for user in request['people']\n", "code_toks_joined": "def group_members ( self , groupname ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> request = self . send_request ( <STRING> % <NEWLINE> <INDENT> quote ( groupname ) , auth = True ) <NEWLINE> <DEDENT> return [ Munch ( username = user [ 0 ] , <NEWLINE> <INDENT> role_type = user [ 3 ] ) for user in request [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Return a list of people approved for a group.'''", "'/group/dump/%s'", "'people'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["11bfd34c7eb914c72f05955f8dda0589", {"code_string": "def getstuff():\n    banner = raw_input('\\nEnter banner information: ')\n    host = raw_input('Enter IP Address: ')\n    while True or hp != null:\n    try:\n        port = int(raw_input('Enter Port Number: '))\n    except TypeError:\n        print('\\n[-] Error: invalid port number\\n')\n        continue\n    else:\n        if(port < 1) or(port > 65535):\n            print('\\n[-] Error: invalid port number\\n')\n            continue\n        else:\n            return(banner, host, port)\n", "code_toks_joined": "def getstuff ( ) : <NEWLINE> <INDENT> banner = raw_input ( <STRING> ) <NEWLINE> host = raw_input ( <STRING> ) <NEWLINE> while True or hp != null : <NEWLINE> try : <NEWLINE> <INDENT> port = int ( raw_input ( <STRING> ) ) <NEWLINE> <DEDENT> except TypeError : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( port < 1 ) or ( port > 65535 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( banner , host , port ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'\\nEnter banner information: '", "'Enter IP Address: '", "'Enter Port Number: '", "'\\n[-] Error: invalid port number\\n'", "'\\n[-] Error: invalid port number\\n'"]}, "err_obj": {"msg": "expected an indented block"}}], ["da7314b7d051b23bb0fd21a5ef76dabe", {"code_string": "def test_call(self):\n    req = mock.Mock()\n    with mock.patch.object(self.handler,\n        '_get_instance_and_tenant_id') as get_ids:\n        get_ids.return_value = ('instance_id', 'tenant_id')\n        with mock.patch.object(self.handler, '_proxy_request') as proxy:\n        proxy.return_value = 'value'\n        retval = self.handler(req)\n        self.assertEqual(retval, 'value')\n", "code_toks_joined": "def test_call ( self ) : <NEWLINE> <INDENT> req = mock . Mock ( ) <NEWLINE> with mock . patch . object ( self . handler , <NEWLINE> <INDENT> <STRING> ) as get_ids : <NEWLINE> get_ids . return_value = ( <STRING> , <STRING> ) <NEWLINE> with mock . patch . object ( self . handler , <STRING> ) as proxy : <NEWLINE> proxy . return_value = <STRING> <NEWLINE> retval = self . handler ( req ) <NEWLINE> self . assertEqual ( retval , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'_get_instance_and_tenant_id'", "'instance_id'", "'tenant_id'", "'_proxy_request'", "'value'", "'value'"]}, "err_obj": {"msg": "expected an indented block"}}], ["7a47fc76e2dc6331a76be4e893a6a160", {"code_string": "def clear(self):\n    LOG.debug(_('Dropping HBase schema...'))\n    with self.conn_pool.connection() as conn:\n        for table in[self.ALARM_TABLE,\n            self.ALARM_HISTORY_TABLE]:\n            try:\n            conn.disable_table(table)\n            except Exception:\n            LOG.debug(_('Cannot disable table but ignoring error'))\n            try:\n            conn.delete_table(table)\n            except Exception:\n            LOG.debug(_('Cannot delete table but ignoring error'))\n", "code_toks_joined": "def clear ( self ) : <NEWLINE> <INDENT> LOG . debug ( _ ( <STRING> ) ) <NEWLINE> with self . conn_pool . connection ( ) as conn : <NEWLINE> <INDENT> for table in [ self . ALARM_TABLE , <NEWLINE> <INDENT> self . ALARM_HISTORY_TABLE ] : <NEWLINE> try : <NEWLINE> conn . disable_table ( table ) <NEWLINE> except Exception : <NEWLINE> LOG . debug ( _ ( <STRING> ) ) <NEWLINE> try : <NEWLINE> conn . delete_table ( table ) <NEWLINE> except Exception : <NEWLINE> LOG . debug ( _ ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Dropping HBase schema...'", "'Cannot disable table but ignoring error'", "'Cannot delete table but ignoring error'"]}, "err_obj": {"msg": "expected an indented block"}}], ["6dfb24d2c34ce56df8df0e17fd2b7a8a", {"code_string": "class CertificateConnection(Connection):\n    \"\"\"Base connection class which accepts a single ``cert_file`` argument.\"\"\"\n    def __init__(self, cert_file, secure = True, host = None, port = None, url = None,\n        proxy_url = None, timeout = None, backoff = None, retry_delay = None):\n        \"\"\"Initialize `cert_file`; set `secure` to an ``int`` based on\"\"\"\n        super(CertificateConnection, self).__init__(secure = secure, host = host,\n            port = port, url = url,\n            timeout = timeout,\n            backoff = backoff,\n            retry_delay = retry_delay,\n            proxy_url = proxy_url)\n            self.cert_file = cert_file\n", "code_toks_joined": "class CertificateConnection ( Connection ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , cert_file , secure = True , host = None , port = None , url = None , <NEWLINE> <INDENT> proxy_url = None , timeout = None , backoff = None , retry_delay = None ) : <NEWLINE> <STRING> <NEWLINE> super ( CertificateConnection , self ) . __init__ ( secure = secure , host = host , <NEWLINE> <INDENT> port = port , url = url , <NEWLINE> timeout = timeout , <NEWLINE> backoff = backoff , <NEWLINE> retry_delay = retry_delay , <NEWLINE> proxy_url = proxy_url ) <NEWLINE> self . cert_file = cert_file <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Base connection class which accepts a single ``cert_file`` argument.\"\"\"", "\"\"\"Initialize `cert_file`; set `secure` to an ``int`` based on\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["4f1f424740cc7074427b5ef949c0576b", {"code_string": "def validate(self):\n    res = super(SaharaClusterTemplate, self).validate()\n    if res:\n        return res\n    if(self.is_using_neutron() and\n        not self.properties[self.MANAGEMENT_NETWORK]):\n        msg = _(\"%s must be provided\"\n            ) % self.MANAGEMENT_NETWORK\n            raise exception.StackValidationFailed(message = msg)\n", "code_toks_joined": "def validate ( self ) : <NEWLINE> <INDENT> res = super ( SaharaClusterTemplate , self ) . validate ( ) <NEWLINE> if res : <NEWLINE> <INDENT> return res <NEWLINE> <DEDENT> if ( self . is_using_neutron ( ) and <NEWLINE> <INDENT> not self . properties [ self . MANAGEMENT_NETWORK ] ) : <NEWLINE> msg = _ ( <STRING> <NEWLINE> <INDENT> ) % self . MANAGEMENT_NETWORK <NEWLINE> raise exception . StackValidationFailed ( message = msg ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"%s must be provided\""]}, "err_obj": {"msg": "unexpected indent"}}], ["bf923daf1d159314d11e310ee7ca4ff2", {"code_string": "def request_email_change(self, new_email):\n    self.assert_account_live()\n    self.assert_email_unique(new_email)\n    Session.add(ChangeAccountEmail(self, new_email)\n    self.send_email_change_mail()\n", "code_toks_joined": "def request_email_change ( self , new_email ) : <NEWLINE> <INDENT> self . assert_account_live ( ) <NEWLINE> self . assert_email_unique ( new_email ) <NEWLINE> Session . add ( ChangeAccountEmail ( self , new_email ) <NEWLINE> self . send_email_change_mail ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["bb25d19589dd5ec3a4aa26003d2c5280", {"code_string": "\"\"\"\"\"\"\nfrom launchConfigureParser import verbose\nif verbose():\n    print \"============== import GEOM =======================\"\nimport GEOM\n", "code_toks_joined": "<STRING> <NEWLINE> from launchConfigureParser import verbose <NEWLINE> if verbose ( ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> import GEOM <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"\"\"\"\"\"", "\"============== import GEOM =======================\""]}, "err_obj": {"msg": "invalid syntax"}}], ["b53a3936e0c0aaaf62204a5902d9e630", {"code_string": "import re\nimport sys\ncss = re.sub(r'(?<=[{}: ;, ])\\s+|\\s+(?=[{}: ;, ])', '', ''.join(sys.stdin)\nhex_colors = (\n    hex_color.group(0)\n    for value in re.finditer(r'(?<=: )(.*?)(?=; )', css)\n    for hex_color in re.finditer(r'#[a-f\\d]{6}|#[a-f\\d]{3}', value.group(0), re.I)\n)\nprint(sep = '\\n', * hex_colors)\n", "code_toks_joined": "import re <NEWLINE> import sys <NEWLINE> css = re . sub ( <STRING> , <STRING> , <STRING> . join ( sys . stdin ) <NEWLINE> hex_colors = ( <NEWLINE> <INDENT> hex_color . group ( 0 ) <NEWLINE> for value in re . finditer ( <STRING> , css ) <NEWLINE> for hex_color in re . finditer ( <STRING> , value . group ( 0 ) , re . I ) <NEWLINE> <DEDENT> ) <NEWLINE> print ( sep = <STRING> , * hex_colors ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["r'(?<=[{}: ;, ])\\s+|\\s+(?=[{}: ;, ])'", "''", "''", "r'(?<=: )(.*?)(?=; )'", "r'#[a-f\\d]{6}|#[a-f\\d]{3}'", "'\\n'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["0aacd51bd7f35fcb803197f5ebc58328", {"code_string": "def debug(msg):\n    if DEBUG:\n    print(msg)\n", "code_toks_joined": "def debug ( msg ) : <NEWLINE> <INDENT> if DEBUG : <NEWLINE> print ( msg ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["ecd8200b01c6af9bfacec7fc1c6452cb", {"code_string": "def HTTP_GET_rjson(self, resourceURL, Timeout_Dur = 90, error_log = '', debug = 0):\n    try:\n        if debug == 1: print \"HTTP GET for URL: \" + str(resourceURL) + \"...\\n\\n\"\n        HTTP_Response = requests.Session()\n        HTTP_Response = requests.request(\"GET\", str(resourceURL), timeout = Timeout_Dur, verify = False)\n        HTTP_ResponseRAW = HTTP_Response.json()\n        if debug == 1:\n            print \"\\n\\n Got back: \" + str(HTTP_ResponseRAW) + \"\\n\\n\"\n        return HTTP_ResponseRAW\n    except OSError:\n        return \"Could not fetch HTTP GET.Reason: \" + sys.exc_info()[0]\n", "code_toks_joined": "def HTTP_GET_rjson ( self , resourceURL , Timeout_Dur = 90 , error_log = <STRING> , debug = 0 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if debug == 1 : print <STRING> + str ( resourceURL ) + <STRING> <NEWLINE> HTTP_Response = requests . Session ( ) <NEWLINE> HTTP_Response = requests . request ( <STRING> , str ( resourceURL ) , timeout = Timeout_Dur , verify = False ) <NEWLINE> HTTP_ResponseRAW = HTTP_Response . json ( ) <NEWLINE> if debug == 1 : <NEWLINE> <INDENT> print <STRING> + str ( HTTP_ResponseRAW ) + <STRING> <NEWLINE> <DEDENT> return HTTP_ResponseRAW <NEWLINE> <DEDENT> except OSError : <NEWLINE> <INDENT> return <STRING> + sys . exc_info ( ) [ 0 ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "\"HTTP GET for URL: \"", "\"...\\n\\n\"", "\"GET\"", "\"\\n\\n Got back: \"", "\"\\n\\n\"", "\"Could not fetch HTTP GET.Reason: \""]}, "err_obj": {"msg": "invalid syntax"}}], ["6fed4a211957b164538202498823371d", {"code_string": "def _get_message_data(self, msg_data):\n    if(not msg_data or\n        ('text' not in msg_data and 'data' not in msg_data) or\n        'from' not in msg_data or\n        msg_data['from'].get('id') not in self.allowed_chat_ids):\n        _LOGGER.error(\"Incoming message does not have required data (%s)\",\n            msg_data)\n            return None\n    return{\n        ATTR_USER_ID: msg_data['from']['id'],\n        ATTR_FROM_FIRST: msg_data['from']['first_name'],\n        ATTR_FROM_LAST: msg_data['from']['last_name']\n    }\n", "code_toks_joined": "def _get_message_data ( self , msg_data ) : <NEWLINE> <INDENT> if ( not msg_data or <NEWLINE> <INDENT> ( <STRING> not in msg_data and <STRING> not in msg_data ) or <NEWLINE> <STRING> not in msg_data or <NEWLINE> msg_data [ <STRING> ] . get ( <STRING> ) not in self . allowed_chat_ids ) : <NEWLINE> _LOGGER . error ( <STRING> , <NEWLINE> <INDENT> msg_data ) <NEWLINE> return None <NEWLINE> <DEDENT> <DEDENT> return { <NEWLINE> <INDENT> ATTR_USER_ID : msg_data [ <STRING> ] [ <STRING> ] , <NEWLINE> ATTR_FROM_FIRST : msg_data [ <STRING> ] [ <STRING> ] , <NEWLINE> ATTR_FROM_LAST : msg_data [ <STRING> ] [ <STRING> ] <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'text'", "'data'", "'from'", "'from'", "'id'", "\"Incoming message does not have required data (%s)\"", "'from'", "'id'", "'from'", "'first_name'", "'from'", "'last_name'"]}, "err_obj": {"msg": "unexpected indent"}}], ["ec4a7f0d1e5fc99207387ec054fca339", {"code_string": "def __init__(self, parent, id):\n    self.winWidth, self.winHeight = wx.DisplaySize()\n    wx.Frame.__init__(self, parent, id, 'EMatch')\n        style = self.GetWindowStyle()\n    self.SetWindowStyle(style | wx.STAY_ON_TOP)\n    self.parent = parent\n    self.Maximize(True)\n    self.Center(True)\n    self.MakeModal(True)\n    self.initializeParameters()\n    self.createGui()\n    self.createBindings()\n    self.initializeTimer()\n", "code_toks_joined": "def __init__ ( self , parent , id ) : <NEWLINE> <INDENT> self . winWidth , self . winHeight = wx . DisplaySize ( ) <NEWLINE> wx . Frame . __init__ ( self , parent , id , <STRING> ) <NEWLINE> <INDENT> style = self . GetWindowStyle ( ) <NEWLINE> <DEDENT> self . SetWindowStyle ( style | wx . STAY_ON_TOP ) <NEWLINE> self . parent = parent <NEWLINE> self . Maximize ( True ) <NEWLINE> self . Center ( True ) <NEWLINE> self . MakeModal ( True ) <NEWLINE> self . initializeParameters ( ) <NEWLINE> self . createGui ( ) <NEWLINE> self . createBindings ( ) <NEWLINE> self . initializeTimer ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'EMatch'"]}, "err_obj": {"msg": "unexpected indent"}}], ["bd75f2ef449009a75a14fe4e68ad663b", {"code_string": "def find(self, sensornum):\n    history = self.findwithoutcreating(sensornum)\n    if history != None:\n        return history\n            history = SensorHistory(sensornum)\n            self.sensorhistories.append(history)\n            return history\n", "code_toks_joined": "def find ( self , sensornum ) : <NEWLINE> <INDENT> history = self . findwithoutcreating ( sensornum ) <NEWLINE> if history != None : <NEWLINE> <INDENT> return history <NEWLINE> <INDENT> history = SensorHistory ( sensornum ) <NEWLINE> self . sensorhistories . append ( history ) <NEWLINE> return history <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["6178ad1ca6ce33e3a5f80e6c10768c9d", {"code_string": "def get_direction((x1, y1), (x2, y2)):\n    \"\"\"Returns the compass direction point from (x1, y1) to (x2, y2) with\"\"\"\n    d = \"\"\n    if y1 < y2:\n        d += \"s\"\n    elif y1 > y2:\n        d += \"n\"\n    if x1 < x2:\n        d += \"e\"\n    elif x1 > x2:\n        d += \"w\"\n    if d == \"\":\n        return None\n    else:\n        return Direction(d)\n", "code_toks_joined": "def get_direction ( ( x1 , y1 ) , ( x2 , y2 ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> d = <STRING> <NEWLINE> if y1 < y2 : <NEWLINE> <INDENT> d += <STRING> <NEWLINE> <DEDENT> elif y1 > y2 : <NEWLINE> <INDENT> d += <STRING> <NEWLINE> <DEDENT> if x1 < x2 : <NEWLINE> <INDENT> d += <STRING> <NEWLINE> <DEDENT> elif x1 > x2 : <NEWLINE> <INDENT> d += <STRING> <NEWLINE> <DEDENT> if d == <STRING> : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return Direction ( d ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns the compass direction point from (x1, y1) to (x2, y2) with\"\"\"", "\"\"", "\"s\"", "\"n\"", "\"e\"", "\"w\"", "\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["a62dc8b4813222d9d03d402460ce3c2b", {"code_string": "def _handle_head(self, path, node, upper = 1024 * 1024):\n    data = ''\n    for load in self._client._read_file(path, node, tail_only = False,\n        check_crc = False):\n        data += load\n        if(len(data) > upper):\n        return data\n    return data\n", "code_toks_joined": "def _handle_head ( self , path , node , upper = 1024 * 1024 ) : <NEWLINE> <INDENT> data = <STRING> <NEWLINE> for load in self . _client . _read_file ( path , node , tail_only = False , <NEWLINE> <INDENT> check_crc = False ) : <NEWLINE> data += load <NEWLINE> if ( len ( data ) > upper ) : <NEWLINE> return data <NEWLINE> <DEDENT> return data <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''"]}, "err_obj": {"msg": "expected an indented block"}}], ["3b1d4dead0fba7ccb52e39ddba7f53a8", {"code_string": "def test_ToRawUri(self):\n    print(\"***==== Test To Raw Uri Value ====***\"\n    epc = self._gsrn96.encode(self._companyPrefix, 0, self._serviceReference, self._filter, 0)\n    print(epc.toEPCRawUri())\n    print(\"***==== END  Test To EPC Tag Uri Value ====***\"\n    print(\"\"\n", "code_toks_joined": "def test_ToRawUri ( self ) : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> epc = self . _gsrn96 . encode ( self . _companyPrefix , 0 , self . _serviceReference , self . _filter , 0 ) <NEWLINE> print ( epc . toEPCRawUri ( ) ) <NEWLINE> print ( <STRING> <NEWLINE> print ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"***==== Test To Raw Uri Value ====***\"", "\"***==== END  Test To EPC Tag Uri Value ====***\"", "\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["15172a8ed4361072ce8b7fe76424705a", {"code_string": "def test_check_for_setup_error_version(self):\n    drv = self._driver\n    drv._client = api.NaServer(\"127.0.0.1\")\n    self.assertRaises(exception.VolumeBackendAPIException\n        drv.check_for_setup_error)\n    drv._client.set_api_version(1, 8)\n    self.assertRaises(exception.VolumeBackendAPIException,\n        drv.check_for_setup_error)\n", "code_toks_joined": "def test_check_for_setup_error_version ( self ) : <NEWLINE> <INDENT> drv = self . _driver <NEWLINE> drv . _client = api . NaServer ( <STRING> ) <NEWLINE> self . assertRaises ( exception . VolumeBackendAPIException <NEWLINE> <INDENT> drv . check_for_setup_error ) <NEWLINE> <DEDENT> drv . _client . set_api_version ( 1 , 8 ) <NEWLINE> self . assertRaises ( exception . VolumeBackendAPIException , <NEWLINE> <INDENT> drv . check_for_setup_error ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"127.0.0.1\""]}, "err_obj": {"msg": "invalid syntax"}}], ["ff800d3b1ea5c749fde463b86541bca9", {"code_string": "class ContributionsByDateTestCase(TestCase):\n    def test_unicode_method(self):\n        today = datetime.date.today()\n        obj = models.ContributionsByDate(date = today, amount = 20.00,\n            total = 1)\n        self.assertEqual('{date}$20.00 via 1 contribution(s)'.format(\n            date = today), str(obj)\n", "code_toks_joined": "class ContributionsByDateTestCase ( TestCase ) : <NEWLINE> <INDENT> def test_unicode_method ( self ) : <NEWLINE> <INDENT> today = datetime . date . today ( ) <NEWLINE> obj = models . ContributionsByDate ( date = today , amount = 20.00 , <NEWLINE> <INDENT> total = 1 ) <NEWLINE> <DEDENT> self . assertEqual ( <STRING> . format ( <NEWLINE> <INDENT> date = today ) , str ( obj ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'{date}$20.00 via 1 contribution(s)'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["d276b1d2cb51e0d2a07d86888329a757", {"code_string": "def test_apt_compile_and_run(self, strategy):\n    with self.do_test_compile('testprojects/src/java/org/pantsbuild/testproject/annotation/main',\n        strategy,\n        expected_files = ['Main.class',\n            'deprecation_report.txt']) as found:\n            self.assertTrue(\n            self.get_only(found, 'Main.class').endswith(\n            'org/pantsbuild/testproject/annotation/main/Main.class'))\n            with open(self.get_only(found, 'deprecation_report.txt')) as fp:\n            self.assertIn('org.pantsbuild.testproject.annotation.main.Main', fp.read().splitlines())\n", "code_toks_joined": "def test_apt_compile_and_run ( self , strategy ) : <NEWLINE> <INDENT> with self . do_test_compile ( <STRING> , <NEWLINE> <INDENT> strategy , <NEWLINE> expected_files = [ <STRING> , <NEWLINE> <INDENT> <STRING> ] ) as found : <NEWLINE> self . assertTrue ( <NEWLINE> self . get_only ( found , <STRING> ) . endswith ( <NEWLINE> <STRING> ) ) <NEWLINE> with open ( self . get_only ( found , <STRING> ) ) as fp : <NEWLINE> self . assertIn ( <STRING> , fp . read ( ) . splitlines ( ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'testprojects/src/java/org/pantsbuild/testproject/annotation/main'", "'Main.class'", "'deprecation_report.txt'", "'Main.class'", "'org/pantsbuild/testproject/annotation/main/Main.class'", "'deprecation_report.txt'", "'org.pantsbuild.testproject.annotation.main.Main'"]}, "err_obj": {"msg": "expected an indented block"}}], ["80eb7c4457713ed91a2bc295523ee991", {"code_string": "def parse_implicit_document_start(self):\n    if not self.check_token(DirectiveToken, DocumentStartToken,\n        StreamEndToken):\n        self.tag_handles = self.DEFAULT_TAGS\n        token = self.peek_token()\n        start_mark = end_mark = token.start_mark\n        event = DocumentStartEvent(start_mark, end_mark,\n            explicit = False)\n            self.states.append(self.parse_document_end)\n            self.state = self.parse_block_node\n            return event\n    else:\n        return self.parse_document_start()\n", "code_toks_joined": "def parse_implicit_document_start ( self ) : <NEWLINE> <INDENT> if not self . check_token ( DirectiveToken , DocumentStartToken , <NEWLINE> <INDENT> StreamEndToken ) : <NEWLINE> self . tag_handles = self . DEFAULT_TAGS <NEWLINE> token = self . peek_token ( ) <NEWLINE> start_mark = end_mark = token . start_mark <NEWLINE> event = DocumentStartEvent ( start_mark , end_mark , <NEWLINE> <INDENT> explicit = False ) <NEWLINE> self . states . append ( self . parse_document_end ) <NEWLINE> self . state = self . parse_block_node <NEWLINE> return event <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return self . parse_document_start ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["b991f5312ec86b80bfd483b3ab3ecf79", {"code_string": "class FakeBrcdFCSanLookupService(object):\n    def get_device_mapping_from_network(self,\n        initiator_wwn_list,\n        target_wwn_list):\n        device_map = {}\n        initiators = []\n        targets = []\n        for i in initiator_wwn_list:\n        if(i in _initiator_ns_map[_fabric_wwn]):\n        initiators.append(i)\n        for t in target_wwn_list:\n        if(t in _target_ns_map[_fabric_wwn]):\n        targets.append(t)\n        device_map[_fabric_wwn] = {\n        'initiator_port_wwn_list': initiators,\n        'target_port_wwn_list': targets}\n        return device_map\n", "code_toks_joined": "class FakeBrcdFCSanLookupService ( object ) : <NEWLINE> <INDENT> def get_device_mapping_from_network ( self , <NEWLINE> <INDENT> initiator_wwn_list , <NEWLINE> target_wwn_list ) : <NEWLINE> device_map = { } <NEWLINE> initiators = [ ] <NEWLINE> targets = [ ] <NEWLINE> for i in initiator_wwn_list : <NEWLINE> if ( i in _initiator_ns_map [ _fabric_wwn ] ) : <NEWLINE> initiators . append ( i ) <NEWLINE> for t in target_wwn_list : <NEWLINE> if ( t in _target_ns_map [ _fabric_wwn ] ) : <NEWLINE> targets . append ( t ) <NEWLINE> device_map [ _fabric_wwn ] = { <NEWLINE> <STRING> : initiators , <NEWLINE> <STRING> : targets } <NEWLINE> return device_map <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'initiator_port_wwn_list'", "'target_port_wwn_list'"]}, "err_obj": {"msg": "expected an indented block"}}], ["fa41a0090b7e82c98ac936034bfa776c", {"code_string": "def tearDownClass(cls):\n    if cls.ctx is not None:\n        for group in[cls.ctx.web_security_group,\n            cls.ctx.nat_security_group,\n            cls.ctx.db_security_group]:\n            if not group:\n            continue\n            try:\n            cls._revoke_security_group_linked_rules(group)\n            except Exception:\n            pass\n    super(VPC_Scenario, cls).tearDownClass()\n", "code_toks_joined": "def tearDownClass ( cls ) : <NEWLINE> <INDENT> if cls . ctx is not None : <NEWLINE> <INDENT> for group in [ cls . ctx . web_security_group , <NEWLINE> <INDENT> cls . ctx . nat_security_group , <NEWLINE> cls . ctx . db_security_group ] : <NEWLINE> if not group : <NEWLINE> continue <NEWLINE> try : <NEWLINE> cls . _revoke_security_group_linked_rules ( group ) <NEWLINE> except Exception : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT> super ( VPC_Scenario , cls ) . tearDownClass ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["67fbb4c803ad2e1973a76b8006a9d953", {"code_string": "class tracer_chunk:\n    def __init__(self, nid, pkt_type, link_id, rem_, ndp_):\n        self.nid = nid\n        self.ndp = ndp_\n            self.chunktype = pkt_type\n        if pkt_type == \"QSPN\":\n            self.chunk = qspn_chunk(link_id, rem_)\n    def print_chuncks(self):\n        print(\"nid:\", self.nid)\n        print(\"chunktype:\", self.chunktype)\n        if self.chunktype == \"QSPN\":\n            self.chunk.print_qspn_ch()\n", "code_toks_joined": "class tracer_chunk : <NEWLINE> <INDENT> def __init__ ( self , nid , pkt_type , link_id , rem_ , ndp_ ) : <NEWLINE> <INDENT> self . nid = nid <NEWLINE> self . ndp = ndp_ <NEWLINE> <INDENT> self . chunktype = pkt_type <NEWLINE> <DEDENT> if pkt_type == <STRING> : <NEWLINE> <INDENT> self . chunk = qspn_chunk ( link_id , rem_ ) <NEWLINE> <DEDENT> <DEDENT> def print_chuncks ( self ) : <NEWLINE> <INDENT> print ( <STRING> , self . nid ) <NEWLINE> print ( <STRING> , self . chunktype ) <NEWLINE> if self . chunktype == <STRING> : <NEWLINE> <INDENT> self . chunk . print_qspn_ch ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"QSPN\"", "\"nid:\"", "\"chunktype:\"", "\"QSPN\""]}, "err_obj": {"msg": "unexpected indent"}}], ["e6fcdd4c6bb06a8868b8e7b57d2d3a83", {"code_string": "def test_list_view(self):\n    \"\"\"roles list view returns 200\"\"\"\n    response = self.client.get(\n        reverse('misago: admin: permissions: users: index')\n    self.assertEqual(response.status_code, 200)\n", "code_toks_joined": "def test_list_view ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> response = self . client . get ( <NEWLINE> <INDENT> reverse ( <STRING> ) <NEWLINE> <DEDENT> self . assertEqual ( response . status_code , 200 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"roles list view returns 200\"\"\"", "'misago: admin: permissions: users: index'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["94bbc7b417fb18af1c4996cd34e28803", {"code_string": "def Init_LCA_Scores(vertex, node_dict):\n    for tnode in node_dict:\n        vertex.lca_scores[tnode.name] = node.maxInt\n    for kid_branches in vertex.child_branches:\n        for kid_nodes in kid_branches.ends:\n        if kid_nodes is not vertex:\n            kid_nodes.Init_LCA_Scores(node_dict)\n", "code_toks_joined": "def Init_LCA_Scores ( vertex , node_dict ) : <NEWLINE> <INDENT> for tnode in node_dict : <NEWLINE> <INDENT> vertex . lca_scores [ tnode . name ] = node . maxInt <NEWLINE> <DEDENT> for kid_branches in vertex . child_branches : <NEWLINE> <INDENT> for kid_nodes in kid_branches . ends : <NEWLINE> if kid_nodes is not vertex : <NEWLINE> <INDENT> kid_nodes . Init_LCA_Scores ( node_dict ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["f9806272b0af01f523c98c6658949b5c", {"code_string": "def show_frame(self, (frame, lineno)):\n    self.frame = frame\n    self.show_variables()\n", "code_toks_joined": "def show_frame ( self , ( frame , lineno ) ) : <NEWLINE> <INDENT> self . frame = frame <NEWLINE> self . show_variables ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["9c09c1fbb9bea6ca4bcbed436dbbffd5", {"code_string": "def extract_lines(filename):\n    file = open(filename 'r')\n    objs = []\n    while True:\n        nextobj = re.sub('[\\n\\r]', '', file.readline())\n        if nextobj == '':\n            break\n        else:\n            objs +=[nextobj]\n    return(objs)\n", "code_toks_joined": "def extract_lines ( filename ) : <NEWLINE> <INDENT> file = open ( filename <STRING> ) <NEWLINE> objs = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> nextobj = re . sub ( <STRING> , <STRING> , file . readline ( ) ) <NEWLINE> if nextobj == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> objs += [ nextobj ] <NEWLINE> <DEDENT> <DEDENT> return ( objs ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'r'", "'[\\n\\r]'", "''", "''"]}, "err_obj": {"msg": "invalid syntax"}}], ["865d87257736e7c4c97168794cc53238", {"code_string": "def testVariableWithRegularizerColocate(self):\n    with self.test_session():\n        with tf.variable_scope('A'):\n            a = tf.contrib.framework.variable('a', [], device = 'gpu:0'\n                regularizer = tf.nn.l2_loss)\n        loss = tf.get_collection(tf.GraphKeys.REGULARIZATION_LOSSES)[0]\n        self.assertDeviceEqual(loss.device, a.device)\n", "code_toks_joined": "def testVariableWithRegularizerColocate ( self ) : <NEWLINE> <INDENT> with self . test_session ( ) : <NEWLINE> <INDENT> with tf . variable_scope ( <STRING> ) : <NEWLINE> <INDENT> a = tf . contrib . framework . variable ( <STRING> , [ ] , device = <STRING> <NEWLINE> <INDENT> regularizer = tf . nn . l2_loss ) <NEWLINE> <DEDENT> <DEDENT> loss = tf . get_collection ( tf . GraphKeys . REGULARIZATION_LOSSES ) [ 0 ] <NEWLINE> self . assertDeviceEqual ( loss . device , a . device ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'A'", "'a'", "'gpu:0'"]}, "err_obj": {"msg": "invalid syntax"}}], ["784e88fed896b9fbce947562024471b3", {"code_string": "class MockGlobalConfig(object):\n    def __init__(self):\n        self._config_info = {}\n    def set_config_value(self, section, key, value):\n        self._config_info[(section, key)] = value\n    def get_config_value(self, section, key, type = str,\n        default = None, allow_blank = False):\n        identifier = (section, key)\n        if identifier not in self._config_info:\n        return default\n        return self._config_info[identifier]\n", "code_toks_joined": "class MockGlobalConfig ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . _config_info = { } <NEWLINE> <DEDENT> def set_config_value ( self , section , key , value ) : <NEWLINE> <INDENT> self . _config_info [ ( section , key ) ] = value <NEWLINE> <DEDENT> def get_config_value ( self , section , key , type = str , <NEWLINE> <INDENT> default = None , allow_blank = False ) : <NEWLINE> identifier = ( section , key ) <NEWLINE> if identifier not in self . _config_info : <NEWLINE> return default <NEWLINE> return self . _config_info [ identifier ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["d1855f405f9e902d35bc536bfeb7d758", {"code_string": "Fib()\n    a, b = b, a + b\n    str(a)\nif len(a) > 1000\nprint(a)\n", "code_toks_joined": "Fib ( ) <NEWLINE> <INDENT> a , b = b , a + b <NEWLINE> str ( a ) <NEWLINE> <DEDENT> if len ( a ) > 1000 <NEWLINE> print ( a ) <NEWLINE>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["f7c9378872a976b77bed979e7a81f463", {"code_string": "class Ui_Dialog(object):\n    def setupUi(self, Dialog):\n        Dialog.setObjectName(\"Dialog\")\n        Dialog.resize(983, 989)\n        self.gridLayout_3 = QtWidgets.QGridLayout(Dialog)\n        self.gridLayout_3.setObjectName(\"gridLayout_3\")\n        self.textBrowser = QtWidgets.QTextBrowser(Dialog)\n        self.textBrowser.setOpenExternalLinks(True)\n        self.textBrowser.setObjectName(\"textBrowser\")\n        self.gridLayout_3.addWidget(self.textBrowser, 0, 0, 1, 1)\n        self.retranslateUi(Dialog)\n        QtCore.QMetaObject.connectSlotsByName(Dialog)\n    def retranslateUi(self, Dialog):\n        _translate = QtCore.QCoreApplication.translate\n        Dialog.setWindowTitle(_translate(\"Dialog\", \"Dialog\"))\n        self.textBrowser.setHtml(_translate(\"Dialog\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "class Ui_Dialog ( object ) : <NEWLINE> <INDENT> def setupUi ( self , Dialog ) : <NEWLINE> <INDENT> Dialog . setObjectName ( <STRING> ) <NEWLINE> Dialog . resize ( 983 , 989 ) <NEWLINE> self . gridLayout_3 = QtWidgets . QGridLayout ( Dialog ) <NEWLINE> self . gridLayout_3 . setObjectName ( <STRING> ) <NEWLINE> self . textBrowser = QtWidgets . QTextBrowser ( Dialog ) <NEWLINE> self . textBrowser . setOpenExternalLinks ( True ) <NEWLINE> self . textBrowser . setObjectName ( <STRING> ) <NEWLINE> self . gridLayout_3 . addWidget ( self . textBrowser , 0 , 0 , 1 , 1 ) <NEWLINE> self . retranslateUi ( Dialog ) <NEWLINE> QtCore . QMetaObject . connectSlotsByName ( Dialog ) <NEWLINE> <DEDENT> def retranslateUi ( self , Dialog ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> Dialog . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . textBrowser . setHtml ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Dialog\"", "\"gridLayout_3\"", "\"textBrowser\"", "\"Dialog\"", "\"Dialog\"", "\"Dialog\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "window_span": [154, 163], "err_obj": {"msg": "unbalanced (){}[]"}}], ["18a43f8c683b205f78866c8962187cc8", {"code_string": "def send_batch(self, inserts):\n    self.session.execute(\"BEGIN BATCH\\n\" + \"\\n\".join(inserts) + \"\\nAPPLY BATCH;\")\n        log.info(\"batch of tweets loaded into db\")\n", "code_toks_joined": "def send_batch ( self , inserts ) : <NEWLINE> <INDENT> self . session . execute ( <STRING> + <STRING> . join ( inserts ) + <STRING> ) <NEWLINE> <INDENT> log . info ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"BEGIN BATCH\\n\"", "\"\\n\"", "\"\\nAPPLY BATCH;\"", "\"batch of tweets loaded into db\""]}, "err_obj": {"msg": "unexpected indent"}}], ["5b6fe992387128466c2da370c7fd7d44", {"code_string": "def assertIn(self, target, source):\n    \"\"\"Overwrite stdlib to swap the arguments.\"\"\"\n    if source not in target:\n        message = u'%s not in %s.' %(repr(source), repr(target)\n        raise AssertionError(message.encode('utf-8'))\n", "code_toks_joined": "def assertIn ( self , target , source ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if source not in target : <NEWLINE> <INDENT> message = <STRING> % ( repr ( source ) , repr ( target ) <NEWLINE> raise AssertionError ( message . encode ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Overwrite stdlib to swap the arguments.\"\"\"", "u'%s not in %s.'", "'utf-8'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["12b69dd3b108b35b1800d19c22067efd", {"code_string": "def get_identity(self):\n    \"\"\"Returns the UID, the UID where the Bricklet is connected to, \"\"\"\n    return GetIdentity(* self.ipcon.send_request(self, BrickletIndustrialAnalogOut.FUNCTION_GET_IDENTITY, (), '', '8s 8s c 3B 3B H')\n", "code_toks_joined": "def get_identity ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return GetIdentity ( * self . ipcon . send_request ( self , BrickletIndustrialAnalogOut . FUNCTION_GET_IDENTITY , ( ) , <STRING> , <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns the UID, the UID where the Bricklet is connected to, \"\"\"", "''", "'8s 8s c 3B 3B H'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["b06a32af0fd05194815037beae6eb93f", {"code_string": "def join(path, * args):\n    \"\"\"Join two or more pathname components, inserting os.sep as needed\"\"\"\n    path = _tostr(path, \"join\")\n    f = File(path)\n    for a in args:\n        a = _tostr(a, \"join\")\n        g = File(a)\n        if g.isAbsolute() or len(f.getPath()) == 0:\n        f = g\n        else:\n        f = File(f, a)\n    return f.getPath()\n", "code_toks_joined": "def join ( path , * args ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> path = _tostr ( path , <STRING> ) <NEWLINE> f = File ( path ) <NEWLINE> for a in args : <NEWLINE> <INDENT> a = _tostr ( a , <STRING> ) <NEWLINE> g = File ( a ) <NEWLINE> if g . isAbsolute ( ) or len ( f . getPath ( ) ) == 0 : <NEWLINE> f = g <NEWLINE> else : <NEWLINE> f = File ( f , a ) <NEWLINE> <DEDENT> return f . getPath ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Join two or more pathname components, inserting os.sep as needed\"\"\"", "\"join\"", "\"join\""]}, "err_obj": {"msg": "expected an indented block"}}], ["9149b9cdd17176894aa59220e52494f3", {"code_string": "class Ui_Dialog(object):\n    def setupUi(self, Dialog):\n        Dialog.setObjectName(_fromUtf8(\"Dialog\"))\n        Dialog.resize(652, 628)\n        Dialog.setStyleSheet(_fromUtf8(\".QLabel{\\n\"\n", "code_toks_joined": "class Ui_Dialog ( object ) : <NEWLINE> <INDENT> def setupUi ( self , Dialog ) : <NEWLINE> <INDENT> Dialog . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> Dialog . resize ( 652 , 628 ) <NEWLINE> Dialog . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Dialog\"", "\".QLabel{\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["5a395ae6d1ea2d0892c8b208bfec84a6", {"code_string": "def tpValues_(self):\n    r = []\n    tname = self.__name__\n    for d in self._c.columns(tname)\n        b = ColumnBrowser()\n        b._d = d\n        try: b.icon = field_icons[d['Type']]\n        except: pass\n        b.TABLE_NAME = tname\n        r.append(b)\n    return r\n", "code_toks_joined": "def tpValues_ ( self ) : <NEWLINE> <INDENT> r = [ ] <NEWLINE> tname = self . __name__ <NEWLINE> for d in self . _c . columns ( tname ) <NEWLINE> <INDENT> b = ColumnBrowser ( ) <NEWLINE> b . _d = d <NEWLINE> try : b . icon = field_icons [ d [ <STRING> ] ] <NEWLINE> except : pass <NEWLINE> b . TABLE_NAME = tname <NEWLINE> r . append ( b ) <NEWLINE> <DEDENT> return r <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Type'"]}, "err_obj": {"msg": "invalid syntax"}}], ["8cc773a30d87cd286fd09c518d0942e5", {"code_string": "def quadraticFormulaOne(a, b, c):\n    quad = (- b + squareRoot((b ** 2 - 4 * a * c))) / 2 a\n    return quad\n", "code_toks_joined": "def quadraticFormulaOne ( a , b , c ) : <NEWLINE> <INDENT> quad = ( - b + squareRoot ( ( b ** 2 - 4 * a * c ) ) ) / 2 a <NEWLINE> return quad <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["ccb94477ba3a9e84421d17e70476d660", {"code_string": "def map_sync_outputs(self, instance, res):\n    instance_id = res[0]['info']['OS-EXT-SRV-ATTR:instance_name']\n        instance_uuid = res[0]['id']\n    try:\n        hostname = res[0]['info']['OS-EXT-SRV-ATTR:hypervisor_hostname']\n        ip = socket.gethostbyname(hostname)\n        instance.ip = ip\n        except:\n        pass\n        instance.instance_id = instance_id\n        instance.instance_uuid = instance_uuid\n        instance.instance_name = self.instance_name\n        instance.save()\n", "code_toks_joined": "def map_sync_outputs ( self , instance , res ) : <NEWLINE> <INDENT> instance_id = res [ 0 ] [ <STRING> ] [ <STRING> ] <NEWLINE> <INDENT> instance_uuid = res [ 0 ] [ <STRING> ] <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> hostname = res [ 0 ] [ <STRING> ] [ <STRING> ] <NEWLINE> ip = socket . gethostbyname ( hostname ) <NEWLINE> instance . ip = ip <NEWLINE> except : <NEWLINE> pass <NEWLINE> instance . instance_id = instance_id <NEWLINE> instance . instance_uuid = instance_uuid <NEWLINE> instance . instance_name = self . instance_name <NEWLINE> instance . save ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'info'", "'OS-EXT-SRV-ATTR:instance_name'", "'id'", "'info'", "'OS-EXT-SRV-ATTR:hypervisor_hostname'"]}, "err_obj": {"msg": "unexpected indent"}}], ["44441eb0c5e245056839b0dae8026178", {"code_string": "class Model:\n    def __init__(self):\n        self.loadVocabulary()\n        view = View()\n        view.set_start_game_callback()\n    def loadVocabulary(self):\n    self.vocabulary = Utils()\n    self.vocabulary.openFile()\n    def searchWords(self):\n    pass\n    def comparison(self):\n    pass\n", "code_toks_joined": "class Model : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . loadVocabulary ( ) <NEWLINE> view = View ( ) <NEWLINE> view . set_start_game_callback ( ) <NEWLINE> <DEDENT> def loadVocabulary ( self ) : <NEWLINE> self . vocabulary = Utils ( ) <NEWLINE> self . vocabulary . openFile ( ) <NEWLINE> def searchWords ( self ) : <NEWLINE> pass <NEWLINE> def comparison ( self ) : <NEWLINE> pass <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["c926b8c1a292155c18323e61d61aa4ca", {"code_string": "def upgrade(migrate_engine):\n    metadata.bind = migrate_engine\n    print(__doc__)\n    metadata.reflect()\n    if migrate_engine.name != \"mysql\":\n        return\n    for(table, column) in BLOB_COLUMNS:\n        cmd = \"ALTER TABLE %s MODIFY COLUMN %s MEDIUMBLOB; \" %(table, column)\n        try:\n            migrate_engine.execute(cmd)\n        except Exception as e:\n            print(\"Failed to grow column %s.%s\" %(table, column)\n            print(str(e))\n", "code_toks_joined": "def upgrade ( migrate_engine ) : <NEWLINE> <INDENT> metadata . bind = migrate_engine <NEWLINE> print ( __doc__ ) <NEWLINE> metadata . reflect ( ) <NEWLINE> if migrate_engine . name != <STRING> : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for ( table , column ) in BLOB_COLUMNS : <NEWLINE> <INDENT> cmd = <STRING> % ( table , column ) <NEWLINE> try : <NEWLINE> <INDENT> migrate_engine . execute ( cmd ) <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> <INDENT> print ( <STRING> % ( table , column ) <NEWLINE> print ( str ( e ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"mysql\"", "\"ALTER TABLE %s MODIFY COLUMN %s MEDIUMBLOB; \"", "\"Failed to grow column %s.%s\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["b4de330dcd3321ed8a888d1635237c0d", {"code_string": "\"\"\"Test-appropriate entry points into the gRPC Python Beta API.\"\"\"\nimport grpc\nfrom grpc.beta import implementations\ndef not_really_secure_channel(\n    host, port, channel_credentials, server_host_override):\n    \"\"\"Creates an insecure Channel to a remote host.\"\"\"\n    target = '%s:%d' %(host, port)\n    channel = grpc.secure_channel(\n        target, channel_credentials,\n        (('grpc.ssl_target_name_override', server_host_override, ), ))\n        return implementations.Channel(channel)\n", "code_toks_joined": "<STRING> <NEWLINE> import grpc <NEWLINE> from grpc . beta import implementations <NEWLINE> def not_really_secure_channel ( <NEWLINE> <INDENT> host , port , channel_credentials , server_host_override ) : <NEWLINE> <STRING> <NEWLINE> target = <STRING> % ( host , port ) <NEWLINE> channel = grpc . secure_channel ( <NEWLINE> <INDENT> target , channel_credentials , <NEWLINE> ( ( <STRING> , server_host_override , ) , ) ) <NEWLINE> return implementations . Channel ( channel ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Test-appropriate entry points into the gRPC Python Beta API.\"\"\"", "\"\"\"Creates an insecure Channel to a remote host.\"\"\"", "'%s:%d'", "'grpc.ssl_target_name_override'"]}, "err_obj": {"msg": "unexpected indent"}}], ["40f23e976ce28c3c6c4f29439210cb32", {"code_string": "class Capacitor(Device):\n    __name__ = \"capacitor\"\n    __type__ = \"instance\"\n    __indent__ = \"\"\n    def __init__(self, name = 'C1', nodes = ('in', 'out'), c = 1e-12, ** parameters):\n    Device.__init__(self, name = name, nodes = nodes, model = 'capacitor', c = c, ** parameters)\n", "code_toks_joined": "class Capacitor ( Device ) : <NEWLINE> <INDENT> __name__ = <STRING> <NEWLINE> __type__ = <STRING> <NEWLINE> __indent__ = <STRING> <NEWLINE> def __init__ ( self , name = <STRING> , nodes = ( <STRING> , <STRING> ) , c = 1e-12 , ** parameters ) : <NEWLINE> Device . __init__ ( self , name = name , nodes = nodes , model = <STRING> , c = c , ** parameters ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"capacitor\"", "\"instance\"", "\"\"", "'C1'", "'in'", "'out'", "'capacitor'"]}, "err_obj": {"msg": "expected an indented block"}}], ["0c18bcee5812cd926bc2cc0fb8ca82df", {"code_string": "def __init__(self, reader, scripts, zero_based = False):\n    super(ScriptCSVReader, self).__init__()\n    self.zero_based = zero_based\n    self.reader = reader\n    self.scripts = scripts\n    self.compiled_scripts = map(lambda(i, script): (script[0], compile(script[1], 'script-%d' % i, 'eval')),\n        enumerate(self.scripts))\n    self.column_names = reader.next()\n", "code_toks_joined": "def __init__ ( self , reader , scripts , zero_based = False ) : <NEWLINE> <INDENT> super ( ScriptCSVReader , self ) . __init__ ( ) <NEWLINE> self . zero_based = zero_based <NEWLINE> self . reader = reader <NEWLINE> self . scripts = scripts <NEWLINE> self . compiled_scripts = map ( lambda ( i , script ) : ( script [ 0 ] , compile ( script [ 1 ] , <STRING> % i , <STRING> ) ) , <NEWLINE> <INDENT> enumerate ( self . scripts ) ) <NEWLINE> <DEDENT> self . column_names = reader . next ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'script-%d'", "'eval'"]}, "err_obj": {"msg": "invalid syntax"}}], ["719cf14f37a7a5334ae596939e0f16f6", {"code_string": "def retranslateUi(self, Tab):\n    _translate = QtCore.QCoreApplication.translate\n    Tab.setWindowTitle(_translate(\"Tab\", \"Form\"))\n    self.btn_loadImage.setText(_translate(\"Tab\", \"Load Photo...\"))\n    self.ckbox_scrollMode.setText(_translate(\"Tab\", \"synchronous scroll\"))\n    self.btn_encrypt.setText(_translate(\"Tab\", \"Encrypt =>\"))\n    self.btn_decrypt.setText(_translate(\"Tab\", \"Decrypt =>\"))\n    self.btn_encryptEmb.setText(_translate(\"Tab\", \"Encrypt && Emb \\n\"\n", "code_toks_joined": "def retranslateUi ( self , Tab ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> Tab . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . btn_loadImage . setText ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . ckbox_scrollMode . setText ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . btn_encrypt . setText ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . btn_decrypt . setText ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . btn_encryptEmb . setText ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Tab\"", "\"Form\"", "\"Tab\"", "\"Load Photo...\"", "\"Tab\"", "\"synchronous scroll\"", "\"Tab\"", "\"Encrypt =>\"", "\"Tab\"", "\"Decrypt =>\"", "\"Tab\"", "\"Encrypt && Emb \\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["adbc4a33f5252d50f55a4a1004fd149f", {"code_string": "\"\"\"The Microsoft Office MRU Windows Registry event formatter.\"\"\"\nfrom plaso.formatters import interface\nfrom plaso.formatters import manager\nclass OfficeMRUWindowsRegistryEventFormatter(\n    interface.ConditionalEventFormatter):\n    \"\"\"Formatter for a Microsoft Office MRU Windows Registry event.\"\"\"\n    DATA_TYPE = u'windows:registry:office_mru'\n    FORMAT_STRING_PIECES = [\n        u'[{key_path}]',\n        u'Value: {value_string}']\n        FORMAT_STRING_SHORT_PIECES = [\n        u'{value_string}']\n        SOURCE_LONG = u'Registry Key: Microsoft Office MRU'\n        SOURCE_SHORT = u'REG'\nmanager.FormattersManager.RegisterFormatter(\n    OfficeMRUWindowsRegistryEventFormatter)\n", "code_toks_joined": "<STRING> <NEWLINE> from plaso . formatters import interface <NEWLINE> from plaso . formatters import manager <NEWLINE> class OfficeMRUWindowsRegistryEventFormatter ( <NEWLINE> <INDENT> interface . ConditionalEventFormatter ) : <NEWLINE> <STRING> <NEWLINE> DATA_TYPE = <STRING> <NEWLINE> FORMAT_STRING_PIECES = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ] <NEWLINE> FORMAT_STRING_SHORT_PIECES = [ <NEWLINE> <STRING> ] <NEWLINE> SOURCE_LONG = <STRING> <NEWLINE> SOURCE_SHORT = <STRING> <NEWLINE> <DEDENT> <DEDENT> manager . FormattersManager . RegisterFormatter ( <NEWLINE> <INDENT> OfficeMRUWindowsRegistryEventFormatter ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"The Microsoft Office MRU Windows Registry event formatter.\"\"\"", "\"\"\"Formatter for a Microsoft Office MRU Windows Registry event.\"\"\"", "u'windows:registry:office_mru'", "u'[{key_path}]'", "u'Value: {value_string}'", "u'{value_string}'", "u'Registry Key: Microsoft Office MRU'", "u'REG'"]}, "err_obj": {"msg": "unexpected indent"}}], ["ca6705113bd0ff88df0b291b138a96e4", {"code_string": "def create_voucher():\n    \"\"\"Helper method for creating a voucher\"\"\"\n    voucher = Voucher.objects.create(\n        name = \"Test voucher\",\n        code = \"test\"\n        start_date = datetime.date.today(),\n        end_date = datetime.date.today() + datetime.timedelta(days = 12))\n    voucher.offers.add(create_offer(offer_type = 'Voucher'))\n    return voucher\n", "code_toks_joined": "def create_voucher ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> voucher = Voucher . objects . create ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> code = <STRING> <NEWLINE> start_date = datetime . date . today ( ) , <NEWLINE> end_date = datetime . date . today ( ) + datetime . timedelta ( days = 12 ) ) <NEWLINE> <DEDENT> voucher . offers . add ( create_offer ( offer_type = <STRING> ) ) <NEWLINE> return voucher <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Helper method for creating a voucher\"\"\"", "\"Test voucher\"", "\"test\"", "'Voucher'"]}, "err_obj": {"msg": "invalid syntax"}}], ["fde599051052f1648f7474ec7dc9bd89", {"code_string": "def last_modified(self):\n    \"\"\"Returns the timestamp at which this case was last modified.\"\"\"\n        return datetime.datetime.now() - self.latest_action.timestamp\n", "code_toks_joined": "def last_modified ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> return datetime . datetime . now ( ) - self . latest_action . timestamp <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns the timestamp at which this case was last modified.\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["b6513fd1dc9bb908c0fb13056b2a06d1", {"code_string": "def _change_server(self):\n    if(self.login_info['ControllerIP0'] and\n        self.login_info['ControllerIP1']):\n        controller_ip = (self.login_info['ControllerIP1']\n            if self.login_info['ControllerIP0'] in self.url\n            else self.login_info['ControllerIP0'])\n            self.url = 'https://' + controller_ip + '/phpclient/client.php'\n", "code_toks_joined": "def _change_server ( self ) : <NEWLINE> <INDENT> if ( self . login_info [ <STRING> ] and <NEWLINE> <INDENT> self . login_info [ <STRING> ] ) : <NEWLINE> controller_ip = ( self . login_info [ <STRING> ] <NEWLINE> <INDENT> if self . login_info [ <STRING> ] in self . url <NEWLINE> else self . login_info [ <STRING> ] ) <NEWLINE> self . url = <STRING> + controller_ip + <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'ControllerIP0'", "'ControllerIP1'", "'ControllerIP1'", "'ControllerIP0'", "'ControllerIP0'", "'https://'", "'/phpclient/client.php'"]}, "err_obj": {"msg": "unexpected indent"}}], ["dbd6fc0f39b862c1594f037a11f7e1d2", {"code_string": "def RegServerFunc(target, source, env):\n    if env.has_key('register') and env['register']:\n        ret = regServerAction([target[0]], [source[0]], env)\n        if ret:\n            raise SCons.Errors.UserError, \"Unable to register %s\" % target[0]\n        else:\n            print(\"Registered %s sucessfully\" % target[0])\n        return ret\n    return 0\n", "code_toks_joined": "def RegServerFunc ( target , source , env ) : <NEWLINE> <INDENT> if env . has_key ( <STRING> ) and env [ <STRING> ] : <NEWLINE> <INDENT> ret = regServerAction ( [ target [ 0 ] ] , [ source [ 0 ] ] , env ) <NEWLINE> if ret : <NEWLINE> <INDENT> raise SCons . Errors . UserError , <STRING> % target [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> % target [ 0 ] ) <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'register'", "'register'", "\"Unable to register %s\"", "\"Registered %s sucessfully\""]}, "err_obj": {"msg": "invalid syntax"}}], ["777b854ac1f80153c0ab90b07331aff6", {"code_string": "class USAddress(raw_ipo.USAddress):\n    def __str__(self):\n        return six.u('''%s%s''') %(self.name(), self.street(), , self.city(), self.state(), self.zip())\n    pass\n", "code_toks_joined": "class USAddress ( raw_ipo . USAddress ) : <NEWLINE> <INDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return six . u ( <STRING> ) % ( self . name ( ) , self . street ( ) , , self . city ( ) , self . state ( ) , self . zip ( ) ) <NEWLINE> <DEDENT> pass <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''%s%s'''"]}, "err_obj": {"msg": "invalid syntax"}}], ["6ca96b70448b5e2b862b2bc321ab5565", {"code_string": "def PuntajeCasillero(self, (x, y), Equipo):\n    if Equipo == EQUIPONEGRO:\n        if y < 4:\n            return 7\n        elif y == 7:\n            return 10\n        else:\n            return 6\n    else:\n        if y > 4:\n            return 7\n        elif y == 0:\n            return 10\n        else:\n            return 6\n", "code_toks_joined": "def PuntajeCasillero ( self , ( x , y ) , Equipo ) : <NEWLINE> <INDENT> if Equipo == EQUIPONEGRO : <NEWLINE> <INDENT> if y < 4 : <NEWLINE> <INDENT> return 7 <NEWLINE> <DEDENT> elif y == 7 : <NEWLINE> <INDENT> return 10 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 6 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if y > 4 : <NEWLINE> <INDENT> return 7 <NEWLINE> <DEDENT> elif y == 0 : <NEWLINE> <INDENT> return 10 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["f019bb4e70c10377cab9274436c1cc1a", {"code_string": "def read_static_uplink(self):\n    \"\"\"Read the static uplink from file, if given.\"\"\"\n    if self.node_list is None or self.node_uplink_list is None:\n        return\n    for node, port in zip(self.node_list.split(','),\n        self.node_uplink_list.split(',')):\n        if node.strip() == self.host_name:\n        self.static_uplink = True\n        self.static_uplink_port = port.strip()\n        return\n", "code_toks_joined": "def read_static_uplink ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . node_list is None or self . node_uplink_list is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for node , port in zip ( self . node_list . split ( <STRING> ) , <NEWLINE> <INDENT> self . node_uplink_list . split ( <STRING> ) ) : <NEWLINE> if node . strip ( ) == self . host_name : <NEWLINE> self . static_uplink = True <NEWLINE> self . static_uplink_port = port . strip ( ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Read the static uplink from file, if given.\"\"\"", "','", "','"]}, "err_obj": {"msg": "expected an indented block"}}], ["a617c1ea961f20332146eb0c177382e7", {"code_string": "def emcToolStartChange(self):\n    if debug(): print \"py: emcToolStartChange\", \"wait for iocontrol.0.start-change-ack\" if self.startchange_pins else \"noop\"\n    if self.startchange_pins:\n        self.hal[\"start-change\"] = 1\n        self.io.status = self.wait_for_named_pin(1, \"iocontrol.0.start-change-ack\", self.start_change_acked)\n        return 0\n    self.io.status = emctask.RCS_STATUS.RCS_DONE\n    return 0\n", "code_toks_joined": "def emcToolStartChange ( self ) : <NEWLINE> <INDENT> if debug ( ) : print <STRING> , <STRING> if self . startchange_pins else <STRING> <NEWLINE> if self . startchange_pins : <NEWLINE> <INDENT> self . hal [ <STRING> ] = 1 <NEWLINE> self . io . status = self . wait_for_named_pin ( 1 , <STRING> , self . start_change_acked ) <NEWLINE> return 0 <NEWLINE> <DEDENT> self . io . status = emctask . RCS_STATUS . RCS_DONE <NEWLINE> return 0 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"py: emcToolStartChange\"", "\"wait for iocontrol.0.start-change-ack\"", "\"noop\"", "\"start-change\"", "\"iocontrol.0.start-change-ack\""]}, "err_obj": {"msg": "invalid syntax"}}], ["82279f394031c4b1dd09222430ac5ae0", {"code_string": "def set_TEST(self, level = True):\n    \"\"\" Controls TEST pin (inverted on board: 0: VCC; 1: GND; unless inverted\"\"\"\n    if self.invertTEST:\n        level = not level\n    if self.testOnTX:\n        self.serial.setBreak(level)\n    else:\n        if self.swapResetTest:\n        GPIO.output(18, level)\n        else:\n        GPIO.output(17, level)\n    time.sleep(self.control_delay)\n", "code_toks_joined": "def set_TEST ( self , level = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . invertTEST : <NEWLINE> <INDENT> level = not level <NEWLINE> <DEDENT> if self . testOnTX : <NEWLINE> <INDENT> self . serial . setBreak ( level ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if self . swapResetTest : <NEWLINE> GPIO . output ( 18 , level ) <NEWLINE> else : <NEWLINE> GPIO . output ( 17 , level ) <NEWLINE> <DEDENT> time . sleep ( self . control_delay ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Controls TEST pin (inverted on board: 0: VCC; 1: GND; unless inverted\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["ac9ba9e9613c333fdea1d778aba0b7a6", {"code_string": "class GoogleFinanceFT(bFeed):\n    \"\"\" PyData reader feed, generalized for google finance. \"\"\"\n    def __init__(self, name, column = 'Close',\n        start = '1995-01-01', end = 'now'):\n        super(GoogleFinanceFT, self).__init__()\n        source = PyDataDataReaderST('google', name, column = column,\n            start = start, end = end)\n            self.sourcing = source.as_dict\n            self._set_stype(source)\n", "code_toks_joined": "class GoogleFinanceFT ( bFeed ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , name , column = <STRING> , <NEWLINE> <INDENT> start = <STRING> , end = <STRING> ) : <NEWLINE> super ( GoogleFinanceFT , self ) . __init__ ( ) <NEWLINE> source = PyDataDataReaderST ( <STRING> , name , column = column , <NEWLINE> <INDENT> start = start , end = end ) <NEWLINE> self . sourcing = source . as_dict <NEWLINE> self . _set_stype ( source ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" PyData reader feed, generalized for google finance. \"\"\"", "'Close'", "'1995-01-01'", "'now'", "'google'"]}, "err_obj": {"msg": "unexpected indent"}}], ["f5877955ffbe0b63bfdde9dad9e56dbf", {"code_string": "def getSpec(self):\n    return dict(type = self.name,\n        of = self.of.getSpec()\n", "code_toks_joined": "def getSpec ( self ) : <NEWLINE> <INDENT> return dict ( type = self . name , <NEWLINE> <INDENT> of = self . of . getSpec ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["036b7bfb493aec83c41e2156e3c85605", {"code_string": "def test_requests_context_retries_read_timeout_retries_exhausted():\n    with mock.patch.object(\n        requests.packages.urllib3.connectionpool.HTTPConnectionPool,\n        '_make_request') as mock_make_request:\n        url, mock_make_request.side_effect = timeout_side_effect(\n            timeout_error = requests.packages.urllib3.exceptions.ReadTimeoutError,\n            num_timeouts = 3)\n            env = Variables(environ = {'PEX_HTTP_RETRIES': '2'})\n            context = RequestsContext(verify = False, env = env)\n            with pytest.raises(Context.Error):\n        context.read(Link.wrap(url))\n", "code_toks_joined": "def test_requests_context_retries_read_timeout_retries_exhausted ( ) : <NEWLINE> <INDENT> with mock . patch . object ( <NEWLINE> <INDENT> requests . packages . urllib3 . connectionpool . HTTPConnectionPool , <NEWLINE> <STRING> ) as mock_make_request : <NEWLINE> url , mock_make_request . side_effect = timeout_side_effect ( <NEWLINE> <INDENT> timeout_error = requests . packages . urllib3 . exceptions . ReadTimeoutError , <NEWLINE> num_timeouts = 3 ) <NEWLINE> env = Variables ( environ = { <STRING> : <STRING> } ) <NEWLINE> context = RequestsContext ( verify = False , env = env ) <NEWLINE> with pytest . raises ( Context . Error ) : <NEWLINE> <DEDENT> context . read ( Link . wrap ( url ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'_make_request'", "'PEX_HTTP_RETRIES'", "'2'"]}, "err_obj": {"msg": "unexpected indent"}}], ["81075e6f5a22017eca3340cc988dc06b", {"code_string": "def find_keyboard_device():\n    for bus in usb.busses():\n        for device in bus.devices:\n        print(device)\n            if device.idVendor == USB_VENDOR and device.idProduct == USB_PRODUCT or device.idProduct == USB_OTHER_PRODUCT:\n                return device\n", "code_toks_joined": "def find_keyboard_device ( ) : <NEWLINE> <INDENT> for bus in usb . busses ( ) : <NEWLINE> <INDENT> for device in bus . devices : <NEWLINE> print ( device ) <NEWLINE> <INDENT> if device . idVendor == USB_VENDOR and device . idProduct == USB_PRODUCT or device . idProduct == USB_OTHER_PRODUCT : <NEWLINE> <INDENT> return device <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["ed83e92d5868960572567160e820df77", {"code_string": "def getTaskFromId(self, tid):\n    if tid == '_'\n        if self.lastTaskId is None:\n            raise YokadiException(\"No previous task defined\")\n        tid = self.lastTaskId\n    task = dbutils.getTaskFromId(tid)\n    if tid != '_':\n        self.lastTaskId = task.id\n    return task\n", "code_toks_joined": "def getTaskFromId ( self , tid ) : <NEWLINE> <INDENT> if tid == <STRING> <NEWLINE> <INDENT> if self . lastTaskId is None : <NEWLINE> <INDENT> raise YokadiException ( <STRING> ) <NEWLINE> <DEDENT> tid = self . lastTaskId <NEWLINE> <DEDENT> task = dbutils . getTaskFromId ( tid ) <NEWLINE> if tid != <STRING> : <NEWLINE> <INDENT> self . lastTaskId = task . id <NEWLINE> <DEDENT> return task <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'_'", "\"No previous task defined\"", "'_'"]}, "err_obj": {"msg": "invalid syntax"}}], ["29a6c4af295573a1bd233697669a30d6", {"code_string": "def tearDown(self):\n    for d in[\"var/lib/apt/lists/\",\n        \"var/cache/apt\"]:\n        try:\n        shutil.rmtree(os.path.join(self.aptroot, d))\n        except IOError:\n        pass\n    try:\n        os.remove(os.path.join(self.aptroot, \"var/lib/dpkg/status\"))\n    except OSError:\n        pass\n", "code_toks_joined": "def tearDown ( self ) : <NEWLINE> <INDENT> for d in [ <STRING> , <NEWLINE> <INDENT> <STRING> ] : <NEWLINE> try : <NEWLINE> shutil . rmtree ( os . path . join ( self . aptroot , d ) ) <NEWLINE> except IOError : <NEWLINE> pass <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> os . remove ( os . path . join ( self . aptroot , <STRING> ) ) <NEWLINE> <DEDENT> except OSError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"var/lib/apt/lists/\"", "\"var/cache/apt\"", "\"var/lib/dpkg/status\""]}, "err_obj": {"msg": "expected an indented block"}}], ["479d14f211256c3b3947462b56dc2b98", {"code_string": "def debug_shell():\n    traceback.print_exception(* sys.exc_info())\n        import code\n        code.interact(\"DBG\", local = locals())\n        sys.exit(- 1)\n", "code_toks_joined": "def debug_shell ( ) : <NEWLINE> <INDENT> traceback . print_exception ( * sys . exc_info ( ) ) <NEWLINE> <INDENT> import code <NEWLINE> code . interact ( <STRING> , local = locals ( ) ) <NEWLINE> sys . exit ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"DBG\""]}, "err_obj": {"msg": "unexpected indent"}}], ["8bc160be67e0b251971d865a78a8e60e", {"code_string": "class Solution(object):\n    def isPalindrome(self, x):\n    \"\"\":type x: int\"\"\"\n    z = str(x)[: : - 1]\n    return True if z == str(x) else False\n", "code_toks_joined": "class Solution ( object ) : <NEWLINE> <INDENT> def isPalindrome ( self , x ) : <NEWLINE> <STRING> <NEWLINE> z = str ( x ) [ : : - 1 ] <NEWLINE> return True if z == str ( x ) else False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\":type x: int\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["7f2a72ee3d89993c1abf25195caa75d7", {"code_string": "def tran_func(a, xshift, yshift, xmag, ymag, xrot, yrot)\n    xtran = ymag * a[0] * cos(yrot * pi / 180.0) - xmag * a[1] * sin(xrot * pi / 180) - yshift\n    ytran = ymag * a[0] * sin(yrot * pi / 180.0) + xmag * a[1] * cos(xrot * pi / 180) - xshift\n    return xtran, ytran\n", "code_toks_joined": "def tran_func ( a , xshift , yshift , xmag , ymag , xrot , yrot ) <NEWLINE> <INDENT> xtran = ymag * a [ 0 ] * cos ( yrot * pi / 180.0 ) - xmag * a [ 1 ] * sin ( xrot * pi / 180 ) - yshift <NEWLINE> ytran = ymag * a [ 0 ] * sin ( yrot * pi / 180.0 ) + xmag * a [ 1 ] * cos ( xrot * pi / 180 ) - xshift <NEWLINE> return xtran , ytran <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["1052b485d9db5784f432e922e13fb02f", {"code_string": "def retranslateUi(self, sits_viewer):\n    sits_viewer.setWindowTitle(_translate(\"sits_viewer\", \"sits_viewer\", None))\n    self.txtFeedback.setHtml(_translate(\"sits_viewer\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , sits_viewer ) : <NEWLINE> <INDENT> sits_viewer . setWindowTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . txtFeedback . setHtml ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"sits_viewer\"", "\"sits_viewer\"", "\"sits_viewer\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["9e115d7dc50fa0abb8cbae16ec91fdec", {"code_string": "def get_total_coverage(fpvals, col_num, step, out_val):\n    \"\"\"Calculate total bases of coverage in `fpvals`.\"\"\"\n    total_coverage = 0\n    for key, chrom_iter in groupby(bediter(fpvals, col_num),\n        itemgetter('chrom')):\n        bases = set([])\n        for feat in chrom_iter:\n        s, e = feat['start'], feat['end']\n        if s == e: e += 1\n        bases.update(range(s, e))\n        total_coverage += len(bases)\n    out_val.value = total_coverage\n", "code_toks_joined": "def get_total_coverage ( fpvals , col_num , step , out_val ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> total_coverage = 0 <NEWLINE> for key , chrom_iter in groupby ( bediter ( fpvals , col_num ) , <NEWLINE> <INDENT> itemgetter ( <STRING> ) ) : <NEWLINE> bases = set ( [ ] ) <NEWLINE> for feat in chrom_iter : <NEWLINE> s , e = feat [ <STRING> ] , feat [ <STRING> ] <NEWLINE> if s == e : e += 1 <NEWLINE> bases . update ( range ( s , e ) ) <NEWLINE> total_coverage += len ( bases ) <NEWLINE> <DEDENT> out_val . value = total_coverage <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Calculate total bases of coverage in `fpvals`.\"\"\"", "'chrom'", "'start'", "'end'"]}, "err_obj": {"msg": "expected an indented block"}}], ["463a3eec8dd026693e5848a6892f8571", {"code_string": "def getDevices(self):\n    if DEBUG:\n        print(\"getDevices()\")\n    self.__send('host:devices-l', checkok = False)\n    try:\n        self.__checkOk()\n    except RuntimeError, ex:\n        print(\"**ERROR:\", ex)\n        return None\n    devices = []\n    for line in self.__receive().splitlines():\n        devices.append(Device.factory(line))\n    self.socket = AdbClient.connect(self.hostname, self.port, self.timeout)\n    return devices\n", "code_toks_joined": "def getDevices ( self ) : <NEWLINE> <INDENT> if DEBUG : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> self . __send ( <STRING> , checkok = False ) <NEWLINE> try : <NEWLINE> <INDENT> self . __checkOk ( ) <NEWLINE> <DEDENT> except RuntimeError , ex : <NEWLINE> <INDENT> print ( <STRING> , ex ) <NEWLINE> return None <NEWLINE> <DEDENT> devices = [ ] <NEWLINE> for line in self . __receive ( ) . splitlines ( ) : <NEWLINE> <INDENT> devices . append ( Device . factory ( line ) ) <NEWLINE> <DEDENT> self . socket = AdbClient . connect ( self . hostname , self . port , self . timeout ) <NEWLINE> return devices <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"getDevices()\"", "'host:devices-l'", "\"**ERROR:\""]}, "err_obj": {"msg": "invalid syntax"}}], ["25602a44e3cc65f08a5b53b1abb8ac4f", {"code_string": "def processXmlQuerySync(rspec, url = None):\n    if threading.currentThread().callBackURL:\n        url = threading.currentThread().callBackURL\n            if not rspec.query.provisioning == None:\n                status = SyncThread.startMethodAndJoin(ProvisioningDispatcher.processProvisioning, rspec.query.provisioning, url)\n                return status\n", "code_toks_joined": "def processXmlQuerySync ( rspec , url = None ) : <NEWLINE> <INDENT> if threading . currentThread ( ) . callBackURL : <NEWLINE> <INDENT> url = threading . currentThread ( ) . callBackURL <NEWLINE> <INDENT> if not rspec . query . provisioning == None : <NEWLINE> <INDENT> status = SyncThread . startMethodAndJoin ( ProvisioningDispatcher . processProvisioning , rspec . query . provisioning , url ) <NEWLINE> return status <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["b2536b328689fe48493ed591a0fc8ff7", {"code_string": "def ping(self, serviceLocator, nonce, nanoseconds):\n    result = ctypes.c_uint64();\n    s = so.rc_ping(self.client, serviceLocator, nonce, nanoseconds,\n        ctypes.byref(result)))\n    self.handle_error(s)\n    return result\n", "code_toks_joined": "def ping ( self , serviceLocator , nonce , nanoseconds ) : <NEWLINE> <INDENT> result = ctypes . c_uint64 ( ) ; <NEWLINE> s = so . rc_ping ( self . client , serviceLocator , nonce , nanoseconds , <NEWLINE> <INDENT> ctypes . byref ( result ) ) ) <NEWLINE> <DEDENT> self . handle_error ( s ) <NEWLINE> return result <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["d3b1b11a5480c2b9aab1c7f09999dad0", {"code_string": "def getMessageData_api(id):\n    \"\"\"Forward message GET to vsync.\"\"\"\n        try:\n        if id in messages:\n        return messages[id]\n        else:\n        res = []\n        nr = group.Query(Vsync.Group.ALL, 4, id, Vsync.EOLMarker(), res)\n        print(\"result from group getting message\")\n        print(res)\n        for ele in res:\n            if ele != \"-1\":\n                return ele\n                return \"-1\"\n        except:\n            return \"-1\"\n", "code_toks_joined": "def getMessageData_api ( id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> try : <NEWLINE> if id in messages : <NEWLINE> return messages [ id ] <NEWLINE> else : <NEWLINE> res = [ ] <NEWLINE> nr = group . Query ( Vsync . Group . ALL , 4 , id , Vsync . EOLMarker ( ) , res ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( res ) <NEWLINE> for ele in res : <NEWLINE> <INDENT> if ele != <STRING> : <NEWLINE> <INDENT> return ele <NEWLINE> return <STRING> <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Forward message GET to vsync.\"\"\"", "\"result from group getting message\"", "\"-1\"", "\"-1\"", "\"-1\""]}, "err_obj": {"msg": "unexpected indent"}}], ["3b7b4372ae5584ed3aa2100fa2327e63", {"code_string": "def draw_label_in_box(ctx, color, label, x, y, w, maxx):\n    label_w = ctx.text_extents(label)[2]\n    label_x = x + w / 2 - label_w / 2\n        if label_w + 10 > w:\n            label_x = x + w + 5\n        if label_x + label_w > maxx:\n            label_x = x - label_w - 5\n    draw_text(ctx, label, color, label_x, y)\n", "code_toks_joined": "def draw_label_in_box ( ctx , color , label , x , y , w , maxx ) : <NEWLINE> <INDENT> label_w = ctx . text_extents ( label ) [ 2 ] <NEWLINE> label_x = x + w / 2 - label_w / 2 <NEWLINE> <INDENT> if label_w + 10 > w : <NEWLINE> <INDENT> label_x = x + w + 5 <NEWLINE> <DEDENT> if label_x + label_w > maxx : <NEWLINE> <INDENT> label_x = x - label_w - 5 <NEWLINE> <DEDENT> <DEDENT> draw_text ( ctx , label , color , label_x , y ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["73d67611a91a8173297b24a9bfce6ef6", {"code_string": "def help_flag(self):\n    print(_(\"The flag command allows configuring, removing and\\n\")\n        \"verifying package flags, and accepts the same options\\n\"\n        \"available in the command line interface.\")\n    print\n    print(_(\"Usage: flag [options]\"))\n", "code_toks_joined": "def help_flag ( self ) : <NEWLINE> <INDENT> print ( _ ( <STRING> ) <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> print <NEWLINE> print ( _ ( <STRING> ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"The flag command allows configuring, removing and\\n\"", "\"verifying package flags, and accepts the same options\\n\"", "\"available in the command line interface.\"", "\"Usage: flag [options]\""]}, "err_obj": {"msg": "invalid syntax"}}], ["5a29d0f1082da6d1184ecb03f14b6541", {"code_string": "def test_nonadmin_cannot_set_subjects(self):\n    initial_subjects = self.preprint.subjects\n    with assert_raises(PermissionsError):\n        self.preprint.set_subjects([[SubjectFactory()._id]]], auth = Auth(self.write_contrib), save = True)\n    self.preprint.reload()\n    assert_equal(initial_subjects, self.preprint.subjects)\n", "code_toks_joined": "def test_nonadmin_cannot_set_subjects ( self ) : <NEWLINE> <INDENT> initial_subjects = self . preprint . subjects <NEWLINE> with assert_raises ( PermissionsError ) : <NEWLINE> <INDENT> self . preprint . set_subjects ( [ [ SubjectFactory ( ) . _id ] ] ] , auth = Auth ( self . write_contrib ) , save = True ) <NEWLINE> <DEDENT> self . preprint . reload ( ) <NEWLINE> assert_equal ( initial_subjects , self . preprint . subjects ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["28b4a82eeea1c8c66b8307e0b8b3d606", {"code_string": "def findCenter(self, side = - 1):\n    self.WriteThenStore('XF{}'.format(side)\n    done = ''\n    while done != 'XD':\n        done = self.status()\n        print('Status: {}\\n'.format(done))\n    print('Center: Found!')\n", "code_toks_joined": "def findCenter ( self , side = - 1 ) : <NEWLINE> <INDENT> self . WriteThenStore ( <STRING> . format ( side ) <NEWLINE> done = <STRING> <NEWLINE> while done != <STRING> : <NEWLINE> <INDENT> done = self . status ( ) <NEWLINE> print ( <STRING> . format ( done ) ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'XF{}'", "''", "'XD'", "'Status: {}\\n'", "'Center: Found!'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["831f34a248834f7e51d18e2010b220b6", {"code_string": "def test_get_component_manager_arg_comp_mgr_id_success(self):\n    value = \"ComponentManagerBody\"\n    with patch('org.o3project.odenos.core.util.remote_object_interface.'\n        'RemoteObjectInterface._get_object_to_remote_object',\n        return_value = Response(Response.StatusCode.OK,\n            value)\n        ) as m_get_object:\n        self.result = self.target.get_component_manager(\"CompMngId1\")\n        self.assertEqual(m_get_object.call_count, 1)\n        m_get_object.assert_any_call(SystemManagerInterface.\n            COMP_MNG_PATH % \"CompMngId1\")\n            self.assertNotEqual(self.result, None)\n            self.assertEqual(self.result, value)\n", "code_toks_joined": "def test_get_component_manager_arg_comp_mgr_id_success ( self ) : <NEWLINE> <INDENT> value = <STRING> <NEWLINE> with patch ( <STRING> <NEWLINE> <INDENT> <STRING> , <NEWLINE> return_value = Response ( Response . StatusCode . OK , <NEWLINE> <INDENT> value ) <NEWLINE> <DEDENT> ) as m_get_object : <NEWLINE> self . result = self . target . get_component_manager ( <STRING> ) <NEWLINE> self . assertEqual ( m_get_object . call_count , 1 ) <NEWLINE> m_get_object . assert_any_call ( SystemManagerInterface . <NEWLINE> <INDENT> COMP_MNG_PATH % <STRING> ) <NEWLINE> self . assertNotEqual ( self . result , None ) <NEWLINE> self . assertEqual ( self . result , value ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"ComponentManagerBody\"", "'org.o3project.odenos.core.util.remote_object_interface.'", "'RemoteObjectInterface._get_object_to_remote_object'", "\"CompMngId1\"", "\"CompMngId1\""]}, "err_obj": {"msg": "unexpected indent"}}], ["e03466134e363cc1c69634d47656f43d", {"code_string": "class ImapProxyClient(object):\n    def __init__(self, uid, pwd, imap_server_address):\n        if ALLVERBOSE or VERBOSE:\n            print \"ImapProxyClient.__init__('%s', '%s', '%s'\" %(uid, pwd, imap_server_address)\n        self.uid = uid\n        self.pwd = pwd\n        self.imap_server_address = imap_server_address\n        self.mailboxCache = {}\n        self.connectecd = False\n        self.selected = None\n        self.subscribed = []\n        self.factory = None\n        self.protocol = None\n", "code_toks_joined": "class ImapProxyClient ( object ) : <NEWLINE> <INDENT> def __init__ ( self , uid , pwd , imap_server_address ) : <NEWLINE> <INDENT> if ALLVERBOSE or VERBOSE : <NEWLINE> <INDENT> print <STRING> % ( uid , pwd , imap_server_address ) <NEWLINE> <DEDENT> self . uid = uid <NEWLINE> self . pwd = pwd <NEWLINE> self . imap_server_address = imap_server_address <NEWLINE> self . mailboxCache = { } <NEWLINE> self . connectecd = False <NEWLINE> self . selected = None <NEWLINE> self . subscribed = [ ] <NEWLINE> self . factory = None <NEWLINE> self . protocol = None <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"ImapProxyClient.__init__('%s', '%s', '%s'\""]}, "err_obj": {"msg": "invalid syntax"}}], ["521be218c7f2e440d5d8f1aa1eb930db", {"code_string": "def latest_tweets(request):\n    tweets = cache.get('tweets')\n    if tweets:\n        return{\"tweets\": tweets}\n    tweets = twitter.Api().GetUserTimeline(settings.TWITTER_USER)[0: 3]\n    for tweet in tweets:\n    tweet.date = datetime.strptime(tweet.created_at, \"%a %b %d %H:%M:%S +0000 %Y\")\n    cache.set('tweets', tweets, settings.TWITTER_TIMEOUT)\n    return{\"tweets\": tweets}\n", "code_toks_joined": "def latest_tweets ( request ) : <NEWLINE> <INDENT> tweets = cache . get ( <STRING> ) <NEWLINE> if tweets : <NEWLINE> <INDENT> return { <STRING> : tweets } <NEWLINE> <DEDENT> tweets = twitter . Api ( ) . GetUserTimeline ( settings . TWITTER_USER ) [ 0 : 3 ] <NEWLINE> for tweet in tweets : <NEWLINE> tweet . date = datetime . strptime ( tweet . created_at , <STRING> ) <NEWLINE> cache . set ( <STRING> , tweets , settings . TWITTER_TIMEOUT ) <NEWLINE> return { <STRING> : tweets } <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'tweets'", "\"tweets\"", "\"%a %b %d %H:%M:%S +0000 %Y\"", "'tweets'", "\"tweets\""]}, "err_obj": {"msg": "expected an indented block"}}], ["bb0fe2f484615c7a9b99440c22f601e8", {"code_string": "import plugin_mgr\nplugins = plugin_mgr.importPlugins(folder = 'plugins')\nfor(name, ns, plugin) in plugins:\n    print('var in the module is[{0}]'.format(plugin.var))\n    print('members of[{0}]'.format(name)))\n    for p, v in plugin.__dict__.items():\n        if not p.startswith('__'):\n            print('\\t{0}->{1}'.format(p, v))\n", "code_toks_joined": "import plugin_mgr <NEWLINE> plugins = plugin_mgr . importPlugins ( folder = <STRING> ) <NEWLINE> for ( name , ns , plugin ) in plugins : <NEWLINE> <INDENT> print ( <STRING> . format ( plugin . var ) ) <NEWLINE> print ( <STRING> . format ( name ) ) ) <NEWLINE> for p , v in plugin . __dict__ . items ( ) : <NEWLINE> <INDENT> if not p . startswith ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> . format ( p , v ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'plugins'", "'var in the module is[{0}]'", "'members of[{0}]'", "'__'", "'\\t{0}->{1}'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["fec946c1e7f34688386eae4ed4f561e7", {"code_string": "def test_search_users_with_text_match(self):\n    \"\"\"Test the ability to use the user search endpoint.\"\"\"\n    cassette_name = self.cassette_name('search_users_with_text_match')\n    with self.recorder.use_cassette(cassette_name,\n        match_requests_on = self.match_on):\n        users = self.gh.search_users('tom followers:>1000',\n            text_match = True)\n            user_result = next(users)\n            assert isinstance(user_result,\n            github3.search.UserSearchResult)\n    assert isinstance(users, github3.structs.SearchIterator)\n    assert len(user_result.text_matches) > 0\n", "code_toks_joined": "def test_search_users_with_text_match ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> cassette_name = self . cassette_name ( <STRING> ) <NEWLINE> with self . recorder . use_cassette ( cassette_name , <NEWLINE> <INDENT> match_requests_on = self . match_on ) : <NEWLINE> users = self . gh . search_users ( <STRING> , <NEWLINE> <INDENT> text_match = True ) <NEWLINE> user_result = next ( users ) <NEWLINE> assert isinstance ( user_result , <NEWLINE> github3 . search . UserSearchResult ) <NEWLINE> <DEDENT> <DEDENT> assert isinstance ( users , github3 . structs . SearchIterator ) <NEWLINE> assert len ( user_result . text_matches ) > 0 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Test the ability to use the user search endpoint.\"\"\"", "'search_users_with_text_match'", "'tom followers:>1000'"]}, "err_obj": {"msg": "unexpected indent"}}], ["ea03aef9e8097f0a59fe0040d60444bd", {"code_string": "def cmp((obj1, obj2)):\n    if obj1.is_immutable_constant() and obj2.is_immutable_constant():\n        return immutablevalue(cmp(obj1.const, obj2.const))\n    else:\n        return SomeInteger()\n", "code_toks_joined": "def cmp ( ( obj1 , obj2 ) ) : <NEWLINE> <INDENT> if obj1 . is_immutable_constant ( ) and obj2 . is_immutable_constant ( ) : <NEWLINE> <INDENT> return immutablevalue ( cmp ( obj1 . const , obj2 . const ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return SomeInteger ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["58d8c1512da4cb982197e43149fb2b8d", {"code_string": "from paddle.proto.DataConfig_pb2 import DataConfig\ng_config = None\ndef SimpleData(\n    files = None,\n    feat_dim = None,\n    context_len = None,\n    buffer_capacity = None):\n    data_config = DataConfig()\n    data_config.type = 'simple'\n    data_config.files = files\n    data_config.feat_dim = feat_dim\n    if context_len is not None:\n    data_config.context_len = context_len\n    if buffer_capacity:\n    data_config.buffer_capacity = buffer_capacity\n    return data_config\n", "code_toks_joined": "from paddle . proto . DataConfig_pb2 import DataConfig <NEWLINE> g_config = None <NEWLINE> def SimpleData ( <NEWLINE> <INDENT> files = None , <NEWLINE> feat_dim = None , <NEWLINE> context_len = None , <NEWLINE> buffer_capacity = None ) : <NEWLINE> data_config = DataConfig ( ) <NEWLINE> data_config . type = <STRING> <NEWLINE> data_config . files = files <NEWLINE> data_config . feat_dim = feat_dim <NEWLINE> if context_len is not None : <NEWLINE> data_config . context_len = context_len <NEWLINE> if buffer_capacity : <NEWLINE> data_config . buffer_capacity = buffer_capacity <NEWLINE> return data_config <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'simple'"]}, "err_obj": {"msg": "expected an indented block"}}], ["45d6ad897b947abdf06da8efff5a9f76", {"code_string": "def running_set(self):\n    \"\"\"Up to the 5 most recent active collectors\"\"\"\n    return self.collector_set.filter(open_date__lte = date.today().order_by('-id')[: 5]\n", "code_toks_joined": "def running_set ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . collector_set . filter ( open_date__lte = date . today ( ) . order_by ( <STRING> ) [ : 5 ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Up to the 5 most recent active collectors\"\"\"", "'-id'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c8c8c0de16229224cb82c82bbf545eff", {"code_string": "def print_applicant(applicant):\n    if not applicant.submission_info.doc_reviewed_complete:\n        return\n    if applicant.education.uses_gat_score:\n        print(\"%s,%f,gatpat,%s\" %(\n            applicant.personal_info.national_id,\n            applicant.education.gpax,\n            ','.join([str(s) for s\n                in extract_gatpat_scores(applicant.education)]))\n    else:\n        print(\"%s,%f,anet,%d\" %(\n            applicant.personal_info.national_id,\n            applicant.education.gpax,\n            applicant.education.anet))\n", "code_toks_joined": "def print_applicant ( applicant ) : <NEWLINE> <INDENT> if not applicant . submission_info . doc_reviewed_complete : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if applicant . education . uses_gat_score : <NEWLINE> <INDENT> print ( <STRING> % ( <NEWLINE> <INDENT> applicant . personal_info . national_id , <NEWLINE> applicant . education . gpax , <NEWLINE> <STRING> . join ( [ str ( s ) for s <NEWLINE> <INDENT> in extract_gatpat_scores ( applicant . education ) ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> % ( <NEWLINE> <INDENT> applicant . personal_info . national_id , <NEWLINE> applicant . education . gpax , <NEWLINE> applicant . education . anet ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"%s,%f,gatpat,%s\"", "','", "\"%s,%f,anet,%d\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["07984e060755289b0ae49a88ae0de68c", {"code_string": "def boot2(self, yesno):\n    if yesno:\n    system(\"touch /tmp/.egamireboot\")\n    system(\"reboot -f\")\n    else:\n    system(\"touch /tmp/.egamireboot\")\n    self.session.open(MessageBox, _('Image will be booted on the next STB boot!'), MessageBox.TYPE_INFO)\n", "code_toks_joined": "def boot2 ( self , yesno ) : <NEWLINE> <INDENT> if yesno : <NEWLINE> system ( <STRING> ) <NEWLINE> system ( <STRING> ) <NEWLINE> else : <NEWLINE> system ( <STRING> ) <NEWLINE> self . session . open ( MessageBox , _ ( <STRING> ) , MessageBox . TYPE_INFO ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"touch /tmp/.egamireboot\"", "\"reboot -f\"", "\"touch /tmp/.egamireboot\"", "'Image will be booted on the next STB boot!'"]}, "err_obj": {"msg": "expected an indented block"}}], ["7f772000ea1cdd61b76caf226d54adfb", {"code_string": "def suite():\n    suite = trytond.tests.test_tryton.suite()\n    suite.addTests(unittest.TestLoader().loadTestsFromTestCase(\n        AccountBankTestCase))\n    suite.addTests(doctest.DocFileSuite('scenario_compensation_move.rst',\n        tearDown = doctest_teardown, encoding = 'utf-8',\n        checker = doctest_checker,\n        optionflags = doctest.REPORT_ONLY_FIRST_FAILURE)\n    return suite\n", "code_toks_joined": "def suite ( ) : <NEWLINE> <INDENT> suite = trytond . tests . test_tryton . suite ( ) <NEWLINE> suite . addTests ( unittest . TestLoader ( ) . loadTestsFromTestCase ( <NEWLINE> <INDENT> AccountBankTestCase ) ) <NEWLINE> <DEDENT> suite . addTests ( doctest . DocFileSuite ( <STRING> , <NEWLINE> <INDENT> tearDown = doctest_teardown , encoding = <STRING> , <NEWLINE> checker = doctest_checker , <NEWLINE> optionflags = doctest . REPORT_ONLY_FIRST_FAILURE ) <NEWLINE> <DEDENT> return suite <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'scenario_compensation_move.rst'", "'utf-8'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["82727cb861a1860d7860ca35f48494bc", {"code_string": "def conllesp():\n    from nltk.corpus import conll2002\n    de = \"\"\".*\"\"\"\n    DE = re.compile(de, re.VERBOSE)\n    print\n    print(\"Spanish CoNLL2002: de(ORG, LOC)-- just the first 10 clauses: \")\n    print(\"=\" * 45)\n    rels = [rel for doc in conll2002.chunked_sents('esp.train')\n        for rel in extract_rels('ORG', 'LOC', doc, corpus = 'conll2002', pattern = DE)]\n    for r in rels[: 10]: print show_clause(r, relsym = 'DE')\n    print\n", "code_toks_joined": "def conllesp ( ) : <NEWLINE> <INDENT> from nltk . corpus import conll2002 <NEWLINE> de = <STRING> <NEWLINE> DE = re . compile ( de , re . VERBOSE ) <NEWLINE> print <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> * 45 ) <NEWLINE> rels = [ rel for doc in conll2002 . chunked_sents ( <STRING> ) <NEWLINE> <INDENT> for rel in extract_rels ( <STRING> , <STRING> , doc , corpus = <STRING> , pattern = DE ) ] <NEWLINE> <DEDENT> for r in rels [ : 10 ] : print show_clause ( r , relsym = <STRING> ) <NEWLINE> print <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\".*\"\"\"", "\"Spanish CoNLL2002: de(ORG, LOC)-- just the first 10 clauses: \"", "\"=\"", "'esp.train'", "'ORG'", "'LOC'", "'conll2002'", "'DE'"]}, "err_obj": {"msg": "invalid syntax"}}], ["516d3b6b2414f876e45a114b0257fed8", {"code_string": "def find_username_git(self):\n    if os == win32:\n        return find_username_git_windows()\n    else\n        return find_username_git_unix()\n", "code_toks_joined": "def find_username_git ( self ) : <NEWLINE> <INDENT> if os == win32 : <NEWLINE> <INDENT> return find_username_git_windows ( ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> return find_username_git_unix ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["67bb2198be3b68cbe34bb469170d73c9", {"code_string": "def flags(self, index):\n    node = self.getNode(index)\n    if np.any(node.vals != 0)\n        return Qt.ItemIsEnabled | Qt.ItemIsSelectable | Qt.ItemIsUserCheckable\n    else:\n        return Qt.ItemIsSelectable\n", "code_toks_joined": "def flags ( self , index ) : <NEWLINE> <INDENT> node = self . getNode ( index ) <NEWLINE> if np . any ( node . vals != 0 ) <NEWLINE> <INDENT> return Qt . ItemIsEnabled | Qt . ItemIsSelectable | Qt . ItemIsUserCheckable <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return Qt . ItemIsSelectable <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["dd5ac13277613411c3a239a6677ac2e1", {"code_string": "def _import_bears(file_path, kinds):\n    for bear_list in iimport_objects(file_path,\n        names = '__additional_bears__',\n        types = list):\n        for bear_class in bear_list:\n        for valid_bear_class in _yield_if_right_kind(bear_class, kinds):\n        yield valid_bear_class\n    for bear_class in iimport_objects(file_path,\n        attributes = 'kind',\n        local = True):\n        for valid_bear_class in _yield_if_right_kind(bear_class, kinds):\n        yield valid_bear_class\n", "code_toks_joined": "def _import_bears ( file_path , kinds ) : <NEWLINE> <INDENT> for bear_list in iimport_objects ( file_path , <NEWLINE> <INDENT> names = <STRING> , <NEWLINE> types = list ) : <NEWLINE> for bear_class in bear_list : <NEWLINE> for valid_bear_class in _yield_if_right_kind ( bear_class , kinds ) : <NEWLINE> yield valid_bear_class <NEWLINE> <DEDENT> for bear_class in iimport_objects ( file_path , <NEWLINE> <INDENT> attributes = <STRING> , <NEWLINE> local = True ) : <NEWLINE> for valid_bear_class in _yield_if_right_kind ( bear_class , kinds ) : <NEWLINE> yield valid_bear_class <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'__additional_bears__'", "'kind'"]}, "err_obj": {"msg": "expected an indented block"}}], ["811227516129db157747685a817133a5", {"code_string": "def returnFanState():\n    try:\n    f = open(\"./state/fanstate.txt\", \"r\")\n    tempString = f.read()\n        f.close()\n        fanstate = int(tempString)\n        except IOError as e:\n        fanstate = 0\n        return fanstate\n", "code_toks_joined": "def returnFanState ( ) : <NEWLINE> <INDENT> try : <NEWLINE> f = open ( <STRING> , <STRING> ) <NEWLINE> tempString = f . read ( ) <NEWLINE> <INDENT> f . close ( ) <NEWLINE> fanstate = int ( tempString ) <NEWLINE> except IOError as e : <NEWLINE> fanstate = 0 <NEWLINE> return fanstate <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"./state/fanstate.txt\"", "\"r\""]}, "err_obj": {"msg": "expected an indented block"}}], ["3e96b50e52bac7a0db628eed7c0c6959", {"code_string": "class IndexPageHandler(webapp2.RequestHandler):\n    def get(self, base_url = None):\n    self.response.out.write(\"<html><body>\")\n    self.response.out.write(\"<p>Welcome to Nimbus Store</p>\")\n    self.response.out.write(\"<p>Click <a href= DROPBOX_FOLDER> HERE </a> to access my files.</p>\")\n    self.response.out.write(\"</body></html>\")\n", "code_toks_joined": "class IndexPageHandler ( webapp2 . RequestHandler ) : <NEWLINE> <INDENT> def get ( self , base_url = None ) : <NEWLINE> self . response . out . write ( <STRING> ) <NEWLINE> self . response . out . write ( <STRING> ) <NEWLINE> self . response . out . write ( <STRING> ) <NEWLINE> self . response . out . write ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"<html><body>\"", "\"<p>Welcome to Nimbus Store</p>\"", "\"<p>Click <a href= DROPBOX_FOLDER> HERE </a> to access my files.</p>\"", "\"</body></html>\""]}, "err_obj": {"msg": "expected an indented block"}}], ["4bb125a618a084d1e0739b122ea7d101", {"code_string": "class ArgumentTypeException(ArgumentException):\n    def __init__(self, except_type, actual_value,\n        * args, ** kwargs):\n        if not isinstance(except_type, type):\n        raise ArgumentTypeException(type, except_type)\n        actual_type = \"'None'\" if actual_value is None else type(actual_value).__name__\n        fmtext = 'param <{name}> value type error:'\n        fmtext += ' (expected <{except_type}>, got <{actual_type}>)'\n        fmtext = 'param <{name}> value type error:' + ' (expected <{except_type}>, got <{actual_type}>)'\n        super().__init__(fmtext,\n            parameter_name = kwargs.get('name', '?'),\n            except_type = except_type.__name__,\n            actual_type = actual_type,\n            * args, ** kwargs)\n", "code_toks_joined": "class ArgumentTypeException ( ArgumentException ) : <NEWLINE> <INDENT> def __init__ ( self , except_type , actual_value , <NEWLINE> <INDENT> * args , ** kwargs ) : <NEWLINE> if not isinstance ( except_type , type ) : <NEWLINE> raise ArgumentTypeException ( type , except_type ) <NEWLINE> actual_type = <STRING> if actual_value is None else type ( actual_value ) . __name__ <NEWLINE> fmtext = <STRING> <NEWLINE> fmtext += <STRING> <NEWLINE> fmtext = <STRING> + <STRING> <NEWLINE> super ( ) . __init__ ( fmtext , <NEWLINE> <INDENT> parameter_name = kwargs . get ( <STRING> , <STRING> ) , <NEWLINE> except_type = except_type . __name__ , <NEWLINE> actual_type = actual_type , <NEWLINE> * args , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"'None'\"", "'param <{name}> value type error:'", "' (expected <{except_type}>, got <{actual_type}>)'", "'param <{name}> value type error:'", "' (expected <{except_type}>, got <{actual_type}>)'", "'name'", "'?'"]}, "err_obj": {"msg": "expected an indented block"}}], ["7d162c375389832b9e88cde64c8b8df7", {"code_string": "class Frame(osg.Geode):\n    Frame()\n    Frame(Frame copy, osg.CopyOp copyop = osg.CopyOp.SHALLOW_COPY)\n    META_Node(osgfxbrowser, Frame)\n    inline str getCaption() return caption_\n    inline void setCaption(str caption) caption_ = caption\n    inline osg.Vec4 getBackgroundColor() return bgcolor_\n    inline void setBackgroundColor(osg.Vec4 bgcolor) bgcolor_ = bgcolor\n    inline Rect getRect() return rect_\n    inline void setRect(Rect rect) rect_ = rect\n    static osg.Geometry * build_quad(Rect rect, osg.Vec4 color, bool shadow = True, float z = 0)\n    rebuild = virtual void()\n    virtual ~ Frame()\n    Frame operator()(Frame) return * this\n    virtual void rebuild_client_area(Rect\n    bgcolor_ = osg.Vec4()\n    rect_ = Rect()\n    caption_ = str()\n", "code_toks_joined": "class Frame ( osg . Geode ) : <NEWLINE> <INDENT> Frame ( ) <NEWLINE> Frame ( Frame copy , osg . CopyOp copyop = osg . CopyOp . SHALLOW_COPY ) <NEWLINE> META_Node ( osgfxbrowser , Frame ) <NEWLINE> inline str getCaption ( ) return caption_ <NEWLINE> inline void setCaption ( str caption ) caption_ = caption <NEWLINE> inline osg . Vec4 getBackgroundColor ( ) return bgcolor_ <NEWLINE> inline void setBackgroundColor ( osg . Vec4 bgcolor ) bgcolor_ = bgcolor <NEWLINE> inline Rect getRect ( ) return rect_ <NEWLINE> inline void setRect ( Rect rect ) rect_ = rect <NEWLINE> static osg . Geometry * build_quad ( Rect rect , osg . Vec4 color , bool shadow = True , float z = 0 ) <NEWLINE> rebuild = virtual void ( ) <NEWLINE> virtual ~ Frame ( ) <NEWLINE> Frame operator ( ) ( Frame ) return * this <NEWLINE> virtual void rebuild_client_area ( Rect <NEWLINE> bgcolor_ = osg . Vec4 ( ) <NEWLINE> rect_ = Rect ( ) <NEWLINE> caption_ = str ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "window_span": [152, 176], "err_obj": {"msg": "unbalanced (){}[]"}}], ["033cfc9022f19e10eccf4909c66ad2f0", {"code_string": "def _bOR(left, right):\n    \"\"\"_bOR(left, right): \"\"\"\n    if timing: print \"starting bOR: \", time()\n    out = left.cloneMerged()\n    out.addFeatures(FeatureUtils.mergeContiguous(right))\n    out.mergeContiguous()\n    if timing:\n        print \"stopping bOR: \", time()\n    return out\n", "code_toks_joined": "def _bOR ( left , right ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if timing : print <STRING> , time ( ) <NEWLINE> out = left . cloneMerged ( ) <NEWLINE> out . addFeatures ( FeatureUtils . mergeContiguous ( right ) ) <NEWLINE> out . mergeContiguous ( ) <NEWLINE> if timing : <NEWLINE> <INDENT> print <STRING> , time ( ) <NEWLINE> <DEDENT> return out <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"_bOR(left, right): \"\"\"", "\"starting bOR: \"", "\"stopping bOR: \""]}, "err_obj": {"msg": "invalid syntax"}}], ["9a7b35854803286b5be072aa4ef694f1", {"code_string": "import json\nimport math\nimport pyflowgo.flowgo_state\nimport pyflowgo.base.flowgo_base_crust_temperature_model\nclass FlowGoCrustTemperatureModelHR2001(pyflowgo.base.flowgo_base_crust_temperature_model.\n    FlowGoBaseCrustTemperatureModel):\n    \"\"\"This method  \"HR2001\" allows the crust temperature to decrease downflow ain the same way as the core temperature is\"\"\"\n    _crust_temperature = 425 + 273.15\n    def read_initial_condition_from_json_file(self, filename):\n    with open(filename) as data_file:\n    data = json.load(data_file)\n    self._crust_temperature = float(data['thermal_parameters']['crust_temperature'])\n    def compute_crust_temperature(self, state):\n    crust_temperature = 0.\n    core_temperature = state.get_core_temperature()\n    self._crust_temperature = core_temperature - 712.0\n    return self._crust_temperature\n", "code_toks_joined": "import json <NEWLINE> import math <NEWLINE> import pyflowgo . flowgo_state <NEWLINE> import pyflowgo . base . flowgo_base_crust_temperature_model <NEWLINE> class FlowGoCrustTemperatureModelHR2001 ( pyflowgo . base . flowgo_base_crust_temperature_model . <NEWLINE> <INDENT> FlowGoBaseCrustTemperatureModel ) : <NEWLINE> <STRING> <NEWLINE> _crust_temperature = 425 + 273.15 <NEWLINE> def read_initial_condition_from_json_file ( self , filename ) : <NEWLINE> with open ( filename ) as data_file : <NEWLINE> data = json . load ( data_file ) <NEWLINE> self . _crust_temperature = float ( data [ <STRING> ] [ <STRING> ] ) <NEWLINE> def compute_crust_temperature ( self , state ) : <NEWLINE> crust_temperature = 0. <NEWLINE> core_temperature = state . get_core_temperature ( ) <NEWLINE> self . _crust_temperature = core_temperature - 712.0 <NEWLINE> return self . _crust_temperature <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"This method  \"HR2001\" allows the crust temperature to decrease downflow ain the same way as the core temperature is\"\"\"", "'thermal_parameters'", "'crust_temperature'"]}, "err_obj": {"msg": "expected an indented block"}}], ["d489c9c5afccce522b576537c7ded874", {"code_string": "def printColLabels(board):\n    (rows, cols) = (len(board), len(board[0]))\n    print(\"  \", )\n    for col in xrange(cols): print chr(ord(\"A\") + col),\n    print\n", "code_toks_joined": "def printColLabels ( board ) : <NEWLINE> <INDENT> ( rows , cols ) = ( len ( board ) , len ( board [ 0 ] ) ) <NEWLINE> print ( <STRING> , ) <NEWLINE> for col in xrange ( cols ) : print chr ( ord ( <STRING> ) + col ) , <NEWLINE> print <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"  \"", "\"A\""]}, "err_obj": {"msg": "invalid syntax"}}], ["da3d807babb937e25060a4c73e5d583c", {"code_string": "def getNetName():\n    \"\"\"Find a hostname or IP suitable for representing ourselves to clients.\"\"\"\n    for(so_fam, addr) in[\n        (socket.AF_INET, '8.8.8.8'),\n        (socket.AF_INET6, '2001:4800::')]:\n        try:\n        s = socket.socket(so_fam, socket.SOCK_DGRAM)\n        s.connect((addr, 0))\n        return s.getsockname()[0]\n        except socket.error:\n        pass\n    return 'localhost'\n", "code_toks_joined": "def getNetName ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for ( so_fam , addr ) in [ <NEWLINE> <INDENT> ( socket . AF_INET , <STRING> ) , <NEWLINE> ( socket . AF_INET6 , <STRING> ) ] : <NEWLINE> try : <NEWLINE> s = socket . socket ( so_fam , socket . SOCK_DGRAM ) <NEWLINE> s . connect ( ( addr , 0 ) ) <NEWLINE> return s . getsockname ( ) [ 0 ] <NEWLINE> except socket . error : <NEWLINE> pass <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Find a hostname or IP suitable for representing ourselves to clients.\"\"\"", "'8.8.8.8'", "'2001:4800::'", "'localhost'"]}, "err_obj": {"msg": "expected an indented block"}}], ["402e708fac0d8da34e1f109de0a095c5", {"code_string": "def testMutableHashTableIsLocal(self):\n    with ops.device(\n        estimator._get_replica_device_setter(run_config.RunConfig())):\n        default_val = constant_op.constant([- 1, - 1], dtypes.int64)\n        table = lookup.MutableHashTable(dtypes.string, dtypes.int64,\n            default_val)\n            input_string = constant_op.constant(['brain', 'salad', 'tank'])\n            output = table.lookup(input_string)\n    self.assertDeviceEqual('', table._table_ref.device)\n    self.assertDeviceEqual('', output.device)\n", "code_toks_joined": "def testMutableHashTableIsLocal ( self ) : <NEWLINE> <INDENT> with ops . device ( <NEWLINE> <INDENT> estimator . _get_replica_device_setter ( run_config . RunConfig ( ) ) ) : <NEWLINE> default_val = constant_op . constant ( [ - 1 , - 1 ] , dtypes . int64 ) <NEWLINE> table = lookup . MutableHashTable ( dtypes . string , dtypes . int64 , <NEWLINE> <INDENT> default_val ) <NEWLINE> input_string = constant_op . constant ( [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> output = table . lookup ( input_string ) <NEWLINE> <DEDENT> <DEDENT> self . assertDeviceEqual ( <STRING> , table . _table_ref . device ) <NEWLINE> self . assertDeviceEqual ( <STRING> , output . device ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'brain'", "'salad'", "'tank'", "''", "''"]}, "err_obj": {"msg": "unexpected indent"}}], ["61f31bf41dd33ec2d08e809c5c97b358", {"code_string": "def _extract_info(self, webpage):\n    info_json = self._search_regex(\n        r'(?s)q\\(\\s*\"\\w+.init\"\\s*,\\s*({.+})\\)\\s*</script>'\n        webpage, 'info json')\n    return json.loads(info_json)\n", "code_toks_joined": "def _extract_info ( self , webpage ) : <NEWLINE> <INDENT> info_json = self . _search_regex ( <NEWLINE> <INDENT> <STRING> <NEWLINE> webpage , <STRING> ) <NEWLINE> <DEDENT> return json . loads ( info_json ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["r'(?s)q\\(\\s*\"\\w+.init\"\\s*,\\s*({.+})\\)\\s*</script>'", "'info json'"]}, "err_obj": {"msg": "invalid syntax"}}], ["93f5f2f47fd41a249afd1848536d0f4c", {"code_string": "def open_write_stream(self, relpath, , mode = None):\n    \"\"\"See Transport.open_write_stream.\"\"\"\n    self.put_bytes(relpath, \"\", mode)\n    result = AppendBasedFileStream(self, relpath)\n    _file_streams[self.abspath(relpath)] = result\n    return result\n", "code_toks_joined": "def open_write_stream ( self , relpath , , mode = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . put_bytes ( relpath , <STRING> , mode ) <NEWLINE> result = AppendBasedFileStream ( self , relpath ) <NEWLINE> _file_streams [ self . abspath ( relpath ) ] = result <NEWLINE> return result <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"See Transport.open_write_stream.\"\"\"", "\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["d4786f9f0a696c6b997456514e93ba51", {"code_string": "'''returns array of arrays'''\nwith pointers:\n    def make_array() ->[] int:\n        arr = new([] int(1, 2, 3, 4))\n        return arr\n    def test_array(arr: [] int):\n        print(arr[0])\n        print(arr[1])\n        print(arr[2])\n        print(arr[3])\n    def main():\n        a = make_array()\n        print('arr length:', len(a))\n        test_array(a)\n", "code_toks_joined": "<STRING> <NEWLINE> with pointers : <NEWLINE> <INDENT> def make_array ( ) -> [ ] int : <NEWLINE> <INDENT> arr = new ( [ ] int ( 1 , 2 , 3 , 4 ) ) <NEWLINE> return arr <NEWLINE> <DEDENT> def test_array ( arr : [ ] int ) : <NEWLINE> <INDENT> print ( arr [ 0 ] ) <NEWLINE> print ( arr [ 1 ] ) <NEWLINE> print ( arr [ 2 ] ) <NEWLINE> print ( arr [ 3 ] ) <NEWLINE> <DEDENT> def main ( ) : <NEWLINE> <INDENT> a = make_array ( ) <NEWLINE> print ( <STRING> , len ( a ) ) <NEWLINE> test_array ( a ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''returns array of arrays'''", "'arr length:'"]}, "err_obj": {"msg": "invalid syntax"}}], ["26d8143593edf85d0261a72f3e8f7232", {"code_string": "def _openConfig(namespace):\n    \"\"\"Get the file descriptor for config file. If no specialized file has been\"\"\"\n    if namespace['config'] is not None:\n        os.environ['JAMESCI_CONFIG'] = namespace['config'].name\n        return namespace['config']\n    if 'JAMESCI_CONFIG' in os.environ:\n        return open(os.environ['JAMESCI_CONFIG'])\n    for path in[appdirs.user_config_dir('james-ci/config.yml'),\n        '/etc/james-ci/config.yml']:\n        if os.path.isfile(path):\n        return open(path, 'r')\n    raise FileNotFoundError('no configuration file could be found')\n", "code_toks_joined": "def _openConfig ( namespace ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if namespace [ <STRING> ] is not None : <NEWLINE> <INDENT> os . environ [ <STRING> ] = namespace [ <STRING> ] . name <NEWLINE> return namespace [ <STRING> ] <NEWLINE> <DEDENT> if <STRING> in os . environ : <NEWLINE> <INDENT> return open ( os . environ [ <STRING> ] ) <NEWLINE> <DEDENT> for path in [ appdirs . user_config_dir ( <STRING> ) , <NEWLINE> <INDENT> <STRING> ] : <NEWLINE> if os . path . isfile ( path ) : <NEWLINE> return open ( path , <STRING> ) <NEWLINE> <DEDENT> raise FileNotFoundError ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get the file descriptor for config file. If no specialized file has been\"\"\"", "'config'", "'JAMESCI_CONFIG'", "'config'", "'config'", "'JAMESCI_CONFIG'", "'JAMESCI_CONFIG'", "'james-ci/config.yml'", "'/etc/james-ci/config.yml'", "'r'", "'no configuration file could be found'"]}, "err_obj": {"msg": "expected an indented block"}}], ["646f0fc180651dc63553b59057a8a6e0", {"code_string": "class TicketChangeEvent(NotificationEvent):\n    \"\"\"Represent a ticket change `NotificationEvent`.\"\"\"\n    def __init__(self, category, target, time, author, comment = None,\n        changes = None, attachment = None):\n        super(TicketChangeEvent, self).__init__('ticket', category, target,\n            time, author)\n            self.comment = comment\n            if changes is None and time is not None:\n            changes = target.get_change(cdate = time)\n            self.changes = changes or{}\n            self.attachment = attachment\n", "code_toks_joined": "class TicketChangeEvent ( NotificationEvent ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , category , target , time , author , comment = None , <NEWLINE> <INDENT> changes = None , attachment = None ) : <NEWLINE> super ( TicketChangeEvent , self ) . __init__ ( <STRING> , category , target , <NEWLINE> <INDENT> time , author ) <NEWLINE> self . comment = comment <NEWLINE> if changes is None and time is not None : <NEWLINE> changes = target . get_change ( cdate = time ) <NEWLINE> self . changes = changes or { } <NEWLINE> self . attachment = attachment <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Represent a ticket change `NotificationEvent`.\"\"\"", "'ticket'"]}, "err_obj": {"msg": "unexpected indent"}}], ["11a63b7679a686bf33c03230c312d2cf", {"code_string": "def test_create_ip_policy_network_ip_policy_already_exists(self):\n    with self._stubs(None, net = dict(id = 1, ip_policy = dict(id = 2),\n        subnets = [dict(id = 1,\n            cidr = \"1.1.1.1/16\")])):\n            with self.assertRaises(quark_exceptions.IPPolicyAlreadyExists):\n            self.plugin.create_ip_policy(self.context, dict(\n            ip_policy = dict(network_ids = [1],\n            exclude = [\"1.1.1.1/24\"])))\n", "code_toks_joined": "def test_create_ip_policy_network_ip_policy_already_exists ( self ) : <NEWLINE> <INDENT> with self . _stubs ( None , net = dict ( id = 1 , ip_policy = dict ( id = 2 ) , <NEWLINE> <INDENT> subnets = [ dict ( id = 1 , <NEWLINE> <INDENT> cidr = <STRING> ) ] ) ) : <NEWLINE> with self . assertRaises ( quark_exceptions . IPPolicyAlreadyExists ) : <NEWLINE> self . plugin . create_ip_policy ( self . context , dict ( <NEWLINE> ip_policy = dict ( network_ids = [ 1 ] , <NEWLINE> exclude = [ <STRING> ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"1.1.1.1/16\"", "\"1.1.1.1/24\""]}, "err_obj": {"msg": "expected an indented block"}}], ["225213183769566aa0a7b840e690f524", {"code_string": "def test_argument_handling(self):\n    self.assertRaises(SyntaxError, eval, 'lambda a,a:0')\n    self.assertRaises(SyntaxError, eval, 'lambda a,a=1:0')\n    self.assertRaises(SyntaxError, eval, 'lambda a=1,a=1:0')\n    try:\n        exec 'def f(a, a): pass'\n        self.fail(\"duplicate arguments\")\n    except SyntaxError:\n        pass\n    try:\n        exec 'def f(a = 0, a = 1): pass'\n        self.fail(\"duplicate keyword arguments\")\n    except SyntaxError:\n        pass\n    try:\n        exec 'def f(a): global a; a = 1'\n        self.fail(\"variable is global and local\")\n    except SyntaxError:\n        pass\n", "code_toks_joined": "def test_argument_handling ( self ) : <NEWLINE> <INDENT> self . assertRaises ( SyntaxError , eval , <STRING> ) <NEWLINE> self . assertRaises ( SyntaxError , eval , <STRING> ) <NEWLINE> self . assertRaises ( SyntaxError , eval , <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> exec <STRING> <NEWLINE> self . fail ( <STRING> ) <NEWLINE> <DEDENT> except SyntaxError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> exec <STRING> <NEWLINE> self . fail ( <STRING> ) <NEWLINE> <DEDENT> except SyntaxError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> exec <STRING> <NEWLINE> self . fail ( <STRING> ) <NEWLINE> <DEDENT> except SyntaxError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'lambda a,a:0'", "'lambda a,a=1:0'", "'lambda a=1,a=1:0'", "'def f(a, a): pass'", "\"duplicate arguments\"", "'def f(a = 0, a = 1): pass'", "\"duplicate keyword arguments\"", "'def f(a): global a; a = 1'", "\"variable is global and local\""]}, "err_obj": {"msg": "invalid syntax"}}], ["fdea6921b984652ad6f9a27e04638038", {"code_string": "def writeArray1(ar, name):\n    s = ''\n    counter = 0\n    for x in ar:\n        s += '%s[%i]=%f;\\n' %(name, counter, x)\n        counter += 1\n            return s\n", "code_toks_joined": "def writeArray1 ( ar , name ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> counter = 0 <NEWLINE> for x in ar : <NEWLINE> <INDENT> s += <STRING> % ( name , counter , x ) <NEWLINE> counter += 1 <NEWLINE> <INDENT> return s <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "'%s[%i]=%f;\\n'"]}, "err_obj": {"msg": "unexpected indent"}}], ["0f0efe5498b1c6d6f8b65aef146fa5e9", {"code_string": "def get_slave(self, name):\n    if self.dbg:\n        print \"BUS: get_slave()\"\n    index = self.get_slave_index(name)\n    return self.slaves[index]\n", "code_toks_joined": "def get_slave ( self , name ) : <NEWLINE> <INDENT> if self . dbg : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> index = self . get_slave_index ( name ) <NEWLINE> return self . slaves [ index ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"BUS: get_slave()\""]}, "err_obj": {"msg": "invalid syntax"}}], ["91c0a0dc612478f419815834e57859bf", {"code_string": "def __init__(self, pidfile, stdin = '/dev/null', stdout = '/dev/null', stderr = '/dev/null')\n    self.stdin = stdin\n    self.stdout = stdout\n    self.stderr = stderr\n    self.pidfile = pidfile\n", "code_toks_joined": "def __init__ ( self , pidfile , stdin = <STRING> , stdout = <STRING> , stderr = <STRING> ) <NEWLINE> <INDENT> self . stdin = stdin <NEWLINE> self . stdout = stdout <NEWLINE> self . stderr = stderr <NEWLINE> self . pidfile = pidfile <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'/dev/null'", "'/dev/null'", "'/dev/null'"]}, "err_obj": {"msg": "invalid syntax"}}], ["3652e2222a76df072ad66bf8c363ac91", {"code_string": "import os\nimport sys\nROOT_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))\nsys.path.append(ROOT_DIR)\n", "code_toks_joined": "import os <NEWLINE> import sys <NEWLINE> ROOT_DIR = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) <NEWLINE> sys . path . append ( ROOT_DIR ) <NEWLINE>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["ec4125e5b09f0f96a4c466841494e002", {"code_string": "def setUp(self):\n    super(CodeTracerMainTest, self).setUp()\n    self.maxDiff = None\n    for module_name in('example_source',\n        'example_package',\n        'example_package.__main__',\n        'example_package.lib_in_package',\n        'example_driver'):\n        if module_name in sys.modules:\n        del sys.modules[module_name]\n", "code_toks_joined": "def setUp ( self ) : <NEWLINE> <INDENT> super ( CodeTracerMainTest , self ) . setUp ( ) <NEWLINE> self . maxDiff = None <NEWLINE> for module_name in ( <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ) : <NEWLINE> if module_name in sys . modules : <NEWLINE> del sys . modules [ module_name ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'example_source'", "'example_package'", "'example_package.__main__'", "'example_package.lib_in_package'", "'example_driver'"]}, "err_obj": {"msg": "expected an indented block"}}], ["ae243347584bdcc0386bb09b49649fae", {"code_string": "\"\"\"jinja2.debug\"\"\"\nimport sys\nimport traceback\nfrom types import TracebackType\nfrom jinja2.utils import CodeType, missing, internal_code\nfrom jinja2.exceptions import TemplateSyntaxError\ntry:\n    from __pypy__ import tproxy\nexcept ImportError:\n    tproxy = None\ntry:\n    exec \"raise TypeError, 'foo'\"\nexcept SyntaxError:\n    raise_helper = 'raise __jinja_exception__[1]'\nexcept TypeError:\n    raise_helper = 'raise __jinja_exception__[0], __jinja_exception__[1]'\n", "code_toks_joined": "<STRING> <NEWLINE> import sys <NEWLINE> import traceback <NEWLINE> from types import TracebackType <NEWLINE> from jinja2 . utils import CodeType , missing , internal_code <NEWLINE> from jinja2 . exceptions import TemplateSyntaxError <NEWLINE> try : <NEWLINE> <INDENT> from __pypy__ import tproxy <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> tproxy = None <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> exec <STRING> <NEWLINE> <DEDENT> except SyntaxError : <NEWLINE> <INDENT> raise_helper = <STRING> <NEWLINE> <DEDENT> except TypeError : <NEWLINE> <INDENT> raise_helper = <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"jinja2.debug\"\"\"", "\"raise TypeError, 'foo'\"", "'raise __jinja_exception__[1]'", "'raise __jinja_exception__[0], __jinja_exception__[1]'"]}, "err_obj": {"msg": "invalid syntax"}}], ["1f30f3e94cd8d16e9197b721eeb7cd8a", {"code_string": "def __iter__(self):\n    if not self._nrbits:\n        raise TypeError, \"Cannot iterate over unsized intbv\"\n    return iter([self[i] for i in range(self._nrbits - 1, - 1, - 1)])\n", "code_toks_joined": "def __iter__ ( self ) : <NEWLINE> <INDENT> if not self . _nrbits : <NEWLINE> <INDENT> raise TypeError , <STRING> <NEWLINE> <DEDENT> return iter ( [ self [ i ] for i in range ( self . _nrbits - 1 , - 1 , - 1 ) ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Cannot iterate over unsized intbv\""]}, "err_obj": {"msg": "invalid syntax"}}], ["7377a57c7381c75ddb1f034587dc6388", {"code_string": "def delete_sleep(request, sleep_id):\n    try:\n        sl = Sleep.objects.get(sl_id = sleep_id)\n    sl.delete()\n    except ObjectDoesNotExist:\n        return HttpResponse(ujson.dumps({'res': 'ok'}),\n            content_type = \"application/json\")\n    return HttpResponse(ujson.dumps({'res': 'ok'}),\n        content_type = \"application/json\")\n", "code_toks_joined": "def delete_sleep ( request , sleep_id ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> sl = Sleep . objects . get ( sl_id = sleep_id ) <NEWLINE> <DEDENT> sl . delete ( ) <NEWLINE> except ObjectDoesNotExist : <NEWLINE> <INDENT> return HttpResponse ( ujson . dumps ( { <STRING> : <STRING> } ) , <NEWLINE> <INDENT> content_type = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return HttpResponse ( ujson . dumps ( { <STRING> : <STRING> } ) , <NEWLINE> <INDENT> content_type = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'res'", "'ok'", "\"application/json\"", "'res'", "'ok'", "\"application/json\""]}, "err_obj": {"msg": "invalid syntax"}}], ["7fb98ece34b9a4d1dadf3a4831b67bde", {"code_string": "def _execute_sql(cursor, command):\n    '''Same as ``cursor.execute(command)``, but more verbose on error.'''\n    try:\n        cursor.execute(command)\n    except MySQLdb.MySQLError, e:\n        e.args +=(command, )\n        raise e\n", "code_toks_joined": "def _execute_sql ( cursor , command ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> cursor . execute ( command ) <NEWLINE> <DEDENT> except MySQLdb . MySQLError , e : <NEWLINE> <INDENT> e . args += ( command , ) <NEWLINE> raise e <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Same as ``cursor.execute(command)``, but more verbose on error.'''"]}, "err_obj": {"msg": "invalid syntax"}}], ["4c2cd2330c72276a957b8bd6cc6b14e7", {"code_string": "def get_ping_logs(hostname, target):\n    slave_active = slave.objects.get(slave_hostname = hostname)\n        try:\n        content = urllib2.urlopen(\"http://\" + slave_active + \"/get_logs?target=\" + target).read()\n    except:\n        content = \"\"\n        pass\n            return content\n", "code_toks_joined": "def get_ping_logs ( hostname , target ) : <NEWLINE> <INDENT> slave_active = slave . objects . get ( slave_hostname = hostname ) <NEWLINE> <INDENT> try : <NEWLINE> content = urllib2 . urlopen ( <STRING> + slave_active + <STRING> + target ) . read ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> content = <STRING> <NEWLINE> pass <NEWLINE> <INDENT> return content <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"http://\"", "\"/get_logs?target=\"", "\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["378c8aa8e244e85290b8bdb5e7384c28", {"code_string": "class JsonResponse(HttpResponse):\n    \"\"\"An HTTP response class that consumes data to be serialized to JSON.\"\"\"\n    def __init__(self, data, encoder = DjangoJSONEncoder, safe = True,\n        json_dumps_params = None, ** kwargs):\n        if safe and not isinstance(data, dict):\n        raise TypeError(\n        'In order to allow non-dict objects to be serialized set the '\n        'safe parameter to False.'\n        )\n        if json_dumps_params is None:\n        json_dumps_params = {}\n        kwargs.setdefault('content_type', 'application/json')\n        data = json.dumps(data, cls = encoder, ** json_dumps_params)\n        super().__init__(content = data, ** kwargs)\n", "code_toks_joined": "class JsonResponse ( HttpResponse ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , data , encoder = DjangoJSONEncoder , safe = True , <NEWLINE> <INDENT> json_dumps_params = None , ** kwargs ) : <NEWLINE> if safe and not isinstance ( data , dict ) : <NEWLINE> raise TypeError ( <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> ) <NEWLINE> if json_dumps_params is None : <NEWLINE> json_dumps_params = { } <NEWLINE> kwargs . setdefault ( <STRING> , <STRING> ) <NEWLINE> data = json . dumps ( data , cls = encoder , ** json_dumps_params ) <NEWLINE> super ( ) . __init__ ( content = data , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"An HTTP response class that consumes data to be serialized to JSON.\"\"\"", "'In order to allow non-dict objects to be serialized set the '", "'safe parameter to False.'", "'content_type'", "'application/json'"]}, "err_obj": {"msg": "expected an indented block"}}], ["267f80f2431b4f2a096bab8b3836992d", {"code_string": "def valid_index(self, i, j):\n    def is_valid(idx):\n        return isinstance(idx, (int, Integer, Symbol, Expr)\n    return(is_valid(i) and is_valid(j) and\n        (0 <= i) != False and(i < self.rows) != False and\n        (0 <= j) != False and(j < self.cols) != False)\n", "code_toks_joined": "def valid_index ( self , i , j ) : <NEWLINE> <INDENT> def is_valid ( idx ) : <NEWLINE> <INDENT> return isinstance ( idx , ( int , Integer , Symbol , Expr ) <NEWLINE> <DEDENT> return ( is_valid ( i ) and is_valid ( j ) and <NEWLINE> <INDENT> ( 0 <= i ) != False and ( i < self . rows ) != False and <NEWLINE> ( 0 <= j ) != False and ( j < self . cols ) != False ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e01cc083f836cc7b638efeacd1a6c467", {"code_string": "def show_mat(self):\n    print('')\n    for m in self.mat:\n        print('(',\n        for c in m:\n            print(c, )\n        print(')')\n", "code_toks_joined": "def show_mat ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for m in self . mat : <NEWLINE> <INDENT> print ( <STRING> , <NEWLINE> for c in m : <NEWLINE> <INDENT> print ( c , ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "'('", "')'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["5c3f2e05fcf5d060c65746eaf7a46133", {"code_string": "import logging\nfrom telemetry.page import shared_page_state\nclass DiagonalScrollingSupportedSharedState(\n    shared_page_state.SharedDesktopPageState):\n    def CanRunOnBrowser(self, browser_info):\n    if not browser_info.HasDiagonalScrollingSupport():\n        logging.warning('Browser does not support synthetic diagonal scrolling,'\n            ' skipping test')\n        return False\n    return True\n", "code_toks_joined": "import logging <NEWLINE> from telemetry . page import shared_page_state <NEWLINE> class DiagonalScrollingSupportedSharedState ( <NEWLINE> <INDENT> shared_page_state . SharedDesktopPageState ) : <NEWLINE> def CanRunOnBrowser ( self , browser_info ) : <NEWLINE> if not browser_info . HasDiagonalScrollingSupport ( ) : <NEWLINE> <INDENT> logging . warning ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Browser does not support synthetic diagonal scrolling,'", "' skipping test'"]}, "err_obj": {"msg": "expected an indented block"}}], ["e8005207d3931ea82d58eccc85e45871", {"code_string": "def _convert_date(self, d):\n    for s in('%B', '%b', '%m',\n        '%m/%d', '%m/% %H:%M'\n            '%m/%d/%y', '%m/%d/%Y',\n        '%m/%d/%y %H:%M', '%m/%d/%Y %H:%M', ):\n        try:\n        return datetime.datetime.strptime(d, s)\n        except ValueError:\n        pass\n", "code_toks_joined": "def _convert_date ( self , d ) : <NEWLINE> <INDENT> for s in ( <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> <DEDENT> <STRING> , <STRING> , ) : <NEWLINE> try : <NEWLINE> return datetime . datetime . strptime ( d , s ) <NEWLINE> except ValueError : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'%B'", "'%b'", "'%m'", "'%m/%d'", "'%m/% %H:%M'", "'%m/%d/%y'", "'%m/%d/%Y'", "'%m/%d/%y %H:%M'", "'%m/%d/%Y %H:%M'"]}, "err_obj": {"msg": "expected an indented block"}}], ["4cfec1f852705d3350838b297f4ae332", {"code_string": "def setupUi(self, RdpolyEditorDialog):\n    RdpolyEditorDialog.setObjectName(_fromUtf8(\"RdpolyEditorDialog\"))\n    RdpolyEditorDialog.resize(589, 437)\n    RdpolyEditorDialog.setMinimumSize(QtCore.QSize(589, 437))\n    self.gridLayout_8 = QtGui.QGridLayout(RdpolyEditorDialog)\n    self.gridLayout_8.setObjectName(_fromUtf8(\"gridLayout_8\"))\n    self.groupBox = QtGui.QGroupBox(RdpolyEditorDialog)\n    self.groupBox.setObjectName(_fromUtf8(\"groupBox\"))\n    self.gridLayout_6 = QtGui.QGridLayout(self.groupBox)\n    self.gridLayout_6.setObjectName(_fromUtf8(\"gridLayout_6\"))\n    self.gridLayout_5 = QtGui.QGridLayout()\n    self.gridLayout_5.setObjectName(_fromUtf8(\"gridLayout_5\"))\n    self.gridLayout_2 = QtGui.QGridLayout()\n    self.gridLayout_2.setObjectName(_fromUtf8(\"gridLayout_2\"))\n    self.label = QtGui.QLabel(self.groupBox)\n    self.label.setObjectName(_fromUtf8(\"label\"))\n    self.gridLayout_2.addWidget(self.label, 0, 0, 1, 1)\n    self.label_3 = QtGui.QLabel(self.groupBox)\n    self.label_3.setObjectName(_fromUtf8(\"label_3\"))\n    self.gridLayout_2.addWidget(self.label_3, 0, 1, 1, 1)\n    self.mclLineEdit = QtGui.QLineEdit(self.groupBox)\n    self.mclLineEdit.setStyleSheet(_fromUtf8(\"border-width:0.5px;\\n\"\n", "code_toks_joined": "def setupUi ( self , RdpolyEditorDialog ) : <NEWLINE> <INDENT> RdpolyEditorDialog . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> RdpolyEditorDialog . resize ( 589 , 437 ) <NEWLINE> RdpolyEditorDialog . setMinimumSize ( QtCore . QSize ( 589 , 437 ) ) <NEWLINE> self . gridLayout_8 = QtGui . QGridLayout ( RdpolyEditorDialog ) <NEWLINE> self . gridLayout_8 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . groupBox = QtGui . QGroupBox ( RdpolyEditorDialog ) <NEWLINE> self . groupBox . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_6 = QtGui . QGridLayout ( self . groupBox ) <NEWLINE> self . gridLayout_6 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_5 = QtGui . QGridLayout ( ) <NEWLINE> self . gridLayout_5 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_2 = QtGui . QGridLayout ( ) <NEWLINE> self . gridLayout_2 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label = QtGui . QLabel ( self . groupBox ) <NEWLINE> self . label . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_2 . addWidget ( self . label , 0 , 0 , 1 , 1 ) <NEWLINE> self . label_3 = QtGui . QLabel ( self . groupBox ) <NEWLINE> self . label_3 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_2 . addWidget ( self . label_3 , 0 , 1 , 1 , 1 ) <NEWLINE> self . mclLineEdit = QtGui . QLineEdit ( self . groupBox ) <NEWLINE> self . mclLineEdit . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"RdpolyEditorDialog\"", "\"gridLayout_8\"", "\"groupBox\"", "\"gridLayout_6\"", "\"gridLayout_5\"", "\"gridLayout_2\"", "\"label\"", "\"label_3\"", "\"border-width:0.5px;\\n\""]}, "window_span": [264, 270], "err_obj": {"msg": "unbalanced (){}[]"}}], ["623e005b029be72090d88ef148619f13", {"code_string": "def preamble():\n    if(metric):\n        print(\"G21 F% 8.0f\" %(feed))\n    else:\n        print(\"G20 F% 8.0f\" %(feed)))\n    print(\"G64 P0.001\")\n    pen_up()\n    print(\"G0 X0 Y0\")\n", "code_toks_joined": "def preamble ( ) : <NEWLINE> <INDENT> if ( metric ) : <NEWLINE> <INDENT> print ( <STRING> % ( feed ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> % ( feed ) ) ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> pen_up ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"G21 F% 8.0f\"", "\"G20 F% 8.0f\"", "\"G64 P0.001\"", "\"G0 X0 Y0\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["301318f54a39b1dbce9ac6307675a3f9", {"code_string": "def get_tbres(self):\n    \"\"\"Get top-bottom resolution\"\"\"\n    if self.D.has_key(\"tbres\"):\n        return self.D[\"tbres\"]\n            else:\n        return None\n", "code_toks_joined": "def get_tbres ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . D . has_key ( <STRING> ) : <NEWLINE> <INDENT> return self . D [ <STRING> ] <NEWLINE> <INDENT> else : <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get top-bottom resolution\"\"\"", "\"tbres\"", "\"tbres\""]}, "err_obj": {"msg": "unexpected indent"}}], ["c59e1765abcf289cee321e812d59df88", {"code_string": "def load_queue_file(filename):\n    \"\"\"This function first reads in an entire list, line by line. It then creates a list of lists where\"\"\"\n    loaded_lines = [[\"start\"]]\n    with open(filename) as f:\n        lines = f.readlines()\n    j = 0\n    for i in range(0, len(lines)):\n        loaded_lines[j].append(lines[i])\n            if lines[i] == '\\n':\n                loaded_lines.append([])\n                j += 1\n                return loaded_lines\n", "code_toks_joined": "def load_queue_file ( filename ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> loaded_lines = [ [ <STRING> ] ] <NEWLINE> with open ( filename ) as f : <NEWLINE> <INDENT> lines = f . readlines ( ) <NEWLINE> <DEDENT> j = 0 <NEWLINE> for i in range ( 0 , len ( lines ) ) : <NEWLINE> <INDENT> loaded_lines [ j ] . append ( lines [ i ] ) <NEWLINE> <INDENT> if lines [ i ] == <STRING> : <NEWLINE> <INDENT> loaded_lines . append ( [ ] ) <NEWLINE> j += 1 <NEWLINE> return loaded_lines <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"This function first reads in an entire list, line by line. It then creates a list of lists where\"\"\"", "\"start\"", "'\\n'"]}, "err_obj": {"msg": "unexpected indent"}}], ["a202697d9c57cdf6528b5b16941ef20d", {"code_string": "class People(models.Model):\n    name = models.CharField(max_length = 30)\n    age = models.IntegerField()\n    def __unicode__(self):\n    return self.name\n", "code_toks_joined": "class People ( models . Model ) : <NEWLINE> <INDENT> name = models . CharField ( max_length = 30 ) <NEWLINE> age = models . IntegerField ( ) <NEWLINE> def __unicode__ ( self ) : <NEWLINE> return self . name <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["feb010f99d2bcaef65c1f2c7b747e4ef", {"code_string": "def retranslateUi(self, DeleteBuddyDialog):\n    DeleteBuddyDialog.setWindowTitle(QtGui.QApplication.translate(\"DeleteBuddyDialog\", \"\u5220\u9664\u597d\u53cb\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label.setText(QtGui.QApplication.translate(\"DeleteBuddyDialog\", \"\u60a8\u786e\u5b9a\u8981\u5220\u9664\u4e00\u4e0b\u597d\u53cb\u7801?\", None, QtGui.QApplication.UnicodeUTF8))\n    self.yes_btn.setText(QtGui.QApplication.translate(\"DeleteBuddyDialog\", \"\u662f\u7684\", None, QtGui.QApplication.UnicodeUTF8))\n    self.yes_btn.setShortcut(QtGui.QApplication.translate(\"DeleteBuddyDialog\", \"Return\", None, QtGui.QApplication.UnicodeUTF8))\n    self.no_btn.setText(QtGui.QApplication.translate(\"DeleteBuddyDialog\", \"\u5426\", None, QtGui.QApplication.UnicodeUTF8))\n    self.no_btn.setShortcut(QtGui.QApplication.translate(\"DeleteBuddyDialog\", \"Esc\", None, QtGui.QApplication.UnicodeUTF8))\n    self.delete_me_checkbox.setText(QtGui.QApplication.translate(\"DeleteBuddyDialog\", \"\u540c\u65f6\u5c06\u6211\u4ece\u4ed6(\u5979)\u7684\u597d\u53cb\u5217\u8868\u4e2d\u5220\u9664\", None, QtGui.QApplication.UnicodeUTF8))\n    self.show_msg_text_edit.setHtml(QtGui.QApplication.translate(\"DeleteBuddyDialog\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , DeleteBuddyDialog ) : <NEWLINE> <INDENT> DeleteBuddyDialog . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . yes_btn . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . yes_btn . setShortcut ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . no_btn . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . no_btn . setShortcut ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . delete_me_checkbox . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . show_msg_text_edit . setHtml ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"DeleteBuddyDialog\"", "\"\u5220\u9664\u597d\u53cb\"", "\"DeleteBuddyDialog\"", "\"\u60a8\u786e\u5b9a\u8981\u5220\u9664\u4e00\u4e0b\u597d\u53cb\u7801?\"", "\"DeleteBuddyDialog\"", "\"\u662f\u7684\"", "\"DeleteBuddyDialog\"", "\"Return\"", "\"DeleteBuddyDialog\"", "\"\u5426\"", "\"DeleteBuddyDialog\"", "\"Esc\"", "\"DeleteBuddyDialog\"", "\"\u540c\u65f6\u5c06\u6211\u4ece\u4ed6(\u5979)\u7684\u597d\u53cb\u5217\u8868\u4e2d\u5220\u9664\"", "\"DeleteBuddyDialog\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "window_span": [195, 207], "err_obj": {"msg": "unbalanced (){}[]"}}], ["289752925c0c43c59f79ffb43c8a11cf", {"code_string": "def parse_itrf_ascii_to_xyz_and_labels(tabledata):\n    \"\"\"Read ITRF data in ascii format and return (antenna positions, labels).\"\"\"\n    tbl = ascii.read(tabledata\n        names = ('x', 'y', 'z', 'diameter', 'label', 'mount'))\n    xyz = hstack_table_columns_as_ndarray(tbl.columns[: 3]) * u.m\n    labels = tbl['label'].data\n    return xyz, labels\n", "code_toks_joined": "def parse_itrf_ascii_to_xyz_and_labels ( tabledata ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> tbl = ascii . read ( tabledata <NEWLINE> <INDENT> names = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) ) <NEWLINE> <DEDENT> xyz = hstack_table_columns_as_ndarray ( tbl . columns [ : 3 ] ) * u . m <NEWLINE> labels = tbl [ <STRING> ] . data <NEWLINE> return xyz , labels <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Read ITRF data in ascii format and return (antenna positions, labels).\"\"\"", "'x'", "'y'", "'z'", "'diameter'", "'label'", "'mount'", "'label'"]}, "err_obj": {"msg": "invalid syntax"}}], ["bad1c1d1d7011e5fef69f607f564bc6b", {"code_string": "def create_new_waypoint(self, widget, (x, y)):\n    wp = Waypoint()\n    wp.name = \"Unnamed Radarpoint\"\n    wp.set_coordinates(self.xy_to_coordinates(x, y))\n    self._session.wpList.append(self._session.get_manual_list_iter(), (wp, ))\n", "code_toks_joined": "def create_new_waypoint ( self , widget , ( x , y ) ) : <NEWLINE> <INDENT> wp = Waypoint ( ) <NEWLINE> wp . name = <STRING> <NEWLINE> wp . set_coordinates ( self . xy_to_coordinates ( x , y ) ) <NEWLINE> self . _session . wpList . append ( self . _session . get_manual_list_iter ( ) , ( wp , ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Unnamed Radarpoint\""]}, "err_obj": {"msg": "invalid syntax"}}], ["510392bf1b9ce8d40f0ace0631f9b683", {"code_string": "def mapping_items(mapping):\n    \"\"\"Return an iterator over the mapping items, sort if it's a plain dict.\"\"\"\n    if type(mapping) is dict:\n        return iter(sorted(iteritems(mapping))))\n    return iteritems(mapping)\n", "code_toks_joined": "def mapping_items ( mapping ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if type ( mapping ) is dict : <NEWLINE> <INDENT> return iter ( sorted ( iteritems ( mapping ) ) ) ) <NEWLINE> <DEDENT> return iteritems ( mapping ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return an iterator over the mapping items, sort if it's a plain dict.\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["abe7c3fddb92d1339f535f1fcd688ab9", {"code_string": "from openpyxl import load_workbook\nfrom pprint import pprint\nwb = load_workbook(filename = 'ORIGINAL DATA IDS ETHNICITY.xlsx')\nws = wb['All']\nnames = {}\nfor rdx, row in enumerate(ws.rows):\n    if rdx > 1:\n        if row[2].value is not None:\n            exec 'tmp = ' + row[2].value\n            for p in tmp:\n                names.setdefault(p, 1)\npprint(names.keys())\n", "code_toks_joined": "from openpyxl import load_workbook <NEWLINE> from pprint import pprint <NEWLINE> wb = load_workbook ( filename = <STRING> ) <NEWLINE> ws = wb [ <STRING> ] <NEWLINE> names = { } <NEWLINE> for rdx , row in enumerate ( ws . rows ) : <NEWLINE> <INDENT> if rdx > 1 : <NEWLINE> <INDENT> if row [ 2 ] . value is not None : <NEWLINE> <INDENT> exec <STRING> + row [ 2 ] . value <NEWLINE> for p in tmp : <NEWLINE> <INDENT> names . setdefault ( p , 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> pprint ( names . keys ( ) ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["'ORIGINAL DATA IDS ETHNICITY.xlsx'", "'All'", "'tmp = '"]}, "err_obj": {"msg": "invalid syntax"}}], ["3dd1bda2b61ed5d3d48baa6980ffea7c", {"code_string": "def get_instance(cls):\n    if cls._instance is None:\n        service_plugins = manager.NeutronManager.get_service_plugins()\n        cls._instance = cls(get_extensions_path(service_plugins)\n            service_plugins)\n    return cls._instance\n", "code_toks_joined": "def get_instance ( cls ) : <NEWLINE> <INDENT> if cls . _instance is None : <NEWLINE> <INDENT> service_plugins = manager . NeutronManager . get_service_plugins ( ) <NEWLINE> cls . _instance = cls ( get_extensions_path ( service_plugins ) <NEWLINE> <INDENT> service_plugins ) <NEWLINE> <DEDENT> <DEDENT> return cls . _instance <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["69058c7217882401fabe55a640b2c0b0", {"code_string": "def get_basic_type(type_):\n    \"\"\"Return the \"basic\" type of a type.\"\"\"\n    while(type_.code == gdb.TYPE_CODE_REF or\n        type_.code == gdb.TYPE_CODE_TYPEDEF):\n        if type_.code == gdb.TYPE_CODE_REF:\n            type_ = type_.target()\n            else:\n            type_ = type_.strip_typedefs()\n    return type_.unqualified()\n", "code_toks_joined": "def get_basic_type ( type_ ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> while ( type_ . code == gdb . TYPE_CODE_REF or <NEWLINE> <INDENT> type_ . code == gdb . TYPE_CODE_TYPEDEF ) : <NEWLINE> if type_ . code == gdb . TYPE_CODE_REF : <NEWLINE> <INDENT> type_ = type_ . target ( ) <NEWLINE> else : <NEWLINE> type_ = type_ . strip_typedefs ( ) <NEWLINE> <DEDENT> <DEDENT> return type_ . unqualified ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return the \"basic\" type of a type.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["1cfb656b980b5a0743fb137c09945e3f", {"code_string": "def retranslateUi(self, Preferences):\n    _translate = QtCore.QCoreApplication.translate\n    Preferences.setWindowTitle(_translate(\"Preferences\", \"Preferences\"))\n    self.dimensionsLabel1.setText(_translate(\"Preferences\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , Preferences ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> Preferences . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . dimensionsLabel1 . setText ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Preferences\"", "\"Preferences\"", "\"Preferences\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["995e18245a9974bfa8a26c2ae3c0abcb", {"code_string": "def open_tag_with_atr(self, tag, atr, atrval):\n    for elem in self._openelems:\n        if(self.elem_has_tag_and_atr(elem, tag, atr, atrval)):\n        return True\n    return False\n", "code_toks_joined": "def open_tag_with_atr ( self , tag , atr , atrval ) : <NEWLINE> <INDENT> for elem in self . _openelems : <NEWLINE> <INDENT> if ( self . elem_has_tag_and_atr ( elem , tag , atr , atrval ) ) : <NEWLINE> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["d41579fb61a55efacd566b28bed20ade", {"code_string": "def getDataSender(self, dstServer):\n    \"\"\"Basing on the protocol name finds a proper module which\tname is composed\"\"\"\n    try:\n        name = self.getDataSenderClassName(dstServer.getProtocol()\n        module = importlib.import_module(\".implementation.\" + name, \"pyagent.data.sender\")\n        dataSenderClassObject = getattr(module, name)\n        dataSender = dataSenderClassObject(dstServer)\n        return dataSender\n    except ImportError:\n        return None\n", "code_toks_joined": "def getDataSender ( self , dstServer ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> name = self . getDataSenderClassName ( dstServer . getProtocol ( ) <NEWLINE> module = importlib . import_module ( <STRING> + name , <STRING> ) <NEWLINE> dataSenderClassObject = getattr ( module , name ) <NEWLINE> dataSender = dataSenderClassObject ( dstServer ) <NEWLINE> return dataSender <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Basing on the protocol name finds a proper module which\tname is composed\"\"\"", "\".implementation.\"", "\"pyagent.data.sender\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["62ac61f6abb35329dd0c09f37410dca6", {"code_string": "def __init__(self, logfile = \"/var/log/cobbler/cobbler.log\"):\n    self.logfile = None\n    if not os.path.exists(logfile) and os.path.exists(os.path.dirname(logfile):\n        self.logfile = open(logfile, \"a\")\n        self.logfile.close()\n    try:\n        self.logfile = open(logfile, \"a\")\n    except IOError:\n        pass\n", "code_toks_joined": "def __init__ ( self , logfile = <STRING> ) : <NEWLINE> <INDENT> self . logfile = None <NEWLINE> if not os . path . exists ( logfile ) and os . path . exists ( os . path . dirname ( logfile ) : <NEWLINE> <INDENT> self . logfile = open ( logfile , <STRING> ) <NEWLINE> self . logfile . close ( ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> self . logfile = open ( logfile , <STRING> ) <NEWLINE> <DEDENT> except IOError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"/var/log/cobbler/cobbler.log\"", "\"a\"", "\"a\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["f70c5560ab5ac6549b4961e06cd72508", {"code_string": "def get_module(cmd, sub):\n    try:\n        exec 'from %s.%s import %s as m' %(cmd, sub, sub)\n    except(ImportError, SyntaxError):\n        return\n    else:\n        return m\n", "code_toks_joined": "def get_module ( cmd , sub ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> exec <STRING> % ( cmd , sub , sub ) <NEWLINE> <DEDENT> except ( ImportError , SyntaxError ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return m <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'from %s.%s import %s as m'"]}, "err_obj": {"msg": "invalid syntax"}}], ["d0724287ce2c1f137584e3b4b0c89d1a", {"code_string": "def Update():\n    Log.Debug(\"Retrieving FranceTelevisions webservices from http://webservices.francetelevisions.fr/catchup/flux/flux_main.zip\")\n    flux_zip = HTTP.Request(\"http://webservices.francetelevisions.fr/catchup/flux/flux_main.zip\")\n    flux_zip.load()\n    fp = StringIO(flux_zip.content)\n    zfile = zipfile.ZipFile(fp, 'r')\n    catalogs = [json_file for json_file in zfile.namelist() if not json_file.startswith('guide_tv_')]\n    for json in catalogs:\n    Log.Debug(\"Found %s\" % json)\n    Data.Save(json, zfile.read(json))\n    return MessageContainer(\n        \"Update\",\n        \"Update completed successfully\"\n    )\n", "code_toks_joined": "def Update ( ) : <NEWLINE> <INDENT> Log . Debug ( <STRING> ) <NEWLINE> flux_zip = HTTP . Request ( <STRING> ) <NEWLINE> flux_zip . load ( ) <NEWLINE> fp = StringIO ( flux_zip . content ) <NEWLINE> zfile = zipfile . ZipFile ( fp , <STRING> ) <NEWLINE> catalogs = [ json_file for json_file in zfile . namelist ( ) if not json_file . startswith ( <STRING> ) ] <NEWLINE> for json in catalogs : <NEWLINE> Log . Debug ( <STRING> % json ) <NEWLINE> Data . Save ( json , zfile . read ( json ) ) <NEWLINE> return MessageContainer ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Retrieving FranceTelevisions webservices from http://webservices.francetelevisions.fr/catchup/flux/flux_main.zip\"", "\"http://webservices.francetelevisions.fr/catchup/flux/flux_main.zip\"", "'r'", "'guide_tv_'", "\"Found %s\"", "\"Update\"", "\"Update completed successfully\""]}, "err_obj": {"msg": "expected an indented block"}}], ["f6e42177f74ca2fa60f707add56c2009", {"code_string": "def value_letters(letter):\n    letter = str(letter)\n    alphabet = list(string.ascii_uppercase)\n    value = 0\n    for i in range(0, len(alphabet):\n        if letter == alphabet[i]:\n            value = (i + 1)\n    return value\n", "code_toks_joined": "def value_letters ( letter ) : <NEWLINE> <INDENT> letter = str ( letter ) <NEWLINE> alphabet = list ( string . ascii_uppercase ) <NEWLINE> value = 0 <NEWLINE> for i in range ( 0 , len ( alphabet ) : <NEWLINE> <INDENT> if letter == alphabet [ i ] : <NEWLINE> <INDENT> value = ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> return value <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["3fb9a7ea6cfe337e184fdfd233d1bc06", {"code_string": "def test_detach_vm_disk(self):\n    self._lookup_vm()\n    mock_disk = self._prepare_mock_disk()\n    with mock.patch.object(self._vmutils,\n        '_remove_virt_resource') as mock_rm_virt_res:\n        self._vmutils.detach_vm_disk(self._FAKE_VM_NAME,\n            self._FAKE_HOST_RESOURCE)\n            mock_rm_virt_res.assert_called_with(mock_disk, self._FAKE_VM_PATH)\n", "code_toks_joined": "def test_detach_vm_disk ( self ) : <NEWLINE> <INDENT> self . _lookup_vm ( ) <NEWLINE> mock_disk = self . _prepare_mock_disk ( ) <NEWLINE> with mock . patch . object ( self . _vmutils , <NEWLINE> <INDENT> <STRING> ) as mock_rm_virt_res : <NEWLINE> self . _vmutils . detach_vm_disk ( self . _FAKE_VM_NAME , <NEWLINE> <INDENT> self . _FAKE_HOST_RESOURCE ) <NEWLINE> mock_rm_virt_res . assert_called_with ( mock_disk , self . _FAKE_VM_PATH ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'_remove_virt_resource'"]}, "err_obj": {"msg": "unexpected indent"}}], ["f519d85948c6b9928809cad7245b75e2", {"code_string": "def test():\n    phash = helpers.Phash(plot()\n    assert phash.phash == 'fd7e03fc03bc0381', phash.get_details()\n    return\n", "code_toks_joined": "def test ( ) : <NEWLINE> <INDENT> phash = helpers . Phash ( plot ( ) <NEWLINE> assert phash . phash == <STRING> , phash . get_details ( ) <NEWLINE> return <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'fd7e03fc03bc0381'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["92d2b1e67269389fd712dc3716759fa5", {"code_string": "def make_connection(connection, state):\n    pre_skID, m = connection\n    for post_skID, synapses in m.iteritems():\n        for source in(('<projection name=\"NetworkConnection\" source=\"sk_%s\" target=\"sk_%s\">\\n' %(pre_skID, post_skID),\n            '<synapse_props synapse_type=\"DoubExpSynA\" internal_delay=\"5\" weight=\"1\" threshold=\"-20\"/>\\n',\n            '<connections size=\"%s\">\\n' % len(synapses)),\n            make_connection_entries(pre_skID, post_skID, synapses, state),\n            ('</connections>\\n', '</projection>\\n')):\n            for line in source:\n            yield line\n", "code_toks_joined": "def make_connection ( connection , state ) : <NEWLINE> <INDENT> pre_skID , m = connection <NEWLINE> for post_skID , synapses in m . iteritems ( ) : <NEWLINE> <INDENT> for source in ( ( <STRING> % ( pre_skID , post_skID ) , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> % len ( synapses ) ) , <NEWLINE> make_connection_entries ( pre_skID , post_skID , synapses , state ) , <NEWLINE> ( <STRING> , <STRING> ) ) : <NEWLINE> for line in source : <NEWLINE> yield line <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'<projection name=\"NetworkConnection\" source=\"sk_%s\" target=\"sk_%s\">\\n'", "'<synapse_props synapse_type=\"DoubExpSynA\" internal_delay=\"5\" weight=\"1\" threshold=\"-20\"/>\\n'", "'<connections size=\"%s\">\\n'", "'</connections>\\n'", "'</projection>\\n'"]}, "err_obj": {"msg": "expected an indented block"}}], ["b4b8773cb8c7b12971235cd594583d2c", {"code_string": "def test_empty_file(tmpdir):\n    \"\"\"Test invocation with an empty file.\"\"\"\n    gjtk.cli.main(argv = [str(tmpdir.join('empty')])\n", "code_toks_joined": "def test_empty_file ( tmpdir ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> gjtk . cli . main ( argv = [ str ( tmpdir . join ( <STRING> ) ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Test invocation with an empty file.\"\"\"", "'empty'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c345dbc6e170690fd2f1d34c997fc20a", {"code_string": "def _small(self, attr, field, n):\n    array = self._asarray(attr, field)\n    try:\n        n -= 1\n        while(n):\n            array.remove(min(array))\n            n -= 1\n        return min(array)\n    except ValueError, e:\n        return None\n", "code_toks_joined": "def _small ( self , attr , field , n ) : <NEWLINE> <INDENT> array = self . _asarray ( attr , field ) <NEWLINE> try : <NEWLINE> <INDENT> n -= 1 <NEWLINE> while ( n ) : <NEWLINE> <INDENT> array . remove ( min ( array ) ) <NEWLINE> n -= 1 <NEWLINE> <DEDENT> return min ( array ) <NEWLINE> <DEDENT> except ValueError , e : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["80e34507fc5f7df02087ef389414d340", {"code_string": "def previous(self, widget):\n    self.player.do_previous()\n    def quit(self, widget):\n    self.shell.quit()\n", "code_toks_joined": "def previous ( self , widget ) : <NEWLINE> <INDENT> self . player . do_previous ( ) <NEWLINE> def quit ( self , widget ) : <NEWLINE> self . shell . quit ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["9843f992993eab83a13e3a403bb6ca49", {"code_string": "class Auth(object):\n    def __init__(self):\n        pass\n    def authenticate(self, user, passwd):\n        ''' verify credentials in backend'''\n        print(\"authenticating: \", user, \" , \", passwd)\n        return True\n        try:\n            return True if self.app.authenticate_account(user, passwd) else False\n        except Exception, e:\n            print(e)\n            return False\n", "code_toks_joined": "class Auth ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def authenticate ( self , user , passwd ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> , user , <STRING> , passwd ) <NEWLINE> return True <NEWLINE> try : <NEWLINE> <INDENT> return True if self . app . authenticate_account ( user , passwd ) else False <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> print ( e ) <NEWLINE> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''' verify credentials in backend'''", "\"authenticating: \"", "\" , \""]}, "err_obj": {"msg": "invalid syntax"}}], ["97acc7cfb5f0907a66752d002250a3d2", {"code_string": "class HtmlAttributePane(AttributePane):\n    def __init__(self, gui, master, edit_child = None, undo_stack = None, ** gui_opts):\n        super(HtmlAttributePane, self).__init__(gui, master, edit_child, undo_stack, ** gui_opts)\n    def get_edition(self): return self.master.get_edition()\n    def get_html(self):\n        html = u\"\"\"<table border=\"0\">\\n\"\"\"\n        print(\"w\"), self.fields)\n        for priority, name, attr, Field in self.attrs:\n            field = self.fields[attr]\n            if not field: continue\n            html += u\"\"\"<tr><td>%s</td><td>%s</td><td>%s</td></tr>\\n\"\"\" %(html_escape(name), field.get_html(), html_escape(field.unit_label))\n        html += u\"\"\"</table>\\n\"\"\"\n        return html\n    def _new_field(self, attr, name, Field, unit, i):\n        field = Field(self.gui, self, self.o, attr, self.undo_stack)\n        if unit: field.unit_label = unit_label\n        else: field.unit_label = u\"\"\n        return field\n", "code_toks_joined": "class HtmlAttributePane ( AttributePane ) : <NEWLINE> <INDENT> def __init__ ( self , gui , master , edit_child = None , undo_stack = None , ** gui_opts ) : <NEWLINE> <INDENT> super ( HtmlAttributePane , self ) . __init__ ( gui , master , edit_child , undo_stack , ** gui_opts ) <NEWLINE> <DEDENT> def get_edition ( self ) : return self . master . get_edition ( ) <NEWLINE> def get_html ( self ) : <NEWLINE> <INDENT> html = <STRING> <NEWLINE> print ( <STRING> ) , self . fields ) <NEWLINE> for priority , name , attr , Field in self . attrs : <NEWLINE> <INDENT> field = self . fields [ attr ] <NEWLINE> if not field : continue <NEWLINE> html += <STRING> % ( html_escape ( name ) , field . get_html ( ) , html_escape ( field . unit_label ) ) <NEWLINE> <DEDENT> html += <STRING> <NEWLINE> return html <NEWLINE> <DEDENT> def _new_field ( self , attr , name , Field , unit , i ) : <NEWLINE> <INDENT> field = Field ( self . gui , self , self . o , attr , self . undo_stack ) <NEWLINE> if unit : field . unit_label = unit_label <NEWLINE> else : field . unit_label = <STRING> <NEWLINE> return field <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["u\"\"\"<table border=\"0\">\\n\"\"\"", "\"w\"", "u\"\"\"<tr><td>%s</td><td>%s</td><td>%s</td></tr>\\n\"\"\"", "u\"\"\"</table>\\n\"\"\"", "u\"\""]}, "window_span": [80, 90], "err_obj": {"msg": "unbalanced (){}[]"}}], ["0939e24bbf6cb96e6cab021cc7b7e269", {"code_string": "def parse(json, key):\n    value = None\n    try:\n        value = json[key]\n    except KeyError:\n        return None\n    except Exception, e:\n        raise e\n    return value\n", "code_toks_joined": "def parse ( json , key ) : <NEWLINE> <INDENT> value = None <NEWLINE> try : <NEWLINE> <INDENT> value = json [ key ] <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> raise e <NEWLINE> <DEDENT> return value <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["7f075a66d6c6b0cec216b287769ff09a", {"code_string": "def SetIsHidden(self, is_hidden):\n    \"\"\"Sets whether this message should be hidden.\"\"\"\n    if is_hidden not in[0, 1]:\n        raise MessageTranslationError, \"is_hidden must be 0 or 1, got %s\"\n    self.__is_hidden = is_hidden\n", "code_toks_joined": "def SetIsHidden ( self , is_hidden ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if is_hidden not in [ 0 , 1 ] : <NEWLINE> <INDENT> raise MessageTranslationError , <STRING> <NEWLINE> <DEDENT> self . __is_hidden = is_hidden <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Sets whether this message should be hidden.\"\"\"", "\"is_hidden must be 0 or 1, got %s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["5a49dbbf7746271dbdb8adf87134aee0", {"code_string": "def retranslateUi(self, widgetDataWizard):\n    widgetDataWizard.setWindowTitle(QtGui.QApplication.translate(\"widgetDataWizard\", \"Wizard\", None, QtGui.QApplication.UnicodeUTF8))\n    self.wizardPageZones.setTitle(QtGui.QApplication.translate(\"widgetDataWizard\", \"Zone\", None, QtGui.QApplication.UnicodeUTF8))\n    self.wizardPageZones.setSubTitle(QtGui.QApplication.translate(\"widgetDataWizard\", \"Homogenous Zone data\", None, QtGui.QApplication.UnicodeUTF8))\n    self.radio_zones_count.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"Land use zones with building count\", None, QtGui.QApplication.UnicodeUTF8))\n    self.radio_zones_only.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"Land use zones\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lb_zones_proj.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"Select/verify projection:\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lb_zones_select_file.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"Select file:\", None, QtGui.QApplication.UnicodeUTF8))\n    self.radio_zones_no_data.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"No Data\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lb_zones_class_field.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"Select field containing land use/class attributes:\", None, QtGui.QApplication.UnicodeUTF8))\n    self.btn_zones_select_file.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"...\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lb_zones_desc.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"What type of data do you have for zones?\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lb_zones_count_field.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"Select field containing building count\", None, QtGui.QApplication.UnicodeUTF8))\n    self.wizardPageFoortprints.setTitle(QtGui.QApplication.translate(\"widgetDataWizard\", \"Footprint\", None, QtGui.QApplication.UnicodeUTF8))\n    self.wizardPageFoortprints.setSubTitle(QtGui.QApplication.translate(\"widgetDataWizard\", \"Building Footprint Data\", None, QtGui.QApplication.UnicodeUTF8))\n    self.radio_fp_height.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"Building footprints with height\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lb_fp_select_file.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"Select file:\", None, QtGui.QApplication.UnicodeUTF8))\n    self.radio_fp_only.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"Building footprints without height\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lb_fp_desc.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"What type of data do you have for building footprints?\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lb_fp_proj.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"Select/verify projection:\", None, QtGui.QApplication.UnicodeUTF8))\n    self.btn_fp_select_file.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"...\", None, QtGui.QApplication.UnicodeUTF8))\n    self.radio_fp_no_data.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"No Data\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lb_fp_story_field.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"Select field containing number of stories:\", None, QtGui.QApplication.UnicodeUTF8))\n    self.wizardPagePopGrid.setTitle(QtGui.QApplication.translate(\"widgetDataWizard\", \"Population Grid\", None, QtGui.QApplication.UnicodeUTF8))\n    self.wizardPagePopGrid.setSubTitle(QtGui.QApplication.translate(\"widgetDataWizard\", \"Population Grid\", None, QtGui.QApplication.UnicodeUTF8))\n    self.radio_pop_grid.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"Population Grid from GED\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lb_pop_desc.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"What type of data do you have for population?\", None, QtGui.QApplication.UnicodeUTF8))\n    self.radio_pop_no_data.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"No Data\", None, QtGui.QApplication.UnicodeUTF8))\n    self.btn_pop_select_file.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"...\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lb_pop_select_file.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"Select file:\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lb_pop_pop_field.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"Select field containing population:\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lb_pop_proj.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"Verify projection:\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lb_pop_bldg_ratio.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"Average Number of People Per Building\", None, QtGui.QApplication.UnicodeUTF8))\n    self.wizardPageSurveys.setTitle(QtGui.QApplication.translate(\"widgetDataWizard\", \"Survey\", None, QtGui.QApplication.UnicodeUTF8))\n    self.wizardPageSurveys.setSubTitle(QtGui.QApplication.translate(\"widgetDataWizard\", \"Field survey data\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lb_svy_select_file.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"Select file:\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lb_svy_desc.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"What type of survey / field data do you have?\", None, QtGui.QApplication.UnicodeUTF8))\n    self.btn_svy_select_file.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"...\", None, QtGui.QApplication.UnicodeUTF8))\n    self.radio_svy_sampled.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"Sampled buildings from survey area\", None, QtGui.QApplication.UnicodeUTF8))\n    self.radio_svy_no_data.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"No Data\", None, QtGui.QApplication.UnicodeUTF8))\n    self.radio_svy_complete.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"Complete building stock/survey area\", None, QtGui.QApplication.UnicodeUTF8))\n    self.wizardPageAggr.setTitle(QtGui.QApplication.translate(\"widgetDataWizard\", \"Output\", None, QtGui.QApplication.UnicodeUTF8))\n    self.wizardPageAggr.setSubTitle(QtGui.QApplication.translate(\"widgetDataWizard\", \"Output Aggregation Format\", None, QtGui.QApplication.UnicodeUTF8))\n    self.radio_aggr_grid.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"GED Compatible 30 arc-second grid\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lb_aggr_desc.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"How do you wish to aggregate your output data?\", None, QtGui.QApplication.UnicodeUTF8))\n    self.radio_aggr_zones.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"Output into defined zones \", None, QtGui.QApplication.UnicodeUTF8))\n    self.wizardPageVerify.setTitle(QtGui.QApplication.translate(\"widgetDataWizard\", \"Review\", None, QtGui.QApplication.UnicodeUTF8))\n    self.wizardPageVerify.setSubTitle(QtGui.QApplication.translate(\"widgetDataWizard\", \"Review input data\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lb_verify_title.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"You have supplied the following types of data:\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lb_verify_fp.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"Footprint\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lb_verify_svy.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"Survey\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lb_verify_zones.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"Zones\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lb_verify_aggregation.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"With aggregation\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lb_verify_agg_zone.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"Zone\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lb_verify_agg_grid.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"GED Compatible Grid\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lb_verify_pop.setText(QtGui.QApplication.translate(\"widgetDataWizard\", \"Population Grid\", None, QtGui.QApplication.UnicodeUTF8))\n    self.txt_verify_text.setHtml(QtGui.QApplication.translate(\"widgetDataWizard\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , widgetDataWizard ) : <NEWLINE> <INDENT> widgetDataWizard . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . wizardPageZones . setTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . wizardPageZones . setSubTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . radio_zones_count . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . radio_zones_only . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lb_zones_proj . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lb_zones_select_file . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . radio_zones_no_data . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lb_zones_class_field . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . btn_zones_select_file . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lb_zones_desc . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lb_zones_count_field . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . wizardPageFoortprints . setTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . wizardPageFoortprints . setSubTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . radio_fp_height . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lb_fp_select_file . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . radio_fp_only . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lb_fp_desc . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lb_fp_proj . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . btn_fp_select_file . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . radio_fp_no_data . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lb_fp_story_field . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . wizardPagePopGrid . setTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . wizardPagePopGrid . setSubTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . radio_pop_grid . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lb_pop_desc . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . radio_pop_no_data . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . btn_pop_select_file . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lb_pop_select_file . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lb_pop_pop_field . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lb_pop_proj . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lb_pop_bldg_ratio . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . wizardPageSurveys . setTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . wizardPageSurveys . setSubTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lb_svy_select_file . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lb_svy_desc . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . btn_svy_select_file . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . radio_svy_sampled . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . radio_svy_no_data . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . radio_svy_complete . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . wizardPageAggr . setTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . wizardPageAggr . setSubTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . radio_aggr_grid . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lb_aggr_desc . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . radio_aggr_zones . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . wizardPageVerify . setTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . wizardPageVerify . setSubTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lb_verify_title . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lb_verify_fp . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lb_verify_svy . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lb_verify_zones . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lb_verify_aggregation . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lb_verify_agg_zone . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lb_verify_agg_grid . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lb_verify_pop . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . txt_verify_text . setHtml ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"widgetDataWizard\"", "\"Wizard\"", "\"widgetDataWizard\"", "\"Zone\"", "\"widgetDataWizard\"", "\"Homogenous Zone data\"", "\"widgetDataWizard\"", "\"Land use zones with building count\"", "\"widgetDataWizard\"", "\"Land use zones\"", "\"widgetDataWizard\"", "\"Select/verify projection:\"", "\"widgetDataWizard\"", "\"Select file:\"", "\"widgetDataWizard\"", "\"No Data\"", "\"widgetDataWizard\"", "\"Select field containing land use/class attributes:\"", "\"widgetDataWizard\"", "\"...\"", "\"widgetDataWizard\"", "\"What type of data do you have for zones?\"", "\"widgetDataWizard\"", "\"Select field containing building count\"", "\"widgetDataWizard\"", "\"Footprint\"", "\"widgetDataWizard\"", "\"Building Footprint Data\"", "\"widgetDataWizard\"", "\"Building footprints with height\"", "\"widgetDataWizard\"", "\"Select file:\"", "\"widgetDataWizard\"", "\"Building footprints without height\"", "\"widgetDataWizard\"", "\"What type of data do you have for building footprints?\"", "\"widgetDataWizard\"", "\"Select/verify projection:\"", "\"widgetDataWizard\"", "\"...\"", "\"widgetDataWizard\"", "\"No Data\"", "\"widgetDataWizard\"", "\"Select field containing number of stories:\"", "\"widgetDataWizard\"", "\"Population Grid\"", "\"widgetDataWizard\"", "\"Population Grid\"", "\"widgetDataWizard\"", "\"Population Grid from GED\"", "\"widgetDataWizard\"", "\"What type of data do you have for population?\"", "\"widgetDataWizard\"", "\"No Data\"", "\"widgetDataWizard\"", "\"...\"", "\"widgetDataWizard\"", "\"Select file:\"", "\"widgetDataWizard\"", "\"Select field containing population:\"", "\"widgetDataWizard\"", "\"Verify projection:\"", "\"widgetDataWizard\"", "\"Average Number of People Per Building\"", "\"widgetDataWizard\"", "\"Survey\"", "\"widgetDataWizard\"", "\"Field survey data\"", "\"widgetDataWizard\"", "\"Select file:\"", "\"widgetDataWizard\"", "\"What type of survey / field data do you have?\"", "\"widgetDataWizard\"", "\"...\"", "\"widgetDataWizard\"", "\"Sampled buildings from survey area\"", "\"widgetDataWizard\"", "\"No Data\"", "\"widgetDataWizard\"", "\"Complete building stock/survey area\"", "\"widgetDataWizard\"", "\"Output\"", "\"widgetDataWizard\"", "\"Output Aggregation Format\"", "\"widgetDataWizard\"", "\"GED Compatible 30 arc-second grid\"", "\"widgetDataWizard\"", "\"How do you wish to aggregate your output data?\"", "\"widgetDataWizard\"", "\"Output into defined zones \"", "\"widgetDataWizard\"", "\"Review\"", "\"widgetDataWizard\"", "\"Review input data\"", "\"widgetDataWizard\"", "\"You have supplied the following types of data:\"", "\"widgetDataWizard\"", "\"Footprint\"", "\"widgetDataWizard\"", "\"Survey\"", "\"widgetDataWizard\"", "\"Zones\"", "\"widgetDataWizard\"", "\"With aggregation\"", "\"widgetDataWizard\"", "\"Zone\"", "\"widgetDataWizard\"", "\"GED Compatible Grid\"", "\"widgetDataWizard\"", "\"Population Grid\"", "\"widgetDataWizard\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "window_span": [1443, 1455], "err_obj": {"msg": "unbalanced (){}[]"}}], ["d38dc5007dcb0290fc15f251846964fc", {"code_string": "from scipy.interpolate import interp1d\nimport numpy as np\nimport pandas as pd\nimport sys, os\nhere = os.path.dirname(os.path.abspath(__file__)\n", "code_toks_joined": "from scipy . interpolate import interp1d <NEWLINE> import numpy as np <NEWLINE> import pandas as pd <NEWLINE> import sys , os <NEWLINE> here = os . path . dirname ( os . path . abspath ( __file__ ) <NEWLINE>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["3c6cbd58f1f4ff91549ed985cd57bfbf", {"code_string": "def build_icmp(self):\n    pkt = IP(src = self.gateway, dst = self.target) / ICMP(type = 5, code = 1, , gw = get_if_addr(self.interface)) / IP(src = self.target, dst = self.gateway) / UDP()\n    return pkt\n", "code_toks_joined": "def build_icmp ( self ) : <NEWLINE> <INDENT> pkt = IP ( src = self . gateway , dst = self . target ) / ICMP ( type = 5 , code = 1 , , gw = get_if_addr ( self . interface ) ) / IP ( src = self . target , dst = self . gateway ) / UDP ( ) <NEWLINE> return pkt <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["7ec97a11f19264ae62e23d679a133e08", {"code_string": "sayi = int(input('Bir sayi giriniz : '))\nbolundu = 0\nfor i in range(2, (sayi // 2):\n    if sayi % i == 0:\n        print(\"Girdiginiz sayi asal degildir !!\")\n        bolundu += 1\n        break\nif(bolundu == 0):\n    print(\"Bu sayi asaldir !!\")\n", "code_toks_joined": "sayi = int ( input ( <STRING> ) ) <NEWLINE> bolundu = 0 <NEWLINE> for i in range ( 2 , ( sayi // 2 ) : <NEWLINE> <INDENT> if sayi % i == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> bolundu += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( bolundu == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Bir sayi giriniz : '", "\"Girdiginiz sayi asal degildir !!\"", "\"Bu sayi asaldir !!\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["a264ed45116bd6b3934639162021cb5a", {"code_string": "def Error(self, msg):\n    if GetOption('release_debug'): print 'Error: %s' % msg\n    self.errors.append(msg)\n", "code_toks_joined": "def Error ( self , msg ) : <NEWLINE> <INDENT> if GetOption ( <STRING> ) : print <STRING> % msg <NEWLINE> self . errors . append ( msg ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'release_debug'", "'Error: %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["9df9f2655c61f48bf4757a16a993309f", {"code_string": "def _get_object(self):\n    \"\"\": return: \"\"\"\n    return Object.new_from_sha(self.repo, hex_to_bin(self.dereference_recursive(self.repo, self.path))\n", "code_toks_joined": "def _get_object ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return Object . new_from_sha ( self . repo , hex_to_bin ( self . dereference_recursive ( self . repo , self . path ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\": return: \"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["98798153ee826235e4a2fbda6a39fee8", {"code_string": "def JudgeSuperior(self, context)\n    self.status_superior = self.status_baseline\n    return self.status_superior\n", "code_toks_joined": "def JudgeSuperior ( self , context ) <NEWLINE> <INDENT> self . status_superior = self . status_baseline <NEWLINE> return self . status_superior <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["1bc96a2dd1c8b80b634a891087019c64", {"code_string": "def __len__(self):\n    value = self.value()\n    if not hasattr(value, \"__len__\"):\n        raise TypeError(\"object of type %s has no len()\" % str(value)\n    return len(value)\n", "code_toks_joined": "def __len__ ( self ) : <NEWLINE> <INDENT> value = self . value ( ) <NEWLINE> if not hasattr ( value , <STRING> ) : <NEWLINE> <INDENT> raise TypeError ( <STRING> % str ( value ) <NEWLINE> <DEDENT> return len ( value ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"__len__\"", "\"object of type %s has no len()\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["74a8f31e9693108ff8daba1d36015080", {"code_string": "def list_inventories(self):\n    data = []\n    r = requests.get(self.tower_url + \"/api/v1/inventories/\", auth = self.tower_credentials, verify = self.ssl_verify)\n    inventories = r.json()\n    for inventory in inventories['results']:\n    data.append(\"[{}] {}\".format(inventory['id'], inventory['name']))\n    return '\\n'.join(data)\n", "code_toks_joined": "def list_inventories ( self ) : <NEWLINE> <INDENT> data = [ ] <NEWLINE> r = requests . get ( self . tower_url + <STRING> , auth = self . tower_credentials , verify = self . ssl_verify ) <NEWLINE> inventories = r . json ( ) <NEWLINE> for inventory in inventories [ <STRING> ] : <NEWLINE> data . append ( <STRING> . format ( inventory [ <STRING> ] , inventory [ <STRING> ] ) ) <NEWLINE> return <STRING> . join ( data ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"/api/v1/inventories/\"", "'results'", "\"[{}] {}\"", "'id'", "'name'", "'\\n'"]}, "err_obj": {"msg": "expected an indented block"}}], ["6ebe0ffd845ce2dae0210585a80e075b", {"code_string": "def sense_RG(self, channel_id, user_id):\n    txtRG = \"Rajjjjjjaaaaaaaaaaaaannnnnnnnnnniiiiiiiiiiiiiiiiiiieeeeeeeeeeeeeee\"\n    txtEff = \"Get a haircut Effy\"\n        if user_id == \"U03BYG0DJ\":\n            printflag = (randint(0, 6))\n            if printflag == 3:\n            self.clients.send_user_typing_pause(channel_id)\n            self.send_message(channel_id, txtRG)\n", "code_toks_joined": "def sense_RG ( self , channel_id , user_id ) : <NEWLINE> <INDENT> txtRG = <STRING> <NEWLINE> txtEff = <STRING> <NEWLINE> <INDENT> if user_id == <STRING> : <NEWLINE> <INDENT> printflag = ( randint ( 0 , 6 ) ) <NEWLINE> if printflag == 3 : <NEWLINE> self . clients . send_user_typing_pause ( channel_id ) <NEWLINE> self . send_message ( channel_id , txtRG ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Rajjjjjjaaaaaaaaaaaaannnnnnnnnnniiiiiiiiiiiiiiiiiiieeeeeeeeeeeeeee\"", "\"Get a haircut Effy\"", "\"U03BYG0DJ\""]}, "err_obj": {"msg": "unexpected indent"}}], ["c1ca62db788c0ce06599f3faa82d0bae", {"code_string": "def __init__(self, indices_or_sections, axis):\n    if not isinstance(\n        indices_or_sections,\n        six.integer_types +(collections.Iterable, )):\n        raise TypeError('indices_or_sections must be integer or 1-D array')\n    if(chainer.is_debug() and\n        isinstance(indices_or_sections, collections.Iterable)):\n        for p, n in six.moves.zip(\n            indices_or_sections, indices_or_sections[1: ]):\n        if p > n:\n            raise ValueError('indices_or_sections must be sorted')\n    self.indices_or_sections = indices_or_sections\n    self.axis = axis\n", "code_toks_joined": "def __init__ ( self , indices_or_sections , axis ) : <NEWLINE> <INDENT> if not isinstance ( <NEWLINE> <INDENT> indices_or_sections , <NEWLINE> six . integer_types + ( collections . Iterable , ) ) : <NEWLINE> raise TypeError ( <STRING> ) <NEWLINE> <DEDENT> if ( chainer . is_debug ( ) and <NEWLINE> <INDENT> isinstance ( indices_or_sections , collections . Iterable ) ) : <NEWLINE> for p , n in six . moves . zip ( <NEWLINE> <INDENT> indices_or_sections , indices_or_sections [ 1 : ] ) : <NEWLINE> <DEDENT> if p > n : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> self . indices_or_sections = indices_or_sections <NEWLINE> self . axis = axis <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'indices_or_sections must be integer or 1-D array'", "'indices_or_sections must be sorted'"]}, "err_obj": {"msg": "expected an indented block"}}], ["b9069e9ceae27551c50db9af9bca7b62", {"code_string": "def test_reset_source_initeration(self):\n    '''reset source using send in iteration - pass'''\n    with(repack\n        .integer()\n        .iterator(\n            iter(['1', '2', '3']))) as iterator:\n            iterator.send(iter(['11', '33', '22']))\n            r = []\n            for v in iterator:\n        r.append(v)\n        if v == 11:\n            iterator.send(iter([22, 33]))\n    self.assertSequenceEqual([11, 22, 33], r)\n", "code_toks_joined": "def test_reset_source_initeration ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with ( repack <NEWLINE> <INDENT> . integer ( ) <NEWLINE> . iterator ( <NEWLINE> <INDENT> iter ( [ <STRING> , <STRING> , <STRING> ] ) ) ) as iterator : <NEWLINE> iterator . send ( iter ( [ <STRING> , <STRING> , <STRING> ] ) ) <NEWLINE> r = [ ] <NEWLINE> for v in iterator : <NEWLINE> <DEDENT> r . append ( v ) <NEWLINE> if v == 11 : <NEWLINE> <INDENT> iterator . send ( iter ( [ 22 , 33 ] ) ) <NEWLINE> <DEDENT> <DEDENT> self . assertSequenceEqual ( [ 11 , 22 , 33 ] , r ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''reset source using send in iteration - pass'''", "'1'", "'2'", "'3'", "'11'", "'33'", "'22'"]}, "err_obj": {"msg": "unindent does not match any outer indentation level"}}], ["e1cfbfd24f958ed07c855db9b5a8c396", {"code_string": "def test_no_notification_notify_nova_on_port_data_changes_false(self):\n    cfg.CONF.set_override('notify_nova_on_port_data_changes', False)\n    with mock.patch.object(self.nova_notifier,\n        'send_events') as send_events:\n        self.nova_notifier.send_network_change('update_floatingip',\n            {}, {})\n            self.assertFalse(send_events.called, False)\n", "code_toks_joined": "def test_no_notification_notify_nova_on_port_data_changes_false ( self ) : <NEWLINE> <INDENT> cfg . CONF . set_override ( <STRING> , False ) <NEWLINE> with mock . patch . object ( self . nova_notifier , <NEWLINE> <INDENT> <STRING> ) as send_events : <NEWLINE> self . nova_notifier . send_network_change ( <STRING> , <NEWLINE> <INDENT> { } , { } ) <NEWLINE> self . assertFalse ( send_events . called , False ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'notify_nova_on_port_data_changes'", "'send_events'", "'update_floatingip'"]}, "err_obj": {"msg": "unexpected indent"}}], ["35d6863ccda20051bee3431747d438d3", {"code_string": "def precompile_exceptions(exceptions, use_regex, flags):\n    if not exceptions:\n        return\n    for exceptionCategory in[\n        'title', 'require-title', 'text-contains', 'inside']:\n        if exceptionCategory in exceptions:\n        patterns = exceptions[exceptionCategory]\n        if not use_regex:\n            patterns = [re.escape(pattern) for pattern in patterns]\n        patterns = [re.compile(pattern, flags) for pattern in patterns]\n        exceptions[exceptionCategory] = patterns\n", "code_toks_joined": "def precompile_exceptions ( exceptions , use_regex , flags ) : <NEWLINE> <INDENT> if not exceptions : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for exceptionCategory in [ <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> if exceptionCategory in exceptions : <NEWLINE> patterns = exceptions [ exceptionCategory ] <NEWLINE> if not use_regex : <NEWLINE> <INDENT> patterns = [ re . escape ( pattern ) for pattern in patterns ] <NEWLINE> <DEDENT> patterns = [ re . compile ( pattern , flags ) for pattern in patterns ] <NEWLINE> exceptions [ exceptionCategory ] = patterns <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'title'", "'require-title'", "'text-contains'", "'inside'"]}, "err_obj": {"msg": "expected an indented block"}}], ["9df30fad542a87a1680e42f1b06c714c", {"code_string": "def containers_index():\n    \"\"\"List all containers\"\"\"\n    if request.args.get('state') == 'running':\n    output = docker('ps')\n    else:\n    output = docker('ps', '-a')\n    resp = json.dumps(docker_ps_to_array(output))\n    return Response(response = resp, mimetype = \"application/json\")\n", "code_toks_joined": "def containers_index ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if request . args . get ( <STRING> ) == <STRING> : <NEWLINE> output = docker ( <STRING> ) <NEWLINE> else : <NEWLINE> output = docker ( <STRING> , <STRING> ) <NEWLINE> resp = json . dumps ( docker_ps_to_array ( output ) ) <NEWLINE> return Response ( response = resp , mimetype = <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"List all containers\"\"\"", "'state'", "'running'", "'ps'", "'ps'", "'-a'", "\"application/json\""]}, "err_obj": {"msg": "expected an indented block"}}], ["625021ef1fe1e0fa73c7d9ec847ccdea", {"code_string": "class CanvasA1(Canvas):\n    def __init__(self, filename,\n        pagesize = None,\n        bottomup = 1,\n        pageCompression = None,\n        encoding = None,\n        invariant = None,\n        verbosity = 0):\n        Canvas.__init__(self, filename, pagesize = pagesize, bottomup = bottomup, pageCompression = pageCompression,\n            encoding = encoding, invariant = invariant, verbosity = verbosity)\n            self.scale(2.0 * math.sqrt(2.0), 2.0 * math.sqrt(2.0))\n            self.setPageSize(A1)\n", "code_toks_joined": "class CanvasA1 ( Canvas ) : <NEWLINE> <INDENT> def __init__ ( self , filename , <NEWLINE> <INDENT> pagesize = None , <NEWLINE> bottomup = 1 , <NEWLINE> pageCompression = None , <NEWLINE> encoding = None , <NEWLINE> invariant = None , <NEWLINE> verbosity = 0 ) : <NEWLINE> Canvas . __init__ ( self , filename , pagesize = pagesize , bottomup = bottomup , pageCompression = pageCompression , <NEWLINE> <INDENT> encoding = encoding , invariant = invariant , verbosity = verbosity ) <NEWLINE> self . scale ( 2.0 * math . sqrt ( 2.0 ) , 2.0 * math . sqrt ( 2.0 ) ) <NEWLINE> self . setPageSize ( A1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["be8a923f5388a9ae336d1723e68b34bd", {"code_string": "def place(self, x, y):\n    self.y[x] = y self.y[0] = 0\n    self.row[y] = 1 self.row[0] = 1\n    self.up[x - y] = 1 self.up[0] = 1\n    self.down[x + y] = 1 self.down[0] = 1\n", "code_toks_joined": "def place ( self , x , y ) : <NEWLINE> <INDENT> self . y [ x ] = y self . y [ 0 ] = 0 <NEWLINE> self . row [ y ] = 1 self . row [ 0 ] = 1 <NEWLINE> self . up [ x - y ] = 1 self . up [ 0 ] = 1 <NEWLINE> self . down [ x + y ] = 1 self . down [ 0 ] = 1 <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["c8f758bea355e19892e72ada2be48c99", {"code_string": "def main():\n    configdict = {}\n        config = '../config/Config.conf'\n        with open(config) as config_file:\n            for lines in config_file:\n                if re.search(r'=', lines):\n                    key = lines.strip('\\n').strip().split('=')\n                    configdict[key[0]] = key[1]\n    testmongo = CountMongo(configdict)\n    testmongo.count()\n", "code_toks_joined": "def main ( ) : <NEWLINE> <INDENT> configdict = { } <NEWLINE> <INDENT> config = <STRING> <NEWLINE> with open ( config ) as config_file : <NEWLINE> <INDENT> for lines in config_file : <NEWLINE> <INDENT> if re . search ( <STRING> , lines ) : <NEWLINE> <INDENT> key = lines . strip ( <STRING> ) . strip ( ) . split ( <STRING> ) <NEWLINE> configdict [ key [ 0 ] ] = key [ 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> testmongo = CountMongo ( configdict ) <NEWLINE> testmongo . count ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'../config/Config.conf'", "r'='", "'\\n'", "'='"]}, "err_obj": {"msg": "unexpected indent"}}], ["86ea5323db32c5ee6849025202f2435c", {"code_string": "class Ui_MainWindow(QtGui.QWidget):\n    def setupUi(self, MainWindow):\n        MainWindow.setObjectName(_fromUtf8(\"MainWindow\"))\n        MainWindow.resize(500, 273)\n        MainWindow.setFixedSize(500, 273)\n        MainWindow.setStyleSheet(_fromUtf8(\"QWidget#centralwidget{background-color: qlineargradient(spread:pad, x1:1, y1:1, x2:1, y2:0, stop:0 rgba(186, 186, 186, 255), stop:0.781095 rgba(235, 235, 235, 255));}\\n\"\n", "code_toks_joined": "class Ui_MainWindow ( QtGui . QWidget ) : <NEWLINE> <INDENT> def setupUi ( self , MainWindow ) : <NEWLINE> <INDENT> MainWindow . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> MainWindow . resize ( 500 , 273 ) <NEWLINE> MainWindow . setFixedSize ( 500 , 273 ) <NEWLINE> MainWindow . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"MainWindow\"", "\"QWidget#centralwidget{background-color: qlineargradient(spread:pad, x1:1, y1:1, x2:1, y2:0, stop:0 rgba(186, 186, 186, 255), stop:0.781095 rgba(235, 235, 235, 255));}\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["8dc84b5f823cb83d73dd2421450dd577", {"code_string": "def __init__(self, wbits = MAX_WBITS):\n    if abs(wbits) > MAX_WBITS or abs(wbits) < 8:\n        raise ValueError, \"Invalid initialization option\"\n    self.inflater = Inflater(wbits < 0)\n    self.unused_data = \"\"\n    self._ended = False\n", "code_toks_joined": "def __init__ ( self , wbits = MAX_WBITS ) : <NEWLINE> <INDENT> if abs ( wbits ) > MAX_WBITS or abs ( wbits ) < 8 : <NEWLINE> <INDENT> raise ValueError , <STRING> <NEWLINE> <DEDENT> self . inflater = Inflater ( wbits < 0 ) <NEWLINE> self . unused_data = <STRING> <NEWLINE> self . _ended = False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Invalid initialization option\"", "\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["4bba2edcf33e3b43f446a104153fb508", {"code_string": "def sparse_softmax_cross_entropy(logits, labels, weights = 1.0, scope = None):\n    \"\"\"Cross-entropy loss using `tf.nn.sparse_softmax_cross_entropy_with_logits`.\"\"\"\n    with ops.name_scope(scope, \"sparse_softmax_cross_entropy_loss\",\n        [logits, labels, weights]) as scope:\n        labels = array_ops.reshape(labels, shape = [array_ops.shape(labels)[0]])\n        losses = nn.sparse_softmax_cross_entropy_with_logits(labels = labels,\n            logits = logits,\n            name = \"xentropy\")\n            return compute_weighted_loss(losses, weights, scope = scope)\n", "code_toks_joined": "def sparse_softmax_cross_entropy ( logits , labels , weights = 1.0 , scope = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with ops . name_scope ( scope , <STRING> , <NEWLINE> <INDENT> [ logits , labels , weights ] ) as scope : <NEWLINE> labels = array_ops . reshape ( labels , shape = [ array_ops . shape ( labels ) [ 0 ] ] ) <NEWLINE> losses = nn . sparse_softmax_cross_entropy_with_logits ( labels = labels , <NEWLINE> <INDENT> logits = logits , <NEWLINE> name = <STRING> ) <NEWLINE> return compute_weighted_loss ( losses , weights , scope = scope ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Cross-entropy loss using `tf.nn.sparse_softmax_cross_entropy_with_logits`.\"\"\"", "\"sparse_softmax_cross_entropy_loss\"", "\"xentropy\""]}, "err_obj": {"msg": "unexpected indent"}}], ["cfc60a7d06fe34e5fafd816bf3d99745", {"code_string": "from utils import *\nfrom web import *\nimport web\nurls = (\n    '/', 'index',\n    '/generate', 'generate'\n)\nrender = web.template.render('templates/')\ntemplate = web.template.render('templates/')\napp = web.application(urls, globals()\n", "code_toks_joined": "from utils import * <NEWLINE> from web import * <NEWLINE> import web <NEWLINE> urls = ( <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> render = web . template . render ( <STRING> ) <NEWLINE> template = web . template . render ( <STRING> ) <NEWLINE> app = web . application ( urls , globals ( ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["'/'", "'index'", "'/generate'", "'generate'", "'templates/'", "'templates/'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c802d818df43c62ff4dafc5b36a885a0", {"code_string": "def getNeighbors(self, node):\n    def filt((nx, ny)):\n        try:\n            return ny >= 0 and nx >= 0 and self.sm[ny][nx] != self.TILE_WALL\n        except IndexError:\n            return False\n    return self._filter_neighbours(node, [(1, 0), (- 1, 0), (0, 1), (0, - 1)], filt)\n", "code_toks_joined": "def getNeighbors ( self , node ) : <NEWLINE> <INDENT> def filt ( ( nx , ny ) ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return ny >= 0 and nx >= 0 and self . sm [ ny ] [ nx ] != self . TILE_WALL <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return self . _filter_neighbours ( node , [ ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ] , filt ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["f87d2953e00e8ad215f6dc1add3b98c1", {"code_string": "def __init__(self, color, (x, y), index):\n    Piece.__init__(self, color, (x, y), index)\n    self.points = 1\n", "code_toks_joined": "def __init__ ( self , color , ( x , y ) , index ) : <NEWLINE> <INDENT> Piece . __init__ ( self , color , ( x , y ) , index ) <NEWLINE> self . points = 1 <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["33fc8cce735f914ac027ec5779b6154a", {"code_string": "def pyrun(src):\n    \"\"\"Run python code 'src' in a separate interpreter.\"\"\"\n    if PY3:\n        src = bytes(src, 'ascii')\n    with tempfile.NamedTemporaryFile(\n        prefix = TESTFILE_PREFIX, delete = False) as f:\n        _testfiles.append(f.name)\n        f.write(src)\n        f.flush()\n        subp = get_test_subprocess([PYTHON, f.name], stdout = None,\n            stderr = None)\n            wait_for_pid(subp.pid)\n            return subp\n", "code_toks_joined": "def pyrun ( src ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if PY3 : <NEWLINE> <INDENT> src = bytes ( src , <STRING> ) <NEWLINE> <DEDENT> with tempfile . NamedTemporaryFile ( <NEWLINE> <INDENT> prefix = TESTFILE_PREFIX , delete = False ) as f : <NEWLINE> _testfiles . append ( f . name ) <NEWLINE> f . write ( src ) <NEWLINE> f . flush ( ) <NEWLINE> subp = get_test_subprocess ( [ PYTHON , f . name ] , stdout = None , <NEWLINE> <INDENT> stderr = None ) <NEWLINE> wait_for_pid ( subp . pid ) <NEWLINE> return subp <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Run python code 'src' in a separate interpreter.\"\"\"", "'ascii'"]}, "err_obj": {"msg": "unexpected indent"}}], ["deab0b305c9fc3382cef6612f0eda2aa", {"code_string": "def indented_title(self):\n    indent = len(self.real_path.split('/') - 1\n    if not indent:\n        return self.title\n    return '%s %s' %('-' * indent, self.title)\n", "code_toks_joined": "def indented_title ( self ) : <NEWLINE> <INDENT> indent = len ( self . real_path . split ( <STRING> ) - 1 <NEWLINE> if not indent : <NEWLINE> <INDENT> return self . title <NEWLINE> <DEDENT> return <STRING> % ( <STRING> * indent , self . title ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'/'", "'%s %s'", "'-'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["d0a602f745a1ec329c1f5a6f2b2f6eae", {"code_string": "def run_check(callback):\n    instance = urllib2.urlopen(urllib2.Request('http: //169.254.169.254/latest/meta-data/instance-id')).read()\n    if instance == 'i-74bbbd1b':\n        callback('elb', elb_metrics('API'))\n    for mountpoint, volume in get_ebs_volumes(instance):\n        callback('ebs', ebs_metrics(mountpoint, volume)\n", "code_toks_joined": "def run_check ( callback ) : <NEWLINE> <INDENT> instance = urllib2 . urlopen ( urllib2 . Request ( <STRING> ) ) . read ( ) <NEWLINE> if instance == <STRING> : <NEWLINE> <INDENT> callback ( <STRING> , elb_metrics ( <STRING> ) ) <NEWLINE> <DEDENT> for mountpoint , volume in get_ebs_volumes ( instance ) : <NEWLINE> <INDENT> callback ( <STRING> , ebs_metrics ( mountpoint , volume ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'http: //169.254.169.254/latest/meta-data/instance-id'", "'i-74bbbd1b'", "'elb'", "'API'", "'ebs'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["fc9db0b186e8074eb0c09ac166086719", {"code_string": "def grad(self, inp, grads):\n    x, = inp\n    gz, = grads\n    return Rebroadcast(*[(axis, x.type.broadcastable[axis])\n", "code_toks_joined": "def grad ( self , inp , grads ) : <NEWLINE> <INDENT> x , = inp <NEWLINE> gz , = grads <NEWLINE> return Rebroadcast ( * [ ( axis , x . type . broadcastable [ axis ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["98c4caefc0625399ebf99322787c823f", {"code_string": "def keyGreen(self):\n    config.misc.window_animation_speed.save()\n        setAnimation_speed(int(config.misc.window_animation_speed.value))\n    self.close()\n", "code_toks_joined": "def keyGreen ( self ) : <NEWLINE> <INDENT> config . misc . window_animation_speed . save ( ) <NEWLINE> <INDENT> setAnimation_speed ( int ( config . misc . window_animation_speed . value ) ) <NEWLINE> <DEDENT> self . close ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["5e1b125cc5ce0230f770980a52e454e9", {"code_string": "def camera_capture(message):\n    delay = 0\n    body = message['body'].split(' ')\n    try:\n    if body[3].isdigit():\n        delay = int(body[3])\n    except IndexError:\n        pass\n    filename = timestamp + '.jpeg'\n    time.sleep(delay)\n    droid.cameraCapturePicture(path_camera + filename)\n", "code_toks_joined": "def camera_capture ( message ) : <NEWLINE> <INDENT> delay = 0 <NEWLINE> body = message [ <STRING> ] . split ( <STRING> ) <NEWLINE> try : <NEWLINE> if body [ 3 ] . isdigit ( ) : <NEWLINE> <INDENT> delay = int ( body [ 3 ] ) <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> filename = timestamp + <STRING> <NEWLINE> time . sleep ( delay ) <NEWLINE> droid . cameraCapturePicture ( path_camera + filename ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'body'", "' '", "'.jpeg'"]}, "err_obj": {"msg": "expected an indented block"}}], ["9099e9dc6133781fc79d3c31b934d0dc", {"code_string": "class Ui_MainWindow(object):\n    def setupUi(self, MainWindow):\n        MainWindow.setObjectName(_fromUtf8(\"MainWindow\"))\n        MainWindow.setEnabled(True)\n        MainWindow.resize(792, 347)\n        MainWindow.setStyleSheet(_fromUtf8(\"QMainWindow{background-image: url(:/Background/Icons/background.jpg);background-repeat: repeat;}\\n\"\n", "code_toks_joined": "class Ui_MainWindow ( object ) : <NEWLINE> <INDENT> def setupUi ( self , MainWindow ) : <NEWLINE> <INDENT> MainWindow . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> MainWindow . setEnabled ( True ) <NEWLINE> MainWindow . resize ( 792 , 347 ) <NEWLINE> MainWindow . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"MainWindow\"", "\"QMainWindow{background-image: url(:/Background/Icons/background.jpg);background-repeat: repeat;}\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["600b245bb7fdf7cf31850b930a91e72e", {"code_string": "def CheckLocation():\n    \"\"\"Checks that the poolclient is not accidentally ran against production.\"\"\"\n    for url in(config_lib.CONFIG[\"Client.server_urls\"] +\n        config_lib.CONFIG[\"Client.control_urls\"]):\n        if \"staging\" in url or \"localhost\" in url:\n        return\n    logging.error(\"Poolclient should only be run against test or staging.\")\n    exit()\n", "code_toks_joined": "def CheckLocation ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for url in ( config_lib . CONFIG [ <STRING> ] + <NEWLINE> <INDENT> config_lib . CONFIG [ <STRING> ] ) : <NEWLINE> if <STRING> in url or <STRING> in url : <NEWLINE> return <NEWLINE> <DEDENT> logging . error ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Checks that the poolclient is not accidentally ran against production.\"\"\"", "\"Client.server_urls\"", "\"Client.control_urls\"", "\"staging\"", "\"localhost\"", "\"Poolclient should only be run against test or staging.\""]}, "err_obj": {"msg": "expected an indented block"}}], ["04d15344b26b8b607ee5c8536480fe5f", {"code_string": "def tempdir(** kwargs):\n    tmpdir = tempfile.mkdtemp(** kwargs)\n    try:\n        yield tmpdir\n    finally:\n        try:\n            shutil.rmtree(tmpdir)\n        except OSError, e:\n            LOG.debug(_('Could not remove tmpdir: %s'), str(e))\n", "code_toks_joined": "def tempdir ( ** kwargs ) : <NEWLINE> <INDENT> tmpdir = tempfile . mkdtemp ( ** kwargs ) <NEWLINE> try : <NEWLINE> <INDENT> yield tmpdir <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> shutil . rmtree ( tmpdir ) <NEWLINE> <DEDENT> except OSError , e : <NEWLINE> <INDENT> LOG . debug ( _ ( <STRING> ) , str ( e ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Could not remove tmpdir: %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["df915c9156b77a254b8c7254462ce41a", {"code_string": "def handle_dashboard_error(view):\n    \"\"\"Decorator which adds seamless DashboardError handling to a view.  If a\"\"\"\n    def wrapper(request, course_id):\n        \"\"\"Wrap the view.\"\"\"\n        try:\n            return view(request, course_id = course_id)\n        except DashboardError, error:\n            return error.response()\n    return wrapper\n", "code_toks_joined": "def handle_dashboard_error ( view ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def wrapper ( request , course_id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> return view ( request , course_id = course_id ) <NEWLINE> <DEDENT> except DashboardError , error : <NEWLINE> <INDENT> return error . response ( ) <NEWLINE> <DEDENT> <DEDENT> return wrapper <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Decorator which adds seamless DashboardError handling to a view.  If a\"\"\"", "\"\"\"Wrap the view.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["ccd7705c98f1b80a86d40dd9398e978c", {"code_string": "def seek(self frame):\n    if frame >= len(self._offset):\n        raise EOFError(\"attempt to seek outside DCX directory\")\n    self.frame = frame\n    self.fp = self.__fp\n    self.fp.seek(self._offset[frame])\n    PcxImageFile._open(self)\n", "code_toks_joined": "def seek ( self frame ) : <NEWLINE> <INDENT> if frame >= len ( self . _offset ) : <NEWLINE> <INDENT> raise EOFError ( <STRING> ) <NEWLINE> <DEDENT> self . frame = frame <NEWLINE> self . fp = self . __fp <NEWLINE> self . fp . seek ( self . _offset [ frame ] ) <NEWLINE> PcxImageFile . _open ( self ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"attempt to seek outside DCX directory\""]}, "err_obj": {"msg": "invalid syntax"}}], ["3c9eb9ac6d49bfde5a43d0299eb20a11", {"code_string": "def get_category(self, catname):\n    cat = category.Category(self.site, catname)\n    items = []\n    for article in cat.getAllMembersGen(namespaces = [0]):\n        items.append(article.title.lower())\n        if len(items) % 1000 == 0:\n            print 'Downloading item %5d: %20s' %(len(items), items[- 1])\n    return items\n", "code_toks_joined": "def get_category ( self , catname ) : <NEWLINE> <INDENT> cat = category . Category ( self . site , catname ) <NEWLINE> items = [ ] <NEWLINE> for article in cat . getAllMembersGen ( namespaces = [ 0 ] ) : <NEWLINE> <INDENT> items . append ( article . title . lower ( ) ) <NEWLINE> if len ( items ) % 1000 == 0 : <NEWLINE> <INDENT> print <STRING> % ( len ( items ) , items [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> return items <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Downloading item %5d: %20s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["60793bc983a6f77b42bb8864bac476fe", {"code_string": "def notify_loop(self, event_payload):\n    \"\"\"Infinite loop.Notifies every minute using event_payload.\"\"\"\n    while True:\n        sleep(60)\n        LOGGER.debug(str(event_payload)\n        event_payload = []\n", "code_toks_joined": "def notify_loop ( self , event_payload ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> sleep ( 60 ) <NEWLINE> LOGGER . debug ( str ( event_payload ) <NEWLINE> event_payload = [ ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Infinite loop.Notifies every minute using event_payload.\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["2995d20de4cf66a531c840027fb60765", {"code_string": "def get_help_text_stored_procedure(stored_procedure, host, database):\n    connection = pymssql.connect(host = host, database = database, as_dict = True)\n    cursor = connection.cursor()\n    result = \"\"\n    cursor.execute(\"SP_HELPTEXT{0}\".format(stored_procedure)\n    for row in cursor:\n        result = result + row['Text']\n    connection.close()\n    return result\n", "code_toks_joined": "def get_help_text_stored_procedure ( stored_procedure , host , database ) : <NEWLINE> <INDENT> connection = pymssql . connect ( host = host , database = database , as_dict = True ) <NEWLINE> cursor = connection . cursor ( ) <NEWLINE> result = <STRING> <NEWLINE> cursor . execute ( <STRING> . format ( stored_procedure ) <NEWLINE> for row in cursor : <NEWLINE> <INDENT> result = result + row [ <STRING> ] <NEWLINE> <DEDENT> connection . close ( ) <NEWLINE> return result <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"", "\"SP_HELPTEXT{0}\"", "'Text'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["6f6275272bad23b2cd0f48e55e54fdb0", {"code_string": "def clean(self):\n    if('password' in self.errors and 'password' in self.data and\n        1 < len(self.data['password']) < PasswordMixin.min_length):\n        msg = _('As part of our new password policy, your password must '\n            'be %s characters or more. Please update your password by '\n            '<a href=\"%s\">issuing a password reset</a>.'\n            ) %(PasswordMixin.min_length,\n                reverse('password_reset_form'))\n                self._errors['password'] = ErrorList([mark_safe(msg)])\n    if 'recaptcha' in self.errors:\n        return{}\n    return super(AuthenticationForm, self).clean()\n", "code_toks_joined": "def clean ( self ) : <NEWLINE> <INDENT> if ( <STRING> in self . errors and <STRING> in self . data and <NEWLINE> <INDENT> 1 < len ( self . data [ <STRING> ] ) < PasswordMixin . min_length ) : <NEWLINE> msg = _ ( <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> ) % ( PasswordMixin . min_length , <NEWLINE> <INDENT> reverse ( <STRING> ) ) <NEWLINE> self . _errors [ <STRING> ] = ErrorList ( [ mark_safe ( msg ) ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if <STRING> in self . errors : <NEWLINE> <INDENT> return { } <NEWLINE> <DEDENT> return super ( AuthenticationForm , self ) . clean ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'password'", "'password'", "'password'", "'As part of our new password policy, your password must '", "'be %s characters or more. Please update your password by '", "'<a href=\"%s\">issuing a password reset</a>.'", "'password_reset_form'", "'password'", "'recaptcha'"]}, "err_obj": {"msg": "unexpected indent"}}], ["ecd0c8a4331a2512cbc52b009563c481", {"code_string": "class AssertPhaseInstructionThatPassIffStdoutEqualsString(AssertPhaseInstruction):\n    def __init__(self, expected: str):\n        self.expected = expected\n    def main(self, environment: InstructionEnvironmentForPostSdsStep,\n        os_services: OsServices) -> pfh.PassOrFailOrHardError:\n        actual_contents = environment.sds.result.stdout_file.read_text()\n        if actual_contents == self.expected:\n        return pfh.new_pfh_pass()\n        else:\n        err_msg = 'Expected: {}\\nActual  : {}'.format(self.expected, actual_contents)\n        return pfh.new_pfh_fail(err_msg)\n", "code_toks_joined": "class AssertPhaseInstructionThatPassIffStdoutEqualsString ( AssertPhaseInstruction ) : <NEWLINE> <INDENT> def __init__ ( self , expected : str ) : <NEWLINE> <INDENT> self . expected = expected <NEWLINE> <DEDENT> def main ( self , environment : InstructionEnvironmentForPostSdsStep , <NEWLINE> <INDENT> os_services : OsServices ) -> pfh . PassOrFailOrHardError : <NEWLINE> actual_contents = environment . sds . result . stdout_file . read_text ( ) <NEWLINE> if actual_contents == self . expected : <NEWLINE> return pfh . new_pfh_pass ( ) <NEWLINE> else : <NEWLINE> err_msg = <STRING> . format ( self . expected , actual_contents ) <NEWLINE> return pfh . new_pfh_fail ( err_msg ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Expected: {}\\nActual  : {}'"]}, "err_obj": {"msg": "expected an indented block"}}], ["f270c4a56b3f206b101fc9e8bd84c112", {"code_string": "def __init__(self, parameters):\n    command = parameters.command.finalize()\n    invokation = \" (%s%i thread(s))\" %(\"pileup; \" if parameters.pileup_only else \"\"\n        parameters.nbatches)\n    description = \"<GenotypeRegions%s: '%s' -> '%s'>\" %(invokation,\n        parameters.infile,\n        parameters.outfile)\n    CommandNode.__init__(self,\n        description = description,\n        command = command,\n        threads = parameters.nbatches,\n        dependencies = parameters.dependencies)\n", "code_toks_joined": "def __init__ ( self , parameters ) : <NEWLINE> <INDENT> command = parameters . command . finalize ( ) <NEWLINE> invokation = <STRING> % ( <STRING> if parameters . pileup_only else <STRING> <NEWLINE> <INDENT> parameters . nbatches ) <NEWLINE> <DEDENT> description = <STRING> % ( invokation , <NEWLINE> <INDENT> parameters . infile , <NEWLINE> parameters . outfile ) <NEWLINE> <DEDENT> CommandNode . __init__ ( self , <NEWLINE> <INDENT> description = description , <NEWLINE> command = command , <NEWLINE> threads = parameters . nbatches , <NEWLINE> dependencies = parameters . dependencies ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\" (%s%i thread(s))\"", "\"pileup; \"", "\"\"", "\"<GenotypeRegions%s: '%s' -> '%s'>\""]}, "err_obj": {"msg": "invalid syntax"}}], ["5274d4f419633094f74bea973cc6efba", {"code_string": "def mjd(self):\n    \"\"\"Returns the *SDSS* MJD. See line ~140 (the mjd4Gang function) here\"\"\"\n        return int(float(self.start_time) / 86400.0 + 0.3)\n", "code_toks_joined": "def mjd ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> return int ( float ( self . start_time ) / 86400.0 + 0.3 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns the *SDSS* MJD. See line ~140 (the mjd4Gang function) here\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["2073174c48cd81ff4827f389276c4185", {"code_string": "def impala_review_list_box(context, addon, , reviews):\n    \"\"\"Details page: Show a box with three add-on reviews.\"\"\"\n    c = dict(context.items())\n    c.update(addon = addon, reviews = reviews)\n    return c\n", "code_toks_joined": "def impala_review_list_box ( context , addon , , reviews ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> c = dict ( context . items ( ) ) <NEWLINE> c . update ( addon = addon , reviews = reviews ) <NEWLINE> return c <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Details page: Show a box with three add-on reviews.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["b9b6b6c59fed2dd3d8f4b83030ac8999", {"code_string": "def templates_list():\n    try:\n        return render(\n            node_templates = [nt.dict for nt in api.get_node_templates()])\n    except Exception, e:\n        abort_and_log(500, \"Exception while listing NodeTemplates\", e)\n", "code_toks_joined": "def templates_list ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return render ( <NEWLINE> <INDENT> node_templates = [ nt . dict for nt in api . get_node_templates ( ) ] ) <NEWLINE> <DEDENT> <DEDENT> except Exception , e : <NEWLINE> <INDENT> abort_and_log ( 500 , <STRING> , e ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Exception while listing NodeTemplates\""]}, "err_obj": {"msg": "invalid syntax"}}], ["630326438d303888849a0b1eec508e4f", {"code_string": "def read_file(file_name, dir = os.path.dirname(__file__):\n    file_path = os.path.join(dir, file_name)\n    with open(file_path) as fd:\n        return fd.read()\n", "code_toks_joined": "def read_file ( file_name , dir = os . path . dirname ( __file__ ) : <NEWLINE> <INDENT> file_path = os . path . join ( dir , file_name ) <NEWLINE> with open ( file_path ) as fd : <NEWLINE> <INDENT> return fd . read ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["1886b96e19dedac68cf319dfb02060c3", {"code_string": "def retranslateUi(self, SvnNewProjectOptionsDialog):\n    _translate = QtCore.QCoreApplication.translate\n    SvnNewProjectOptionsDialog.setWindowTitle(_translate(\"SvnNewProjectOptionsDialog\", \"New Project from Repository\"))\n    SvnNewProjectOptionsDialog.setWhatsThis(_translate(\"SvnNewProjectOptionsDialog\", \"<b>New Project from Repository Dialog</b>\\n\"\n", "code_toks_joined": "def retranslateUi ( self , SvnNewProjectOptionsDialog ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> SvnNewProjectOptionsDialog . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> SvnNewProjectOptionsDialog . setWhatsThis ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"SvnNewProjectOptionsDialog\"", "\"New Project from Repository\"", "\"SvnNewProjectOptionsDialog\"", "\"<b>New Project from Repository Dialog</b>\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["3ef3b6d4e5626cc3f0aa1427cbc4a76b", {"code_string": "def printxml(tree):\n    \"\"\"Helper function for debugging xml content\"\"\"\n    print(etree.tostring(tree, pretty_print(= True))\n    return\n", "code_toks_joined": "def printxml ( tree ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( etree . tostring ( tree , pretty_print ( = True ) ) <NEWLINE> return <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Helper function for debugging xml content\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["d55d4d1011606291fdae80fe0b32bbee", {"code_string": "def processHeader(self, msg):\n    '''process header line.'''\n    if msg.startswith(\"Content-Length\"):\n    self.contentlength = int(msg[len(\"Content-Length: \"): ])\n", "code_toks_joined": "def processHeader ( self , msg ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if msg . startswith ( <STRING> ) : <NEWLINE> self . contentlength = int ( msg [ len ( <STRING> ) : ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''process header line.'''", "\"Content-Length\"", "\"Content-Length: \""]}, "err_obj": {"msg": "expected an indented block"}}], ["94c03b9d544be2ec71c340a2f105732c", {"code_string": "def dump(record, fobj = sys.stdout):\n    \"\"\"Dump a human-readable text representation of a record to a file-like object.\"\"\"\n    for key, value in sorted(record.items():\n        if isinstance(key, tuple):\n            key = \"/\".join(key)\n        fobj.write(u\"%s: %s\\n\" %(key, value))\n    fobj.write(u\"\\n\")\n    fobj.flush()\n", "code_toks_joined": "def dump ( record , fobj = sys . stdout ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for key , value in sorted ( record . items ( ) : <NEWLINE> <INDENT> if isinstance ( key , tuple ) : <NEWLINE> <INDENT> key = <STRING> . join ( key ) <NEWLINE> <DEDENT> fobj . write ( <STRING> % ( key , value ) ) <NEWLINE> <DEDENT> fobj . write ( <STRING> ) <NEWLINE> fobj . flush ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Dump a human-readable text representation of a record to a file-like object.\"\"\"", "\"/\"", "u\"%s: %s\\n\"", "u\"\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["0a083f4329617dd7c7bf28cc92269ccc", {"code_string": "def test_FromHex(self):\n    print(\"==== Test Decoding from Hex Value ====\"\n    epc = self._giai96.encode(self._companyPrefix, None, self._itemRef, self._filter, None)\n    hex = epc.toHex()\n    epc = epc.fromHex(hex)\n    self._checkFields(epc)\n    print(epc.toHex())\n    print(epc.toBinary())\n    print(\"====END Test Decoding from Hex Value ====\"\n    print(\"\"\n", "code_toks_joined": "def test_FromHex ( self ) : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> epc = self . _giai96 . encode ( self . _companyPrefix , None , self . _itemRef , self . _filter , None ) <NEWLINE> hex = epc . toHex ( ) <NEWLINE> epc = epc . fromHex ( hex ) <NEWLINE> self . _checkFields ( epc ) <NEWLINE> print ( epc . toHex ( ) ) <NEWLINE> print ( epc . toBinary ( ) ) <NEWLINE> print ( <STRING> <NEWLINE> print ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"==== Test Decoding from Hex Value ====\"", "\"====END Test Decoding from Hex Value ====\"", "\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["ae28c1bb5778eefc25452c4f6e6cef4b", {"code_string": "def user_import_form(nodes = [], products = []):\n    return pyforms.Form(\n        pyforms.Dropdown(\"node_id\", description = u\"\u7528\u6237\u533a\u57df\", args = nodes, ** input_style),\n        pyforms.Dropdown(\"product_id\", args = products, description = u\"\u4e0a\u7f51\u8d44\u8d39\", required = \"required\", ** input_style),\n        pyforms.File(\"import_file\", description = u\"\u6570\u636e\u6587\u4ef6\", required = \"required\", ** input_style),\n        pyforms.Button(\"submit\", type = \"submit\", html = u\"<b>\u63d0\u4ea4</b>\", ** button_style),\n        title = u\"\u7528\u6237\u5bfc\u5165\",\n        action = \"/bus/member/import\"\n", "code_toks_joined": "def user_import_form ( nodes = [ ] , products = [ ] ) : <NEWLINE> <INDENT> return pyforms . Form ( <NEWLINE> <INDENT> pyforms . Dropdown ( <STRING> , description = <STRING> , args = nodes , ** input_style ) , <NEWLINE> pyforms . Dropdown ( <STRING> , args = products , description = <STRING> , required = <STRING> , ** input_style ) , <NEWLINE> pyforms . File ( <STRING> , description = <STRING> , required = <STRING> , ** input_style ) , <NEWLINE> pyforms . Button ( <STRING> , type = <STRING> , html = <STRING> , ** button_style ) , <NEWLINE> title = <STRING> , <NEWLINE> action = <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"node_id\"", "u\"\u7528\u6237\u533a\u57df\"", "\"product_id\"", "u\"\u4e0a\u7f51\u8d44\u8d39\"", "\"required\"", "\"import_file\"", "u\"\u6570\u636e\u6587\u4ef6\"", "\"required\"", "\"submit\"", "\"submit\"", "u\"<b>\u63d0\u4ea4</b>\"", "u\"\u7528\u6237\u5bfc\u5165\"", "\"/bus/member/import\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["085701af71b432e121659162b9b115a5", {"code_string": "def test_sauce(self):\n    el = self.driver.find_element_by_ios_uiautomation('.elements()[2]')\n    el.is_displayed()\n        action = TouchAction(self.driver)\n    action.tap(el).perform()\n", "code_toks_joined": "def test_sauce ( self ) : <NEWLINE> <INDENT> el = self . driver . find_element_by_ios_uiautomation ( <STRING> ) <NEWLINE> el . is_displayed ( ) <NEWLINE> <INDENT> action = TouchAction ( self . driver ) <NEWLINE> <DEDENT> action . tap ( el ) . perform ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'.elements()[2]'"]}, "err_obj": {"msg": "unexpected indent"}}], ["df063cf5c63021f0e6be6125ff64a484", {"code_string": "def copy(self, source, destination, error_on_failure = False):\n    \"\"\"Copies the item from the source to the destination\"\"\"\n    res = self._copy_on_client(source, destination)\n    if error_on_failure and not res.is_success():\n        error_message = 'Copy from \"{}\" to \"{}\" failed with:\\nerror: {}\\noutput: {}\\nexit code: {}'.format(\n            source,\n            destination,\n            res.raw_error\n            res.raw_output,\n            res.returncode,\n        )\n        raise RuntimeError(error_message)\n    else:\n        return res\n", "code_toks_joined": "def copy ( self , source , destination , error_on_failure = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> res = self . _copy_on_client ( source , destination ) <NEWLINE> if error_on_failure and not res . is_success ( ) : <NEWLINE> <INDENT> error_message = <STRING> . format ( <NEWLINE> <INDENT> source , <NEWLINE> destination , <NEWLINE> res . raw_error <NEWLINE> res . raw_output , <NEWLINE> res . returncode , <NEWLINE> <DEDENT> ) <NEWLINE> raise RuntimeError ( error_message ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return res <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Copies the item from the source to the destination\"\"\"", "'Copy from \"{}\" to \"{}\" failed with:\\nerror: {}\\noutput: {}\\nexit code: {}'"]}, "err_obj": {"msg": "invalid syntax"}}], ["806a8a0bf3b58f5f1facdb35d44327fa", {"code_string": "import sys\n_RTLD_GLOBAL = 0\ntry:\n    from dl import RTLD_GLOBAL as _RTLD_GLOBAL\nexcept ImportError:\n    try:\n    from DLFCN import RTLD_GLOBAL as _RTLD_GLOBAL\n    except ImportError:\n    pass\nif _RTLD_GLOBAL != 0:\n    _dlopenflags = sys.getdlopenflags()\n    sys.setdlopenflags(_dlopenflags | _RTLD_GLOBAL)\nfrom ieee802_11_swig import *\nif _RTLD_GLOBAL != 0:\n    sys.setdlopenflags(_dlopenflags)\n", "code_toks_joined": "import sys <NEWLINE> _RTLD_GLOBAL = 0 <NEWLINE> try : <NEWLINE> <INDENT> from dl import RTLD_GLOBAL as _RTLD_GLOBAL <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> try : <NEWLINE> from DLFCN import RTLD_GLOBAL as _RTLD_GLOBAL <NEWLINE> except ImportError : <NEWLINE> pass <NEWLINE> <DEDENT> if _RTLD_GLOBAL != 0 : <NEWLINE> <INDENT> _dlopenflags = sys . getdlopenflags ( ) <NEWLINE> sys . setdlopenflags ( _dlopenflags | _RTLD_GLOBAL ) <NEWLINE> <DEDENT> from ieee802_11_swig import * <NEWLINE> if _RTLD_GLOBAL != 0 : <NEWLINE> <INDENT> sys . setdlopenflags ( _dlopenflags ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["aed3cdecc765df516eb25cf4009dfda6", {"code_string": "\"\"\"********************************************************************************\"\"\"\nfrom sys import argv\nscript, filename = argv\ntxt = open(filename)\nprint(\"Here's your file %r: \" % filename)\nprint(txt.read()\nprint(\"Type the filename again: \")\nfile_again = raw_input(\"> \")\ntxt_again = open(file_again)\nprint(txt_again.read())\ntxt.close()\ntxt_again.close()\n", "code_toks_joined": "<STRING> <NEWLINE> from sys import argv <NEWLINE> script , filename = argv <NEWLINE> txt = open ( filename ) <NEWLINE> print ( <STRING> % filename ) <NEWLINE> print ( txt . read ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> file_again = raw_input ( <STRING> ) <NEWLINE> txt_again = open ( file_again ) <NEWLINE> print ( txt_again . read ( ) ) <NEWLINE> txt . close ( ) <NEWLINE> txt_again . close ( ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"\"\"********************************************************************************\"\"\"", "\"Here's your file %r: \"", "\"Type the filename again: \"", "\"> \""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["95c96c5d418dfb163329ab58e8bb5168", {"code_string": "import urllib, urllib2, sys, httplib\nif __name__ == '__main__':\n    connection = httplib.HTTPConnection('localhost:8080')\n        body_content = '<Keyspace name=\"fff\"/>'\n        headers = {\n            'Content-Type': 'application/xml; charset=utf-8',\n                'Accept': 'application/xml, multipart/related'\n                }\n        connection.request('POST', '/DaaS-0.1/api/m2m/keyspace', body = body_content, headers = headers)\n    result = connection.getresponse()\n        print(result)\n", "code_toks_joined": "import urllib , urllib2 , sys , httplib <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> connection = httplib . HTTPConnection ( <STRING> ) <NEWLINE> <INDENT> body_content = <STRING> <NEWLINE> headers = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> <NEWLINE> } <NEWLINE> <DEDENT> <DEDENT> connection . request ( <STRING> , <STRING> , body = body_content , headers = headers ) <NEWLINE> <DEDENT> result = connection . getresponse ( ) <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'__main__'", "'localhost:8080'", "'<Keyspace name=\"fff\"/>'", "'Content-Type'", "'application/xml; charset=utf-8'", "'Accept'", "'application/xml, multipart/related'", "'POST'", "'/DaaS-0.1/api/m2m/keyspace'"]}, "err_obj": {"msg": "unexpected indent"}}], ["8af4aadcf2325dd5bfbbc0eb0698d8a2", {"code_string": "def userEntryChanged(self, command):\n    try:\n        print(command)\n        exec command\n    except:\n        print(sys.exc_info())\n        print_tb(sys.exc_info()[2])\n    finally:\n        self.userEntry[\"focus\"] = True\n", "code_toks_joined": "def userEntryChanged ( self , command ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> print ( command ) <NEWLINE> exec command <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( sys . exc_info ( ) ) <NEWLINE> print_tb ( sys . exc_info ( ) [ 2 ] ) <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> self . userEntry [ <STRING> ] = True <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"focus\""]}, "err_obj": {"msg": "invalid syntax"}}], ["dda4abfdcddd7aef19ce5e03f5f700f0", {"code_string": "def retranslateUi(self, Dialog):\n    Dialog.setWindowTitle(_translate(\"Dialog\", \"Insert Point\", None))\n    self.label.setText(_translate(\"Dialog\", \"Enter the values of the point you want to insert. \\n\"\n", "code_toks_joined": "def retranslateUi ( self , Dialog ) : <NEWLINE> <INDENT> Dialog . setWindowTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label . setText ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Dialog\"", "\"Insert Point\"", "\"Dialog\"", "\"Enter the values of the point you want to insert. \\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["025be6b911d8832251865424fd05aab7", {"code_string": "def is_accession_for_server(instance):\n    from.server_defaults import(\n        ACCESSION_FACTORY,\n        test_accession,\n        ,\n    )\n    if accession_re.match(instance):\n        return True\n    request = get_current_request()\n    if request.registry[ACCESSION_FACTORY] is test_accession:\n        if test_accession_re.match(instance):\n            return True\n    return False\n", "code_toks_joined": "def is_accession_for_server ( instance ) : <NEWLINE> <INDENT> from . server_defaults import ( <NEWLINE> <INDENT> ACCESSION_FACTORY , <NEWLINE> test_accession , <NEWLINE> , <NEWLINE> <DEDENT> ) <NEWLINE> if accession_re . match ( instance ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> request = get_current_request ( ) <NEWLINE> if request . registry [ ACCESSION_FACTORY ] is test_accession : <NEWLINE> <INDENT> if test_accession_re . match ( instance ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["ef48a9d1bf219781aa932c4a5935c3e7", {"code_string": "class AdjuntoForm(forms.ModelForm):\n    class Meta:\n    model = Documentos\n    exclude = ('content_type', 'object_id', 'content_object', )\n", "code_toks_joined": "class AdjuntoForm ( forms . ModelForm ) : <NEWLINE> <INDENT> class Meta : <NEWLINE> model = Documentos <NEWLINE> exclude = ( <STRING> , <STRING> , <STRING> , ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'content_type'", "'object_id'", "'content_object'"]}, "err_obj": {"msg": "expected an indented block"}}], ["ba6b1e9ae33e872abda343dc018f4e2a", {"code_string": "def get_all_logged_in_users():\n    uid_list = []\n        data = session.get_decoded()\n        uid_list.append(data.get('_auth_user_id', None))\n", "code_toks_joined": "def get_all_logged_in_users ( ) : <NEWLINE> <INDENT> uid_list = [ ] <NEWLINE> <INDENT> data = session . get_decoded ( ) <NEWLINE> uid_list . append ( data . get ( <STRING> , None ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'_auth_user_id'"]}, "err_obj": {"msg": "unexpected indent"}}], ["3f3227141320a30d53446521617a1b69", {"code_string": "def accept_invitation(self, invite_id, member_id, credentials, options):\n    with MethodContext(self, SA_LOG_PREFIX, 'accept_invitation',\n        {'invite_id': invite_id, 'member_id': member_id},\n        credentials, options, read_only = False) as mc:\n        if not mc._error:\n        mc._result = self._delegate.accept_invitation(mc._client_cert,\n            invite_id,\n            member_id,\n            credentials,\n            options,\n            mc._session)\n    return mc._result\n", "code_toks_joined": "def accept_invitation ( self , invite_id , member_id , credentials , options ) : <NEWLINE> <INDENT> with MethodContext ( self , SA_LOG_PREFIX , <STRING> , <NEWLINE> <INDENT> { <STRING> : invite_id , <STRING> : member_id } , <NEWLINE> credentials , options , read_only = False ) as mc : <NEWLINE> if not mc . _error : <NEWLINE> mc . _result = self . _delegate . accept_invitation ( mc . _client_cert , <NEWLINE> <INDENT> invite_id , <NEWLINE> member_id , <NEWLINE> credentials , <NEWLINE> options , <NEWLINE> mc . _session ) <NEWLINE> <DEDENT> <DEDENT> return mc . _result <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'accept_invitation'", "'invite_id'", "'member_id'"]}, "err_obj": {"msg": "expected an indented block"}}], ["06de719a2e409515f56eaafdb5b8d01c", {"code_string": "def add_lines(self, paragraphs):\n    for paragraph in paragraphs:\n    del self.buffer[0]\n        self.buffer.append(paragraph)\n        if self.offset > 0:\n        self.offset = self.offset + 1\n        if self.offset > self.scrollback - self.numlines:\n    self.offset = self.scrollback - self.numlines\n    return self.render()\n", "code_toks_joined": "def add_lines ( self , paragraphs ) : <NEWLINE> <INDENT> for paragraph in paragraphs : <NEWLINE> del self . buffer [ 0 ] <NEWLINE> <INDENT> self . buffer . append ( paragraph ) <NEWLINE> if self . offset > 0 : <NEWLINE> self . offset = self . offset + 1 <NEWLINE> if self . offset > self . scrollback - self . numlines : <NEWLINE> <DEDENT> self . offset = self . scrollback - self . numlines <NEWLINE> return self . render ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["49a4bb77c325629091f1b3a96d848053", {"code_string": "def nextprime(number):\n    \"This function will find the smallest prime larger than the current number\"\n    potential = number\n    j = 3\n    while j <= sqrt(potential):\n        if potential % j:\n        j = j + 2\n        else:\n        potential = potential + 2\n        j = 3\n        continue\n    return potential\n", "code_toks_joined": "def nextprime ( number ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> potential = number <NEWLINE> j = 3 <NEWLINE> while j <= sqrt ( potential ) : <NEWLINE> <INDENT> if potential % j : <NEWLINE> j = j + 2 <NEWLINE> else : <NEWLINE> potential = potential + 2 <NEWLINE> j = 3 <NEWLINE> continue <NEWLINE> <DEDENT> return potential <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"This function will find the smallest prime larger than the current number\""]}, "err_obj": {"msg": "expected an indented block"}}], ["f7ea7c9f3a20592520cb188a28c03215", {"code_string": "def saveCustomDefinitions(self, fileobj):\n    \"\"\"Save custom constants and functions.\"\"\"\n    for ctype, defns in(\n        ('import', self.def_imports),\n        ('definition', self.def_definitions),\n        ('color', self.def_colors),\n        ('colormap', self.def_colormaps)):\n        for val in defns:\n        fileobj.write(\n            'AddCustom(%s, %s, %s)\\n' %(\n                repr(ctype), repr(val[0]), repr(val[1])))\n", "code_toks_joined": "def saveCustomDefinitions ( self , fileobj ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for ctype , defns in ( <NEWLINE> <INDENT> ( <STRING> , self . def_imports ) , <NEWLINE> ( <STRING> , self . def_definitions ) , <NEWLINE> ( <STRING> , self . def_colors ) , <NEWLINE> ( <STRING> , self . def_colormaps ) ) : <NEWLINE> for val in defns : <NEWLINE> fileobj . write ( <NEWLINE> <INDENT> <STRING> % ( <NEWLINE> <INDENT> repr ( ctype ) , repr ( val [ 0 ] ) , repr ( val [ 1 ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Save custom constants and functions.\"\"\"", "'import'", "'definition'", "'color'", "'colormap'", "'AddCustom(%s, %s, %s)\\n'"]}, "err_obj": {"msg": "expected an indented block"}}], ["abcb51f657f3dc02a833804ed30fef53", {"code_string": "def update_watched(self, account_id, watched):\n    local_db_watched = self.get_watched_by(account_id)\n    if watched is None:\n        watched = set()\n    watched = set(watched)\n    in_cloud_but_not_in_local_db = watched - local_db_watched\n    print(\"Found \" + str(len(in_cloud_but_not_in_local_db)) + \" items not in local db for accound_id \" + str(\n        account_id))\n    select_item_sql = \"SELECT * FROM metadata_items WHERE guid = ?\"\n    select_sql = \"SELECT view_count FROM metadata_item_settings WHERE account_id = ? AND guid = ?\"\n    insert_sql = \"INSERT INTO metadata_item_settings (account_id, guid, view_count, last_viewed_at, created_at, updated_at, skip_count) VALUES (?, ?, ?, ?, ?, ?, ?)\"\n    update_sql = \"UPDATE metadata_item_settings SET view_count = 1, last_viewed_at = ? WHERE account_id = ? AND guid = ?\"\n    cur = self.connection.cursor()\n    inserted = 0\n    updated = 0\n    skipped = 0\n    for watch_id in in_cloud_but_not_in_local_db:\n        cur.execute(select_item_sql, (watch_id, ))\n        if cur.fetchone() is None:\n            skipped += 1\n            continue\n        cur.execute(select_sql, (account_id, watch_id, ))\n        row = cur.fetchone()\n        now = time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime())\n        if row is None:\n            cur.execute(insert_sql, (account_id, watch_id, 1, now, now, now, 0, ))\n            self.connection.commit()\n            inserted += 1\n        else:\n            cur.execute(update_sql, (now, account_id, watch_id, ))\n            self.connection.commit()\n            updated += 1\n    print(\"Skipped \" + str(skipped) + \", inserted \" + str(inserted) + \", updated \" + str(\n        updated) + \" items for account_id \" + str(account_id) + \" in local db\"\n", "code_toks_joined": "def update_watched ( self , account_id , watched ) : <NEWLINE> <INDENT> local_db_watched = self . get_watched_by ( account_id ) <NEWLINE> if watched is None : <NEWLINE> <INDENT> watched = set ( ) <NEWLINE> <DEDENT> watched = set ( watched ) <NEWLINE> in_cloud_but_not_in_local_db = watched - local_db_watched <NEWLINE> print ( <STRING> + str ( len ( in_cloud_but_not_in_local_db ) ) + <STRING> + str ( <NEWLINE> <INDENT> account_id ) ) <NEWLINE> <DEDENT> select_item_sql = <STRING> <NEWLINE> select_sql = <STRING> <NEWLINE> insert_sql = <STRING> <NEWLINE> update_sql = <STRING> <NEWLINE> cur = self . connection . cursor ( ) <NEWLINE> inserted = 0 <NEWLINE> updated = 0 <NEWLINE> skipped = 0 <NEWLINE> for watch_id in in_cloud_but_not_in_local_db : <NEWLINE> <INDENT> cur . execute ( select_item_sql , ( watch_id , ) ) <NEWLINE> if cur . fetchone ( ) is None : <NEWLINE> <INDENT> skipped += 1 <NEWLINE> continue <NEWLINE> <DEDENT> cur . execute ( select_sql , ( account_id , watch_id , ) ) <NEWLINE> row = cur . fetchone ( ) <NEWLINE> now = time . strftime ( <STRING> , time . localtime ( ) ) <NEWLINE> if row is None : <NEWLINE> <INDENT> cur . execute ( insert_sql , ( account_id , watch_id , 1 , now , now , now , 0 , ) ) <NEWLINE> self . connection . commit ( ) <NEWLINE> inserted += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cur . execute ( update_sql , ( now , account_id , watch_id , ) ) <NEWLINE> self . connection . commit ( ) <NEWLINE> updated += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + str ( skipped ) + <STRING> + str ( inserted ) + <STRING> + str ( <NEWLINE> <INDENT> updated ) + <STRING> + str ( account_id ) + <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Found \"", "\" items not in local db for accound_id \"", "\"SELECT * FROM metadata_items WHERE guid = ?\"", "\"SELECT view_count FROM metadata_item_settings WHERE account_id = ? AND guid = ?\"", "\"INSERT INTO metadata_item_settings (account_id, guid, view_count, last_viewed_at, created_at, updated_at, skip_count) VALUES (?, ?, ?, ?, ?, ?, ?)\"", "\"UPDATE metadata_item_settings SET view_count = 1, last_viewed_at = ? WHERE account_id = ? AND guid = ?\"", "\"%Y-%m-%d %H:%M:%S\"", "\"Skipped \"", "\", inserted \"", "\", updated \"", "\" items for account_id \"", "\" in local db\""]}, "window_span": [262, 297], "err_obj": {"msg": "unbalanced (){}[]"}}], ["87cdb3bed38d7243da54f0750385d989", {"code_string": "def editor_saved(self, user, old_metadata, old_content):\n    \"\"\"If source_library_id or capa_type has been edited, refresh_children automatically.\"\"\"\n    old_source_library_id = old_metadata.get('source_library_id', [])\n    if(old_source_library_id != self.source_library_id or\n        old_metadata.get('capa_type', ANY_CAPA_TYPE_VALUE) != self.capa_type):\n        try:\n        self.refresh_children()\n        except ValueError:\n        pass\n", "code_toks_joined": "def editor_saved ( self , user , old_metadata , old_content ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> old_source_library_id = old_metadata . get ( <STRING> , [ ] ) <NEWLINE> if ( old_source_library_id != self . source_library_id or <NEWLINE> <INDENT> old_metadata . get ( <STRING> , ANY_CAPA_TYPE_VALUE ) != self . capa_type ) : <NEWLINE> try : <NEWLINE> self . refresh_children ( ) <NEWLINE> except ValueError : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"If source_library_id or capa_type has been edited, refresh_children automatically.\"\"\"", "'source_library_id'", "'capa_type'"]}, "err_obj": {"msg": "expected an indented block"}}], ["e49d7df0198c2fb19211de814adf91a7", {"code_string": "def parse(self, _in):\n    \"\"\"parses the xml input\"\"\"\n        xml.sax.parseString(_in, self)\n        return self.env\n", "code_toks_joined": "def parse ( self , _in ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> xml . sax . parseString ( _in , self ) <NEWLINE> return self . env <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"parses the xml input\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["405236fc6550679f7211130bf400010d", {"code_string": "from bs4 import BeautifulSoup\nfrom datetime import date\nimport os.path as path\nimport sys\n_SRC = path.join(path.dirname(path.abspath(__file__)), \"..\", \"..\")\n_COMPILE_JS = path.join(\n    _SRC, \"third_party\", \"closure_compiler\", \"compile_js2.gypi\")\n_POLYMERS = [\"polymer%s.html\" % p for p in \"\", \"-mini\", \"-micro\"]\n_WEB_ANIMATIONS_BASE = \"web-animations.html\"\n_WEB_ANIMATIONS_TARGET = \"<(EXTERNS_GYP):web_animations\"\n_COMPILED_RESOURCES_TEMPLATE = \"\"\"{'targets': [\"\"\".strip()\n", "code_toks_joined": "from bs4 import BeautifulSoup <NEWLINE> from datetime import date <NEWLINE> import os . path as path <NEWLINE> import sys <NEWLINE> _SRC = path . join ( path . dirname ( path . abspath ( __file__ ) ) , <STRING> , <STRING> ) <NEWLINE> _COMPILE_JS = path . join ( <NEWLINE> <INDENT> _SRC , <STRING> , <STRING> , <STRING> ) <NEWLINE> <DEDENT> _POLYMERS = [ <STRING> % p for p in <STRING> , <STRING> , <STRING> ] <NEWLINE> _WEB_ANIMATIONS_BASE = <STRING> <NEWLINE> _WEB_ANIMATIONS_TARGET = <STRING> <NEWLINE> _COMPILED_RESOURCES_TEMPLATE = <STRING> . strip ( ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"..\"", "\"..\"", "\"third_party\"", "\"closure_compiler\"", "\"compile_js2.gypi\"", "\"polymer%s.html\"", "\"\"", "\"-mini\"", "\"-micro\"", "\"web-animations.html\"", "\"<(EXTERNS_GYP):web_animations\"", "\"\"\"{'targets': [\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["60790ab993b6db4054fd508fc7eee4cf", {"code_string": "def chunk(sequence, size):\n    \"\"\"Yield a sequence of chunks from sequence.\"\"\"\n    for(_, pairs) in itertools.groupby(enumerate(sequence), lambda(i, _): i / size):\n        yield(v for(_, v) in pairs)\n", "code_toks_joined": "def chunk ( sequence , size ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for ( _ , pairs ) in itertools . groupby ( enumerate ( sequence ) , lambda ( i , _ ) : i / size ) : <NEWLINE> <INDENT> yield ( v for ( _ , v ) in pairs ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Yield a sequence of chunks from sequence.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["3b0ad30eeb09265424247dc1793507a6", {"code_string": "def newsletters(self):\n    newsletters = ['ambassadors']\n    for newsletter in['nl_mozilla_and_you', 'nl_mobile',\n        'nl_firefox_flicks', 'nl_about_mozilla']:\n        if self.cleaned_data.get(newsletter, False):\n        newsletters.append(newsletter[3: ].replace('_', '-'))\n    return newsletters\n", "code_toks_joined": "def newsletters ( self ) : <NEWLINE> <INDENT> newsletters = [ <STRING> ] <NEWLINE> for newsletter in [ <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> ] : <NEWLINE> if self . cleaned_data . get ( newsletter , False ) : <NEWLINE> newsletters . append ( newsletter [ 3 : ] . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT> return newsletters <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'ambassadors'", "'nl_mozilla_and_you'", "'nl_mobile'", "'nl_firefox_flicks'", "'nl_about_mozilla'", "'_'", "'-'"]}, "err_obj": {"msg": "expected an indented block"}}], ["09b61bd97ea377fc6d205aa2952dfa78", {"code_string": "def isGod(self, nickname, host):\n    XMLHandler = serviceXML()\n    XMLParser = xml.sax.make_parser()\n    XMLParser.setContentHandler(XMLHandler)\n    XMLParser.parse(self.servicesFile)\n    for reg in XMLHandler.getGodList():\n    if reg[0] == 'nickname':\n        if re.search(reg[1], nickname) != None:\n        return True\n        elif reg[0] == 'host':\n        if re.search(reg[1], host) != None:\n        return True\n        return False\n", "code_toks_joined": "def isGod ( self , nickname , host ) : <NEWLINE> <INDENT> XMLHandler = serviceXML ( ) <NEWLINE> XMLParser = xml . sax . make_parser ( ) <NEWLINE> XMLParser . setContentHandler ( XMLHandler ) <NEWLINE> XMLParser . parse ( self . servicesFile ) <NEWLINE> for reg in XMLHandler . getGodList ( ) : <NEWLINE> if reg [ 0 ] == <STRING> : <NEWLINE> <INDENT> if re . search ( reg [ 1 ] , nickname ) != None : <NEWLINE> return True <NEWLINE> elif reg [ 0 ] == <STRING> : <NEWLINE> if re . search ( reg [ 1 ] , host ) != None : <NEWLINE> return True <NEWLINE> return False <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'nickname'", "'host'"]}, "err_obj": {"msg": "expected an indented block"}}], ["4acd6d7604ded734df871aec6ca60a92", {"code_string": "def zip_files(self):\n    file = zipfile.ZipFile(self.zipname, , 'w')\n    for filename in os.listdir(self.temp_directory):\n        file.write(self._full_filename(filename), filename)\n    shutil.rmtree(self.temp_directory)\n", "code_toks_joined": "def zip_files ( self ) : <NEWLINE> <INDENT> file = zipfile . ZipFile ( self . zipname , , <STRING> ) <NEWLINE> for filename in os . listdir ( self . temp_directory ) : <NEWLINE> <INDENT> file . write ( self . _full_filename ( filename ) , filename ) <NEWLINE> <DEDENT> shutil . rmtree ( self . temp_directory ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'w'"]}, "err_obj": {"msg": "invalid syntax"}}], ["3805ec579f14c994824e2dfe88845106", {"code_string": "def _handleMuxers(self):\n    for muxerName, components in[('audio', [self._audioEncoder]),\n        ('video', [self._videoEncoder]),\n        ('audio-video', [self._audioEncoder,\n            self._videoEncoder])]:\n            muxer = self._getMuxer(muxerName)\n            if muxer.feeders:\n            self._flowComponents.append(muxer)\n            for component in components:\n            component and component.link(muxer)\n", "code_toks_joined": "def _handleMuxers ( self ) : <NEWLINE> <INDENT> for muxerName , components in [ ( <STRING> , [ self . _audioEncoder ] ) , <NEWLINE> <INDENT> ( <STRING> , [ self . _videoEncoder ] ) , <NEWLINE> ( <STRING> , [ self . _audioEncoder , <NEWLINE> <INDENT> self . _videoEncoder ] ) ] : <NEWLINE> muxer = self . _getMuxer ( muxerName ) <NEWLINE> if muxer . feeders : <NEWLINE> self . _flowComponents . append ( muxer ) <NEWLINE> for component in components : <NEWLINE> component and component . link ( muxer ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'audio'", "'video'", "'audio-video'"]}, "err_obj": {"msg": "expected an indented block"}}], ["e0d250cc0118d8735dd908630f82ea05", {"code_string": "import sys\nPATH_INSTALL = \"./libelsign\"\nsys.path.append(PATH_INSTALL)\nfrom libelsign import libelsign\nSIGNS = [\n    [\"Sign1\", \"a\",\n        [[4.4915299415588379, 4.9674844741821289,\n            4.9468302726745605, 0.0], \"HELLO WORLDDDDDDDDDDDDDDDDDDDDDDD\"]],\n    [\"Sign2\", \"a && b\",\n        [[2.0, 3.0, 4.0, 5.0], \"OOOPS !!!!!!!!\"], [[2.0, 3.0, 4.0, 8.0], \"OOOOOOOOPPPPPS !!!\"]],\n]\nHSIGNS = {}\nELEMS = [\n    [[4.4915299415588379, 4.9674844741821289, 4.9468302726745605, 1.0], \"FALSE POSITIVE\"],\n    [[2.0, 3.0, 4.0, 5.0], \"HELLO WORLDDDDDDDDDDDDDDDDDDDDDDD\"],\n    [[2.0, 3.0, 4.0, 5.0], \"HELLO WORLDDDDDDDDDDDDDDDDDDDDDDD\"],\n    [[2.0, 3.0, 4.0, 5.0], \"HELLO WORLDDDDDDDDDDDDDDDDDDDDDDD\"],\n    [[2.0, 3.0, 4.0, 5.0], \"HELLO WORLDDDDDDDDDDDDDDDDDDDDDDD\"],\n]\nHELEMS = {}\nes = libelsign.Elsign()\nes.set_debug_log(1)\nes.set_distance('e')\nes.set_method('m')\nes.set_weight([2.0, 1.2, 0.5, 0.1, 0.6])\nes.set_sim_method(0)\nes.set_threshold_low(0.3)\nes.set_threshold_high(0.4)\nes.set_ncd_compression_algorithm(5)\nfor i in range(0, len(SIGNS)):\n    id = es.add_signature(SIGNS[i][0], SIGNS[i][1], SIGNS[i][2: ])\n    print(SIGNS[i], id)\n    HSIGNS[id] = i\nfor i in range(0, len(ELEMS)):\n    id = es.add_element(ELEMS[i][1], ELEMS[i][0])\n    print(ELEMS[i], id)\n    HELEMS[id] = i\nprint(es.check())\ndt = es.get_debug()\ndebug_nb_sign = dt[0]\ndebug_nb_clusters = dt[1]\ndebug_nb_cmp_clusters = dt[2]\ndebug_nb_elements = dt[3]\ndebug_nb_cmp_elements = dt[4]\ndebug_nb_cmp_max = debug_nb_sign * debug_nb_elements\nprint(\"[SIGN:%d CLUSTERS:%d CMP_CLUSTERS:%d ELEMENTS:%d CMP_ELEMENTS:%d\" %(debug_nb_sign, debug_nb_clusters, debug_nb_cmp_clusters, debug_nb_elements, debug_nb_cmp_elements),\nprint(\"-> %d %f%%]\" %(debug_nb_cmp_max, ((debug_nb_cmp_elements / float(debug_nb_cmp_max)) * 100)))\n", "code_toks_joined": "import sys <NEWLINE> PATH_INSTALL = <STRING> <NEWLINE> sys . path . append ( PATH_INSTALL ) <NEWLINE> from libelsign import libelsign <NEWLINE> SIGNS = [ <NEWLINE> <INDENT> [ <STRING> , <STRING> , <NEWLINE> <INDENT> [ [ 4.4915299415588379 , 4.9674844741821289 , <NEWLINE> <INDENT> 4.9468302726745605 , 0.0 ] , <STRING> ] ] , <NEWLINE> <DEDENT> <DEDENT> [ <STRING> , <STRING> , <NEWLINE> <INDENT> [ [ 2.0 , 3.0 , 4.0 , 5.0 ] , <STRING> ] , [ [ 2.0 , 3.0 , 4.0 , 8.0 ] , <STRING> ] ] , <NEWLINE> <DEDENT> <DEDENT> ] <NEWLINE> HSIGNS = { } <NEWLINE> ELEMS = [ <NEWLINE> <INDENT> [ [ 4.4915299415588379 , 4.9674844741821289 , 4.9468302726745605 , 1.0 ] , <STRING> ] , <NEWLINE> [ [ 2.0 , 3.0 , 4.0 , 5.0 ] , <STRING> ] , <NEWLINE> [ [ 2.0 , 3.0 , 4.0 , 5.0 ] , <STRING> ] , <NEWLINE> [ [ 2.0 , 3.0 , 4.0 , 5.0 ] , <STRING> ] , <NEWLINE> [ [ 2.0 , 3.0 , 4.0 , 5.0 ] , <STRING> ] , <NEWLINE> <DEDENT> ] <NEWLINE> HELEMS = { } <NEWLINE> es = libelsign . Elsign ( ) <NEWLINE> es . set_debug_log ( 1 ) <NEWLINE> es . set_distance ( <STRING> ) <NEWLINE> es . set_method ( <STRING> ) <NEWLINE> es . set_weight ( [ 2.0 , 1.2 , 0.5 , 0.1 , 0.6 ] ) <NEWLINE> es . set_sim_method ( 0 ) <NEWLINE> es . set_threshold_low ( 0.3 ) <NEWLINE> es . set_threshold_high ( 0.4 ) <NEWLINE> es . set_ncd_compression_algorithm ( 5 ) <NEWLINE> for i in range ( 0 , len ( SIGNS ) ) : <NEWLINE> <INDENT> id = es . add_signature ( SIGNS [ i ] [ 0 ] , SIGNS [ i ] [ 1 ] , SIGNS [ i ] [ 2 : ] ) <NEWLINE> print ( SIGNS [ i ] , id ) <NEWLINE> HSIGNS [ id ] = i <NEWLINE> <DEDENT> for i in range ( 0 , len ( ELEMS ) ) : <NEWLINE> <INDENT> id = es . add_element ( ELEMS [ i ] [ 1 ] , ELEMS [ i ] [ 0 ] ) <NEWLINE> print ( ELEMS [ i ] , id ) <NEWLINE> HELEMS [ id ] = i <NEWLINE> <DEDENT> print ( es . check ( ) ) <NEWLINE> dt = es . get_debug ( ) <NEWLINE> debug_nb_sign = dt [ 0 ] <NEWLINE> debug_nb_clusters = dt [ 1 ] <NEWLINE> debug_nb_cmp_clusters = dt [ 2 ] <NEWLINE> debug_nb_elements = dt [ 3 ] <NEWLINE> debug_nb_cmp_elements = dt [ 4 ] <NEWLINE> debug_nb_cmp_max = debug_nb_sign * debug_nb_elements <NEWLINE> print ( <STRING> % ( debug_nb_sign , debug_nb_clusters , debug_nb_cmp_clusters , debug_nb_elements , debug_nb_cmp_elements ) , <NEWLINE> print ( <STRING> % ( debug_nb_cmp_max , ( ( debug_nb_cmp_elements / float ( debug_nb_cmp_max ) ) * 100 ) ) ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"./libelsign\"", "\"Sign1\"", "\"a\"", "\"HELLO WORLDDDDDDDDDDDDDDDDDDDDDDD\"", "\"Sign2\"", "\"a && b\"", "\"OOOPS !!!!!!!!\"", "\"OOOOOOOOPPPPPS !!!\"", "\"FALSE POSITIVE\"", "\"HELLO WORLDDDDDDDDDDDDDDDDDDDDDDD\"", "\"HELLO WORLDDDDDDDDDDDDDDDDDDDDDDD\"", "\"HELLO WORLDDDDDDDDDDDDDDDDDDDDDDD\"", "\"HELLO WORLDDDDDDDDDDDDDDDDDDDDDDD\"", "'e'", "'m'", "\"[SIGN:%d CLUSTERS:%d CMP_CLUSTERS:%d ELEMENTS:%d CMP_ELEMENTS:%d\"", "\"-> %d %f%%]\""]}, "window_span": [441, 479], "err_obj": {"msg": "unbalanced (){}[]"}}], ["9429ec8f541f16fbd6d6ec211240fab2", {"code_string": "def drawCloud(tags: list, filename: str, fontname: str = 'D2Coding', size = (1920, 1080))):\n    pytagcloud.create_tag_image(tags, filename, fontname = fontname, size = size)\n    webbrowser.open(filename)\n", "code_toks_joined": "def drawCloud ( tags : list , filename : str , fontname : str = <STRING> , size = ( 1920 , 1080 ) ) ) : <NEWLINE> <INDENT> pytagcloud . create_tag_image ( tags , filename , fontname = fontname , size = size ) <NEWLINE> webbrowser . open ( filename ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'D2Coding'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["02e72ee646308a58658be8155e14eeb6", {"code_string": "def get_any(self, value):\n    \"\"\"Get the pattern for __any operator\"\"\"\n    if not isinstance(value, (list, tuple)):\n        raise ValueError, \"__any requires a list or tuple\"\n    return self.operator(\"&&\", value)\n", "code_toks_joined": "def get_any ( self , value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not isinstance ( value , ( list , tuple ) ) : <NEWLINE> <INDENT> raise ValueError , <STRING> <NEWLINE> <DEDENT> return self . operator ( <STRING> , value ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get the pattern for __any operator\"\"\"", "\"__any requires a list or tuple\"", "\"&&\""]}, "err_obj": {"msg": "invalid syntax"}}], ["4ab45a9e27bc25a8b063583d9a3cfcf6", {"code_string": "def create(self, name, instance_dir = None, config = 'solrcofig.xml', schema = 'schema.xml'):\n    \"\"\"http://wiki.apache.org/solr/CoreAdmin#head-7ca1b98a9df8b8ca0dcfbfc49940ed5ac98c4a08\"\"\"\n    params = {\n        'action': 'STATUS',\n        'name': name,\n        'config': config,\n        'schema': schema,\n        ,\n    }\n    if instance_dir is None:\n        params.update(instanceDir = name)\n    else:\n        params.update(instanceDir = instance_dir)\n    return self._get_url(self.url, params = params)\n", "code_toks_joined": "def create ( self , name , instance_dir = None , config = <STRING> , schema = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> params = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : name , <NEWLINE> <STRING> : config , <NEWLINE> <STRING> : schema , <NEWLINE> , <NEWLINE> <DEDENT> } <NEWLINE> if instance_dir is None : <NEWLINE> <INDENT> params . update ( instanceDir = name ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> params . update ( instanceDir = instance_dir ) <NEWLINE> <DEDENT> return self . _get_url ( self . url , params = params ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'solrcofig.xml'", "'schema.xml'", "\"\"\"http://wiki.apache.org/solr/CoreAdmin#head-7ca1b98a9df8b8ca0dcfbfc49940ed5ac98c4a08\"\"\"", "'action'", "'STATUS'", "'name'", "'config'", "'schema'"]}, "err_obj": {"msg": "invalid syntax"}}], ["9f5eac1caa53bc746827324a53a45d81", {"code_string": "def CATEGORIES(url, value):\n    if(dbg): print url\n    data = getUrl(url)\n    for(href, title) in re.findall('<li>[^<]*<a[^>]*href=\"([^\"]+' + value + '-online[^\"]+)\"[^>]*><strong>([^<]+)</strong>', data, re.S | re.I):\n        if(dbg):\n            print href, title\n        addDir(clean(title), href, 1, '', True)\n    if forceViewMode: xbmc.executebuiltin(\"Container.SetViewMode(\" + viewMode + \")\")\n", "code_toks_joined": "def CATEGORIES ( url , value ) : <NEWLINE> <INDENT> if ( dbg ) : print url <NEWLINE> data = getUrl ( url ) <NEWLINE> for ( href , title ) in re . findall ( <STRING> + value + <STRING> , data , re . S | re . I ) : <NEWLINE> <INDENT> if ( dbg ) : <NEWLINE> <INDENT> print href , title <NEWLINE> <DEDENT> addDir ( clean ( title ) , href , 1 , <STRING> , True ) <NEWLINE> <DEDENT> if forceViewMode : xbmc . executebuiltin ( <STRING> + viewMode + <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'<li>[^<]*<a[^>]*href=\"([^\"]+'", "'-online[^\"]+)\"[^>]*><strong>([^<]+)</strong>'", "''", "\"Container.SetViewMode(\"", "\")\""]}, "err_obj": {"msg": "invalid syntax"}}], ["7ec0f9ec0968fa452f2f4cb8dbac14cb", {"code_string": "def check_merkle_branch(tip_hash, index, merkle_branch):\n    return reduce(lambda c, (i, h): hash256(merkle_record_type.pack(\n        dict(left = h, right = c) if 2 ** i & index else\n        dict(left = c, right = h)\n    )), enumerate(merkle_branch), tip_hash)\n", "code_toks_joined": "def check_merkle_branch ( tip_hash , index , merkle_branch ) : <NEWLINE> <INDENT> return reduce ( lambda c , ( i , h ) : hash256 ( merkle_record_type . pack ( <NEWLINE> <INDENT> dict ( left = h , right = c ) if 2 ** i & index else <NEWLINE> dict ( left = c , right = h ) <NEWLINE> <DEDENT> ) ) , enumerate ( merkle_branch ) , tip_hash ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["296778ae4ef4eb1649ba069ae21f2e39", {"code_string": "class GameFactory(object):\n    \"\"\"Class to encapsulate game modules into an object.\"\"\"\n    def __init__(self, game_type):\n        \"\"\"Initiates a Game class. If it fails, it raises ImportError.\"\"\"\n        self.result = False\n        module_name = \"PTTGame_%s\" % game_type\n        exec \"from pttgames.%s import %s\" %(game_type, module_name)\n        exec \"self.result = %s()\" % module_name\n", "code_toks_joined": "class GameFactory ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , game_type ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . result = False <NEWLINE> module_name = <STRING> % game_type <NEWLINE> exec <STRING> % ( game_type , module_name ) <NEWLINE> exec <STRING> % module_name <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Class to encapsulate game modules into an object.\"\"\"", "\"\"\"Initiates a Game class. If it fails, it raises ImportError.\"\"\"", "\"PTTGame_%s\"", "\"from pttgames.%s import %s\"", "\"self.result = %s()\""]}, "err_obj": {"msg": "invalid syntax"}}], ["5c4dc534dd76f83c86ac8c9f75791f5a", {"code_string": "def is_move_valid(self, player, move):\n    if move_beside_valid_piece(player, move):\n        if check_line_end_in_same_color(player, move)\n            return True\n    return False\n", "code_toks_joined": "def is_move_valid ( self , player , move ) : <NEWLINE> <INDENT> if move_beside_valid_piece ( player , move ) : <NEWLINE> <INDENT> if check_line_end_in_same_color ( player , move ) <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["8e1d792556ec638be5f65c1eb46742f9", {"code_string": "from telemetry.core.backends import form_based_credentials_backend_unittest_base\nfrom telemetry.core.backends import facebook_credentials_backend\nclass TestFacebookCredentialsBackend(\n    form_based_credentials_backend_unittest_base.\n    FormBasedCredentialsBackendUnitTestBase):\n    def setUp(self):\n    self._credentials_type = 'facebook'\n    def testLoginUsingMock(self):\n    self._LoginUsingMock(\n        facebook_credentials_backend.FacebookCredentialsBackend(),\n        'http://www.facebook.com/', 'email', 'pass')\n", "code_toks_joined": "from telemetry . core . backends import form_based_credentials_backend_unittest_base <NEWLINE> from telemetry . core . backends import facebook_credentials_backend <NEWLINE> class TestFacebookCredentialsBackend ( <NEWLINE> <INDENT> form_based_credentials_backend_unittest_base . <NEWLINE> FormBasedCredentialsBackendUnitTestBase ) : <NEWLINE> def setUp ( self ) : <NEWLINE> self . _credentials_type = <STRING> <NEWLINE> def testLoginUsingMock ( self ) : <NEWLINE> self . _LoginUsingMock ( <NEWLINE> <INDENT> facebook_credentials_backend . FacebookCredentialsBackend ( ) , <NEWLINE> <STRING> , <STRING> , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'facebook'", "'http://www.facebook.com/'", "'email'", "'pass'"]}, "err_obj": {"msg": "expected an indented block"}}], ["4ae476e6f6fb24a82b63c15ee637c823", {"code_string": "def custom_fetch(self, inputs, fetch_layers):\n    feed_dict = dict(zip([l.get_output() for l in self.input_placeholder_layers], inputs)\n    feed_dict[self.is_training] = False\n    return self.session.run(fetch_layers, feed_dict = feed_dict)\n", "code_toks_joined": "def custom_fetch ( self , inputs , fetch_layers ) : <NEWLINE> <INDENT> feed_dict = dict ( zip ( [ l . get_output ( ) for l in self . input_placeholder_layers ] , inputs ) <NEWLINE> feed_dict [ self . is_training ] = False <NEWLINE> return self . session . run ( fetch_layers , feed_dict = feed_dict ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["fa2a648b49092d3e9898cede14873863", {"code_string": "from npieces import State\ndef template(problem)\n    \"\"\"This is a template algorithm for solving an n-pieces problem.\"\"\"\n    return State(None)\n", "code_toks_joined": "from npieces import State <NEWLINE> def template ( problem ) <NEWLINE> <INDENT> <STRING> <NEWLINE> return State ( None ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"This is a template algorithm for solving an n-pieces problem.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["fb1005897f742f4213dc72a77aaf4b0a", {"code_string": "from django.conf import settings\ntry:\n    from importlib import import_module\nexcept ImportError:\n    from django.utils.importlib import import_module\n\"\"\" Add the backend to settings.INSTALLED_APPS \"\"\"\nbackend_models = getattr(settings, 'AGENDA_BACKEND',\n    'elephantagenda.backends.agenda')\nexec 'from %s.models import *' % backend_models\n", "code_toks_joined": "from django . conf import settings <NEWLINE> try : <NEWLINE> <INDENT> from importlib import import_module <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> from django . utils . importlib import import_module <NEWLINE> <DEDENT> <STRING> <NEWLINE> backend_models = getattr ( settings , <STRING> , <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> exec <STRING> % backend_models <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"\"\" Add the backend to settings.INSTALLED_APPS \"\"\"", "'AGENDA_BACKEND'", "'elephantagenda.backends.agenda'", "'from %s.models import *'"]}, "err_obj": {"msg": "invalid syntax"}}], ["ff159f3f5b841bd1d0b8567c676aa1a3", {"code_string": "def get_arbiter_master_selected(self):\n    if self.dbg:\n        print \"GS: get_arbiter_master_selected()\"\n    return self.arbiter_selected\n", "code_toks_joined": "def get_arbiter_master_selected ( self ) : <NEWLINE> <INDENT> if self . dbg : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> return self . arbiter_selected <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"GS: get_arbiter_master_selected()\""]}, "err_obj": {"msg": "invalid syntax"}}], ["9e235527ef86ef0d489136635337eefc", {"code_string": "def _async_render(self):\n    \"\"\"Get the state of template.\"\"\"\n    try:\n        return self._template.async_render().lower() == 'true'\n    except TemplateError as ex:\n        if ex.args and ex.args[0].startswith(\n            \"UndefinedError: 'None' has no attribute\"):\n            _LOGGER.warning(\"Could not render template %s, \"\n                \"the state is unknown\", self._name)\n                return\n        _LOGGER.error(\"Could not render template %s: %s\", self._name, ex)\n", "code_toks_joined": "def _async_render ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> return self . _template . async_render ( ) . lower ( ) == <STRING> <NEWLINE> <DEDENT> except TemplateError as ex : <NEWLINE> <INDENT> if ex . args and ex . args [ 0 ] . startswith ( <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> _LOGGER . warning ( <STRING> <NEWLINE> <INDENT> <STRING> , self . _name ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> _LOGGER . error ( <STRING> , self . _name , ex ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get the state of template.\"\"\"", "'true'", "\"UndefinedError: 'None' has no attribute\"", "\"Could not render template %s, \"", "\"the state is unknown\"", "\"Could not render template %s: %s\""]}, "err_obj": {"msg": "unexpected indent"}}], ["d6af29ea89cde138dfdb9f115800ec56", {"code_string": "def test_legacy_source_image(self):\n    for legacy, new in zip(self.legacy_mapping_source_image,\n        self.new_mapping_source_image):\n        if new['destination_type'] == 'volume':\n        self.assertThat(legacy, matchers.IsSubDictOf(new.legacy()))\n        else:\n        self.assertRaises(exception.InvalidBDMForLegacy, new.legacy)\n", "code_toks_joined": "def test_legacy_source_image ( self ) : <NEWLINE> <INDENT> for legacy , new in zip ( self . legacy_mapping_source_image , <NEWLINE> <INDENT> self . new_mapping_source_image ) : <NEWLINE> if new [ <STRING> ] == <STRING> : <NEWLINE> self . assertThat ( legacy , matchers . IsSubDictOf ( new . legacy ( ) ) ) <NEWLINE> else : <NEWLINE> self . assertRaises ( exception . InvalidBDMForLegacy , new . legacy ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'destination_type'", "'volume'"]}, "err_obj": {"msg": "expected an indented block"}}], ["629a118ced2b012333c2761820bca1d5", {"code_string": "def get_summary_str(self):\n    \"\"\"Return the poll context as a summary string delimited by \"|\".\"\"\"\n    items = []\n    for item in[\n        self.job_log_dir,\n        self.batch_sys_name,\n        self.batch_sys_job_id,\n        self.batch_sys_exit_polled,\n        self.run_status,\n        self.run_signal,\n        self.time_submit_exit,\n        self.time_run,\n        self.time_run_exit]:\n        if item is None:\n        items.append(\"\")\n        else:\n        items.append(str(item))\n    return \"|\".join(items)\n", "code_toks_joined": "def get_summary_str ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> items = [ ] <NEWLINE> for item in [ <NEWLINE> <INDENT> self . job_log_dir , <NEWLINE> self . batch_sys_name , <NEWLINE> self . batch_sys_job_id , <NEWLINE> self . batch_sys_exit_polled , <NEWLINE> self . run_status , <NEWLINE> self . run_signal , <NEWLINE> self . time_submit_exit , <NEWLINE> self . time_run , <NEWLINE> self . time_run_exit ] : <NEWLINE> if item is None : <NEWLINE> items . append ( <STRING> ) <NEWLINE> else : <NEWLINE> items . append ( str ( item ) ) <NEWLINE> <DEDENT> return <STRING> . join ( items ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return the poll context as a summary string delimited by \"|\".\"\"\"", "\"\"", "\"|\""]}, "err_obj": {"msg": "expected an indented block"}}], ["247b5e4a75c015a5bda30aeb907317d9", {"code_string": "class Point:\n    def __init__(self, (vert, norm)):\n        assert(isinstance(vert, Vector))\n        assert(isinstance(norm, Vector))\n        self.vert = vert\n        self.norm = norm\n    def __repr__(self):\n        return 'point(%s, %s)' %(repr(self.vert), repr(self.norm))\n", "code_toks_joined": "class Point : <NEWLINE> <INDENT> def __init__ ( self , ( vert , norm ) ) : <NEWLINE> <INDENT> assert ( isinstance ( vert , Vector ) ) <NEWLINE> assert ( isinstance ( norm , Vector ) ) <NEWLINE> self . vert = vert <NEWLINE> self . norm = norm <NEWLINE> <DEDENT> def __repr__ ( self ) : <NEWLINE> <INDENT> return <STRING> % ( repr ( self . vert ) , repr ( self . norm ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'point(%s, %s)'"]}, "err_obj": {"msg": "invalid syntax"}}], ["0f0e59bcf3b0d9467045b733eedac81a", {"code_string": "def CopyDependentFiles(self, dir, listFileName = None):\n    \"\"\"Copy the required files to the directory and optionally include the\"\"\"\n    if sys.platform == \"win32\":\n        self.AddDependentFile(sys.dllname)\n    for targetName, sourceName in self.dependentFiles.iteritems():\n        print(\"Copying\", sourceName)\n        targetName = os.path.join(dir, targetName)\n        if os.path.exists(targetName):\n            os.remove(targetName)\n        shutil.copy2(sourceName, targetName)\n    if listFileName is not None:\n        fileNames = [os.path.join(dir, n) for n in self.dependentFiles]\n        fileNames.sort()\n        print(\"w\"), \"\\n\".join(fileNames))\n", "code_toks_joined": "def CopyDependentFiles ( self , dir , listFileName = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if sys . platform == <STRING> : <NEWLINE> <INDENT> self . AddDependentFile ( sys . dllname ) <NEWLINE> <DEDENT> for targetName , sourceName in self . dependentFiles . iteritems ( ) : <NEWLINE> <INDENT> print ( <STRING> , sourceName ) <NEWLINE> targetName = os . path . join ( dir , targetName ) <NEWLINE> if os . path . exists ( targetName ) : <NEWLINE> <INDENT> os . remove ( targetName ) <NEWLINE> <DEDENT> shutil . copy2 ( sourceName , targetName ) <NEWLINE> <DEDENT> if listFileName is not None : <NEWLINE> <INDENT> fileNames = [ os . path . join ( dir , n ) for n in self . dependentFiles ] <NEWLINE> fileNames . sort ( ) <NEWLINE> print ( <STRING> ) , <STRING> . join ( fileNames ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Copy the required files to the directory and optionally include the\"\"\"", "\"win32\"", "\"Copying\"", "\"w\"", "\"\\n\""]}, "window_span": [135, 148], "err_obj": {"msg": "unbalanced (){}[]"}}], ["7084e1ad20335bef02b2c3d7c9422ac9", {"code_string": "_LANGUAGES_NOT_IN_BUILD = []\ndef UpdateSettingsForCheckedInVersion(env,\n    version_major,\n    version_minor,\n    version_build,\n    version_patch,\n    oneclick_plugin_version):\n    print\n    print('******* CHANGING VERSION! *******')\n    env.SetProductVersion(\n    version_major, version_minor, version_build, version_patch)\n    print\n    print('*********************************')\n    print('Plug-in version: ' + oneclick_plugin_version)\n    print('*********************************')\n    env.SetActiveXFilenames(oneclick_plugin_version)\n    for language in _LANGUAGES_NOT_IN_BUILD:\n    if language in env['languages']:\n    env['languages'].remove(language)\n    print('*** Removing language: ' + language)\n    return _LANGUAGES_NOT_IN_BUILD\n", "code_toks_joined": "_LANGUAGES_NOT_IN_BUILD = [ ] <NEWLINE> def UpdateSettingsForCheckedInVersion ( env , <NEWLINE> <INDENT> version_major , <NEWLINE> version_minor , <NEWLINE> version_build , <NEWLINE> version_patch , <NEWLINE> oneclick_plugin_version ) : <NEWLINE> print <NEWLINE> print ( <STRING> ) <NEWLINE> env . SetProductVersion ( <NEWLINE> version_major , version_minor , version_build , version_patch ) <NEWLINE> print <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> + oneclick_plugin_version ) <NEWLINE> print ( <STRING> ) <NEWLINE> env . SetActiveXFilenames ( oneclick_plugin_version ) <NEWLINE> for language in _LANGUAGES_NOT_IN_BUILD : <NEWLINE> if language in env [ <STRING> ] : <NEWLINE> env [ <STRING> ] . remove ( language ) <NEWLINE> print ( <STRING> + language ) <NEWLINE> return _LANGUAGES_NOT_IN_BUILD <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'******* CHANGING VERSION! *******'", "'*********************************'", "'Plug-in version: '", "'*********************************'", "'languages'", "'languages'", "'*** Removing language: '"]}, "err_obj": {"msg": "expected an indented block"}}], ["e062f8a23f851ef00ac34acfc773b38b", {"code_string": "from django.conf.urls import include, url\nfrom django.contrib import admin\nfrom django.contrib.staticfiles.urls import staticfiles_urlpatterns\nadmin.autodiscover()\nurlpatterns = [\n    url(r'^', include('django_freeradius.urls', namespace = 'freeradius')),\n    url(r'^admin/', include(admin.site.urls),\n]\nurlpatterns += staticfiles_urlpatterns()\n", "code_toks_joined": "from django . conf . urls import include , url <NEWLINE> from django . contrib import admin <NEWLINE> from django . contrib . staticfiles . urls import staticfiles_urlpatterns <NEWLINE> admin . autodiscover ( ) <NEWLINE> urlpatterns = [ <NEWLINE> <INDENT> url ( <STRING> , include ( <STRING> , namespace = <STRING> ) ) , <NEWLINE> url ( <STRING> , include ( admin . site . urls ) , <NEWLINE> <DEDENT> ] <NEWLINE> urlpatterns += staticfiles_urlpatterns ( ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["r'^'", "'django_freeradius.urls'", "'freeradius'", "r'^admin/'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e9bfc9d985d6982eb491d4fee62a146a", {"code_string": "def draw_line(self, gc, x1, y1, x2, y2):\n    \"\"\"Draw a single line from x1, y1 to x2, y2\"\"\"\n    if debugPrint:\n        print \"draw_line: ({0: f}, {1: f}) -({2: f}, {3: f})\".format(x1, y1, x2, y2)\n    if self.select_pen(gc):\n        self.emf.Polyline([(long(x1), long(self.height - y1)), (long(x2), long(self.height - y2))])\n    else:\n        if debugPrint: print \"draw_line: optimizing away({0: f}, {1: f}) -({2: f}, {3: f})\".format(x1, y1, x2, y2)\n", "code_toks_joined": "def draw_line ( self , gc , x1 , y1 , x2 , y2 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if debugPrint : <NEWLINE> <INDENT> print <STRING> . format ( x1 , y1 , x2 , y2 ) <NEWLINE> <DEDENT> if self . select_pen ( gc ) : <NEWLINE> <INDENT> self . emf . Polyline ( [ ( long ( x1 ) , long ( self . height - y1 ) ) , ( long ( x2 ) , long ( self . height - y2 ) ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if debugPrint : print <STRING> . format ( x1 , y1 , x2 , y2 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Draw a single line from x1, y1 to x2, y2\"\"\"", "\"draw_line: ({0: f}, {1: f}) -({2: f}, {3: f})\"", "\"draw_line: optimizing away({0: f}, {1: f}) -({2: f}, {3: f})\""]}, "err_obj": {"msg": "invalid syntax"}}], ["4536714a6f9fc2f16e50ee4657bb8643", {"code_string": "def install_examples(request):\n    response = {'status': - 1, 'message': ''}\n    if request.method == 'POST':\n        try:\n            Command().handle(user = request.user)\n            response['status'] = 0\n        except Exception, err:\n            LOG.exception(err)\n            response['message'] = str(err)\n    else:\n        response['message'] = _('A POST request is required.')\n    return JsonResponse(response)\n", "code_toks_joined": "def install_examples ( request ) : <NEWLINE> <INDENT> response = { <STRING> : - 1 , <STRING> : <STRING> } <NEWLINE> if request . method == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> Command ( ) . handle ( user = request . user ) <NEWLINE> response [ <STRING> ] = 0 <NEWLINE> <DEDENT> except Exception , err : <NEWLINE> <INDENT> LOG . exception ( err ) <NEWLINE> response [ <STRING> ] = str ( err ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> response [ <STRING> ] = _ ( <STRING> ) <NEWLINE> <DEDENT> return JsonResponse ( response ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'status'", "'message'", "''", "'POST'", "'status'", "'message'", "'message'", "'A POST request is required.'"]}, "err_obj": {"msg": "invalid syntax"}}], ["f9c91050778c1b131467fb6595d65dab", {"code_string": "def render_template(template_filename, output_filename, template_context):\n    with open(template_filename, 'r') as f:\n        template = jinja2.Template(f.read())\n    print('Writing %r' % output_filename)\n    with open(output_filename, 'w') as f:\n        f.write(template.render(** template_context)\n", "code_toks_joined": "def render_template ( template_filename , output_filename , template_context ) : <NEWLINE> <INDENT> with open ( template_filename , <STRING> ) as f : <NEWLINE> <INDENT> template = jinja2 . Template ( f . read ( ) ) <NEWLINE> <DEDENT> print ( <STRING> % output_filename ) <NEWLINE> with open ( output_filename , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( template . render ( ** template_context ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'r'", "'Writing %r'", "'w'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["2019c3ee85cdec3c44cf00ddcd147052", {"code_string": "def communicate(self, in_line):\n    \"\"\"Return output and error of the decoder for the given input.\"\"\"\n    err = []\n    output = \"\"\n    logging.info(\"Decoder_Deterministic:|\" + in_line + \"|\")\n    if in_line in self.source_hash:\n    if self.verbosity > 0: logging.info(\"Match:|\" + in_line + \"|\")\n    output = self.target_list[self.source_hash[in_line]]\n    else:\n    if self.verbosity > 0: logging.info(\"NO Match:|\" + in_line + \"|\")\n    return output, \"\".join(err)\n", "code_toks_joined": "def communicate ( self , in_line ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> err = [ ] <NEWLINE> output = <STRING> <NEWLINE> logging . info ( <STRING> + in_line + <STRING> ) <NEWLINE> if in_line in self . source_hash : <NEWLINE> if self . verbosity > 0 : logging . info ( <STRING> + in_line + <STRING> ) <NEWLINE> output = self . target_list [ self . source_hash [ in_line ] ] <NEWLINE> else : <NEWLINE> if self . verbosity > 0 : logging . info ( <STRING> + in_line + <STRING> ) <NEWLINE> return output , <STRING> . join ( err ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return output and error of the decoder for the given input.\"\"\"", "\"\"", "\"Decoder_Deterministic:|\"", "\"|\"", "\"Match:|\"", "\"|\"", "\"NO Match:|\"", "\"|\"", "\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["e2f20bd20d3c2d8ed844ffb7e185dedb", {"code_string": "def _get_hash_list(self accounts_list):\n    hash_list = []\n    for account in accounts_list:\n        hash = hashlib.md5()\n        hash.update(six.text_type(account).encode('utf-8'))\n        temp_hash = hash.hexdigest()\n        hash_list.append(temp_hash)\n    return hash_list\n", "code_toks_joined": "def _get_hash_list ( self accounts_list ) : <NEWLINE> <INDENT> hash_list = [ ] <NEWLINE> for account in accounts_list : <NEWLINE> <INDENT> hash = hashlib . md5 ( ) <NEWLINE> hash . update ( six . text_type ( account ) . encode ( <STRING> ) ) <NEWLINE> temp_hash = hash . hexdigest ( ) <NEWLINE> hash_list . append ( temp_hash ) <NEWLINE> <DEDENT> return hash_list <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'utf-8'"]}, "err_obj": {"msg": "invalid syntax"}}], ["8d04446219f6d3b6fcd59d5e678fa97d", {"code_string": "def get_seq(pdb_file):\n    \"\"\"Returns an array with the aminoacids of the pdb file specified\"\"\"\n    parser = PDBParser()\n    structure = parser.get_structure(pdb_file[: - 4], pdb_file)\n    resids = structure.get_residues()\n    residues = []\n    for r in resids:\n    aa = r.get_resname()\n    if is_aa(aa):\n        residues.append(aa)\n    if len(residues) == 0:\n    print('404 - No Sequence Found!!!')\n    raise NoProtError('404 - No Sequence Found!!!')\n    return residues\n", "code_toks_joined": "def get_seq ( pdb_file ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> parser = PDBParser ( ) <NEWLINE> structure = parser . get_structure ( pdb_file [ : - 4 ] , pdb_file ) <NEWLINE> resids = structure . get_residues ( ) <NEWLINE> residues = [ ] <NEWLINE> for r in resids : <NEWLINE> aa = r . get_resname ( ) <NEWLINE> if is_aa ( aa ) : <NEWLINE> <INDENT> residues . append ( aa ) <NEWLINE> <DEDENT> if len ( residues ) == 0 : <NEWLINE> print ( <STRING> ) <NEWLINE> raise NoProtError ( <STRING> ) <NEWLINE> return residues <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns an array with the aminoacids of the pdb file specified\"\"\"", "'404 - No Sequence Found!!!'", "'404 - No Sequence Found!!!'"]}, "err_obj": {"msg": "expected an indented block"}}], ["2a00dd436e15cafacecfcbf63c1ad240", {"code_string": "def _save(self):\n    pickle.dump(\n        self.__dict__['_struct']\n        open(self.__dict__['_pickle_file'], \"w\")\n    )\n", "code_toks_joined": "def _save ( self ) : <NEWLINE> <INDENT> pickle . dump ( <NEWLINE> <INDENT> self . __dict__ [ <STRING> ] <NEWLINE> open ( self . __dict__ [ <STRING> ] , <STRING> ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'_struct'", "'_pickle_file'", "\"w\""]}, "err_obj": {"msg": "invalid syntax"}}], ["983d5903447fe7ef9337be5f6e714424", {"code_string": "def main(argv = None):\n    if argv is None:\n    argv = sys.argv\n    [Scans_filename_list, filenumber, outputpath] = parse_options(argv)\n    for eachFileName in Scans_filename_list:\n        os.system(\"python separate_scans.py -f \" + eachFileName + \" -o \" + outputpath + \" -n \" + filenumber)\n", "code_toks_joined": "def main ( argv = None ) : <NEWLINE> <INDENT> if argv is None : <NEWLINE> argv = sys . argv <NEWLINE> [ Scans_filename_list , filenumber , outputpath ] = parse_options ( argv ) <NEWLINE> for eachFileName in Scans_filename_list : <NEWLINE> <INDENT> os . system ( <STRING> + eachFileName + <STRING> + outputpath + <STRING> + filenumber ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"python separate_scans.py -f \"", "\" -o \"", "\" -n \""]}, "err_obj": {"msg": "expected an indented block"}}], ["6939935707b4454adcde6d7530704716", {"code_string": "def test_function_getter_uuid(self):\n    mesh = self.mesh_with_subdomains()\n    state = State(mesh)\n    state.a = Constant(1.0)\n    masked = MaskedState(state, 2)\n    uuid = masked.uuid(\"a\")\n    state.a = Constant(2.0)\n    self.assertFalse(uuid == masked.uuid(\"a\")\n", "code_toks_joined": "def test_function_getter_uuid ( self ) : <NEWLINE> <INDENT> mesh = self . mesh_with_subdomains ( ) <NEWLINE> state = State ( mesh ) <NEWLINE> state . a = Constant ( 1.0 ) <NEWLINE> masked = MaskedState ( state , 2 ) <NEWLINE> uuid = masked . uuid ( <STRING> ) <NEWLINE> state . a = Constant ( 2.0 ) <NEWLINE> self . assertFalse ( uuid == masked . uuid ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"a\"", "\"a\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["128f01decb2835fbef2581e46fa5dd79", {"code_string": "def test_do_delete_notifications(self):\n    with mock.patch.object(\n        notificationmethods.NotificationMethodDispatcher,\n        'handle_notification_msg', return_value = 200):\n        res = mock.Mock()\n        (self.dispatcher_post.\n        do_delete_notification_methods(\n            mock.Mock(), res,\n            id = \"c60ec47e-5038-4bf1-9f95-4046c6e9a719\"))\n            self.assertEqual(getattr(falcon, 'HTTP_200'), res.status)\n", "code_toks_joined": "def test_do_delete_notifications ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( <NEWLINE> <INDENT> notificationmethods . NotificationMethodDispatcher , <NEWLINE> <STRING> , return_value = 200 ) : <NEWLINE> res = mock . Mock ( ) <NEWLINE> ( self . dispatcher_post . <NEWLINE> do_delete_notification_methods ( <NEWLINE> <INDENT> mock . Mock ( ) , res , <NEWLINE> id = <STRING> ) ) <NEWLINE> self . assertEqual ( getattr ( falcon , <STRING> ) , res . status ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'handle_notification_msg'", "\"c60ec47e-5038-4bf1-9f95-4046c6e9a719\"", "'HTTP_200'"]}, "err_obj": {"msg": "unexpected indent"}}], ["87e6c5f99003c6f4763fc8d3603c6880", {"code_string": "def GetFatturatoFilter(self):\n    def cn(x):\n        return self.FindWindowByName(x)\n    fatcat, fatpro = self.dbfatcat, self.dbfatpro\n    self.fatlastpdc = self.pdcid\n    filtmov = []\n    for name, op in(('masdatdoc1', '>='),\n        ('masdatdoc2', '<=')):\n        val = cn(name).GetValue()\n        if val:\n        filtmov.append('doc.datdoc%s\\'%s\\'' %(op, val.Format('%Y%m%d')))\n    return filtmov\n", "code_toks_joined": "def GetFatturatoFilter ( self ) : <NEWLINE> <INDENT> def cn ( x ) : <NEWLINE> <INDENT> return self . FindWindowByName ( x ) <NEWLINE> <DEDENT> fatcat , fatpro = self . dbfatcat , self . dbfatpro <NEWLINE> self . fatlastpdc = self . pdcid <NEWLINE> filtmov = [ ] <NEWLINE> for name , op in ( ( <STRING> , <STRING> ) , <NEWLINE> <INDENT> ( <STRING> , <STRING> ) ) : <NEWLINE> val = cn ( name ) . GetValue ( ) <NEWLINE> if val : <NEWLINE> filtmov . append ( <STRING> % ( op , val . Format ( <STRING> ) ) ) <NEWLINE> <DEDENT> return filtmov <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'masdatdoc1'", "'>='", "'masdatdoc2'", "'<='", "'doc.datdoc%s\\'%s\\''", "'%Y%m%d'"]}, "err_obj": {"msg": "expected an indented block"}}], ["f1c0180763bb6c224c1c2c15ba3ac257", {"code_string": "def testWhenXHasTwoLargerLargerBatchRankThanBatchRankArg(self):\n    batch_shape = [4, 5]\n    x = self._rng.rand(2, 3, 4, 5, 6)\n    for static_batch_shape in[\n        tf.TensorShape(batch_shape), tf.TensorShape(None)]:\n        with self.test_session():\n        mat = operator_pd.flip_vector_to_matrix(\n            x, batch_shape, static_batch_shape)\n        mat_v = mat.eval()\n        self.assertAllEqual((4, 5, 6, 2 * 3), mat_v.shape)\n", "code_toks_joined": "def testWhenXHasTwoLargerLargerBatchRankThanBatchRankArg ( self ) : <NEWLINE> <INDENT> batch_shape = [ 4 , 5 ] <NEWLINE> x = self . _rng . rand ( 2 , 3 , 4 , 5 , 6 ) <NEWLINE> for static_batch_shape in [ <NEWLINE> <INDENT> tf . TensorShape ( batch_shape ) , tf . TensorShape ( None ) ] : <NEWLINE> with self . test_session ( ) : <NEWLINE> mat = operator_pd . flip_vector_to_matrix ( <NEWLINE> <INDENT> x , batch_shape , static_batch_shape ) <NEWLINE> <DEDENT> mat_v = mat . eval ( ) <NEWLINE> self . assertAllEqual ( ( 4 , 5 , 6 , 2 * 3 ) , mat_v . shape ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["77b0979e0240fc9dcd2c3e199280bf3f", {"code_string": "class Feature:\n    def __init__(self, db, id, title, desc, display, level = 1,\n        parent = None, directory = None, attributes = 0):\n        self.id = id\n        if parent:\n        parent = parent.id\n        add_data(db, \"Feature\",\n            [(id, parent, title, desc, display,\n                level, directory, attributes)])\n    def set_current(self):\n        global current_feature\n        current_feature = self\n", "code_toks_joined": "class Feature : <NEWLINE> <INDENT> def __init__ ( self , db , id , title , desc , display , level = 1 , <NEWLINE> <INDENT> parent = None , directory = None , attributes = 0 ) : <NEWLINE> self . id = id <NEWLINE> if parent : <NEWLINE> parent = parent . id <NEWLINE> add_data ( db , <STRING> , <NEWLINE> <INDENT> [ ( id , parent , title , desc , display , <NEWLINE> <INDENT> level , directory , attributes ) ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> def set_current ( self ) : <NEWLINE> <INDENT> global current_feature <NEWLINE> current_feature = self <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Feature\""]}, "err_obj": {"msg": "expected an indented block"}}], ["984f565c15f8328581139078625be457", {"code_string": "def retranslateUi(self, MainWindow):\n    MainWindow.setWindowTitle(_(\"SubDownloader\"))\n    self.label_11.setText(_(\"Select the video/folder that needs subtitles:\"))\n    self.buttonSearchSelectVideos.setToolTip(_(\"Select videos that need subtitles\"))\n    self.buttonSearchSelectVideos.setText(_(\"Select videos...\"))\n    self.buttonSearchSelectFolder.setToolTip(_(\"Click here to Search the subtitles of the movies in that folder\"))\n    self.buttonSearchSelectFolder.setText(_(\"Select folder...\"))\n    self.buttonRefresh.setText(_(\"Refresh list\"))\n    self.buttonFind.setToolTip(_(\"Click here to Search the subtitles of the movies in that folder\"))\n    self.buttonFind.setText(_(\"Search subtitles\"))\n    self.label_videosFound.setText(_(\"Videos/Subtitles found:\"))\n    self.label_filterBy.setText(_(\"Filter by:\"))\n    self.introductionHelp.setHtml(QtGui.QApplication.translate(\"MainWindow\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , MainWindow ) : <NEWLINE> <INDENT> MainWindow . setWindowTitle ( _ ( <STRING> ) ) <NEWLINE> self . label_11 . setText ( _ ( <STRING> ) ) <NEWLINE> self . buttonSearchSelectVideos . setToolTip ( _ ( <STRING> ) ) <NEWLINE> self . buttonSearchSelectVideos . setText ( _ ( <STRING> ) ) <NEWLINE> self . buttonSearchSelectFolder . setToolTip ( _ ( <STRING> ) ) <NEWLINE> self . buttonSearchSelectFolder . setText ( _ ( <STRING> ) ) <NEWLINE> self . buttonRefresh . setText ( _ ( <STRING> ) ) <NEWLINE> self . buttonFind . setToolTip ( _ ( <STRING> ) ) <NEWLINE> self . buttonFind . setText ( _ ( <STRING> ) ) <NEWLINE> self . label_videosFound . setText ( _ ( <STRING> ) ) <NEWLINE> self . label_filterBy . setText ( _ ( <STRING> ) ) <NEWLINE> self . introductionHelp . setHtml ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"SubDownloader\"", "\"Select the video/folder that needs subtitles:\"", "\"Select videos that need subtitles\"", "\"Select videos...\"", "\"Click here to Search the subtitles of the movies in that folder\"", "\"Select folder...\"", "\"Refresh list\"", "\"Click here to Search the subtitles of the movies in that folder\"", "\"Search subtitles\"", "\"Videos/Subtitles found:\"", "\"Filter by:\"", "\"MainWindow\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "window_span": [145, 157], "err_obj": {"msg": "unbalanced (){}[]"}}], ["1b398c3db76c95a3cbfab7a3885d7893", {"code_string": "def update(self):\n    if self._t >= self._endTime:\n    raise \"endTime already reached, model not updated\"\n    self._state = np.dot(self._ARcoefMatrix, self._state) + self._forcing[: , self._forcingTimeIndex]\n    self._forcingTimeIndex += 1\n    self._t += self._dt\n", "code_toks_joined": "def update ( self ) : <NEWLINE> <INDENT> if self . _t >= self . _endTime : <NEWLINE> raise <STRING> <NEWLINE> self . _state = np . dot ( self . _ARcoefMatrix , self . _state ) + self . _forcing [ : , self . _forcingTimeIndex ] <NEWLINE> self . _forcingTimeIndex += 1 <NEWLINE> self . _t += self . _dt <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"endTime already reached, model not updated\""]}, "err_obj": {"msg": "expected an indented block"}}], ["9a26037bff41a7fb3e0a4dcf4e2c8976", {"code_string": "def test_count(courseid):\n    proxy, client, cle = login()\n        for i in range(6):\n        print(i, proxy.count_users_bycourse(client, cle, courseid, 'id', i))\n        logout(proxy, client, cle)\n", "code_toks_joined": "def test_count ( courseid ) : <NEWLINE> <INDENT> proxy , client , cle = login ( ) <NEWLINE> <INDENT> for i in range ( 6 ) : <NEWLINE> print ( i , proxy . count_users_bycourse ( client , cle , courseid , <STRING> , i ) ) <NEWLINE> logout ( proxy , client , cle ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'id'"]}, "err_obj": {"msg": "unexpected indent"}}], ["72c1f010501078781528bc832ba2e479", {"code_string": "def test_file_only_at_dest(self):\n    print(\"w\"), \"line 1\")\n    base_utils.merge_trees(* self.paths(\"dest_only\"))\n    self.assertEqual(False, os.path.exists(self.src(\"dest_only\")))\n    self.assertFileContents(\"line 1\\n\", \"dest_only\")\n", "code_toks_joined": "def test_file_only_at_dest ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) , <STRING> ) <NEWLINE> base_utils . merge_trees ( * self . paths ( <STRING> ) ) <NEWLINE> self . assertEqual ( False , os . path . exists ( self . src ( <STRING> ) ) ) <NEWLINE> self . assertFileContents ( <STRING> , <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"w\"", "\"line 1\"", "\"dest_only\"", "\"dest_only\"", "\"line 1\\n\"", "\"dest_only\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["944f6d703ef82a0def5a704f4ad2f673", {"code_string": "def test_nominated_review_time_set(self):\n    for status in REVIEW_ADDON_STATUSES:\n        for process in['process_sandbox', 'process_preliminary',\n            'process_public']:\n            if(status == amo.STATUS_UNREVIEWED and\n            process == 'process_public'):\n            continue\n            self.version.update(reviewed = None)\n            self.setup_data(status)\n            getattr(self.helper.handler, process)()\n            assert self.version.reviewed, ('Reviewed for status %r, %s()'\n                %(status, process))\n", "code_toks_joined": "def test_nominated_review_time_set ( self ) : <NEWLINE> <INDENT> for status in REVIEW_ADDON_STATUSES : <NEWLINE> <INDENT> for process in [ <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ] : <NEWLINE> if ( status == amo . STATUS_UNREVIEWED and <NEWLINE> process == <STRING> ) : <NEWLINE> continue <NEWLINE> self . version . update ( reviewed = None ) <NEWLINE> self . setup_data ( status ) <NEWLINE> getattr ( self . helper . handler , process ) ( ) <NEWLINE> assert self . version . reviewed , ( <STRING> <NEWLINE> <INDENT> % ( status , process ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'process_sandbox'", "'process_preliminary'", "'process_public'", "'process_public'", "'Reviewed for status %r, %s()'"]}, "err_obj": {"msg": "expected an indented block"}}], ["3904cc99612069e4d8e5fbb2733aa366", {"code_string": "def retranslateUi(self, Dialog):\n    Dialog.setWindowTitle(_translate(\"Dialog\", \"Select image\", None))\n    self.groupBox.setTitle(_translate(\"Dialog\", \"Image1\", None))\n    self.labelSize1.setText(_translate(\"Dialog\", \"TextLabel\", None))\n    self.groupBox_2.setTitle(_translate(\"Dialog\", \"Image2\", None))\n    self.labelSize2.setText(_translate(\"Dialog\", \"TextLabel\", None))\n    self.label.setText(_translate(\"Dialog\", \"<html><head><meta name=\\\"qrichtext\\\" content=\\\"1\\\" /><style type=\\\"text/css\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , Dialog ) : <NEWLINE> <INDENT> Dialog . setWindowTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . groupBox . setTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . labelSize1 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . groupBox_2 . setTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . labelSize2 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label . setText ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Dialog\"", "\"Select image\"", "\"Dialog\"", "\"Image1\"", "\"Dialog\"", "\"TextLabel\"", "\"Dialog\"", "\"Image2\"", "\"Dialog\"", "\"TextLabel\"", "\"Dialog\"", "\"<html><head><meta name=\\\"qrichtext\\\" content=\\\"1\\\" /><style type=\\\"text/css\\\">\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["1059813bae310ef980a3b4b824fc3200", {"code_string": "def btle_slave(self, mac_addr):\n    a = list(\"\".join(\"aa:bb:cc:dd:ee:ff\".split(\":\")).decode(\"hex\"))\n        return self._device.ctrl_transfer(VENDOR_OUT, UBERTOOTH_BTLE_PROMISC, 0, 0, struct.pack(\"6c\", a[0], a[1], a[2], a[3], a[4], a[5]))\n", "code_toks_joined": "def btle_slave ( self , mac_addr ) : <NEWLINE> <INDENT> a = list ( <STRING> . join ( <STRING> . split ( <STRING> ) ) . decode ( <STRING> ) ) <NEWLINE> <INDENT> return self . _device . ctrl_transfer ( VENDOR_OUT , UBERTOOTH_BTLE_PROMISC , 0 , 0 , struct . pack ( <STRING> , a [ 0 ] , a [ 1 ] , a [ 2 ] , a [ 3 ] , a [ 4 ] , a [ 5 ] ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"", "\"aa:bb:cc:dd:ee:ff\"", "\":\"", "\"hex\"", "\"6c\""]}, "err_obj": {"msg": "unexpected indent"}}], ["c634a434e99930755f6b6bf5d5b806a9", {"code_string": "class Command(NoArgsCommand):\n    option_list = NoArgsCommand.option_list +(\n        make_option('--locale', '-l', default = None, dest = 'locale', action = 'append',\n            help = 'Creates or updates the message files for the given locale(s) (e.g. pt_BR). '\n                'Can be used multiple times.'),\n        make_option('--domain', '-d', default = 'django', dest = 'domain',\n            help = 'The domain of the message files (default: \"django\").'),\n        make_option('--all', '-a', action = 'store_true', dest = 'all',\n            default = False, help = 'Updates the message files for all existing locales.'),\n        make_option('--extension', '-e', dest = 'extensions',\n            help = 'The file extension(s) to examine (default: \"html,txt\", or \"js\" if the domain is \"djangojs\"). Separate multiple extensions with commas, or use -e multiple times.',\n            action = 'append'),\n        make_option('--symlinks', '-s', action = 'store_true', dest = 'symlinks',\n            default = False, help = 'Follows symlinks to directories when examining source code and templates for translation strings.'),\n        make_option('--ignore', '-i', action = 'append', dest = 'ignore_patterns',\n            default = [], metavar = 'PATTERN', help = 'Ignore files or directories matching this glob-style pattern. Use multiple times to ignore more.'),\n        make_option('--no-default-ignore', action = 'store_false', dest = 'use_default_ignore_patterns',\n            default = True, help = \"Don't ignore the common glob-style patterns 'CVS', '.*', '*~' and '*.pyc'.\"),\n        make_option('--no-wrap', action = 'store_true', dest = 'no_wrap',\n            default = False, help = \"Don't break long message lines into several lines.\"),\n        make_option('--no-location', action = 'store_true', dest = 'no_location',\n            default = False, help = \"Don't write '#: filename:line' lines.\"),\n        make_option('--no-obsolete', action = 'store_true', dest = 'no_obsolete',\n            default = False, help = \"Remove obsolete message strings.\"),\n        make_option('--keep-pot', action = 'store_true', dest = 'keep_pot',\n            default = False, help = \"Keep .pot file after making messages. Useful when debugging.\"),\n    )\n    help = (\"Runs over the entire source tree of the current directory and \"\n", "code_toks_joined": "class Command ( NoArgsCommand ) : <NEWLINE> <INDENT> option_list = NoArgsCommand . option_list + ( <NEWLINE> <INDENT> make_option ( <STRING> , <STRING> , default = None , dest = <STRING> , action = <STRING> , <NEWLINE> <INDENT> help = <STRING> <NEWLINE> <INDENT> <STRING> ) , <NEWLINE> <DEDENT> <DEDENT> make_option ( <STRING> , <STRING> , default = <STRING> , dest = <STRING> , <NEWLINE> <INDENT> help = <STRING> ) , <NEWLINE> <DEDENT> make_option ( <STRING> , <STRING> , action = <STRING> , dest = <STRING> , <NEWLINE> <INDENT> default = False , help = <STRING> ) , <NEWLINE> <DEDENT> make_option ( <STRING> , <STRING> , dest = <STRING> , <NEWLINE> <INDENT> help = <STRING> , <NEWLINE> action = <STRING> ) , <NEWLINE> <DEDENT> make_option ( <STRING> , <STRING> , action = <STRING> , dest = <STRING> , <NEWLINE> <INDENT> default = False , help = <STRING> ) , <NEWLINE> <DEDENT> make_option ( <STRING> , <STRING> , action = <STRING> , dest = <STRING> , <NEWLINE> <INDENT> default = [ ] , metavar = <STRING> , help = <STRING> ) , <NEWLINE> <DEDENT> make_option ( <STRING> , action = <STRING> , dest = <STRING> , <NEWLINE> <INDENT> default = True , help = <STRING> ) , <NEWLINE> <DEDENT> make_option ( <STRING> , action = <STRING> , dest = <STRING> , <NEWLINE> <INDENT> default = False , help = <STRING> ) , <NEWLINE> <DEDENT> make_option ( <STRING> , action = <STRING> , dest = <STRING> , <NEWLINE> <INDENT> default = False , help = <STRING> ) , <NEWLINE> <DEDENT> make_option ( <STRING> , action = <STRING> , dest = <STRING> , <NEWLINE> <INDENT> default = False , help = <STRING> ) , <NEWLINE> <DEDENT> make_option ( <STRING> , action = <STRING> , dest = <STRING> , <NEWLINE> <INDENT> default = False , help = <STRING> ) , <NEWLINE> <DEDENT> <DEDENT> ) <NEWLINE> help = ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'--locale'", "'-l'", "'locale'", "'append'", "'Creates or updates the message files for the given locale(s) (e.g. pt_BR). '", "'Can be used multiple times.'", "'--domain'", "'-d'", "'django'", "'domain'", "'The domain of the message files (default: \"django\").'", "'--all'", "'-a'", "'store_true'", "'all'", "'Updates the message files for all existing locales.'", "'--extension'", "'-e'", "'extensions'", "'The file extension(s) to examine (default: \"html,txt\", or \"js\" if the domain is \"djangojs\"). Separate multiple extensions with commas, or use -e multiple times.'", "'append'", "'--symlinks'", "'-s'", "'store_true'", "'symlinks'", "'Follows symlinks to directories when examining source code and templates for translation strings.'", "'--ignore'", "'-i'", "'append'", "'ignore_patterns'", "'PATTERN'", "'Ignore files or directories matching this glob-style pattern. Use multiple times to ignore more.'", "'--no-default-ignore'", "'store_false'", "'use_default_ignore_patterns'", "\"Don't ignore the common glob-style patterns 'CVS', '.*', '*~' and '*.pyc'.\"", "'--no-wrap'", "'store_true'", "'no_wrap'", "\"Don't break long message lines into several lines.\"", "'--no-location'", "'store_true'", "'no_location'", "\"Don't write '#: filename:line' lines.\"", "'--no-obsolete'", "'store_true'", "'no_obsolete'", "\"Remove obsolete message strings.\"", "'--keep-pot'", "'store_true'", "'keep_pot'", "\"Keep .pot file after making messages. Useful when debugging.\"", "\"Runs over the entire source tree of the current directory and \""]}, "window_span": [311, 315], "err_obj": {"msg": "unbalanced (){}[]"}}], ["875c4eb2256fe6c57ca0ffaaef867760", {"code_string": "class CORSHTTPRequestHandler(SimpleHTTPServer.SimpleHTTPRequestHandler):\n    def send_head(self):\n    path = self.path\n    print(path)\n    ospath = os.path.abspath('')\n    if 'say' in path:\n    regex = re.compile(\"\\/say(.*)\")\n    m = regex.match(urllib2.unquote(path))\n    engine.say(m.group(1))\n    engine.runAndWait()\n", "code_toks_joined": "class CORSHTTPRequestHandler ( SimpleHTTPServer . SimpleHTTPRequestHandler ) : <NEWLINE> <INDENT> def send_head ( self ) : <NEWLINE> path = self . path <NEWLINE> print ( path ) <NEWLINE> ospath = os . path . abspath ( <STRING> ) <NEWLINE> if <STRING> in path : <NEWLINE> regex = re . compile ( <STRING> ) <NEWLINE> m = regex . match ( urllib2 . unquote ( path ) ) <NEWLINE> engine . say ( m . group ( 1 ) ) <NEWLINE> engine . runAndWait ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "'say'", "\"\\/say(.*)\""]}, "err_obj": {"msg": "expected an indented block"}}], ["023d007b4f021b9f40044cde18cb9aaf", {"code_string": "def _insert_menu(self):\n    manager = self._window.get_ui_manager()\n    self._action_group = gtk.ActionGroup(\"GpickerPluginActions\")\n    self._action_group.add_actions([(\"Gpicker\",\n        None,\n        _(\"Open _Gpicker\")\n        \"<control><alt>O\",\n        _(\"Quick open file with gpicker\"),\n        self.on_gpicker_open)])\n    manager.insert_action_group(self._action_group, - 1)\n    self._ui_id = manager.add_ui_from_string(ui_str)\n", "code_toks_joined": "def _insert_menu ( self ) : <NEWLINE> <INDENT> manager = self . _window . get_ui_manager ( ) <NEWLINE> self . _action_group = gtk . ActionGroup ( <STRING> ) <NEWLINE> self . _action_group . add_actions ( [ ( <STRING> , <NEWLINE> <INDENT> None , <NEWLINE> _ ( <STRING> ) <NEWLINE> <STRING> , <NEWLINE> _ ( <STRING> ) , <NEWLINE> self . on_gpicker_open ) ] ) <NEWLINE> <DEDENT> manager . insert_action_group ( self . _action_group , - 1 ) <NEWLINE> self . _ui_id = manager . add_ui_from_string ( ui_str ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"GpickerPluginActions\"", "\"Gpicker\"", "\"Open _Gpicker\"", "\"<control><alt>O\"", "\"Quick open file with gpicker\""]}, "err_obj": {"msg": "invalid syntax"}}], ["d13aefe09165f02b8c169956e4a3fd23", {"code_string": "class MyApplication(web.application):\n    def run(self, port = 8888, * middleware):\n        func = self.wsgifunc(* middleware)\n            return web.httpserver.runsimple(func, ('0.0.0.0', port))\n", "code_toks_joined": "class MyApplication ( web . application ) : <NEWLINE> <INDENT> def run ( self , port = 8888 , * middleware ) : <NEWLINE> <INDENT> func = self . wsgifunc ( * middleware ) <NEWLINE> <INDENT> return web . httpserver . runsimple ( func , ( <STRING> , port ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'0.0.0.0'"]}, "err_obj": {"msg": "unexpected indent"}}], ["53bdef39beee3b3e09b94489a3e53fa1", {"code_string": "class HTTPMethodNotAllowed(HTTPClientError):\n    status_code = 405\n    def __init__(self, method, allowed_methods, *, headers = None, reason = None,\n        body = None, text = None, content_type = None):\n        allow = ','.join(sorted(allowed_methods))\n        super().__init__(headers = headers, reason = reason,\n            body = body, text = text, content_type = content_type)\n            self.headers['Allow'] = allow\n            self.allowed_methods = allowed_methods\n            self.method = method.upper()\n", "code_toks_joined": "class HTTPMethodNotAllowed ( HTTPClientError ) : <NEWLINE> <INDENT> status_code = 405 <NEWLINE> def __init__ ( self , method , allowed_methods , * , headers = None , reason = None , <NEWLINE> <INDENT> body = None , text = None , content_type = None ) : <NEWLINE> allow = <STRING> . join ( sorted ( allowed_methods ) ) <NEWLINE> super ( ) . __init__ ( headers = headers , reason = reason , <NEWLINE> <INDENT> body = body , text = text , content_type = content_type ) <NEWLINE> self . headers [ <STRING> ] = allow <NEWLINE> self . allowed_methods = allowed_methods <NEWLINE> self . method = method . upper ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["','", "'Allow'"]}, "err_obj": {"msg": "unexpected indent"}}], ["24448f1bbc9c37536e05ac15eaf24fa2", {"code_string": "def updateLineDataThread():\n    global wasThreaded\n    global gcIndex\n    wasThreaded = True\n    while True:\n    if gcIndex > 60 * 1.7:\n        gcIndex = 0\n        gc.collect()\n        t1 = FuncThread(updateLastSysDictList)\n        t1.daemon = True\n        t1.start()\n        updateLastSysDictMemory()\n        updateLastSysDict()\n        changeGuiData(ChangeGuiData)\n        time.sleep(myInterval / 1000 / 2)\n        gcIndex += 1\n", "code_toks_joined": "def updateLineDataThread ( ) : <NEWLINE> <INDENT> global wasThreaded <NEWLINE> global gcIndex <NEWLINE> wasThreaded = True <NEWLINE> while True : <NEWLINE> if gcIndex > 60 * 1.7 : <NEWLINE> <INDENT> gcIndex = 0 <NEWLINE> gc . collect ( ) <NEWLINE> t1 = FuncThread ( updateLastSysDictList ) <NEWLINE> t1 . daemon = True <NEWLINE> t1 . start ( ) <NEWLINE> updateLastSysDictMemory ( ) <NEWLINE> updateLastSysDict ( ) <NEWLINE> changeGuiData ( ChangeGuiData ) <NEWLINE> time . sleep ( myInterval / 1000 / 2 ) <NEWLINE> gcIndex += 1 <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["ee8e5e705686533fb924dba6797eb537", {"code_string": "def get_locally_available_covers(self, album):\n    \"\"\"Get locally available covers for album\"\"\"\n    all_paths = [os.path.join(album.path, f) for f in os.listdir(\n        album.path)]\n    paths = []\n    for path in filter(lambda p: p.lower().endswith(self._MIMES),\n        all_paths):\n        if not path.endswith(self._favorite):\n        paths.append(path)\n    return paths\n", "code_toks_joined": "def get_locally_available_covers ( self , album ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> all_paths = [ os . path . join ( album . path , f ) for f in os . listdir ( <NEWLINE> <INDENT> album . path ) ] <NEWLINE> <DEDENT> paths = [ ] <NEWLINE> for path in filter ( lambda p : p . lower ( ) . endswith ( self . _MIMES ) , <NEWLINE> <INDENT> all_paths ) : <NEWLINE> if not path . endswith ( self . _favorite ) : <NEWLINE> paths . append ( path ) <NEWLINE> <DEDENT> return paths <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get locally available covers for album\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["776a837388a4f9d38b89b0ff2ab2e79f", {"code_string": "class Renderer(StdIOHandler):\n    \"base class for renderers\"\n    def process(self, in_file):\n        for line in in_file.readlines():\n            fname, rendered = self.render(self.serializer.load(line)\n            yield{'filename': fname, 'content': rendered}\n", "code_toks_joined": "class Renderer ( StdIOHandler ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def process ( self , in_file ) : <NEWLINE> <INDENT> for line in in_file . readlines ( ) : <NEWLINE> <INDENT> fname , rendered = self . render ( self . serializer . load ( line ) <NEWLINE> yield { <STRING> : fname , <STRING> : rendered } <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"base class for renderers\"", "'filename'", "'content'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["3c6c1732dcd9927f75b2be5eb677f566", {"code_string": "'''Wed Mar 20 10:44:09 2013'''\nfrom PIL import Image\nimport os\nfilelist = os.getcwd()\nfor r, d, f in os.walk(filelist):\n    for infile in f:\n    outfile = os.path.splitext(infile)[0] + \".png\"\n    if infile != outfile:\n        try:\n    Image.open(infile).save(outfile)\n    print(\"successful convert %s to %s\" %(infile, outfile))\n        except IOError:\n    print(\"cannot convert\", infile)\n", "code_toks_joined": "<STRING> <NEWLINE> from PIL import Image <NEWLINE> import os <NEWLINE> filelist = os . getcwd ( ) <NEWLINE> for r , d , f in os . walk ( filelist ) : <NEWLINE> <INDENT> for infile in f : <NEWLINE> outfile = os . path . splitext ( infile ) [ 0 ] + <STRING> <NEWLINE> if infile != outfile : <NEWLINE> <INDENT> try : <NEWLINE> <DEDENT> Image . open ( infile ) . save ( outfile ) <NEWLINE> print ( <STRING> % ( infile , outfile ) ) <NEWLINE> <INDENT> except IOError : <NEWLINE> <DEDENT> print ( <STRING> , infile ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Wed Mar 20 10:44:09 2013'''", "\".png\"", "\"successful convert %s to %s\"", "\"cannot convert\""]}, "err_obj": {"msg": "expected an indented block"}}], ["679ae4314424a4955d2245761c3de141", {"code_string": "class Product(models.Model):\n    productID = models.CharField(, max_length = 200)\n    en_name = models.CharField(max_length = 800)\n    ch_name = models.CharField(max_length = 800)\n    comment = models.CharField(max_length = 500)\n    ori_price = models.DecimalField(max_digits = 7, decimal_places = 2)\n    retail_price = models.DecimalField(max_digits = 7, decimal_places = 2)\n    category = models.CharField(max_length = 200)\n    attribute = models.CharField(max_length = 500)\n    image = models.ImageField()\n", "code_toks_joined": "class Product ( models . Model ) : <NEWLINE> <INDENT> productID = models . CharField ( , max_length = 200 ) <NEWLINE> en_name = models . CharField ( max_length = 800 ) <NEWLINE> ch_name = models . CharField ( max_length = 800 ) <NEWLINE> comment = models . CharField ( max_length = 500 ) <NEWLINE> ori_price = models . DecimalField ( max_digits = 7 , decimal_places = 2 ) <NEWLINE> retail_price = models . DecimalField ( max_digits = 7 , decimal_places = 2 ) <NEWLINE> category = models . CharField ( max_length = 200 ) <NEWLINE> attribute = models . CharField ( max_length = 500 ) <NEWLINE> image = models . ImageField ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["a8b0b61e7e70568b1c4264b70a64fb90", {"code_string": "def testDepthwiseConv2D(self):\n    for index, (input_size, filter_size, _, stride,\n        padding) in enumerate(ConfigsToTest()):\n        print(\"Processing \", index, \"th config.\")\n        if index == 2:\n        self._VerifyValues(input_size,\n            filter_size,\n            stride,\n            padding,\n            use_gpu = True)\n            self._VerifyValues(input_size,\n            filter_size,\n            stride,\n            padding,\n            use_gpu = False)\n", "code_toks_joined": "def testDepthwiseConv2D ( self ) : <NEWLINE> <INDENT> for index , ( input_size , filter_size , _ , stride , <NEWLINE> <INDENT> padding ) in enumerate ( ConfigsToTest ( ) ) : <NEWLINE> print ( <STRING> , index , <STRING> ) <NEWLINE> if index == 2 : <NEWLINE> self . _VerifyValues ( input_size , <NEWLINE> <INDENT> filter_size , <NEWLINE> stride , <NEWLINE> padding , <NEWLINE> use_gpu = True ) <NEWLINE> self . _VerifyValues ( input_size , <NEWLINE> filter_size , <NEWLINE> stride , <NEWLINE> padding , <NEWLINE> use_gpu = False ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Processing \"", "\"th config.\""]}, "err_obj": {"msg": "expected an indented block"}}], ["b0dd087a827e88e5b376f664c1823cbe", {"code_string": "def remove_owner(self):\n    self.log(\"removing current user\")\n        self.os_exec(\"userdel --force --remove \" + os.environ['NEST_CONTACT_ID'])\n        self.os_exec(\"sed -i /\" + os.environ['NEST_CONTACT_ID'] + \"/d /etc/sudoers.d/99-forest-sudoers\")\n        self.os_exec(\"rm -rf /home/\" + os.environ['NEST_CONTACT_ID'])\n        self.log(\"removing group\")\n        self.os_exec(\"groupdel tree\")\n", "code_toks_joined": "def remove_owner ( self ) : <NEWLINE> <INDENT> self . log ( <STRING> ) <NEWLINE> <INDENT> self . os_exec ( <STRING> + os . environ [ <STRING> ] ) <NEWLINE> self . os_exec ( <STRING> + os . environ [ <STRING> ] + <STRING> ) <NEWLINE> self . os_exec ( <STRING> + os . environ [ <STRING> ] ) <NEWLINE> self . log ( <STRING> ) <NEWLINE> self . os_exec ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"removing current user\"", "\"userdel --force --remove \"", "'NEST_CONTACT_ID'", "\"sed -i /\"", "'NEST_CONTACT_ID'", "\"/d /etc/sudoers.d/99-forest-sudoers\"", "\"rm -rf /home/\"", "'NEST_CONTACT_ID'", "\"removing group\"", "\"groupdel tree\""]}, "err_obj": {"msg": "unexpected indent"}}], ["129fd46c7ccdc3bd8412fe266fcb68d7", {"code_string": "def get_endpoint_data():\n    return[{\n    \"input\": {\n        \"endpoint-group\": \"web\",\n        \"network-containment\": \"subnet-10.0.35.0/24\",\n        \"l2-context\": \"bridge-domain1\",\n        \"mac-address\": \"00:00:00:00:35:02\",\n        \"l3-address\": [\n            {\n                \"ip-address\": \"10.0.35.2\",\n                \"l3-context\": \"l3-context-vrf-red\"\n            }\n        ],\n        \"faas-port-ref-id\": \"165b3a20-adc7-11e5-bf7f-feff819cdc9f\",\n        \"tenant\": \"tenant-dobre\"\n    }\n", "code_toks_joined": "def get_endpoint_data ( ) : <NEWLINE> <INDENT> return [ { <NEWLINE> <STRING> : { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : [ <NEWLINE> <INDENT> { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> ] , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"input\"", "\"endpoint-group\"", "\"web\"", "\"network-containment\"", "\"subnet-10.0.35.0/24\"", "\"l2-context\"", "\"bridge-domain1\"", "\"mac-address\"", "\"00:00:00:00:35:02\"", "\"l3-address\"", "\"ip-address\"", "\"10.0.35.2\"", "\"l3-context\"", "\"l3-context-vrf-red\"", "\"faas-port-ref-id\"", "\"165b3a20-adc7-11e5-bf7f-feff819cdc9f\"", "\"tenant\"", "\"tenant-dobre\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["4a86221a2ec3a9c0d7ba139f706d48ae", {"code_string": "class Ui_Declaration(object):\n    def setupUi(self, Declaration):\n        Declaration.setObjectName(_fromUtf8(\"Declaration\"))\n        Declaration.resize(1000, 545)\n        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Preferred)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(Declaration.sizePolicy().hasHeightForWidth())\n        Declaration.setSizePolicy(sizePolicy)\n        Declaration.setMinimumSize(QtCore.QSize(700, 500))\n        Declaration.setMaximumSize(QtCore.QSize(1000, 640))\n        Declaration.setStyleSheet(_fromUtf8(\"QDialog{\\n\"\n", "code_toks_joined": "class Ui_Declaration ( object ) : <NEWLINE> <INDENT> def setupUi ( self , Declaration ) : <NEWLINE> <INDENT> Declaration . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> Declaration . resize ( 1000 , 545 ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Preferred , QtGui . QSizePolicy . Preferred ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( Declaration . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> Declaration . setSizePolicy ( sizePolicy ) <NEWLINE> Declaration . setMinimumSize ( QtCore . QSize ( 700 , 500 ) ) <NEWLINE> Declaration . setMaximumSize ( QtCore . QSize ( 1000 , 640 ) ) <NEWLINE> Declaration . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Declaration\"", "\"QDialog{\\n\""]}, "window_span": [123, 130], "err_obj": {"msg": "unbalanced (){}[]"}}], ["7bc2985ad2bf972bc01668c8839a0767", {"code_string": "def build_type(self):\n    \"\"\"Return the build type of the keystore.\"\"\"\n    if self._type is None:\n        keystore_type = self._build_type.lower()\n        if keystore_type not in('release', 'debug'):\n            raise ValueError('The build_type of Android keystores must be one of(debug, release)'\n                'instead of: {0}.'.format(self._build_type)))\n        else:\n            self._type = keystore_type\n    return self._type\n", "code_toks_joined": "def build_type ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . _type is None : <NEWLINE> <INDENT> keystore_type = self . _build_type . lower ( ) <NEWLINE> if keystore_type not in ( <STRING> , <STRING> ) : <NEWLINE> <INDENT> raise ValueError ( <STRING> <NEWLINE> <INDENT> <STRING> . format ( self . _build_type ) ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> self . _type = keystore_type <NEWLINE> <DEDENT> <DEDENT> return self . _type <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return the build type of the keystore.\"\"\"", "'release'", "'debug'", "'The build_type of Android keystores must be one of(debug, release)'", "'instead of: {0}.'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["a4d021de734eb5a20060cdd9326de64a", {"code_string": "class Plugin:\n    \"Represents ERPXE plugin\"\n    name = ''\n    def __init__(self, name):\n    self.name = name\n", "code_toks_joined": "class Plugin : <NEWLINE> <INDENT> <STRING> <NEWLINE> name = <STRING> <NEWLINE> def __init__ ( self , name ) : <NEWLINE> self . name = name <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Represents ERPXE plugin\"", "''"]}, "err_obj": {"msg": "expected an indented block"}}], ["601931d55a86f6b60ca4fda0e2549525", {"code_string": "class JSBenchmarker(Benchmarker):\n    def __init__(self, name, engine, extra_args = [], env = {}):\n        self.name = name\n        self.engine = engine\n        self.extra_args = extra_args\n        self.env = os.environ.copy()\n        for k, v in env.iteritems():\n            self.env[k] = v\n    def build(self, parent, filename, args, shared_args, emcc_args, native_args, native_exec, lib_builder):\n        self.filename = filename\n        llvm_root = self.env.get('LLVM') or LLVM_ROOT\n        if lib_builder: emcc_args = emcc_args + lib_builder('js_' + llvm_root, native = False, env_init = self.env)\n        open('hardcode.py', 'w').write('''def process(filename):''' % str(args[: - 1])\n", "code_toks_joined": "class JSBenchmarker ( Benchmarker ) : <NEWLINE> <INDENT> def __init__ ( self , name , engine , extra_args = [ ] , env = { } ) : <NEWLINE> <INDENT> self . name = name <NEWLINE> self . engine = engine <NEWLINE> self . extra_args = extra_args <NEWLINE> self . env = os . environ . copy ( ) <NEWLINE> for k , v in env . iteritems ( ) : <NEWLINE> <INDENT> self . env [ k ] = v <NEWLINE> <DEDENT> <DEDENT> def build ( self , parent , filename , args , shared_args , emcc_args , native_args , native_exec , lib_builder ) : <NEWLINE> <INDENT> self . filename = filename <NEWLINE> llvm_root = self . env . get ( <STRING> ) or LLVM_ROOT <NEWLINE> if lib_builder : emcc_args = emcc_args + lib_builder ( <STRING> + llvm_root , native = False , env_init = self . env ) <NEWLINE> open ( <STRING> , <STRING> ) . write ( <STRING> % str ( args [ : - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'LLVM'", "'js_'", "'hardcode.py'", "'w'", "'''def process(filename):'''"]}, "window_span": [159, 174], "err_obj": {"msg": "unbalanced (){}[]"}}], ["52feadd90b831d08b516441dad1546d4", {"code_string": "def parse_simple_decimal(value, error = raise_exception):\n    \"\"\"Parse simple decimal value from string.\"\"\"\n    decoded_value = (\n        value.decode('ascii', errors = 'replace')\n        if six.PY2 and isinstance(value, bytes)\n        else value)\n    if not isinstance(decoded_value, six.text_type) or(\n        not _simple_decimal_rx.match(decoded_value)):\n        if error is raise_exception:\n        raise ValueError('Cannot parse as simple decimal: %r' %(value, ))\n        return error\n    return Decimal(value)\n", "code_toks_joined": "def parse_simple_decimal ( value , error = raise_exception ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> decoded_value = ( <NEWLINE> <INDENT> value . decode ( <STRING> , errors = <STRING> ) <NEWLINE> if six . PY2 and isinstance ( value , bytes ) <NEWLINE> else value ) <NEWLINE> <DEDENT> if not isinstance ( decoded_value , six . text_type ) or ( <NEWLINE> <INDENT> not _simple_decimal_rx . match ( decoded_value ) ) : <NEWLINE> if error is raise_exception : <NEWLINE> raise ValueError ( <STRING> % ( value , ) ) <NEWLINE> return error <NEWLINE> <DEDENT> return Decimal ( value ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Parse simple decimal value from string.\"\"\"", "'ascii'", "'replace'", "'Cannot parse as simple decimal: %r'"]}, "err_obj": {"msg": "expected an indented block"}}], ["4001a95665c14d73dc0d30f3bf299853", {"code_string": "def __getitem__(self, charNum):\n    if charNum > self.lastChar or charNum < 0:\n        raise IndexError, \"no such character\"\n    index = charNum - self.firstChar\n    if index < 0:\n        return None\n    return self.glyphs[index]\n", "code_toks_joined": "def __getitem__ ( self , charNum ) : <NEWLINE> <INDENT> if charNum > self . lastChar or charNum < 0 : <NEWLINE> <INDENT> raise IndexError , <STRING> <NEWLINE> <DEDENT> index = charNum - self . firstChar <NEWLINE> if index < 0 : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> return self . glyphs [ index ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"no such character\""]}, "err_obj": {"msg": "invalid syntax"}}], ["8b07660ced9dd3ea8abf5cfa34a09af7", {"code_string": "def write(self, buf):\n    \"\"\"Write command to blink(1)\"\"\"\n    if debug_rw:\n        print \"blink1write: \" + \", \".join('0x%02x' % v for v in buf)\n    if(self.dev == None): return self.notfound()\n    bmRequestTypeOut = usb.util.build_request_type(usb.util.CTRL_OUT, usb.util.CTRL_TYPE_CLASS, usb.util.CTRL_RECIPIENT_INTERFACE)\n    self.dev.ctrl_transfer(bmRequestTypeOut,\n        0x09,\n        (3 << 8) | report_id,\n        0,\n        buf)\n", "code_toks_joined": "def write ( self , buf ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if debug_rw : <NEWLINE> <INDENT> print <STRING> + <STRING> . join ( <STRING> % v for v in buf ) <NEWLINE> <DEDENT> if ( self . dev == None ) : return self . notfound ( ) <NEWLINE> bmRequestTypeOut = usb . util . build_request_type ( usb . util . CTRL_OUT , usb . util . CTRL_TYPE_CLASS , usb . util . CTRL_RECIPIENT_INTERFACE ) <NEWLINE> self . dev . ctrl_transfer ( bmRequestTypeOut , <NEWLINE> <INDENT> 0x09 , <NEWLINE> ( 3 << 8 ) | report_id , <NEWLINE> 0 , <NEWLINE> buf ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Write command to blink(1)\"\"\"", "\"blink1write: \"", "\", \"", "'0x%02x'"]}, "err_obj": {"msg": "invalid syntax"}}], ["7a0a7ac2c7c7b5a946e180346f83a6a1", {"code_string": "def add_domain(domain, url, secure = False):\n    if not(url.startswith('http://')\n        or url.startswith('https://')\n        or url.startswith('mailto:')):\n        if secure:\n        protocol = 'https'\n        else:\n        protocol = 'http'\n        url = iri_to_uri(u'%s://%s%s' %(protocol, domain, url))\n    return url\n", "code_toks_joined": "def add_domain ( domain , url , secure = False ) : <NEWLINE> <INDENT> if not ( url . startswith ( <STRING> ) <NEWLINE> <INDENT> or url . startswith ( <STRING> ) <NEWLINE> or url . startswith ( <STRING> ) ) : <NEWLINE> if secure : <NEWLINE> protocol = <STRING> <NEWLINE> else : <NEWLINE> protocol = <STRING> <NEWLINE> url = iri_to_uri ( <STRING> % ( protocol , domain , url ) ) <NEWLINE> <DEDENT> return url <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'http://'", "'https://'", "'mailto:'", "'https'", "'http'", "u'%s://%s%s'"]}, "err_obj": {"msg": "expected an indented block"}}], ["bba21edd70b0ce9d741e9191d28924f5", {"code_string": "\"\"\"\"\"\"\nfrom..protocol.rfc4511 import ModifyDNRequest, LDAPDN, RelativeLDAPDN, DeleteOldRDN, NewSuperior, ResultCode\nfrom..operation.bind import referrals_to_list\ndef modify_dn_operation(dn,\n    new_relative_dn,\n    delete_old_rdn = True,\n    new_superior = None):\n    request = ModifyDNRequest()\n    request['entry'] = LDAPDN(dn)\n    request['newrdn'] = RelativeLDAPDN(new_relative_dn)\n    request['deleteoldrdn'] = DeleteOldRDN(delete_old_rdn)\n    if new_superior:\n    request['newSuperior'] = NewSuperior(new_superior)\n    return request\n", "code_toks_joined": "<STRING> <NEWLINE> from . . protocol . rfc4511 import ModifyDNRequest , LDAPDN , RelativeLDAPDN , DeleteOldRDN , NewSuperior , ResultCode <NEWLINE> from . . operation . bind import referrals_to_list <NEWLINE> def modify_dn_operation ( dn , <NEWLINE> <INDENT> new_relative_dn , <NEWLINE> delete_old_rdn = True , <NEWLINE> new_superior = None ) : <NEWLINE> request = ModifyDNRequest ( ) <NEWLINE> request [ <STRING> ] = LDAPDN ( dn ) <NEWLINE> request [ <STRING> ] = RelativeLDAPDN ( new_relative_dn ) <NEWLINE> request [ <STRING> ] = DeleteOldRDN ( delete_old_rdn ) <NEWLINE> if new_superior : <NEWLINE> request [ <STRING> ] = NewSuperior ( new_superior ) <NEWLINE> return request <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"\"\"\"", "'entry'", "'newrdn'", "'deleteoldrdn'", "'newSuperior'"]}, "err_obj": {"msg": "expected an indented block"}}], ["9c946208ac680aacb3ac432e31a502f5", {"code_string": "def scrypt_mcf_check(mcf, password):\n    \"\"\"Returns True if the password matches the given MCF hash\"\"\"\n    if not isinstance(mcf, bytes):\n        raise TypeError('MCF must be a byte string')\n    if mcf_mod._scrypt_mcf_7_is_standard(mcf) and not _scrypt_ll:\n        return _scrypt_str_chk(mcf, password, len(password) == 0\n    return mcf_mod.scrypt_mcf_check(scrypt, mcf, password)\n", "code_toks_joined": "def scrypt_mcf_check ( mcf , password ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not isinstance ( mcf , bytes ) : <NEWLINE> <INDENT> raise TypeError ( <STRING> ) <NEWLINE> <DEDENT> if mcf_mod . _scrypt_mcf_7_is_standard ( mcf ) and not _scrypt_ll : <NEWLINE> <INDENT> return _scrypt_str_chk ( mcf , password , len ( password ) == 0 <NEWLINE> <DEDENT> return mcf_mod . scrypt_mcf_check ( scrypt , mcf , password ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns True if the password matches the given MCF hash\"\"\"", "'MCF must be a byte string'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["dbd74f12aac6b24ac94775f0316aad88", {"code_string": "def gsm_dial(class_, number):\n    class_.call_type = 'outgoing'\n    if class_.alsacurrent == 'stereoout':\n        class_.set_state_file('gsmhandset')\n    elif class_.alsacurrent == 'voipheadset':\n        class_.set_state_file('gsmheadset')\n    try:\n        name = class_.gsm_wireless.Initiate(number, dbus_interface = DIN_VOICE_CALL_INITIATOR, timeout = 200)\n        class_.call = object_by_url(name)\n    except Exception, e:\n        print(\"Dial error: \" + str(e))\n        class_.set_state_file(class_.alsacurrent)\n        class_.notify_callbacks(\"gsm_phone_call_end\")\n", "code_toks_joined": "def gsm_dial ( class_ , number ) : <NEWLINE> <INDENT> class_ . call_type = <STRING> <NEWLINE> if class_ . alsacurrent == <STRING> : <NEWLINE> <INDENT> class_ . set_state_file ( <STRING> ) <NEWLINE> <DEDENT> elif class_ . alsacurrent == <STRING> : <NEWLINE> <INDENT> class_ . set_state_file ( <STRING> ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> name = class_ . gsm_wireless . Initiate ( number , dbus_interface = DIN_VOICE_CALL_INITIATOR , timeout = 200 ) <NEWLINE> class_ . call = object_by_url ( name ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> print ( <STRING> + str ( e ) ) <NEWLINE> class_ . set_state_file ( class_ . alsacurrent ) <NEWLINE> class_ . notify_callbacks ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'outgoing'", "'stereoout'", "'gsmhandset'", "'voipheadset'", "'gsmheadset'", "\"Dial error: \"", "\"gsm_phone_call_end\""]}, "err_obj": {"msg": "invalid syntax"}}], ["783950212fb35185e4154535df1aedec", {"code_string": "def remove(self, elem):\n    \"\"\" Removes last element from chain  \"\"\"\n        self.last = self.last.prev\n        self.last.hash = []\n", "code_toks_joined": "def remove ( self , elem ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> self . last = self . last . prev <NEWLINE> self . last . hash = [ ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Removes last element from chain  \"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["fae5750a903059c7eef185cb03a0c743", {"code_string": "import urllib, urllib2, sys, httplib\nurl = \"/MELA/REST_WS\"\nHOST_IP = \"128.130.172.214:8080\"\nif __name__ == '__main__':\n    connection = httplib.HTTPConnection(HOST_IP)\n        description_file = open(\"./requirements.xml\", \"r\")\n        body_content = description_file.read()\n        headers = {\n            'Content-Type': 'application/xml; charset=utf-8',\n                'Accept': 'application/xml, multipart/related'\n    }\n    connection.request('PUT', url + '/servicerequirements', body = body_content, headers = headers, )\n    result = connection.getresponse()\n        print(result.read())\n", "code_toks_joined": "import urllib , urllib2 , sys , httplib <NEWLINE> url = <STRING> <NEWLINE> HOST_IP = <STRING> <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> connection = httplib . HTTPConnection ( HOST_IP ) <NEWLINE> <INDENT> description_file = open ( <STRING> , <STRING> ) <NEWLINE> body_content = description_file . read ( ) <NEWLINE> headers = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> } <NEWLINE> connection . request ( <STRING> , url + <STRING> , body = body_content , headers = headers , ) <NEWLINE> result = connection . getresponse ( ) <NEWLINE> <INDENT> print ( result . read ( ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"/MELA/REST_WS\"", "\"128.130.172.214:8080\"", "'__main__'", "\"./requirements.xml\"", "\"r\"", "'Content-Type'", "'application/xml; charset=utf-8'", "'Accept'", "'application/xml, multipart/related'", "'PUT'", "'/servicerequirements'"]}, "err_obj": {"msg": "unexpected indent"}}], ["806263b64ce6cf52595b371c21b150c1", {"code_string": "def retranslateUi(self, WizardPage):\n    WizardPage.setWindowTitle(_translate(\"WizardPage\", \"WizardPage\", None))\n    self.label.setText(_translate(\"WizardPage\", \"This tool helps design your phylogenetic meta-analysis model.\", None))\n    self.label_2.setText(_translate(\"WizardPage\", \"Please select your model of evolution and assumptions.\", None))\n    self.groupBox.setTitle(_translate(\"WizardPage\", \"Model Type for phylogenetic correlations\", None))\n    self.BM_radioButton.setText(_translate(\"WizardPage\", \"random drift\", None))\n    self.label_4.setText(_translate(\"WizardPage\", \"  (Brownian-motion model, or BM)\", None))\n    self.label_6.setText(_translate(\"WizardPage\", \"Pagel\\'s \u03bb =\", None))\n    self.label_7.setText(_translate(\"WizardPage\", \"(default = 1.0)\", None))\n    self.label_8.setText(_translate(\"WizardPage\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , WizardPage ) : <NEWLINE> <INDENT> WizardPage . setWindowTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_2 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . groupBox . setTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . BM_radioButton . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_4 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_6 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_7 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_8 . setText ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"WizardPage\"", "\"WizardPage\"", "\"WizardPage\"", "\"This tool helps design your phylogenetic meta-analysis model.\"", "\"WizardPage\"", "\"Please select your model of evolution and assumptions.\"", "\"WizardPage\"", "\"Model Type for phylogenetic correlations\"", "\"WizardPage\"", "\"random drift\"", "\"WizardPage\"", "\"  (Brownian-motion model, or BM)\"", "\"WizardPage\"", "\"Pagel\\'s \u03bb =\"", "\"WizardPage\"", "\"(default = 1.0)\"", "\"WizardPage\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "window_span": [141, 149], "err_obj": {"msg": "unbalanced (){}[]"}}], ["a851981d29bc0c86dbf8f1fabfe994ff", {"code_string": "from __future__ import division\nimport webapp2, jinja2, os, urllib, myFunctions\nfrom math import *\nfrom google.appengine.api import users\nfrom google.appengine.ext import ndb\nJINJA_ENVIRONMENT = jinja2.Environment(\n    loader = jinja2.FileSystemLoader(os.path.dirname(__file__))\n    extensions = ['jinja2.ext.autoescape'])\nDEFAULT_NAMESPACE_NAME = 'default_namespace'\n", "code_toks_joined": "from __future__ import division <NEWLINE> import webapp2 , jinja2 , os , urllib , myFunctions <NEWLINE> from math import * <NEWLINE> from google . appengine . api import users <NEWLINE> from google . appengine . ext import ndb <NEWLINE> JINJA_ENVIRONMENT = jinja2 . Environment ( <NEWLINE> <INDENT> loader = jinja2 . FileSystemLoader ( os . path . dirname ( __file__ ) ) <NEWLINE> extensions = [ <STRING> ] ) <NEWLINE> <DEDENT> DEFAULT_NAMESPACE_NAME = <STRING> <NEWLINE>", "anonymize_dict": {"<STRING>": ["'jinja2.ext.autoescape'", "'default_namespace'"]}, "err_obj": {"msg": "invalid syntax"}}], ["39fc056b37eb3bbbfb54f6224521701d", {"code_string": "def both_ends(s):\n    strng = ''\n    if len(s) > 2:\n    strng = s[0] + s[1] + s[- 2] + s[- 1]\n    return strng\n", "code_toks_joined": "def both_ends ( s ) : <NEWLINE> <INDENT> strng = <STRING> <NEWLINE> if len ( s ) > 2 : <NEWLINE> strng = s [ 0 ] + s [ 1 ] + s [ - 2 ] + s [ - 1 ] <NEWLINE> return strng <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''"]}, "err_obj": {"msg": "expected an indented block"}}], ["bcc8a53bcdc84eccc7161d9e50416b7c", {"code_string": "def callback_context_switch_ftrace(self, res, line):\n    timestamp = int(float(res.group('timestamp')) * 1000.0)\n    if self.reference_timestamp == 0:\n    self.reference_timestamp = timestamp\n    timestamp = timestamp - self.reference_timestamp\n    cpu_id = int(res.group('cpu_id'))\n    name = res.group('next_task_name').rstrip(' ')\n    tid = int(res.group('next_tid'))\n    self.callback_context_switch_post(timestamp, cpu_id, tid, name, 0, \"\", \"\")\n", "code_toks_joined": "def callback_context_switch_ftrace ( self , res , line ) : <NEWLINE> <INDENT> timestamp = int ( float ( res . group ( <STRING> ) ) * 1000.0 ) <NEWLINE> if self . reference_timestamp == 0 : <NEWLINE> self . reference_timestamp = timestamp <NEWLINE> timestamp = timestamp - self . reference_timestamp <NEWLINE> cpu_id = int ( res . group ( <STRING> ) ) <NEWLINE> name = res . group ( <STRING> ) . rstrip ( <STRING> ) <NEWLINE> tid = int ( res . group ( <STRING> ) ) <NEWLINE> self . callback_context_switch_post ( timestamp , cpu_id , tid , name , 0 , <STRING> , <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'timestamp'", "'cpu_id'", "'next_task_name'", "' '", "'next_tid'", "\"\"", "\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["c84e4147213cd4deae65d47a7850411a", {"code_string": "def read_file(file_name, string_escape = True):\n    with open(Fixtures.file(file_name))) as f:\n        contents = f.read()\n        if string_escape:\n            contents = contents.decode('string-escape')\n        return contents.decode(\"utf-8\")\n", "code_toks_joined": "def read_file ( file_name , string_escape = True ) : <NEWLINE> <INDENT> with open ( Fixtures . file ( file_name ) ) ) as f : <NEWLINE> <INDENT> contents = f . read ( ) <NEWLINE> if string_escape : <NEWLINE> <INDENT> contents = contents . decode ( <STRING> ) <NEWLINE> <DEDENT> return contents . decode ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'string-escape'", "\"utf-8\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["8298bee22c709de17fd8cd07a1099cbb", {"code_string": "def splitter(seq, chnks):\n    \"\"\" Splits a list into roughly equal parts \"\"\"\n    if chnks > len(seq):\n        raise Exception('List too short or too many chunks')\n    newseq = []\n    splitsize = 1.0 / chnks * len(seq)\n    for i in range(chnks):\n        newseq.append(seq[int(round(i * splitsize)): int(round((i + 1) * splitsize)))])\n    return newseq\n", "code_toks_joined": "def splitter ( seq , chnks ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if chnks > len ( seq ) : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> newseq = [ ] <NEWLINE> splitsize = 1.0 / chnks * len ( seq ) <NEWLINE> for i in range ( chnks ) : <NEWLINE> <INDENT> newseq . append ( seq [ int ( round ( i * splitsize ) ) : int ( round ( ( i + 1 ) * splitsize ) ) ) ] ) <NEWLINE> <DEDENT> return newseq <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Splits a list into roughly equal parts \"\"\"", "'List too short or too many chunks'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c969aad5ce12ae8e815e7c065db820ad", {"code_string": "def print_thousands(s_before, l, s_after = \"   \", overwrite = True):\n    if overwrite:\n        print('\\x1b[0G',\n    print(s_before, comma_000(l), s_after, )\n    sys.stdout.flush()\n", "code_toks_joined": "def print_thousands ( s_before , l , s_after = <STRING> , overwrite = True ) : <NEWLINE> <INDENT> if overwrite : <NEWLINE> <INDENT> print ( <STRING> , <NEWLINE> <DEDENT> print ( s_before , comma_000 ( l ) , s_after , ) <NEWLINE> sys . stdout . flush ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"   \"", "'\\x1b[0G'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["7f0fbb4002fec762444f917298f7a04e", {"code_string": "def getDisplayedImage(self):\n    \"\"\"Returns the displayed image and the normalize flag\"\"\"\n    if not self._savedExpression or self._savedExpression == \"x\":\n        self._savedExpression = \"x\"\n        image = self.image\n    else:\n        for f in vigra.ufunc.__all__:\n            exec 'from vigra.ufunc import %s' % f\n        for f in dir(vigra.colors):\n            if not f.startswith('__'):\n                exec 'from vigra.colors import %s' % f\n        x = self.image\n        image = eval(self._savedExpression)\n    return image, self._normalized\n", "code_toks_joined": "def getDisplayedImage ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not self . _savedExpression or self . _savedExpression == <STRING> : <NEWLINE> <INDENT> self . _savedExpression = <STRING> <NEWLINE> image = self . image <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for f in vigra . ufunc . __all__ : <NEWLINE> <INDENT> exec <STRING> % f <NEWLINE> <DEDENT> for f in dir ( vigra . colors ) : <NEWLINE> <INDENT> if not f . startswith ( <STRING> ) : <NEWLINE> <INDENT> exec <STRING> % f <NEWLINE> <DEDENT> <DEDENT> x = self . image <NEWLINE> image = eval ( self . _savedExpression ) <NEWLINE> <DEDENT> return image , self . _normalized <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns the displayed image and the normalize flag\"\"\"", "\"x\"", "\"x\"", "'from vigra.ufunc import %s'", "'__'", "'from vigra.colors import %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["f998edfe5e88029bfcaa522037fc9b7b", {"code_string": "def connect(self, other, mapping):\n    other_inputs = other.inputs\n    if mapping is None:\n        return\n    if self == other:\n        for k, v in mapping.items():\n            if k == v:\n                raise Exception('Trying to connect value-.* to itself')\n    solar_map(\n        lambda(my_name, other_name): self._connect_single(other_inputs,\n            other_name,\n            my_name),\n        mapping.iteritems(),\n        concurrency = 2)\n", "code_toks_joined": "def connect ( self , other , mapping ) : <NEWLINE> <INDENT> other_inputs = other . inputs <NEWLINE> if mapping is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self == other : <NEWLINE> <INDENT> for k , v in mapping . items ( ) : <NEWLINE> <INDENT> if k == v : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> solar_map ( <NEWLINE> <INDENT> lambda ( my_name , other_name ) : self . _connect_single ( other_inputs , <NEWLINE> <INDENT> other_name , <NEWLINE> my_name ) , <NEWLINE> <DEDENT> mapping . iteritems ( ) , <NEWLINE> concurrency = 2 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Trying to connect value-.* to itself'"]}, "err_obj": {"msg": "invalid syntax"}}], ["c75b2d788b2157d57627b848454c8dd1", {"code_string": "def pick_square((x, y, w, h), bw, bh):\n    mod_w = w - bw\n    mod_h = h - bh\n    bx = rand() %(mod_w + 1)\n    by = rand() %(mod_h + 1)\n    return x + bx, y + by, bw, bh\n", "code_toks_joined": "def pick_square ( ( x , y , w , h ) , bw , bh ) : <NEWLINE> <INDENT> mod_w = w - bw <NEWLINE> mod_h = h - bh <NEWLINE> bx = rand ( ) % ( mod_w + 1 ) <NEWLINE> by = rand ( ) % ( mod_h + 1 ) <NEWLINE> return x + bx , y + by , bw , bh <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["d83309e71c0312d11c56032806cbc8dc", {"code_string": "def create_dir(directory):\n    if not os.path.exists(directory)\n        os.makedirs(directory)\n", "code_toks_joined": "def create_dir ( directory ) : <NEWLINE> <INDENT> if not os . path . exists ( directory ) <NEWLINE> <INDENT> os . makedirs ( directory ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["fdd7a42a5c51fd8ddb5e83128bb0d87e", {"code_string": "def choose(self):\n    \"\"\"Pick a random symbol from the list of symbols with the correct probability.\"\"\"\n    total = 0\n    n = whrandom.randint(1, self.count)\n    for symbol, freq in self.freqs.items():\n    total = total + freq\n    if n <= total: return symbol\n", "code_toks_joined": "def choose ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> total = 0 <NEWLINE> n = whrandom . randint ( 1 , self . count ) <NEWLINE> for symbol , freq in self . freqs . items ( ) : <NEWLINE> total = total + freq <NEWLINE> if n <= total : return symbol <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Pick a random symbol from the list of symbols with the correct probability.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["3f2b59ce9d730326b3f5fe10ad446bb1", {"code_string": "class Ui_MainWindow(object):\n    def setupUi(self, MainWindow):\n        MainWindow.setObjectName(_fromUtf8(\"MainWindow\"))\n        MainWindow.resize(819, 867)\n        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Preferred)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(MainWindow.sizePolicy().hasHeightForWidth())\n        MainWindow.setSizePolicy(sizePolicy)\n        MainWindow.setMinimumSize(QtCore.QSize(790, 580))\n        icon = QtGui.QIcon()\n        icon.addPixmap(QtGui.QPixmap(_fromUtf8(\":/Application/Main\")), QtGui.QIcon.Normal, QtGui.QIcon.Off)\n        MainWindow.setWindowIcon(icon)\n        MainWindow.setAutoFillBackground(False)\n        MainWindow.setStyleSheet(_fromUtf8(\"QGroupBox {\\n\"\n", "code_toks_joined": "class Ui_MainWindow ( object ) : <NEWLINE> <INDENT> def setupUi ( self , MainWindow ) : <NEWLINE> <INDENT> MainWindow . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> MainWindow . resize ( 819 , 867 ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Preferred , QtGui . QSizePolicy . Preferred ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( MainWindow . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> MainWindow . setSizePolicy ( sizePolicy ) <NEWLINE> MainWindow . setMinimumSize ( QtCore . QSize ( 790 , 580 ) ) <NEWLINE> icon = QtGui . QIcon ( ) <NEWLINE> icon . addPixmap ( QtGui . QPixmap ( _fromUtf8 ( <STRING> ) ) , QtGui . QIcon . Normal , QtGui . QIcon . Off ) <NEWLINE> MainWindow . setWindowIcon ( icon ) <NEWLINE> MainWindow . setAutoFillBackground ( False ) <NEWLINE> MainWindow . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"MainWindow\"", "\":/Application/Main\"", "\"QGroupBox {\\n\""]}, "window_span": [158, 165], "err_obj": {"msg": "unbalanced (){}[]"}}], ["9933af95839a2a0c5a46d91c0d6fae96", {"code_string": "1 import sys as s\nimport subprocess as sb\nfrom time import time\nfrom parsingInfo import parseInfo\nfrom actions import userNodeSelectionAct, randomSubSamplingAct, parseList\nfrom featuresVector import featuresCreate\nfrom misc import mergeList\nfrom preformat import process\n", "code_toks_joined": "1 import sys as s <NEWLINE> import subprocess as sb <NEWLINE> from time import time <NEWLINE> from parsingInfo import parseInfo <NEWLINE> from actions import userNodeSelectionAct , randomSubSamplingAct , parseList <NEWLINE> from featuresVector import featuresCreate <NEWLINE> from misc import mergeList <NEWLINE> from preformat import process <NEWLINE>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["ed1fa2eb4030bd0efb2faec098aac2fa", {"code_string": "[+ autogen5 template +]\n[+ CASE(get \"License\") +]\n[+ == \"BSD\" +][+(bsd(get \"Name\")(get \"Author\") \"# \") +]\n[+ == \"LGPL\" +][+(lgpl(get \"Name\")(get \"Author\") \"# \") +]\n[+ == \"GPL\" +][+(gpl(get \"Name\") \"# \") +]\n[+ ESAC +]\nimport sys\ntry:\n    import gtk\nexcept ImportError:\n    sys.exit(\"pygtk not found.\")\nUI_FILE = \"data/[+NameHLower+].ui\"\n", "code_toks_joined": "[ + autogen5 template + ] <NEWLINE> [ + CASE ( get <STRING> ) + ] <NEWLINE> [ + == <STRING> + ] [ + ( bsd ( get <STRING> ) ( get <STRING> ) <STRING> ) + ] <NEWLINE> [ + == <STRING> + ] [ + ( lgpl ( get <STRING> ) ( get <STRING> ) <STRING> ) + ] <NEWLINE> [ + == <STRING> + ] [ + ( gpl ( get <STRING> ) <STRING> ) + ] <NEWLINE> [ + ESAC + ] <NEWLINE> import sys <NEWLINE> try : <NEWLINE> <INDENT> import gtk <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> sys . exit ( <STRING> ) <NEWLINE> <DEDENT> UI_FILE = <STRING> <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"License\"", "\"BSD\"", "\"Name\"", "\"Author\"", "\"# \"", "\"LGPL\"", "\"Name\"", "\"Author\"", "\"# \"", "\"GPL\"", "\"Name\"", "\"# \"", "\"pygtk not found.\"", "\"data/[+NameHLower+].ui\""]}, "err_obj": {"msg": "invalid syntax"}}], ["f5d0fa20c6313f3e7514053a2043661f", {"code_string": "def run_bot_run(self, shuffle = False):\n    while True:\n        if len(self.media_by_tag) == 0:\n            self.get_media_id_by_tag(random.choice(self.tag_list))\n            self.this_tag_like_count = 0\n            self.max_tag_like_count = random.randint(1, self.max_like_for_one_tag)\n        if shuffle:\n            if(random.randint(0, 100) > 30 and random.randint(0, 100) < 60):\n                self.main_follow_func()\n                self.main_like_func()\n                self.unfollow_non_followers()\n            elif(random.randint(0, 100) > 60 and random.randint(0, 100) < 100):\n                self.unfollow_non_followers()\n                self.main_like_func()\n            else:\n                self.unfollow_non_followers()\n                self.main_follow_func()\n                self.main_like_func()\n        else:\n            self.main_like_func()\n            self.main_follow_func()\n            self.unfollow_non_followers()\n        cur_follower_count = self.get_user_follower_count(self.user_login)\n        cur_following_count = self.get_user_following_count(self.user_login)\n        print('========================\\n Current time: %s\\n You have %s Followers.\\n You follow %s instagram users.\\n During this run you have gained %s followers.\\n \\n \\n Bot Counters and Pointers:\\n - Likes made: %s/%s\\n - People followed: %s/%s\\n - People unfollowed: %s/%s\\n \\n The bot has been running for %s\\n ========================' %(datetime.datetime.now().strftime(\"%d.%m.%Y %H:%M:%S\"),\n            cur_follower_count,\n            cur_following_count,\n            str(int(cur_follower_count) - int(self.start_follower_count)),\n            self.like_counter,\n            self.like_per_day,\n            self.follow_counter,\n            self.follow_per_day,\n            self.unfollow_counter,\n            self.unfollow_per_day,\n            str(datetime.datetime.now() - self.bot_start)\n            )\n", "code_toks_joined": "def run_bot_run ( self , shuffle = False ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if len ( self . media_by_tag ) == 0 : <NEWLINE> <INDENT> self . get_media_id_by_tag ( random . choice ( self . tag_list ) ) <NEWLINE> self . this_tag_like_count = 0 <NEWLINE> self . max_tag_like_count = random . randint ( 1 , self . max_like_for_one_tag ) <NEWLINE> <DEDENT> if shuffle : <NEWLINE> <INDENT> if ( random . randint ( 0 , 100 ) > 30 and random . randint ( 0 , 100 ) < 60 ) : <NEWLINE> <INDENT> self . main_follow_func ( ) <NEWLINE> self . main_like_func ( ) <NEWLINE> self . unfollow_non_followers ( ) <NEWLINE> <DEDENT> elif ( random . randint ( 0 , 100 ) > 60 and random . randint ( 0 , 100 ) < 100 ) : <NEWLINE> <INDENT> self . unfollow_non_followers ( ) <NEWLINE> self . main_like_func ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . unfollow_non_followers ( ) <NEWLINE> self . main_follow_func ( ) <NEWLINE> self . main_like_func ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> self . main_like_func ( ) <NEWLINE> self . main_follow_func ( ) <NEWLINE> self . unfollow_non_followers ( ) <NEWLINE> <DEDENT> cur_follower_count = self . get_user_follower_count ( self . user_login ) <NEWLINE> cur_following_count = self . get_user_following_count ( self . user_login ) <NEWLINE> print ( <STRING> % ( datetime . datetime . now ( ) . strftime ( <STRING> ) , <NEWLINE> <INDENT> cur_follower_count , <NEWLINE> cur_following_count , <NEWLINE> str ( int ( cur_follower_count ) - int ( self . start_follower_count ) ) , <NEWLINE> self . like_counter , <NEWLINE> self . like_per_day , <NEWLINE> self . follow_counter , <NEWLINE> self . follow_per_day , <NEWLINE> self . unfollow_counter , <NEWLINE> self . unfollow_per_day , <NEWLINE> str ( datetime . datetime . now ( ) - self . bot_start ) <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'========================\\n Current time: %s\\n You have %s Followers.\\n You follow %s instagram users.\\n During this run you have gained %s followers.\\n \\n \\n Bot Counters and Pointers:\\n - Likes made: %s/%s\\n - People followed: %s/%s\\n - People unfollowed: %s/%s\\n \\n The bot has been running for %s\\n ========================'", "\"%d.%m.%Y %H:%M:%S\""]}, "window_span": [226, 317], "err_obj": {"msg": "unbalanced (){}[]"}}], ["19ded8590f3c2b7d42292b9e3285bce8", {"code_string": "def add_element(self, parent, element_content):\n    \"\"\"Recursive Method for adding the content\"\"\"\n    ascending = lambda(key, value): key.lower()\n    for key, value in sorted(element_content.iteritems(), key = ascending):\n        if key is not None:\n            key_pango = markup.convert_to_pango(key)\n        new_child = self.tree_store.append(parent, [key_pango])\n        if not value is None:\n            self.add_element(new_child, value)\n", "code_toks_joined": "def add_element ( self , parent , element_content ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ascending = lambda ( key , value ) : key . lower ( ) <NEWLINE> for key , value in sorted ( element_content . iteritems ( ) , key = ascending ) : <NEWLINE> <INDENT> if key is not None : <NEWLINE> <INDENT> key_pango = markup . convert_to_pango ( key ) <NEWLINE> <DEDENT> new_child = self . tree_store . append ( parent , [ key_pango ] ) <NEWLINE> if not value is None : <NEWLINE> <INDENT> self . add_element ( new_child , value ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Recursive Method for adding the content\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["bfe13a9751c22a2f1ebf58ddc2c910b7", {"code_string": "def cmpmd5(self, filename, md5):\n    \"\"\"Compares the filename and md5, against the controllers ffdir listing dictionary\"\"\"\n    try:\n        (size, ffmd5) = self.dirdic[filename]\n        if(md5 == ffmd5):\n            result = True\n        else:\n            result = False\n    except Exception, e:\n        result = False;\n    return result\n", "code_toks_joined": "def cmpmd5 ( self , filename , md5 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> ( size , ffmd5 ) = self . dirdic [ filename ] <NEWLINE> if ( md5 == ffmd5 ) : <NEWLINE> <INDENT> result = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = False <NEWLINE> <DEDENT> <DEDENT> except Exception , e : <NEWLINE> <INDENT> result = False ; <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Compares the filename and md5, against the controllers ffdir listing dictionary\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["b2201a9d2a2f6da54192bc8f73b8b839", {"code_string": "class TriggeredAlert(models.Model):\n    \"\"\"Logs alerts that have been sent. \"\"\"\n    reporter = models.ForeignKey(Reporter)\n    report = models.ForeignKey(Report, related_name = \"alerts\", null = True)\n    trigger = models.ForeignKey(TriggeredText)\n    date = models.DateTimeField(auto_now_add = True)\n    def __unicode__(self):\n    return '%s : \"%s\"' %(str(self.id), str(self.trigger))\n    def __int__(self):\n        return self.id\n    class Meta:\n    permissions = (\n        (\"can_view\", \"Can view\"),\n    )\n", "code_toks_joined": "class TriggeredAlert ( models . Model ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> reporter = models . ForeignKey ( Reporter ) <NEWLINE> report = models . ForeignKey ( Report , related_name = <STRING> , null = True ) <NEWLINE> trigger = models . ForeignKey ( TriggeredText ) <NEWLINE> date = models . DateTimeField ( auto_now_add = True ) <NEWLINE> def __unicode__ ( self ) : <NEWLINE> return <STRING> % ( str ( self . id ) , str ( self . trigger ) ) <NEWLINE> def __int__ ( self ) : <NEWLINE> <INDENT> return self . id <NEWLINE> <DEDENT> class Meta : <NEWLINE> permissions = ( <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Logs alerts that have been sent. \"\"\"", "\"alerts\"", "'%s : \"%s\"'", "\"can_view\"", "\"Can view\""]}, "err_obj": {"msg": "expected an indented block"}}], ["2a7c8522c80d3d0ecc29d34307723d6a", {"code_string": "from patron import test\nfrom lxml import etree\nfrom patron.compute import arch\nimport patron.tests.unit.virt.libvirt.fakelibvirt as libvirt\ndef get_vm_xml(name = \"testname\", uuid = None, source_type = 'file',\n    interface_type = 'bridge'):\n    uuid_tag = ''\n    if uuid:\n    uuid_tag = '<uuid>%s</uuid>' %(uuid, )\n    return '''<domain type='kvm'>''' %{'name': name,\n        'uuid_tag': uuid_tag,\n        'source_type': source_type,\n        'interface_type': interface_type}\n", "code_toks_joined": "from patron import test <NEWLINE> from lxml import etree <NEWLINE> from patron . compute import arch <NEWLINE> import patron . tests . unit . virt . libvirt . fakelibvirt as libvirt <NEWLINE> def get_vm_xml ( name = <STRING> , uuid = None , source_type = <STRING> , <NEWLINE> <INDENT> interface_type = <STRING> ) : <NEWLINE> uuid_tag = <STRING> <NEWLINE> if uuid : <NEWLINE> uuid_tag = <STRING> % ( uuid , ) <NEWLINE> return <STRING> % { <STRING> : name , <NEWLINE> <INDENT> <STRING> : uuid_tag , <NEWLINE> <STRING> : source_type , <NEWLINE> <STRING> : interface_type } <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"testname\"", "'file'", "'bridge'", "''", "'<uuid>%s</uuid>'", "'''<domain type='kvm'>'''", "'name'", "'uuid_tag'", "'source_type'", "'interface_type'"]}, "err_obj": {"msg": "expected an indented block"}}], ["287b6f22f97db69e5ab5b994c0ecf55d", {"code_string": "def testUpdateConfigSkipTryjob(self):\n    self._MockTryserverJson({'win_perf_bisect': 'stuff'})\n    command = trybot_command.Trybot()\n    command._InitializeBuilderNames('win-x64')\n    self._ExpectProcesses(())\n    cfg_filename = 'tools/run-perf-test.cfg'\n    cfg_data = ('''config = {'''\n", "code_toks_joined": "def testUpdateConfigSkipTryjob ( self ) : <NEWLINE> <INDENT> self . _MockTryserverJson ( { <STRING> : <STRING> } ) <NEWLINE> command = trybot_command . Trybot ( ) <NEWLINE> command . _InitializeBuilderNames ( <STRING> ) <NEWLINE> self . _ExpectProcesses ( ( ) ) <NEWLINE> cfg_filename = <STRING> <NEWLINE> cfg_data = ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'win_perf_bisect'", "'stuff'", "'win-x64'", "'tools/run-perf-test.cfg'", "'''config = {'''"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["8c2c50d8ce4a6b32a2c0465e1e47ea04", {"code_string": "def _compute_percentage_satisfaction_issue(self):\n    project_issue = self.env['project.issue'].search([('project_id', '=', self.id)])\n    activity = project_issue.rating_get_grades()\n    self.percentage_satisfaction_issue = activity['great'] * 100 / sum(activity.values())) if sum(activity.values()) else - 1\n", "code_toks_joined": "def _compute_percentage_satisfaction_issue ( self ) : <NEWLINE> <INDENT> project_issue = self . env [ <STRING> ] . search ( [ ( <STRING> , <STRING> , self . id ) ] ) <NEWLINE> activity = project_issue . rating_get_grades ( ) <NEWLINE> self . percentage_satisfaction_issue = activity [ <STRING> ] * 100 / sum ( activity . values ( ) ) ) if sum ( activity . values ( ) ) else - 1 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'project.issue'", "'project_id'", "'='", "'great'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["176f3b0e8ba10ce500a9e9408cd45a53", {"code_string": "\"\"\"Created on Mon Jul 10 14:28:40 2017\"\"\"\nimport numpy as np\nimport pickle\ndef recode_wide(file: str, outfile: str,\n    anc_file: str, out_anc_file: str) -> None:\n    \"\"\"Recode file in the \"wide\" format, for example:\"\"\"\n    data = np.genfromtxt(file, dtype = 'int8', delimiter = 1)\n    with open(outfile, 'wb') as f:\n    pickle.dump(data + 1, f)\n    anc_data = np.genfromtxt(anc_file, dtype = 'int8')\n    with open(out_anc_file, 'wb') as f:\n    pickle.dump(anc_data, f)\n    print('Saved ', out_anc_file)\n", "code_toks_joined": "<STRING> <NEWLINE> import numpy as np <NEWLINE> import pickle <NEWLINE> def recode_wide ( file : str , outfile : str , <NEWLINE> <INDENT> anc_file : str , out_anc_file : str ) -> None : <NEWLINE> <STRING> <NEWLINE> data = np . genfromtxt ( file , dtype = <STRING> , delimiter = 1 ) <NEWLINE> with open ( outfile , <STRING> ) as f : <NEWLINE> pickle . dump ( data + 1 , f ) <NEWLINE> anc_data = np . genfromtxt ( anc_file , dtype = <STRING> ) <NEWLINE> with open ( out_anc_file , <STRING> ) as f : <NEWLINE> pickle . dump ( anc_data , f ) <NEWLINE> print ( <STRING> , out_anc_file ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Created on Mon Jul 10 14:28:40 2017\"\"\"", "\"\"\"Recode file in the \"wide\" format, for example:\"\"\"", "'int8'", "'wb'", "'int8'", "'wb'", "'Saved '"]}, "err_obj": {"msg": "expected an indented block"}}], ["0737ddb9f0f4fc57e08d7c01c788406e", {"code_string": "def index():\n    logging.info('index page')\n        return render_template('index.html')\n", "code_toks_joined": "def index ( ) : <NEWLINE> <INDENT> logging . info ( <STRING> ) <NEWLINE> <INDENT> return render_template ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'index page'", "'index.html'"]}, "err_obj": {"msg": "unexpected indent"}}], ["e546a6e67e5c680d1c4dc2e9853f519f", {"code_string": "class MockRecognizer(object):\n    def __init__(self):\n        self.transcriptions = []\n    def recognize_mycroft(self, audio, key = None,\n        language = None, show_all = False):\n        if len(self.transcriptions) > 0:\n        return self.transcriptions.pop(0)\n        else:\n        raise speech_recognition.UnknownValueError()\n    def set_transcriptions(self, transcriptions):\n        self.transcriptions = transcriptions\n", "code_toks_joined": "class MockRecognizer ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . transcriptions = [ ] <NEWLINE> <DEDENT> def recognize_mycroft ( self , audio , key = None , <NEWLINE> <INDENT> language = None , show_all = False ) : <NEWLINE> if len ( self . transcriptions ) > 0 : <NEWLINE> return self . transcriptions . pop ( 0 ) <NEWLINE> else : <NEWLINE> raise speech_recognition . UnknownValueError ( ) <NEWLINE> <DEDENT> def set_transcriptions ( self , transcriptions ) : <NEWLINE> <INDENT> self . transcriptions = transcriptions <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["e773367a934bb1a263d55ad778837567", {"code_string": "class SparseCoder(BaseEstimator, SparseCodingMixin):\n    \"\"\"Sparse coding\"\"\"\n    def __init__(self, dictionary, transform_algorithm = 'omp',\n        transform_n_nonzero_coefs = None, transform_alpha = None,\n        split_sign = False, n_jobs = 1):\n        self._set_sparse_coding_params(dictionary.shape[0],\n            transform_algorithm,\n            transform_n_nonzero_coefs,\n            transform_alpha, split_sign, n_jobs)\n            self.components_ = dictionary\n    def fit(self, X, y = None):\n        \"\"\"Do nothing and return the estimator unchanged\"\"\"\n        return self\n", "code_toks_joined": "class SparseCoder ( BaseEstimator , SparseCodingMixin ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , dictionary , transform_algorithm = <STRING> , <NEWLINE> <INDENT> transform_n_nonzero_coefs = None , transform_alpha = None , <NEWLINE> split_sign = False , n_jobs = 1 ) : <NEWLINE> self . _set_sparse_coding_params ( dictionary . shape [ 0 ] , <NEWLINE> <INDENT> transform_algorithm , <NEWLINE> transform_n_nonzero_coefs , <NEWLINE> transform_alpha , split_sign , n_jobs ) <NEWLINE> self . components_ = dictionary <NEWLINE> <DEDENT> <DEDENT> def fit ( self , X , y = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Sparse coding\"\"\"", "'omp'", "\"\"\"Do nothing and return the estimator unchanged\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["4d31e6fd1b4676cdb3fd78b8d57960eb", {"code_string": "def calculateSimilarItems(prefs, n = 10):\n    result = {}\n    itemPrefs = transformPrefs(prefs)\n    c = 0\n    for item in itemPrefs:\n        c += 1\n        if c % 100 == 0:\n            print \"%d / %d\" %(c, len(itemPrefs))\n        scores = topMatches(itemPrefs, item, n = n, similarity = sim_distance)\n        result[item] = scores\n    return result\n", "code_toks_joined": "def calculateSimilarItems ( prefs , n = 10 ) : <NEWLINE> <INDENT> result = { } <NEWLINE> itemPrefs = transformPrefs ( prefs ) <NEWLINE> c = 0 <NEWLINE> for item in itemPrefs : <NEWLINE> <INDENT> c += 1 <NEWLINE> if c % 100 == 0 : <NEWLINE> <INDENT> print <STRING> % ( c , len ( itemPrefs ) ) <NEWLINE> <DEDENT> scores = topMatches ( itemPrefs , item , n = n , similarity = sim_distance ) <NEWLINE> result [ item ] = scores <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"%d / %d\""]}, "err_obj": {"msg": "invalid syntax"}}], ["68815dfec5857ba951aa7b9388788568", {"code_string": "def retranslateUi(self, RenameDocumentDialog):\n    _translate = QtCore.QCoreApplication.translate\n    RenameDocumentDialog.setWindowTitle(_translate(\"RenameDocumentDialog\", \"Dialog\"))\n    self.label.setText(_translate(\"RenameDocumentDialog\", \"Format string\"))\n    self.label_8.setText(_translate(\"RenameDocumentDialog\", \"{title} - \\n\"\n", "code_toks_joined": "def retranslateUi ( self , RenameDocumentDialog ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> RenameDocumentDialog . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . label . setText ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . label_8 . setText ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"RenameDocumentDialog\"", "\"Dialog\"", "\"RenameDocumentDialog\"", "\"Format string\"", "\"RenameDocumentDialog\"", "\"{title} - \\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["8bd3c08091e044766c7dc8cc87c4769e", {"code_string": "def _build_storage_path(self):\n    self.assign_id()\n    path_segments = ['event', strict_unicode(self.contribution.event_new.id), 'papers',\n        \"{}_{}\".format(self.id, strict_unicode(self.contribution.id)]\n    path = posixpath.join(*(path_segments +[self.filename]))\n    return Config.getInstance().getAttachmentStorage(), path\n", "code_toks_joined": "def _build_storage_path ( self ) : <NEWLINE> <INDENT> self . assign_id ( ) <NEWLINE> path_segments = [ <STRING> , strict_unicode ( self . contribution . event_new . id ) , <STRING> , <NEWLINE> <INDENT> <STRING> . format ( self . id , strict_unicode ( self . contribution . id ) ] <NEWLINE> <DEDENT> path = posixpath . join ( * ( path_segments + [ self . filename ] ) ) <NEWLINE> return Config . getInstance ( ) . getAttachmentStorage ( ) , path <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'event'", "'papers'", "\"{}_{}\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["f34a9fa8ddd00d66081941419c43c572", {"code_string": "def __div__(self, other):\n    '''Divide an angle by another'''\n    div = self.todegrees() / other.todegrees()\n    divint = int(round(div)\n    if other * divint == self:\n        return divint\n    else:\n        return div\n", "code_toks_joined": "def __div__ ( self , other ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> div = self . todegrees ( ) / other . todegrees ( ) <NEWLINE> divint = int ( round ( div ) <NEWLINE> if other * divint == self : <NEWLINE> <INDENT> return divint <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return div <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Divide an angle by another'''"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["f8b55e1ff6a71c09ea51d5bd64091fdf", {"code_string": "class SomeClass(object):\n    def __init__(self, data)\n        self.data = data\n", "code_toks_joined": "class SomeClass ( object ) : <NEWLINE> <INDENT> def __init__ ( self , data ) <NEWLINE> <INDENT> self . data = data <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["ec6d58a99fe691a9918f04ef9daee440", {"code_string": "def read(data, namespace):\n    assert data\n    if isinstance(data, dict):\n        return OrderedDict((k, read(v, namespace)) for(k, v) in data.items()}\n    else:\n        return to_function(data)\n", "code_toks_joined": "def read ( data , namespace ) : <NEWLINE> <INDENT> assert data <NEWLINE> if isinstance ( data , dict ) : <NEWLINE> <INDENT> return OrderedDict ( ( k , read ( v , namespace ) ) for ( k , v ) in data . items ( ) } <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return to_function ( data ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["abcff1c9a3de13f2dc9c323e4bbe0fa5", {"code_string": "class ScalingTransformation:\n    def __init__(self, scaling):\n        scaling = float(scaling)\n        if scaling > 0:\n        def f(x):\n            return x / scaling\n            def finv(y):\n            return y * scaling\n        else:\n            raise Exception('Scaling Transformation is not set up correctly.')\n        self.__call__ = f\n        self.inverse = finv\n", "code_toks_joined": "class ScalingTransformation : <NEWLINE> <INDENT> def __init__ ( self , scaling ) : <NEWLINE> <INDENT> scaling = float ( scaling ) <NEWLINE> if scaling > 0 : <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> return x / scaling <NEWLINE> def finv ( y ) : <NEWLINE> return y * scaling <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> self . __call__ = f <NEWLINE> self . inverse = finv <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Scaling Transformation is not set up correctly.'"]}, "err_obj": {"msg": "expected an indented block"}}], ["3dbd70a58583c43afa06bcb8c08ace75", {"code_string": "def _click_to_show_instructions_fired(self):\n    m = information(None,\n        \"\\nTo remove spikes from the data:\\n\\n\"\n        \"   1. Click \\\"Show derivative histogram\\\" to \"\n        \"determine at what magnitude the spikes are present.\\n\"\n        \"   2. Enter a suitable threshold (lower than the \"\n        \"lowest magnitude outlier in the histogram) in the \"\n        \"\\\"Threshold\\\" box, which will be the magnitude \"\n        \"from which to search. \\n\"\n        \"   3. Click \\\"Find next\\\" to find the first spike.\\n\"\n        \"   4. If desired, the width and position of the \"\n        \"boundaries used to replace the spike can be \"\n        \"adjusted by clicking and dragging on the displayed \"\n        \"plot.\\n \"\n        \"   5. View the spike (and the replacement data that \"\n        \"will be added) and click \\\"Remove spike\\\" in order \"\n        \"to alter the data as shown. The tool will \"\n        \"automatically find the next spike to replace.\\n\"\n        \"   6. Repeat this process for each spike throughout \"\n        \"the dataset, until the end of the dataset is \"\n        \"reached.\\n\"\n        \"   7. Click \\\"OK\\\" when finished to close the spikes \"\n        \"removal tool.\\n\\n\"\n        \"Note: Various settings can be configured in \"\n        \"the \\\"Advanced settings\\\" section. Hover the \"\n        \"mouse over each parameter for a description of what \"\n        \"it does.\"\n", "code_toks_joined": "def _click_to_show_instructions_fired ( self ) : <NEWLINE> <INDENT> m = information ( None , <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\\nTo remove spikes from the data:\\n\\n\"", "\"   1. Click \\\"Show derivative histogram\\\" to \"", "\"determine at what magnitude the spikes are present.\\n\"", "\"   2. Enter a suitable threshold (lower than the \"", "\"lowest magnitude outlier in the histogram) in the \"", "\"\\\"Threshold\\\" box, which will be the magnitude \"", "\"from which to search. \\n\"", "\"   3. Click \\\"Find next\\\" to find the first spike.\\n\"", "\"   4. If desired, the width and position of the \"", "\"boundaries used to replace the spike can be \"", "\"adjusted by clicking and dragging on the displayed \"", "\"plot.\\n \"", "\"   5. View the spike (and the replacement data that \"", "\"will be added) and click \\\"Remove spike\\\" in order \"", "\"to alter the data as shown. The tool will \"", "\"automatically find the next spike to replace.\\n\"", "\"   6. Repeat this process for each spike throughout \"", "\"the dataset, until the end of the dataset is \"", "\"reached.\\n\"", "\"   7. Click \\\"OK\\\" when finished to close the spikes \"", "\"removal tool.\\n\\n\"", "\"Note: Various settings can be configured in \"", "\"the \\\"Advanced settings\\\" section. Hover the \"", "\"mouse over each parameter for a description of what \"", "\"it does.\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["8980b1ce94c709733f5a2dc315b4be2b", {"code_string": "def _dcommit_calls_bypassed(cls):\n    return[\n        ((['git',\n            'config', 'branch.working.rietveldissue'], ), '12345'),\n        ((['git', 'config', 'branch.working.rietveldserver'], ),\n            'codereview.example.com'),\n        ((['git', 'config', 'rietveld.tree-status-url'], ), ''),\n        (('GitClHooksBypassedCommit',\n            'Issue https://codereview.example.com/12345 bypassed hook when '\n", "code_toks_joined": "def _dcommit_calls_bypassed ( cls ) : <NEWLINE> <INDENT> return [ <NEWLINE> <INDENT> ( ( [ <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> ] , ) , <STRING> ) , <NEWLINE> <DEDENT> ( ( [ <STRING> , <STRING> , <STRING> ] , ) , <NEWLINE> <INDENT> <STRING> ) , <NEWLINE> <DEDENT> ( ( [ <STRING> , <STRING> , <STRING> ] , ) , <STRING> ) , <NEWLINE> ( ( <STRING> , <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'git'", "'config'", "'branch.working.rietveldissue'", "'12345'", "'git'", "'config'", "'branch.working.rietveldserver'", "'codereview.example.com'", "'git'", "'config'", "'rietveld.tree-status-url'", "''", "'GitClHooksBypassedCommit'", "'Issue https://codereview.example.com/12345 bypassed hook when '"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["5f15f1b7f8b9fdcc5da30dc3734974df", {"code_string": "def packet_header(packet):\n    caplen = wirelen = len(packet)\n    t = time.time()\n    sec = int(t)\n    usec = int(round((t - sec) * 1000000)\n    return struct.pack('IIII', sec, usec, caplen, wirelen)\n", "code_toks_joined": "def packet_header ( packet ) : <NEWLINE> <INDENT> caplen = wirelen = len ( packet ) <NEWLINE> t = time . time ( ) <NEWLINE> sec = int ( t ) <NEWLINE> usec = int ( round ( ( t - sec ) * 1000000 ) <NEWLINE> return struct . pack ( <STRING> , sec , usec , caplen , wirelen ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'IIII'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c3834e9afcd3a8c4959c0fcc30346d5f", {"code_string": "def _resolve_check(domain, request):\n    try:\n        res = socket.gethostbyname(domain)\n    except Exception, e:\n        e_msg = ('Domain/Realm(%s) could not be resolved. Check '\n            'your DNS configuration and try again. '\n            'Lower level error: %s' %(domain, e.__str__()))\n        handle_exception(Exception(e_msg), request)\n", "code_toks_joined": "def _resolve_check ( domain , request ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> res = socket . gethostbyname ( domain ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> e_msg = ( <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> % ( domain , e . __str__ ( ) ) ) <NEWLINE> <DEDENT> handle_exception ( Exception ( e_msg ) , request ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Domain/Realm(%s) could not be resolved. Check '", "'your DNS configuration and try again. '", "'Lower level error: %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["13030eab500c42a34c054f5318ab22c0", {"code_string": "def trim_release_list(value):\n    return sorted(\n        value,\n        key = lambda(id, count): count,\n        reverse = True,\n    )[: 5]\n", "code_toks_joined": "def trim_release_list ( value ) : <NEWLINE> <INDENT> return sorted ( <NEWLINE> <INDENT> value , <NEWLINE> key = lambda ( id , count ) : count , <NEWLINE> reverse = True , <NEWLINE> <DEDENT> ) [ : 5 ] <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["9e167e00b8144fc2dd25cf42a65871a9", {"code_string": "def retranslateUi(self, Dialog):\n    Dialog.setWindowTitle(_translate(\"Dialog\", \"Dialog\", None))\n    self.label_2.setText(_translate(\"Dialog\", \"Prediction Market\", None))\n    self.label_3.setText(_translate(\"Dialog\", \"Democratising Data Sciences Through Competition\", None))\n    self.label_6.setText(_translate(\"Dialog\", \"<html><head/><body><p><span style=\\\" font-size:16pt; font-weight:600;\\\">The User</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Complex data needs complex modeling.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Data science expertise required to analyse data.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Statistician and business intelligence tools <br/>\u00a0\u00a0\u00a0 are expensive.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Free software available but requires knowledge.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 May worry about intellectual property.</span></p><p><br/></p></body></html>\", None))\n    self.label_8.setText(_translate(\"Dialog\", \"<html><head/><body><p><span style=\\\" font-size:16pt; font-weight:600;\\\">The Data Scientist</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Has knowledge of the machile learning tools.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Develops new algorithms.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Is looking for data to test algorithms.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 May require external data to improve<br/>\u00a0\u00a0\u00a0 predictions.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 May worry about intellectual property.</span><br/></p></body></html>\", None))\n    self.label_9.setText(_translate(\"Dialog\", \"<html><head/><body><p><span style=\\\" font-size:16pt; font-weight:600;\\\">Computational Resources</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Provide low level storage and processing<br>&nbsp;&nbsp;&nbsp; interfaces.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Maintenance required by another party.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 It is not free, but is cheap if bought in bulk.</span></p><p><br/></p><p><br/></p></body></html>\", None))\n    self.label_11.setText(_translate(\"Dialog\", \"<html><head/><body><p><span style=\\\" font-size:16pt; font-weight:600;\\\">A market for users and developers</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Allowing developers and users to search and<br/>\u00a0\u00a0\u00a0advertise, like an \u201cApp Store\u201d.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Competition to provide better algorithms.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Fair pricing of algorithms based on their<br/>\u00a0\u00a0\u00a0performance.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Third party to keep intellectual property safe.</span></p><p><br/></p><p><br/></p></body></html>\", None))\n    self.label_12.setText(_translate(\"Dialog\", \"<html><head/><body><p><span style=\\\" font-size:16pt; font-weight:600;\\\">Everything is on the cloud</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Web-based and JSON interface, for<br/>\u00a0\u00a0\u00a0man and machine.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 On demand and scalable.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Better use of computational resources.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Many open source algorithms to<br/>\u00a0\u00a0\u00a0start with.</span></p><p><br/></p><p><br/></p></body></html>\", None))\n    self.label_13.setText(_translate(\"Dialog\", \"<html><head/><body><p><span style=\\\" font-size:16pt; font-weight:600;\\\">Real-world Demo</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Forecasting electricity demand<br/>\u00a0\u00a0\u00a0and solar generation.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Scheduling a battery to <br/>\u00a0\u00a0\u00a0control local demand.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 See Intelligent Energy <br/>\u00a0\u00a0\u00a0Network Section.</span><br/></p><p><br/></p></body></html>\", None))\n    self.label_algo_description.setText(_translate(\"Dialog\", \"Select an algorithm for more information.\", None))\n    self.label_ts_description.setText(_translate(\"Dialog\", \"Select a time-series to begin.\", None))\n    self.label_7.setText(_translate(\"Dialog\", \"<html><head/><body><p><span style=\\\" font-size:12pt;\\\">Legend:</span>\\n\"\n", "code_toks_joined": "def retranslateUi ( self , Dialog ) : <NEWLINE> <INDENT> Dialog . setWindowTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_2 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_3 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_6 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_8 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_9 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_11 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_12 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_13 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_algo_description . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_ts_description . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_7 . setText ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Dialog\"", "\"Dialog\"", "\"Dialog\"", "\"Prediction Market\"", "\"Dialog\"", "\"Democratising Data Sciences Through Competition\"", "\"Dialog\"", "\"<html><head/><body><p><span style=\\\" font-size:16pt; font-weight:600;\\\">The User</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Complex data needs complex modeling.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Data science expertise required to analyse data.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Statistician and business intelligence tools <br/>\u00a0\u00a0\u00a0 are expensive.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Free software available but requires knowledge.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 May worry about intellectual property.</span></p><p><br/></p></body></html>\"", "\"Dialog\"", "\"<html><head/><body><p><span style=\\\" font-size:16pt; font-weight:600;\\\">The Data Scientist</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Has knowledge of the machile learning tools.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Develops new algorithms.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Is looking for data to test algorithms.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 May require external data to improve<br/>\u00a0\u00a0\u00a0 predictions.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 May worry about intellectual property.</span><br/></p></body></html>\"", "\"Dialog\"", "\"<html><head/><body><p><span style=\\\" font-size:16pt; font-weight:600;\\\">Computational Resources</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Provide low level storage and processing<br>&nbsp;&nbsp;&nbsp; interfaces.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Maintenance required by another party.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 It is not free, but is cheap if bought in bulk.</span></p><p><br/></p><p><br/></p></body></html>\"", "\"Dialog\"", "\"<html><head/><body><p><span style=\\\" font-size:16pt; font-weight:600;\\\">A market for users and developers</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Allowing developers and users to search and<br/>\u00a0\u00a0\u00a0advertise, like an \u201cApp Store\u201d.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Competition to provide better algorithms.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Fair pricing of algorithms based on their<br/>\u00a0\u00a0\u00a0performance.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Third party to keep intellectual property safe.</span></p><p><br/></p><p><br/></p></body></html>\"", "\"Dialog\"", "\"<html><head/><body><p><span style=\\\" font-size:16pt; font-weight:600;\\\">Everything is on the cloud</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Web-based and JSON interface, for<br/>\u00a0\u00a0\u00a0man and machine.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 On demand and scalable.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Better use of computational resources.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Many open source algorithms to<br/>\u00a0\u00a0\u00a0start with.</span></p><p><br/></p><p><br/></p></body></html>\"", "\"Dialog\"", "\"<html><head/><body><p><span style=\\\" font-size:16pt; font-weight:600;\\\">Real-world Demo</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Forecasting electricity demand<br/>\u00a0\u00a0\u00a0and solar generation.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 Scheduling a battery to <br/>\u00a0\u00a0\u00a0control local demand.</span></p><p><span style=\\\" font-size:12pt;\\\">\u2022 See Intelligent Energy <br/>\u00a0\u00a0\u00a0Network Section.</span><br/></p><p><br/></p></body></html>\"", "\"Dialog\"", "\"Select an algorithm for more information.\"", "\"Dialog\"", "\"Select a time-series to begin.\"", "\"Dialog\"", "\"<html><head/><body><p><span style=\\\" font-size:12pt;\\\">Legend:</span>\\n\""]}, "window_span": [189, 197], "err_obj": {"msg": "unbalanced (){}[]"}}], ["705e86cb3e1078cad7b54cce4fa23a82", {"code_string": "def get_creator(self):\n    \"\"\"Get the creator of the map\"\"\"\n    if self.D.has_key(\"creator\"):\n        return self.D[\"creator\"]\n            else:\n        return None\n", "code_toks_joined": "def get_creator ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . D . has_key ( <STRING> ) : <NEWLINE> <INDENT> return self . D [ <STRING> ] <NEWLINE> <INDENT> else : <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get the creator of the map\"\"\"", "\"creator\"", "\"creator\""]}, "err_obj": {"msg": "unexpected indent"}}], ["2affb366ddbf499e012495f8f473178e", {"code_string": "def downgrade(migrate_engine):\n    meta = MetaData()\n    meta.bind = migrate_engine\n    transfers = Table('transfers',\n        meta,\n        autoload = True)\n    try:\n        transfers.drop()\n    except Exception:\n        LOG.error(_(\"transfers table not dropped\")\n        raise\n", "code_toks_joined": "def downgrade ( migrate_engine ) : <NEWLINE> <INDENT> meta = MetaData ( ) <NEWLINE> meta . bind = migrate_engine <NEWLINE> transfers = Table ( <STRING> , <NEWLINE> <INDENT> meta , <NEWLINE> autoload = True ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> transfers . drop ( ) <NEWLINE> <DEDENT> except Exception : <NEWLINE> <INDENT> LOG . error ( _ ( <STRING> ) <NEWLINE> raise <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'transfers'", "\"transfers table not dropped\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["33dc5f7ccdd64c93ba6215940d7d5961", {"code_string": "def run(self, options = None):\n    self.verbosity = options['verbosity']\n    messages = []\n    for(name, method) in inspect.getmembers(self,\n        predicate = inspect.ismethod):\n        if name.startswith('check_'):\n        messages += method()\n    return messages\n", "code_toks_joined": "def run ( self , options = None ) : <NEWLINE> <INDENT> self . verbosity = options [ <STRING> ] <NEWLINE> messages = [ ] <NEWLINE> for ( name , method ) in inspect . getmembers ( self , <NEWLINE> <INDENT> predicate = inspect . ismethod ) : <NEWLINE> if name . startswith ( <STRING> ) : <NEWLINE> messages += method ( ) <NEWLINE> <DEDENT> return messages <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'verbosity'", "'check_'"]}, "err_obj": {"msg": "expected an indented block"}}], ["603dd55306590796d214e7496de5a9cd", {"code_string": "def main():\n    input = [\n        \"CGContext.h\",\n    ]\n    output = SHORT + \"gen.py\"\n    defsoutput = TOOLBOXDIR + LONG + \".py\"\n    scanner = MyScanner(input, output, defsoutput)\n    scanner.scan()\n    scanner.gentypetest(SHORT + \"typetest.py\")\n    scanner.close()\n    print(\"=== Testing definitions output code ===\")\n    execfile(defsoutput, {}, {})\n    print(\"=== Done scanning and generating, now importing the generated code... ===\")\n    exec \"import \" + SHORT + \"support\"\n    print(\"=== Done.  It's up to you to compile it now! ===\")\n", "code_toks_joined": "def main ( ) : <NEWLINE> <INDENT> input = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <DEDENT> ] <NEWLINE> output = SHORT + <STRING> <NEWLINE> defsoutput = TOOLBOXDIR + LONG + <STRING> <NEWLINE> scanner = MyScanner ( input , output , defsoutput ) <NEWLINE> scanner . scan ( ) <NEWLINE> scanner . gentypetest ( SHORT + <STRING> ) <NEWLINE> scanner . close ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> execfile ( defsoutput , { } , { } ) <NEWLINE> print ( <STRING> ) <NEWLINE> exec <STRING> + SHORT + <STRING> <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"CGContext.h\"", "\"gen.py\"", "\".py\"", "\"typetest.py\"", "\"=== Testing definitions output code ===\"", "\"=== Done scanning and generating, now importing the generated code... ===\"", "\"import \"", "\"support\"", "\"=== Done.  It's up to you to compile it now! ===\""]}, "err_obj": {"msg": "invalid syntax"}}], ["7e192449c9478132fb9cf3f1a330cc56", {"code_string": "def join(self, arg):\n    \"\"\"Join using the default separator.\"\"\"\n    ret = \"\"\n    try:\n        ret = self.sep.join(arg)\n    except TypeError, e:\n        ret = self.sep.join([str(item) for item in arg])\n    return ret\n", "code_toks_joined": "def join ( self , arg ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = <STRING> <NEWLINE> try : <NEWLINE> <INDENT> ret = self . sep . join ( arg ) <NEWLINE> <DEDENT> except TypeError , e : <NEWLINE> <INDENT> ret = self . sep . join ( [ str ( item ) for item in arg ] ) <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Join using the default separator.\"\"\"", "\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["6af25fc81c56e85f46d073f72145d80f", {"code_string": "def usage():\n    print(\"Usage: \")\n    print(\"python{} <username>\".format(argv[0])))\n", "code_toks_joined": "def usage ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . format ( argv [ 0 ] ) ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Usage: \"", "\"python{} <username>\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["aaec21e91abddf8999d315058fb7af70", {"code_string": "def getAllDownloadStatus(self):\n    log.debug('Checking Transmission download status.')\n    host = self.conf('host').split(':')\n    if not isInt(host[1]):\n        log.error('Config properties are not filled in correctly, port is missing.')\n        return False\n    try:\n        trpc = TransmissionRPC(host[0], port = host[1], username = self.conf('username'), password = self.conf('password'))\n        return_params = {\n            'fields': ['id', 'name', 'hashString', 'percentDone', 'status', 'eta', 'isFinished', 'downloadDir', 'uploadRatio']\n        }\n        queue = trpc.get_alltorrents(return_params)\n    except Exception, err:\n        log.error('Failed getting queue: %s', err)\n        return False\n    if not queue:\n        return[]\n    statuses = StatusList(self)\n    for item in queue['torrents']:\n        log.debug('name=%s / id=%s / downloadDir=%s / hashString=%s / percentDone=%s / status=%s / eta=%s / uploadRatio=%s / confRatio=%s / isFinished=%s', (item['name'], item['id'], item['downloadDir'], item['hashString'], item['percentDone'], item['status'], item['eta'], item['uploadRatio'], self.conf('ratio'), item['isFinished']))\n        if not os.path.isdir(Env.setting('from', 'renamer')):\n            log.error('Renamer \"from\" folder doesn\\'t to exist.')\n            return\n        if(item['percentDone'] * 100) >= 100 and(item['status'] == 6 or item['status'] == 0) and item['uploadRatio'] > self.conf('ratio'):\n            try:\n                trpc.stop_torrent(item['hashString'], {})\n                statuses.append({\n                    'id': item['hashString'],\n                    'name': item['name'],\n                    'status': 'completed',\n                    'original_status': item['status'],\n                    'timeleft': str(timedelta(seconds = 0)),\n                    'folder': os.path.join(item['downloadDir'], item['name']),\n                })\n                if((not os.path.isdir(item['downloadDir']))) and(self.conf('from') in item['downloadDir'])):\n                    trpc.remove_torrent(item['id'], \"true\", {})\n            except Exception, err:\n                log.error('Failed to stop and remove torrent \"%s\" with error: %s', (item['name'], err))\n                statuses.append({\n                    'id': item['hashString'],\n                    'name': item['name'],\n                    'status': 'failed',\n                    'original_status': item['status'],\n                    'timeleft': str(timedelta(seconds = 0)),\n                })\n        else:\n            statuses.append({\n                'id': item['hashString'],\n                'name': item['name'],\n                'status': 'busy',\n                'original_status': item['status'],\n                'timeleft': str(timedelta(seconds = item['eta'])),\n            })\n    return statuses\n", "code_toks_joined": "def getAllDownloadStatus ( self ) : <NEWLINE> <INDENT> log . debug ( <STRING> ) <NEWLINE> host = self . conf ( <STRING> ) . split ( <STRING> ) <NEWLINE> if not isInt ( host [ 1 ] ) : <NEWLINE> <INDENT> log . error ( <STRING> ) <NEWLINE> return False <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> trpc = TransmissionRPC ( host [ 0 ] , port = host [ 1 ] , username = self . conf ( <STRING> ) , password = self . conf ( <STRING> ) ) <NEWLINE> return_params = { <NEWLINE> <INDENT> <STRING> : [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <DEDENT> } <NEWLINE> queue = trpc . get_alltorrents ( return_params ) <NEWLINE> <DEDENT> except Exception , err : <NEWLINE> <INDENT> log . error ( <STRING> , err ) <NEWLINE> return False <NEWLINE> <DEDENT> if not queue : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> statuses = StatusList ( self ) <NEWLINE> for item in queue [ <STRING> ] : <NEWLINE> <INDENT> log . debug ( <STRING> , ( item [ <STRING> ] , item [ <STRING> ] , item [ <STRING> ] , item [ <STRING> ] , item [ <STRING> ] , item [ <STRING> ] , item [ <STRING> ] , item [ <STRING> ] , self . conf ( <STRING> ) , item [ <STRING> ] ) ) <NEWLINE> if not os . path . isdir ( Env . setting ( <STRING> , <STRING> ) ) : <NEWLINE> <INDENT> log . error ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> if ( item [ <STRING> ] * 100 ) >= 100 and ( item [ <STRING> ] == 6 or item [ <STRING> ] == 0 ) and item [ <STRING> ] > self . conf ( <STRING> ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> trpc . stop_torrent ( item [ <STRING> ] , { } ) <NEWLINE> statuses . append ( { <NEWLINE> <INDENT> <STRING> : item [ <STRING> ] , <NEWLINE> <STRING> : item [ <STRING> ] , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : item [ <STRING> ] , <NEWLINE> <STRING> : str ( timedelta ( seconds = 0 ) ) , <NEWLINE> <STRING> : os . path . join ( item [ <STRING> ] , item [ <STRING> ] ) , <NEWLINE> <DEDENT> } ) <NEWLINE> if ( ( not os . path . isdir ( item [ <STRING> ] ) ) ) and ( self . conf ( <STRING> ) in item [ <STRING> ] ) ) : <NEWLINE> <INDENT> trpc . remove_torrent ( item [ <STRING> ] , <STRING> , { } ) <NEWLINE> <DEDENT> <DEDENT> except Exception , err : <NEWLINE> <INDENT> log . error ( <STRING> , ( item [ <STRING> ] , err ) ) <NEWLINE> statuses . append ( { <NEWLINE> <INDENT> <STRING> : item [ <STRING> ] , <NEWLINE> <STRING> : item [ <STRING> ] , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : item [ <STRING> ] , <NEWLINE> <STRING> : str ( timedelta ( seconds = 0 ) ) , <NEWLINE> <DEDENT> } ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> statuses . append ( { <NEWLINE> <INDENT> <STRING> : item [ <STRING> ] , <NEWLINE> <STRING> : item [ <STRING> ] , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : item [ <STRING> ] , <NEWLINE> <STRING> : str ( timedelta ( seconds = item [ <STRING> ] ) ) , <NEWLINE> <DEDENT> } ) <NEWLINE> <DEDENT> <DEDENT> return statuses <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Checking Transmission download status.'", "'host'", "':'", "'Config properties are not filled in correctly, port is missing.'", "'username'", "'password'", "'fields'", "'id'", "'name'", "'hashString'", "'percentDone'", "'status'", "'eta'", "'isFinished'", "'downloadDir'", "'uploadRatio'", "'Failed getting queue: %s'", "'torrents'", "'name=%s / id=%s / downloadDir=%s / hashString=%s / percentDone=%s / status=%s / eta=%s / uploadRatio=%s / confRatio=%s / isFinished=%s'", "'name'", "'id'", "'downloadDir'", "'hashString'", "'percentDone'", "'status'", "'eta'", "'uploadRatio'", "'ratio'", "'isFinished'", "'from'", "'renamer'", "'Renamer \"from\" folder doesn\\'t to exist.'", "'percentDone'", "'status'", "'status'", "'uploadRatio'", "'ratio'", "'hashString'", "'id'", "'hashString'", "'name'", "'name'", "'status'", "'completed'", "'original_status'", "'status'", "'timeleft'", "'folder'", "'downloadDir'", "'name'", "'downloadDir'", "'from'", "'downloadDir'", "'id'", "\"true\"", "'Failed to stop and remove torrent \"%s\" with error: %s'", "'name'", "'id'", "'hashString'", "'name'", "'name'", "'status'", "'failed'", "'original_status'", "'status'", "'timeleft'", "'id'", "'hashString'", "'name'", "'name'", "'status'", "'busy'", "'original_status'", "'status'", "'timeleft'", "'eta'"]}, "window_span": [402, 436], "err_obj": {"msg": "unbalanced (){}[]"}}], ["32e00d096debcceadb8ceed7fc6771d6", {"code_string": "def broadcast(self, content = \"\"):\n    broadcast_msg = '{\"action\": \"broadcast\", \"content\": \"%s\"}' % content\n    try:\n        self.send_json(broadcast_msg.encode('utf-8'))\n        return True\n    except Exception, e:\n        return False\n", "code_toks_joined": "def broadcast ( self , content = <STRING> ) : <NEWLINE> <INDENT> broadcast_msg = <STRING> % content <NEWLINE> try : <NEWLINE> <INDENT> self . send_json ( broadcast_msg . encode ( <STRING> ) ) <NEWLINE> return True <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"", "'{\"action\": \"broadcast\", \"content\": \"%s\"}'", "'utf-8'"]}, "err_obj": {"msg": "invalid syntax"}}], ["f40aeb58d9a92ba67d2f0b25333da648", {"code_string": "def lasers(fname):\n    room = open(fname).readlines()\n    x, y, dx, dy = find_emitter(room)\n    while True:\n        x += dx\n        y += dy\n        char = room[y][x]\n        passage = {' ': (dx, dy),\n            '\\\\': (dy, dx),\n            '/': (- dy, - dx)}\n            dx, dy = passage[char]\n        else:\n            return char == 'x'\n", "code_toks_joined": "def lasers ( fname ) : <NEWLINE> <INDENT> room = open ( fname ) . readlines ( ) <NEWLINE> x , y , dx , dy = find_emitter ( room ) <NEWLINE> while True : <NEWLINE> <INDENT> x += dx <NEWLINE> y += dy <NEWLINE> char = room [ y ] [ x ] <NEWLINE> passage = { <STRING> : ( dx , dy ) , <NEWLINE> <INDENT> <STRING> : ( dy , dx ) , <NEWLINE> <STRING> : ( - dy , - dx ) } <NEWLINE> dx , dy = passage [ char ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return char == <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["' '", "'\\\\'", "'/'", "'x'"]}, "err_obj": {"msg": "unexpected indent"}}], ["6315ff941cc73ec4098769bacfaf8c6e", {"code_string": "class MidiTimeCirc(DelayCirc):\n    def split(self):\n        if(len(self.list) > 0):\n            split = max(self.list) - min(self.list)\n                return abs(split)\n        else:\n            return 0\n", "code_toks_joined": "class MidiTimeCirc ( DelayCirc ) : <NEWLINE> <INDENT> def split ( self ) : <NEWLINE> <INDENT> if ( len ( self . list ) > 0 ) : <NEWLINE> <INDENT> split = max ( self . list ) - min ( self . list ) <NEWLINE> <INDENT> return abs ( split ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["f573af2f8dfeb0f4de15c68870c31900", {"code_string": "def download_images(img_urls, dest_dir):\n    \"\"\"Given the urls already in the correct order, downloads\"\"\"\n    count = 0\n    if not os.access(dest_dir, \"F_OK\"):\n        os.makedirs(dest_dir)\n    os.chdir(dest_dir)\n    for url in img_urls:\n        image_binary = urllib2.urlopen(url)\n        with open(\"img%02d.jpg\" % count, \"w\") as img:\n            img.write(image_binary)\n        count += 1\n    with open(\"index.html\", \"w\") as index:\n        index.write(\"<!DOCTYPE html>\\n<html>\\n\\t<head>\\n\\t\\t<title>Puzzle Images</title>\\n\\t</head>\\n\\t<body>\\n\\t\\t<h1>Puzzle Images</h1>\\n\")\n        for url in img_urls:\n            image = urllib2.urlopen(url)\n            with open(\"img%02d.jpg\" % count\n            print(image)\n", "code_toks_joined": "def download_images ( img_urls , dest_dir ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> count = 0 <NEWLINE> if not os . access ( dest_dir , <STRING> ) : <NEWLINE> <INDENT> os . makedirs ( dest_dir ) <NEWLINE> <DEDENT> os . chdir ( dest_dir ) <NEWLINE> for url in img_urls : <NEWLINE> <INDENT> image_binary = urllib2 . urlopen ( url ) <NEWLINE> with open ( <STRING> % count , <STRING> ) as img : <NEWLINE> <INDENT> img . write ( image_binary ) <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> with open ( <STRING> , <STRING> ) as index : <NEWLINE> <INDENT> index . write ( <STRING> ) <NEWLINE> for url in img_urls : <NEWLINE> <INDENT> image = urllib2 . urlopen ( url ) <NEWLINE> with open ( <STRING> % count <NEWLINE> print ( image ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Given the urls already in the correct order, downloads\"\"\"", "\"F_OK\"", "\"img%02d.jpg\"", "\"w\"", "\"index.html\"", "\"w\"", "\"<!DOCTYPE html>\\n<html>\\n\\t<head>\\n\\t\\t<title>Puzzle Images</title>\\n\\t</head>\\n\\t<body>\\n\\t\\t<h1>Puzzle Images</h1>\\n\"", "\"img%02d.jpg\""]}, "window_span": [124, 137], "err_obj": {"msg": "unbalanced (){}[]"}}], ["a084cb8127176dabeafc70e424e9b269", {"code_string": "def warn_missing(element):\n    if element.tag not in action: print '============(%s)============' % element.tag\n    pass\n", "code_toks_joined": "def warn_missing ( element ) : <NEWLINE> <INDENT> if element . tag not in action : print <STRING> % element . tag <NEWLINE> pass <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'============(%s)============'"]}, "err_obj": {"msg": "invalid syntax"}}], ["30f56df59c0886109b9a6f841e73f2e3", {"code_string": "def module_load(m):\n    minst = None\n    exec \"\"\" from %(mod)s import %(mod)s\"\"\" %({'mod': m})\n    return minst\n", "code_toks_joined": "def module_load ( m ) : <NEWLINE> <INDENT> minst = None <NEWLINE> exec <STRING> % ( { <STRING> : m } ) <NEWLINE> return minst <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" from %(mod)s import %(mod)s\"\"\"", "'mod'"]}, "err_obj": {"msg": "invalid syntax"}}], ["e174d5097e25f18fc5a3df11500aa85f", {"code_string": "def change_display_name(step, display_name):\n    world.edit_component_and_select_settings()\n    index = world.get_setting_entry_index(DISPLAY_NAME)\n    world.set_field_value(index display_name)\n    world.save_component()\n", "code_toks_joined": "def change_display_name ( step , display_name ) : <NEWLINE> <INDENT> world . edit_component_and_select_settings ( ) <NEWLINE> index = world . get_setting_entry_index ( DISPLAY_NAME ) <NEWLINE> world . set_field_value ( index display_name ) <NEWLINE> world . save_component ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["6a0afdc58e656f21530bd53e122e8783", {"code_string": "def EndMapping(self, top_value, mapping):\n    \"\"\"When leaving scope, makes sure new object is initialized.\"\"\"\n    if not hasattr(mapping.value, 'CheckInitialized'):\n        raise validation.ValidationError('Cannot convert map to non-map value.')\n    try:\n        mapping.value.CheckInitialized()\n    except validation.ValidationError:\n        raise\n    except Exception, e:\n        try:\n            error_str = str(e)\n        except Exception:\n            error_str = '<unknown>'\n        raise validation.ValidationError(error_str, e)\n", "code_toks_joined": "def EndMapping ( self , top_value , mapping ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not hasattr ( mapping . value , <STRING> ) : <NEWLINE> <INDENT> raise validation . ValidationError ( <STRING> ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> mapping . value . CheckInitialized ( ) <NEWLINE> <DEDENT> except validation . ValidationError : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> error_str = str ( e ) <NEWLINE> <DEDENT> except Exception : <NEWLINE> <INDENT> error_str = <STRING> <NEWLINE> <DEDENT> raise validation . ValidationError ( error_str , e ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"When leaving scope, makes sure new object is initialized.\"\"\"", "'CheckInitialized'", "'Cannot convert map to non-map value.'", "'<unknown>'"]}, "err_obj": {"msg": "invalid syntax"}}], ["e6a6e2246791ef32af516b1ae9748b50", {"code_string": "\"\"\"This Class is a plugin for the Shinken Broker. It is in charge\"\"\"\nimport re\nfrom socket import socket\nimport cPickle\nimport struct\nfrom shinken.basemodule import BaseModule\nfrom shinken.log import logger\nfrom shinken.misc.perfdata import PerfDatas\nproperties = {\n    'daemons': ['broker'],\n    'type': 'graphite_perfdata',\n    ,\n    'external': False,\n}\n", "code_toks_joined": "<STRING> <NEWLINE> import re <NEWLINE> from socket import socket <NEWLINE> import cPickle <NEWLINE> import struct <NEWLINE> from shinken . basemodule import BaseModule <NEWLINE> from shinken . log import logger <NEWLINE> from shinken . misc . perfdata import PerfDatas <NEWLINE> properties = { <NEWLINE> <INDENT> <STRING> : [ <STRING> ] , <NEWLINE> <STRING> : <STRING> , <NEWLINE> , <NEWLINE> <STRING> : False , <NEWLINE> <DEDENT> } <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"\"\"This Class is a plugin for the Shinken Broker. It is in charge\"\"\"", "'daemons'", "'broker'", "'type'", "'graphite_perfdata'", "'external'"]}, "err_obj": {"msg": "invalid syntax"}}], ["658e33ec50beea46a137fcb261439733", {"code_string": "class DiffKind:\n    def __init__(self, a, b):\n    self.a = a\n    self.b = b\n    self.d_tag = 'diffkind'\n    def get_atom_kinds(self):\n    return[self]\n    def get_id_name(self):\n    return self.a.get_id_name() + '+' + self.b.get_id_name() + \"'\"\n", "code_toks_joined": "class DiffKind : <NEWLINE> <INDENT> def __init__ ( self , a , b ) : <NEWLINE> self . a = a <NEWLINE> self . b = b <NEWLINE> self . d_tag = <STRING> <NEWLINE> def get_atom_kinds ( self ) : <NEWLINE> return [ self ] <NEWLINE> def get_id_name ( self ) : <NEWLINE> return self . a . get_id_name ( ) + <STRING> + self . b . get_id_name ( ) + <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'diffkind'", "'+'", "\"'\""]}, "err_obj": {"msg": "expected an indented block"}}], ["e3132cbf13eb9632e017248321435d6a", {"code_string": "def start(self):\n    \"\"\" starts the event loop which handles commands until the receiver\"\"\"\n    try:\n        while self.running and not self.pipe.closed:\n            command = self.pipe.recv()\n            self.handle_command(command)\n            while self.running and(self._waiting_for_frame\n                or self._waiting_for_read_ahead):\n                time.sleep(1 / self.poll_frequency)\n                if self._waiting_for_frame:\n                self.try_getting_frame()\n                if self._waiting_for_read_ahead:\n                self.try_reading_ahead()\n    except(KeyboardInterrupt, SystemExit):\n        self.abort_iteration()\n", "code_toks_joined": "def start ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> while self . running and not self . pipe . closed : <NEWLINE> <INDENT> command = self . pipe . recv ( ) <NEWLINE> self . handle_command ( command ) <NEWLINE> while self . running and ( self . _waiting_for_frame <NEWLINE> <INDENT> or self . _waiting_for_read_ahead ) : <NEWLINE> time . sleep ( 1 / self . poll_frequency ) <NEWLINE> if self . _waiting_for_frame : <NEWLINE> self . try_getting_frame ( ) <NEWLINE> if self . _waiting_for_read_ahead : <NEWLINE> self . try_reading_ahead ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except ( KeyboardInterrupt , SystemExit ) : <NEWLINE> <INDENT> self . abort_iteration ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" starts the event loop which handles commands until the receiver\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["d598ef75e2babe6cd8285ad55bd9abfa", {"code_string": "def text_to_button(msg, color, buttonx, buttony, buttonwidth, buttonheight):\n    text = font.render(msg.zfill(2), True, rCBack)\n    text_rect = text.get_rect()\n    text_rect.center = ((buttonx +(buttonwidth / 2)), buttony +(buttonheight / 2)\n    screen.blit(text, text_rect)\n", "code_toks_joined": "def text_to_button ( msg , color , buttonx , buttony , buttonwidth , buttonheight ) : <NEWLINE> <INDENT> text = font . render ( msg . zfill ( 2 ) , True , rCBack ) <NEWLINE> text_rect = text . get_rect ( ) <NEWLINE> text_rect . center = ( ( buttonx + ( buttonwidth / 2 ) ) , buttony + ( buttonheight / 2 ) <NEWLINE> screen . blit ( text , text_rect ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["0bf09b809f04db5d7087055d260bb379", {"code_string": "class GitRevision(Revision):\n    def __init__(self, project_name, revision, branch, author,\n        comments, files, change_ts,\n        codebase = None, revision_link = None, repository = None):\n        self.project = project_name\n        self.revision = revision\n        self.author = author\n        self.branch = branch\n        self.comments = comments\n        self.files = files\n        self.change_ts = change_ts\n        if revision_link:\n        self.revlink = revision_link\n        if repository:\n        self.repository = repository\n        if codebase:\n        self.codebase = codebase\n", "code_toks_joined": "class GitRevision ( Revision ) : <NEWLINE> <INDENT> def __init__ ( self , project_name , revision , branch , author , <NEWLINE> <INDENT> comments , files , change_ts , <NEWLINE> codebase = None , revision_link = None , repository = None ) : <NEWLINE> self . project = project_name <NEWLINE> self . revision = revision <NEWLINE> self . author = author <NEWLINE> self . branch = branch <NEWLINE> self . comments = comments <NEWLINE> self . files = files <NEWLINE> self . change_ts = change_ts <NEWLINE> if revision_link : <NEWLINE> self . revlink = revision_link <NEWLINE> if repository : <NEWLINE> self . repository = repository <NEWLINE> if codebase : <NEWLINE> self . codebase = codebase <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["164ffd1e99f5adb70ef10444d37d6d3d", {"code_string": "class _AssertRaisesBaseContext(object):\n    def __init__(self, expected, test_case, callable_obj = None,\n        expected_regex = None):\n        self.expected = expected\n        self.failureException = test_case.failureException\n        self.obj_name = None\n        if isinstance(expected_regex, basestring):\n        expected_regex = re.compile(expected_regex)\n        self.expected_regex = expected_regex\n", "code_toks_joined": "class _AssertRaisesBaseContext ( object ) : <NEWLINE> <INDENT> def __init__ ( self , expected , test_case , callable_obj = None , <NEWLINE> <INDENT> expected_regex = None ) : <NEWLINE> self . expected = expected <NEWLINE> self . failureException = test_case . failureException <NEWLINE> self . obj_name = None <NEWLINE> if isinstance ( expected_regex , basestring ) : <NEWLINE> expected_regex = re . compile ( expected_regex ) <NEWLINE> self . expected_regex = expected_regex <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["eb6b82947cec06547410de38e70e3c3f", {"code_string": "def testAlias(self):\n    \"\"\" Playing with aliases \"\"\"\n    sheet = self.doc.addObject(\"Spreadsheet: :Sheet\", \"Calc\")\n    sheet.setAlias(\"A1\", \"Test\")\n    self.assertEqual(sheet.getAlias(\"A1\"), \"Test\")\n    sheet.set(\"A1\", \"4711\")\n    self.doc.recompute()\n    self.assertEqual(sheet.get(\"Test\"), 4711)\n    self.assertEqual(sheet.get(\"Test\"), sheet.get(\"A1\")))\n", "code_toks_joined": "def testAlias ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> sheet = self . doc . addObject ( <STRING> , <STRING> ) <NEWLINE> sheet . setAlias ( <STRING> , <STRING> ) <NEWLINE> self . assertEqual ( sheet . getAlias ( <STRING> ) , <STRING> ) <NEWLINE> sheet . set ( <STRING> , <STRING> ) <NEWLINE> self . doc . recompute ( ) <NEWLINE> self . assertEqual ( sheet . get ( <STRING> ) , 4711 ) <NEWLINE> self . assertEqual ( sheet . get ( <STRING> ) , sheet . get ( <STRING> ) ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Playing with aliases \"\"\"", "\"Spreadsheet: :Sheet\"", "\"Calc\"", "\"A1\"", "\"Test\"", "\"A1\"", "\"Test\"", "\"A1\"", "\"4711\"", "\"Test\"", "\"Test\"", "\"A1\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["1eadbdc67cebebd72200fb9da77ff74a", {"code_string": "def parse_exif_time(filename):\n    '''parse a timestamp from exif data'''\n    basename = os.path.basename(filename)\n        if basename.lower().endswith('.jpg') or basename.lower().endswith('.jpeg'):\n            try:\n                from.import mav_position\n                return mav_position.exif_timestamp(filename)\n            except Exception as e:\n                print(\"Failed to get EXIF timestamp: %s\" % e)\n                return 0\n        return 0\n", "code_toks_joined": "def parse_exif_time ( filename ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> basename = os . path . basename ( filename ) <NEWLINE> <INDENT> if basename . lower ( ) . endswith ( <STRING> ) or basename . lower ( ) . endswith ( <STRING> ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> from . import mav_position <NEWLINE> return mav_position . exif_timestamp ( filename ) <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> <INDENT> print ( <STRING> % e ) <NEWLINE> return 0 <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''parse a timestamp from exif data'''", "'.jpg'", "'.jpeg'", "\"Failed to get EXIF timestamp: %s\""]}, "err_obj": {"msg": "unexpected indent"}}], ["aa62d9241a74d132db82ee5df282a430", {"code_string": "def ShowOption(self, e):\n    chgopt = ChangeOptions(None, title = 'Change Wallet Options')\n        chgopt.ShowModal()\n        chgopt.Destroy()\n    return\n", "code_toks_joined": "def ShowOption ( self , e ) : <NEWLINE> <INDENT> chgopt = ChangeOptions ( None , title = <STRING> ) <NEWLINE> <INDENT> chgopt . ShowModal ( ) <NEWLINE> chgopt . Destroy ( ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Change Wallet Options'"]}, "err_obj": {"msg": "unexpected indent"}}], ["df7f7f2ceeb21882de5dd48ae89867b1", {"code_string": "def put_plugin(self, psa_id, name = None, new_url = None, token = None):\n    url = self.base_url + 'PSA/M2Lplugins/' + psa_id + '/'\n        params = {}\n        if token:\n            params['token'] = token\n    if name:\n        params['name'] = name\n    if new_url:\n        params['new_url'] = new_url\n    return put(url, params = params)\n", "code_toks_joined": "def put_plugin ( self , psa_id , name = None , new_url = None , token = None ) : <NEWLINE> <INDENT> url = self . base_url + <STRING> + psa_id + <STRING> <NEWLINE> <INDENT> params = { } <NEWLINE> if token : <NEWLINE> <INDENT> params [ <STRING> ] = token <NEWLINE> <DEDENT> <DEDENT> if name : <NEWLINE> <INDENT> params [ <STRING> ] = name <NEWLINE> <DEDENT> if new_url : <NEWLINE> <INDENT> params [ <STRING> ] = new_url <NEWLINE> <DEDENT> return put ( url , params = params ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'PSA/M2Lplugins/'", "'/'", "'token'", "'name'", "'new_url'"]}, "err_obj": {"msg": "unexpected indent"}}], ["0eeee98ec8c2a49132dec201feae78b5", {"code_string": "def _get_datafile(self, handle):\n    \"\"\"Return path to datafile corresponding to given handle.\"\"\"\n    datafile = None\n    datafiletype = None\n    for dfiletype in(persistence.pddatafile, persistence.npdatafile,\n        persistence.pydatafile):\n        dfile = os.path.join(self._backend.get_location(),\n            handle, dfiletype)\n            if os.path.exists(dfile):\n            datafile = dfile\n            datafiletype = dfiletype\n    return(datafile, datafiletype)\n", "code_toks_joined": "def _get_datafile ( self , handle ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> datafile = None <NEWLINE> datafiletype = None <NEWLINE> for dfiletype in ( persistence . pddatafile , persistence . npdatafile , <NEWLINE> <INDENT> persistence . pydatafile ) : <NEWLINE> dfile = os . path . join ( self . _backend . get_location ( ) , <NEWLINE> <INDENT> handle , dfiletype ) <NEWLINE> if os . path . exists ( dfile ) : <NEWLINE> datafile = dfile <NEWLINE> datafiletype = dfiletype <NEWLINE> <DEDENT> <DEDENT> return ( datafile , datafiletype ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return path to datafile corresponding to given handle.\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["e71ace148d7746239367d40b3cee5996", {"code_string": "def makeSafeFilename(inputFilename):\n    try:\n    safechars = string.letters + string.digits + \" -_.\"\n    return filter(lambda c: c in safechars, inputFilename).replace(\" \", \"_\")\n    except:\n    return \"\"\n    pass\n", "code_toks_joined": "def makeSafeFilename ( inputFilename ) : <NEWLINE> <INDENT> try : <NEWLINE> safechars = string . letters + string . digits + <STRING> <NEWLINE> return filter ( lambda c : c in safechars , inputFilename ) . replace ( <STRING> , <STRING> ) <NEWLINE> except : <NEWLINE> return <STRING> <NEWLINE> pass <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\" -_.\"", "\" \"", "\"_\"", "\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["247eaa222c592824478b44f8eef301e7", {"code_string": "\"\"\"test_modparc\"\"\"\nfrom funcparserlib.parser import skip, finished\nimport modparc\nfrom modparc.syntax import tokenize\ndef verify_parsed_result(source_code, parser,\n    subelement_type, subelement_code):\n    \"\"\"Verify the parsed result contain a predefined set of subelements\"\"\"\n    tokens = tokenize(source_code)\n    parsed_element = (parser + skip(finished)).parse(tokens)\n    subelements = parsed_element.search(subelement_type)\n    assert len(subelements) == len(subelement_code)\n    for(i, parsed_subelements) in enumerate(subelements):\n    assert parsed_subelements.code() == subelement_code[i]\n", "code_toks_joined": "<STRING> <NEWLINE> from funcparserlib . parser import skip , finished <NEWLINE> import modparc <NEWLINE> from modparc . syntax import tokenize <NEWLINE> def verify_parsed_result ( source_code , parser , <NEWLINE> <INDENT> subelement_type , subelement_code ) : <NEWLINE> <STRING> <NEWLINE> tokens = tokenize ( source_code ) <NEWLINE> parsed_element = ( parser + skip ( finished ) ) . parse ( tokens ) <NEWLINE> subelements = parsed_element . search ( subelement_type ) <NEWLINE> assert len ( subelements ) == len ( subelement_code ) <NEWLINE> for ( i , parsed_subelements ) in enumerate ( subelements ) : <NEWLINE> assert parsed_subelements . code ( ) == subelement_code [ i ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"test_modparc\"\"\"", "\"\"\"Verify the parsed result contain a predefined set of subelements\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["323d7b6e4653065a87656be8f0288211", {"code_string": "def is_on_firewall(self, mac):\n    r = False\n    for m in self.list():\n        if m == mac:\n        r = True\n        break\n        else:\n        r = False\n    return r\n", "code_toks_joined": "def is_on_firewall ( self , mac ) : <NEWLINE> <INDENT> r = False <NEWLINE> for m in self . list ( ) : <NEWLINE> <INDENT> if m == mac : <NEWLINE> r = True <NEWLINE> break <NEWLINE> else : <NEWLINE> r = False <NEWLINE> <DEDENT> return r <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["47b0132f47879bb3c0c32d73fce04652", {"code_string": "def any(iterable)\n    for element in iterable:\n        if element:\n            return True\n    return False\n", "code_toks_joined": "def any ( iterable ) <NEWLINE> <INDENT> for element in iterable : <NEWLINE> <INDENT> if element : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["71a0631425d86f0ba879b92c6cceb6ba", {"code_string": "def show_html(self):\n    for obj in self.ui_objects:\n        print(obj.get_html()\n", "code_toks_joined": "def show_html ( self ) : <NEWLINE> <INDENT> for obj in self . ui_objects : <NEWLINE> <INDENT> print ( obj . get_html ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["bf93458b5be407e36b29f6bdff871243", {"code_string": "def karatsubaMultiplication(a, b):\n    if(a < 10) or(b < 10)\n        return a * b\n    low1\n    z0 = karatsubaMultiplication(low1, low2)\n    z1 = karatsubaMultiplication(low1 + high1, low2 + high2)\n    z2 = karatsubaMultiplication(high1, high2)\n    return\n", "code_toks_joined": "def karatsubaMultiplication ( a , b ) : <NEWLINE> <INDENT> if ( a < 10 ) or ( b < 10 ) <NEWLINE> <INDENT> return a * b <NEWLINE> <DEDENT> low1 <NEWLINE> z0 = karatsubaMultiplication ( low1 , low2 ) <NEWLINE> z1 = karatsubaMultiplication ( low1 + high1 , low2 + high2 ) <NEWLINE> z2 = karatsubaMultiplication ( high1 , high2 ) <NEWLINE> return <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["5af5814095728e5abc37f2af5aa46234", {"code_string": "def rtype_setitem((r_lst, r_int), hop):\n    if hop.has_implicit_exception(IndexError):\n        spec = dum_checkidx\n    else:\n        spec = dum_nocheck\n    v_func = hop.inputconst(Void, spec)\n    v_lst, v_index, v_item = hop.inputargs(r_lst, Signed, r_lst.item_repr)\n    if hop.args_s[1].nonneg:\n        llfn = ll_setitem_nonneg\n    else:\n        llfn = ll_setitem\n    hop.exception_is_here()\n    return hop.gendirectcall(llfn, v_func, v_lst, v_index, v_item)\n", "code_toks_joined": "def rtype_setitem ( ( r_lst , r_int ) , hop ) : <NEWLINE> <INDENT> if hop . has_implicit_exception ( IndexError ) : <NEWLINE> <INDENT> spec = dum_checkidx <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> spec = dum_nocheck <NEWLINE> <DEDENT> v_func = hop . inputconst ( Void , spec ) <NEWLINE> v_lst , v_index , v_item = hop . inputargs ( r_lst , Signed , r_lst . item_repr ) <NEWLINE> if hop . args_s [ 1 ] . nonneg : <NEWLINE> <INDENT> llfn = ll_setitem_nonneg <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> llfn = ll_setitem <NEWLINE> <DEDENT> hop . exception_is_here ( ) <NEWLINE> return hop . gendirectcall ( llfn , v_func , v_lst , v_index , v_item ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["f70afd7414870672aabc52e22a8a92ef", {"code_string": "class Ui_Dialog(object):\n    def setupUi(self, Dialog):\n        Dialog.setObjectName(_fromUtf8(\"Dialog\"))\n        Dialog.setFixedSize(362, 241)\n        self.textBrowser = QtGui.QTextBrowser(Dialog)\n        self.textBrowser.setGeometry(QtCore.QRect(10, 10, 341, 221))\n        self.textBrowser.setObjectName(_fromUtf8(\"textBrowser\"))\n        self.retranslateUi(Dialog)\n        QtCore.QMetaObject.connectSlotsByName(Dialog)\n    def retranslateUi(self, Dialog):\n        Dialog.setWindowTitle(_translate(\"Dialog\", \"Dialog\", None))\n        self.textBrowser.setHtml(_translate(\"Dialog\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "class Ui_Dialog ( object ) : <NEWLINE> <INDENT> def setupUi ( self , Dialog ) : <NEWLINE> <INDENT> Dialog . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> Dialog . setFixedSize ( 362 , 241 ) <NEWLINE> self . textBrowser = QtGui . QTextBrowser ( Dialog ) <NEWLINE> self . textBrowser . setGeometry ( QtCore . QRect ( 10 , 10 , 341 , 221 ) ) <NEWLINE> self . textBrowser . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . retranslateUi ( Dialog ) <NEWLINE> QtCore . QMetaObject . connectSlotsByName ( Dialog ) <NEWLINE> <DEDENT> def retranslateUi ( self , Dialog ) : <NEWLINE> <INDENT> Dialog . setWindowTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . textBrowser . setHtml ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Dialog\"", "\"textBrowser\"", "\"Dialog\"", "\"Dialog\"", "\"Dialog\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "window_span": [126, 135], "err_obj": {"msg": "unbalanced (){}[]"}}], ["668e48d557fb09e68cefbb273d9952f0", {"code_string": "def __init__(self, screen, (posX, posY)):\n    super(tickBox, self).__init__(screen, (posX, posY))\n    self.box = pygame.image.load(\"buttons/box.png\")\n    self.boxTicked = pygame.image.load(\"buttons/box1.png\")\n    self.box.convert_alpha()\n    self.boxTicked.convert_alpha()\n    return\n", "code_toks_joined": "def __init__ ( self , screen , ( posX , posY ) ) : <NEWLINE> <INDENT> super ( tickBox , self ) . __init__ ( screen , ( posX , posY ) ) <NEWLINE> self . box = pygame . image . load ( <STRING> ) <NEWLINE> self . boxTicked = pygame . image . load ( <STRING> ) <NEWLINE> self . box . convert_alpha ( ) <NEWLINE> self . boxTicked . convert_alpha ( ) <NEWLINE> return <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"buttons/box.png\"", "\"buttons/box1.png\""]}, "err_obj": {"msg": "invalid syntax"}}], ["8baac72ada133d1a09459a5df0bd7efd", {"code_string": "def collect_tax(self, sender, amount):\n    self.send_message(sender, messages.Inform(\n        messages.MetaInfo(self, sender),\n        \"Tax received %02.2f from %s\" %(amount, sender.get_id())\n    )\n    self.capital += amount\n    if not sender in self._taxes:\n        self._taxes[sender] = []\n    self._taxes[sender].append(amount)\n", "code_toks_joined": "def collect_tax ( self , sender , amount ) : <NEWLINE> <INDENT> self . send_message ( sender , messages . Inform ( <NEWLINE> <INDENT> messages . MetaInfo ( self , sender ) , <NEWLINE> <STRING> % ( amount , sender . get_id ( ) ) <NEWLINE> <DEDENT> ) <NEWLINE> self . capital += amount <NEWLINE> if not sender in self . _taxes : <NEWLINE> <INDENT> self . _taxes [ sender ] = [ ] <NEWLINE> <DEDENT> self . _taxes [ sender ] . append ( amount ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Tax received %02.2f from %s\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["b8d5224a61dbf7813623d9cc92c0f9d6", {"code_string": "\"\"\"Functional tests using WebTest.\"\"\"\nimport pytest\nfrom flask import url_for\nfrom{{cookiecutter.app_name}}.user.models import User\nfrom.factories import UserFactory\n", "code_toks_joined": "<STRING> <NEWLINE> import pytest <NEWLINE> from flask import url_for <NEWLINE> from { { cookiecutter . app_name } } . user . models import User <NEWLINE> from . factories import UserFactory <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"\"\"Functional tests using WebTest.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["392b1070d6b96ac26172952ec10f9c95", {"code_string": "class DispersiveDecay(VNATimeResolvedDispersiveMeasurement1D):\n    def __init__(self, name, sample_name, vna_name, ro_awg, q_awg,\n        q_lo_name, line_attenuation_db = 60):\n        super().__init__(name, sample_name, vna_name, ro_awg, q_awg,\n            q_lo_name, line_attenuation_db)\n            self._measurement_result = DispersiveDecayResult(name,\n            sample_name)\n            self._sequence_generator = PulseBuilder.build_dispersive_decay_sequences\n            self._swept_parameter_name = \"readout_delay\"\n    def set_swept_parameters(self, readout_delays):\n        super().set_swept_parameters(self._swept_parameter_name, readout_delays)\n", "code_toks_joined": "class DispersiveDecay ( VNATimeResolvedDispersiveMeasurement1D ) : <NEWLINE> <INDENT> def __init__ ( self , name , sample_name , vna_name , ro_awg , q_awg , <NEWLINE> <INDENT> q_lo_name , line_attenuation_db = 60 ) : <NEWLINE> super ( ) . __init__ ( name , sample_name , vna_name , ro_awg , q_awg , <NEWLINE> <INDENT> q_lo_name , line_attenuation_db ) <NEWLINE> self . _measurement_result = DispersiveDecayResult ( name , <NEWLINE> sample_name ) <NEWLINE> self . _sequence_generator = PulseBuilder . build_dispersive_decay_sequences <NEWLINE> self . _swept_parameter_name = <STRING> <NEWLINE> <DEDENT> <DEDENT> def set_swept_parameters ( self , readout_delays ) : <NEWLINE> <INDENT> super ( ) . set_swept_parameters ( self . _swept_parameter_name , readout_delays ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"readout_delay\""]}, "err_obj": {"msg": "unexpected indent"}}], ["dd4d42cdbf966b095e5c7a5d229be926", {"code_string": "def removeCoverageFromPreviousRun():\n    \"\"\"If the class files change between runs, we get confusing results.\"\"\"\n    for f in(os.path.join(os.environ['HOME'], 'cobertura.ser'),\n        'cobertura.ser'):\n        try:\n        os.unlink(f)\n        except OSError:\n        pass\n", "code_toks_joined": "def removeCoverageFromPreviousRun ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for f in ( os . path . join ( os . environ [ <STRING> ] , <STRING> ) , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> try : <NEWLINE> os . unlink ( f ) <NEWLINE> except OSError : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"If the class files change between runs, we get confusing results.\"\"\"", "'HOME'", "'cobertura.ser'", "'cobertura.ser'"]}, "err_obj": {"msg": "expected an indented block"}}], ["88c3443282177fcdeb62f490df9fac41", {"code_string": "def register_xf86_keys(keybinder):\n    try:\n        inhibit_power_button()\n    except Exception as e:\n        notify('%s inhibiting systemd handle-power-key & handle-lid-switch: %s' %(e.__class__.__name__, str(e)), timeout = 5000)\n            raise\n    keybinder.bind_key(0, 'XF86_PowerOff', power_button)\n", "code_toks_joined": "def register_xf86_keys ( keybinder ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> inhibit_power_button ( ) <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> <INDENT> notify ( <STRING> % ( e . __class__ . __name__ , str ( e ) ) , timeout = 5000 ) <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> <DEDENT> keybinder . bind_key ( 0 , <STRING> , power_button ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'%s inhibiting systemd handle-power-key & handle-lid-switch: %s'", "'XF86_PowerOff'"]}, "err_obj": {"msg": "unexpected indent"}}], ["7e4a9f9baa36e30efcc800d63da7ee3c", {"code_string": "def xml_add_text_tags(doc, root_node, tags):\n    \"\"\"RSS feed helper function.\"\"\"\n    for pair in tags:\n        name, value = pair\n        channelTag = doc.createElement(name)\n        channelTag.appendChild(doc.createTextNode(unicode(value))\n        root_node.appendChild(channelTag)\n", "code_toks_joined": "def xml_add_text_tags ( doc , root_node , tags ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for pair in tags : <NEWLINE> <INDENT> name , value = pair <NEWLINE> channelTag = doc . createElement ( name ) <NEWLINE> channelTag . appendChild ( doc . createTextNode ( unicode ( value ) ) <NEWLINE> root_node . appendChild ( channelTag ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"RSS feed helper function.\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["31375c09fad9b4d84ec865597e6563d5", {"code_string": "class FileParseError(ParsecError):\n    \"\"\"An error raised when attempting to read in the config file(s).\"\"\"\n    def __init__(self, reason, index = None, line = None, lines = None,\n        error_name = \"FileParseError\"):\n        self.msg = error_name + \":\\n\" + reason\n        if index:\n        self.msg += \" (line \" + str(index + 1) + \")\"\n        if line:\n        self.msg += \":\\n   \" + line.strip()\n        if lines:\n        self.msg += \"\\nContext lines:\\n\" + \"\\n\".join(lines)\n        self.msg += \"\\t<-- \" + error_name\n        if index:\n        self.msg += \"\\n(line numbers match 'cylc view -p')\"\n", "code_toks_joined": "class FileParseError ( ParsecError ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , reason , index = None , line = None , lines = None , <NEWLINE> <INDENT> error_name = <STRING> ) : <NEWLINE> self . msg = error_name + <STRING> + reason <NEWLINE> if index : <NEWLINE> self . msg += <STRING> + str ( index + 1 ) + <STRING> <NEWLINE> if line : <NEWLINE> self . msg += <STRING> + line . strip ( ) <NEWLINE> if lines : <NEWLINE> self . msg += <STRING> + <STRING> . join ( lines ) <NEWLINE> self . msg += <STRING> + error_name <NEWLINE> if index : <NEWLINE> self . msg += <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"An error raised when attempting to read in the config file(s).\"\"\"", "\"FileParseError\"", "\":\\n\"", "\" (line \"", "\")\"", "\":\\n   \"", "\"\\nContext lines:\\n\"", "\"\\n\"", "\"\\t<-- \"", "\"\\n(line numbers match 'cylc view -p')\""]}, "err_obj": {"msg": "expected an indented block"}}], ["192a0b9551ca1504c412bbcb844f4da6", {"code_string": "class GetterBy(list):\n    \"sort of like a read-only dict for namedtuple. inherits from list so it's iterable\"\n    def __init__(self, tups): super(GetterBy, self).__init__(tups)\n    def __getitem__(self, (key, value)): return next(x for x in self if getattr(x, key) == value)\n    def __contains__(self, (key, value)): return any(getattr(x, key) == value for x in self)\n", "code_toks_joined": "class GetterBy ( list ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , tups ) : super ( GetterBy , self ) . __init__ ( tups ) <NEWLINE> def __getitem__ ( self , ( key , value ) ) : return next ( x for x in self if getattr ( x , key ) == value ) <NEWLINE> def __contains__ ( self , ( key , value ) ) : return any ( getattr ( x , key ) == value for x in self ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"sort of like a read-only dict for namedtuple. inherits from list so it's iterable\""]}, "err_obj": {"msg": "invalid syntax"}}], ["53ec79e3176de487476cfb40240dde6d", {"code_string": "def is_int(x):\n    if x == int(x):\n        return True\n        else:\n        return False\n", "code_toks_joined": "def is_int ( x ) : <NEWLINE> <INDENT> if x == int ( x ) : <NEWLINE> <INDENT> return True <NEWLINE> else : <NEWLINE> return False <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["418407139b239d3c8cd2e9022afe4f78", {"code_string": "def test_top(self):\n    msgs = (\"this\", \"test\", \"should\", \"pass\")\n    tb = gr.top_block()\n    src = demo_msg_src(msgs)\n    sink = demo_msg_sink(len(msgs)\n    tb.connect(src, sink)\n    tb.run()\n    self.assertItemsEqual(sink.msgs(), msgs)\n", "code_toks_joined": "def test_top ( self ) : <NEWLINE> <INDENT> msgs = ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> tb = gr . top_block ( ) <NEWLINE> src = demo_msg_src ( msgs ) <NEWLINE> sink = demo_msg_sink ( len ( msgs ) <NEWLINE> tb . connect ( src , sink ) <NEWLINE> tb . run ( ) <NEWLINE> self . assertItemsEqual ( sink . msgs ( ) , msgs ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"this\"", "\"test\"", "\"should\"", "\"pass\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e1ef809b073dcd9e2523d4b0b027f846", {"code_string": "def test_sigchain_fileobj(self):\n    \"\"\"Test getting signature chain fileobjs from archive_dir\"\"\"\n    self.set_gpg_profile()\n    self.sigchain_fileobj_check_list(self.sigchain_fileobj_get(1)\n    self.sigchain_fileobj_check_list(self.sigchain_fileobj_get(None))\n", "code_toks_joined": "def test_sigchain_fileobj ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . set_gpg_profile ( ) <NEWLINE> self . sigchain_fileobj_check_list ( self . sigchain_fileobj_get ( 1 ) <NEWLINE> self . sigchain_fileobj_check_list ( self . sigchain_fileobj_get ( None ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Test getting signature chain fileobjs from archive_dir\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["73a263e327e6653d17f2fa3f1dcfd272", {"code_string": "def updateBounds(bounds, (x, y), min = min, max = max):\n    \"\"\"Return the bounding recangle of rectangle bounds and point (x, y).\"\"\"\n    xMin, yMin, xMax, yMax = bounds\n    return min(xMin, x), min(yMin, y), max(xMax, x), max(yMax, y)\n", "code_toks_joined": "def updateBounds ( bounds , ( x , y ) , min = min , max = max ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> xMin , yMin , xMax , yMax = bounds <NEWLINE> return min ( xMin , x ) , min ( yMin , y ) , max ( xMax , x ) , max ( yMax , y ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return the bounding recangle of rectangle bounds and point (x, y).\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["0f9a56f2662fe13b1d985c485a21b989", {"code_string": "def password_md5(s):\n    \"\"\"Funkcija za hasanje gesel.\"\"\"\n    h = hashlib.md5()\n    h.update(s.encode('utf-8')\n    return h.hexdigest()\n", "code_toks_joined": "def password_md5 ( s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> h = hashlib . md5 ( ) <NEWLINE> h . update ( s . encode ( <STRING> ) <NEWLINE> return h . hexdigest ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Funkcija za hasanje gesel.\"\"\"", "'utf-8'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["3e84448df57940eaa030eece0034a798", {"code_string": "def testDepthwiseConv2DInputGradCompare(self):\n    for index, (input_size, filter_size, output_size, stride,\n        padding) in enumerate(ConfigsToTest()):\n        print(\"Testing DepthwiseConv2DInputGradCompare,\", index, \"th config:\",\n        input_size, \"*\", filter_size, \"stride:\", stride, \"padding:\",\n        padding)\n        self._CompareBackpropInputFloat(input_size, filter_size, output_size,\n            stride, padding)\n            self._CompareBackpropInputDouble(input_size, filter_size, output_size,\n                stride, padding)\n", "code_toks_joined": "def testDepthwiseConv2DInputGradCompare ( self ) : <NEWLINE> <INDENT> for index , ( input_size , filter_size , output_size , stride , <NEWLINE> <INDENT> padding ) in enumerate ( ConfigsToTest ( ) ) : <NEWLINE> print ( <STRING> , index , <STRING> , <NEWLINE> input_size , <STRING> , filter_size , <STRING> , stride , <STRING> , <NEWLINE> padding ) <NEWLINE> self . _CompareBackpropInputFloat ( input_size , filter_size , output_size , <NEWLINE> <INDENT> stride , padding ) <NEWLINE> self . _CompareBackpropInputDouble ( input_size , filter_size , output_size , <NEWLINE> <INDENT> stride , padding ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Testing DepthwiseConv2DInputGradCompare,\"", "\"th config:\"", "\"*\"", "\"stride:\"", "\"padding:\""]}, "err_obj": {"msg": "unexpected indent"}}], ["10ef680d64170f0339a9518777c1b2ba", {"code_string": "def polyfunc2d((x, y), a, b, c, d, e, f):\n    u = a + b * x + c * y + d *(x ** 2) + e * x * y + f *(y ** 2)\n    return u\n", "code_toks_joined": "def polyfunc2d ( ( x , y ) , a , b , c , d , e , f ) : <NEWLINE> <INDENT> u = a + b * x + c * y + d * ( x ** 2 ) + e * x * y + f * ( y ** 2 ) <NEWLINE> return u <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["c40ed016a4358259c5f0f69d3f7892c9", {"code_string": "class TipoTaxonAdmin(admin.ModelAdmin):\n    list_display = ('id', 'nombre', 'tiptax', 'estatu', )\n    list_editable = ('estatu', )\n    def formfield_for_foreignkey(self, db_field, request, ** kwargs):\n        if db_field.name == \"userupdate\":\n            kwargs[\"queryset\"] = User.objects.filter(id = request.user.id)\n        return super(TipoTaxonAdmin, self).formfield_for_foreignkey(db_field, request, ** kwargs)\n    class Media:\n    js = ('/js/tiny_mce/tiny_mce.js', '/js/textareas.js')\n", "code_toks_joined": "class TipoTaxonAdmin ( admin . ModelAdmin ) : <NEWLINE> <INDENT> list_display = ( <STRING> , <STRING> , <STRING> , <STRING> , ) <NEWLINE> list_editable = ( <STRING> , ) <NEWLINE> def formfield_for_foreignkey ( self , db_field , request , ** kwargs ) : <NEWLINE> <INDENT> if db_field . name == <STRING> : <NEWLINE> <INDENT> kwargs [ <STRING> ] = User . objects . filter ( id = request . user . id ) <NEWLINE> <DEDENT> return super ( TipoTaxonAdmin , self ) . formfield_for_foreignkey ( db_field , request , ** kwargs ) <NEWLINE> <DEDENT> class Media : <NEWLINE> js = ( <STRING> , <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'id'", "'nombre'", "'tiptax'", "'estatu'", "'estatu'", "\"userupdate\"", "\"queryset\"", "'/js/tiny_mce/tiny_mce.js'", "'/js/textareas.js'"]}, "err_obj": {"msg": "expected an indented block"}}], ["010a48681999e1baf52a1cba56147446", {"code_string": "def _get_node_and_metadata_for_path(self, path):\n    d = self._get_root(path)\n    def _got_root((root, path)):\n        if path:\n            return root.get_child_and_metadata_at_path(path)\n        else:\n            return(root, {})\n    d.addCallback(_got_root)\n    return d\n", "code_toks_joined": "def _get_node_and_metadata_for_path ( self , path ) : <NEWLINE> <INDENT> d = self . _get_root ( path ) <NEWLINE> def _got_root ( ( root , path ) ) : <NEWLINE> <INDENT> if path : <NEWLINE> <INDENT> return root . get_child_and_metadata_at_path ( path ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( root , { } ) <NEWLINE> <DEDENT> <DEDENT> d . addCallback ( _got_root ) <NEWLINE> return d <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["e64e371c860a1819bac8ca22bba9e051", {"code_string": "def reset(self):\n    \"\"\"Returns void\"\"\"\n    try:\n        _lock.writeLock().lock()\n        _cache.clear()\n    final:\n        _lock.writeLock().unlock()\n", "code_toks_joined": "def reset ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> _lock . writeLock ( ) . lock ( ) <NEWLINE> _cache . clear ( ) <NEWLINE> <DEDENT> final : <NEWLINE> <INDENT> _lock . writeLock ( ) . unlock ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns void\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["7da6eb371446a09f518bcbdf87e92b0f", {"code_string": "def setup(topdir):\n    srcdir = os.path.join(topdir, 'src')\n    os.chdir(srcdir)\n    utils.configure('--with-elfutils=elfutils --prefix=%s/systemtap' % topdir)\n    utils.make('-j %d' % utils.count_cpus()\n    utils.make('install')\n    os.chdir(topdir)\n", "code_toks_joined": "def setup ( topdir ) : <NEWLINE> <INDENT> srcdir = os . path . join ( topdir , <STRING> ) <NEWLINE> os . chdir ( srcdir ) <NEWLINE> utils . configure ( <STRING> % topdir ) <NEWLINE> utils . make ( <STRING> % utils . count_cpus ( ) <NEWLINE> utils . make ( <STRING> ) <NEWLINE> os . chdir ( topdir ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'src'", "'--with-elfutils=elfutils --prefix=%s/systemtap'", "'-j %d'", "'install'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["bbf5d3a865f2714b087e11af16b3988a", {"code_string": "def user_dict(user):\n    groups = [group.pk for group in user.groups.all()]\n    data = {\n        'id': user.pk,\n        'username': user.username,\n        'first_name': user.first_name\n        'last_name': user.last_name,\n        'group': groups or None\n    }\n    return data\n", "code_toks_joined": "def user_dict ( user ) : <NEWLINE> <INDENT> groups = [ group . pk for group in user . groups . all ( ) ] <NEWLINE> data = { <NEWLINE> <INDENT> <STRING> : user . pk , <NEWLINE> <STRING> : user . username , <NEWLINE> <STRING> : user . first_name <NEWLINE> <STRING> : user . last_name , <NEWLINE> <STRING> : groups or None <NEWLINE> <DEDENT> } <NEWLINE> return data <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'id'", "'username'", "'first_name'", "'last_name'", "'group'"]}, "err_obj": {"msg": "invalid syntax"}}], ["9de52cb6358e58ac143b95497b1a35ba", {"code_string": "def _doCommand(self, valueStr):\n    valueInt = self.scale.get()\n    colors = self['colors']\n    thresholds = self['threshold']\n    color = colors[- 1]\n    for index in range(len(colors) - 1):\n        if valueInt <= thresholds[index]:\n        color = colors[index]\n        break\n    self.indicator.configure(background = color)\n    self.value.configure(text = valueStr)\n", "code_toks_joined": "def _doCommand ( self , valueStr ) : <NEWLINE> <INDENT> valueInt = self . scale . get ( ) <NEWLINE> colors = self [ <STRING> ] <NEWLINE> thresholds = self [ <STRING> ] <NEWLINE> color = colors [ - 1 ] <NEWLINE> for index in range ( len ( colors ) - 1 ) : <NEWLINE> <INDENT> if valueInt <= thresholds [ index ] : <NEWLINE> color = colors [ index ] <NEWLINE> break <NEWLINE> <DEDENT> self . indicator . configure ( background = color ) <NEWLINE> self . value . configure ( text = valueStr ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'colors'", "'threshold'"]}, "err_obj": {"msg": "expected an indented block"}}], ["1d2f2b7625c10731d83ad03eeb353edd", {"code_string": "def getmodinfo(self, mname):\n    self.info += \"\\n\" + mname + \"\\n\\tConfig: \\t\" + self.show_config(self.modl[mname].conf)\n    for proc in self.lproc:\n        if proc.mod.name == mname:\n            self.info += \"\\n\\tArguments: \\t\" + self.show_arg(proc.args)\n                self.info += \"\\n\\tResults: \\t\" + self.show_res(proc.res)\n", "code_toks_joined": "def getmodinfo ( self , mname ) : <NEWLINE> <INDENT> self . info += <STRING> + mname + <STRING> + self . show_config ( self . modl [ mname ] . conf ) <NEWLINE> for proc in self . lproc : <NEWLINE> <INDENT> if proc . mod . name == mname : <NEWLINE> <INDENT> self . info += <STRING> + self . show_arg ( proc . args ) <NEWLINE> <INDENT> self . info += <STRING> + self . show_res ( proc . res ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\\n\"", "\"\\n\\tConfig: \\t\"", "\"\\n\\tArguments: \\t\"", "\"\\n\\tResults: \\t\""]}, "err_obj": {"msg": "unexpected indent"}}], ["d634da862b8e280e573d69e06e241686", {"code_string": "class SnapTransfer(action.Action):\n    def __init__(self, init, driver,\n        snap_position):\n        super(SnapTransfer, self).__init__(init)\n        self.driver = driver(self.src_cloud,\n            self.dst_cloud,\n            self.cfg)\n            self.snap_position = snap_position\n    def run(self, volume, snapshot_info, ** kwargs):\n        self.driver.transfer(volume, snapshot_info, self.snap_position)\n        return{}\n", "code_toks_joined": "class SnapTransfer ( action . Action ) : <NEWLINE> <INDENT> def __init__ ( self , init , driver , <NEWLINE> <INDENT> snap_position ) : <NEWLINE> super ( SnapTransfer , self ) . __init__ ( init ) <NEWLINE> self . driver = driver ( self . src_cloud , <NEWLINE> <INDENT> self . dst_cloud , <NEWLINE> self . cfg ) <NEWLINE> self . snap_position = snap_position <NEWLINE> <DEDENT> <DEDENT> def run ( self , volume , snapshot_info , ** kwargs ) : <NEWLINE> <INDENT> self . driver . transfer ( volume , snapshot_info , self . snap_position ) <NEWLINE> return { } <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["0b55627d415dcbc80e50b7eb2387de8c", {"code_string": "def create_user_rss(user_id, ** kwargs)\n    user = User.query.filter_by(id = user_id).first()\n    UserHandler().create_rss(user)\n    user.save()\n    return\n", "code_toks_joined": "def create_user_rss ( user_id , ** kwargs ) <NEWLINE> <INDENT> user = User . query . filter_by ( id = user_id ) . first ( ) <NEWLINE> UserHandler ( ) . create_rss ( user ) <NEWLINE> user . save ( ) <NEWLINE> return <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["74f1316ee88090673efcd10772147eb2", {"code_string": "def EndLoadScreen():\n    LoadScreen.SetVisible(WINDOW_VISIBLE)\n    LoadScreen.Unload()\n        return\n", "code_toks_joined": "def EndLoadScreen ( ) : <NEWLINE> <INDENT> LoadScreen . SetVisible ( WINDOW_VISIBLE ) <NEWLINE> LoadScreen . Unload ( ) <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["17cd52e2790933ac7a2be73ef48aca98", {"code_string": "def write_file(self, result):\n    \"\"\"Writes a FileInformation object.\"\"\"\n    for row in result.results:\n        filename = row[\"filename\"]\n        with open(filename, \"rb\") as in_fd:\n            with self.session.GetRenderer().open(\n                directory = self.dump_dir,\n                filename = filename, mode = \"wb\") as out_fd:\n                while 1:\n                data = in_fd.read(1024 * 1024)\n                if not data:\n                    break\n                out_fd.write(data)\n", "code_toks_joined": "def write_file ( self , result ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for row in result . results : <NEWLINE> <INDENT> filename = row [ <STRING> ] <NEWLINE> with open ( filename , <STRING> ) as in_fd : <NEWLINE> <INDENT> with self . session . GetRenderer ( ) . open ( <NEWLINE> <INDENT> directory = self . dump_dir , <NEWLINE> filename = filename , mode = <STRING> ) as out_fd : <NEWLINE> while 1 : <NEWLINE> data = in_fd . read ( 1024 * 1024 ) <NEWLINE> if not data : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> out_fd . write ( data ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Writes a FileInformation object.\"\"\"", "\"filename\"", "\"rb\"", "\"wb\""]}, "err_obj": {"msg": "expected an indented block"}}], ["13c3789e8e7719ce1dd34d59c1754916", {"code_string": "class TestTimeLog(unittest.TestCase):\n    def test_duplication(self):\n        ts = frappe.get_doc(frappe.copy_doc(test_records[0])\n        self.assertRaises(OverlapError, ts.insert)\n", "code_toks_joined": "class TestTimeLog ( unittest . TestCase ) : <NEWLINE> <INDENT> def test_duplication ( self ) : <NEWLINE> <INDENT> ts = frappe . get_doc ( frappe . copy_doc ( test_records [ 0 ] ) <NEWLINE> self . assertRaises ( OverlapError , ts . insert ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c1080674f0c794cc25879678ff0b8ff6", {"code_string": "def __init__(self, ft232h):\n    self.ft232h = ft232h\n    self.count = 0\n    print(\"[*] Inititalizing I2C Scanner Thread \")\n    super(I2CScanner, self).__init__()\n        def __del__(self):\n            self.wait()\n        def close(self):\n            self.terminate()\n", "code_toks_joined": "def __init__ ( self , ft232h ) : <NEWLINE> <INDENT> self . ft232h = ft232h <NEWLINE> self . count = 0 <NEWLINE> print ( <STRING> ) <NEWLINE> super ( I2CScanner , self ) . __init__ ( ) <NEWLINE> <INDENT> def __del__ ( self ) : <NEWLINE> <INDENT> self . wait ( ) <NEWLINE> <DEDENT> def close ( self ) : <NEWLINE> <INDENT> self . terminate ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"[*] Inititalizing I2C Scanner Thread \""]}, "err_obj": {"msg": "unexpected indent"}}], ["6567dbfd36606474b6c9067bc5655265", {"code_string": "def assign_role(chat_id):\n    \"\"\"after player_addition phase, roles/leaders are assigned\"\"\"\n    curr_game = get_curr_game(chat_id)\n    num_player = curr_game.num_player\n    numSpies = identityDictRS[num_player][1]\n    numResistance = identityDictRS[num_player][0]\n    player_list = get_curr_player_list(chat_id)\n    count = 0\n    for player in player_list:\n        indicator = randint(0, 1)\n        if indicator == 1 and count < numSpies:\n            player.role = 'spy'\n            count = count + 1\n        else:\n            player.role = the resistance\n    return\n", "code_toks_joined": "def assign_role ( chat_id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> curr_game = get_curr_game ( chat_id ) <NEWLINE> num_player = curr_game . num_player <NEWLINE> numSpies = identityDictRS [ num_player ] [ 1 ] <NEWLINE> numResistance = identityDictRS [ num_player ] [ 0 ] <NEWLINE> player_list = get_curr_player_list ( chat_id ) <NEWLINE> count = 0 <NEWLINE> for player in player_list : <NEWLINE> <INDENT> indicator = randint ( 0 , 1 ) <NEWLINE> if indicator == 1 and count < numSpies : <NEWLINE> <INDENT> player . role = <STRING> <NEWLINE> count = count + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> player . role = the resistance <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"after player_addition phase, roles/leaders are assigned\"\"\"", "'spy'"]}, "err_obj": {"msg": "invalid syntax"}}], ["24ce5bf0a9fff3a87c24c1fcdc84ecb7", {"code_string": "def process_metrics_event(session, ref, snapshot):\n    vm_ref = vm_of_metrics(session, ref)\n    if vm_ref == None:\n    return\n    if session.xenapi.VM.get_power_state(vm_ref) < > \"Running\":\n        return\n    other = {}\n    try:\n        other = session.xenapi.VM_guest_metrics.get_other(ref)\n    except Exception, e:\n        print(repr(e))\n    if \"feature-shutdown\" in other.keys():\n        seen_possible_boot(session, vm_ref)\n", "code_toks_joined": "def process_metrics_event ( session , ref , snapshot ) : <NEWLINE> <INDENT> vm_ref = vm_of_metrics ( session , ref ) <NEWLINE> if vm_ref == None : <NEWLINE> return <NEWLINE> if session . xenapi . VM . get_power_state ( vm_ref ) < > <STRING> : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> other = { } <NEWLINE> try : <NEWLINE> <INDENT> other = session . xenapi . VM_guest_metrics . get_other ( ref ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> print ( repr ( e ) ) <NEWLINE> <DEDENT> if <STRING> in other . keys ( ) : <NEWLINE> <INDENT> seen_possible_boot ( session , vm_ref ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Running\"", "\"feature-shutdown\""]}, "err_obj": {"msg": "expected an indented block"}}], ["6154deaf570878ae566172eb4dabb4ee", {"code_string": "def get_size(self):\n    try:\n        return format_size(self.file_data.size)\n    except(OSError, IOError):\n        logging.error(\"File does not exist: %s\" % repr({\n            \"path\": self.file_data.path,\n            \"module\": \"%s.%s\" %(type(self)._meta.app_label, type(self)._meta.module_name)\n            \"pk\": self.pk,\n        }))\n        return None\n", "code_toks_joined": "def get_size ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return format_size ( self . file_data . size ) <NEWLINE> <DEDENT> except ( OSError , IOError ) : <NEWLINE> <INDENT> logging . error ( <STRING> % repr ( { <NEWLINE> <INDENT> <STRING> : self . file_data . path , <NEWLINE> <STRING> : <STRING> % ( type ( self ) . _meta . app_label , type ( self ) . _meta . module_name ) <NEWLINE> <STRING> : self . pk , <NEWLINE> <DEDENT> } ) ) <NEWLINE> return None <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"File does not exist: %s\"", "\"path\"", "\"module\"", "\"%s.%s\"", "\"pk\""]}, "err_obj": {"msg": "invalid syntax"}}], ["f8a106ca5be69f4715c27e561c6eb336", {"code_string": "def get_plugins(self ptype):\n    \"\"\" the return value is dict of name:class pairs \"\"\"\n    if ptype not in PLUGIN_TYPES:\n        raise errors.CreatorError('%s is not valid plugin type' % ptype)\n    plugins_dir = self._build_plugin_dir_list(self.plugin_dir, ptype)\n    self.append_dirs(plugins_dir)\n    return pluginbase.get_plugins(ptype)\n", "code_toks_joined": "def get_plugins ( self ptype ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ptype not in PLUGIN_TYPES : <NEWLINE> <INDENT> raise errors . CreatorError ( <STRING> % ptype ) <NEWLINE> <DEDENT> plugins_dir = self . _build_plugin_dir_list ( self . plugin_dir , ptype ) <NEWLINE> self . append_dirs ( plugins_dir ) <NEWLINE> return pluginbase . get_plugins ( ptype ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" the return value is dict of name:class pairs \"\"\"", "'%s is not valid plugin type'"]}, "err_obj": {"msg": "invalid syntax"}}], ["ee3410993479939e017f1929b6870bde", {"code_string": "from rest_framework import serializers\nfrom contrib.drf_introspection.serializers import StrictSerializerMixin\nfrom.models import Label, Arch, SigKey\nclass LabelSerializer(StrictSerializerMixin,\n    serializers.HyperlinkedModelSerializer):\n    \"\"\"Label Serializer\"\"\"\n    class Meta:\n    model = Label\n    fields = ('url', 'name', 'description')\n", "code_toks_joined": "from rest_framework import serializers <NEWLINE> from contrib . drf_introspection . serializers import StrictSerializerMixin <NEWLINE> from . models import Label , Arch , SigKey <NEWLINE> class LabelSerializer ( StrictSerializerMixin , <NEWLINE> <INDENT> serializers . HyperlinkedModelSerializer ) : <NEWLINE> <STRING> <NEWLINE> class Meta : <NEWLINE> model = Label <NEWLINE> fields = ( <STRING> , <STRING> , <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Label Serializer\"\"\"", "'url'", "'name'", "'description'"]}, "err_obj": {"msg": "expected an indented block"}}], ["51ed19a4e387af10817c5cbe6467f3ff", {"code_string": "class Object(object):\n    def __init__(self, name, sprite, (x, y), scale, rot):\n        self.name = name\n        self.sprite = sprite\n        self.x = y\n        self.y = x\n        self.scale = scale\n        self.rot = rot\n    '''doesPointIntersect()'''\n    def doesPointIntersect(self, point, threshold):\n        pass\n", "code_toks_joined": "class Object ( object ) : <NEWLINE> <INDENT> def __init__ ( self , name , sprite , ( x , y ) , scale , rot ) : <NEWLINE> <INDENT> self . name = name <NEWLINE> self . sprite = sprite <NEWLINE> self . x = y <NEWLINE> self . y = x <NEWLINE> self . scale = scale <NEWLINE> self . rot = rot <NEWLINE> <DEDENT> <STRING> <NEWLINE> def doesPointIntersect ( self , point , threshold ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''doesPointIntersect()'''"]}, "err_obj": {"msg": "invalid syntax"}}], ["566a656e8de4373dce584c4452c1ca8a", {"code_string": "def entry_error(cfg, entry):\n    if(cfg.entry_error_busy == True):\n    return\n    cfg.entry_error_busy = True\n    thread_messageBox = thread_gfunc(cfg, False, True, entry_error_t, cfg, entry)\n    thread_messageBox.start()\n", "code_toks_joined": "def entry_error ( cfg , entry ) : <NEWLINE> <INDENT> if ( cfg . entry_error_busy == True ) : <NEWLINE> return <NEWLINE> cfg . entry_error_busy = True <NEWLINE> thread_messageBox = thread_gfunc ( cfg , False , True , entry_error_t , cfg , entry ) <NEWLINE> thread_messageBox . start ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["62b7082bf80d559533c5e36307b06e75", {"code_string": "def __init__(self, (client, address)):\n    threading.Thread.__init__(self)\n    self.client = client\n    self.address = address\n    self.size = 1024\n", "code_toks_joined": "def __init__ ( self , ( client , address ) ) : <NEWLINE> <INDENT> threading . Thread . __init__ ( self ) <NEWLINE> self . client = client <NEWLINE> self . address = address <NEWLINE> self . size = 1024 <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["cc92435d0d03988226f1dac16095a3b6", {"code_string": "def test_getargspec_sublistofone(self):\n    def sublistOfOne((foo, )): return 1\n    self.assertArgSpecEquals(sublistOfOne, [['foo']])\n    def fakeSublistOfOne((foo)): return 1\n    self.assertArgSpecEquals(fakeSublistOfOne, ['foo'])\n", "code_toks_joined": "def test_getargspec_sublistofone ( self ) : <NEWLINE> <INDENT> def sublistOfOne ( ( foo , ) ) : return 1 <NEWLINE> self . assertArgSpecEquals ( sublistOfOne , [ [ <STRING> ] ] ) <NEWLINE> def fakeSublistOfOne ( ( foo ) ) : return 1 <NEWLINE> self . assertArgSpecEquals ( fakeSublistOfOne , [ <STRING> ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'foo'", "'foo'"]}, "err_obj": {"msg": "invalid syntax"}}], ["e21ccbfe8f90d7af6714c3dee5a4a40d", {"code_string": "import requests\nfrom oauth10a import signing_requests\nuser_authorization_url = None\naccess_token_url = None\ndef obtain_request_token(request_token_url, consumer_key, secret_key,\n    callback_url = 'oob', http_method = 'POST',\n    ** additional_params):\n    \"\"\"OAuth 1.0a 6.1.1: Consumer Obtains a Request Token\"\"\"\n    auth = signing_requests.HMACSHA1Auth(\n    consumer_key, secret_key, callback_url)\n    if http_method == 'POST':\n    return requests.post(request_token_url, auth = auth)\n    elif http_method == 'GET':\n    return requests.get(request_token_url, auth = auth)\n", "code_toks_joined": "import requests <NEWLINE> from oauth10a import signing_requests <NEWLINE> user_authorization_url = None <NEWLINE> access_token_url = None <NEWLINE> def obtain_request_token ( request_token_url , consumer_key , secret_key , <NEWLINE> <INDENT> callback_url = <STRING> , http_method = <STRING> , <NEWLINE> ** additional_params ) : <NEWLINE> <STRING> <NEWLINE> auth = signing_requests . HMACSHA1Auth ( <NEWLINE> consumer_key , secret_key , callback_url ) <NEWLINE> if http_method == <STRING> : <NEWLINE> return requests . post ( request_token_url , auth = auth ) <NEWLINE> elif http_method == <STRING> : <NEWLINE> return requests . get ( request_token_url , auth = auth ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'oob'", "'POST'", "\"\"\"OAuth 1.0a 6.1.1: Consumer Obtains a Request Token\"\"\"", "'POST'", "'GET'"]}, "err_obj": {"msg": "expected an indented block"}}], ["0e46a85a082cd89bdd7399ac143ed15b", {"code_string": "class CdblibShelf(ShelfWithHooks):\n    def __init__(self, filename, flag, key_type = 'str', dump_method = None,\n        cached = True, writeback = False):\n        if flag == 'r':\n        Shelf.__init__(self, CDBReader(filename), - 1, writeback)\n        elif flag == 'c':\n        Shelf.__init__(self, CDBWriter(filename), - 1, writeback)\n        self._setup_methods(cached, key_type, dump_method)\n    def close(self):\n        self.dict.close()\n", "code_toks_joined": "class CdblibShelf ( ShelfWithHooks ) : <NEWLINE> <INDENT> def __init__ ( self , filename , flag , key_type = <STRING> , dump_method = None , <NEWLINE> <INDENT> cached = True , writeback = False ) : <NEWLINE> if flag == <STRING> : <NEWLINE> Shelf . __init__ ( self , CDBReader ( filename ) , - 1 , writeback ) <NEWLINE> elif flag == <STRING> : <NEWLINE> Shelf . __init__ ( self , CDBWriter ( filename ) , - 1 , writeback ) <NEWLINE> self . _setup_methods ( cached , key_type , dump_method ) <NEWLINE> <DEDENT> def close ( self ) : <NEWLINE> <INDENT> self . dict . close ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'str'", "'r'", "'c'"]}, "err_obj": {"msg": "expected an indented block"}}], ["f34281741c45a58133cc62191a580ba2", {"code_string": "def undef_macro(self, macro_name, line_num, filename):\n    ''' undef the specified macro name '''\n    if macro_name not in self.macros:\n        print(\"WARNING: Macro not previously defined: `undef macro '%s' in file %s at line %d.\" %(macro_name, filename, line_num))\n        return\n    if self.debug: print \"Undef'd Macro '%s' in file %s at line %d.\" %(macro_name, filename, line_num)\n    del self.macros[macro_name]\n", "code_toks_joined": "def undef_macro ( self , macro_name , line_num , filename ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if macro_name not in self . macros : <NEWLINE> <INDENT> print ( <STRING> % ( macro_name , filename , line_num ) ) <NEWLINE> return <NEWLINE> <DEDENT> if self . debug : print <STRING> % ( macro_name , filename , line_num ) <NEWLINE> del self . macros [ macro_name ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''' undef the specified macro name '''", "\"WARNING: Macro not previously defined: `undef macro '%s' in file %s at line %d.\"", "\"Undef'd Macro '%s' in file %s at line %d.\""]}, "err_obj": {"msg": "invalid syntax"}}], ["19692495e43dc6cfc41068e4c1e6b245", {"code_string": "def dispatch_simplify_path(self, planner, (request_id, request)):\n    thread = threading.Thread(target = self.simplify_path_wrapper, args = (planner, request_id, request, self.handle_simplify_path_response))\n    thread.start()\n", "code_toks_joined": "def dispatch_simplify_path ( self , planner , ( request_id , request ) ) : <NEWLINE> <INDENT> thread = threading . Thread ( target = self . simplify_path_wrapper , args = ( planner , request_id , request , self . handle_simplify_path_response ) ) <NEWLINE> thread . start ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["a71a9a97b31a5591bd6394bbb80a67cc", {"code_string": "def ReadFromFile(filename):\n    with open(filename, 'r') as f:\n    return f.read()\n", "code_toks_joined": "def ReadFromFile ( filename ) : <NEWLINE> <INDENT> with open ( filename , <STRING> ) as f : <NEWLINE> return f . read ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'r'"]}, "err_obj": {"msg": "expected an indented block"}}], ["850e9071dbd5d644ff6973e1dc376792", {"code_string": "def get(self):\n    self._entry = SSCAPI.ssc_module_entry(self._idx)\n    if(self._entry is None):\n    self.reset()\n    return False\n    else:\n    self._idx += 1\n    return True\n", "code_toks_joined": "def get ( self ) : <NEWLINE> <INDENT> self . _entry = SSCAPI . ssc_module_entry ( self . _idx ) <NEWLINE> if ( self . _entry is None ) : <NEWLINE> self . reset ( ) <NEWLINE> return False <NEWLINE> else : <NEWLINE> self . _idx += 1 <NEWLINE> return True <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["83cdf56a56ced856fa43b0ecc1185b89", {"code_string": "def test_get_datapath_retry_out_by_default_time(self):\n    cfg.CONF.set_override('get_datapath_retry_times', 3, group = 'AGENT')\n    with mock.patch.object(self.mod_agent.ryu_api, 'get_datapath',\n        return_value = None) as mock_get_datapath:\n        with testtools.ExpectedException(SystemExit):\n        self.ovs.datapath_id = '0x64'\n        self.ovs.get_datapath(retry_max = 3)\n    self.assertEqual(mock_get_datapath.call_count, 3)\n", "code_toks_joined": "def test_get_datapath_retry_out_by_default_time ( self ) : <NEWLINE> <INDENT> cfg . CONF . set_override ( <STRING> , 3 , group = <STRING> ) <NEWLINE> with mock . patch . object ( self . mod_agent . ryu_api , <STRING> , <NEWLINE> <INDENT> return_value = None ) as mock_get_datapath : <NEWLINE> with testtools . ExpectedException ( SystemExit ) : <NEWLINE> self . ovs . datapath_id = <STRING> <NEWLINE> self . ovs . get_datapath ( retry_max = 3 ) <NEWLINE> <DEDENT> self . assertEqual ( mock_get_datapath . call_count , 3 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'get_datapath_retry_times'", "'AGENT'", "'get_datapath'", "'0x64'"]}, "err_obj": {"msg": "expected an indented block"}}], ["b555548278c1f4050add52e6e15aea4b", {"code_string": "def permute(variable, output_order = ('time', 'z', 'zb', 'y', 'x')):\n    \"\"\"Permute dimensions of a NetCDF variable to match the output storage order.\"\"\"\n    input_dimensions = variable.dimensions\n    dimensions = filter(lambda(x): x in input_dimensions,\n        output_order)\n    mapping = map(lambda(x): dimensions.index(x),\n        input_dimensions)\n    if mapping:\n        return np.transpose(variable[: ], mapping)\n    else:\n        return variable[: ]\n", "code_toks_joined": "def permute ( variable , output_order = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> input_dimensions = variable . dimensions <NEWLINE> dimensions = filter ( lambda ( x ) : x in input_dimensions , <NEWLINE> <INDENT> output_order ) <NEWLINE> <DEDENT> mapping = map ( lambda ( x ) : dimensions . index ( x ) , <NEWLINE> <INDENT> input_dimensions ) <NEWLINE> <DEDENT> if mapping : <NEWLINE> <INDENT> return np . transpose ( variable [ : ] , mapping ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return variable [ : ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'time'", "'z'", "'zb'", "'y'", "'x'", "\"\"\"Permute dimensions of a NetCDF variable to match the output storage order.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["0f5ee86b5347861c46cc392b9915f906", {"code_string": "class MainHandler(tornado.web.RequestHandler):\n    def get(self):\n    sesiones = []\n    for key, val in csv.reader(open(\"sesiones.csv\")):\n        sesiones.append([key, val])\n        if len(sesiones) > 0:\n    self.render(\"template.html\", title = \"My title\", datos = sesiones)\n    else:\n    self.write(\"No rows\")\n", "code_toks_joined": "class MainHandler ( tornado . web . RequestHandler ) : <NEWLINE> <INDENT> def get ( self ) : <NEWLINE> sesiones = [ ] <NEWLINE> for key , val in csv . reader ( open ( <STRING> ) ) : <NEWLINE> <INDENT> sesiones . append ( [ key , val ] ) <NEWLINE> if len ( sesiones ) > 0 : <NEWLINE> <DEDENT> self . render ( <STRING> , title = <STRING> , datos = sesiones ) <NEWLINE> else : <NEWLINE> self . write ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"sesiones.csv\"", "\"template.html\"", "\"My title\"", "\"No rows\""]}, "err_obj": {"msg": "expected an indented block"}}], ["4c6f05a8a1bc2613527a020648751d09", {"code_string": "def height_vertical_coord(cube, field):\n    \"\"\"Add a height coord to the cube, if present in the field.\"\"\"\n    if(field.reference_vertical_coord_type == field.int_mdi or\n        field.reference_vertical_coord == field.float32_mdi):\n        height_coord = DimCoord(field.vertical_coord,\n            standard_name = \"height\", units = \"m\",\n            attributes = {\"positive\": \"up\"})\n            cube.add_aux_coord(height_coord)\n    else:\n        raise TranslationError(\"Bounded vertical not yet implemented\")\n", "code_toks_joined": "def height_vertical_coord ( cube , field ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( field . reference_vertical_coord_type == field . int_mdi or <NEWLINE> <INDENT> field . reference_vertical_coord == field . float32_mdi ) : <NEWLINE> height_coord = DimCoord ( field . vertical_coord , <NEWLINE> <INDENT> standard_name = <STRING> , units = <STRING> , <NEWLINE> attributes = { <STRING> : <STRING> } ) <NEWLINE> cube . add_aux_coord ( height_coord ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> raise TranslationError ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Add a height coord to the cube, if present in the field.\"\"\"", "\"height\"", "\"m\"", "\"positive\"", "\"up\"", "\"Bounded vertical not yet implemented\""]}, "err_obj": {"msg": "unexpected indent"}}], ["5635baa3cb07de7ab81926fed4d05d54", {"code_string": "def redistribute(winner, looser, depth):\n    cdef unsigned int i\n    for i in range(depth + 1):\n        winner.append(looser[0])\n        winner.append(winner[0])\n        del winner[0]\n        del looser[0]\n", "code_toks_joined": "def redistribute ( winner , looser , depth ) : <NEWLINE> <INDENT> cdef unsigned int i <NEWLINE> for i in range ( depth + 1 ) : <NEWLINE> <INDENT> winner . append ( looser [ 0 ] ) <NEWLINE> winner . append ( winner [ 0 ] ) <NEWLINE> del winner [ 0 ] <NEWLINE> del looser [ 0 ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["58cf04a6d71fab4ef278c31b270e9832", {"code_string": "def collideswordlow(self, player):\n    for i in self.gameobjects:\n    if i != None:\n    id = i.collidewithswordlow(self, player)\n    return i\n    return None\n", "code_toks_joined": "def collideswordlow ( self , player ) : <NEWLINE> <INDENT> for i in self . gameobjects : <NEWLINE> if i != None : <NEWLINE> id = i . collidewithswordlow ( self , player ) <NEWLINE> return i <NEWLINE> return None <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["93900f4923ee4764a4f7dbac023087f9", {"code_string": "class CreateAndUpdateVolume(cinder_utils.CinderBasic):\n    def run(self, size, image = None, create_volume_kwargs = None,\n        update_volume_kwargs = None):\n        \"\"\"Create a volume and update its name and description.\"\"\"\n        create_volume_kwargs = create_volume_kwargs or{}\n        update_volume_kwargs = update_volume_kwargs or{}\n        if image:\n        create_volume_kwargs[\"imageRef\"] = image\n        if update_volume_kwargs.pop(\"update_name\", False):\n        update_volume_kwargs[\"name\"] = self.generate_random_name()\n        volume = self.cinder.create_volume(size, ** create_volume_kwargs)\n        self.cinder.update_volume(volume, ** update_volume_kwargs)\n", "code_toks_joined": "class CreateAndUpdateVolume ( cinder_utils . CinderBasic ) : <NEWLINE> <INDENT> def run ( self , size , image = None , create_volume_kwargs = None , <NEWLINE> <INDENT> update_volume_kwargs = None ) : <NEWLINE> <STRING> <NEWLINE> create_volume_kwargs = create_volume_kwargs or { } <NEWLINE> update_volume_kwargs = update_volume_kwargs or { } <NEWLINE> if image : <NEWLINE> create_volume_kwargs [ <STRING> ] = image <NEWLINE> if update_volume_kwargs . pop ( <STRING> , False ) : <NEWLINE> update_volume_kwargs [ <STRING> ] = self . generate_random_name ( ) <NEWLINE> volume = self . cinder . create_volume ( size , ** create_volume_kwargs ) <NEWLINE> self . cinder . update_volume ( volume , ** update_volume_kwargs ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Create a volume and update its name and description.\"\"\"", "\"imageRef\"", "\"update_name\"", "\"name\""]}, "err_obj": {"msg": "expected an indented block"}}], ["cb9b8d0fa4ed5473941af51661d58020", {"code_string": "def get_template_names(self):\n    return('gold/subscription{0}.html'\n        .format(self.template_name_suffix)\n", "code_toks_joined": "def get_template_names ( self ) : <NEWLINE> <INDENT> return ( <STRING> <NEWLINE> <INDENT> . format ( self . template_name_suffix ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'gold/subscription{0}.html'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["52acff171aa7f799d2970c376fb176b9", {"code_string": "def new_workunit(self, name, labels = None, cmd = '', log_config = None):\n    \"\"\"Creates a (hierarchical) subunit of work for the purpose of timing and reporting.\"\"\"\n    parent = self._threadlocal.current_workunit\n    with self.new_workunit_under_parent(name, parent = parent, labels = labels, cmd = cmd,\n        log_config = log_config) as workunit:\n        self._threadlocal.current_workunit = workunit\n        try:\n        yield workunit\n        finally:\n        self._threadlocal.current_workunit = parent\n", "code_toks_joined": "def new_workunit ( self , name , labels = None , cmd = <STRING> , log_config = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> parent = self . _threadlocal . current_workunit <NEWLINE> with self . new_workunit_under_parent ( name , parent = parent , labels = labels , cmd = cmd , <NEWLINE> <INDENT> log_config = log_config ) as workunit : <NEWLINE> self . _threadlocal . current_workunit = workunit <NEWLINE> try : <NEWLINE> yield workunit <NEWLINE> finally : <NEWLINE> self . _threadlocal . current_workunit = parent <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "\"\"\"Creates a (hierarchical) subunit of work for the purpose of timing and reporting.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["c87a99d4f5c89e580f653a82b735551b", {"code_string": "def retranslateUi(self):\n    try:\n        self.aboutLabel.setText(_translate(\"\", self.workflowProvider.aboutHTML, None))\n    except:\n        self.aboutLabel.setText(_translate(\"\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . aboutLabel . setText ( _translate ( <STRING> , self . workflowProvider . aboutHTML , None ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> self . aboutLabel . setText ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"", "\"\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["ee31a58572163e054d92d159d8546e10", {"code_string": "def co_findloadednames(co):\n    \"\"\"Find all loaded names in a code object and all its consts of code type\"\"\"\n    names = {}\n    names.update(co_code_findloadednames(co))\n    for c in co.co_consts:\n    if isinstance(c, type(co)):\n        names.update(co_findloadednames(c))\n    return names\n", "code_toks_joined": "def co_findloadednames ( co ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> names = { } <NEWLINE> names . update ( co_code_findloadednames ( co ) ) <NEWLINE> for c in co . co_consts : <NEWLINE> if isinstance ( c , type ( co ) ) : <NEWLINE> <INDENT> names . update ( co_findloadednames ( c ) ) <NEWLINE> <DEDENT> return names <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Find all loaded names in a code object and all its consts of code type\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["f1e78207f66860f6af5f325c636d4a01", {"code_string": "def advanced_cnlgb(self):\n    zz = []\n    p = get_CNL_sentence_authors(self)\n    if not p:\n        pass\n    else:\n        zz.extend(p)\n            \"\"\"Generates CNL sentence for RT/R\"\"\"\n            rt = get_RT_sentence(self)\n            if not rt:\n                pass\n            else:\n                zz.extend(rt)\n    return zz\n", "code_toks_joined": "def advanced_cnlgb ( self ) : <NEWLINE> <INDENT> zz = [ ] <NEWLINE> p = get_CNL_sentence_authors ( self ) <NEWLINE> if not p : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> zz . extend ( p ) <NEWLINE> <INDENT> <STRING> <NEWLINE> rt = get_RT_sentence ( self ) <NEWLINE> if not rt : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> zz . extend ( rt ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return zz <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Generates CNL sentence for RT/R\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["43084595503895262290475deda92e3c", {"code_string": "def createList(data):\n    size = len(data)\n    if size == 0:\n        return None\n    head = ListNode(data[0])\n    p = head\n    for i in range(1, size):\n    q = ListNode(data[i])\n        p.next = q\n        p = q\n    p.next = None\n    return head\n", "code_toks_joined": "def createList ( data ) : <NEWLINE> <INDENT> size = len ( data ) <NEWLINE> if size == 0 : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> head = ListNode ( data [ 0 ] ) <NEWLINE> p = head <NEWLINE> for i in range ( 1 , size ) : <NEWLINE> q = ListNode ( data [ i ] ) <NEWLINE> <INDENT> p . next = q <NEWLINE> p = q <NEWLINE> <DEDENT> p . next = None <NEWLINE> return head <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["33ab21d067dee4e9731517ed0ba3222a", {"code_string": "def buildQueues(self):\n    \"\"\"Organizes Queue list\"\"\"\n        self.buildImageList()\n        self.sortImages()\n        pools = list()\n        for tier in self.tiers:\n            pool = Queue.Queue()\n            for image in tier:\n                pool.put(image)\n            pools.append(pool)\n        return pools\n", "code_toks_joined": "def buildQueues ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> self . buildImageList ( ) <NEWLINE> self . sortImages ( ) <NEWLINE> pools = list ( ) <NEWLINE> for tier in self . tiers : <NEWLINE> <INDENT> pool = Queue . Queue ( ) <NEWLINE> for image in tier : <NEWLINE> <INDENT> pool . put ( image ) <NEWLINE> <DEDENT> pools . append ( pool ) <NEWLINE> <DEDENT> return pools <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Organizes Queue list\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["1f963a304fd0ba9056504b8b8099f92e", {"code_string": "def parse_cpath(path):\n    '''\u51fd\u6570\u529f\u80fd\uff1a\u5bf9\u7c7b\u8def\u5f84\u8fdb\u884c\u89e3\u6790'''\n    if path.startswith('L') and path.endswith(';') and('.' not in path):\n    return path\n    elif path.startswith('L') or path.endswith(';') or('/' in path):\n    raise ParseError('could not determine if path is a JNI or logical class path', path)\n    else:\n    return 'L' + path.replace('.', '/') + ';'\n", "code_toks_joined": "def parse_cpath ( path ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if path . startswith ( <STRING> ) and path . endswith ( <STRING> ) and ( <STRING> not in path ) : <NEWLINE> return path <NEWLINE> elif path . startswith ( <STRING> ) or path . endswith ( <STRING> ) or ( <STRING> in path ) : <NEWLINE> raise ParseError ( <STRING> , path ) <NEWLINE> else : <NEWLINE> return <STRING> + path . replace ( <STRING> , <STRING> ) + <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''\u51fd\u6570\u529f\u80fd\uff1a\u5bf9\u7c7b\u8def\u5f84\u8fdb\u884c\u89e3\u6790'''", "'L'", "';'", "'.'", "'L'", "';'", "'/'", "'could not determine if path is a JNI or logical class path'", "'L'", "'.'", "'/'", "';'"]}, "err_obj": {"msg": "expected an indented block"}}], ["be169d681174bc319080c7d84849baaa", {"code_string": "class CategoryAdmin(admin.ModelAdmin):\n    search_fields = ['code', 'desc']\n    list_display = ['code', 'desc']\n        ordering = ('code', )\n", "code_toks_joined": "class CategoryAdmin ( admin . ModelAdmin ) : <NEWLINE> <INDENT> search_fields = [ <STRING> , <STRING> ] <NEWLINE> list_display = [ <STRING> , <STRING> ] <NEWLINE> <INDENT> ordering = ( <STRING> , ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'code'", "'desc'", "'code'", "'desc'", "'code'"]}, "err_obj": {"msg": "unexpected indent"}}], ["4d720ee5cc5049174d27506426bb57fe", {"code_string": "def main():\n    response = \"\"\n    if not response:\n        d = Dialog('Insta-Snorby - First boot configuration')\n        response = d.yesno(\"Automatically Update Rules Everyday?\", \"Snorby can update the configured ruleset on a daily basis. Snorby supports this through intergration with Pulled Pork, a simple popular Snort rule update script\\n\\nEnable Pulled Pork?\")\n        if response:\n    d.infobox('Configuring Pulled Pork to run everyday at 2:00AM local time')\n    system(\"crontab -l > /root/crontmp\")\n    system(\"echo '0 2 * * * /root/pulledpork-0.6.1/pulledpork.pl -c /root/pulledpork-0.6.1/etc/pulledpork.conf -H -v >> /var/log/pulledpork 2>&1 #Update Snort Rules' >> /root/crontmp\")\n    system(\"crontab /root/crontmp\")\n    d.infobox('Running Pulled Pork now! Logs are stored at /var/log/pulledpork')\n    system(\"/root/pulledpork-0.6.1/pulledpork.pl -c /root/pulledpork-0.6.1/etc/pulledpork.conf -H -v >> /var/log/pulledpork 2>&1\")\n", "code_toks_joined": "def main ( ) : <NEWLINE> <INDENT> response = <STRING> <NEWLINE> if not response : <NEWLINE> <INDENT> d = Dialog ( <STRING> ) <NEWLINE> response = d . yesno ( <STRING> , <STRING> ) <NEWLINE> if response : <NEWLINE> <DEDENT> d . infobox ( <STRING> ) <NEWLINE> system ( <STRING> ) <NEWLINE> system ( <STRING> ) <NEWLINE> system ( <STRING> ) <NEWLINE> d . infobox ( <STRING> ) <NEWLINE> system ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"", "'Insta-Snorby - First boot configuration'", "\"Automatically Update Rules Everyday?\"", "\"Snorby can update the configured ruleset on a daily basis. Snorby supports this through intergration with Pulled Pork, a simple popular Snort rule update script\\n\\nEnable Pulled Pork?\"", "'Configuring Pulled Pork to run everyday at 2:00AM local time'", "\"crontab -l > /root/crontmp\"", "\"echo '0 2 * * * /root/pulledpork-0.6.1/pulledpork.pl -c /root/pulledpork-0.6.1/etc/pulledpork.conf -H -v >> /var/log/pulledpork 2>&1 #Update Snort Rules' >> /root/crontmp\"", "\"crontab /root/crontmp\"", "'Running Pulled Pork now! Logs are stored at /var/log/pulledpork'", "\"/root/pulledpork-0.6.1/pulledpork.pl -c /root/pulledpork-0.6.1/etc/pulledpork.conf -H -v >> /var/log/pulledpork 2>&1\""]}, "err_obj": {"msg": "expected an indented block"}}], ["2efb55e401a593e967a80182ea343fa5", {"code_string": "def sync_user_email_addresses(user):\n    \"\"\"Keep user.email in sync with user.emailaddress_set.\"\"\"\n    from.models import EmailAddress\n    email = user_email(user)\n    if email and not EmailAddress.objects.filter(user = user,\n        email__iexact = email).exists():\n        if app_settings.UNIQUE_EMAIL and EmailAddress.objects.filter(email__iexact = email).exists():\n        return\n        EmailAddress.objects.create(user = user,\n        email = email,\n        primary = False,\n        verified = False)\n", "code_toks_joined": "def sync_user_email_addresses ( user ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> from . models import EmailAddress <NEWLINE> email = user_email ( user ) <NEWLINE> if email and not EmailAddress . objects . filter ( user = user , <NEWLINE> <INDENT> email__iexact = email ) . exists ( ) : <NEWLINE> if app_settings . UNIQUE_EMAIL and EmailAddress . objects . filter ( email__iexact = email ) . exists ( ) : <NEWLINE> return <NEWLINE> EmailAddress . objects . create ( user = user , <NEWLINE> email = email , <NEWLINE> primary = False , <NEWLINE> verified = False ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Keep user.email in sync with user.emailaddress_set.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["732a1c858e0f0dc3a4cdcbe8a3fdc63a", {"code_string": "def get_size_t(self, i):\n    if(i < 0 or i >= self._nobjects)\n        raise Exception('Index %i exceeds size of \"%s\"' %(i, self._path))\n    self._fp.seek(self._hsize + i * self._rlength)\n    vec = self._fp.read(self._rlength)\n    return list(unpack('%iL' % self._vdim, vec))\n", "code_toks_joined": "def get_size_t ( self , i ) : <NEWLINE> <INDENT> if ( i < 0 or i >= self . _nobjects ) <NEWLINE> <INDENT> raise Exception ( <STRING> % ( i , self . _path ) ) <NEWLINE> <DEDENT> self . _fp . seek ( self . _hsize + i * self . _rlength ) <NEWLINE> vec = self . _fp . read ( self . _rlength ) <NEWLINE> return list ( unpack ( <STRING> % self . _vdim , vec ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Index %i exceeds size of \"%s\"'", "'%iL'"]}, "err_obj": {"msg": "invalid syntax"}}], ["49b17a8c99a5333e7a7992b237dd8672", {"code_string": "def _start_cli(self, ** kw):\n    r\"\"\"protected method def;\"\"\"\n        _(\n            \"\\n[INFO] this is the non-GUI implementation of your \"\n            \"application program.\\n\\nFeel free to implement it \"\n            \"at your taste in subclasses.\"\n            \"\\n\\n*** Program end ***\"\n        )\n    )\n", "code_toks_joined": "def _start_cli ( self , ** kw ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> _ ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["r\"\"\"protected method def;\"\"\"", "\"\\n[INFO] this is the non-GUI implementation of your \"", "\"application program.\\n\\nFeel free to implement it \"", "\"at your taste in subclasses.\"", "\"\\n\\n*** Program end ***\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["6bf516af82692b32a55d14da57d20fa3", {"code_string": "def attach(self):\n    '''open db file and reconstruct b-tree for operations.'''\n    self.dc.setup()\n    meta_node = get_meta_node()\n    unalloc_nodes = [i if self.nodes[i].status() == NULL_NODE for i in range(self.dc.block_num]\n    self.free_list = deque(unalloc_nodes)\n", "code_toks_joined": "def attach ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . dc . setup ( ) <NEWLINE> meta_node = get_meta_node ( ) <NEWLINE> unalloc_nodes = [ i if self . nodes [ i ] . status ( ) == NULL_NODE for i in range ( self . dc . block_num ] <NEWLINE> self . free_list = deque ( unalloc_nodes ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''open db file and reconstruct b-tree for operations.'''"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["89bf32e421f8ca350bc7689e887b5b45", {"code_string": "def setupUi(self, VentanaPrincipal):\n    VentanaPrincipal.setObjectName(_fromUtf8(\"VentanaPrincipal\"))\n    VentanaPrincipal.resize(650, 420)\n    VentanaPrincipal.setMaximumSize(QtCore.QSize(650, 420))\n    font = QtGui.QFont()\n    font.setPointSize(17)\n    VentanaPrincipal.setFont(font)\n    VentanaPrincipal.setMouseTracking(True)\n    self.cwgtPrincipal = QtGui.QWidget(VentanaPrincipal)\n    self.cwgtPrincipal.setObjectName(_fromUtf8(\"cwgtPrincipal\"))\n    self.lblBazarPapeleria = QtGui.QLabel(self.cwgtPrincipal)\n    self.lblBazarPapeleria.setGeometry(QtCore.QRect(110, 40, 425, 35))\n    font = QtGui.QFont()\n    font.setPointSize(23)\n    font.setBold(True)\n    font.setWeight(75)\n    self.lblBazarPapeleria.setFont(font)\n    self.lblBazarPapeleria.setCursor(QtGui.QCursor(QtCore.Qt.SizeBDiagCursor))\n    self.lblBazarPapeleria.setStyleSheet(_fromUtf8(\"color: rgb(51, 102, 255);\"))\n    self.lblBazarPapeleria.setObjectName(_fromUtf8(\"lblBazarPapeleria\"))\n    self.btnAgregar = QtGui.QPushButton(self.cwgtPrincipal)\n    self.btnAgregar.setGeometry(QtCore.QRect(70, 120, 170, 110))\n    font = QtGui.QFont()\n    font.setFamily(_fromUtf8(\"Arial\"))\n    font.setPointSize(20)\n    font.setBold(True)\n    font.setWeight(75)\n    self.btnAgregar.setFont(font)\n    self.btnAgregar.setStyleSheet(_fromUtf8(\"color: rgb(223, 15, 90);\\n\"\n", "code_toks_joined": "def setupUi ( self , VentanaPrincipal ) : <NEWLINE> <INDENT> VentanaPrincipal . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> VentanaPrincipal . resize ( 650 , 420 ) <NEWLINE> VentanaPrincipal . setMaximumSize ( QtCore . QSize ( 650 , 420 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setPointSize ( 17 ) <NEWLINE> VentanaPrincipal . setFont ( font ) <NEWLINE> VentanaPrincipal . setMouseTracking ( True ) <NEWLINE> self . cwgtPrincipal = QtGui . QWidget ( VentanaPrincipal ) <NEWLINE> self . cwgtPrincipal . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . lblBazarPapeleria = QtGui . QLabel ( self . cwgtPrincipal ) <NEWLINE> self . lblBazarPapeleria . setGeometry ( QtCore . QRect ( 110 , 40 , 425 , 35 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setPointSize ( 23 ) <NEWLINE> font . setBold ( True ) <NEWLINE> font . setWeight ( 75 ) <NEWLINE> self . lblBazarPapeleria . setFont ( font ) <NEWLINE> self . lblBazarPapeleria . setCursor ( QtGui . QCursor ( QtCore . Qt . SizeBDiagCursor ) ) <NEWLINE> self . lblBazarPapeleria . setStyleSheet ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . lblBazarPapeleria . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . btnAgregar = QtGui . QPushButton ( self . cwgtPrincipal ) <NEWLINE> self . btnAgregar . setGeometry ( QtCore . QRect ( 70 , 120 , 170 , 110 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setFamily ( _fromUtf8 ( <STRING> ) ) <NEWLINE> font . setPointSize ( 20 ) <NEWLINE> font . setBold ( True ) <NEWLINE> font . setWeight ( 75 ) <NEWLINE> self . btnAgregar . setFont ( font ) <NEWLINE> self . btnAgregar . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"VentanaPrincipal\"", "\"cwgtPrincipal\"", "\"color: rgb(51, 102, 255);\"", "\"lblBazarPapeleria\"", "\"Arial\"", "\"color: rgb(223, 15, 90);\\n\""]}, "window_span": [294, 300], "err_obj": {"msg": "unbalanced (){}[]"}}], ["8dd6bec6d4306747286efeeb303436d0", {"code_string": "def wait_for_tool_in_spindle(self, expected_tool, timeout = 10.0):\n    \"\"\"Arguments:\"\"\"\n    start_time = time.time()\n    while(time.time() - start_time) < timeout:\n        time.sleep(0.1)\n            self.status.poll()\n        if self.status.tool_in_spindle == expected_tool:\n        print(\"the Stat buffer's toolInSpindle reached the value of %d after %f seconds\" %(expected_tool, time.time() - start_time))\n        return\n    raise LinuxCNC_Exception(\"the Stat buffer's toolInSpindle value is %d, expected %d\" %(self.status.tool_in_spindle, expected_tool))\n", "code_toks_joined": "def wait_for_tool_in_spindle ( self , expected_tool , timeout = 10.0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> start_time = time . time ( ) <NEWLINE> while ( time . time ( ) - start_time ) < timeout : <NEWLINE> <INDENT> time . sleep ( 0.1 ) <NEWLINE> <INDENT> self . status . poll ( ) <NEWLINE> <DEDENT> if self . status . tool_in_spindle == expected_tool : <NEWLINE> print ( <STRING> % ( expected_tool , time . time ( ) - start_time ) ) <NEWLINE> return <NEWLINE> <DEDENT> raise LinuxCNC_Exception ( <STRING> % ( self . status . tool_in_spindle , expected_tool ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Arguments:\"\"\"", "\"the Stat buffer's toolInSpindle reached the value of %d after %f seconds\"", "\"the Stat buffer's toolInSpindle value is %d, expected %d\""]}, "err_obj": {"msg": "unexpected indent"}}], ["78be687f4084099b5a7036eebe8e03dd", {"code_string": "import hashlib\nimport os\ndef CallAndRecordIfStale(\n    function, record_path = None, input_paths = None, input_strings = None,\n    force = False):\n    \"\"\"Calls function if the md5sum of the input paths/strings has changed.\"\"\"\n    if not input_paths:\n    input_paths = []\n    if not input_strings:\n    input_strings = []\n    md5_checker = _Md5Checker(\n        record_path = record_path,\n        input_paths = input_paths,\n        input_strings = input_strings)\n        if force or md5_checker.IsStale():\n    function()\n    md5_checker.Write()\n", "code_toks_joined": "import hashlib <NEWLINE> import os <NEWLINE> def CallAndRecordIfStale ( <NEWLINE> <INDENT> function , record_path = None , input_paths = None , input_strings = None , <NEWLINE> force = False ) : <NEWLINE> <STRING> <NEWLINE> if not input_paths : <NEWLINE> input_paths = [ ] <NEWLINE> if not input_strings : <NEWLINE> input_strings = [ ] <NEWLINE> md5_checker = _Md5Checker ( <NEWLINE> <INDENT> record_path = record_path , <NEWLINE> input_paths = input_paths , <NEWLINE> input_strings = input_strings ) <NEWLINE> if force or md5_checker . IsStale ( ) : <NEWLINE> <DEDENT> function ( ) <NEWLINE> md5_checker . Write ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Calls function if the md5sum of the input paths/strings has changed.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["a329be3e5b1013df12bb9a458f25fad6", {"code_string": "def readSection(self, section):\n    self.sectionData[self.sections[section] = np.genfromtxt(self.datafile,\n        delimiter = \" \",\n        skip_header = (int(self.sectionBegin[section]) - 1),\n        skip_footer = (self.fileLen - int(self.sectionEnd[section])),\n        filling_values = 0,\n        invalid_raise = False,\n        unpack = True\n        )\n", "code_toks_joined": "def readSection ( self , section ) : <NEWLINE> <INDENT> self . sectionData [ self . sections [ section ] = np . genfromtxt ( self . datafile , <NEWLINE> <INDENT> delimiter = <STRING> , <NEWLINE> skip_header = ( int ( self . sectionBegin [ section ] ) - 1 ) , <NEWLINE> skip_footer = ( self . fileLen - int ( self . sectionEnd [ section ] ) ) , <NEWLINE> filling_values = 0 , <NEWLINE> invalid_raise = False , <NEWLINE> unpack = True <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\" \""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["a0ddf8d5ded105546ac861014c4d8509", {"code_string": "def __setattr__(self k, v):\n    done, v = DummySettingsManager.__setattr__(self, k, v)\n    if done:\n        return\n    if k in self._save:\n        print('info: saving setting: \\'{0}\\''.format(k))\n        self._save[k] = v\n        self.dump(False)\n", "code_toks_joined": "def __setattr__ ( self k , v ) : <NEWLINE> <INDENT> done , v = DummySettingsManager . __setattr__ ( self , k , v ) <NEWLINE> if done : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if k in self . _save : <NEWLINE> <INDENT> print ( <STRING> . format ( k ) ) <NEWLINE> self . _save [ k ] = v <NEWLINE> self . dump ( False ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'info: saving setting: \\'{0}\\''"]}, "err_obj": {"msg": "invalid syntax"}}], ["395b0d10ce613c5e0c1daae0524d40c7", {"code_string": "def shortest_paths_from(from_user):\n    shortest_paths_to = {from_user[\"id\"]: [[]]}\n    frontier = deque((from_user, frined) for friend in from_user[\"friends\"])\n    while frontier:\n        prev_user, user = frontier.popleft()\n        user_id = user[\"id\"]\n        paths_to_prev_user = shortest_paths_to[prev_user[\"id\"]]\n        new_paths_to_user = [path +[user_id] for path in paths_to_prev_user]\n        old_paths_to_user = shortest_paths_to.get(user_id, [])\n        if old_paths_to_user:\n            min_path_length = len(old_paths_to_user[0])\n        else:\n            min_path_length = float('inf')\n        new_paths_to_user = [path for path in new_paths_to_user\n            if len(path) <= min_path_length\n            and path not in old_paths_to_user]\n        shortest_paths_to[user_id] = old_paths_to_user + new_paths_to_user\n        frontier.extend(user, friend)\n            for friend in user[\"friends\"]\n            if friend[\"id\"] not in shortest_paths_from)\n    return shortest_paths_from\n", "code_toks_joined": "def shortest_paths_from ( from_user ) : <NEWLINE> <INDENT> shortest_paths_to = { from_user [ <STRING> ] : [ [ ] ] } <NEWLINE> frontier = deque ( ( from_user , frined ) for friend in from_user [ <STRING> ] ) <NEWLINE> while frontier : <NEWLINE> <INDENT> prev_user , user = frontier . popleft ( ) <NEWLINE> user_id = user [ <STRING> ] <NEWLINE> paths_to_prev_user = shortest_paths_to [ prev_user [ <STRING> ] ] <NEWLINE> new_paths_to_user = [ path + [ user_id ] for path in paths_to_prev_user ] <NEWLINE> old_paths_to_user = shortest_paths_to . get ( user_id , [ ] ) <NEWLINE> if old_paths_to_user : <NEWLINE> <INDENT> min_path_length = len ( old_paths_to_user [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_path_length = float ( <STRING> ) <NEWLINE> <DEDENT> new_paths_to_user = [ path for path in new_paths_to_user <NEWLINE> <INDENT> if len ( path ) <= min_path_length <NEWLINE> and path not in old_paths_to_user ] <NEWLINE> <DEDENT> shortest_paths_to [ user_id ] = old_paths_to_user + new_paths_to_user <NEWLINE> frontier . extend ( user , friend ) <NEWLINE> <INDENT> for friend in user [ <STRING> ] <NEWLINE> if friend [ <STRING> ] not in shortest_paths_from ) <NEWLINE> <DEDENT> <DEDENT> return shortest_paths_from <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"id\"", "\"friends\"", "\"id\"", "\"id\"", "'inf'", "\"friends\"", "\"id\""]}, "window_span": [179, 189], "err_obj": {"msg": "unbalanced (){}[]"}}], ["397270fb751a5286c92985a66d6d7464", {"code_string": "< % if(isPaymentPackage){% > from django.views.generic import RedirectView, View\nimport oscar\nfrom oscar.core.loading import get_class, get_model\nPaymentDetailsView = get_class('checkout.views', 'PaymentDetailsView')\nCheckoutSessionMixin = get_class('checkout.session', 'CheckoutSessionMixin')\n", "code_toks_joined": "< % if ( isPaymentPackage ) { % > from django . views . generic import RedirectView , View <NEWLINE> import oscar <NEWLINE> from oscar . core . loading import get_class , get_model <NEWLINE> PaymentDetailsView = get_class ( <STRING> , <STRING> ) <NEWLINE> CheckoutSessionMixin = get_class ( <STRING> , <STRING> ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["'checkout.views'", "'PaymentDetailsView'", "'checkout.session'", "'CheckoutSessionMixin'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e09f8d09d003716d0b25a507bacfb1dd", {"code_string": "def from_html(self, html):\n    \"\"\"Convert HTML source to wikitext\"\"\"\n    try:\n        soup = BeautifulSoup.BeautifulSoup(html,\n            convertEntities = BeautifulSoup.BeautifulSoup.XHTML_ENTITIES)\n    except:\n        raise self.ParseError, \"Could not parse HTML\"\n    return self.from_soup(soup)\n", "code_toks_joined": "def from_html ( self , html ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> soup = BeautifulSoup . BeautifulSoup ( html , <NEWLINE> <INDENT> convertEntities = BeautifulSoup . BeautifulSoup . XHTML_ENTITIES ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> raise self . ParseError , <STRING> <NEWLINE> <DEDENT> return self . from_soup ( soup ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Convert HTML source to wikitext\"\"\"", "\"Could not parse HTML\""]}, "err_obj": {"msg": "invalid syntax"}}], ["02b9c8c0d6483fe442944641879e90c8", {"code_string": "def _ForwardStageFull(self, ctr, in_a, in_b, in_c, in_rhs):\n    \"\"\"The 'Do' function of the Forward stage, applied over the FullDomain.-\"\"\"\n    self.tmp[ctr] = in_c[ctr[0, 0, - 1]] / self.bet[ctr]\n    self.bet[ctr] = in_b[ctr] - in_a[ctr] * self.tmp[ctr]\n    self.y[ctr] = (in_rhs[ctr] -\n        in_a[ctr] * self.y[ctr[0, 0, - 1]] / self.bet[ctr]\n", "code_toks_joined": "def _ForwardStageFull ( self , ctr , in_a , in_b , in_c , in_rhs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . tmp [ ctr ] = in_c [ ctr [ 0 , 0 , - 1 ] ] / self . bet [ ctr ] <NEWLINE> self . bet [ ctr ] = in_b [ ctr ] - in_a [ ctr ] * self . tmp [ ctr ] <NEWLINE> self . y [ ctr ] = ( in_rhs [ ctr ] - <NEWLINE> <INDENT> in_a [ ctr ] * self . y [ ctr [ 0 , 0 , - 1 ] ] / self . bet [ ctr ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"The 'Do' function of the Forward stage, applied over the FullDomain.-\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["b84dd5b416551c471bd9bc8d13b1c4f7", {"code_string": "def putline(self, line):\n    if self.debugging > 1: print '*put*', repr(line)\n    line += CRLF\n    bytes = len(line)\n    while bytes > 0:\n        sent = self.sslobj.write(line)\n        if sent == bytes:\n            break\n        line = line[sent: ]\n        bytes = bytes - sent\n", "code_toks_joined": "def putline ( self , line ) : <NEWLINE> <INDENT> if self . debugging > 1 : print <STRING> , repr ( line ) <NEWLINE> line += CRLF <NEWLINE> bytes = len ( line ) <NEWLINE> while bytes > 0 : <NEWLINE> <INDENT> sent = self . sslobj . write ( line ) <NEWLINE> if sent == bytes : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> line = line [ sent : ] <NEWLINE> bytes = bytes - sent <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'*put*'"]}, "err_obj": {"msg": "invalid syntax"}}], ["c8a37b2628f81f6692002982376c207e", {"code_string": "def printVariant(self, delim, ** kwargs):\n    onlyThisVariant = kwargs.get('minimal', False)\n    if not onlyThisVariant:\n        super(vepcolocatedvariant, self).printVariant(delim, ** kwargs)\n    print(\"vepcolocatedvariant: { \",\n    if self.ID:\n        print(\"ID=\", )\n        print(self.ID + delim, )\n    if self.phenotypeOrDisease:\n        print(\"phenotypeOrDisease= \" + self.phenotypeOrDisease + delim, )\n    if self.somatic:\n        print(\"somatic= \" + self.somatic)\n    print(\" }\")\n", "code_toks_joined": "def printVariant ( self , delim , ** kwargs ) : <NEWLINE> <INDENT> onlyThisVariant = kwargs . get ( <STRING> , False ) <NEWLINE> if not onlyThisVariant : <NEWLINE> <INDENT> super ( vepcolocatedvariant , self ) . printVariant ( delim , ** kwargs ) <NEWLINE> <DEDENT> print ( <STRING> , <NEWLINE> if self . ID : <NEWLINE> <INDENT> print ( <STRING> , ) <NEWLINE> print ( self . ID + delim , ) <NEWLINE> <DEDENT> if self . phenotypeOrDisease : <NEWLINE> <INDENT> print ( <STRING> + self . phenotypeOrDisease + delim , ) <NEWLINE> <DEDENT> if self . somatic : <NEWLINE> <INDENT> print ( <STRING> + self . somatic ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'minimal'", "\"vepcolocatedvariant: { \"", "\"ID=\"", "\"phenotypeOrDisease= \"", "\"somatic= \"", "\" }\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["2644fb0bbd3081c55cdf44f65f2c6e8b", {"code_string": "def db4_file_classes_request(filepath, path_to_db4):\n    mydb = bsddb.btopen(path_to_db4 + \".cl\", 'r')\n    mykeys = mydb.keys()\n    respond = []\n    for key, val in mydb.iteritems():\n    s_key = key.rsplit('\\x01')\n    s_val = val.rsplit('\\x01')\n    if s_key[2].find(filepath) >= 0:\n        respond.append({'title': s_key[0], 'isLazy': 'false', 'addClass': 'iconclass'})\n    return respond\n", "code_toks_joined": "def db4_file_classes_request ( filepath , path_to_db4 ) : <NEWLINE> <INDENT> mydb = bsddb . btopen ( path_to_db4 + <STRING> , <STRING> ) <NEWLINE> mykeys = mydb . keys ( ) <NEWLINE> respond = [ ] <NEWLINE> for key , val in mydb . iteritems ( ) : <NEWLINE> s_key = key . rsplit ( <STRING> ) <NEWLINE> s_val = val . rsplit ( <STRING> ) <NEWLINE> if s_key [ 2 ] . find ( filepath ) >= 0 : <NEWLINE> <INDENT> respond . append ( { <STRING> : s_key [ 0 ] , <STRING> : <STRING> , <STRING> : <STRING> } ) <NEWLINE> <DEDENT> return respond <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\".cl\"", "'r'", "'\\x01'", "'\\x01'", "'title'", "'isLazy'", "'false'", "'addClass'", "'iconclass'"]}, "err_obj": {"msg": "expected an indented block"}}], ["4e00d322b6a5fe74537ab7eb393b3ba8", {"code_string": "def __init__(self, data, tag):\n    self._data = data\n    self._lrtype = parseTypeTag(tag)\n    def __lrtype__(self):\n    return self._lrtype\n", "code_toks_joined": "def __init__ ( self , data , tag ) : <NEWLINE> <INDENT> self . _data = data <NEWLINE> self . _lrtype = parseTypeTag ( tag ) <NEWLINE> def __lrtype__ ( self ) : <NEWLINE> return self . _lrtype <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["1105e31233ba13276ff163d329563486", {"code_string": "def run():\n    params = plugintools.get_params()\n    if params.get(\"action\") is None:\n        xbmc.Player().play(entryurl)\n        while xbmc.Player().isPlaying():\n            time.sleep(1)\n        main_list(params)\n    else:\n        action = params.get(\"action\")\n        exec action + \"(params)\"\n    plugintools.close_item_list()\n", "code_toks_joined": "def run ( ) : <NEWLINE> <INDENT> params = plugintools . get_params ( ) <NEWLINE> if params . get ( <STRING> ) is None : <NEWLINE> <INDENT> xbmc . Player ( ) . play ( entryurl ) <NEWLINE> while xbmc . Player ( ) . isPlaying ( ) : <NEWLINE> <INDENT> time . sleep ( 1 ) <NEWLINE> <DEDENT> main_list ( params ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> action = params . get ( <STRING> ) <NEWLINE> exec action + <STRING> <NEWLINE> <DEDENT> plugintools . close_item_list ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"action\"", "\"action\"", "\"(params)\""]}, "err_obj": {"msg": "invalid syntax"}}], ["431eedf76657f00b713918c4393adee4", {"code_string": "def test_set_power_state_reboot(self, run_method_mock):\n    with task_manager.acquire(self.context, self.node.uuid,\n        shared = False) as task:\n        task.driver.power.set_power_state(task, states.REBOOT)\n        run_method_mock.assert_any_call(task.node,\n            'reboot',\n            'stop')\n            run_method_mock.assert_any_call(task.node,\n            'reboot',\n            'start')\n", "code_toks_joined": "def test_set_power_state_reboot ( self , run_method_mock ) : <NEWLINE> <INDENT> with task_manager . acquire ( self . context , self . node . uuid , <NEWLINE> <INDENT> shared = False ) as task : <NEWLINE> task . driver . power . set_power_state ( task , states . REBOOT ) <NEWLINE> run_method_mock . assert_any_call ( task . node , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ) <NEWLINE> run_method_mock . assert_any_call ( task . node , <NEWLINE> <STRING> , <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'reboot'", "'stop'", "'reboot'", "'start'"]}, "err_obj": {"msg": "unexpected indent"}}], ["327e486d0cce946f2365bdaa16a9b011", {"code_string": "def save_shp(self, shape_file, user):\n    \"\"\"Saves a shape file on server\"\"\"\n        shp = shape_file['shp']\n        shx = shape_file['shx']\n        dbf = shape_file['dbf']\n        prj = shape_file['prj']\n        file_saved = ShapeFile.objects.create(shp = shp, shx = shx,\n            dbf = dbf, prj = prj,\n            owner = user)\n        return file_saved\n", "code_toks_joined": "def save_shp ( self , shape_file , user ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> shp = shape_file [ <STRING> ] <NEWLINE> shx = shape_file [ <STRING> ] <NEWLINE> dbf = shape_file [ <STRING> ] <NEWLINE> prj = shape_file [ <STRING> ] <NEWLINE> file_saved = ShapeFile . objects . create ( shp = shp , shx = shx , <NEWLINE> <INDENT> dbf = dbf , prj = prj , <NEWLINE> owner = user ) <NEWLINE> <DEDENT> return file_saved <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Saves a shape file on server\"\"\"", "'shp'", "'shx'", "'dbf'", "'prj'"]}, "err_obj": {"msg": "unexpected indent"}}], ["b0c75d59022d6ab64c7d078c4049b60e", {"code_string": "def PrintSummary(self, trace_tag):\n    if self.page_failures:\n        return\n    for measurement_units_type, values in sorted(\n        self.results_summary.iteritems()):\n        measurement, units, data_type = measurement_units_type\n        if '.' in measurement:\n        measurement, trace = measurement.split('.', 1)\n        trace +=(trace_tag or '')\n        else:\n        trace = measurement +(trace_tag or '')\n        PrintPerfResult(measurement, trace, values, units, data_type)\n", "code_toks_joined": "def PrintSummary ( self , trace_tag ) : <NEWLINE> <INDENT> if self . page_failures : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for measurement_units_type , values in sorted ( <NEWLINE> <INDENT> self . results_summary . iteritems ( ) ) : <NEWLINE> measurement , units , data_type = measurement_units_type <NEWLINE> if <STRING> in measurement : <NEWLINE> measurement , trace = measurement . split ( <STRING> , 1 ) <NEWLINE> trace += ( trace_tag or <STRING> ) <NEWLINE> else : <NEWLINE> trace = measurement + ( trace_tag or <STRING> ) <NEWLINE> PrintPerfResult ( measurement , trace , values , units , data_type ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'.'", "'.'", "''", "''"]}, "err_obj": {"msg": "expected an indented block"}}], ["605afb10354feef87a6e09291ea0e33d", {"code_string": "def test_unassigned(function, * args):\n    try:\n        function(* args)\n    except UnboundLocalError, n:\n        pass\n    else:\n        Fail(\"%s: expected unassigned variable exception, but no exception caught\" % function.func_name)\n", "code_toks_joined": "def test_unassigned ( function , * args ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> function ( * args ) <NEWLINE> <DEDENT> except UnboundLocalError , n : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Fail ( <STRING> % function . func_name ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"%s: expected unassigned variable exception, but no exception caught\""]}, "err_obj": {"msg": "invalid syntax"}}], ["aef030bf0fedb6244c1a36914db2e448", {"code_string": "def off():\n    led = Pin(args.sensor, 'OUTPUT')\n    print(\"off-ing %s\" % args.sensor)\n    led.off()\n    pin_status = subprocess.check_output([\"cat\", \"/sys/class/gpio/pio\" + pin_kernel + \"/value\"])\n        if pin_status.strip() != \"0\":\n            print(\"ERROR! Action failed, pin status = %s\" % pin_status.strip())\n        else:\n            print(\"Action complete, pin status: %s\" % pin_status.strip())\n", "code_toks_joined": "def off ( ) : <NEWLINE> <INDENT> led = Pin ( args . sensor , <STRING> ) <NEWLINE> print ( <STRING> % args . sensor ) <NEWLINE> led . off ( ) <NEWLINE> pin_status = subprocess . check_output ( [ <STRING> , <STRING> + pin_kernel + <STRING> ] ) <NEWLINE> <INDENT> if pin_status . strip ( ) != <STRING> : <NEWLINE> <INDENT> print ( <STRING> % pin_status . strip ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> % pin_status . strip ( ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'OUTPUT'", "\"off-ing %s\"", "\"cat\"", "\"/sys/class/gpio/pio\"", "\"/value\"", "\"0\"", "\"ERROR! Action failed, pin status = %s\"", "\"Action complete, pin status: %s\""]}, "err_obj": {"msg": "unexpected indent"}}], ["6cff7b78b764855cf9720723410ea698", {"code_string": "def __onKeyClick(self, evt):\n    button = (evt.GetEventObject()).Label\n    passwd = self.focus.GetValue()\n    if button == 'DEL':\n        if len(passwd) > 0:\n        passwd = passwd[: - 1]\n        self.focus.SetValue(passwd)\n    elif button == 'ENABLE':\n        self.Close()\n    else:\n        passwd += button\n        self.focus.SetValue(passwd)\n", "code_toks_joined": "def __onKeyClick ( self , evt ) : <NEWLINE> <INDENT> button = ( evt . GetEventObject ( ) ) . Label <NEWLINE> passwd = self . focus . GetValue ( ) <NEWLINE> if button == <STRING> : <NEWLINE> <INDENT> if len ( passwd ) > 0 : <NEWLINE> passwd = passwd [ : - 1 ] <NEWLINE> self . focus . SetValue ( passwd ) <NEWLINE> <DEDENT> elif button == <STRING> : <NEWLINE> <INDENT> self . Close ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> passwd += button <NEWLINE> self . focus . SetValue ( passwd ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'DEL'", "'ENABLE'"]}, "err_obj": {"msg": "expected an indented block"}}], ["229c8357f71abfcb84f9e6087334f71f", {"code_string": "def on_key_pressed(widget, event):\n    if(event.state & gtk.gdk.CONTROL_MASK and\n        event.keyval == gtk.gdk.keyval_from_name('l')):\n        if widget.view == 'week':\n        widget.set_view('month')\n        else:\n        widget.set_view('week')\n", "code_toks_joined": "def on_key_pressed ( widget , event ) : <NEWLINE> <INDENT> if ( event . state & gtk . gdk . CONTROL_MASK and <NEWLINE> <INDENT> event . keyval == gtk . gdk . keyval_from_name ( <STRING> ) ) : <NEWLINE> if widget . view == <STRING> : <NEWLINE> widget . set_view ( <STRING> ) <NEWLINE> else : <NEWLINE> widget . set_view ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'l'", "'week'", "'month'", "'week'"]}, "err_obj": {"msg": "expected an indented block"}}], ["5082de9b931153bf61283644d74c87e5", {"code_string": "def test_ensure_gateways_present_is_executed_once(self):\n    with patch.object(\n        objects.Cluster.get_network_manager(self.cluster),\n        'ensure_gateways_present_in_default_node_group') as ensure_mock:\n        for n in range(2):\n        resp = self.env.create_node_group(name = 'group{0}'.format(n))\n        self.assertEquals(resp.status_code, 201)\n        self.assertEqual(\n            ensure_mock.call_count, 1,\n            'Method was called {0} time(s) unexpectedly, '\n            'current node group: {1}'.format(ensure_mock.call_count,\n                resp.json_body['name']))\n", "code_toks_joined": "def test_ensure_gateways_present_is_executed_once ( self ) : <NEWLINE> <INDENT> with patch . object ( <NEWLINE> <INDENT> objects . Cluster . get_network_manager ( self . cluster ) , <NEWLINE> <STRING> ) as ensure_mock : <NEWLINE> for n in range ( 2 ) : <NEWLINE> resp = self . env . create_node_group ( name = <STRING> . format ( n ) ) <NEWLINE> self . assertEquals ( resp . status_code , 201 ) <NEWLINE> self . assertEqual ( <NEWLINE> <INDENT> ensure_mock . call_count , 1 , <NEWLINE> <STRING> <NEWLINE> <STRING> . format ( ensure_mock . call_count , <NEWLINE> <INDENT> resp . json_body [ <STRING> ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'ensure_gateways_present_in_default_node_group'", "'group{0}'", "'Method was called {0} time(s) unexpectedly, '", "'current node group: {1}'", "'name'"]}, "err_obj": {"msg": "expected an indented block"}}], ["b070a601174a44f6d41664cc54529070", {"code_string": "def callback():\n    if p.input('test'):\n    print(\"high\")\n    else:\n    print(\"low\")\n", "code_toks_joined": "def callback ( ) : <NEWLINE> <INDENT> if p . input ( <STRING> ) : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'test'", "\"high\"", "\"low\""]}, "err_obj": {"msg": "expected an indented block"}}], ["0fe76f7d2acb41d3047a1fef0e2c28be", {"code_string": "def test_parsePlaylistFeed(self):\n    self._mockFeedCall('playlists', 'playlists')\n    plEntries = list(yt.iPlaylistEntries(self.account.username)\n    self.assertEqual(len(plEntries), 13)\n    pls = map(yt.entry2group, plEntries)\n    extId, name = pls[0]\n    self.assertEqual(name, \"Ads\")\n    self.assertEqual(extId,\n        'http: //gdata.youtube.com/feeds/playlists/FFF43205215330C')\n    self.cliMock.verify()\n", "code_toks_joined": "def test_parsePlaylistFeed ( self ) : <NEWLINE> <INDENT> self . _mockFeedCall ( <STRING> , <STRING> ) <NEWLINE> plEntries = list ( yt . iPlaylistEntries ( self . account . username ) <NEWLINE> self . assertEqual ( len ( plEntries ) , 13 ) <NEWLINE> pls = map ( yt . entry2group , plEntries ) <NEWLINE> extId , name = pls [ 0 ] <NEWLINE> self . assertEqual ( name , <STRING> ) <NEWLINE> self . assertEqual ( extId , <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> self . cliMock . verify ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'playlists'", "'playlists'", "\"Ads\"", "'http: //gdata.youtube.com/feeds/playlists/FFF43205215330C'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["fa84e357405af298bd04ecbc228bacdc", {"code_string": "class Ui_sign_inDialog(object):\n    def setupUi(self, sign_inDialog):\n        sign_inDialog.setObjectName(\"sign_inDialog\")\n        sign_inDialog.setWindowModality(QtCore.Qt.ApplicationModal)\n        sign_inDialog.resize(400, 300)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(sign_inDialog.sizePolicy().hasHeightForWidth())\n        sign_inDialog.setSizePolicy(sizePolicy)\n        sign_inDialog.setStyleSheet(\"QDialog {\\n\"\n", "code_toks_joined": "class Ui_sign_inDialog ( object ) : <NEWLINE> <INDENT> def setupUi ( self , sign_inDialog ) : <NEWLINE> <INDENT> sign_inDialog . setObjectName ( <STRING> ) <NEWLINE> sign_inDialog . setWindowModality ( QtCore . Qt . ApplicationModal ) <NEWLINE> sign_inDialog . resize ( 400 , 300 ) <NEWLINE> sizePolicy = QtWidgets . QSizePolicy ( QtWidgets . QSizePolicy . Fixed , QtWidgets . QSizePolicy . Fixed ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( sign_inDialog . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> sign_inDialog . setSizePolicy ( sizePolicy ) <NEWLINE> sign_inDialog . setStyleSheet ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"sign_inDialog\"", "\"QDialog {\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["582883ecc8757e73e0833d0638d48be2", {"code_string": "def _stop(self, signame: str):\n    print('\\ngot signal{} - exiting'.format(signame)\n    self._loop.stop()\n", "code_toks_joined": "def _stop ( self , signame : str ) : <NEWLINE> <INDENT> print ( <STRING> . format ( signame ) <NEWLINE> self . _loop . stop ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'\\ngot signal{} - exiting'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["f9c6901e77816315805308215f60a5aa", {"code_string": "def on_config_sensors(self, client, userdata, msg):\n    self.logger.info('Config config_sensors received')\n    with self.config_sensors_lock:\n        self.sensors.update(json.loads(msg.payload))\n    if not self.config_sensors_received.is_set()\n        self.logger.info('Config config_sensors for the first time received, subscribing to channel_config')\n        self.config_sensors_received.set()\n        client.subscribe(\"channel_config/{module_id}/+/\".format(module_id = self.module_id))\n    if self.config_channels_received.is_set():\n        self.update_sensors()\n", "code_toks_joined": "def on_config_sensors ( self , client , userdata , msg ) : <NEWLINE> <INDENT> self . logger . info ( <STRING> ) <NEWLINE> with self . config_sensors_lock : <NEWLINE> <INDENT> self . sensors . update ( json . loads ( msg . payload ) ) <NEWLINE> <DEDENT> if not self . config_sensors_received . is_set ( ) <NEWLINE> <INDENT> self . logger . info ( <STRING> ) <NEWLINE> self . config_sensors_received . set ( ) <NEWLINE> client . subscribe ( <STRING> . format ( module_id = self . module_id ) ) <NEWLINE> <DEDENT> if self . config_channels_received . is_set ( ) : <NEWLINE> <INDENT> self . update_sensors ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Config config_sensors received'", "'Config config_sensors for the first time received, subscribing to channel_config'", "\"channel_config/{module_id}/+/\""]}, "err_obj": {"msg": "invalid syntax"}}], ["ef34df9ac57f0238dd9274fa8c9185fb", {"code_string": "def c_code_cache_version(self):\n    version = []\n    for t, (c, v) in sorted(iteritems(self.c_code_and_version),\n        key = lambda pair: str(pair[0])):\n        if not v:\n        warnings.warn(\"Type %s has C code for ViewOp, but it has no \"\n        \"version. You should add a 'version' keyword \"\n        \"arg when calling register_view_op_c_code.\" % t,\n        stacklevel = 2)\n        return()\n        version.append((str(t), v))\n    return tuple(version)\n", "code_toks_joined": "def c_code_cache_version ( self ) : <NEWLINE> <INDENT> version = [ ] <NEWLINE> for t , ( c , v ) in sorted ( iteritems ( self . c_code_and_version ) , <NEWLINE> <INDENT> key = lambda pair : str ( pair [ 0 ] ) ) : <NEWLINE> if not v : <NEWLINE> warnings . warn ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> % t , <NEWLINE> stacklevel = 2 ) <NEWLINE> return ( ) <NEWLINE> version . append ( ( str ( t ) , v ) ) <NEWLINE> <DEDENT> return tuple ( version ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Type %s has C code for ViewOp, but it has no \"", "\"version. You should add a 'version' keyword \"", "\"arg when calling register_view_op_c_code.\""]}, "err_obj": {"msg": "expected an indented block"}}], ["cea1f8b6c2c67f4edceabeafe2f0aada", {"code_string": "def load_tests(loader, tests, ignore):\n    tests.addTests(doctest.DocTestSuite(cloudtracker))\n        return tests\n", "code_toks_joined": "def load_tests ( loader , tests , ignore ) : <NEWLINE> <INDENT> tests . addTests ( doctest . DocTestSuite ( cloudtracker ) ) <NEWLINE> <INDENT> return tests <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["3d57802f4726d22ffd09582c3dd51035", {"code_string": "def packRequest_pty_req(term, (rows, cols, xpixel, ypixel), modes):\n    \"\"\"Pack a pty-req request so that it is suitable for sending.\"\"\"\n    termPacked = common.NS(term)\n    winSizePacked = struct.pack('>4L', cols, rows, xpixel, ypixel)\n    modesPacked = common.NS(modes)\n    return termPacked + winSizePacked + modesPacked\n", "code_toks_joined": "def packRequest_pty_req ( term , ( rows , cols , xpixel , ypixel ) , modes ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> termPacked = common . NS ( term ) <NEWLINE> winSizePacked = struct . pack ( <STRING> , cols , rows , xpixel , ypixel ) <NEWLINE> modesPacked = common . NS ( modes ) <NEWLINE> return termPacked + winSizePacked + modesPacked <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Pack a pty-req request so that it is suitable for sending.\"\"\"", "'>4L'"]}, "err_obj": {"msg": "invalid syntax"}}], ["d92d37d79011fdc7cb69ae899a89e77d", {"code_string": "def _irfft_wrapper(ifft_fn, fft_rank, default_name):\n    \"\"\"Wrapper around gen_spectral_ops.irfft* that infers fft_length argument.\"\"\"\n    def _irfft(input_tensor, fft_length = None, name = None):\n        with _ops.name_scope(name, default_name,\n            [input_tensor, fft_length]) as name:\n            input_tensor = _ops.convert_to_tensor(input_tensor, _dtypes.complex64)\n            if fft_length is None:\n            fft_length = _infer_fft_length_for_irfft(input_tensor, fft_rank)\n            else:\n            fft_length = _ops.convert_to_tensor(fft_length, _dtypes.int32)\n            return ifft_fn(input_tensor, fft_length, name)\n    _irfft.__doc__ = ifft_fn.__doc__\n    return _irfft\n", "code_toks_joined": "def _irfft_wrapper ( ifft_fn , fft_rank , default_name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def _irfft ( input_tensor , fft_length = None , name = None ) : <NEWLINE> <INDENT> with _ops . name_scope ( name , default_name , <NEWLINE> <INDENT> [ input_tensor , fft_length ] ) as name : <NEWLINE> input_tensor = _ops . convert_to_tensor ( input_tensor , _dtypes . complex64 ) <NEWLINE> if fft_length is None : <NEWLINE> fft_length = _infer_fft_length_for_irfft ( input_tensor , fft_rank ) <NEWLINE> else : <NEWLINE> fft_length = _ops . convert_to_tensor ( fft_length , _dtypes . int32 ) <NEWLINE> return ifft_fn ( input_tensor , fft_length , name ) <NEWLINE> <DEDENT> <DEDENT> _irfft . __doc__ = ifft_fn . __doc__ <NEWLINE> return _irfft <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Wrapper around gen_spectral_ops.irfft* that infers fft_length argument.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["b66ee45a357a3cba035554ef1ac5939c", {"code_string": "def checkparam1_retained(self):\n    if hasattr(self, 'param1'):\n        print(\"param1 was retained, value = \", self.param1)\n    else:\n        return \"param1 was not retained across invocations\"\n    if hasattr(interpreter, 'this'):\n    print(\"this is self:\", self is interpreter.this)\n    else:\n        print(\"module interpreter: no 'this' attribute\")\n", "code_toks_joined": "def checkparam1_retained ( self ) : <NEWLINE> <INDENT> if hasattr ( self , <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> , self . param1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if hasattr ( interpreter , <STRING> ) : <NEWLINE> print ( <STRING> , self is interpreter . this ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'param1'", "\"param1 was retained, value = \"", "\"param1 was not retained across invocations\"", "'this'", "\"this is self:\"", "\"module interpreter: no 'this' attribute\""]}, "err_obj": {"msg": "expected an indented block"}}], ["bd81c73d42d1902f64fa74005ea4fa50", {"code_string": "import gi\nfrom gi.repository import Gtk, GdkPixbuf, Gdk, GObject, Gio, GdkX11\ntry:\n    import os\n    import commands\n    import sys\n    import string\n    import gettext\n    import apt_pkg\n    from subprocess import Popen\n    import tempfile\n    import locale\nexcept Exception, detail:\n    print(detail)\n    sys.exit(1)\nAPP = 'mintlocale'\nLOCALE_DIR = \"/usr/share/linuxmint/locale\"\nlocale.bindtextdomain(APP, LOCALE_DIR)\ngettext.bindtextdomain(APP, LOCALE_DIR)\ngettext.textdomain(APP)\n_ = gettext.gettext\n", "code_toks_joined": "import gi <NEWLINE> from gi . repository import Gtk , GdkPixbuf , Gdk , GObject , Gio , GdkX11 <NEWLINE> try : <NEWLINE> <INDENT> import os <NEWLINE> import commands <NEWLINE> import sys <NEWLINE> import string <NEWLINE> import gettext <NEWLINE> import apt_pkg <NEWLINE> from subprocess import Popen <NEWLINE> import tempfile <NEWLINE> import locale <NEWLINE> <DEDENT> except Exception , detail : <NEWLINE> <INDENT> print ( detail ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> APP = <STRING> <NEWLINE> LOCALE_DIR = <STRING> <NEWLINE> locale . bindtextdomain ( APP , LOCALE_DIR ) <NEWLINE> gettext . bindtextdomain ( APP , LOCALE_DIR ) <NEWLINE> gettext . textdomain ( APP ) <NEWLINE> _ = gettext . gettext <NEWLINE>", "anonymize_dict": {"<STRING>": ["'mintlocale'", "\"/usr/share/linuxmint/locale\""]}, "err_obj": {"msg": "invalid syntax"}}], ["9b39e7411581c71849011fb65cff466c", {"code_string": "def test_unexpected_kw_arg(self):\n    \"\"\"Test UNEXPECTED_KEYWORDARG_RE.\"\"\"\n    msgs = [\n        (\"some_func() got an unexpected keyword argument 'a'\",\n            ('some_func', 'a'),\n        (\"<lambda>() got an unexpected keyword argument 'a'\",\n            ('<lambda>', 'a')),\n    ]\n    for msg, groups in msgs:\n        func, kw_arg = groups\n        named_groups = {'arg': kw_arg, 'func': func}\n        results = (groups, named_groups)\n        self.re_matches(msg, re.UNEXPECTED_KEYWORDARG_RE, results)\n", "code_toks_joined": "def test_unexpected_kw_arg ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> msgs = [ <NEWLINE> <INDENT> ( <STRING> , <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ( <STRING> , <NEWLINE> <INDENT> ( <STRING> , <STRING> ) ) , <NEWLINE> <DEDENT> <DEDENT> ] <NEWLINE> for msg , groups in msgs : <NEWLINE> <INDENT> func , kw_arg = groups <NEWLINE> named_groups = { <STRING> : kw_arg , <STRING> : func } <NEWLINE> results = ( groups , named_groups ) <NEWLINE> self . re_matches ( msg , re . UNEXPECTED_KEYWORDARG_RE , results ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Test UNEXPECTED_KEYWORDARG_RE.\"\"\"", "\"some_func() got an unexpected keyword argument 'a'\"", "'some_func'", "'a'", "\"<lambda>() got an unexpected keyword argument 'a'\"", "'<lambda>'", "'a'", "'arg'", "'func'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["3dd6dc40e30f9524e8a59e99a0521d48", {"code_string": "def crawl_imdb_title(settings, db, requests_session, imdb_id, public_domain = 0, replace_existing = False):\n    imdb_id = int(imdb_id)\n    dbc = db.execute(\"\"\"SELECT\"\"\", {\n    'imdb_id': imdb_id\n", "code_toks_joined": "def crawl_imdb_title ( settings , db , requests_session , imdb_id , public_domain = 0 , replace_existing = False ) : <NEWLINE> <INDENT> imdb_id = int ( imdb_id ) <NEWLINE> dbc = db . execute ( <STRING> , { <NEWLINE> <STRING> : imdb_id <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"SELECT\"\"\"", "'imdb_id'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["ddad034d99489fd7337f67a8299bbb6e", {"code_string": "from __future__ import division\nfrom sympy import * i\nimport itertools\n", "code_toks_joined": "from __future__ import division <NEWLINE> from sympy import * i <NEWLINE> import itertools <NEWLINE>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["172413549423f3756643bc9b0b737a07", {"code_string": "def OnText(self, event):\n    id = self.number.GetValue()\n    if len(id) == 13:\n    self.OnTextEnter(event)\n", "code_toks_joined": "def OnText ( self , event ) : <NEWLINE> <INDENT> id = self . number . GetValue ( ) <NEWLINE> if len ( id ) == 13 : <NEWLINE> self . OnTextEnter ( event ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["4cb93b89befdd3450ac36d30a445a429", {"code_string": "def test_assess_metadata_valid_url(self):\n    with extended_bootstrap_cxt('2.0.0'):\n        with patch('jujupy.ModelClient.bootstrap', autospec = True):\n            args = parse_args(['metadata', 'bar', '/foo'])\n            args.temp_env_name = 'qux'\n            bs_manager = BootstrapManager.from_args(args)\n            with patch.object(\n                bs_manager.client, 'get_model_config',\n                return_value = {'agent-metadata-url':\n                    {'value': 'example.com/valid'}}):\n                    with self.assertRaises(JujuAssertionError):\n                assess_metadata(bs_manager, None)\n", "code_toks_joined": "def test_assess_metadata_valid_url ( self ) : <NEWLINE> <INDENT> with extended_bootstrap_cxt ( <STRING> ) : <NEWLINE> <INDENT> with patch ( <STRING> , autospec = True ) : <NEWLINE> <INDENT> args = parse_args ( [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> args . temp_env_name = <STRING> <NEWLINE> bs_manager = BootstrapManager . from_args ( args ) <NEWLINE> with patch . object ( <NEWLINE> <INDENT> bs_manager . client , <STRING> , <NEWLINE> return_value = { <STRING> : <NEWLINE> <INDENT> { <STRING> : <STRING> } } ) : <NEWLINE> with self . assertRaises ( JujuAssertionError ) : <NEWLINE> <DEDENT> assess_metadata ( bs_manager , None ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'2.0.0'", "'jujupy.ModelClient.bootstrap'", "'metadata'", "'bar'", "'/foo'", "'qux'", "'get_model_config'", "'agent-metadata-url'", "'value'", "'example.com/valid'"]}, "err_obj": {"msg": "unindent does not match any outer indentation level"}}], ["830e13f5ffc8ba625aff68db065e3581", {"code_string": "def __call__(self):\n    from pybtex.exceptions import PybtexError\n    import pybtex.io\n    try:\n        self.main()\n    except PybtexError, error:\n        errors.print_error(error)\n        sys.exit(1)\n", "code_toks_joined": "def __call__ ( self ) : <NEWLINE> <INDENT> from pybtex . exceptions import PybtexError <NEWLINE> import pybtex . io <NEWLINE> try : <NEWLINE> <INDENT> self . main ( ) <NEWLINE> <DEDENT> except PybtexError , error : <NEWLINE> <INDENT> errors . print_error ( error ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["71a94fbba1012ff9867b029f86d31358", {"code_string": "def lineno():\n    \"\"\"Return the cumulative line number of the line that has just been read.\"\"\"\n    if not _state:\n        raise RuntimeError, \"no active input()\"\n    return _state.lineno()\n", "code_toks_joined": "def lineno ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not _state : <NEWLINE> <INDENT> raise RuntimeError , <STRING> <NEWLINE> <DEDENT> return _state . lineno ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return the cumulative line number of the line that has just been read.\"\"\"", "\"no active input()\""]}, "err_obj": {"msg": "invalid syntax"}}], ["9df9f8cf33b68647ee0eda68cd22c178", {"code_string": "def verify_created(self):\n    \"\"\"Verify that all checks and alarms have been created\"\"\"\n    LOGGER.info(\"--- %(datestamp)s ---\"\n        %{'datestamp': datetime.datetime.now()})\n    result = 0\n    for step in[self.compare_checks,\n        self.compare_alarms,\n        self.checks_without_alarms,\n        self.excluded_checks]:\n        step_result = step()\n        if step_result is not None:\n        result += step_result\n    if result > 0:\n        return 1\n    else:\n        LOGGER.info(\"All expected checks and alarms are present\")\n", "code_toks_joined": "def verify_created ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> LOGGER . info ( <STRING> <NEWLINE> <INDENT> % { <STRING> : datetime . datetime . now ( ) } ) <NEWLINE> <DEDENT> result = 0 <NEWLINE> for step in [ self . compare_checks , <NEWLINE> <INDENT> self . compare_alarms , <NEWLINE> self . checks_without_alarms , <NEWLINE> self . excluded_checks ] : <NEWLINE> step_result = step ( ) <NEWLINE> if step_result is not None : <NEWLINE> result += step_result <NEWLINE> <DEDENT> if result > 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> LOGGER . info ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Verify that all checks and alarms have been created\"\"\"", "\"--- %(datestamp)s ---\"", "'datestamp'", "\"All expected checks and alarms are present\""]}, "err_obj": {"msg": "expected an indented block"}}], ["5570247d5e461d59a6060ae6e496e70e", {"code_string": "def get_xclip_action_list(self, xclip, full_action_list):\n    \"\"\" Get the action list to perform. X-Clips can have an on and off action list seperated by a comma. This will return which action list to perform\"\"\"\n    result = None\n    split_list = full_action_list.split(',')\n    if xclip.is_playing:\n        result = split_list[0]\n    else:\n        if len(split_list) == 2:\n        if split_list[1].strip() == '*':\n            result = split_list[0]\n            else:\n            result = split_list[1]\n    if self._is_debugging:\n        self.log_message('get_xclip_action_list returning ' + str(result))\n    return result\n", "code_toks_joined": "def get_xclip_action_list ( self , xclip , full_action_list ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> result = None <NEWLINE> split_list = full_action_list . split ( <STRING> ) <NEWLINE> if xclip . is_playing : <NEWLINE> <INDENT> result = split_list [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( split_list ) == 2 : <NEWLINE> if split_list [ 1 ] . strip ( ) == <STRING> : <NEWLINE> <INDENT> result = split_list [ 0 ] <NEWLINE> else : <NEWLINE> result = split_list [ 1 ] <NEWLINE> <DEDENT> <DEDENT> if self . _is_debugging : <NEWLINE> <INDENT> self . log_message ( <STRING> + str ( result ) ) <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Get the action list to perform. X-Clips can have an on and off action list seperated by a comma. This will return which action list to perform\"\"\"", "','", "'*'", "'get_xclip_action_list returning '"]}, "err_obj": {"msg": "expected an indented block"}}], ["220485fc3cec4029c678b5d378204bec", {"code_string": "def datasource(lat, lon, source_dir):\n    \"\"\" Return a gdal datasource for a NED 10m lat, lon corner.\"\"\"\n    fmt = 'http://ned.stamen.com/100m/n%02dw%03d.tif.gz'\n    url = fmt %(abs(lat), abs(lon))\n    s, host, path, p, q, f = urlparse(url)\n    local_dir = md5(url).hexdigest()[: 3]\n    local_dir = join(source_dir, local_dir)\n    local_base = join(local_dir, basename(path)[: - 7])\n    local_path = local_base + '.tif'\n    local_none = local_base + '.404'\n    if exists(local_path):\n        return gdal.Open(local_path, gdal.GA_ReadOnly)\n    if exists(local_none):\n        return None\n    if not exists(local_dir):\n        mkdir(local_dir)\n        chmod(local_dir, 0 777)\n    assert isdir(local_dir)\n    print('Retrieving', url, 'in DEM.NED100m.datasource().')\n    conn = HTTPConnection(host, 80)\n    conn.request('GET', path)\n    resp = conn.getresponse()\n    if resp.status in range(400, 500):\n        print('w'), url)\n        return None\n    assert resp.status == 200, (resp.status, resp.read())\n    body = StringIO(resp.read())\n    file = GzipFile(fileobj = body, mode = 'r')\n    open(local_path, mode = 'w').write(file.read())\n    return gdal.Open(local_path, gdal.GA_ReadOnly)\n", "code_toks_joined": "def datasource ( lat , lon , source_dir ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> fmt = <STRING> <NEWLINE> url = fmt % ( abs ( lat ) , abs ( lon ) ) <NEWLINE> s , host , path , p , q , f = urlparse ( url ) <NEWLINE> local_dir = md5 ( url ) . hexdigest ( ) [ : 3 ] <NEWLINE> local_dir = join ( source_dir , local_dir ) <NEWLINE> local_base = join ( local_dir , basename ( path ) [ : - 7 ] ) <NEWLINE> local_path = local_base + <STRING> <NEWLINE> local_none = local_base + <STRING> <NEWLINE> if exists ( local_path ) : <NEWLINE> <INDENT> return gdal . Open ( local_path , gdal . GA_ReadOnly ) <NEWLINE> <DEDENT> if exists ( local_none ) : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> if not exists ( local_dir ) : <NEWLINE> <INDENT> mkdir ( local_dir ) <NEWLINE> chmod ( local_dir , 0 777 ) <NEWLINE> <DEDENT> assert isdir ( local_dir ) <NEWLINE> print ( <STRING> , url , <STRING> ) <NEWLINE> conn = HTTPConnection ( host , 80 ) <NEWLINE> conn . request ( <STRING> , path ) <NEWLINE> resp = conn . getresponse ( ) <NEWLINE> if resp . status in range ( 400 , 500 ) : <NEWLINE> <INDENT> print ( <STRING> ) , url ) <NEWLINE> return None <NEWLINE> <DEDENT> assert resp . status == 200 , ( resp . status , resp . read ( ) ) <NEWLINE> body = StringIO ( resp . read ( ) ) <NEWLINE> file = GzipFile ( fileobj = body , mode = <STRING> ) <NEWLINE> open ( local_path , mode = <STRING> ) . write ( file . read ( ) ) <NEWLINE> return gdal . Open ( local_path , gdal . GA_ReadOnly ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Return a gdal datasource for a NED 10m lat, lon corner.\"\"\"", "'http://ned.stamen.com/100m/n%02dw%03d.tif.gz'", "'.tif'", "'.404'", "'Retrieving'", "'in DEM.NED100m.datasource().'", "'GET'", "'w'", "'r'", "'w'"]}, "window_span": [214, 223], "err_obj": {"msg": "unbalanced (){}[]"}}], ["14f533deeecac2a21b02ad8298669a81", {"code_string": "def GetClines(self):\n    print(\"Now getting Demed clines!\")\n    demedClines = []\n    demedClines.append(self.__GetDemedCline())\n    demedClines = filter(None, demedClines)\n    if len(demedClines) == 0: print \"No Demed lines retrieved\"\n    return demedClines\n", "code_toks_joined": "def GetClines ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> demedClines = [ ] <NEWLINE> demedClines . append ( self . __GetDemedCline ( ) ) <NEWLINE> demedClines = filter ( None , demedClines ) <NEWLINE> if len ( demedClines ) == 0 : print <STRING> <NEWLINE> return demedClines <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Now getting Demed clines!\"", "\"No Demed lines retrieved\""]}, "err_obj": {"msg": "invalid syntax"}}], ["c7a8c1ce9b578f2f29dceac8e29f3c90", {"code_string": "def test_shapes():\n    for ip in[KroghInterpolator, BarycentricInterpolator, pchip,\n        Akima1DInterpolator]:\n        for s1 in SHAPES:\n        for s2 in SHAPES:\n            for axis in range(- len(s2), len(s2)):\n                yield check_shape, ip, s1, s2, None, axis\n", "code_toks_joined": "def test_shapes ( ) : <NEWLINE> <INDENT> for ip in [ KroghInterpolator , BarycentricInterpolator , pchip , <NEWLINE> <INDENT> Akima1DInterpolator ] : <NEWLINE> for s1 in SHAPES : <NEWLINE> for s2 in SHAPES : <NEWLINE> <INDENT> for axis in range ( - len ( s2 ) , len ( s2 ) ) : <NEWLINE> <INDENT> yield check_shape , ip , s1 , s2 , None , axis <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["70c6f8c8968e184ecd2dd8b93834b91c", {"code_string": "def generateRandomKey(keysize):\n    \"\"\"Generates a key from random data of length `keysize`.\"\"\"\n    if keysize not in(16, 24, 32):\n        emsg = 'Invalid keysize, %s. Should be one of (16, 24, 32).'\n        raise ValueError, emsg % keysize\n    return os.urandom(keysize)\n", "code_toks_joined": "def generateRandomKey ( keysize ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if keysize not in ( 16 , 24 , 32 ) : <NEWLINE> <INDENT> emsg = <STRING> <NEWLINE> raise ValueError , emsg % keysize <NEWLINE> <DEDENT> return os . urandom ( keysize ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Generates a key from random data of length `keysize`.\"\"\"", "'Invalid keysize, %s. Should be one of (16, 24, 32).'"]}, "err_obj": {"msg": "invalid syntax"}}], ["713ecb75d527f4902d604434f97ff9d9", {"code_string": "def emcCoolantMistOff(self):\n    if debug(): print \"py: emcCoolantMistOff\"\n    self.hal[\"coolant-mist\"] = 0\n    self.io.coolant.mist = 0\n    self.io.status = emctask.RCS_STATUS.RCS_DONE\n    return 0\n", "code_toks_joined": "def emcCoolantMistOff ( self ) : <NEWLINE> <INDENT> if debug ( ) : print <STRING> <NEWLINE> self . hal [ <STRING> ] = 0 <NEWLINE> self . io . coolant . mist = 0 <NEWLINE> self . io . status = emctask . RCS_STATUS . RCS_DONE <NEWLINE> return 0 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"py: emcCoolantMistOff\"", "\"coolant-mist\""]}, "err_obj": {"msg": "invalid syntax"}}], ["bbad574fc5bf7c08881dac80e3904b1d", {"code_string": "class MyHTMLParser(HTMLParser):\n    def handle_starttag(self, tag, attrs):\n        for attr in attrs:\n    boo.append(attr[1].split(\"/\")[1])\n", "code_toks_joined": "class MyHTMLParser ( HTMLParser ) : <NEWLINE> <INDENT> def handle_starttag ( self , tag , attrs ) : <NEWLINE> <INDENT> for attr in attrs : <NEWLINE> <DEDENT> boo . append ( attr [ 1 ] . split ( <STRING> ) [ 1 ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"/\""]}, "err_obj": {"msg": "expected an indented block"}}], ["d631e328511c264a6110a8c8205f7888", {"code_string": "def GetDependencies(self, required_namespaces):\n    \"\"\"Get source dependencies, in order, for the given namespaces.\"\"\"\n    if isinstance(required_namespaces, str):\n        required_namespaces = [required_namespaces]\n    deps_sources = []\n    for namespace in required_namespaces:\n        for source in DepsTree._ResolveDependencies(\n            namespace, [], self._provides_map, []):\n            if source not in deps_sources:\n            deps_sources.append(source)\n    return deps_sources\n", "code_toks_joined": "def GetDependencies ( self , required_namespaces ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if isinstance ( required_namespaces , str ) : <NEWLINE> <INDENT> required_namespaces = [ required_namespaces ] <NEWLINE> <DEDENT> deps_sources = [ ] <NEWLINE> for namespace in required_namespaces : <NEWLINE> <INDENT> for source in DepsTree . _ResolveDependencies ( <NEWLINE> <INDENT> namespace , [ ] , self . _provides_map , [ ] ) : <NEWLINE> if source not in deps_sources : <NEWLINE> deps_sources . append ( source ) <NEWLINE> <DEDENT> <DEDENT> return deps_sources <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get source dependencies, in order, for the given namespaces.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["66524444f28ad715a027acbf14f98a53", {"code_string": "def format_flags(flags):\n    names = []\n    for flag, name in[(PAI_CONTIGUOUS, 'CONTIGUOUS'),\n        (PAI_FORTRAN, 'FORTRAN'),\n        (PAI_ALIGNED, 'ALIGNED'),\n        (PAI_NOTSWAPPED, 'NOTSWAPPED'),\n        (PAI_WRITEABLE, 'WRITEABLE'),\n        (PAI_ARR_HAS_DESCR, 'ARR_HAS_DESCR')]:\n        if flag & flags:\n        names.append(name)\n    return ', '.join(names)\n", "code_toks_joined": "def format_flags ( flags ) : <NEWLINE> <INDENT> names = [ ] <NEWLINE> for flag , name in [ ( PAI_CONTIGUOUS , <STRING> ) , <NEWLINE> <INDENT> ( PAI_FORTRAN , <STRING> ) , <NEWLINE> ( PAI_ALIGNED , <STRING> ) , <NEWLINE> ( PAI_NOTSWAPPED , <STRING> ) , <NEWLINE> ( PAI_WRITEABLE , <STRING> ) , <NEWLINE> ( PAI_ARR_HAS_DESCR , <STRING> ) ] : <NEWLINE> if flag & flags : <NEWLINE> names . append ( name ) <NEWLINE> <DEDENT> return <STRING> . join ( names ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'CONTIGUOUS'", "'FORTRAN'", "'ALIGNED'", "'NOTSWAPPED'", "'WRITEABLE'", "'ARR_HAS_DESCR'", "', '"]}, "err_obj": {"msg": "expected an indented block"}}], ["98da838ad940c5dd42422c9fd6556eaa", {"code_string": "def get_points_stored_ASCII(self, i, j, k):\n    commtxt = \"TRCA? \"\n    commtxt = commtxt + str(i)\n    commtxt = commtxt \",\" + str(j)\n    commtxt = commtxt \",\" + str(k)\n    result = self.ask(commtxt)\n    return result\n", "code_toks_joined": "def get_points_stored_ASCII ( self , i , j , k ) : <NEWLINE> <INDENT> commtxt = <STRING> <NEWLINE> commtxt = commtxt + str ( i ) <NEWLINE> commtxt = commtxt <STRING> + str ( j ) <NEWLINE> commtxt = commtxt <STRING> + str ( k ) <NEWLINE> result = self . ask ( commtxt ) <NEWLINE> return result <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"TRCA? \"", "\",\"", "\",\""]}, "err_obj": {"msg": "invalid syntax"}}], ["3fd095569d2c4232a93454ce05cd38ef", {"code_string": "def close_request(self, request):\n    if self.serverAdapter:\n        self.serverAdapter._clearClientObjects(request.getpeername()\n    SimpleXMLRPCServer.close_request(self, request)\n", "code_toks_joined": "def close_request ( self , request ) : <NEWLINE> <INDENT> if self . serverAdapter : <NEWLINE> <INDENT> self . serverAdapter . _clearClientObjects ( request . getpeername ( ) <NEWLINE> <DEDENT> SimpleXMLRPCServer . close_request ( self , request ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["b80717e9a8dbdac612c78e1026af917c", {"code_string": "def size(myStack):\n    count = 0\n    while(not isinstance(myStack, noneNode):\n        count = count + 1\n        myStack = myStack.next\n", "code_toks_joined": "def size ( myStack ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> while ( not isinstance ( myStack , noneNode ) : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> myStack = myStack . next <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["b1da3036650e3d9de0526f02da2b94a0", {"code_string": "import os\nimport sys\nfrom ctk_cli import CLIArgumentParser\nsys.path.append(os.path.join(os.environ['ITK_BUILD_DIR'],\n    'Wrapping/Generators/Python'))\nsys.path.append(os.path.join(os.environ['ITK_BUILD_DIR'], 'lib')\nsys.path.append(os.environ['TUBETK_BUILD_DIR'], 'TubeTK-build/lib/TubeTK')\nimport itk\nfrom itk import TubeTKITK as itktube\n", "code_toks_joined": "import os <NEWLINE> import sys <NEWLINE> from ctk_cli import CLIArgumentParser <NEWLINE> sys . path . append ( os . path . join ( os . environ [ <STRING> ] , <NEWLINE> <INDENT> <STRING> ) ) <NEWLINE> <DEDENT> sys . path . append ( os . path . join ( os . environ [ <STRING> ] , <STRING> ) <NEWLINE> sys . path . append ( os . environ [ <STRING> ] , <STRING> ) <NEWLINE> import itk <NEWLINE> from itk import TubeTKITK as itktube <NEWLINE>", "anonymize_dict": {"<STRING>": ["'ITK_BUILD_DIR'", "'Wrapping/Generators/Python'", "'ITK_BUILD_DIR'", "'lib'", "'TUBETK_BUILD_DIR'", "'TubeTK-build/lib/TubeTK'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["98e545f9fd088cc5d82f6c5fb4111772", {"code_string": "def host_passes(self, host_state, filter_properties):\n    \"\"\"Filter based on disk usage.\"\"\"\n    instance_type = filter_properties.get('instance_type')\n    if not self._satisfies_extra_specs(host_state,\n        instance_type):\n        LOG.debug(_(\"%(host_state)s fails instance_type extra_specs \"\n            \"requirements\"), {'host_state': host_state})\n            return False\n    return True\n", "code_toks_joined": "def host_passes ( self , host_state , filter_properties ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> instance_type = filter_properties . get ( <STRING> ) <NEWLINE> if not self . _satisfies_extra_specs ( host_state , <NEWLINE> <INDENT> instance_type ) : <NEWLINE> LOG . debug ( _ ( <STRING> <NEWLINE> <INDENT> <STRING> ) , { <STRING> : host_state } ) <NEWLINE> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Filter based on disk usage.\"\"\"", "'instance_type'", "\"%(host_state)s fails instance_type extra_specs \"", "\"requirements\"", "'host_state'"]}, "err_obj": {"msg": "unexpected indent"}}], ["c00dc8525d68c1f4f3c075df96501d7d", {"code_string": "def getLdap(uid, field):\n    try:\n    l = ldap.initialize(\"ldap://ldap.collegiumv.org\")\n    l.simple_bind_s()\n    result = l.search_s(\"ou=people,dc=collegiumv,dc=org\", ldap.SCOPE_SUBTREE, \"(uid={0})\".format(uid), attrlist = [str(field)])\n    l.unbind()\n    if len(result) == 0:\n        return \"No user found\"\n        return result[0][1].itervalues().next()\n    except ldap.LDAPError, e:\n    return \"An error occurred: %s\" % e\n    except Exception as e:\n    print(e)\n", "code_toks_joined": "def getLdap ( uid , field ) : <NEWLINE> <INDENT> try : <NEWLINE> l = ldap . initialize ( <STRING> ) <NEWLINE> l . simple_bind_s ( ) <NEWLINE> result = l . search_s ( <STRING> , ldap . SCOPE_SUBTREE , <STRING> . format ( uid ) , attrlist = [ str ( field ) ] ) <NEWLINE> l . unbind ( ) <NEWLINE> if len ( result ) == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> return result [ 0 ] [ 1 ] . itervalues ( ) . next ( ) <NEWLINE> <DEDENT> except ldap . LDAPError , e : <NEWLINE> return <STRING> % e <NEWLINE> except Exception as e : <NEWLINE> print ( e ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"ldap://ldap.collegiumv.org\"", "\"ou=people,dc=collegiumv,dc=org\"", "\"(uid={0})\"", "\"No user found\"", "\"An error occurred: %s\""]}, "err_obj": {"msg": "expected an indented block"}}], ["961ea053504e05d1fdfa275df92e25c9", {"code_string": "def cleanup_address(s, assume_capitol_zipcode = True):\n    if re.match(r'^, ', s):\n    s = string.replace(s, ', ', '', 1)\n    if not assume_capitol_zipcode:\n    return s\n    elif re.match(r'.*Philadelphia.*PA', s) and not re.match(r'.*19107', s):\n    return string.replace(s, 'PA', 'PA 19107-3290')\n    elif re.match(r'.*19107-', s):\n    return s\n    else:\n    return string.replace(s, '19107', '19107-3290')\n", "code_toks_joined": "def cleanup_address ( s , assume_capitol_zipcode = True ) : <NEWLINE> <INDENT> if re . match ( <STRING> , s ) : <NEWLINE> s = string . replace ( s , <STRING> , <STRING> , 1 ) <NEWLINE> if not assume_capitol_zipcode : <NEWLINE> return s <NEWLINE> elif re . match ( <STRING> , s ) and not re . match ( <STRING> , s ) : <NEWLINE> return string . replace ( s , <STRING> , <STRING> ) <NEWLINE> elif re . match ( <STRING> , s ) : <NEWLINE> return s <NEWLINE> else : <NEWLINE> return string . replace ( s , <STRING> , <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["r'^, '", "', '", "''", "r'.*Philadelphia.*PA'", "r'.*19107'", "'PA'", "'PA 19107-3290'", "r'.*19107-'", "'19107'", "'19107-3290'"]}, "err_obj": {"msg": "expected an indented block"}}], ["951e90228e73b4c0a450a41a593297d9", {"code_string": "def __init__(self):\n    self.selectedPkgs = []\n        pass\n", "code_toks_joined": "def __init__ ( self ) : <NEWLINE> <INDENT> self . selectedPkgs = [ ] <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["2c0be5d4aeec89e037aefbf0c26fc51f", {"code_string": "def getUrlsForSearch(self, searchid, limit = None):\n    urls = []\n    try:\n        if limit:\n            urlsearch = UrlSearch.selectBy(searchid = searchid).limit(limit)\n        else:\n            urlsearch = UrlSearch.selectBy(searchid = searchid)\n        for u in urlsearch:\n        try:\n    urls.append(Url.get(u.urlid))\n    except SQLObjectNotFound:\n    raise DbError(\"The UrlSearch table has entry for url %i, which doesn't exist\" % u.urlid)\n        return urls\n    except Exception, e:\n        raise DbError(\"getUrlsForSearch failed\")\n", "code_toks_joined": "def getUrlsForSearch ( self , searchid , limit = None ) : <NEWLINE> <INDENT> urls = [ ] <NEWLINE> try : <NEWLINE> <INDENT> if limit : <NEWLINE> <INDENT> urlsearch = UrlSearch . selectBy ( searchid = searchid ) . limit ( limit ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> urlsearch = UrlSearch . selectBy ( searchid = searchid ) <NEWLINE> <DEDENT> for u in urlsearch : <NEWLINE> try : <NEWLINE> <DEDENT> urls . append ( Url . get ( u . urlid ) ) <NEWLINE> except SQLObjectNotFound : <NEWLINE> raise DbError ( <STRING> % u . urlid ) <NEWLINE> <INDENT> return urls <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> raise DbError ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"The UrlSearch table has entry for url %i, which doesn't exist\"", "\"getUrlsForSearch failed\""]}, "err_obj": {"msg": "expected an indented block"}}], ["eb7a202087c084a5c7a6b5a074dc0e9f", {"code_string": "def valid(self):\n    if self.name is not None and self.backing_device is not None\n        return True\n    return False\n", "code_toks_joined": "def valid ( self ) : <NEWLINE> <INDENT> if self . name is not None and self . backing_device is not None <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["7e5dd3daa94405442ad8e56ee1184cc8", {"code_string": "def maplayer_attributes(request, layername):\n    layer = Layer.objects.get(typename = layername)\n    return HttpResponse(\n        json.dumps(\n            layer.attribute_config(),\n        content_type = \"application/json\")\n", "code_toks_joined": "def maplayer_attributes ( request , layername ) : <NEWLINE> <INDENT> layer = Layer . objects . get ( typename = layername ) <NEWLINE> return HttpResponse ( <NEWLINE> <INDENT> json . dumps ( <NEWLINE> <INDENT> layer . attribute_config ( ) , <NEWLINE> <DEDENT> content_type = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"application/json\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["b9cdb5129fe24d7d94eb0bebbe09ae79", {"code_string": "def _validate_on_list(o, key, rule):\n    _value = o.get(key, [])\n    if not _value:\n        if rule.get('empty', False):\n            return True, 0, ''\n        else:\n            return False, ERROR_EMPTY_CODE, ERROR_EMPTY_MSG\n    if not isinstance(_value, list):\n        return False, ERROR_TYPE, ERROR_TYPE_LIST_MSG\n    if rule.get('max_len') and len(_value) > rule.get('max_len'):\n        return False, ERROR_LIST_MAX_CODE, ERROR_LIST_MAX_MSG % rule.get('max_len')\n    if rule.get('mix_len') and _value < rule.get('min_len'):\n        return False, ERROR_LIST_MIX_CODE, ERROR_LIST_MIX_MSG % rule.get('min_len')\n    if rule.get('in', []) and len(set(_value) - set(rule.get('in', [])) != 0:\n        return False, ERROR_IN_CODE, ERROR_IN_MSG % ','.join(map(str, rule.get('in', [])))\n    _callback = rule.get('validate')\n    if _callback and callable(_callback):\n        _status, _code, _msg = _callback(_value)\n        if not _status:\n            return False, _code, _msg\n", "code_toks_joined": "def _validate_on_list ( o , key , rule ) : <NEWLINE> <INDENT> _value = o . get ( key , [ ] ) <NEWLINE> if not _value : <NEWLINE> <INDENT> if rule . get ( <STRING> , False ) : <NEWLINE> <INDENT> return True , 0 , <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False , ERROR_EMPTY_CODE , ERROR_EMPTY_MSG <NEWLINE> <DEDENT> <DEDENT> if not isinstance ( _value , list ) : <NEWLINE> <INDENT> return False , ERROR_TYPE , ERROR_TYPE_LIST_MSG <NEWLINE> <DEDENT> if rule . get ( <STRING> ) and len ( _value ) > rule . get ( <STRING> ) : <NEWLINE> <INDENT> return False , ERROR_LIST_MAX_CODE , ERROR_LIST_MAX_MSG % rule . get ( <STRING> ) <NEWLINE> <DEDENT> if rule . get ( <STRING> ) and _value < rule . get ( <STRING> ) : <NEWLINE> <INDENT> return False , ERROR_LIST_MIX_CODE , ERROR_LIST_MIX_MSG % rule . get ( <STRING> ) <NEWLINE> <DEDENT> if rule . get ( <STRING> , [ ] ) and len ( set ( _value ) - set ( rule . get ( <STRING> , [ ] ) ) != 0 : <NEWLINE> <INDENT> return False , ERROR_IN_CODE , ERROR_IN_MSG % <STRING> . join ( map ( str , rule . get ( <STRING> , [ ] ) ) ) <NEWLINE> <DEDENT> _callback = rule . get ( <STRING> ) <NEWLINE> if _callback and callable ( _callback ) : <NEWLINE> <INDENT> _status , _code , _msg = _callback ( _value ) <NEWLINE> if not _status : <NEWLINE> <INDENT> return False , _code , _msg <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'empty'", "''", "'max_len'", "'max_len'", "'max_len'", "'mix_len'", "'min_len'", "'min_len'", "'in'", "'in'", "','", "'in'", "'validate'"]}, "window_span": [165, 262], "err_obj": {"msg": "unbalanced (){}[]"}}], ["4ffbe953631a161d1b60491b2237b143", {"code_string": "from django.conf.urls.defaults import *\nimport settings\nurlpatterns = patterns('',\n    (r'^$', 'views.index')\n)\nif settings.DEBUG:\n    urlpatterns += patterns('', (r'^' + settings.MEDIA_URL + r'(.+)$',\n        'django.views.static.serve', {'document_root': settings.MEDIA_ROOT})\n", "code_toks_joined": "from django . conf . urls . defaults import * <NEWLINE> import settings <NEWLINE> urlpatterns = patterns ( <STRING> , <NEWLINE> <INDENT> ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> ) <NEWLINE> if settings . DEBUG : <NEWLINE> <INDENT> urlpatterns += patterns ( <STRING> , ( <STRING> + settings . MEDIA_URL + <STRING> , <NEWLINE> <INDENT> <STRING> , { <STRING> : settings . MEDIA_ROOT } ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "r'^$'", "'views.index'", "''", "r'^'", "r'(.+)$'", "'django.views.static.serve'", "'document_root'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e58ba0f2ae2cdfa66adae51253022c21", {"code_string": "def pavnosig(power, nspec, nsim = 1.0e9, verbose = False):\n    if power * nspec > 30000:\n    if verbose:\n        print(\"Probability of no signal too miniscule to calculate.\")\n        return 0.0\n    else:\n        fn = pavnosigfun(power, nspec, nsim, verbose)\n        if verbose:\n            print(\"Pr(Averaged power lies above P if no signal present) = %.4e\" % fn)\n        return fn\n", "code_toks_joined": "def pavnosig ( power , nspec , nsim = 1.0e9 , verbose = False ) : <NEWLINE> <INDENT> if power * nspec > 30000 : <NEWLINE> if verbose : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return 0.0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fn = pavnosigfun ( power , nspec , nsim , verbose ) <NEWLINE> if verbose : <NEWLINE> <INDENT> print ( <STRING> % fn ) <NEWLINE> <DEDENT> return fn <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Probability of no signal too miniscule to calculate.\"", "\"Pr(Averaged power lies above P if no signal present) = %.4e\""]}, "err_obj": {"msg": "expected an indented block"}}], ["45558e948381d24054b13260f0624abb", {"code_string": "def retranslateUi(self, CalcFOMDialog):\n    CalcFOMDialog.setWindowTitle(_translate(\"CalcFOMDialog\", \"Process Data, Calc FOM from EXP\", None))\n    self.BatchComboBox.setToolTip(_translate(\"CalcFOMDialog\", \"Apply all other filteres in this section to only this run\", None))\n    self.BatchPushButton.setToolTip(_translate(\"CalcFOMDialog\", \"Considering the files already in the EXP, keep the files that meet all criteria\", None))\n    self.BatchPushButton.setText(_translate(\"CalcFOMDialog\", \"Run Batch Process:\", None))\n    self.label_17.setText(_translate(\"CalcFOMDialog\", \"Analysis name:\", None))\n    self.label_18.setText(_translate(\"CalcFOMDialog\", \"created by:\", None))\n    self.label_19.setText(_translate(\"CalcFOMDialog\", \"access:\", None))\n    self.UserNameLineEdit.setToolTip(_translate(\"CalcFOMDialog\", \"Comment string to be included in EXP\", None))\n    self.UserNameLineEdit.setText(_translate(\"CalcFOMDialog\", \"eche\", None))\n    self.AnaTypeLineEdit.setToolTip(_translate(\"CalcFOMDialog\", \"Comment string to be included in EXP\", None))\n    self.AnaTypeLineEdit.setText(_translate(\"CalcFOMDialog\", \"eche\", None))\n    self.AnaNameLineEdit.setToolTip(_translate(\"CalcFOMDialog\", \"Comment string to be included in EXP\", None))\n    self.AnaNameLineEdit.setText(_translate(\"CalcFOMDialog\", \"eche\", None))\n    self.AccessLineEdit.setToolTip(_translate(\"CalcFOMDialog\", \"Comment string to be included in EXP\", None))\n    self.AccessLineEdit.setText(_translate(\"CalcFOMDialog\", \"hte\", None))\n    self.label_16.setText(_translate(\"CalcFOMDialog\", \"Analysis type:\", None))\n    self.AnaDescLineEdit.setToolTip(_translate(\"CalcFOMDialog\", \"Comment string to be included in EXP.\\n\"\n", "code_toks_joined": "def retranslateUi ( self , CalcFOMDialog ) : <NEWLINE> <INDENT> CalcFOMDialog . setWindowTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . BatchComboBox . setToolTip ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . BatchPushButton . setToolTip ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . BatchPushButton . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_17 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_18 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_19 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . UserNameLineEdit . setToolTip ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . UserNameLineEdit . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . AnaTypeLineEdit . setToolTip ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . AnaTypeLineEdit . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . AnaNameLineEdit . setToolTip ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . AnaNameLineEdit . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . AccessLineEdit . setToolTip ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . AccessLineEdit . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_16 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . AnaDescLineEdit . setToolTip ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"CalcFOMDialog\"", "\"Process Data, Calc FOM from EXP\"", "\"CalcFOMDialog\"", "\"Apply all other filteres in this section to only this run\"", "\"CalcFOMDialog\"", "\"Considering the files already in the EXP, keep the files that meet all criteria\"", "\"CalcFOMDialog\"", "\"Run Batch Process:\"", "\"CalcFOMDialog\"", "\"Analysis name:\"", "\"CalcFOMDialog\"", "\"created by:\"", "\"CalcFOMDialog\"", "\"access:\"", "\"CalcFOMDialog\"", "\"Comment string to be included in EXP\"", "\"CalcFOMDialog\"", "\"eche\"", "\"CalcFOMDialog\"", "\"Comment string to be included in EXP\"", "\"CalcFOMDialog\"", "\"eche\"", "\"CalcFOMDialog\"", "\"Comment string to be included in EXP\"", "\"CalcFOMDialog\"", "\"eche\"", "\"CalcFOMDialog\"", "\"Comment string to be included in EXP\"", "\"CalcFOMDialog\"", "\"hte\"", "\"CalcFOMDialog\"", "\"Analysis type:\"", "\"CalcFOMDialog\"", "\"Comment string to be included in EXP.\\n\""]}, "window_span": [269, 277], "err_obj": {"msg": "unbalanced (){}[]"}}], ["14a78613885d94d8e70265948211cd9e", {"code_string": "def invalidate(self):\n    for a in(\"_map\", \"_copymap\", \"_foldmap\", \"_branch\", \"_pl\", \"_dirs\",\n        \"_ignore\"):\n        if a in self.__dict__:\n        delattr(self, a)\n    self._lastnormaltime = 0\n    self._dirty = False\n", "code_toks_joined": "def invalidate ( self ) : <NEWLINE> <INDENT> for a in ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> if a in self . __dict__ : <NEWLINE> delattr ( self , a ) <NEWLINE> <DEDENT> self . _lastnormaltime = 0 <NEWLINE> self . _dirty = False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"_map\"", "\"_copymap\"", "\"_foldmap\"", "\"_branch\"", "\"_pl\"", "\"_dirs\"", "\"_ignore\""]}, "err_obj": {"msg": "expected an indented block"}}], ["d94682e49786f1aea979b9a554dfae8e", {"code_string": "import eventlet\nimport logging\ndef sentry_logger(conf, name, log_to_console, log_route, fmt, logger,\n    adapted_logger):\n    sentry_dsn = conf.get('log_sentry_dsn', None)\n    sentry_log_level = getattr(logging,\n        conf.get('log_sentry_level',\n            'ERROR').upper(),\n        logging.ERROR)\n        if sentry_dsn:\n        raven_logging = eventlet.import_patched('raven.handlers.logging')\n        sentry = raven_logging.SentryHandler(sentry_dsn)\n        sentry.setLevel(sentry_log_level)\n        logger.addHandler(sentry)\n", "code_toks_joined": "import eventlet <NEWLINE> import logging <NEWLINE> def sentry_logger ( conf , name , log_to_console , log_route , fmt , logger , <NEWLINE> <INDENT> adapted_logger ) : <NEWLINE> sentry_dsn = conf . get ( <STRING> , None ) <NEWLINE> sentry_log_level = getattr ( logging , <NEWLINE> <INDENT> conf . get ( <STRING> , <NEWLINE> <INDENT> <STRING> ) . upper ( ) , <NEWLINE> <DEDENT> logging . ERROR ) <NEWLINE> if sentry_dsn : <NEWLINE> raven_logging = eventlet . import_patched ( <STRING> ) <NEWLINE> sentry = raven_logging . SentryHandler ( sentry_dsn ) <NEWLINE> sentry . setLevel ( sentry_log_level ) <NEWLINE> logger . addHandler ( sentry ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'log_sentry_dsn'", "'log_sentry_level'", "'ERROR'", "'raven.handlers.logging'"]}, "err_obj": {"msg": "unexpected indent"}}], ["0663dbb7a7fd5d0c0a9151a74f809f93", {"code_string": "def _prepare_leapin_solvatecap(self, model):\n    output = \"\"\n    for solvatecap in self._solvatecaps:\n        output += \"solvateCap {model} TIP3PBOX ${solcap_center} ${solcap_closeness}\\n\".format(\n            model = solvatecap[\"model\"],\n            wat_model = solvatecap[\"wat_model\"],\n            solcap_center = solvatecap[\"solcap_center\"]\n            solcap_closeness = solvatecap[\"solcap_closeness\"]\n        )\n    return output\n", "code_toks_joined": "def _prepare_leapin_solvatecap ( self , model ) : <NEWLINE> <INDENT> output = <STRING> <NEWLINE> for solvatecap in self . _solvatecaps : <NEWLINE> <INDENT> output += <STRING> . format ( <NEWLINE> <INDENT> model = solvatecap [ <STRING> ] , <NEWLINE> wat_model = solvatecap [ <STRING> ] , <NEWLINE> solcap_center = solvatecap [ <STRING> ] <NEWLINE> solcap_closeness = solvatecap [ <STRING> ] <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> return output <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"", "\"solvateCap {model} TIP3PBOX ${solcap_center} ${solcap_closeness}\\n\"", "\"model\"", "\"wat_model\"", "\"solcap_center\"", "\"solcap_closeness\""]}, "err_obj": {"msg": "invalid syntax"}}], ["0a96985d125e654f360407c4a3ca0c0d", {"code_string": "def flatten(aList):\n    '''aList: a list'''\n    flatlist = []\n    for element in aList:\n        if type(element) is list:\n            flatlist.extend(flatten(element)\n        else:\n            flatlist.append(element)\n    return flatlist\n", "code_toks_joined": "def flatten ( aList ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> flatlist = [ ] <NEWLINE> for element in aList : <NEWLINE> <INDENT> if type ( element ) is list : <NEWLINE> <INDENT> flatlist . extend ( flatten ( element ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flatlist . append ( element ) <NEWLINE> <DEDENT> <DEDENT> return flatlist <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''aList: a list'''"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["73deb8c91fc915b2cc2eeab3454eb027", {"code_string": "class NLG(self):\n    def acknowledge(self):\n        simple_acknoledgement = [\n            \"Yes?\",\n            \"What can I do for you?\",\n            \"How can I help?\",\n            \"How can I help you Today?\",\n            \"Hi, what can I do for you?\"\n            \"Hey, what can I do for you?\"\n        ]\n            ret_phrase = random.choice(simple_acknoledgement)\n        return ret_phrase\n", "code_toks_joined": "class NLG ( self ) : <NEWLINE> <INDENT> def acknowledge ( self ) : <NEWLINE> <INDENT> simple_acknoledgement = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <DEDENT> ] <NEWLINE> <INDENT> ret_phrase = random . choice ( simple_acknoledgement ) <NEWLINE> <DEDENT> return ret_phrase <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Yes?\"", "\"What can I do for you?\"", "\"How can I help?\"", "\"How can I help you Today?\"", "\"Hi, what can I do for you?\"", "\"Hey, what can I do for you?\""]}, "err_obj": {"msg": "unexpected indent"}}], ["91bc3f303ccdeb139385eeea3c6d6b48", {"code_string": "class UptonUpdateNoNonceHandler(webapp2.RequestHandler):\n    def get(self):\n    template = templates.GetTemplate('upton-update-no-nonce.html')\n    self.response.write(template.render())\n", "code_toks_joined": "class UptonUpdateNoNonceHandler ( webapp2 . RequestHandler ) : <NEWLINE> <INDENT> def get ( self ) : <NEWLINE> template = templates . GetTemplate ( <STRING> ) <NEWLINE> self . response . write ( template . render ( ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'upton-update-no-nonce.html'"]}, "err_obj": {"msg": "expected an indented block"}}], ["99971474b77612925fd3d2642fec5268", {"code_string": "def __init__(self, which_pin, d = False):\n    global ser\n        self._d = d\n        self._pin_no = which_pin\n    self._dinput_value = False\n", "code_toks_joined": "def __init__ ( self , which_pin , d = False ) : <NEWLINE> <INDENT> global ser <NEWLINE> <INDENT> self . _d = d <NEWLINE> self . _pin_no = which_pin <NEWLINE> <DEDENT> self . _dinput_value = False <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["709e3003ea86b7171098b903cfb6b8bf", {"code_string": "def main():\n    languages = sorted([s.split(os.path.sep)[- 2] for s in glob.glob('license_xsl/i18n/i18n_po/*/cc_org.po')])\n    for my_variants in([], ['nojuri'], ['definitely_want_license'],\n        ['nojuri', 'definitely_want_license'],\n        ['no_license_by_default'],\n        ['no_license_by_default', 'nojuri']):\n        my_variants.sort()\n        for lang in languages:\n        gen_templated_js(lang, my_variants)\n        create_var_file(my_variants, languages)\n", "code_toks_joined": "def main ( ) : <NEWLINE> <INDENT> languages = sorted ( [ s . split ( os . path . sep ) [ - 2 ] for s in glob . glob ( <STRING> ) ] ) <NEWLINE> for my_variants in ( [ ] , [ <STRING> ] , [ <STRING> ] , <NEWLINE> <INDENT> [ <STRING> , <STRING> ] , <NEWLINE> [ <STRING> ] , <NEWLINE> [ <STRING> , <STRING> ] ) : <NEWLINE> my_variants . sort ( ) <NEWLINE> for lang in languages : <NEWLINE> gen_templated_js ( lang , my_variants ) <NEWLINE> create_var_file ( my_variants , languages ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'license_xsl/i18n/i18n_po/*/cc_org.po'", "'nojuri'", "'definitely_want_license'", "'nojuri'", "'definitely_want_license'", "'no_license_by_default'", "'no_license_by_default'", "'nojuri'"]}, "err_obj": {"msg": "expected an indented block"}}], ["2a4f53b7cf40c78f428f47c77db18ef3", {"code_string": "def __init__(self, defaulttracker = \"\"):\n    super(TorrentMaker self).__init__()\n    self.defaulttracker = defaulttracker\n", "code_toks_joined": "def __init__ ( self , defaulttracker = <STRING> ) : <NEWLINE> <INDENT> super ( TorrentMaker self ) . __init__ ( ) <NEWLINE> self . defaulttracker = defaulttracker <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["25087bc39338975aecbc5dda45f53e7b", {"code_string": "def test_get_group_permissions(self):\n    group = Group.objects.create(name = 'test_group')\n    self.user3.groups.add(group)\n    self.assertEqual(self.user3.get_group_permissions(TestObj())), set(['group_perm']))\n", "code_toks_joined": "def test_get_group_permissions ( self ) : <NEWLINE> <INDENT> group = Group . objects . create ( name = <STRING> ) <NEWLINE> self . user3 . groups . add ( group ) <NEWLINE> self . assertEqual ( self . user3 . get_group_permissions ( TestObj ( ) ) ) , set ( [ <STRING> ] ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'test_group'", "'group_perm'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["2afdf08454c4bc28336a8cce3e2bc1a5", {"code_string": "def get_tgi_result(command):\n    myHeaders = {'User-Agent': 'check_netio plugin(https: //github.com/stdevel/check_netio)'}\n    if options.debug: print \"Accessing: '{0}?login=p: {1}: xxx&{2}'\".format(NETIO_URL, s_username, command)\n    try:\n        r = requests.get(NETIO_URL + \"?login=p: \" + s_username + \": \" + s_password + \"&\" + command, headers = myHeaders)\n        return r.content.replace(\"<html>\", \"\").replace(\"</html>\", \"\").replace(\" \", \"\")\n    except:\n        print(\"CRITICAL: unable to check device with hostname '{0}' - please check values!\".format(options.hostname))\n        exit(2)\n", "code_toks_joined": "def get_tgi_result ( command ) : <NEWLINE> <INDENT> myHeaders = { <STRING> : <STRING> } <NEWLINE> if options . debug : print <STRING> . format ( NETIO_URL , s_username , command ) <NEWLINE> try : <NEWLINE> <INDENT> r = requests . get ( NETIO_URL + <STRING> + s_username + <STRING> + s_password + <STRING> + command , headers = myHeaders ) <NEWLINE> return r . content . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> . format ( options . hostname ) ) <NEWLINE> exit ( 2 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'User-Agent'", "'check_netio plugin(https: //github.com/stdevel/check_netio)'", "\"Accessing: '{0}?login=p: {1}: xxx&{2}'\"", "\"?login=p: \"", "\": \"", "\"&\"", "\"<html>\"", "\"\"", "\"</html>\"", "\"\"", "\" \"", "\"\"", "\"CRITICAL: unable to check device with hostname '{0}' - please check values!\""]}, "err_obj": {"msg": "invalid syntax"}}], ["ac7d4591117d9028b9b470e8b59dd15e", {"code_string": "def get_in_prompt(self, continued = False):\n    next_line_number = self.get_last_line_number() + 1\n    if continued:\n        return ' ' * len('In[{0}]: = '.format(next_line_number)\n    else:\n        return '{1}In[{2}{0}{3}]: ={4}'.format(next_line_number, * self.incolors)\n", "code_toks_joined": "def get_in_prompt ( self , continued = False ) : <NEWLINE> <INDENT> next_line_number = self . get_last_line_number ( ) + 1 <NEWLINE> if continued : <NEWLINE> <INDENT> return <STRING> * len ( <STRING> . format ( next_line_number ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> . format ( next_line_number , * self . incolors ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["' '", "'In[{0}]: = '", "'{1}In[{2}{0}{3}]: ={4}'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e8c72122a1bfb8cb99ac90a0a24fb0c8", {"code_string": "class Command(BaseCommand):\n    help = \"Stop CTF! Disable all problem entries... (set is_active=False)\"\n    def handle(self, * args, ** options):\n        self.stdout.write(\"Stop CTF!\")\n        prob_entries = Entries.objects.all()\n        for entry in prob_entries:\n    entry.is_active = False\n    entry.save()\n", "code_toks_joined": "class Command ( BaseCommand ) : <NEWLINE> <INDENT> help = <STRING> <NEWLINE> def handle ( self , * args , ** options ) : <NEWLINE> <INDENT> self . stdout . write ( <STRING> ) <NEWLINE> prob_entries = Entries . objects . all ( ) <NEWLINE> for entry in prob_entries : <NEWLINE> <DEDENT> entry . is_active = False <NEWLINE> entry . save ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Stop CTF! Disable all problem entries... (set is_active=False)\"", "\"Stop CTF!\""]}, "err_obj": {"msg": "expected an indented block"}}], ["b157bae25f12bd25ae7f90d8df65999e", {"code_string": "def _parse_api_name(self api_names):\n    \"\"\"Remove API pattern 'API' and appendix 'MSG'\"\"\"\n    short_api_name = []\n    for api in api_names:\n        if api.endswith('Msg'):\n            short_api_name.append(api[3: - 3])\n    short_api_name.sort()\n    return short_api_name\n", "code_toks_joined": "def _parse_api_name ( self api_names ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> short_api_name = [ ] <NEWLINE> for api in api_names : <NEWLINE> <INDENT> if api . endswith ( <STRING> ) : <NEWLINE> <INDENT> short_api_name . append ( api [ 3 : - 3 ] ) <NEWLINE> <DEDENT> <DEDENT> short_api_name . sort ( ) <NEWLINE> return short_api_name <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Remove API pattern 'API' and appendix 'MSG'\"\"\"", "'Msg'"]}, "err_obj": {"msg": "invalid syntax"}}], ["1b6d2b6c554650a107dc81dd2b913496", {"code_string": "def SetHideEscapeParam(self, value):\n    \"\"\" Set the option state \"\"\"\n    self.HideEscapeChars = value\n    Pattern = re.compile(\"<EscapeChars:(.+)$\")\n    Param = \"<EscapeChars:\" + str(value)\n    for line in fileinput.input(CONFIG_FILENAME, inplace = 1):\n        line = Pattern.sub(Param, line)\n        if '\\n' in line:\n        line = line.replace(\"\\n\", \"\")\n        print(line)\n        else:\n        print(line)\n    fileinput.close()\n", "code_toks_joined": "def SetHideEscapeParam ( self , value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . HideEscapeChars = value <NEWLINE> Pattern = re . compile ( <STRING> ) <NEWLINE> Param = <STRING> + str ( value ) <NEWLINE> for line in fileinput . input ( CONFIG_FILENAME , inplace = 1 ) : <NEWLINE> <INDENT> line = Pattern . sub ( Param , line ) <NEWLINE> if <STRING> in line : <NEWLINE> line = line . replace ( <STRING> , <STRING> ) <NEWLINE> print ( line ) <NEWLINE> else : <NEWLINE> print ( line ) <NEWLINE> <DEDENT> fileinput . close ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Set the option state \"\"\"", "\"<EscapeChars:(.+)$\"", "\"<EscapeChars:\"", "'\\n'", "\"\\n\"", "\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["39d53fa76e5864004a3aabb43aebeeaa", {"code_string": "def this_characteristic_nothere(true_or_false, dict_defined, system, os_string, filter_name):\n    counter = 0\n    if true_or_false:\n        for os in dict_defined:\n            if os.lower() in os_string:\n                counter += 1\n        if counter == 0:\n            if debug: print \"%s has been skipped b/c of %s filtering\" %(system, filter_name)\n            return True\n    return False\n", "code_toks_joined": "def this_characteristic_nothere ( true_or_false , dict_defined , system , os_string , filter_name ) : <NEWLINE> <INDENT> counter = 0 <NEWLINE> if true_or_false : <NEWLINE> <INDENT> for os in dict_defined : <NEWLINE> <INDENT> if os . lower ( ) in os_string : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> <DEDENT> if counter == 0 : <NEWLINE> <INDENT> if debug : print <STRING> % ( system , filter_name ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"%s has been skipped b/c of %s filtering\""]}, "err_obj": {"msg": "invalid syntax"}}], ["5c95b04c760eb7156371dfdd28a18bef", {"code_string": "def r_phpbb3(mydata):\n    results = re.search(r'\\$H\\$\\S{31}', mydata, re.M | re.I)\n    if results:\n        if args.quietmode: print results.group()\n        else: outputhandler.write(str(results.group().rstrip('\\n')) + '\\r\\n')\n", "code_toks_joined": "def r_phpbb3 ( mydata ) : <NEWLINE> <INDENT> results = re . search ( <STRING> , mydata , re . M | re . I ) <NEWLINE> if results : <NEWLINE> <INDENT> if args . quietmode : print results . group ( ) <NEWLINE> else : outputhandler . write ( str ( results . group ( ) . rstrip ( <STRING> ) ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["r'\\$H\\$\\S{31}'", "'\\n'", "'\\r\\n'"]}, "err_obj": {"msg": "invalid syntax"}}], ["f4fb29865304fbee497b38ac3441dca1", {"code_string": "def get_participants():\n    '''Returns the list of active participants, in order of arrival.'''\n    log.debug('get_participants')\n    try:\n        return instance().ordered_bus_names[: ]\n    except IndexError, err:\n        return[]\n", "code_toks_joined": "def get_participants ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> log . debug ( <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> return instance ( ) . ordered_bus_names [ : ] <NEWLINE> <DEDENT> except IndexError , err : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Returns the list of active participants, in order of arrival.'''", "'get_participants'"]}, "err_obj": {"msg": "invalid syntax"}}], ["ac5d693074b796f4080442136c2b0831", {"code_string": "def definir_centro(self, (x, y)):\n    \"\"\" Define en que posici\u00f3n estar\u00e1 el centro del Actor.\"\"\"\n    self.centro_x = x\n    self.centro_y = y\n", "code_toks_joined": "def definir_centro ( self , ( x , y ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . centro_x = x <NEWLINE> self . centro_y = y <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Define en que posici\u00f3n estar\u00e1 el centro del Actor.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["679370faf62979ae7881b837c3a40ab4", {"code_string": "print(\"Tabla de sumar del\", Tabla, )\nfor j in range(1, 13):\nprint(\" % d + % d = % d\" %(Tabla, j, Tabla + j))\n", "code_toks_joined": "print ( <STRING> , Tabla , ) <NEWLINE> for j in range ( 1 , 13 ) : <NEWLINE> print ( <STRING> % ( Tabla , j , Tabla + j ) ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"Tabla de sumar del\"", "\" % d + % d = % d\""]}, "err_obj": {"msg": "expected an indented block"}}], ["b9db19bca9b5ba4ebc2fc1dfea638548", {"code_string": "def concat_pcr(index_type):\n    if re.match('D5', index_type) or re.match('D7', index_type)\n        return ','.join([PCR_fwd_D5, PCR_rev_D7])\n    elif re.match('A0', index_type):\n        return ','.join([PCR_fwd_A5, PCR_rev_A7])\n    else:\n        return 'N/A'\n", "code_toks_joined": "def concat_pcr ( index_type ) : <NEWLINE> <INDENT> if re . match ( <STRING> , index_type ) or re . match ( <STRING> , index_type ) <NEWLINE> <INDENT> return <STRING> . join ( [ PCR_fwd_D5 , PCR_rev_D7 ] ) <NEWLINE> <DEDENT> elif re . match ( <STRING> , index_type ) : <NEWLINE> <INDENT> return <STRING> . join ( [ PCR_fwd_A5 , PCR_rev_A7 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'D5'", "'D7'", "','", "'A0'", "','", "'N/A'"]}, "err_obj": {"msg": "invalid syntax"}}], ["7dd7d9c95c73dcc26cfb22e3c491b997", {"code_string": "class Ui_incom(object):\n    def setupUi(self, incom):\n        incom.setObjectName(\"incom\")\n        incom.resize(154, 156)\n        self.horizontalLayout = QtGui.QHBoxLayout(incom)\n        self.horizontalLayout.setSpacing(0)\n        self.horizontalLayout.setContentsMargins(0, 0, 0, 0)\n        self.horizontalLayout.setObjectName(\"horizontalLayout\")\n        self.groupBox = QtGui.QGroupBox(incom)\n        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Maximum)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.groupBox.sizePolicy().hasHeightForWidth())\n        self.groupBox.setSizePolicy(sizePolicy)\n        self.groupBox.setStyleSheet(\"QGroupBox {\\n\"\n", "code_toks_joined": "class Ui_incom ( object ) : <NEWLINE> <INDENT> def setupUi ( self , incom ) : <NEWLINE> <INDENT> incom . setObjectName ( <STRING> ) <NEWLINE> incom . resize ( 154 , 156 ) <NEWLINE> self . horizontalLayout = QtGui . QHBoxLayout ( incom ) <NEWLINE> self . horizontalLayout . setSpacing ( 0 ) <NEWLINE> self . horizontalLayout . setContentsMargins ( 0 , 0 , 0 , 0 ) <NEWLINE> self . horizontalLayout . setObjectName ( <STRING> ) <NEWLINE> self . groupBox = QtGui . QGroupBox ( incom ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Preferred , QtGui . QSizePolicy . Maximum ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( self . groupBox . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> self . groupBox . setSizePolicy ( sizePolicy ) <NEWLINE> self . groupBox . setStyleSheet ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"incom\"", "\"horizontalLayout\"", "\"QGroupBox {\\n\""]}, "window_span": [153, 158], "err_obj": {"msg": "unbalanced (){}[]"}}], ["7e084841fc565df7ba9105a13bd6edc4", {"code_string": "def list_instance_notes(self):\n    instance_notes = []\n    for vs in self._conn.Msvm_VirtualSystemSettingData(\n        ['ElementName', 'Notes'],\n        VirtualSystemType = self._VIRTUAL_SYSTEM_TYPE_REALIZED):\n        if vs.Notes is not None:\n        instance_notes.append(\n            (vs.ElementName, [v for v in vs.Notes if v]))\n    return instance_notes\n", "code_toks_joined": "def list_instance_notes ( self ) : <NEWLINE> <INDENT> instance_notes = [ ] <NEWLINE> for vs in self . _conn . Msvm_VirtualSystemSettingData ( <NEWLINE> <INDENT> [ <STRING> , <STRING> ] , <NEWLINE> VirtualSystemType = self . _VIRTUAL_SYSTEM_TYPE_REALIZED ) : <NEWLINE> if vs . Notes is not None : <NEWLINE> instance_notes . append ( <NEWLINE> <INDENT> ( vs . ElementName , [ v for v in vs . Notes if v ] ) ) <NEWLINE> <DEDENT> <DEDENT> return instance_notes <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'ElementName'", "'Notes'"]}, "err_obj": {"msg": "expected an indented block"}}], ["72c7aa971435f6aff9c0aa75e7ab103a", {"code_string": "def rescued_header(self):\n    return{\n        'ID': self.rescue_tag,\n        'Description': 'Filter status before rescued based on allele balance',\n        ,\n        'Type': 'String',\n        'Number': '1'\n        }\n", "code_toks_joined": "def rescued_header ( self ) : <NEWLINE> <INDENT> return { <NEWLINE> <INDENT> <STRING> : self . rescue_tag , <NEWLINE> <STRING> : <STRING> , <NEWLINE> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> } <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'ID'", "'Description'", "'Filter status before rescued based on allele balance'", "'Type'", "'String'", "'Number'", "'1'"]}, "err_obj": {"msg": "invalid syntax"}}], ["a4767bf7bfce0d2cd3a69872b32e0a7a", {"code_string": "class WHTMLHeader(WTemplated):\n    def __init__(self tpl_name = None):\n        WTemplated.__init__(self)\n", "code_toks_joined": "class WHTMLHeader ( WTemplated ) : <NEWLINE> <INDENT> def __init__ ( self tpl_name = None ) : <NEWLINE> <INDENT> WTemplated . __init__ ( self ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["e5affccb1434ca432388968a0683bed1", {"code_string": "class TextTag(Tag):\n    \"\"\" A Sanitising Tag to print the DOM as plain text.\"\"\"\n    def __str__(self):\n        if self.name in['br', 'p']:\n            return \"\\n\"\n        if self.name in['script', 'style']:\n        return ' '\n        data = decode_unicode(self.innerHTML())\n        data = re.sub(r\"[\\r\\n]+\", \"\\n\", data)\n        data = re.sub(r\" +\", \" \", data)\n        data = unquote(data)\n        return data + \" \"\n", "code_toks_joined": "class TextTag ( Tag ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __str__ ( self ) : <NEWLINE> <INDENT> if self . name in [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if self . name in [ <STRING> , <STRING> ] : <NEWLINE> return <STRING> <NEWLINE> data = decode_unicode ( self . innerHTML ( ) ) <NEWLINE> data = re . sub ( <STRING> , <STRING> , data ) <NEWLINE> data = re . sub ( <STRING> , <STRING> , data ) <NEWLINE> data = unquote ( data ) <NEWLINE> return data + <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" A Sanitising Tag to print the DOM as plain text.\"\"\"", "'br'", "'p'", "\"\\n\"", "'script'", "'style'", "' '", "r\"[\\r\\n]+\"", "\"\\n\"", "r\" +\"", "\" \"", "\" \""]}, "err_obj": {"msg": "expected an indented block"}}], ["d2af71f96a1041b6920e1e5a26c8b6b9", {"code_string": "def _accuracy_at_threshold(labels, predictions, weights, threshold, name = None):\n    with ops.name_scope(\n        name, 'accuracy_at_%s' % threshold,\n        (predictions, labels, weights, threshold)) as scope:\n        threshold_predictions = math_ops.to_float(\n            math_ops.greater_equal(predictions, threshold))\n            return metrics_lib.accuracy(\n            labels = labels, predictions = threshold_predictions, weights = weights,\n            name = scope)\n", "code_toks_joined": "def _accuracy_at_threshold ( labels , predictions , weights , threshold , name = None ) : <NEWLINE> <INDENT> with ops . name_scope ( <NEWLINE> <INDENT> name , <STRING> % threshold , <NEWLINE> ( predictions , labels , weights , threshold ) ) as scope : <NEWLINE> threshold_predictions = math_ops . to_float ( <NEWLINE> <INDENT> math_ops . greater_equal ( predictions , threshold ) ) <NEWLINE> return metrics_lib . accuracy ( <NEWLINE> labels = labels , predictions = threshold_predictions , weights = weights , <NEWLINE> name = scope ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'accuracy_at_%s'"]}, "err_obj": {"msg": "unexpected indent"}}], ["4fcca53f8b9e90367619bd3537665bef", {"code_string": "class FeedURLField(forms.URLField):\n    def __init__(self, max_length = None, min_length = None, verify_exists = False,\n        validator_user_agent = validators.URL_VALIDATOR_USER_AGENT, * args, ** kwargs):\n        forms.CharField.__init__(self, max_length, min_length, * args,\n            ** kwargs)\n            self.validators.append(FeedURLValidator(verify_exists = verify_exists, validator_user_agent = validator_user_agent))\n    def to_python(self, value):\n        value = super(FeedURLField, self).to_python(value)\n        return value.strip()\n", "code_toks_joined": "class FeedURLField ( forms . URLField ) : <NEWLINE> <INDENT> def __init__ ( self , max_length = None , min_length = None , verify_exists = False , <NEWLINE> <INDENT> validator_user_agent = validators . URL_VALIDATOR_USER_AGENT , * args , ** kwargs ) : <NEWLINE> forms . CharField . __init__ ( self , max_length , min_length , * args , <NEWLINE> <INDENT> ** kwargs ) <NEWLINE> self . validators . append ( FeedURLValidator ( verify_exists = verify_exists , validator_user_agent = validator_user_agent ) ) <NEWLINE> <DEDENT> <DEDENT> def to_python ( self , value ) : <NEWLINE> <INDENT> value = super ( FeedURLField , self ) . to_python ( value ) <NEWLINE> return value . strip ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["de015901bc8969d0e4d2e73725191c64", {"code_string": "def winner(sprites, n):\n    \"Check if player n occupies 3 squares in a row\"\n    for sq in[(0, 1, 2), (3, 4, 5), (6, 7, 8), (0, 3, 6),\n        (1, 4, 7), (2, 5, 8), (0, 4, 8), (2, 4, 6)]:\n        if sum(1 for s in sq if sprites[s].costumeNumber == n) == 3:\n        return True\n", "code_toks_joined": "def winner ( sprites , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for sq in [ ( 0 , 1 , 2 ) , ( 3 , 4 , 5 ) , ( 6 , 7 , 8 ) , ( 0 , 3 , 6 ) , <NEWLINE> <INDENT> ( 1 , 4 , 7 ) , ( 2 , 5 , 8 ) , ( 0 , 4 , 8 ) , ( 2 , 4 , 6 ) ] : <NEWLINE> if sum ( 1 for s in sq if sprites [ s ] . costumeNumber == n ) == 3 : <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Check if player n occupies 3 squares in a row\""]}, "err_obj": {"msg": "expected an indented block"}}], ["c5c6b0ae7dbedd117d6edf1e82252a0b", {"code_string": "def find_sample(reponse):\n    \"\"\"Function that can find the sampling rate for a given station.\"\"\"\n    for stage in reponse.response_stages[: : - 1]:\n        if(stage.decimation_input_sample_rate is not None and\n            stage.decimation_factor is not None):\n            sampling_rate = (stage.decimation_input_sample_rate /\n                stage.decimation_factor)\n                break\n    else:\n        msg = (\"Failed to autodetect sampling rate of channel from \"\n            \"response stages. Please manually specify parameter \"\n            \"`sampling_rate`\")\n        raise Exception(msg)\n    return sampling_rate\n", "code_toks_joined": "def find_sample ( reponse ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for stage in reponse . response_stages [ : : - 1 ] : <NEWLINE> <INDENT> if ( stage . decimation_input_sample_rate is not None and <NEWLINE> <INDENT> stage . decimation_factor is not None ) : <NEWLINE> sampling_rate = ( stage . decimation_input_sample_rate / <NEWLINE> <INDENT> stage . decimation_factor ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> msg = ( <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> raise Exception ( msg ) <NEWLINE> <DEDENT> return sampling_rate <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Function that can find the sampling rate for a given station.\"\"\"", "\"Failed to autodetect sampling rate of channel from \"", "\"response stages. Please manually specify parameter \"", "\"`sampling_rate`\""]}, "err_obj": {"msg": "unexpected indent"}}], ["a9d4d1afa5fd1931a000b122380a669d", {"code_string": "def should_nuke_file(self, pretty, file, mgs):\n    if self.libtool_file.match(mgs):\n        return True\n    if pretty == \"/usr/share/info/dir\":\n        return True\n    if pretty.startswith(\"/emul32\"):\n        return True\n    if(pretty.startswith(\"/usr/lib64/avx2/\") or\n        pretty.startswith(\"/usr/lib32/avx2/\")):\n        if \".so\" not in pretty:\n        return True\n        if pretty.endswith(\".so\") and os.path.islink(file):\n        return True\n    return False\n", "code_toks_joined": "def should_nuke_file ( self , pretty , file , mgs ) : <NEWLINE> <INDENT> if self . libtool_file . match ( mgs ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if pretty == <STRING> : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if pretty . startswith ( <STRING> ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if ( pretty . startswith ( <STRING> ) or <NEWLINE> <INDENT> pretty . startswith ( <STRING> ) ) : <NEWLINE> if <STRING> not in pretty : <NEWLINE> return True <NEWLINE> if pretty . endswith ( <STRING> ) and os . path . islink ( file ) : <NEWLINE> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"/usr/share/info/dir\"", "\"/emul32\"", "\"/usr/lib64/avx2/\"", "\"/usr/lib32/avx2/\"", "\".so\"", "\".so\""]}, "err_obj": {"msg": "expected an indented block"}}], ["5075256d0e7f06618a98ac7340f2c7f1", {"code_string": "def show_packer(filename):\n    peid = pecore.check_peid(filename)\n    if peid != None:\n        len_peid = len(peid)\n            file2 = open(\"/tmp/packer.txt\", \"w\")\n            file2.write(\"\\nPacker matched [\" + str(len_peid) + \"]\")\n        print(\"-\" * 60)\n            file2.write(\"-\" * 60)\n        for i in range(0, len_peid):\n            file2.write(\"Packer\".ljust(18) + peid[i][0])\n                file2.close()\n", "code_toks_joined": "def show_packer ( filename ) : <NEWLINE> <INDENT> peid = pecore . check_peid ( filename ) <NEWLINE> if peid != None : <NEWLINE> <INDENT> len_peid = len ( peid ) <NEWLINE> <INDENT> file2 = open ( <STRING> , <STRING> ) <NEWLINE> file2 . write ( <STRING> + str ( len_peid ) + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * 60 ) <NEWLINE> <INDENT> file2 . write ( <STRING> * 60 ) <NEWLINE> <DEDENT> for i in range ( 0 , len_peid ) : <NEWLINE> <INDENT> file2 . write ( <STRING> . ljust ( 18 ) + peid [ i ] [ 0 ] ) <NEWLINE> <INDENT> file2 . close ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"/tmp/packer.txt\"", "\"w\"", "\"\\nPacker matched [\"", "\"]\"", "\"-\"", "\"-\"", "\"Packer\""]}, "err_obj": {"msg": "unexpected indent"}}], ["921726f798c50dd2195e49249568b7a9", {"code_string": "class altitudeMode(enumeration):\n    error = InvalidAltitudeMode\n    valuelist = [\n    \"clampToGround\", \"relativeToGround\", \"absolute\"\n", "code_toks_joined": "class altitudeMode ( enumeration ) : <NEWLINE> <INDENT> error = InvalidAltitudeMode <NEWLINE> valuelist = [ <NEWLINE> <STRING> , <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"clampToGround\"", "\"relativeToGround\"", "\"absolute\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["3734971ba1f57b63464c47da2103738a", {"code_string": "def get_drum_rack_to_operate_on(self, track):\n    \"\"\" Get drum rack to operate on \"\"\"\n    dr = None\n    for device in track.devices:\n        if device.can_have_drum_pads:\n        dr = device\n        break\n    if self._is_debugging:\n        debug_string = 'None'\n        if dr:\n        debug_string = dr.name\n        self.log_message('get_drum_rack_to_operate_on returning dr=' + str(debug_string))\n    return dr\n", "code_toks_joined": "def get_drum_rack_to_operate_on ( self , track ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> dr = None <NEWLINE> for device in track . devices : <NEWLINE> <INDENT> if device . can_have_drum_pads : <NEWLINE> dr = device <NEWLINE> break <NEWLINE> <DEDENT> if self . _is_debugging : <NEWLINE> <INDENT> debug_string = <STRING> <NEWLINE> if dr : <NEWLINE> debug_string = dr . name <NEWLINE> self . log_message ( <STRING> + str ( debug_string ) ) <NEWLINE> <DEDENT> return dr <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Get drum rack to operate on \"\"\"", "'None'", "'get_drum_rack_to_operate_on returning dr='"]}, "err_obj": {"msg": "expected an indented block"}}], ["6dc019865a31c30603c354d09ea4e158", {"code_string": "def test_stringify_files_creates_correct_body_content(self):\n    fake_file = Mock()\n    fake_file.read.return_value = \"contents\"\n    request = {'files': {'fake': fake_file},\n        'headers': {'content-type': 'tmp'}}\n    with patch('bravado.multipart_response.get_random_boundary',\n        return_value = 'zz'):\n        resp = bravado.fido_client.stringify_body(request)\n        expected_contents = (\n        '--zz\\r\\nContent-Disposition: form-data; name=fake;' +\n        ' filename=fake\\r\\n\\r\\ncontents\\r\\n--zz--\\r\\n')\n        self.assertEqual('multipart/form-data; boundary=zz',\n            request['headers']['content-type'])\n            self.assertEqual(expected_contents, resp)\n", "code_toks_joined": "def test_stringify_files_creates_correct_body_content ( self ) : <NEWLINE> <INDENT> fake_file = Mock ( ) <NEWLINE> fake_file . read . return_value = <STRING> <NEWLINE> request = { <STRING> : { <STRING> : fake_file } , <NEWLINE> <INDENT> <STRING> : { <STRING> : <STRING> } } <NEWLINE> <DEDENT> with patch ( <STRING> , <NEWLINE> <INDENT> return_value = <STRING> ) : <NEWLINE> resp = bravado . fido_client . stringify_body ( request ) <NEWLINE> expected_contents = ( <NEWLINE> <STRING> + <NEWLINE> <STRING> ) <NEWLINE> self . assertEqual ( <STRING> , <NEWLINE> <INDENT> request [ <STRING> ] [ <STRING> ] ) <NEWLINE> self . assertEqual ( expected_contents , resp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"contents\"", "'files'", "'fake'", "'headers'", "'content-type'", "'tmp'", "'bravado.multipart_response.get_random_boundary'", "'zz'", "'--zz\\r\\nContent-Disposition: form-data; name=fake;'", "' filename=fake\\r\\n\\r\\ncontents\\r\\n--zz--\\r\\n'", "'multipart/form-data; boundary=zz'", "'headers'", "'content-type'"]}, "err_obj": {"msg": "unexpected indent"}}], ["d5bd08664b925c4b9388741257f656a0", {"code_string": "class IAuthorizer(Interface)\n    def getChallenge(peer):\n        \"\"\"Generate a challenge the client may respond to.\"\"\"\n    def decode(response):\n        \"\"\"Create a credentials object from the given response.\"\"\"\n", "code_toks_joined": "class IAuthorizer ( Interface ) <NEWLINE> <INDENT> def getChallenge ( peer ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> def decode ( response ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Generate a challenge the client may respond to.\"\"\"", "\"\"\"Create a credentials object from the given response.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["db07d7efecffb261204913395803cc6b", {"code_string": "def SetBlock(self, x, z, y, newType, newMeta)\n    offset = self._GetOffset(x, z, y)\n    self._blocks[offset] = (newType & 0xff)\n    return newType\n", "code_toks_joined": "def SetBlock ( self , x , z , y , newType , newMeta ) <NEWLINE> <INDENT> offset = self . _GetOffset ( x , z , y ) <NEWLINE> self . _blocks [ offset ] = ( newType & 0xff ) <NEWLINE> return newType <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["2017b490797cb6c00411b680a2bbe8d8", {"code_string": "class Ufunc(object):\n    \"\"\"Description of a ufunc.\"\"\"\n    def __init__(self, nin, nout, identity, docstring, typereso,\n        * type_descriptions):\n        self.nin = nin\n        self.nout = nout\n        if identity is None:\n        identity = None_\n        self.identity = identity\n        self.docstring = docstring\n        self.typereso = typereso\n        self.type_descriptions = []\n        for td in type_descriptions:\n        self.type_descriptions.extend(td)\n        for td in self.type_descriptions:\n        td.finish_signature(self.nin, self.nout)\n", "code_toks_joined": "class Ufunc ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , nin , nout , identity , docstring , typereso , <NEWLINE> <INDENT> * type_descriptions ) : <NEWLINE> self . nin = nin <NEWLINE> self . nout = nout <NEWLINE> if identity is None : <NEWLINE> identity = None_ <NEWLINE> self . identity = identity <NEWLINE> self . docstring = docstring <NEWLINE> self . typereso = typereso <NEWLINE> self . type_descriptions = [ ] <NEWLINE> for td in type_descriptions : <NEWLINE> self . type_descriptions . extend ( td ) <NEWLINE> for td in self . type_descriptions : <NEWLINE> td . finish_signature ( self . nin , self . nout ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Description of a ufunc.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["dbc7f92c822196a30dbdaeea775cf003", {"code_string": "def retranslateUi(self, MetadataBulkDialog):\n    MetadataBulkDialog.setWindowTitle(_(\"Edit Meta information\"))\n    self.label_2.setText(_(\"&Author(s): \"))\n    self.auto_author_sort.setToolTip(_(\"This will cause the author sort field to be automatically updated\\n\"\n", "code_toks_joined": "def retranslateUi ( self , MetadataBulkDialog ) : <NEWLINE> <INDENT> MetadataBulkDialog . setWindowTitle ( _ ( <STRING> ) ) <NEWLINE> self . label_2 . setText ( _ ( <STRING> ) ) <NEWLINE> self . auto_author_sort . setToolTip ( _ ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Edit Meta information\"", "\"&Author(s): \"", "\"This will cause the author sort field to be automatically updated\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["9c6ed589b7da3b39b9e50ab025105bd2", {"code_string": "def _getresp(self):\n    resp, o = self._getline()\n    if self._debugging > 1:\n        print '*resp*', repr(resp)\n    c = resp[: 1]\n    if c != '+':\n        raise error_proto(resp)\n    return resp\n", "code_toks_joined": "def _getresp ( self ) : <NEWLINE> <INDENT> resp , o = self . _getline ( ) <NEWLINE> if self . _debugging > 1 : <NEWLINE> <INDENT> print <STRING> , repr ( resp ) <NEWLINE> <DEDENT> c = resp [ : 1 ] <NEWLINE> if c != <STRING> : <NEWLINE> <INDENT> raise error_proto ( resp ) <NEWLINE> <DEDENT> return resp <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'*resp*'", "'+'"]}, "err_obj": {"msg": "invalid syntax"}}], ["6a888c3a8ad2f18ecbb5a38bd071129b", {"code_string": "def includeme(config):\n    \"\"\"Initialize the model for a Pyramid app.\"\"\"\n    settings = config.get_settings()\n    config.include('pyramid_tm')\n    session_factory = get_session_factory(get_engine(settings)\n    config.registry['dbsession_factory'] = session_factory\n    config.add_request_method(\n        lambda r: get_tm_session(session_factory, r.tm),\n        'dbsession',\n        reify = True\n    )\n", "code_toks_joined": "def includeme ( config ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> settings = config . get_settings ( ) <NEWLINE> config . include ( <STRING> ) <NEWLINE> session_factory = get_session_factory ( get_engine ( settings ) <NEWLINE> config . registry [ <STRING> ] = session_factory <NEWLINE> config . add_request_method ( <NEWLINE> <INDENT> lambda r : get_tm_session ( session_factory , r . tm ) , <NEWLINE> <STRING> , <NEWLINE> reify = True <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Initialize the model for a Pyramid app.\"\"\"", "'pyramid_tm'", "'dbsession_factory'", "'dbsession'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["108547e89e6c19b69df43ddac46f0fa7", {"code_string": "from distutils.core import setup\nimport py2exe\nsetup(windows = [\"converter_ui.py\"])\ndata_files = ['logo.jpg']\noptions = {'py2exe': {\n\"optimize\": 2,\n\"bundle_files\": 2,\n", "code_toks_joined": "from distutils . core import setup <NEWLINE> import py2exe <NEWLINE> setup ( windows = [ <STRING> ] ) <NEWLINE> data_files = [ <STRING> ] <NEWLINE> options = { <STRING> : { <NEWLINE> <STRING> : 2 , <NEWLINE> <STRING> : 2 , <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"converter_ui.py\"", "'logo.jpg'", "'py2exe'", "\"optimize\"", "\"bundle_files\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["5ecad85ff3837536326ecff30c95c401", {"code_string": "import os, stat, errno\ntry:\n    import _find_fuse_parts\nexcept ImportError:\n    pass\nimport fuse\nfrom fuse import Fuse\nfrom sinastorage.bucket import SCSBucket\nimport sinastorage\nimport datetime\nimport calendar\nimport tempfile\nif not hasattr(fuse, '__version__'):\n    raise RuntimeError, \"your fuse-py doesn't know of fuse.__version__, probably it's too old.\"\nfuse.fuse_python_api = (0, 2)\nscs_accesskey = '\u4f60\u7684\u65b0\u6d6a\u4e91\u5b58\u50a8ak'\nscs_secretkey = '\u4f60\u7684\u65b0\u6d6a\u4e91\u5b58\u50a8sk'\nscs_bucket = '\u4f60\u7684bucket\u540d'\nsinastorage.setDefaultAppInfo(scs_accesskey, scs_secretkey)\ns = SCSBucket(scs_bucket, secure = False)\n", "code_toks_joined": "import os , stat , errno <NEWLINE> try : <NEWLINE> <INDENT> import _find_fuse_parts <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> import fuse <NEWLINE> from fuse import Fuse <NEWLINE> from sinastorage . bucket import SCSBucket <NEWLINE> import sinastorage <NEWLINE> import datetime <NEWLINE> import calendar <NEWLINE> import tempfile <NEWLINE> if not hasattr ( fuse , <STRING> ) : <NEWLINE> <INDENT> raise RuntimeError , <STRING> <NEWLINE> <DEDENT> fuse . fuse_python_api = ( 0 , 2 ) <NEWLINE> scs_accesskey = <STRING> <NEWLINE> scs_secretkey = <STRING> <NEWLINE> scs_bucket = <STRING> <NEWLINE> sinastorage . setDefaultAppInfo ( scs_accesskey , scs_secretkey ) <NEWLINE> s = SCSBucket ( scs_bucket , secure = False ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["'__version__'", "\"your fuse-py doesn't know of fuse.__version__, probably it's too old.\"", "'\u4f60\u7684\u65b0\u6d6a\u4e91\u5b58\u50a8ak'", "'\u4f60\u7684\u65b0\u6d6a\u4e91\u5b58\u50a8sk'", "'\u4f60\u7684bucket\u540d'"]}, "err_obj": {"msg": "invalid syntax"}}], ["e3fa63fa0a4039b700d359f440dfecfc", {"code_string": "def machine_leaves():\n    for x in machines.keys():\n    if x not in current:\n        string = \"Leaves: %s (%s)\" %(x, machines[x])\n        logger.info(string)\n        event_triggerer('leaves', x, machines[x])\n        del machines[x]\n", "code_toks_joined": "def machine_leaves ( ) : <NEWLINE> <INDENT> for x in machines . keys ( ) : <NEWLINE> if x not in current : <NEWLINE> <INDENT> string = <STRING> % ( x , machines [ x ] ) <NEWLINE> logger . info ( string ) <NEWLINE> event_triggerer ( <STRING> , x , machines [ x ] ) <NEWLINE> del machines [ x ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Leaves: %s (%s)\"", "'leaves'"]}, "err_obj": {"msg": "expected an indented block"}}], ["3bdf658ae546df03d43468b55284e570", {"code_string": "def as_sql(self, connection, lookup, template_params, * args):\n    if lookup.lhs.output_field.geography and not self.geography:\n        raise ValueError('PostGIS geography does not support the \"%s\" '\n            'function/operator.' %(self.func or self.op, )))\n    template_params = self.check_raster(lookup, template_params)\n    return super().as_sql(connection, lookup, template_params, * args)\n", "code_toks_joined": "def as_sql ( self , connection , lookup , template_params , * args ) : <NEWLINE> <INDENT> if lookup . lhs . output_field . geography and not self . geography : <NEWLINE> <INDENT> raise ValueError ( <STRING> <NEWLINE> <INDENT> <STRING> % ( self . func or self . op , ) ) ) <NEWLINE> <DEDENT> <DEDENT> template_params = self . check_raster ( lookup , template_params ) <NEWLINE> return super ( ) . as_sql ( connection , lookup , template_params , * args ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'PostGIS geography does not support the \"%s\" '", "'function/operator.'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["43d3b891050ad3c03c0135c49818bea4", {"code_string": "def testingDecorators():\n    print(\"Testing Decorators...\")\n    try:\n        nonNegative(3, 6, - 2, 5)\n    except LessThanZero:\n        print(\"Exception caught. This works.\")\n    setA = set(allCaps(\"mother\", \"kitten\", \"pizza\"))\n    setB = set(\"MOTHER\", \"KITTEN\", \"PIZZA\")\n        if(setA == setB):\n            print(\"All tests passed!\")\n    else:\n        print(\"AllCaps failed\")\n", "code_toks_joined": "def testingDecorators ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> nonNegative ( 3 , 6 , - 2 , 5 ) <NEWLINE> <DEDENT> except LessThanZero : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> setA = set ( allCaps ( <STRING> , <STRING> , <STRING> ) ) <NEWLINE> setB = set ( <STRING> , <STRING> , <STRING> ) <NEWLINE> <INDENT> if ( setA == setB ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Testing Decorators...\"", "\"Exception caught. This works.\"", "\"mother\"", "\"kitten\"", "\"pizza\"", "\"MOTHER\"", "\"KITTEN\"", "\"PIZZA\"", "\"All tests passed!\"", "\"AllCaps failed\""]}, "err_obj": {"msg": "unexpected indent"}}], ["1c860f0934c6262c54f06d99a67f9307", {"code_string": "class StatReloaderLoop(ReloaderLoop):\n    name = 'stat'\n    def run(self):\n        mtimes = {}\n        while 1:\n            for filename in chain(_iter_module_files(),\n                self.extra_files):\n                try:\n                mtime = os.stat(filename).st_mtime\n                except OSError:\n                continue\n                old_time = mtimes.get(filename)\n                if old_time is None:\n                mtimes[filename] = mtime\n                continue\n                elif mtime > old_time:\n                self.trigger_reload(filename)\n            self._sleep(self.interval)\n", "code_toks_joined": "class StatReloaderLoop ( ReloaderLoop ) : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> def run ( self ) : <NEWLINE> <INDENT> mtimes = { } <NEWLINE> while 1 : <NEWLINE> <INDENT> for filename in chain ( _iter_module_files ( ) , <NEWLINE> <INDENT> self . extra_files ) : <NEWLINE> try : <NEWLINE> mtime = os . stat ( filename ) . st_mtime <NEWLINE> except OSError : <NEWLINE> continue <NEWLINE> old_time = mtimes . get ( filename ) <NEWLINE> if old_time is None : <NEWLINE> mtimes [ filename ] = mtime <NEWLINE> continue <NEWLINE> elif mtime > old_time : <NEWLINE> self . trigger_reload ( filename ) <NEWLINE> <DEDENT> self . _sleep ( self . interval ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'stat'"]}, "err_obj": {"msg": "expected an indented block"}}], ["243ccc17310a388e2d4d0e06fa798d4d", {"code_string": "def read_INI_file(ini_file, default_params):\n    params = default_params\n    try:\n        input = open(ini_file)\n        for line in input:\n            match = re.match(r'^(.*?)=(.*)$', line)\n            if not match: continue\n            keyword = match.group(1)\n            value = match.group(2)\n            if keyword == \"MaximumCommands\":\n                params[\"maximum_commands\"] = safe_int(value, 1)\n    except IOError, e:\n        pass\n    return params\n", "code_toks_joined": "def read_INI_file ( ini_file , default_params ) : <NEWLINE> <INDENT> params = default_params <NEWLINE> try : <NEWLINE> <INDENT> input = open ( ini_file ) <NEWLINE> for line in input : <NEWLINE> <INDENT> match = re . match ( <STRING> , line ) <NEWLINE> if not match : continue <NEWLINE> keyword = match . group ( 1 ) <NEWLINE> value = match . group ( 2 ) <NEWLINE> if keyword == <STRING> : <NEWLINE> <INDENT> params [ <STRING> ] = safe_int ( value , 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except IOError , e : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> return params <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["r'^(.*?)=(.*)$'", "\"MaximumCommands\"", "\"maximum_commands\""]}, "err_obj": {"msg": "invalid syntax"}}], ["fea2d092379383dd66601d8303238c0d", {"code_string": "def nesting_order((point, is_start, payload)):\n    \"\"\"Return a sorting key that places coincident Line boundaries outermost,\"\"\"\n    return point, is_start, (payload.sort_order if is_start else\n        - payload.sort_order)\n", "code_toks_joined": "def nesting_order ( ( point , is_start , payload ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return point , is_start , ( payload . sort_order if is_start else <NEWLINE> <INDENT> - payload . sort_order ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return a sorting key that places coincident Line boundaries outermost,\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["59d1941fc81da89a46aecebf4cdd6311", {"code_string": "def main():\n    global Alive\n    Alive = 1\n    thread.start_new_thread(webshow, ())\n    sleep(0.5)\n    thread.start_new_thread(gettext, ())\n    while Alive:\n    sleep(0.2)\n        clip_id = os.popen(\"ps aux | grep xclip | grep -v grep |awk '{print $2}'| grep -v ^$ |wc -l\")\n        pid = clip_id.readline().strip('\\r\\n\\x00')\n        if int(pid) >= 1:\n            os.system(\"ps aux | grep xclip |awk '{print $2}' |xargs kill -9 >/dev/null\")\n", "code_toks_joined": "def main ( ) : <NEWLINE> <INDENT> global Alive <NEWLINE> Alive = 1 <NEWLINE> thread . start_new_thread ( webshow , ( ) ) <NEWLINE> sleep ( 0.5 ) <NEWLINE> thread . start_new_thread ( gettext , ( ) ) <NEWLINE> while Alive : <NEWLINE> sleep ( 0.2 ) <NEWLINE> <INDENT> clip_id = os . popen ( <STRING> ) <NEWLINE> pid = clip_id . readline ( ) . strip ( <STRING> ) <NEWLINE> if int ( pid ) >= 1 : <NEWLINE> <INDENT> os . system ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"ps aux | grep xclip | grep -v grep |awk '{print $2}'| grep -v ^$ |wc -l\"", "'\\r\\n\\x00'", "\"ps aux | grep xclip |awk '{print $2}' |xargs kill -9 >/dev/null\""]}, "err_obj": {"msg": "expected an indented block"}}], ["f0445e68b2e903ec2c6eaf2a49d5825a", {"code_string": "def show_help():\n    \"\"\"Help on common operations.\"\"\"\n    from denim.environment import get_environments\n    import denim\n    print(\"\"\"Common operations with Denim (%(version)s).\"\"\" %{\n        'environments': '|'.join(get_environments()),\n        'version': denim.__version__,\n    }\n", "code_toks_joined": "def show_help ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> from denim . environment import get_environments <NEWLINE> import denim <NEWLINE> print ( <STRING> % { <NEWLINE> <INDENT> <STRING> : <STRING> . join ( get_environments ( ) ) , <NEWLINE> <STRING> : denim . __version__ , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Help on common operations.\"\"\"", "\"\"\"Common operations with Denim (%(version)s).\"\"\"", "'environments'", "'|'", "'version'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["b56efd38f409a4115aedc17049a09e74", {"code_string": "def residual(self, level):\n    \"\"\"residual: puts the residual into the next level source vector\"\"\"\n        lhs = np.dot((self.grids[level].T - self.grids[level].S), self.grids[level].phi)\n        r = self.grids[level].q - lhs\n        self.grids[level + 1].q = copy.deepcopy(self.restrict(r))\n", "code_toks_joined": "def residual ( self , level ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> lhs = np . dot ( ( self . grids [ level ] . T - self . grids [ level ] . S ) , self . grids [ level ] . phi ) <NEWLINE> r = self . grids [ level ] . q - lhs <NEWLINE> self . grids [ level + 1 ] . q = copy . deepcopy ( self . restrict ( r ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"residual: puts the residual into the next level source vector\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["d1f551c8a96124c82acabac5bb295d3d", {"code_string": "def _test_SUNW_ldynsym_section_generic(self, testfile, reference_data):\n    with open(os.path.join('test', 'testfiles_for_unittests',\n        testfile), 'rb') as f:\n        elf = ELFFile(f)\n        ldynsym_section = elf.get_section_by_name('.SUNW_ldynsym')\n        self.assertIsNotNone(ldynsym_section)\n        for symbol, ref_symbol_name in zip(\n        ldynsym_section.iter_symbols(), reference_data):\n        self.assertEqual(symbol.name, ref_symbol_name)\n", "code_toks_joined": "def _test_SUNW_ldynsym_section_generic ( self , testfile , reference_data ) : <NEWLINE> <INDENT> with open ( os . path . join ( <STRING> , <STRING> , <NEWLINE> <INDENT> testfile ) , <STRING> ) as f : <NEWLINE> elf = ELFFile ( f ) <NEWLINE> ldynsym_section = elf . get_section_by_name ( <STRING> ) <NEWLINE> self . assertIsNotNone ( ldynsym_section ) <NEWLINE> for symbol , ref_symbol_name in zip ( <NEWLINE> ldynsym_section . iter_symbols ( ) , reference_data ) : <NEWLINE> self . assertEqual ( symbol . name , ref_symbol_name ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'test'", "'testfiles_for_unittests'", "'rb'", "'.SUNW_ldynsym'"]}, "err_obj": {"msg": "expected an indented block"}}], ["4038eb218bd4381b49db54049c55a63c", {"code_string": "def make_new_dir(name_str):\n    file_list = os.listdir()\n    for file_str in file_list:\n        if file_str == name_str:\n            if os.path.isdir(file_str):\n                return 0\n            else:\n                continue\n        else:\n            continue\n    if find_dir(name_str) == 0:\n    else:\n        os.mkdir(os.path.normpath(name_str))\n    return 0\n", "code_toks_joined": "def make_new_dir ( name_str ) : <NEWLINE> <INDENT> file_list = os . listdir ( ) <NEWLINE> for file_str in file_list : <NEWLINE> <INDENT> if file_str == name_str : <NEWLINE> <INDENT> if os . path . isdir ( file_str ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if find_dir ( name_str ) == 0 : <NEWLINE> else : <NEWLINE> <INDENT> os . mkdir ( os . path . normpath ( name_str ) ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["9d5bdeba964a2c1d6eeb1bc633799826", {"code_string": "def do_start(self):\n    print(Options.options)\n    try:\n    Options.options.dband\n    except AttributeError:\n    raise ValueError('use def options(opt): opt.load(\"parallel_debug\")!')\n    self.taskinfo = Queue()\n    old_start(self)\n    process_colors(self)\n", "code_toks_joined": "def do_start ( self ) : <NEWLINE> <INDENT> print ( Options . options ) <NEWLINE> try : <NEWLINE> Options . options . dband <NEWLINE> except AttributeError : <NEWLINE> raise ValueError ( <STRING> ) <NEWLINE> self . taskinfo = Queue ( ) <NEWLINE> old_start ( self ) <NEWLINE> process_colors ( self ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'use def options(opt): opt.load(\"parallel_debug\")!'"]}, "err_obj": {"msg": "expected an indented block"}}], ["abf89d7d015fe761cd94bb49afe372c0", {"code_string": "def create_zip_file(source_dir, outfile):\n    \"\"\"Create a zip file from a source input directory.\"\"\"\n    with zipfile.ZipFile(outfile, 'w',\n        compression = zipfile.ZIP_DEFLATED) as z:\n        for root, _, filenames in os.walk(source_dir):\n        for filename in filenames:\n        full_name = os.path.join(root, filename)\n        archive_name = os.path.relpath(full_name, source_dir)\n        z.write(full_name, archive_name)\n", "code_toks_joined": "def create_zip_file ( source_dir , outfile ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with zipfile . ZipFile ( outfile , <STRING> , <NEWLINE> <INDENT> compression = zipfile . ZIP_DEFLATED ) as z : <NEWLINE> for root , _ , filenames in os . walk ( source_dir ) : <NEWLINE> for filename in filenames : <NEWLINE> full_name = os . path . join ( root , filename ) <NEWLINE> archive_name = os . path . relpath ( full_name , source_dir ) <NEWLINE> z . write ( full_name , archive_name ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Create a zip file from a source input directory.\"\"\"", "'w'"]}, "err_obj": {"msg": "expected an indented block"}}], ["3748a06f3951ae3a1fdf681cb315af41", {"code_string": "def cml2_add_default_caps(config):\n    for c in config.containers:\n    create_default_capabilities(c)\n", "code_toks_joined": "def cml2_add_default_caps ( config ) : <NEWLINE> <INDENT> for c in config . containers : <NEWLINE> create_default_capabilities ( c ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["7f013f9471682933553555b242f29de1", {"code_string": "def quads(self, (s, p, o)):\n    \"\"\"Iterate over all the quads in the entire aggregate graph\"\"\"\n    for graph in self.graphs:\n        for s1, p1, o1 in graph.triples((s, p, o)):\n            yield(s1, p1, o1, graph)\n", "code_toks_joined": "def quads ( self , ( s , p , o ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for graph in self . graphs : <NEWLINE> <INDENT> for s1 , p1 , o1 in graph . triples ( ( s , p , o ) ) : <NEWLINE> <INDENT> yield ( s1 , p1 , o1 , graph ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Iterate over all the quads in the entire aggregate graph\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["fba38c9e4ed11de60862bde670a9ea50", {"code_string": "def __init__(self, region):\n    \"\"\"Init method for AwsPlacementGroup.\"\"\"\n    super(AwsPlacementGroup, self).__init__()\n    self.name = (\n        'perfkit-%s-%s' %(FLAGS.run_uri, str(uuid.uuid4()[- 12: ]))\n    self.region = region\n", "code_toks_joined": "def __init__ ( self , region ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> super ( AwsPlacementGroup , self ) . __init__ ( ) <NEWLINE> self . name = ( <NEWLINE> <INDENT> <STRING> % ( FLAGS . run_uri , str ( uuid . uuid4 ( ) [ - 12 : ] ) ) <NEWLINE> <DEDENT> self . region = region <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Init method for AwsPlacementGroup.\"\"\"", "'perfkit-%s-%s'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["70163a062cd2729a1881ab3a4ec65b86", {"code_string": "class mav_Command(Command):\n    def create_from(self, argarray, execLib):\n    self.lib = execLib\n        self.v0 = argarray[0]\n        self.v1 = argarray[1]\n        return\n    def execute(self):\n        self.lib.lib_mav(self.v0, self.v1)\n        return\n    def toCommands(self):\n        out = \"\"\n        out += \"mav(\" + str(self.v0) + \",\" + str(self.v1) + \");\\n\"\n        return out\n", "code_toks_joined": "class mav_Command ( Command ) : <NEWLINE> <INDENT> def create_from ( self , argarray , execLib ) : <NEWLINE> self . lib = execLib <NEWLINE> <INDENT> self . v0 = argarray [ 0 ] <NEWLINE> self . v1 = argarray [ 1 ] <NEWLINE> return <NEWLINE> <DEDENT> def execute ( self ) : <NEWLINE> <INDENT> self . lib . lib_mav ( self . v0 , self . v1 ) <NEWLINE> return <NEWLINE> <DEDENT> def toCommands ( self ) : <NEWLINE> <INDENT> out = <STRING> <NEWLINE> out += <STRING> + str ( self . v0 ) + <STRING> + str ( self . v1 ) + <STRING> <NEWLINE> return out <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"", "\"mav(\"", "\",\"", "\");\\n\""]}, "err_obj": {"msg": "expected an indented block"}}], ["9f8734cd2755d750617fb183111443ae", {"code_string": "def test_clean_not_exists(self):\n    \"\"\"Test of the \"patatools cache clean\" subcommand\"\"\"\n    for main, args in[\n        (tools_main, [\"patatools\", \"cache\", \"clean\", \"test_cache.yaml\"]),\n        (cache_main, [\"patatools-cache\", \"clean\", \"test_cache.yaml\"]),\n        ]:\n        with self.subTest(main = main, args = args):\n        with logging_reduced('patatools.cache'):\n            self._system(main, args)\n", "code_toks_joined": "def test_clean_not_exists ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for main , args in [ <NEWLINE> <INDENT> ( tools_main , [ <STRING> , <STRING> , <STRING> , <STRING> ] ) , <NEWLINE> ( cache_main , [ <STRING> , <STRING> , <STRING> ] ) , <NEWLINE> ] : <NEWLINE> with self . subTest ( main = main , args = args ) : <NEWLINE> with logging_reduced ( <STRING> ) : <NEWLINE> <INDENT> self . _system ( main , args ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Test of the \"patatools cache clean\" subcommand\"\"\"", "\"patatools\"", "\"cache\"", "\"clean\"", "\"test_cache.yaml\"", "\"patatools-cache\"", "\"clean\"", "\"test_cache.yaml\"", "'patatools.cache'"]}, "err_obj": {"msg": "expected an indented block"}}], ["6329720c1e4b253159a1f96e95633a31", {"code_string": "def get_cookie_string(cls, url, user_agent = None, ** kwargs):\n    \"\"\"Convenience function for building a Cookie HTTP header value.\"\"\"\n    tokens, user_agent = cls.get_tokens(url, user_agent = user_agent)\n    return \"; \".join(\"=\".join(pair) for pair in tokens.items(), user_agent\n", "code_toks_joined": "def get_cookie_string ( cls , url , user_agent = None , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> tokens , user_agent = cls . get_tokens ( url , user_agent = user_agent ) <NEWLINE> return <STRING> . join ( <STRING> . join ( pair ) for pair in tokens . items ( ) , user_agent <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Convenience function for building a Cookie HTTP header value.\"\"\"", "\"; \"", "\"=\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["fd2e75f9ebfcf9ec06ffc15af99a7afe", {"code_string": "def rosterBoxChange(self, event):\n    entry = self.box.getSelectedItem()\n        if isinstance(entry, jmri.jmrit.roster.RosterEntry):\n        theDccAddress = entry.getDccAddress()\n        self.address.text = theDccAddress\n        else:\n            self.address.text = \"\"\n            theDccAddress = 3\n    return 0\n", "code_toks_joined": "def rosterBoxChange ( self , event ) : <NEWLINE> <INDENT> entry = self . box . getSelectedItem ( ) <NEWLINE> <INDENT> if isinstance ( entry , jmri . jmrit . roster . RosterEntry ) : <NEWLINE> theDccAddress = entry . getDccAddress ( ) <NEWLINE> self . address . text = theDccAddress <NEWLINE> else : <NEWLINE> <INDENT> self . address . text = <STRING> <NEWLINE> theDccAddress = 3 <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["c2bb51ea7817ab4d4b557f0738e13c15", {"code_string": "def test_output_dtype_correct(self):\n    '''The output dtype should be correct given the input dtype.'''\n    inp_dtype_tuple = input_dtypes[functions[self.func]]\n    output_dtype_tuple = output_dtypes[functions[self.func]]\n    for input_dtype, output_dtype in zip(inp_dtype_tuple[0],\n        output_dtype_tuple):\n        for test_shape, s, kwargs in self.test_data:\n        s = None\n        FFTW_object = self.validate_pyfftw_object(inp_dtype_tuple[1],\n        test_shape, input_dtype, s, kwargs)\n        self.assertTrue(\n        FFTW_object.output_array.dtype.char ==\n        np.dtype(output_dtype).char)\n", "code_toks_joined": "def test_output_dtype_correct ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> inp_dtype_tuple = input_dtypes [ functions [ self . func ] ] <NEWLINE> output_dtype_tuple = output_dtypes [ functions [ self . func ] ] <NEWLINE> for input_dtype , output_dtype in zip ( inp_dtype_tuple [ 0 ] , <NEWLINE> <INDENT> output_dtype_tuple ) : <NEWLINE> for test_shape , s , kwargs in self . test_data : <NEWLINE> s = None <NEWLINE> FFTW_object = self . validate_pyfftw_object ( inp_dtype_tuple [ 1 ] , <NEWLINE> test_shape , input_dtype , s , kwargs ) <NEWLINE> self . assertTrue ( <NEWLINE> FFTW_object . output_array . dtype . char == <NEWLINE> np . dtype ( output_dtype ) . char ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''The output dtype should be correct given the input dtype.'''"]}, "err_obj": {"msg": "expected an indented block"}}], ["b111330b29d987a6d9f1a2b2ed69d693", {"code_string": "def verify_rtslib():\n    for member in['BlockStorageObject', 'FabricModule', 'LUN',\n        'MappedLUN', 'NetworkPortal', 'NodeACL', 'root',\n        'Target', 'TPG']:\n        if not hasattr(rtslib_fb, member):\n        raise RtstoolImportError(_(\"rtslib_fb is missing member %s: You \"\n            \"may need a newer python-rtslib-fb.\") %\n            member)\n", "code_toks_joined": "def verify_rtslib ( ) : <NEWLINE> <INDENT> for member in [ <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> ] : <NEWLINE> if not hasattr ( rtslib_fb , member ) : <NEWLINE> raise RtstoolImportError ( _ ( <STRING> <NEWLINE> <INDENT> <STRING> ) % <NEWLINE> member ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'BlockStorageObject'", "'FabricModule'", "'LUN'", "'MappedLUN'", "'NetworkPortal'", "'NodeACL'", "'root'", "'Target'", "'TPG'", "\"rtslib_fb is missing member %s: You \"", "\"may need a newer python-rtslib-fb.\""]}, "err_obj": {"msg": "expected an indented block"}}], ["fe7c5e0e1a6db8a1630ec25777f376cf", {"code_string": "def test_report_state(self):\n    with mock.patch.object(self.agent.state_rpc,\n        \"report_state\") as report_st:\n        self.agent._report_state()\n        report_st.assert_called_with(self.agent.context,\n            self.agent.agent_state)\n            self.assertNotIn(\"start_flag\", self.agent.agent_state)\n", "code_toks_joined": "def test_report_state ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( self . agent . state_rpc , <NEWLINE> <INDENT> <STRING> ) as report_st : <NEWLINE> self . agent . _report_state ( ) <NEWLINE> report_st . assert_called_with ( self . agent . context , <NEWLINE> <INDENT> self . agent . agent_state ) <NEWLINE> self . assertNotIn ( <STRING> , self . agent . agent_state ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"report_state\"", "\"start_flag\""]}, "err_obj": {"msg": "unexpected indent"}}], ["b93c79352482493b8f7d71f42f81d7cc", {"code_string": "def load_variables():\n    \"\"\"Load variables from environment variables.\"\"\"\n    if(not os.environ.get(\"PYCONFLUENCE_TOKEN\") or\n        not os.environ.get(\"PYCONFLUENCE_USER\") or\n        not os.environ.get(\"PYCONFLUENCE_ORG\")):\n        print(\"One or more pyconfluence environment variables are not set. \"\n            \"See README for directions on how to resolve this.\")\n            sys.exit(\"Error\")\n    global token\n    global user\n    global base_url\n    token = os.environ[\"PYCONFLUENCE_TOKEN\"]\n    user = os.environ[\"PYCONFLUENCE_USER\"]\n    base_url = (\"https://\" + os.environ[\"PYCONFLUENCE_ORG\"] + \".atlassian\"\n        \".net/wiki/rest/api/content\")\n", "code_toks_joined": "def load_variables ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( not os . environ . get ( <STRING> ) or <NEWLINE> <INDENT> not os . environ . get ( <STRING> ) or <NEWLINE> not os . environ . get ( <STRING> ) ) : <NEWLINE> print ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> sys . exit ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> global token <NEWLINE> global user <NEWLINE> global base_url <NEWLINE> token = os . environ [ <STRING> ] <NEWLINE> user = os . environ [ <STRING> ] <NEWLINE> base_url = ( <STRING> + os . environ [ <STRING> ] + <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Load variables from environment variables.\"\"\"", "\"PYCONFLUENCE_TOKEN\"", "\"PYCONFLUENCE_USER\"", "\"PYCONFLUENCE_ORG\"", "\"One or more pyconfluence environment variables are not set. \"", "\"See README for directions on how to resolve this.\"", "\"Error\"", "\"PYCONFLUENCE_TOKEN\"", "\"PYCONFLUENCE_USER\"", "\"https://\"", "\"PYCONFLUENCE_ORG\"", "\".atlassian\"", "\".net/wiki/rest/api/content\""]}, "err_obj": {"msg": "unexpected indent"}}], ["b6f6c50e48b83c9e4e1dfb538dc8c139", {"code_string": "class SecureSession(object):\n    def __init__(self):\n    json()\n        base64.b64encode(hmac.new(tob(key), msg).digest())):\n            return pickle.loads(base64.b64decode(msg))\n", "code_toks_joined": "class SecureSession ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> json ( ) <NEWLINE> <INDENT> base64 . b64encode ( hmac . new ( tob ( key ) , msg ) . digest ( ) ) ) : <NEWLINE> <INDENT> return pickle . loads ( base64 . b64decode ( msg ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["628b69178ab104e862eda47cd44f51d4", {"code_string": "def get_objects_data(self):\n    \"\"\"Returns a list of objects within the current folder.\"\"\"\n    filtered_objects = [item for item in self.objects\n        if(not self.is_subdir(item) and\n            not self.is_placeholder(item)]\n    return filtered_objects\n", "code_toks_joined": "def get_objects_data ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> filtered_objects = [ item for item in self . objects <NEWLINE> <INDENT> if ( not self . is_subdir ( item ) and <NEWLINE> <INDENT> not self . is_placeholder ( item ) ] <NEWLINE> <DEDENT> <DEDENT> return filtered_objects <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns a list of objects within the current folder.\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e1d994bcbdcc32e8327d1ca89b3c4022", {"code_string": "import os\nimport argparse\nimport boto.iam\nimport boto.ec2\nimport boto.ec2.elb\nimport boto.cloudformation\nimport boto.utils\nimport boto.rds2\nimport json\nimport base64\nimport yaml\nimport requests\nimport hashlib\nfrom requests.auth import HTTPBasicAuth\nfrom pprint import pprint\nimport string\nBASE_LIST = string.digits + string.letters\nBASE_DICT = dict((c, i) for i, c in enumerate(BASE_LIST)\n", "code_toks_joined": "import os <NEWLINE> import argparse <NEWLINE> import boto . iam <NEWLINE> import boto . ec2 <NEWLINE> import boto . ec2 . elb <NEWLINE> import boto . cloudformation <NEWLINE> import boto . utils <NEWLINE> import boto . rds2 <NEWLINE> import json <NEWLINE> import base64 <NEWLINE> import yaml <NEWLINE> import requests <NEWLINE> import hashlib <NEWLINE> from requests . auth import HTTPBasicAuth <NEWLINE> from pprint import pprint <NEWLINE> import string <NEWLINE> BASE_LIST = string . digits + string . letters <NEWLINE> BASE_DICT = dict ( ( c , i ) for i , c in enumerate ( BASE_LIST ) <NEWLINE>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["130125c1fe5e8a823533c692109d5128", {"code_string": "def get(self, workflow_id, email_id):\n    \"\"\"Get information about an individual Automation workflow email.\"\"\"\n    self.workflow_id = workflow_id\n    self.email_id = email_id\n    return self._mc_client._get(url = self._build_path(workflow_id, 'emails', email_id)\n", "code_toks_joined": "def get ( self , workflow_id , email_id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . workflow_id = workflow_id <NEWLINE> self . email_id = email_id <NEWLINE> return self . _mc_client . _get ( url = self . _build_path ( workflow_id , <STRING> , email_id ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get information about an individual Automation workflow email.\"\"\"", "'emails'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["ee95512b474585da6683c483fb14ce4c", {"code_string": "class Command(BaseCommand):\n    help = 'Create new Super User with Profile.'\n    def create_user(\n        self, name, username, password):\n        new_user = (\n        self.User.objects.create_superuser(\n            username, password))\n            try:\n        Profile.objects.create(\n            user = new_user,\n            name = name,\n            slug = slugify(name))\n            except Exception as e:\n        raise CommandError(\n            \"Could not create Profile:\\n{}\"\n            .format('; '.join(e.messages)))\n", "code_toks_joined": "class Command ( BaseCommand ) : <NEWLINE> <INDENT> help = <STRING> <NEWLINE> def create_user ( <NEWLINE> <INDENT> self , name , username , password ) : <NEWLINE> new_user = ( <NEWLINE> self . User . objects . create_superuser ( <NEWLINE> <INDENT> username , password ) ) <NEWLINE> try : <NEWLINE> <DEDENT> Profile . objects . create ( <NEWLINE> <INDENT> user = new_user , <NEWLINE> name = name , <NEWLINE> slug = slugify ( name ) ) <NEWLINE> except Exception as e : <NEWLINE> <DEDENT> raise CommandError ( <NEWLINE> <INDENT> <STRING> <NEWLINE> . format ( <STRING> . join ( e . messages ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Create new Super User with Profile.'", "\"Could not create Profile:\\n{}\"", "'; '"]}, "err_obj": {"msg": "unexpected indent"}}], ["3e5605b3efec726a6c3187c835a72465", {"code_string": "class Application(tornado.web.Application):\n    def __init__(self, handlers = None, default_host = \"\", transforms = None,\n        ** configs):\n        if handlers is None:\n        handlers = pages\n        if not configs:\n        configs = config\n        tornado.web.Application.__init__(self, handlers, default_host,\n            transforms, ** configs)\n            self.db = engine.connect()\n", "code_toks_joined": "class Application ( tornado . web . Application ) : <NEWLINE> <INDENT> def __init__ ( self , handlers = None , default_host = <STRING> , transforms = None , <NEWLINE> <INDENT> ** configs ) : <NEWLINE> if handlers is None : <NEWLINE> handlers = pages <NEWLINE> if not configs : <NEWLINE> configs = config <NEWLINE> tornado . web . Application . __init__ ( self , handlers , default_host , <NEWLINE> <INDENT> transforms , ** configs ) <NEWLINE> self . db = engine . connect ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["3e969aeb96c816e07bb6e8909a1b026c", {"code_string": "def __repr__(self):\n    rtlst = []\n    for net, msk, gw, iface, addr in self.routes:\n    rtlst.append((ltoa(net),\n        ltoa(msk),\n        gw,\n        (iface.name if not isinstance(iface, basestring) else iface),\n        addr))\n    return pretty_routes(rtlst,\n        [(\"Network\", \"Netmask\", \"Gateway\", \"Iface\", \"Output IP\")])\n", "code_toks_joined": "def __repr__ ( self ) : <NEWLINE> <INDENT> rtlst = [ ] <NEWLINE> for net , msk , gw , iface , addr in self . routes : <NEWLINE> rtlst . append ( ( ltoa ( net ) , <NEWLINE> <INDENT> ltoa ( msk ) , <NEWLINE> gw , <NEWLINE> ( iface . name if not isinstance ( iface , basestring ) else iface ) , <NEWLINE> addr ) ) <NEWLINE> <DEDENT> return pretty_routes ( rtlst , <NEWLINE> <INDENT> [ ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) ] ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Network\"", "\"Netmask\"", "\"Gateway\"", "\"Iface\"", "\"Output IP\""]}, "err_obj": {"msg": "expected an indented block"}}], ["4d9a5423f5b4b4dd36e4e007d610b1b4", {"code_string": "def someFunctionWithUnqualifiedExecAndCallback():\n    exec \"def f(): pass\"\n    def callback():\n        return nested\n", "code_toks_joined": "def someFunctionWithUnqualifiedExecAndCallback ( ) : <NEWLINE> <INDENT> exec <STRING> <NEWLINE> def callback ( ) : <NEWLINE> <INDENT> return nested <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"def f(): pass\""]}, "err_obj": {"msg": "invalid syntax"}}], ["8bacb9f18198f7b5fbb3a7bd26956738", {"code_string": "def __init__(user_url):\n    super(User, self) __init_()\n    self.user = user_url\n", "code_toks_joined": "def __init__ ( user_url ) : <NEWLINE> <INDENT> super ( User , self ) __init_ ( ) <NEWLINE> self . user = user_url <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["0e5f9fbf854dfff1ed8a850f1b2bb8af", {"code_string": "class BatchTransformAlgorithmSetSid(TradingAlgorithm):\n    def initialize(self, sids = None):\n        self.history = []\n        self.batch_transform = return_price(\n            refresh_period = 1,\n            window_length = 10,\n            clean_nans = False,\n            sids = sids,\n            compute_only_full = False\n        )\n    def handle_data(self, data):\n        self.history.append(\n            deepcopy(self.batch_transform.handle_data(data))))\n", "code_toks_joined": "class BatchTransformAlgorithmSetSid ( TradingAlgorithm ) : <NEWLINE> <INDENT> def initialize ( self , sids = None ) : <NEWLINE> <INDENT> self . history = [ ] <NEWLINE> self . batch_transform = return_price ( <NEWLINE> <INDENT> refresh_period = 1 , <NEWLINE> window_length = 10 , <NEWLINE> clean_nans = False , <NEWLINE> sids = sids , <NEWLINE> compute_only_full = False <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> def handle_data ( self , data ) : <NEWLINE> <INDENT> self . history . append ( <NEWLINE> <INDENT> deepcopy ( self . batch_transform . handle_data ( data ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["13c6904788318458ae7acd77c2b14502", {"code_string": "def getExceptionCheckProfile(self, detachThread, methodReturn = \"\"):\n    if configGiws().getThrowsException():\n        str = \"\"\"if (curEnv->ExceptionCheck()) {\"\"\"\n            if methodReturn != \"\":\n                str += \"\"\"delete[] %s;\"\"\" %(methodReturn)\n            str += \"\"\"%sthrow %s::JniCallMethodException(curEnv);\"\"\" %(detachThread, configGiws().getExceptionFileName())\n            return str\n    else:\n        return \"\"\"if (curEnv->ExceptionCheck()) {\"\"\"\n", "code_toks_joined": "def getExceptionCheckProfile ( self , detachThread , methodReturn = <STRING> ) : <NEWLINE> <INDENT> if configGiws ( ) . getThrowsException ( ) : <NEWLINE> <INDENT> str = <STRING> <NEWLINE> <INDENT> if methodReturn != <STRING> : <NEWLINE> <INDENT> str += <STRING> % ( methodReturn ) <NEWLINE> <DEDENT> str += <STRING> % ( detachThread , configGiws ( ) . getExceptionFileName ( ) ) <NEWLINE> return str <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"", "\"\"\"if (curEnv->ExceptionCheck()) {\"\"\"", "\"\"", "\"\"\"delete[] %s;\"\"\"", "\"\"\"%sthrow %s::JniCallMethodException(curEnv);\"\"\"", "\"\"\"if (curEnv->ExceptionCheck()) {\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["4c19cbbfd6866fbd47aaec3ff6cc5388", {"code_string": "def addListener(self, listener, iface = None):\n    \"\"\"Adds the link activated listener.\"\"\"\n    if(isinstance(listener, ILinkActivatedListener) and\n        (iface is None or issubclass(iface, ILinkActivatedListener))):\n        self._listeners.add(listener)\n        super(ActiveLink, self).registerListener(LinkActivatedEvent,\n            listener, _LINK_FOLLOWED_METHOD)\n            if len(self._listeners) == 1:\n        self.requestRepaint()\n    super(ActiveLink, self).addListener(listener, iface)\n", "code_toks_joined": "def addListener ( self , listener , iface = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( isinstance ( listener , ILinkActivatedListener ) and <NEWLINE> <INDENT> ( iface is None or issubclass ( iface , ILinkActivatedListener ) ) ) : <NEWLINE> self . _listeners . add ( listener ) <NEWLINE> super ( ActiveLink , self ) . registerListener ( LinkActivatedEvent , <NEWLINE> <INDENT> listener , _LINK_FOLLOWED_METHOD ) <NEWLINE> if len ( self . _listeners ) == 1 : <NEWLINE> <DEDENT> self . requestRepaint ( ) <NEWLINE> <DEDENT> super ( ActiveLink , self ) . addListener ( listener , iface ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Adds the link activated listener.\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["ec0a50fdf204bac04eb090513d3e5c9d", {"code_string": "def decodeData(self, data):\n    self.log.debug(\"Running...\")\n    d = subprocess.Popen([\"./fdmdv_demod\", \"-\", \"-\"], stdin = subprocess.PIPE, stdout = subprocess.PIPE, stderr = subprocess.PIPE, shell = False)\n    if d is not None:\n    r = d.communicate(data)\n    d.wait()\n    return r[0]\n", "code_toks_joined": "def decodeData ( self , data ) : <NEWLINE> <INDENT> self . log . debug ( <STRING> ) <NEWLINE> d = subprocess . Popen ( [ <STRING> , <STRING> , <STRING> ] , stdin = subprocess . PIPE , stdout = subprocess . PIPE , stderr = subprocess . PIPE , shell = False ) <NEWLINE> if d is not None : <NEWLINE> r = d . communicate ( data ) <NEWLINE> d . wait ( ) <NEWLINE> return r [ 0 ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Running...\"", "\"./fdmdv_demod\"", "\"-\"", "\"-\""]}, "err_obj": {"msg": "expected an indented block"}}], ["02b58e1b7aee8fd8fab0a0a388c3b4c9", {"code_string": "def test_with_short_args(self):\n    with self._args_test([0, 1, 2], [0, 1],\n        i = [0, 1, 2], i2 = [0, 1, 4]) as dummy:\n        for i in range(2):\n        dummy.do_step(1, i, i * i, i = i, i2 = i * i)\n", "code_toks_joined": "def test_with_short_args ( self ) : <NEWLINE> <INDENT> with self . _args_test ( [ 0 , 1 , 2 ] , [ 0 , 1 ] , <NEWLINE> <INDENT> i = [ 0 , 1 , 2 ] , i2 = [ 0 , 1 , 4 ] ) as dummy : <NEWLINE> for i in range ( 2 ) : <NEWLINE> dummy . do_step ( 1 , i , i * i , i = i , i2 = i * i ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["9eed8a31440bc823f725183c99c1b2ae", {"code_string": "def get_counts(fn_in, gtf, out):\n    \"\"\"Get counts using htseq-count script\"\"\"\n    if fn_in.endswith(\"bam\") or fn_in.endswith(\"sam\"):\n        cmd = \"samtools sort -n -O sam {fn_in} -o /dev/stdout | awk '$7==\\\"=\\\"' | htseq-count -s no -i gene - {gtf} > {out}\"\n    elif fn_in.startswith(\"SRR\"):\n        cmd = \"sam-dump {fn_in} | samtools sort -n -O sam - -o /dev/stdout | awk '$7==\\\"=\\\"' | htseq-count -s no -i gene - {gtf} > {out}\"\n    else:\n    raise ValueError(\"Sample or ID doesn't sound familiar %s\" % fn_in)\n    logger.info(cmd.format(** locals()))\n    if not os.path.exists(out):\n        do.run(cmd.format(** locals()), log_stdout = True)\n    return out\n", "code_toks_joined": "def get_counts ( fn_in , gtf , out ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if fn_in . endswith ( <STRING> ) or fn_in . endswith ( <STRING> ) : <NEWLINE> <INDENT> cmd = <STRING> <NEWLINE> <DEDENT> elif fn_in . startswith ( <STRING> ) : <NEWLINE> <INDENT> cmd = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> raise ValueError ( <STRING> % fn_in ) <NEWLINE> logger . info ( cmd . format ( ** locals ( ) ) ) <NEWLINE> if not os . path . exists ( out ) : <NEWLINE> <INDENT> do . run ( cmd . format ( ** locals ( ) ) , log_stdout = True ) <NEWLINE> <DEDENT> return out <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get counts using htseq-count script\"\"\"", "\"bam\"", "\"sam\"", "\"samtools sort -n -O sam {fn_in} -o /dev/stdout | awk '$7==\\\"=\\\"' | htseq-count -s no -i gene - {gtf} > {out}\"", "\"SRR\"", "\"sam-dump {fn_in} | samtools sort -n -O sam - -o /dev/stdout | awk '$7==\\\"=\\\"' | htseq-count -s no -i gene - {gtf} > {out}\"", "\"Sample or ID doesn't sound familiar %s\""]}, "err_obj": {"msg": "expected an indented block"}}], ["47b420655d2fd510895d37562dbfd141", {"code_string": "def test_database_outage(self, mock_lms_request):\n    \"\"\"Test that the endpoint reports when the database is unavailable.\"\"\"\n    self.fake_lms_response.status_code = status.HTTP_200_OK\n    mock_lms_request.return_value = self.fake_lms_response\n    self._assert_health(\n        status.HTTP_503_SERVICE_UNAVAILABLE,\n        Status.UNAVAILABLE,\n        Status.UNAVAILABLE,\n        ,\n        Status.OK\n    )\n", "code_toks_joined": "def test_database_outage ( self , mock_lms_request ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . fake_lms_response . status_code = status . HTTP_200_OK <NEWLINE> mock_lms_request . return_value = self . fake_lms_response <NEWLINE> self . _assert_health ( <NEWLINE> <INDENT> status . HTTP_503_SERVICE_UNAVAILABLE , <NEWLINE> Status . UNAVAILABLE , <NEWLINE> Status . UNAVAILABLE , <NEWLINE> , <NEWLINE> Status . OK <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Test that the endpoint reports when the database is unavailable.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["29198bd0a3775e55bc11b1dafbc93369", {"code_string": "def main():\n    provider = AtramhasisProvider({'id': 'Atramhasis'}, base_url = 'http://glacial-bastion-1106.herokuapp.com', scheme_id = 'TREES')\n    keyword = 'Lar'\n    results = provider.find(\n    {\n        'label': keyword,\n        'type': 'concept'\n    }\n", "code_toks_joined": "def main ( ) : <NEWLINE> <INDENT> provider = AtramhasisProvider ( { <STRING> : <STRING> } , base_url = <STRING> , scheme_id = <STRING> ) <NEWLINE> keyword = <STRING> <NEWLINE> results = provider . find ( <NEWLINE> { <NEWLINE> <INDENT> <STRING> : keyword , <NEWLINE> <STRING> : <STRING> <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'id'", "'Atramhasis'", "'http://glacial-bastion-1106.herokuapp.com'", "'TREES'", "'Lar'", "'label'", "'type'", "'concept'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["d613d509795d1ded92a963958c0a69cb", {"code_string": "class METHOD(CIMElement):\n    \"\"\"The METHOD element defines a single CIM Method. It may have\"\"\"\n    def __init__(self, name, parameters = [], return_type = None,\n        class_origin = None, propagated = None, qualifiers = []):\n        Element.__init__(self, 'METHOD')\n        self.setName(name)\n        self.setOptionalAttribute('TYPE', return_type)\n        self.setOptionalAttribute('CLASSORIGIN', class_origin)\n        if propagated is not None:\n        self.setAttribute('PROPAGATED', str(propagated).lower())\n        self.appendChildren(qualifiers + parameters)\n", "code_toks_joined": "class METHOD ( CIMElement ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , name , parameters = [ ] , return_type = None , <NEWLINE> <INDENT> class_origin = None , propagated = None , qualifiers = [ ] ) : <NEWLINE> Element . __init__ ( self , <STRING> ) <NEWLINE> self . setName ( name ) <NEWLINE> self . setOptionalAttribute ( <STRING> , return_type ) <NEWLINE> self . setOptionalAttribute ( <STRING> , class_origin ) <NEWLINE> if propagated is not None : <NEWLINE> self . setAttribute ( <STRING> , str ( propagated ) . lower ( ) ) <NEWLINE> self . appendChildren ( qualifiers + parameters ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"The METHOD element defines a single CIM Method. It may have\"\"\"", "'METHOD'", "'TYPE'", "'CLASSORIGIN'", "'PROPAGATED'"]}, "err_obj": {"msg": "expected an indented block"}}], ["749eb4453803815fd475153d84ba947e", {"code_string": "def set(self, property, value):\n    cmd = 'self.cam.set( cv2.cv.CV_CAP_PROP_' + property + ', ' + str(value) + ')'\n    print(cmd)\n    exec cmd\n", "code_toks_joined": "def set ( self , property , value ) : <NEWLINE> <INDENT> cmd = <STRING> + property + <STRING> + str ( value ) + <STRING> <NEWLINE> print ( cmd ) <NEWLINE> exec cmd <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'self.cam.set( cv2.cv.CV_CAP_PROP_'", "', '", "')'"]}, "err_obj": {"msg": "invalid syntax"}}], ["64186fdf994b58365e515bbf701a41fd", {"code_string": "def _get_entry(self, request):\n    \"\"\"Find an entry in the API cache store that matches the request.\"\"\"\n    url = request.get_full_url()\n    try:\n        with contextlib.closing(self.db.cursor()) as c:\n            for row in c.execute('SELECT * FROM api_cache WHERE url=?',\n                (url, )):\n                if row.matches_request(request):\n                return row\n    except sqlite3.Error as e:\n        self._die('Could not retrieve an entry from the HTTP cache', e)\n    return None\n", "code_toks_joined": "def _get_entry ( self , request ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> url = request . get_full_url ( ) <NEWLINE> try : <NEWLINE> <INDENT> with contextlib . closing ( self . db . cursor ( ) ) as c : <NEWLINE> <INDENT> for row in c . execute ( <STRING> , <NEWLINE> <INDENT> ( url , ) ) : <NEWLINE> if row . matches_request ( request ) : <NEWLINE> return row <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except sqlite3 . Error as e : <NEWLINE> <INDENT> self . _die ( <STRING> , e ) <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Find an entry in the API cache store that matches the request.\"\"\"", "'SELECT * FROM api_cache WHERE url=?'", "'Could not retrieve an entry from the HTTP cache'"]}, "err_obj": {"msg": "expected an indented block"}}], ["efaf5e285c529870071e8c0d8d042fe1", {"code_string": "def OnSave(self, event):\n    file_choices = \"PNG (*.png)|*.png\"\n        dlg = wx.FileDialog(\n        self,\n        message = \"Save plot as...\",\n            defaultDir = os.getcwd(),\n            defaultFile = \"plot.png\",\n            wildcard = file_choices,\n            style = wx.SAVE)\n        if dlg.ShowModal() == wx.ID_OK:\n            path = dlg.GetPath()\n            self.canvas.print_figure(path, dpi = self.dpi)\n", "code_toks_joined": "def OnSave ( self , event ) : <NEWLINE> <INDENT> file_choices = <STRING> <NEWLINE> <INDENT> dlg = wx . FileDialog ( <NEWLINE> self , <NEWLINE> message = <STRING> , <NEWLINE> <INDENT> defaultDir = os . getcwd ( ) , <NEWLINE> defaultFile = <STRING> , <NEWLINE> wildcard = file_choices , <NEWLINE> style = wx . SAVE ) <NEWLINE> <DEDENT> if dlg . ShowModal ( ) == wx . ID_OK : <NEWLINE> <INDENT> path = dlg . GetPath ( ) <NEWLINE> self . canvas . print_figure ( path , dpi = self . dpi ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"PNG (*.png)|*.png\"", "\"Save plot as...\"", "\"plot.png\""]}, "err_obj": {"msg": "unexpected indent"}}], ["f50ae22db39ffff402e5743481dfe31d", {"code_string": "def _trovePreparingChroot(self, (jobId, troveTuple), host, path):\n    if not self._watchTrove(jobId, troveTuple):\n        return\n    if host == '_local_':\n        msg = 'Chroot at %s' % path\n    else:\n        msg = 'Chroot at Node %s:%s' %(host, path)\n    self._msg('[%d] - %s - %s' %(jobId, troveTuple[0], msg))\n", "code_toks_joined": "def _trovePreparingChroot ( self , ( jobId , troveTuple ) , host , path ) : <NEWLINE> <INDENT> if not self . _watchTrove ( jobId , troveTuple ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if host == <STRING> : <NEWLINE> <INDENT> msg = <STRING> % path <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> msg = <STRING> % ( host , path ) <NEWLINE> <DEDENT> self . _msg ( <STRING> % ( jobId , troveTuple [ 0 ] , msg ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'_local_'", "'Chroot at %s'", "'Chroot at Node %s:%s'", "'[%d] - %s - %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["3b6a5157a624cacb89364ff70a15aa1c", {"code_string": "def test_wrappers(self):\n    self.o.ind = 4\n    self.n.ind = 5\n    self.assertEqual(6 .__index__(), 6)\n    self.assertEqual(- 7 L.__index__(), - 7)\n    self.assertEqual(self.o.__index__(), 4)\n    self.assertEqual(self.n.__index__(), 5)\n", "code_toks_joined": "def test_wrappers ( self ) : <NEWLINE> <INDENT> self . o . ind = 4 <NEWLINE> self . n . ind = 5 <NEWLINE> self . assertEqual ( 6 . __index__ ( ) , 6 ) <NEWLINE> self . assertEqual ( - 7 L . __index__ ( ) , - 7 ) <NEWLINE> self . assertEqual ( self . o . __index__ ( ) , 4 ) <NEWLINE> self . assertEqual ( self . n . __index__ ( ) , 5 ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["19a9c47a234482dfb8ee5db4e9ef58c4", {"code_string": "def _read(self, input):\n    \"\"\"Read the output of the child process.\"\"\"\n    out = ''\n    try:\n        out = os.read(input, 0x400)\n        if self.verbose and str(out).strip():\n            print(\"INPUT>\", out.strip())\n    except Exception, e:\n        pass\n    return out\n", "code_toks_joined": "def _read ( self , input ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> out = <STRING> <NEWLINE> try : <NEWLINE> <INDENT> out = os . read ( input , 0x400 ) <NEWLINE> if self . verbose and str ( out ) . strip ( ) : <NEWLINE> <INDENT> print ( <STRING> , out . strip ( ) ) <NEWLINE> <DEDENT> <DEDENT> except Exception , e : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> return out <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Read the output of the child process.\"\"\"", "''", "\"INPUT>\""]}, "err_obj": {"msg": "invalid syntax"}}], ["35afc33d1ef0f9f5c42194e66baa95a4", {"code_string": "def getResult(endpoint, parameters = None):\n    if parameters:\n        parameter_string = urllib.urlencode(parameters)\n        path = ''.join([endpoint + '?', parameter_string])\n    else:\n        path = endpoint\n    endpoint_result = session.get(urljoin(baseurl, path))\n    if debug: print \">>>\\n\" + json.dumps(endpoint_result.json(), indent = 2) + \"\\n<<<\\n\"\n    return endpoint_result.json()\n", "code_toks_joined": "def getResult ( endpoint , parameters = None ) : <NEWLINE> <INDENT> if parameters : <NEWLINE> <INDENT> parameter_string = urllib . urlencode ( parameters ) <NEWLINE> path = <STRING> . join ( [ endpoint + <STRING> , parameter_string ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> path = endpoint <NEWLINE> <DEDENT> endpoint_result = session . get ( urljoin ( baseurl , path ) ) <NEWLINE> if debug : print <STRING> + json . dumps ( endpoint_result . json ( ) , indent = 2 ) + <STRING> <NEWLINE> return endpoint_result . json ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "'?'", "\">>>\\n\"", "\"\\n<<<\\n\""]}, "err_obj": {"msg": "invalid syntax"}}], ["749b391a5f2ea8c7216662e75b8c0912", {"code_string": "def djpoi(bot, trigger):\n    x = requests.get(\"http: //api.dubtrack.fm/room/58fa285f78c3bfb500a1dff2\").json()\n    if not x['data']['currentSong']:\n        bot.say(\"join at https: //www.dubtrack.fm/join/spzo\")\n    else:\n        bot.say(\"Current song: {0}| https: //www.dubtrack.fm/join/spzo\".format(x['data']['currentSong']['name'], x['data']['activeUsers'])\n", "code_toks_joined": "def djpoi ( bot , trigger ) : <NEWLINE> <INDENT> x = requests . get ( <STRING> ) . json ( ) <NEWLINE> if not x [ <STRING> ] [ <STRING> ] : <NEWLINE> <INDENT> bot . say ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bot . say ( <STRING> . format ( x [ <STRING> ] [ <STRING> ] [ <STRING> ] , x [ <STRING> ] [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"http: //api.dubtrack.fm/room/58fa285f78c3bfb500a1dff2\"", "'data'", "'currentSong'", "\"join at https: //www.dubtrack.fm/join/spzo\"", "\"Current song: {0}| https: //www.dubtrack.fm/join/spzo\"", "'data'", "'currentSong'", "'name'", "'data'", "'activeUsers'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["dec625fe5a3e06d33aa4a2f890b6e711", {"code_string": "def __init__(self):\n    settings = dict(\n        blog_title = u\"CC98 Forum\",\n        template_path = os.path.join(os.path.dirname(__file__), \"templates\"),\n        static_path = os.path.join(os.path.dirname(__file__), \"static\"),\n        xsrf_cookies = True,\n        cookie_secret = \"xxxxxxxxxxxxx\",\n        login_url = \"/login\",\n        autoescape = None,\n        jinja2 = Environment(loader = FileSystemLoader(os.path.join(os.path.dirname(__file__), \"templates\")), trim_blocks = True),\n    )\n    handlers = [\n        (r\"/\", handler.topic.IndexHandler),\n            (r\"/login\", handler.user.LogoutHandler),\n            (r\"/logout\", handler.user.LogoutHandler),\n            (r\"/forgot\", handler.user.ForgotPasswordHandler),\n            (r\"/register\", handler.user.RegisterHandler),\n            (r\"/setting/avatar\", handler.user.SettingAvatarHandler),\n            (r\"/setting/gravatar\", handler.user.SettingAvatarFromGravatarHandler),\n            (r\"/setting/password\", handler.user.SettingPasswordHandler),\n            (r\"/vote\", handler.topic.VoteHandler),\n            (r\"/favorites\", handler.topic.FavoriteHandler),\n            (r\"/unfavorites\", handler.topic.CancelFavoriteHandler),\n            (r\"/topic/(\\d+)\", handler.topic.ViewHandler),\n            (r\"/topic/create\", handler.topic.CreateHandler),\n            (r\"/topic/edit\", handler.topic.EditHandler),\n            (r\"/reply/edit/(.*)\", handler.topic.ReplyEditHandler),\n            (r\"/node/(.*)\", handler.topic.NodeTopicHandler),\n            (r\"/user/(.*)\", handler.user.ProfileHandler),\n            (r\"/user/(.*)/topics\", handler.user.UserTopicsHandler),\n            (r\"/user/(.*)/replies\", handler.user.UserRepliesHandler),\n            (r\"/user/(.*)/favorites\", handler.user.UserFavoritesHandler),\n            (r\"/members\", handler.user.MembersHandler),\n            (r\"/notifications\", handler.notification.ListHandler),\n    ]\n    tornado.web.Application.__init__(self, handlers, settings)\n    self.db = torndb.Connection(\n    )\n    self.mc = memcache.Client([\"127.0.0.1:11211\"]])\n", "code_toks_joined": "def __init__ ( self ) : <NEWLINE> <INDENT> settings = dict ( <NEWLINE> <INDENT> blog_title = <STRING> , <NEWLINE> template_path = os . path . join ( os . path . dirname ( __file__ ) , <STRING> ) , <NEWLINE> static_path = os . path . join ( os . path . dirname ( __file__ ) , <STRING> ) , <NEWLINE> xsrf_cookies = True , <NEWLINE> cookie_secret = <STRING> , <NEWLINE> login_url = <STRING> , <NEWLINE> autoescape = None , <NEWLINE> jinja2 = Environment ( loader = FileSystemLoader ( os . path . join ( os . path . dirname ( __file__ ) , <STRING> ) ) , trim_blocks = True ) , <NEWLINE> <DEDENT> ) <NEWLINE> handlers = [ <NEWLINE> <INDENT> ( <STRING> , handler . topic . IndexHandler ) , <NEWLINE> <INDENT> ( <STRING> , handler . user . LogoutHandler ) , <NEWLINE> ( <STRING> , handler . user . LogoutHandler ) , <NEWLINE> ( <STRING> , handler . user . ForgotPasswordHandler ) , <NEWLINE> ( <STRING> , handler . user . RegisterHandler ) , <NEWLINE> ( <STRING> , handler . user . SettingAvatarHandler ) , <NEWLINE> ( <STRING> , handler . user . SettingAvatarFromGravatarHandler ) , <NEWLINE> ( <STRING> , handler . user . SettingPasswordHandler ) , <NEWLINE> ( <STRING> , handler . topic . VoteHandler ) , <NEWLINE> ( <STRING> , handler . topic . FavoriteHandler ) , <NEWLINE> ( <STRING> , handler . topic . CancelFavoriteHandler ) , <NEWLINE> ( <STRING> , handler . topic . ViewHandler ) , <NEWLINE> ( <STRING> , handler . topic . CreateHandler ) , <NEWLINE> ( <STRING> , handler . topic . EditHandler ) , <NEWLINE> ( <STRING> , handler . topic . ReplyEditHandler ) , <NEWLINE> ( <STRING> , handler . topic . NodeTopicHandler ) , <NEWLINE> ( <STRING> , handler . user . ProfileHandler ) , <NEWLINE> ( <STRING> , handler . user . UserTopicsHandler ) , <NEWLINE> ( <STRING> , handler . user . UserRepliesHandler ) , <NEWLINE> ( <STRING> , handler . user . UserFavoritesHandler ) , <NEWLINE> ( <STRING> , handler . user . MembersHandler ) , <NEWLINE> ( <STRING> , handler . notification . ListHandler ) , <NEWLINE> <DEDENT> <DEDENT> ] <NEWLINE> tornado . web . Application . __init__ ( self , handlers , settings ) <NEWLINE> self . db = torndb . Connection ( <NEWLINE> ) <NEWLINE> self . mc = memcache . Client ( [ <STRING> ] ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["u\"CC98 Forum\"", "\"templates\"", "\"static\"", "\"xxxxxxxxxxxxx\"", "\"/login\"", "\"templates\"", "r\"/\"", "r\"/login\"", "r\"/logout\"", "r\"/forgot\"", "r\"/register\"", "r\"/setting/avatar\"", "r\"/setting/gravatar\"", "r\"/setting/password\"", "r\"/vote\"", "r\"/favorites\"", "r\"/unfavorites\"", "r\"/topic/(\\d+)\"", "r\"/topic/create\"", "r\"/topic/edit\"", "r\"/reply/edit/(.*)\"", "r\"/node/(.*)\"", "r\"/user/(.*)\"", "r\"/user/(.*)/topics\"", "r\"/user/(.*)/replies\"", "r\"/user/(.*)/favorites\"", "r\"/members\"", "r\"/notifications\"", "\"127.0.0.1:11211\""]}, "window_span": [395, 409], "err_obj": {"msg": "unbalanced (){}[]"}}], ["2f90f8178be879893f3f3d625137f5be", {"code_string": "def makeDraggable(self, draggable):\n    if draggable instanceof HasDragHandle:\n        makeDraggable(draggable, ((HasDragHandle) draggable).getDragHandle())\n        else:\n        makeDraggable(draggable, draggable)\n", "code_toks_joined": "def makeDraggable ( self , draggable ) : <NEWLINE> <INDENT> if draggable instanceof HasDragHandle : <NEWLINE> <INDENT> makeDraggable ( draggable , ( ( HasDragHandle ) draggable ) . getDragHandle ( ) ) <NEWLINE> else : <NEWLINE> makeDraggable ( draggable , draggable ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["49e5dfb796b965967733f43a08b8af31", {"code_string": "def validar(request):\n    if request.method == 'POST':\n        form = PessoaForm(request.POST)\n        if form.is_valid():\n            form.save()\n            pessoas = Pessoa.objects.all().order_by('nome')\n            return render(request, 'validar.html', {'form': form, 'pessoas': pessoas})\n        else:\n        return render(request, 'index.html', {'form': form})\n", "code_toks_joined": "def validar ( request ) : <NEWLINE> <INDENT> if request . method == <STRING> : <NEWLINE> <INDENT> form = PessoaForm ( request . POST ) <NEWLINE> if form . is_valid ( ) : <NEWLINE> <INDENT> form . save ( ) <NEWLINE> pessoas = Pessoa . objects . all ( ) . order_by ( <STRING> ) <NEWLINE> return render ( request , <STRING> , { <STRING> : form , <STRING> : pessoas } ) <NEWLINE> <DEDENT> else : <NEWLINE> return render ( request , <STRING> , { <STRING> : form } ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'POST'", "'nome'", "'validar.html'", "'form'", "'pessoas'", "'index.html'", "'form'"]}, "err_obj": {"msg": "expected an indented block"}}], ["f8b3f133dab0ed9ce2bde55bb53bd1fa", {"code_string": "def agenda(request):\n    entry_list = Entry.objects.filter(publish = True).order_by('start')\n    context = {\n        \"entries\" entry_list\n    }\n    return render(request, \"agenda.html\", context)\n", "code_toks_joined": "def agenda ( request ) : <NEWLINE> <INDENT> entry_list = Entry . objects . filter ( publish = True ) . order_by ( <STRING> ) <NEWLINE> context = { <NEWLINE> <INDENT> <STRING> entry_list <NEWLINE> <DEDENT> } <NEWLINE> return render ( request , <STRING> , context ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'start'", "\"entries\"", "\"agenda.html\""]}, "err_obj": {"msg": "invalid syntax"}}], ["4628a2ae41db7b427f502432437276f3", {"code_string": "def _remove(self, f):\n    try:\n        import send2trash\n        logging.info(\"send 2 trash: {0}\".format(f)))\n        send2trash.send2trash(f)\n    except ImportError:\n        import os\n        logging.warn(\"REMOVE file: {0}\".format(f))\n        os.remove(f)\n", "code_toks_joined": "def _remove ( self , f ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> import send2trash <NEWLINE> logging . info ( <STRING> . format ( f ) ) ) <NEWLINE> send2trash . send2trash ( f ) <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> import os <NEWLINE> logging . warn ( <STRING> . format ( f ) ) <NEWLINE> os . remove ( f ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"send 2 trash: {0}\"", "\"REMOVE file: {0}\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e9fe68bb21bc5cd600746bcef44aad37", {"code_string": "def read(self):\n    try:\n        (data, address) = self.socket.recvfrom(65535)\n    except socket.error, e:\n        try:\n            self.socket.close()\n        except socket.error:\n            pass\n        self.feedback.closed(e.args[0])\n        return False\n    else:\n        if len(data) == 0:\n            self.feedback.closed()\n            return False\n        self.feedback.registerIncomingData(data)\n    return True\n", "code_toks_joined": "def read ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ( data , address ) = self . socket . recvfrom ( 65535 ) <NEWLINE> <DEDENT> except socket . error , e : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . socket . close ( ) <NEWLINE> <DEDENT> except socket . error : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> self . feedback . closed ( e . args [ 0 ] ) <NEWLINE> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( data ) == 0 : <NEWLINE> <INDENT> self . feedback . closed ( ) <NEWLINE> return False <NEWLINE> <DEDENT> self . feedback . registerIncomingData ( data ) <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["b2b8e62114086ab47ba3fe781697950d", {"code_string": "\"\"\"Created on Sat May 28 19:17:42 2016\"\"\"\nN, M = raw_input().split()\nN, M = int(N), int(M)\nwhile(1):\ni0 = 0\nwhile(i0 < 2 **(M * N)):\n    bit = [0] * M * N\n    t_bit = bin(i0)\n    lt_bit = len(t_bit)\n    for j0 in range(lt_bit - 2):\n        bit[j0] = int(t_bit[j0 + 2])\n    i0 += 1\n    print(bit)\n\"\"\"N,M = raw_input().split()\"\"\"\n", "code_toks_joined": "<STRING> <NEWLINE> N , M = raw_input ( ) . split ( ) <NEWLINE> N , M = int ( N ) , int ( M ) <NEWLINE> while ( 1 ) : <NEWLINE> i0 = 0 <NEWLINE> while ( i0 < 2 ** ( M * N ) ) : <NEWLINE> <INDENT> bit = [ 0 ] * M * N <NEWLINE> t_bit = bin ( i0 ) <NEWLINE> lt_bit = len ( t_bit ) <NEWLINE> for j0 in range ( lt_bit - 2 ) : <NEWLINE> <INDENT> bit [ j0 ] = int ( t_bit [ j0 + 2 ] ) <NEWLINE> <DEDENT> i0 += 1 <NEWLINE> print ( bit ) <NEWLINE> <DEDENT> <STRING> <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"\"\"Created on Sat May 28 19:17:42 2016\"\"\"", "\"\"\"N,M = raw_input().split()\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["c97eb0cf7a6917c00d57dbcc76492eaf", {"code_string": "def set_page_size(self, (width, height)):\n    self.page_width = width\n    self.page_height = height\n", "code_toks_joined": "def set_page_size ( self , ( width , height ) ) : <NEWLINE> <INDENT> self . page_width = width <NEWLINE> self . page_height = height <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["9d27d6578e3e7a2cea89ea14b655e3fb", {"code_string": "def test_execute_no_jobexit_stat(self):\n    orchestrator = mock.Mock()\n    command = post_exec.LsfPostExecCommand(orchestrator = orchestrator)\n    parsed_arguments = mock.Mock()\n    exit_process = mock.Mock()\n    exit_process.side_effect = RuntimeError\n    with mock.patch(\n        'flow.shell_command.lsf.commands.post_exec.exit_process',\n        new = exit_process):\n        with self.assertRaises(RuntimeError):\n        command._execute(parsed_arguments)\n    self.assertFalse(orchestrator.create_token.called)\n    exit_process.assert_called_once_with(exit_codes.EXECUTE_ERROR)\n", "code_toks_joined": "def test_execute_no_jobexit_stat ( self ) : <NEWLINE> <INDENT> orchestrator = mock . Mock ( ) <NEWLINE> command = post_exec . LsfPostExecCommand ( orchestrator = orchestrator ) <NEWLINE> parsed_arguments = mock . Mock ( ) <NEWLINE> exit_process = mock . Mock ( ) <NEWLINE> exit_process . side_effect = RuntimeError <NEWLINE> with mock . patch ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> new = exit_process ) : <NEWLINE> with self . assertRaises ( RuntimeError ) : <NEWLINE> command . _execute ( parsed_arguments ) <NEWLINE> <DEDENT> self . assertFalse ( orchestrator . create_token . called ) <NEWLINE> exit_process . assert_called_once_with ( exit_codes . EXECUTE_ERROR ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'flow.shell_command.lsf.commands.post_exec.exit_process'"]}, "err_obj": {"msg": "expected an indented block"}}], ["26a8e5c6566b0981e7a111d49a2bd6de", {"code_string": "def Espera(self):\n    while not self.terminar:\n    time.sleep(1)\n", "code_toks_joined": "def Espera ( self ) : <NEWLINE> <INDENT> while not self . terminar : <NEWLINE> time . sleep ( 1 ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["27a90b032fc99c2718aa521a95bea727", {"code_string": "def main():\n    module = AnsibleModule(\n        argument_spec = dict(\n            domain = dict(),\n            default_root = dict(),\n            plugins = dict(),\n            cert_key_size = dict()\n            valid_min = dict(),\n            reuse_key = dict(),\n            account_key_public_exponent = dict()\n            account_key_size = dict(),\n            tos_SHA256 = dict(),\n            email = dict(),\n            user_agent = dict(),\n            server = dict(),\n            revoke = dict()\n        )\n        )\n", "code_toks_joined": "def main ( ) : <NEWLINE> <INDENT> module = AnsibleModule ( <NEWLINE> <INDENT> argument_spec = dict ( <NEWLINE> <INDENT> domain = dict ( ) , <NEWLINE> default_root = dict ( ) , <NEWLINE> plugins = dict ( ) , <NEWLINE> cert_key_size = dict ( ) <NEWLINE> valid_min = dict ( ) , <NEWLINE> reuse_key = dict ( ) , <NEWLINE> account_key_public_exponent = dict ( ) <NEWLINE> account_key_size = dict ( ) , <NEWLINE> tos_SHA256 = dict ( ) , <NEWLINE> email = dict ( ) , <NEWLINE> user_agent = dict ( ) , <NEWLINE> server = dict ( ) , <NEWLINE> revoke = dict ( ) <NEWLINE> <DEDENT> ) <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["69a6dc7b79ab928943a26b21854a251f", {"code_string": "def testlibbind_ns_msg_count(self):\n    \"\"\"Test whether ns_msg_count correctly returns the section counts\"\"\"\n    for message in self.queries + self.responses:\n        msg = libbind.ns_msg(message['data'])\n        for section in self.sections:\n        sectionVal = getattr(libbind, section)\n        self.assertEquals(libbind.ns_msg_count(msg, sectionVal), message['sections'][section])\n", "code_toks_joined": "def testlibbind_ns_msg_count ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for message in self . queries + self . responses : <NEWLINE> <INDENT> msg = libbind . ns_msg ( message [ <STRING> ] ) <NEWLINE> for section in self . sections : <NEWLINE> sectionVal = getattr ( libbind , section ) <NEWLINE> self . assertEquals ( libbind . ns_msg_count ( msg , sectionVal ) , message [ <STRING> ] [ section ] ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Test whether ns_msg_count correctly returns the section counts\"\"\"", "'data'", "'sections'"]}, "err_obj": {"msg": "expected an indented block"}}], ["265ccd0fd5bacc81c7f081dec20ea163", {"code_string": "def test_lc_numeric_localeconv(self):\n    tested = False\n    for loc in candidate_locales:\n        try:\n            setlocale(LC_NUMERIC, loc)\n            setlocale(LC_CTYPE, loc)\n        except Error:\n            continue\n        formatting = localeconv()\n        for lc in(\"decimal_point\",\n            \"thousands_sep\"):\n            if self.numeric_tester('localeconv', formatting[lc], lc, loc):\n            tested = True\n    if not tested:\n        self.skipTest('no suitable locales')\n", "code_toks_joined": "def test_lc_numeric_localeconv ( self ) : <NEWLINE> <INDENT> tested = False <NEWLINE> for loc in candidate_locales : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> setlocale ( LC_NUMERIC , loc ) <NEWLINE> setlocale ( LC_CTYPE , loc ) <NEWLINE> <DEDENT> except Error : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> formatting = localeconv ( ) <NEWLINE> for lc in ( <STRING> , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> if self . numeric_tester ( <STRING> , formatting [ lc ] , lc , loc ) : <NEWLINE> tested = True <NEWLINE> <DEDENT> <DEDENT> if not tested : <NEWLINE> <INDENT> self . skipTest ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"decimal_point\"", "\"thousands_sep\"", "'localeconv'", "'no suitable locales'"]}, "err_obj": {"msg": "expected an indented block"}}], ["5789c9c30af95e3ce199e5cad2739082", {"code_string": "def AddSourceToRegistry(appName, msgDLL = None, eventLogType = \"Application\", eventLogFlags = None):\n    \"\"\"Add a source of messages to the event log.\"\"\"\n    if msgDLL is None:\n        msgDLL = win32evtlog.__file__\n    hkey = win32api.RegCreateKey(win32con.HKEY_LOCAL_MACHINE, \"SYSTEM\\\\CurrentControlSet\\\\Services\\\\EventLog\\\\%s\\\\%s\" %(eventLogType, appName))\n    win32api.RegSetValueEx(hkey,\n        \"EventMessageFile\",\n    if eventLogFlags is None:\n        eventLogFlags = win32evtlog.EVENTLOG_ERROR_TYPE | win32evtlog.EVENTLOG_WARNING_TYPE | win32evtlog.EVENTLOG_INFORMATION_TYPE\n    win32api.RegSetValueEx(hkey,\n    win32api.RegCloseKey(hkey)\n", "code_toks_joined": "def AddSourceToRegistry ( appName , msgDLL = None , eventLogType = <STRING> , eventLogFlags = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if msgDLL is None : <NEWLINE> <INDENT> msgDLL = win32evtlog . __file__ <NEWLINE> <DEDENT> hkey = win32api . RegCreateKey ( win32con . HKEY_LOCAL_MACHINE , <STRING> % ( eventLogType , appName ) ) <NEWLINE> win32api . RegSetValueEx ( hkey , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <DEDENT> if eventLogFlags is None : <NEWLINE> <INDENT> eventLogFlags = win32evtlog . EVENTLOG_ERROR_TYPE | win32evtlog . EVENTLOG_WARNING_TYPE | win32evtlog . EVENTLOG_INFORMATION_TYPE <NEWLINE> <DEDENT> win32api . RegSetValueEx ( hkey , <NEWLINE> win32api . RegCloseKey ( hkey ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Application\"", "\"\"\"Add a source of messages to the event log.\"\"\"", "\"SYSTEM\\\\CurrentControlSet\\\\Services\\\\EventLog\\\\%s\\\\%s\"", "\"EventMessageFile\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["623f8bb688672f2700eba09227622e9c", {"code_string": "def setupUi(self, MainWindow):\n    MainWindow.setObjectName(_fromUtf8(\"MainWindow\"))\n    MainWindow.resize(561, 423)\n    MainWindow.setStyleSheet(_fromUtf8(\"\"))\n    self.centralwidget = QtGui.QWidget(MainWindow)\n    self.centralwidget.setObjectName(_fromUtf8(\"centralwidget\"))\n    self.verticalLayout_2 = QtGui.QVBoxLayout(self.centralwidget)\n    self.verticalLayout_2.setObjectName(_fromUtf8(\"verticalLayout_2\"))\n    self.verticalLayout = QtGui.QVBoxLayout()\n    self.verticalLayout.setObjectName(_fromUtf8(\"verticalLayout\"))\n    self.horizontalLayout = QtGui.QHBoxLayout()\n    self.horizontalLayout.setObjectName(_fromUtf8(\"horizontalLayout\"))\n    spacerItem = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)\n    self.horizontalLayout.addItem(spacerItem)\n    self.label = QtGui.QLabel(self.centralwidget)\n    self.label.setText(_fromUtf8(\"\"))\n    self.label.setPixmap(QtGui.QPixmap(_fromUtf8(\":/logo.png\")))\n    self.label.setObjectName(_fromUtf8(\"label\"))\n    self.horizontalLayout.addWidget(self.label)\n    spacerItem1 = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)\n    self.horizontalLayout.addItem(spacerItem1)\n    self.verticalLayout.addLayout(self.horizontalLayout)\n    self.tabWidget = QtGui.QTabWidget(self.centralwidget)\n    self.tabWidget.setStyleSheet(_fromUtf8(\"QTabWidget::pane { /* The tab widget frame */\\n\"\n", "code_toks_joined": "def setupUi ( self , MainWindow ) : <NEWLINE> <INDENT> MainWindow . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> MainWindow . resize ( 561 , 423 ) <NEWLINE> MainWindow . setStyleSheet ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . centralwidget = QtGui . QWidget ( MainWindow ) <NEWLINE> self . centralwidget . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . verticalLayout_2 = QtGui . QVBoxLayout ( self . centralwidget ) <NEWLINE> self . verticalLayout_2 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . verticalLayout = QtGui . QVBoxLayout ( ) <NEWLINE> self . verticalLayout . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . horizontalLayout = QtGui . QHBoxLayout ( ) <NEWLINE> self . horizontalLayout . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> spacerItem = QtGui . QSpacerItem ( 40 , 20 , QtGui . QSizePolicy . Expanding , QtGui . QSizePolicy . Minimum ) <NEWLINE> self . horizontalLayout . addItem ( spacerItem ) <NEWLINE> self . label = QtGui . QLabel ( self . centralwidget ) <NEWLINE> self . label . setText ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label . setPixmap ( QtGui . QPixmap ( _fromUtf8 ( <STRING> ) ) ) <NEWLINE> self . label . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . horizontalLayout . addWidget ( self . label ) <NEWLINE> spacerItem1 = QtGui . QSpacerItem ( 40 , 20 , QtGui . QSizePolicy . Expanding , QtGui . QSizePolicy . Minimum ) <NEWLINE> self . horizontalLayout . addItem ( spacerItem1 ) <NEWLINE> self . verticalLayout . addLayout ( self . horizontalLayout ) <NEWLINE> self . tabWidget = QtGui . QTabWidget ( self . centralwidget ) <NEWLINE> self . tabWidget . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"MainWindow\"", "\"\"", "\"centralwidget\"", "\"verticalLayout_2\"", "\"verticalLayout\"", "\"horizontalLayout\"", "\"\"", "\":/logo.png\"", "\"label\"", "\"QTabWidget::pane { /* The tab widget frame */\\n\""]}, "window_span": [289, 295], "err_obj": {"msg": "unbalanced (){}[]"}}], ["d0d143427a7f0b610640511532e6af63", {"code_string": "def correlation(X, Y, condition = None, ** kwargs):\n    \"\"\"Correlation of two random expressions, also known as correlation\"\"\"\n    return covariance(X, Y, condition, ** kwargs) /(std(X, condition, ** kwargs)\n        * std(Y, condition, ** kwargs)\n", "code_toks_joined": "def correlation ( X , Y , condition = None , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return covariance ( X , Y , condition , ** kwargs ) / ( std ( X , condition , ** kwargs ) <NEWLINE> <INDENT> * std ( Y , condition , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Correlation of two random expressions, also known as correlation\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["030e1941516af6969c1de9207428a93d", {"code_string": "def _is_secure(self, request):\n    if request.is_secure():\n    return True\n    if 'HTTP_X_FORWARDED_SSL' in request.META:\n        return request.META['HTTP_X_FORWARDED_SSL'] == 'on'\n    return False\n", "code_toks_joined": "def _is_secure ( self , request ) : <NEWLINE> <INDENT> if request . is_secure ( ) : <NEWLINE> return True <NEWLINE> if <STRING> in request . META : <NEWLINE> <INDENT> return request . META [ <STRING> ] == <STRING> <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'HTTP_X_FORWARDED_SSL'", "'HTTP_X_FORWARDED_SSL'", "'on'"]}, "err_obj": {"msg": "expected an indented block"}}], ["83f64cc4b031065b9f99f926553e6f22", {"code_string": "def _process_associate_metering_label(self, router):\n    self._update_router(router)\n    rm = self.routers.get(router['id'])\n    ext_dev, ext_snat_dev = self.get_external_device_names(rm)\n    for(im, dev) in[(rm.iptables_manager, ext_dev),\n        (rm.snat_iptables_manager, ext_snat_dev)]:\n        if im:\n        self._process_ns_specific_metering_label(router, dev, im)\n", "code_toks_joined": "def _process_associate_metering_label ( self , router ) : <NEWLINE> <INDENT> self . _update_router ( router ) <NEWLINE> rm = self . routers . get ( router [ <STRING> ] ) <NEWLINE> ext_dev , ext_snat_dev = self . get_external_device_names ( rm ) <NEWLINE> for ( im , dev ) in [ ( rm . iptables_manager , ext_dev ) , <NEWLINE> <INDENT> ( rm . snat_iptables_manager , ext_snat_dev ) ] : <NEWLINE> if im : <NEWLINE> self . _process_ns_specific_metering_label ( router , dev , im ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'id'"]}, "err_obj": {"msg": "expected an indented block"}}], ["5c598aaee5a86128ecb3eba4a5eefb81", {"code_string": "def local_ultra_fast_sigmoid(node):\n    \"\"\"When enabled, change all sigmoid to ultra_fast_sigmoid.\"\"\"\n    if(isinstance(node.op, tensor.Elemwise) and\n        node.op.scalar_op == scalar_sigmoid):\n        out = ultra_fast_sigmoid(node.inputs[0])\n        def values_eq_approx_remove_low_prec(a, b):\n        return tensor.TensorType.values_eq_approx(a, b, atol = 0.02)\n        out.values_eq_approx = values_eq_approx_remove_low_prec\n        return[out]\n", "code_toks_joined": "def local_ultra_fast_sigmoid ( node ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( isinstance ( node . op , tensor . Elemwise ) and <NEWLINE> <INDENT> node . op . scalar_op == scalar_sigmoid ) : <NEWLINE> out = ultra_fast_sigmoid ( node . inputs [ 0 ] ) <NEWLINE> def values_eq_approx_remove_low_prec ( a , b ) : <NEWLINE> return tensor . TensorType . values_eq_approx ( a , b , atol = 0.02 ) <NEWLINE> out . values_eq_approx = values_eq_approx_remove_low_prec <NEWLINE> return [ out ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"When enabled, change all sigmoid to ultra_fast_sigmoid.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["f2a69ab2f5d2da90d0249133768c39d0", {"code_string": "def draw_arrow(ax, t, r):\n    ax.annotate('', xy = (0.5, 0.5 + r), xytext = (0.5, 0.5), size = 30,\n        arrowprops = dict(arrowstyle = t,\n            fc = \"b\", ec = 'k')\n", "code_toks_joined": "def draw_arrow ( ax , t , r ) : <NEWLINE> <INDENT> ax . annotate ( <STRING> , xy = ( 0.5 , 0.5 + r ) , xytext = ( 0.5 , 0.5 ) , size = 30 , <NEWLINE> <INDENT> arrowprops = dict ( arrowstyle = t , <NEWLINE> <INDENT> fc = <STRING> , ec = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "\"b\"", "'k'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c10bbe3f1a24493ca06beaba1da99f35", {"code_string": "def next(self):\n    '''Read until comes across stop_sign or end of data.'''\n    row = []\n    while self.stop_sign not in self.buffer:\n        bulk = self.read_bulk()\n        if bulk == '':\n            raise StopIteration\n        self.buffer += bulk\n    left = ''\n    while left != self.stop_sign:\n        left = self.buffer.popleft()\n        row.append(left)\n    return(''.join(row)\n", "code_toks_joined": "def next ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> row = [ ] <NEWLINE> while self . stop_sign not in self . buffer : <NEWLINE> <INDENT> bulk = self . read_bulk ( ) <NEWLINE> if bulk == <STRING> : <NEWLINE> <INDENT> raise StopIteration <NEWLINE> <DEDENT> self . buffer += bulk <NEWLINE> <DEDENT> left = <STRING> <NEWLINE> while left != self . stop_sign : <NEWLINE> <INDENT> left = self . buffer . popleft ( ) <NEWLINE> row . append ( left ) <NEWLINE> <DEDENT> return ( <STRING> . join ( row ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Read until comes across stop_sign or end of data.'''", "''", "''", "''"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["bd9afc5f78bdf420755b75eae836c04a", {"code_string": "def _buildMpxNamesToApiEnumNames(dummyClasses = None, dummyNodes = None):\n    import pymel.api as api\n    mpxNamesToEnumNames = {}\n    with _DummyPluginNodesMaker(dummyClasses = dummyClasses,\n        alreadyCreated = dummyNodes) as nodeMaker:\n        for mpxCls, mayaNode in nodeMaker.nodes.iteritems():\n        mobj = api.toMObject(mayaNode)\n        mpxNamesToEnumNames[mpxCls.__name__] = mobj.apiTypeStr()\n    return mpxNamesToEnumNames\n", "code_toks_joined": "def _buildMpxNamesToApiEnumNames ( dummyClasses = None , dummyNodes = None ) : <NEWLINE> <INDENT> import pymel . api as api <NEWLINE> mpxNamesToEnumNames = { } <NEWLINE> with _DummyPluginNodesMaker ( dummyClasses = dummyClasses , <NEWLINE> <INDENT> alreadyCreated = dummyNodes ) as nodeMaker : <NEWLINE> for mpxCls , mayaNode in nodeMaker . nodes . iteritems ( ) : <NEWLINE> mobj = api . toMObject ( mayaNode ) <NEWLINE> mpxNamesToEnumNames [ mpxCls . __name__ ] = mobj . apiTypeStr ( ) <NEWLINE> <DEDENT> return mpxNamesToEnumNames <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["e1a34297340b93a6efb4e59fccfb501d", {"code_string": "def test_render_nothing_batch(self):\n    context = MigrationContext.configure(\n        connection = self.bind.connect(),\n        opts = {\n            'compare_type': True,\n            'compare_server_default': True,\n            'target_metadata': self.m1,\n            'upgrade_token': \"upgrades\",\n            'downgrade_token': \"downgrades\",\n            'alembic_module_prefix': 'op.',\n            'sqlalchemy_module_prefix': 'sa.',\n            'render_as_batch': True,\n            'include_symbol': lambda name, schema: False\n        }\n    )\n    template_args = {}\n    autogenerate._render_migration_diffs(\n        context, template_args, set(),\n    )\n    eq_(re.sub(r\"u'\", \"'\", template_args['upgrades']),\n        \"\"\"### commands auto generated by Alembic - please adjust! ###\"\"\"\n", "code_toks_joined": "def test_render_nothing_batch ( self ) : <NEWLINE> <INDENT> context = MigrationContext . configure ( <NEWLINE> <INDENT> connection = self . bind . connect ( ) , <NEWLINE> opts = { <NEWLINE> <INDENT> <STRING> : True , <NEWLINE> <STRING> : True , <NEWLINE> <STRING> : self . m1 , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : True , <NEWLINE> <STRING> : lambda name , schema : False <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> ) <NEWLINE> template_args = { } <NEWLINE> autogenerate . _render_migration_diffs ( <NEWLINE> <INDENT> context , template_args , set ( ) , <NEWLINE> <DEDENT> ) <NEWLINE> eq_ ( re . sub ( <STRING> , <STRING> , template_args [ <STRING> ] ) , <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'compare_type'", "'compare_server_default'", "'target_metadata'", "'upgrade_token'", "\"upgrades\"", "'downgrade_token'", "\"downgrades\"", "'alembic_module_prefix'", "'op.'", "'sqlalchemy_module_prefix'", "'sa.'", "'render_as_batch'", "'include_symbol'", "r\"u'\"", "\"'\"", "'upgrades'", "\"\"\"### commands auto generated by Alembic - please adjust! ###\"\"\""]}, "window_span": [113, 134], "err_obj": {"msg": "unbalanced (){}[]"}}], ["27cefbf731a38ad81c55cffad136e2bc", {"code_string": "def run_server():\n    app_logged = TransLogger(app)\n    cherrypy.tree.graft(app_logged, '/')\n    cherrypy.config.update({\n        'engine.autoreload_on': True,\n        'log.screen': True\n        'server.socket_port': PORT,\n        'server.socket_host': '0.0.0.0'\n    })\n    cherrypy.engine.start()\n    cherrypy.engine.block()\n", "code_toks_joined": "def run_server ( ) : <NEWLINE> <INDENT> app_logged = TransLogger ( app ) <NEWLINE> cherrypy . tree . graft ( app_logged , <STRING> ) <NEWLINE> cherrypy . config . update ( { <NEWLINE> <INDENT> <STRING> : True , <NEWLINE> <STRING> : True <NEWLINE> <STRING> : PORT , <NEWLINE> <STRING> : <STRING> <NEWLINE> <DEDENT> } ) <NEWLINE> cherrypy . engine . start ( ) <NEWLINE> cherrypy . engine . block ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'/'", "'engine.autoreload_on'", "'log.screen'", "'server.socket_port'", "'server.socket_host'", "'0.0.0.0'"]}, "err_obj": {"msg": "invalid syntax"}}], ["f0277e858a2acb35476938d879a2e192", {"code_string": "def on_touch_down(self, touch):\n    ret = super(Inspector, self).on_touch_down(touch)\n    if(('button' not in touch.profile or touch.button == 'left')\n        and not ret and self.inspect_enabled):\n        self.highlight_at(* touch.pos)\n        if touch.is_double_tap:\n        self.inspect_enabled = False\n        self.show_widget_info()\n        ret = True\n    return ret\n", "code_toks_joined": "def on_touch_down ( self , touch ) : <NEWLINE> <INDENT> ret = super ( Inspector , self ) . on_touch_down ( touch ) <NEWLINE> if ( ( <STRING> not in touch . profile or touch . button == <STRING> ) <NEWLINE> <INDENT> and not ret and self . inspect_enabled ) : <NEWLINE> self . highlight_at ( * touch . pos ) <NEWLINE> if touch . is_double_tap : <NEWLINE> self . inspect_enabled = False <NEWLINE> self . show_widget_info ( ) <NEWLINE> ret = True <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'button'", "'left'"]}, "err_obj": {"msg": "expected an indented block"}}], ["5b14f2656e1048ac044fce0fde45560c", {"code_string": "def _find_starts(self, linespec):\n    \"\"\"Finds the start points.\"\"\"\n    linespec += \".*\"\n    start_points = []\n    for item in self._indent_list:\n        match = re.search(linespec, item[1])\n        if match:\n            entry = (item, self._indent_list.index(item)\n            start_points.append(entry)\n    return start_points\n", "code_toks_joined": "def _find_starts ( self , linespec ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> linespec += <STRING> <NEWLINE> start_points = [ ] <NEWLINE> for item in self . _indent_list : <NEWLINE> <INDENT> match = re . search ( linespec , item [ 1 ] ) <NEWLINE> if match : <NEWLINE> <INDENT> entry = ( item , self . _indent_list . index ( item ) <NEWLINE> start_points . append ( entry ) <NEWLINE> <DEDENT> <DEDENT> return start_points <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Finds the start points.\"\"\"", "\".*\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["8226bde85efb0f19150416a2de6ef6af", {"code_string": "class QueueItemSubtitle(ShowQueueItem):\n    def __init__(self, show = None):\n        ShowQueueItem.__init__(self, ShowQueueActions.SUBTITLE, show)\n    def run(self):\n        super(QueueItemSubtitle, self).run()\n        logger.log('Downloading subtitles for{0}'.format(self.show.name)\n        self.show.download_subtitles()\n        super(QueueItemSubtitle, self).finish()\n        self.finish()\n", "code_toks_joined": "class QueueItemSubtitle ( ShowQueueItem ) : <NEWLINE> <INDENT> def __init__ ( self , show = None ) : <NEWLINE> <INDENT> ShowQueueItem . __init__ ( self , ShowQueueActions . SUBTITLE , show ) <NEWLINE> <DEDENT> def run ( self ) : <NEWLINE> <INDENT> super ( QueueItemSubtitle , self ) . run ( ) <NEWLINE> logger . log ( <STRING> . format ( self . show . name ) <NEWLINE> self . show . download_subtitles ( ) <NEWLINE> super ( QueueItemSubtitle , self ) . finish ( ) <NEWLINE> self . finish ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Downloading subtitles for{0}'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["4186df09bb74252fddc400cdd9e56e6f", {"code_string": "class HolonomicLinkage(Linkage):\n    holonomic = True\n    def __init__(self, part1, part2, position, euler_angles, static_matrix1, static_matrix2,\n        static_behavior_occurence_matrix, static_behavior_nonlinear_eq_indices,\n        static_behavior_linear_eq, static_behavior_nonlinear_eq,\n        kinematic_matrix, static_require_kinematic = False, name = ''):\n        Linkage.__init__(self, part1, part2, position, euler_angles, static_matrix1, static_matrix2,\n            static_behavior_occurence_matrix, static_behavior_nonlinear_eq_indices,\n            static_behavior_linear_eq, static_behavior_nonlinear_eq,\n            static_require_kinematic, name)\n            self.kinematic_matrix = kinematic_matrix\n            self.n_kinematic_unknowns = kinematic_matrix.shape[1]\n", "code_toks_joined": "class HolonomicLinkage ( Linkage ) : <NEWLINE> <INDENT> holonomic = True <NEWLINE> def __init__ ( self , part1 , part2 , position , euler_angles , static_matrix1 , static_matrix2 , <NEWLINE> <INDENT> static_behavior_occurence_matrix , static_behavior_nonlinear_eq_indices , <NEWLINE> static_behavior_linear_eq , static_behavior_nonlinear_eq , <NEWLINE> kinematic_matrix , static_require_kinematic = False , name = <STRING> ) : <NEWLINE> Linkage . __init__ ( self , part1 , part2 , position , euler_angles , static_matrix1 , static_matrix2 , <NEWLINE> <INDENT> static_behavior_occurence_matrix , static_behavior_nonlinear_eq_indices , <NEWLINE> static_behavior_linear_eq , static_behavior_nonlinear_eq , <NEWLINE> static_require_kinematic , name ) <NEWLINE> self . kinematic_matrix = kinematic_matrix <NEWLINE> self . n_kinematic_unknowns = kinematic_matrix . shape [ 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''"]}, "err_obj": {"msg": "unexpected indent"}}], ["9067765a165e26022dda69705bacd12f", {"code_string": "def stopConnecting(self):\n    \"\"\"Stop attempting to connect.\"\"\"\n    if self.state != \"connecting\":\n        raise error.NotConnectingError, \"we're not trying to connect\"\n    self.state = \"disconnected\"\n    self.transport.failIfNotConnected(error.UserError())\n    del self.transport\n", "code_toks_joined": "def stopConnecting ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . state != <STRING> : <NEWLINE> <INDENT> raise error . NotConnectingError , <STRING> <NEWLINE> <DEDENT> self . state = <STRING> <NEWLINE> self . transport . failIfNotConnected ( error . UserError ( ) ) <NEWLINE> del self . transport <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Stop attempting to connect.\"\"\"", "\"connecting\"", "\"we're not trying to connect\"", "\"disconnected\""]}, "err_obj": {"msg": "invalid syntax"}}], ["e305b29e3db8203d8917888caac2521f", {"code_string": "def test_parse_2(self):\n    off_mont = [[[128, 62, 100], 1000]]\n    self.chapter_n.update(off_mont)\n        size, notes_parsed = self.chapter_n.parse(self.chapter_n.content)\n", "code_toks_joined": "def test_parse_2 ( self ) : <NEWLINE> <INDENT> off_mont = [ [ [ 128 , 62 , 100 ] , 1000 ] ] <NEWLINE> self . chapter_n . update ( off_mont ) <NEWLINE> <INDENT> size , notes_parsed = self . chapter_n . parse ( self . chapter_n . content ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["43e62d46e3cae9c7ed0bec2639ed54e0", {"code_string": "from pyspark import SparkContext\nfrom pyspark.mllib.feature import HashingTF, IDF\nsc = SparkContext(appName = \"twitter-stream\")\npath = '/Users/cathyq/code/twitter-streaming/twitter_output'\nrdd = sc.wholeTextFiles(\"data\").map(lambda(name, text): text.split())\ntf = HashingTF()\ntfVectors = tf.transform(rdd).cache()\nidf = IDF()\nIDFModel = idf.fit(tfVectors)\ntfIdfVectors = IDFModel.transform(tfVectors)\ntfIdfVectors.saveAsTextFile(path)\n", "code_toks_joined": "from pyspark import SparkContext <NEWLINE> from pyspark . mllib . feature import HashingTF , IDF <NEWLINE> sc = SparkContext ( appName = <STRING> ) <NEWLINE> path = <STRING> <NEWLINE> rdd = sc . wholeTextFiles ( <STRING> ) . map ( lambda ( name , text ) : text . split ( ) ) <NEWLINE> tf = HashingTF ( ) <NEWLINE> tfVectors = tf . transform ( rdd ) . cache ( ) <NEWLINE> idf = IDF ( ) <NEWLINE> IDFModel = idf . fit ( tfVectors ) <NEWLINE> tfIdfVectors = IDFModel . transform ( tfVectors ) <NEWLINE> tfIdfVectors . saveAsTextFile ( path ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"twitter-stream\"", "'/Users/cathyq/code/twitter-streaming/twitter_output'", "\"data\""]}, "err_obj": {"msg": "invalid syntax"}}], ["0312e176258889e29225be9e49952375", {"code_string": "def __init__(self, numColumns):\n    self.SetColumnCount(numColumns)\n    list = self.GetListCtrl()\n    if not list:\n        raise ValueError, \"No wx.ListCtrl available\"\n    list.Bind(wx.EVT_LIST_COL_CLICK, self.__OnColClick, list)\n", "code_toks_joined": "def __init__ ( self , numColumns ) : <NEWLINE> <INDENT> self . SetColumnCount ( numColumns ) <NEWLINE> list = self . GetListCtrl ( ) <NEWLINE> if not list : <NEWLINE> <INDENT> raise ValueError , <STRING> <NEWLINE> <DEDENT> list . Bind ( wx . EVT_LIST_COL_CLICK , self . __OnColClick , list ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"No wx.ListCtrl available\""]}, "err_obj": {"msg": "invalid syntax"}}], ["dc4b256f479eadd344e783cce709576c", {"code_string": "def interpreter(self):\n    if not self.__check_session():\n        return\n    interp = None\n    for segment in self.elf.iter_segments():\n        if segment['p_type'] == 'PT_INTERP':\n            interp = segment\n            break\n    if interp:\n        self.log('', \"Program interpreter: {0}\".format(interp.get_interp_name())))\n    else:\n        self.log('error', \"No PT_INTERP entry found\")\n", "code_toks_joined": "def interpreter ( self ) : <NEWLINE> <INDENT> if not self . __check_session ( ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> interp = None <NEWLINE> for segment in self . elf . iter_segments ( ) : <NEWLINE> <INDENT> if segment [ <STRING> ] == <STRING> : <NEWLINE> <INDENT> interp = segment <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if interp : <NEWLINE> <INDENT> self . log ( <STRING> , <STRING> . format ( interp . get_interp_name ( ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . log ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'p_type'", "'PT_INTERP'", "''", "\"Program interpreter: {0}\"", "'error'", "\"No PT_INTERP entry found\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["5fb9613e2d5ac0ff72fbf3ecfe190908", {"code_string": "def pairing_done(self, data):\n    if data is not None:\n        self.cfg['pair'] = [data['pairid'], data['name'], data['platform']\n        self.cfg['mode'] = 2\n        self.handler.win.wallet.get_keystore().cfg = self.cfg\n        self.handler.win.wallet.save_keystore()\n    self.pin = 'paired'\n    self.accept()\n", "code_toks_joined": "def pairing_done ( self , data ) : <NEWLINE> <INDENT> if data is not None : <NEWLINE> <INDENT> self . cfg [ <STRING> ] = [ data [ <STRING> ] , data [ <STRING> ] , data [ <STRING> ] <NEWLINE> self . cfg [ <STRING> ] = 2 <NEWLINE> self . handler . win . wallet . get_keystore ( ) . cfg = self . cfg <NEWLINE> self . handler . win . wallet . save_keystore ( ) <NEWLINE> <DEDENT> self . pin = <STRING> <NEWLINE> self . accept ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'pair'", "'pairid'", "'name'", "'platform'", "'mode'", "'paired'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["bbdec40ad9f08feb98abf36b6da16c5d", {"code_string": "def UpdateImage(self, delay, event = None):\n    global dev, status, calImage, calimgI, ImageFinal, label\n        self.iteration += 1\n        self.image = self.get_image(dev)\n    ImageFinal = self.image\n        label.configure(image = ImageFinal, text = \"Frames captured %s\" % self.iteration)\n        self.after(delay, self.UpdateImage, 1)\n", "code_toks_joined": "def UpdateImage ( self , delay , event = None ) : <NEWLINE> <INDENT> global dev , status , calImage , calimgI , ImageFinal , label <NEWLINE> <INDENT> self . iteration += 1 <NEWLINE> self . image = self . get_image ( dev ) <NEWLINE> <DEDENT> ImageFinal = self . image <NEWLINE> <INDENT> label . configure ( image = ImageFinal , text = <STRING> % self . iteration ) <NEWLINE> self . after ( delay , self . UpdateImage , 1 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Frames captured %s\""]}, "err_obj": {"msg": "unexpected indent"}}], ["f24db7fce487648c037505622b5f8393", {"code_string": "class Solution(object):\n    def reverseList(self, head):\n    \"\"\":type head: ListNode\"\"\"\n    back = head\n    curr = None\n    if back:\n        curr = head.next\n        back.next = None\n    while curr:\n        forw = curr.next\n        curr.next = back\n        back = curr\n        curr = forw\n    return back\n", "code_toks_joined": "class Solution ( object ) : <NEWLINE> <INDENT> def reverseList ( self , head ) : <NEWLINE> <STRING> <NEWLINE> back = head <NEWLINE> curr = None <NEWLINE> if back : <NEWLINE> <INDENT> curr = head . next <NEWLINE> back . next = None <NEWLINE> <DEDENT> while curr : <NEWLINE> <INDENT> forw = curr . next <NEWLINE> curr . next = back <NEWLINE> back = curr <NEWLINE> curr = forw <NEWLINE> <DEDENT> return back <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\":type head: ListNode\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["2002cf5f5969c5f7670b23dbe1b372bd", {"code_string": "def __init__(self, * args, ** kw)\n    self.already = False\n    Fuse.__init__(self, * args, ** kw)\n", "code_toks_joined": "def __init__ ( self , * args , ** kw ) <NEWLINE> <INDENT> self . already = False <NEWLINE> Fuse . __init__ ( self , * args , ** kw ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["c4325e3d78566ea720fb2ece17e2c337", {"code_string": "def _create_connection((host, port), connect_timeout):\n    \"\"\"Connect to a 2-tuple (host, port) and return\"\"\"\n    if sys.version_info <(2, 6):\n        (family, _) = _convert_host_to_ip(host)\n        connect_socket = socket.socket(family, socket.SOCK_STREAM)\n        connect_socket.settimeout(connect_timeout)\n        connect_socket.connect((host, port))\n    else:\n        connect_socket = socket.create_connection((host, port), connect_timeout)\n    return connect_socket\n", "code_toks_joined": "def _create_connection ( ( host , port ) , connect_timeout ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if sys . version_info < ( 2 , 6 ) : <NEWLINE> <INDENT> ( family , _ ) = _convert_host_to_ip ( host ) <NEWLINE> connect_socket = socket . socket ( family , socket . SOCK_STREAM ) <NEWLINE> connect_socket . settimeout ( connect_timeout ) <NEWLINE> connect_socket . connect ( ( host , port ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> connect_socket = socket . create_connection ( ( host , port ) , connect_timeout ) <NEWLINE> <DEDENT> return connect_socket <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Connect to a 2-tuple (host, port) and return\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["9199038ec27d505c20d67ebf28d4d7ce", {"code_string": "def test_marvin_function_exception(self):\n    from headjack.archiver import marvin\n    try:\n        this = marvin(\n            log = log,\n            settings = settings,\n            fakeKey = \"break the code\"\n        )\n        this.get()\n        assert False\n    except Exception, e:\n        assert True\n        print(str(e))\n", "code_toks_joined": "def test_marvin_function_exception ( self ) : <NEWLINE> <INDENT> from headjack . archiver import marvin <NEWLINE> try : <NEWLINE> <INDENT> this = marvin ( <NEWLINE> <INDENT> log = log , <NEWLINE> settings = settings , <NEWLINE> fakeKey = <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> this . get ( ) <NEWLINE> assert False <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> assert True <NEWLINE> print ( str ( e ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"break the code\""]}, "err_obj": {"msg": "invalid syntax"}}], ["05d18bb5c39be34df499cf8f4092b319", {"code_string": "def convert(color, converter):\n    if isinstance(color, gtk.gdk.Color):\n        pass\n    elif type(color) == type(0) or type(color) == type(0 l):\n        color = int2gdk(color)\n    elif type(color) == type(''):\n        color = str2gdk(color)\n    else:\n        raise TypeError('%s is not a known color type' % type(color))\n    return converter(color)\n", "code_toks_joined": "def convert ( color , converter ) : <NEWLINE> <INDENT> if isinstance ( color , gtk . gdk . Color ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif type ( color ) == type ( 0 ) or type ( color ) == type ( 0 l ) : <NEWLINE> <INDENT> color = int2gdk ( color ) <NEWLINE> <DEDENT> elif type ( color ) == type ( <STRING> ) : <NEWLINE> <INDENT> color = str2gdk ( color ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise TypeError ( <STRING> % type ( color ) ) <NEWLINE> <DEDENT> return converter ( color ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "'%s is not a known color type'"]}, "err_obj": {"msg": "invalid syntax"}}], ["c78c135aecb202df9f29f483e24cb657", {"code_string": "def __parse_addrs(self):\n    try:\n        self.__src = dotted_to_int(self.src)\n    except ValueError:\n        try:\n        self.__src = dotted_to_int(socket.gethostbyname(self.src))\n        except ValueError:\n        raise ValueError, \"invalid source address\"\n    try:\n        self.__dst = dotted_to_int(self.dst)\n    except ValueError:\n        try:\n        self.__dst = dotted_to_int(socket.gethostbyname(self.dst))\n        except ValueError:\n        raise ValueError, \"invalid source address\"\n", "code_toks_joined": "def __parse_addrs ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . __src = dotted_to_int ( self . src ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> try : <NEWLINE> self . __src = dotted_to_int ( socket . gethostbyname ( self . src ) ) <NEWLINE> except ValueError : <NEWLINE> raise ValueError , <STRING> <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> self . __dst = dotted_to_int ( self . dst ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> try : <NEWLINE> self . __dst = dotted_to_int ( socket . gethostbyname ( self . dst ) ) <NEWLINE> except ValueError : <NEWLINE> raise ValueError , <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"invalid source address\"", "\"invalid source address\""]}, "err_obj": {"msg": "expected an indented block"}}], ["003735ad18525396012f46cab9a2b049", {"code_string": "class Ui_Dialog(object):\n    def setupUi(self, Dialog):\n        Dialog.setObjectName(_fromUtf8(\"Dialog\"))\n        Dialog.resize(936, 610)\n        icon = QtGui.QIcon()\n        icon.addPixmap(QtGui.QPixmap(_fromUtf8(\":/images/lambda.png\")), QtGui.QIcon.Normal, QtGui.QIcon.Off)\n        Dialog.setWindowIcon(icon)\n        Dialog.setStyleSheet(_fromUtf8(\"QToolTip\\n\"\n", "code_toks_joined": "class Ui_Dialog ( object ) : <NEWLINE> <INDENT> def setupUi ( self , Dialog ) : <NEWLINE> <INDENT> Dialog . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> Dialog . resize ( 936 , 610 ) <NEWLINE> icon = QtGui . QIcon ( ) <NEWLINE> icon . addPixmap ( QtGui . QPixmap ( _fromUtf8 ( <STRING> ) ) , QtGui . QIcon . Normal , QtGui . QIcon . Off ) <NEWLINE> Dialog . setWindowIcon ( icon ) <NEWLINE> Dialog . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Dialog\"", "\":/images/lambda.png\"", "\"QToolTip\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["9ff02edb7a1619da0eba59f78afe037b", {"code_string": "def _extend_network_qos_queue(self, context, network):\n    if self._check_view_auth(context, {'qos_queue': None},\n        ext_qos.qos_queue_get):\n        filters = {'network_id': [network['id']]}\n        fields = ['queue_id']\n        network[ext_qos.QUEUE] = None\n        queue_id = self._get_network_queue_bindings(\n        context, filters, fields)\n        if queue_id:\n        network[ext_qos.QUEUE] = queue_id[0]['queue_id']\n    return network\n", "code_toks_joined": "def _extend_network_qos_queue ( self , context , network ) : <NEWLINE> <INDENT> if self . _check_view_auth ( context , { <STRING> : None } , <NEWLINE> <INDENT> ext_qos . qos_queue_get ) : <NEWLINE> filters = { <STRING> : [ network [ <STRING> ] ] } <NEWLINE> fields = [ <STRING> ] <NEWLINE> network [ ext_qos . QUEUE ] = None <NEWLINE> queue_id = self . _get_network_queue_bindings ( <NEWLINE> context , filters , fields ) <NEWLINE> if queue_id : <NEWLINE> network [ ext_qos . QUEUE ] = queue_id [ 0 ] [ <STRING> ] <NEWLINE> <DEDENT> return network <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'qos_queue'", "'network_id'", "'id'", "'queue_id'", "'queue_id'"]}, "err_obj": {"msg": "expected an indented block"}}], ["dceec15a143750b07063403fd1191af7", {"code_string": "def _reselect_row(model, _, iter_, (selection, selected_rows, )):\n    \"\"\"Select rows if they are referenced by selected_rows.\"\"\"\n    if model.get_value(iter_, 0) in selected_rows:\n        selection.select_iter(iter_)\n", "code_toks_joined": "def _reselect_row ( model , _ , iter_ , ( selection , selected_rows , ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if model . get_value ( iter_ , 0 ) in selected_rows : <NEWLINE> <INDENT> selection . select_iter ( iter_ ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Select rows if they are referenced by selected_rows.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["152aa90febea09c008d5280980ad49a7", {"code_string": "def update_screen_rgbabits(self, (x, y), (w, h), data):\n    (x0, y0) = self.screenpos\n    self.screen.blit_rgba(x - x0, y - y0, w, h, data)\n", "code_toks_joined": "def update_screen_rgbabits ( self , ( x , y ) , ( w , h ) , data ) : <NEWLINE> <INDENT> ( x0 , y0 ) = self . screenpos <NEWLINE> self . screen . blit_rgba ( x - x0 , y - y0 , w , h , data ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["c66fdad69dd6e9f93cabb834fe2134df", {"code_string": "def CalcAndSetPosition(self):\n    parentSize = self.GetParent().GetSize()\n    mySize = self.GetSize()\n        maxXCoord = parentSize.width - mySize.width\n        xCoord = maxXCoord * self.xrel\n        maxYCoord = parentSize.height - mySize.height\n        yCoord = maxYCoord * self.yrel\n        position = wx.Point(xCoord, yCoord)\n        position = self.GetParent().ClientToScreen(position)\n        self.SetPosition(position)\n", "code_toks_joined": "def CalcAndSetPosition ( self ) : <NEWLINE> <INDENT> parentSize = self . GetParent ( ) . GetSize ( ) <NEWLINE> mySize = self . GetSize ( ) <NEWLINE> <INDENT> maxXCoord = parentSize . width - mySize . width <NEWLINE> xCoord = maxXCoord * self . xrel <NEWLINE> maxYCoord = parentSize . height - mySize . height <NEWLINE> yCoord = maxYCoord * self . yrel <NEWLINE> position = wx . Point ( xCoord , yCoord ) <NEWLINE> position = self . GetParent ( ) . ClientToScreen ( position ) <NEWLINE> self . SetPosition ( position ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["f16d50e09033c16e232347b22e3deea1", {"code_string": "def get_hash(self):\n    return reduce(lambda a, (ik, v), hc = self.kcase:\n        a.update({hc[ik]: v}) or a, self.data.items(), {})\n", "code_toks_joined": "def get_hash ( self ) : <NEWLINE> <INDENT> return reduce ( lambda a , ( ik , v ) , hc = self . kcase : <NEWLINE> <INDENT> a . update ( { hc [ ik ] : v } ) or a , self . data . items ( ) , { } ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["48a74690144dbabe407051e08f9c6c97", {"code_string": "def __init__(self, persistent_filepath = None, write_when_destructed = True):\n    \"\"\"Creates a file change tracker and loads previous data from a file or file-like object,\"\"\"\n    self.persistent_filepath = persistent_filepath\n    self.write_when_destructed = write_when_destructed\n    self._is_dirty = False\n    self._cache = {}\n    if(self.persistent_filepath is not None\n        and osp.exists(self.persistent_filepath)\n        and os.stat(self.persistent_filepath).st_size > 0):\n        with open(self.persistent_filepath, 'rb') as fp:\n        self._cache = pickle.load(fp)\n", "code_toks_joined": "def __init__ ( self , persistent_filepath = None , write_when_destructed = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . persistent_filepath = persistent_filepath <NEWLINE> self . write_when_destructed = write_when_destructed <NEWLINE> self . _is_dirty = False <NEWLINE> self . _cache = { } <NEWLINE> if ( self . persistent_filepath is not None <NEWLINE> <INDENT> and osp . exists ( self . persistent_filepath ) <NEWLINE> and os . stat ( self . persistent_filepath ) . st_size > 0 ) : <NEWLINE> with open ( self . persistent_filepath , <STRING> ) as fp : <NEWLINE> self . _cache = pickle . load ( fp ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Creates a file change tracker and loads previous data from a file or file-like object,\"\"\"", "'rb'"]}, "err_obj": {"msg": "expected an indented block"}}], ["16a8b752a49fa38564c370bd89173c37", {"code_string": "def test_broken_connection(self, mock_ver):\n    for(error, domain) in(\n        (fakelibvirt.VIR_ERR_SYSTEM_ERROR,\n            fakelibvirt.VIR_FROM_REMOTE),\n        (fakelibvirt.VIR_ERR_SYSTEM_ERROR,\n            fakelibvirt.VIR_FROM_RPC),\n        (fakelibvirt.VIR_ERR_INTERNAL_ERROR,\n            fakelibvirt.VIR_FROM_RPC)):\n            conn = self.host._connect(\"qemu:///system\", False)\n            mock_ver.side_effect = fakelibvirt.make_libvirtError(\n        fakelibvirt.libvirtError,\n        \"Connection broken\",\n        error_code = error,\n        error_domain = domain)\n        self.assertFalse(self.host._test_connection(conn))\n", "code_toks_joined": "def test_broken_connection ( self , mock_ver ) : <NEWLINE> <INDENT> for ( error , domain ) in ( <NEWLINE> <INDENT> ( fakelibvirt . VIR_ERR_SYSTEM_ERROR , <NEWLINE> <INDENT> fakelibvirt . VIR_FROM_REMOTE ) , <NEWLINE> <DEDENT> ( fakelibvirt . VIR_ERR_SYSTEM_ERROR , <NEWLINE> <INDENT> fakelibvirt . VIR_FROM_RPC ) , <NEWLINE> <DEDENT> ( fakelibvirt . VIR_ERR_INTERNAL_ERROR , <NEWLINE> <INDENT> fakelibvirt . VIR_FROM_RPC ) ) : <NEWLINE> conn = self . host . _connect ( <STRING> , False ) <NEWLINE> mock_ver . side_effect = fakelibvirt . make_libvirtError ( <NEWLINE> <DEDENT> fakelibvirt . libvirtError , <NEWLINE> <STRING> , <NEWLINE> error_code = error , <NEWLINE> error_domain = domain ) <NEWLINE> self . assertFalse ( self . host . _test_connection ( conn ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"qemu:///system\"", "\"Connection broken\""]}, "err_obj": {"msg": "unindent does not match any outer indentation level"}}], ["b6fcf2c35604f42fa09acf93497e5c34", {"code_string": "def getSubscribed(self):\n    \"\"\"gets subscribed mailboxes from server - should do this at first connect\"\"\"\n    if ALLVERBOSE or VERBOSE: print \"ImapProxyAccount.getSubscribed()\"\n    d = self.server.protocol.lsub(\"\", \"*\")\n    d.addCallback(self.__getSubscribed_cb)\n    return d\n", "code_toks_joined": "def getSubscribed ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ALLVERBOSE or VERBOSE : print <STRING> <NEWLINE> d = self . server . protocol . lsub ( <STRING> , <STRING> ) <NEWLINE> d . addCallback ( self . __getSubscribed_cb ) <NEWLINE> return d <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"gets subscribed mailboxes from server - should do this at first connect\"\"\"", "\"ImapProxyAccount.getSubscribed()\"", "\"\"", "\"*\""]}, "err_obj": {"msg": "invalid syntax"}}], ["aa98396b60f5dd6041c66ba5db79671c", {"code_string": "class CreateContactView(CreateView):\n    model = Contact\n    template_name = 'edit_contact.html'\n    form_class = forms.ContactForm\n    def get_success_url(self):\n        return reverse('contacts-list')\n    def get_context_data(self, ** kwargs):\n    context = super(CreateContactView, self).get_context_data(** kwargs)\n    context['target'] = reverse('contacts-new')\n    return context\n", "code_toks_joined": "class CreateContactView ( CreateView ) : <NEWLINE> <INDENT> model = Contact <NEWLINE> template_name = <STRING> <NEWLINE> form_class = forms . ContactForm <NEWLINE> def get_success_url ( self ) : <NEWLINE> <INDENT> return reverse ( <STRING> ) <NEWLINE> <DEDENT> def get_context_data ( self , ** kwargs ) : <NEWLINE> context = super ( CreateContactView , self ) . get_context_data ( ** kwargs ) <NEWLINE> context [ <STRING> ] = reverse ( <STRING> ) <NEWLINE> return context <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'edit_contact.html'", "'contacts-list'", "'target'", "'contacts-new'"]}, "err_obj": {"msg": "expected an indented block"}}], ["a8758730d15f5ce0fedd480551654feb", {"code_string": "def readJobInfo(jobtext):\n    job = Job()\n    lines = jobtext.split(\"\\n\")\n    for line in lines:\n        pair = line.split(\"=\")\n        if len(pair) > 1:\n            key, value = pair\n            exec \"job.\" + key.strip() + \"=\" + \"\\\"\" + value.strip() + \"\\\"\"\n    return job;\n", "code_toks_joined": "def readJobInfo ( jobtext ) : <NEWLINE> <INDENT> job = Job ( ) <NEWLINE> lines = jobtext . split ( <STRING> ) <NEWLINE> for line in lines : <NEWLINE> <INDENT> pair = line . split ( <STRING> ) <NEWLINE> if len ( pair ) > 1 : <NEWLINE> <INDENT> key , value = pair <NEWLINE> exec <STRING> + key . strip ( ) + <STRING> + <STRING> + value . strip ( ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> return job ; <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\\n\"", "\"=\"", "\"job.\"", "\"=\"", "\"\\\"\"", "\"\\\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["ed2971791ef6392d51ea96e7a2441521", {"code_string": "def textPosition(self, pos):\n    if type(pos) not in[tuple, list] or len(pos) != 2:\n        raise AttributeError, \"Expected a two-element tuple when \" \"setting textOffset\"\n    self.setTextPosition(pos[0], pos[1])\n", "code_toks_joined": "def textPosition ( self , pos ) : <NEWLINE> <INDENT> if type ( pos ) not in [ tuple , list ] or len ( pos ) != 2 : <NEWLINE> <INDENT> raise AttributeError , <STRING> <STRING> <NEWLINE> <DEDENT> self . setTextPosition ( pos [ 0 ] , pos [ 1 ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Expected a two-element tuple when \"", "\"setting textOffset\""]}, "err_obj": {"msg": "invalid syntax"}}], ["f9155f0469378da05ca9a1553ba4206e", {"code_string": "def __init__(self):\n    self.__client = config.api_client\n    self.__base = defaults.get('RACKHD_BASE_REPO_URL', 'http://{0}:{1}'.format(HOST_IP, HOST_PORT))\n    self.__obm_options = {\n        'obmServiceName': defaults.get('RACKHD_GLOBAL_OBM_SERVICE_NAME', 'ipmi-obm-service')\n", "code_toks_joined": "def __init__ ( self ) : <NEWLINE> <INDENT> self . __client = config . api_client <NEWLINE> self . __base = defaults . get ( <STRING> , <STRING> . format ( HOST_IP , HOST_PORT ) ) <NEWLINE> self . __obm_options = { <NEWLINE> <INDENT> <STRING> : defaults . get ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'RACKHD_BASE_REPO_URL'", "'http://{0}:{1}'", "'obmServiceName'", "'RACKHD_GLOBAL_OBM_SERVICE_NAME'", "'ipmi-obm-service'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["99bf740938514398b4c52ad07e278c42", {"code_string": "def merge(self, nuevaTabla):\n    error = None\n    for i in nuevaTabla.lista:\n        if self.isMember(i.id, 0):\n        error = (i.lineno, i.colno, i.id)\n        else:\n        self.insert(i)\n    return error\n", "code_toks_joined": "def merge ( self , nuevaTabla ) : <NEWLINE> <INDENT> error = None <NEWLINE> for i in nuevaTabla . lista : <NEWLINE> <INDENT> if self . isMember ( i . id , 0 ) : <NEWLINE> error = ( i . lineno , i . colno , i . id ) <NEWLINE> else : <NEWLINE> self . insert ( i ) <NEWLINE> <DEDENT> return error <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["119302af13699c7723eadb7f967008ab", {"code_string": "def pretty_wait_print():\n    SECS_4_3 = int((4.0 / 3) / WAIT_TIME)\n    SECS_1_3 = int((1.0 / 3) / WAIT_TIME)\n    print('\\x1b[K',\n    print(\"\\rWaiting for device '%s' to be plugged in \" % serial_port, )\n    for i in range(pretty_wait_print.count - SECS_1_3, 0, - SECS_1_3):\n        sys.stdout.write('.')\n    sys.stdout.flush()\n    pretty_wait_print.count = (pretty_wait_print.count + 1) %(SECS_4_3 - 1)\n", "code_toks_joined": "def pretty_wait_print ( ) : <NEWLINE> <INDENT> SECS_4_3 = int ( ( 4.0 / 3 ) / WAIT_TIME ) <NEWLINE> SECS_1_3 = int ( ( 1.0 / 3 ) / WAIT_TIME ) <NEWLINE> print ( <STRING> , <NEWLINE> print ( <STRING> % serial_port , ) <NEWLINE> for i in range ( pretty_wait_print . count - SECS_1_3 , 0 , - SECS_1_3 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> sys . stdout . flush ( ) <NEWLINE> pretty_wait_print . count = ( pretty_wait_print . count + 1 ) % ( SECS_4_3 - 1 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'\\x1b[K'", "\"\\rWaiting for device '%s' to be plugged in \"", "'.'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["95be1c1164bac0def90c4785cdd9dc8c", {"code_string": "def assign_molweight(atom_id):\n    \"\"\"assignes a molecular weight to each atom in a given structure\"\"\"\n    MOLWEIGHTS = {\n        '?': 0.0, 'H': 1.00794, 'C': 12.0107, 'N': 14.0067,\n        'O': 15.9994, 'P': 30.973761, 'S': 32.065}\n        for char in atom_id:\n        if char in MOLWEIGHTS.keys():\n        atom_name = char\n        break\n    if atom_name in MOLWEIGHTS.keys():\n        molweight = MOLWEIGHTS[atom_name]\n        return molweight\n    else: raise PyRyStructureError(\"Atom not known\" + atom_name)\n", "code_toks_joined": "def assign_molweight ( atom_id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> MOLWEIGHTS = { <NEWLINE> <INDENT> <STRING> : 0.0 , <STRING> : 1.00794 , <STRING> : 12.0107 , <STRING> : 14.0067 , <NEWLINE> <STRING> : 15.9994 , <STRING> : 30.973761 , <STRING> : 32.065 } <NEWLINE> for char in atom_id : <NEWLINE> if char in MOLWEIGHTS . keys ( ) : <NEWLINE> atom_name = char <NEWLINE> break <NEWLINE> <DEDENT> if atom_name in MOLWEIGHTS . keys ( ) : <NEWLINE> <INDENT> molweight = MOLWEIGHTS [ atom_name ] <NEWLINE> return molweight <NEWLINE> <DEDENT> else : raise PyRyStructureError ( <STRING> + atom_name ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"assignes a molecular weight to each atom in a given structure\"\"\"", "'?'", "'H'", "'C'", "'N'", "'O'", "'P'", "'S'", "\"Atom not known\""]}, "err_obj": {"msg": "unexpected indent"}}], ["56db210bdbe6531f1ce8c157883d7fc6", {"code_string": "def test_builds(self):\n    \"\"\"Test Build class\"\"\"\n    try:\n        b = travis.Build(- 1)\n    except Exception as ex:\n        self.assertEqual('AttributeError', type(ex).__name__)\n    b = travis.Build(self.valid_build_id)\n    self.assertIsInstance(b, travis.Build)\n        for job in b.matrix:\n            self.assertIsInstance(job, travis.Job)\n        self.assertEqual(b.jobs, 2)\n", "code_toks_joined": "def test_builds ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> b = travis . Build ( - 1 ) <NEWLINE> <DEDENT> except Exception as ex : <NEWLINE> <INDENT> self . assertEqual ( <STRING> , type ( ex ) . __name__ ) <NEWLINE> <DEDENT> b = travis . Build ( self . valid_build_id ) <NEWLINE> self . assertIsInstance ( b , travis . Build ) <NEWLINE> <INDENT> for job in b . matrix : <NEWLINE> <INDENT> self . assertIsInstance ( job , travis . Job ) <NEWLINE> <DEDENT> self . assertEqual ( b . jobs , 2 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Test Build class\"\"\"", "'AttributeError'"]}, "err_obj": {"msg": "unexpected indent"}}], ["65e855a8fbcad6b3dc7ca79ba2412850", {"code_string": "def getScalars(self input):\n    \"\"\"See method description in :meth:`~.nupic.encoders.base.Encoder.getScalars`.\"\"\"\n    return numpy.array(self.getEncodedValues(input))\n", "code_toks_joined": "def getScalars ( self input ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return numpy . array ( self . getEncodedValues ( input ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"See method description in :meth:`~.nupic.encoders.base.Encoder.getScalars`.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["395954e65f5b1847503bd44fb28defa9", {"code_string": "def main():\n    debug = int(ConfigSectionMap(\"debug\")['debug'])\n    set_path(debug)\n    try:\n        custom_acct(debug)\n        csvpath = '%s/acct-%s_%s.csv.gz' %(path, yesterday(), ConfigSectionMap(\"client\")['hostname']))\n        if scp_copy(csvpath, ConfigSectionMap(\"ssh\")['user'], ConfigSectionMap(\"ssh\")['host'], ConfigSectionMap(\"ssh\")['path']):\n            if debug:\n                print(\"[+] File uploaded successfully\")\n            return 0\n        else:\n            if debug:\n                print(\"[-] File upload failed\")\n            return 1\n    except IOError:\n        if debug:\n            print(\"[-] Il file \" + logfilename() + \" non e' presente\")\n    clean_tmp(debug)\n    return 0\n", "code_toks_joined": "def main ( ) : <NEWLINE> <INDENT> debug = int ( ConfigSectionMap ( <STRING> ) [ <STRING> ] ) <NEWLINE> set_path ( debug ) <NEWLINE> try : <NEWLINE> <INDENT> custom_acct ( debug ) <NEWLINE> csvpath = <STRING> % ( path , yesterday ( ) , ConfigSectionMap ( <STRING> ) [ <STRING> ] ) ) <NEWLINE> if scp_copy ( csvpath , ConfigSectionMap ( <STRING> ) [ <STRING> ] , ConfigSectionMap ( <STRING> ) [ <STRING> ] , ConfigSectionMap ( <STRING> ) [ <STRING> ] ) : <NEWLINE> <INDENT> if debug : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if debug : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> return 1 <NEWLINE> <DEDENT> <DEDENT> except IOError : <NEWLINE> <INDENT> if debug : <NEWLINE> <INDENT> print ( <STRING> + logfilename ( ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> clean_tmp ( debug ) <NEWLINE> return 0 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"debug\"", "'debug'", "'%s/acct-%s_%s.csv.gz'", "\"client\"", "'hostname'", "\"ssh\"", "'user'", "\"ssh\"", "'host'", "\"ssh\"", "'path'", "\"[+] File uploaded successfully\"", "\"[-] File upload failed\"", "\"[-] Il file \"", "\" non e' presente\""]}, "window_span": [34, 55], "err_obj": {"msg": "unbalanced (){}[]"}}], ["090aecb5636298e364360a5a8c6b61c1", {"code_string": "def nextButtonCallBack(self, button, * args):\n    self.vBoxMain.get_children()[self.currentIndexExercise].hide()\n        self.currentIndexExercise = self.currentIndexExercise + 1\n        self.vBoxMain.get_children()[self.currentIndexExercise].show_all()\n        self.manageBackNextButtons()\n", "code_toks_joined": "def nextButtonCallBack ( self , button , * args ) : <NEWLINE> <INDENT> self . vBoxMain . get_children ( ) [ self . currentIndexExercise ] . hide ( ) <NEWLINE> <INDENT> self . currentIndexExercise = self . currentIndexExercise + 1 <NEWLINE> self . vBoxMain . get_children ( ) [ self . currentIndexExercise ] . show_all ( ) <NEWLINE> self . manageBackNextButtons ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["8aec533d71855866a5c3a94c75f2a12e", {"code_string": "def calcHash(listEntry):\n    for el in listEntry:\n    if len(listEntry[el]) == 0:\n        f = file(el, \"rb\")\n        hash = hashlib.sha1(f.read()).hexdigest()\n        listEntry[el] = hash\n", "code_toks_joined": "def calcHash ( listEntry ) : <NEWLINE> <INDENT> for el in listEntry : <NEWLINE> if len ( listEntry [ el ] ) == 0 : <NEWLINE> <INDENT> f = file ( el , <STRING> ) <NEWLINE> hash = hashlib . sha1 ( f . read ( ) ) . hexdigest ( ) <NEWLINE> listEntry [ el ] = hash <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"rb\""]}, "err_obj": {"msg": "expected an indented block"}}], ["d48ece4fad69c3f4304e9ba5ad151bf2", {"code_string": "def test_dense_sparse():\n    for test_func in(_test_ridge_loo,\n        _test_ridge_cv,\n        _test_ridge_diabetes,\n        _test_multi_ridge_diabetes,\n        _test_ridge_classifiers,\n        _test_tolerance):\n        ret_dense = test_func(DENSE_FILTER)\n        ret_sparse = test_func(SPARSE_FILTER)\n        if ret_dense is not None and ret_sparse is not None:\n        assert_array_almost_equal(ret_dense, ret_sparse, decimal = 3)\n", "code_toks_joined": "def test_dense_sparse ( ) : <NEWLINE> <INDENT> for test_func in ( _test_ridge_loo , <NEWLINE> <INDENT> _test_ridge_cv , <NEWLINE> _test_ridge_diabetes , <NEWLINE> _test_multi_ridge_diabetes , <NEWLINE> _test_ridge_classifiers , <NEWLINE> _test_tolerance ) : <NEWLINE> ret_dense = test_func ( DENSE_FILTER ) <NEWLINE> ret_sparse = test_func ( SPARSE_FILTER ) <NEWLINE> if ret_dense is not None and ret_sparse is not None : <NEWLINE> assert_array_almost_equal ( ret_dense , ret_sparse , decimal = 3 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["c82f694bd857291e6de8d7d64f929554", {"code_string": "def variableName(name):\n    '''Method 2'''\n        return name.isidentifier()\n", "code_toks_joined": "def variableName ( name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> return name . isidentifier ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Method 2'''"]}, "err_obj": {"msg": "unexpected indent"}}], ["5ac866f8c4935452dc9e9d70d1dda596", {"code_string": "from sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import scoped_session, sessionmaker\nfrom zope.sqlalchemy import ZopeTransactionExtension\nDBSession = scoped_session(sessionmaker(extension = ZopeTransactionExtension())\nBase = declarative_base()\n", "code_toks_joined": "from sqlalchemy . ext . declarative import declarative_base <NEWLINE> from sqlalchemy . orm import scoped_session , sessionmaker <NEWLINE> from zope . sqlalchemy import ZopeTransactionExtension <NEWLINE> DBSession = scoped_session ( sessionmaker ( extension = ZopeTransactionExtension ( ) ) <NEWLINE> Base = declarative_base ( ) <NEWLINE>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["747daeffdfbd8c7dc44c88ab0cddfd68", {"code_string": "def on_key_press(key, modifiers):\n    if board.is_won():\n    exit()\n    if key == pyglet.window.key.RIGHT:\n        board.advance_right()\n    elif key == pyglet.window.key.LEFT:\n        board.advance_left()\n", "code_toks_joined": "def on_key_press ( key , modifiers ) : <NEWLINE> <INDENT> if board . is_won ( ) : <NEWLINE> exit ( ) <NEWLINE> if key == pyglet . window . key . RIGHT : <NEWLINE> <INDENT> board . advance_right ( ) <NEWLINE> <DEDENT> elif key == pyglet . window . key . LEFT : <NEWLINE> <INDENT> board . advance_left ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["0b4dadc893cafe69f29c732d8baba146", {"code_string": "\"\"\"Styles and conventions to keep my code consistent.\"\"\"\nprint(\"\"\"PEP8 Highlights\"\"\")\ndef my_long_function_name(long_variable_one = 'hello', long_variable_two = True,\n    long_variable_three = 123):\n    print('Hello world!')\ndef another_long_function(\n    long_variable_one = 'hello', long_variable_two = True,\n    long_variable_three = 123):\n    if long_variable_two:\n    print('Kittens!')\nfoo = another_long_function(\n    long_variable_one = 'world', long_variable_two = False,\n    long_variable_three = 100)\n", "code_toks_joined": "<STRING> <NEWLINE> print ( <STRING> ) <NEWLINE> def my_long_function_name ( long_variable_one = <STRING> , long_variable_two = True , <NEWLINE> <INDENT> long_variable_three = 123 ) : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> def another_long_function ( <NEWLINE> <INDENT> long_variable_one = <STRING> , long_variable_two = True , <NEWLINE> long_variable_three = 123 ) : <NEWLINE> if long_variable_two : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> foo = another_long_function ( <NEWLINE> <INDENT> long_variable_one = <STRING> , long_variable_two = False , <NEWLINE> long_variable_three = 100 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Styles and conventions to keep my code consistent.\"\"\"", "\"\"\"PEP8 Highlights\"\"\"", "'hello'", "'Hello world!'", "'hello'", "'Kittens!'", "'world'"]}, "err_obj": {"msg": "expected an indented block"}}], ["64e7256e4507b5ab01ab0b0cc38001cc", {"code_string": "def _GenerateBenchmarkDocumentation():\n    \"\"\"Generates benchmark documentation to show in --help.\"\"\"\n    benchmark_docs = []\n    for benchmark_module in(benchmarks.BENCHMARKS +\n        windows_benchmarks.BENCHMARKS):\n        benchmark_info = benchmark_module.BENCHMARK_INFO\n        vm_count = benchmark_info.get('num_machines') or 'variable'\n        scratch_disk_str = ''\n        if benchmark_info.get('scratch_disk'):\n        scratch_disk_str = ' with scratch volume'\n        name = benchmark_info['name']\n        if benchmark_module in windows_benchmarks.BENCHMARKS:\n        name += ' (Windows)'\n        benchmark_docs.append('%s: %s (%s VMs%s)' %\n        (name,\n        benchmark_info['description'],\n        vm_count,\n        scratch_disk_str))\n    return '\\n\\t'.join(benchmark_docs)\n", "code_toks_joined": "def _GenerateBenchmarkDocumentation ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> benchmark_docs = [ ] <NEWLINE> for benchmark_module in ( benchmarks . BENCHMARKS + <NEWLINE> <INDENT> windows_benchmarks . BENCHMARKS ) : <NEWLINE> benchmark_info = benchmark_module . BENCHMARK_INFO <NEWLINE> vm_count = benchmark_info . get ( <STRING> ) or <STRING> <NEWLINE> scratch_disk_str = <STRING> <NEWLINE> if benchmark_info . get ( <STRING> ) : <NEWLINE> scratch_disk_str = <STRING> <NEWLINE> name = benchmark_info [ <STRING> ] <NEWLINE> if benchmark_module in windows_benchmarks . BENCHMARKS : <NEWLINE> name += <STRING> <NEWLINE> benchmark_docs . append ( <STRING> % <NEWLINE> ( name , <NEWLINE> benchmark_info [ <STRING> ] , <NEWLINE> vm_count , <NEWLINE> scratch_disk_str ) ) <NEWLINE> <DEDENT> return <STRING> . join ( benchmark_docs ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Generates benchmark documentation to show in --help.\"\"\"", "'num_machines'", "'variable'", "''", "'scratch_disk'", "' with scratch volume'", "'name'", "' (Windows)'", "'%s: %s (%s VMs%s)'", "'description'", "'\\n\\t'"]}, "err_obj": {"msg": "expected an indented block"}}], ["a1ff40d57d151c86c75ffb22c52f8f92", {"code_string": "class QConfigurationPathEdit(QConfigurationLineEditButton):\n    def __init__(self, key, field, callback_f,\n        button_cls = QDirectoryChooserToolButton, parent = None):\n        QConfigurationLineEditButton.__init__(self, key, field, callback_f,\n            None, parent)\n            button = button_cls(self, self.line_edit)\n            self.add_button(button)\n", "code_toks_joined": "class QConfigurationPathEdit ( QConfigurationLineEditButton ) : <NEWLINE> <INDENT> def __init__ ( self , key , field , callback_f , <NEWLINE> <INDENT> button_cls = QDirectoryChooserToolButton , parent = None ) : <NEWLINE> QConfigurationLineEditButton . __init__ ( self , key , field , callback_f , <NEWLINE> <INDENT> None , parent ) <NEWLINE> button = button_cls ( self , self . line_edit ) <NEWLINE> self . add_button ( button ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["a5bfe31281192a4122cc619d36d8e62b", {"code_string": "import sys, os\ncurrent = os.path.dirname(__file__)\nsys.path.insert(0, os.path.normpath(os.path.join(current, '..'))))\nfrom service import main\nif not os.path.exists('temp'):\n    os.mkdir('temp')\nmain()\n", "code_toks_joined": "import sys , os <NEWLINE> current = os . path . dirname ( __file__ ) <NEWLINE> sys . path . insert ( 0 , os . path . normpath ( os . path . join ( current , <STRING> ) ) ) ) <NEWLINE> from service import main <NEWLINE> if not os . path . exists ( <STRING> ) : <NEWLINE> <INDENT> os . mkdir ( <STRING> ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["'..'", "'temp'", "'temp'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["fa70126e83f2c9d55a7e2e28fe307e20", {"code_string": "def is_horizontal_line((x1, y1), (x2, y2)):\n    dx = abs(x2 - x1)\n    dy = abs(y2 - y1)\n    return dx > dy\n", "code_toks_joined": "def is_horizontal_line ( ( x1 , y1 ) , ( x2 , y2 ) ) : <NEWLINE> <INDENT> dx = abs ( x2 - x1 ) <NEWLINE> dy = abs ( y2 - y1 ) <NEWLINE> return dx > dy <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["ae5b7c3920de900aaa11354677921757", {"code_string": "def lil_eye((r, c), k = 0, dtype = 'd'):\n    \"\"\"Generate a lil_matrix of dimensions (r,c) with the k-th\"\"\"\n    warn(\"lil_eye is deprecated.\" \"use scipy.sparse.eye(r, c, k, format='lil') instead\", DeprecationWarning)\n    return eye(r, c, k, dtype = dtype, format = 'lil')\n", "code_toks_joined": "def lil_eye ( ( r , c ) , k = 0 , dtype = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> warn ( <STRING> <STRING> , DeprecationWarning ) <NEWLINE> return eye ( r , c , k , dtype = dtype , format = <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'d'", "\"\"\"Generate a lil_matrix of dimensions (r,c) with the k-th\"\"\"", "\"lil_eye is deprecated.\"", "\"use scipy.sparse.eye(r, c, k, format='lil') instead\"", "'lil'"]}, "err_obj": {"msg": "invalid syntax"}}], ["542d9340cb7151e0056aef53f79e901c", {"code_string": "def hscaleRbOD_adj_value_changed(self, slider):\n    self.RbParameters['imageObj'].set_clim(0, slider.get_value()\n    self.RbParameters['canvasObj'].draw_idle()\n", "code_toks_joined": "def hscaleRbOD_adj_value_changed ( self , slider ) : <NEWLINE> <INDENT> self . RbParameters [ <STRING> ] . set_clim ( 0 , slider . get_value ( ) <NEWLINE> self . RbParameters [ <STRING> ] . draw_idle ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'imageObj'", "'canvasObj'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c8e384ec555b8226890dfc1396fff73f", {"code_string": "def psi(self, F):\n    temp1 = - self.a *(self.mu - F)\n    temp2 = self.a ** 2 *(1 / self.gamma + 1 / self.gx) / 2\n    return(1 / self.a) *(1 - np.exp(temp1 + temp2) - self.c\n", "code_toks_joined": "def psi ( self , F ) : <NEWLINE> <INDENT> temp1 = - self . a * ( self . mu - F ) <NEWLINE> temp2 = self . a ** 2 * ( 1 / self . gamma + 1 / self . gx ) / 2 <NEWLINE> return ( 1 / self . a ) * ( 1 - np . exp ( temp1 + temp2 ) - self . c <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c1b62a48813e057769fc5950d627291b", {"code_string": "def AddExports(exports, module_name, module_version, file_path):\n    if module_name not in exports:\n        exports[module_name] = {};\n    if module_version not in exports[module_name]:\n        exports[module_name][module_version] = {'exports': [], 'forwards': {}, 'order': []};\n    module_exports = exports[module_name][module_version]['exports'];\n    module_forwards = exports[module_name][module_version]['forwards'];\n    module_order = exports[module_name][module_version]['order'];\n    file_handle = open(file_path, 'rb');\n    try:\n        in_header = True;\n        line_index = 0;\n        for line in file_handle:\n            line_index += 1;\n            if re.match(r'^\\s*[\\r\\n]*$', line):\n                continue;\n            if in_header:\n                if re.match(r'^\\s*ordinal\\s+hint\\s+RVA\\s+name\\s*[\\r\\n]*$', line):\n                    in_header = False;\n            elif re.match(r'^\\s*Summary\\s*[\\r\\n]*$', line):\n                break;\n            else:\n                export_match = re.match(r'^.{11} .{4} \\w{8} (\\w+)(?: = .*)?\\s*[\\r\\n]*$', line);\n                if export_match:\n                    export = export_match.group(1);\n                    module_exports.append(export);\n                    module_order.append(export);\n                    continue;\n                none_match = re.match(r'^.{11}      \\w{8} .*\\s*[\\r\\n]*$', line);\n                if none_match:\n                    continue;\n                forward_match = re.match(r'^.{11} .{4}          (\\w+) \\(forwarded to (\\w+)\\.(\\w+)\\)\\s*[\\r\\n]*$', line);\n                if forward_match:\n                    forward = forward_match.group(1);\n                    target_module = forward_match.group(2);\n                    target_function = forward_match.group(3);\n                    module_forwards[forward] = (target_module, target_function);\n                    module_order.append(forward);\n                    continue;\n                print('Unknown syntax in \"%s\":' % file_path)\n                print('Line #%d: %s' %(line_index, repr(line)))\n                return False;\n        print('  + %s (%s): %d exports, %s forwards.' %(module_name, module_version,\n            len(module_exports), len(module_forwards));\n        return True;\n    finally:\n        file_handle.close();\n", "code_toks_joined": "def AddExports ( exports , module_name , module_version , file_path ) : <NEWLINE> <INDENT> if module_name not in exports : <NEWLINE> <INDENT> exports [ module_name ] = { } ; <NEWLINE> <DEDENT> if module_version not in exports [ module_name ] : <NEWLINE> <INDENT> exports [ module_name ] [ module_version ] = { <STRING> : [ ] , <STRING> : { } , <STRING> : [ ] } ; <NEWLINE> <DEDENT> module_exports = exports [ module_name ] [ module_version ] [ <STRING> ] ; <NEWLINE> module_forwards = exports [ module_name ] [ module_version ] [ <STRING> ] ; <NEWLINE> module_order = exports [ module_name ] [ module_version ] [ <STRING> ] ; <NEWLINE> file_handle = open ( file_path , <STRING> ) ; <NEWLINE> try : <NEWLINE> <INDENT> in_header = True ; <NEWLINE> line_index = 0 ; <NEWLINE> for line in file_handle : <NEWLINE> <INDENT> line_index += 1 ; <NEWLINE> if re . match ( <STRING> , line ) : <NEWLINE> <INDENT> continue ; <NEWLINE> <DEDENT> if in_header : <NEWLINE> <INDENT> if re . match ( <STRING> , line ) : <NEWLINE> <INDENT> in_header = False ; <NEWLINE> <DEDENT> <DEDENT> elif re . match ( <STRING> , line ) : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> export_match = re . match ( <STRING> , line ) ; <NEWLINE> if export_match : <NEWLINE> <INDENT> export = export_match . group ( 1 ) ; <NEWLINE> module_exports . append ( export ) ; <NEWLINE> module_order . append ( export ) ; <NEWLINE> continue ; <NEWLINE> <DEDENT> none_match = re . match ( <STRING> , line ) ; <NEWLINE> if none_match : <NEWLINE> <INDENT> continue ; <NEWLINE> <DEDENT> forward_match = re . match ( <STRING> , line ) ; <NEWLINE> if forward_match : <NEWLINE> <INDENT> forward = forward_match . group ( 1 ) ; <NEWLINE> target_module = forward_match . group ( 2 ) ; <NEWLINE> target_function = forward_match . group ( 3 ) ; <NEWLINE> module_forwards [ forward ] = ( target_module , target_function ) ; <NEWLINE> module_order . append ( forward ) ; <NEWLINE> continue ; <NEWLINE> <DEDENT> print ( <STRING> % file_path ) <NEWLINE> print ( <STRING> % ( line_index , repr ( line ) ) ) <NEWLINE> return False ; <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> % ( module_name , module_version , <NEWLINE> <INDENT> len ( module_exports ) , len ( module_forwards ) ) ; <NEWLINE> <DEDENT> return True ; <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> file_handle . close ( ) ; <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'exports'", "'forwards'", "'order'", "'exports'", "'forwards'", "'order'", "'rb'", "r'^\\s*[\\r\\n]*$'", "r'^\\s*ordinal\\s+hint\\s+RVA\\s+name\\s*[\\r\\n]*$'", "r'^\\s*Summary\\s*[\\r\\n]*$'", "r'^.{11} .{4} \\w{8} (\\w+)(?: = .*)?\\s*[\\r\\n]*$'", "r'^.{11}      \\w{8} .*\\s*[\\r\\n]*$'", "r'^.{11} .{4}          (\\w+) \\(forwarded to (\\w+)\\.(\\w+)\\)\\s*[\\r\\n]*$'", "'Unknown syntax in \"%s\":'", "'Line #%d: %s'", "'  + %s (%s): %d exports, %s forwards.'"]}, "window_span": [375, 416], "err_obj": {"msg": "unbalanced (){}[]"}}], ["30c4588314555efdb6bcae25c90cb72c", {"code_string": "def setBuildMode(self, Id, Status):\n    Response = self.PUT(self.SatAPILocation + 'hosts/' + str(Id),\n        json.dumps({'host': {'build': Status}}))\n        return Response\n", "code_toks_joined": "def setBuildMode ( self , Id , Status ) : <NEWLINE> <INDENT> Response = self . PUT ( self . SatAPILocation + <STRING> + str ( Id ) , <NEWLINE> <INDENT> json . dumps ( { <STRING> : { <STRING> : Status } } ) ) <NEWLINE> return Response <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'hosts/'", "'host'", "'build'"]}, "err_obj": {"msg": "unexpected indent"}}], ["554b789f469d1343db03d71efa8198c2", {"code_string": "def getaddrlist(self):\n    \"\"\"Parse all addresses.\"\"\"\n    result = []\n    while self.pos < len(self.field):\n        ad = self.getaddress()\n        if ad:\n            result += ad\n        else:\n            result.append(('', '')\n    return result\n", "code_toks_joined": "def getaddrlist ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> result = [ ] <NEWLINE> while self . pos < len ( self . field ) : <NEWLINE> <INDENT> ad = self . getaddress ( ) <NEWLINE> if ad : <NEWLINE> <INDENT> result += ad <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . append ( ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Parse all addresses.\"\"\"", "''", "''"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["f20cebe7b3cd743f003ebc60f2cdeeef", {"code_string": "def _update_kernel_boundaries(self, (row, column)):\n    self._min_row = min(self._min_row, row)\n    self._max_row = max(self._max_row, row)\n    self._min_column = min(self._min_column, column)\n    self._max_column = max(self._max_column, column)\n", "code_toks_joined": "def _update_kernel_boundaries ( self , ( row , column ) ) : <NEWLINE> <INDENT> self . _min_row = min ( self . _min_row , row ) <NEWLINE> self . _max_row = max ( self . _max_row , row ) <NEWLINE> self . _min_column = min ( self . _min_column , column ) <NEWLINE> self . _max_column = max ( self . _max_column , column ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["7e2a8a4adc712e515775a7c717fdd57d", {"code_string": "def adapt(text):\n    a = psycopg2.extensions.adapt(force_text(text)\n    a.prepare(connection.connection)\n    return a\n", "code_toks_joined": "def adapt ( text ) : <NEWLINE> <INDENT> a = psycopg2 . extensions . adapt ( force_text ( text ) <NEWLINE> a . prepare ( connection . connection ) <NEWLINE> return a <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c88efb9065dd21e9f5146cd27d9bcd27", {"code_string": "def _get_mpi_data(self, context, project_id):\n    result = {}\n    for instance in self.compute_api.get_all(context,\n        project_id = project_id):\n        if instance['fixed_ip']:\n        line = '%s slots=%d' %(instance['fixed_ip']['address'],\n        instance['vcpus'])\n        key = str(instance['key_name'])\n        if key in result:\n        result[key].append(line)\n        else:\n        result[key] = [line]\n    return result\n", "code_toks_joined": "def _get_mpi_data ( self , context , project_id ) : <NEWLINE> <INDENT> result = { } <NEWLINE> for instance in self . compute_api . get_all ( context , <NEWLINE> <INDENT> project_id = project_id ) : <NEWLINE> if instance [ <STRING> ] : <NEWLINE> line = <STRING> % ( instance [ <STRING> ] [ <STRING> ] , <NEWLINE> instance [ <STRING> ] ) <NEWLINE> key = str ( instance [ <STRING> ] ) <NEWLINE> if key in result : <NEWLINE> result [ key ] . append ( line ) <NEWLINE> else : <NEWLINE> result [ key ] = [ line ] <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'fixed_ip'", "'%s slots=%d'", "'fixed_ip'", "'address'", "'vcpus'", "'key_name'"]}, "err_obj": {"msg": "expected an indented block"}}], ["d6261fd63b415f88a11fae498ab90563", {"code_string": "def run(self):\n    self.ips = []\n    self.ipstoleases = {}\n    self.leasestoips = {}\n    self.ipstoslices = {}\n    self.slicestoips = {}\n    while 1:\n        try:\n            self.ganglia = gmon.ganglia.Ganglia(self.host, self.port)\n            self.ganglia.refresh()\n            self.updateips()\n            self.updateleases()\n            self.updateslices()\n        except:\n        self.reset()\n        time.sleep(self.pollint)\n", "code_toks_joined": "def run ( self ) : <NEWLINE> <INDENT> self . ips = [ ] <NEWLINE> self . ipstoleases = { } <NEWLINE> self . leasestoips = { } <NEWLINE> self . ipstoslices = { } <NEWLINE> self . slicestoips = { } <NEWLINE> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . ganglia = gmon . ganglia . Ganglia ( self . host , self . port ) <NEWLINE> self . ganglia . refresh ( ) <NEWLINE> self . updateips ( ) <NEWLINE> self . updateleases ( ) <NEWLINE> self . updateslices ( ) <NEWLINE> <DEDENT> except : <NEWLINE> self . reset ( ) <NEWLINE> time . sleep ( self . pollint ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["026f43e152105d5f663f94e47f480da6", {"code_string": "def subtractByKey(self, other, numPartitions = None):\n    \"\"\"Return each (key, value) pair in C{self} that has no pair with matching key\"\"\"\n    filter_func = lambda(key, vals): len(vals[0]) > 0 and len(vals[1]) == 0\n    map_func = lambda(key, vals): [(key, val) for val in vals[0]]\n    return self.cogroup(other, numPartitions).filter(filter_func).flatMap(map_func)\n", "code_toks_joined": "def subtractByKey ( self , other , numPartitions = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> filter_func = lambda ( key , vals ) : len ( vals [ 0 ] ) > 0 and len ( vals [ 1 ] ) == 0 <NEWLINE> map_func = lambda ( key , vals ) : [ ( key , val ) for val in vals [ 0 ] ] <NEWLINE> return self . cogroup ( other , numPartitions ) . filter ( filter_func ) . flatMap ( map_func ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return each (key, value) pair in C{self} that has no pair with matching key\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["07fe78963b06b0cbb0188a6867d22e84", {"code_string": "def setUp(self):\n    Config.parse_directory(os.path.abspath('../ConfDir'))\n    Config.load_user()\n    print('CONFIGURATION')\n    print(50 * '-')\n    for i in Config.domains():\n    print(i, Config.keys_in_domain(i))\n    print('END', 50 * '-')\n    self.db = Base.DataBase('//localhost/Internal')\n    self.output = cStringIO.StringIO()\n", "code_toks_joined": "def setUp ( self ) : <NEWLINE> <INDENT> Config . parse_directory ( os . path . abspath ( <STRING> ) ) <NEWLINE> Config . load_user ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( 50 * <STRING> ) <NEWLINE> for i in Config . domains ( ) : <NEWLINE> print ( i , Config . keys_in_domain ( i ) ) <NEWLINE> print ( <STRING> , 50 * <STRING> ) <NEWLINE> self . db = Base . DataBase ( <STRING> ) <NEWLINE> self . output = cStringIO . StringIO ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'../ConfDir'", "'CONFIGURATION'", "'-'", "'END'", "'-'", "'//localhost/Internal'"]}, "err_obj": {"msg": "expected an indented block"}}], ["8a60bd7697a9f72a18a55be4b4e12d67", {"code_string": "def getOpenTM2Version():\n    fin = open(r'..\\include\\EQFSERNO.H', 'r')\n    for line in fin:\n        if line.find('#define STR_DRIVER_LEVEL_NUMBER') != - 1:\n            items = line.strip('\\n').split(' ')\n            totalItems = len(items)\n            if totalItems < 3:\n            continue\n            version = items[totalItems - 1].strip('\"')\n            print(version)\n            fout = open(r'..\\openTM2ScripterGUI\\resources\\OpenTM2Version.info', 'w')\n            fout.writelines(version)\n            fout.close()\n    fin.close()\n", "code_toks_joined": "def getOpenTM2Version ( ) : <NEWLINE> <INDENT> fin = open ( <STRING> , <STRING> ) <NEWLINE> for line in fin : <NEWLINE> <INDENT> if line . find ( <STRING> ) != - 1 : <NEWLINE> <INDENT> items = line . strip ( <STRING> ) . split ( <STRING> ) <NEWLINE> totalItems = len ( items ) <NEWLINE> if totalItems < 3 : <NEWLINE> continue <NEWLINE> version = items [ totalItems - 1 ] . strip ( <STRING> ) <NEWLINE> print ( version ) <NEWLINE> fout = open ( <STRING> , <STRING> ) <NEWLINE> fout . writelines ( version ) <NEWLINE> fout . close ( ) <NEWLINE> <DEDENT> <DEDENT> fin . close ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["r'..\\include\\EQFSERNO.H'", "'r'", "'#define STR_DRIVER_LEVEL_NUMBER'", "'\\n'", "' '", "'\"'", "r'..\\openTM2ScripterGUI\\resources\\OpenTM2Version.info'", "'w'"]}, "err_obj": {"msg": "expected an indented block"}}], ["041778ecf4ff32775fda8f116f486d97", {"code_string": "def _terminal_login(self):\n    if \"login_userdomain\" in self.all_attributes:\n        self.fd.write(\"\"\".SH TERMINAL LOGIN\"\"\")\n        if \"login_userdomain\" in self.attributes:\n        self.fd.write(\"\"\"The SELinux user %s_u is able to terminal login.\"\"\" % self.domainname)\n        else:\n        self.fd.write(\"\"\"The SELinux user %s_u is not able to terminal login.\"\"\" % self.domainname)\n", "code_toks_joined": "def _terminal_login ( self ) : <NEWLINE> <INDENT> if <STRING> in self . all_attributes : <NEWLINE> <INDENT> self . fd . write ( <STRING> ) <NEWLINE> if <STRING> in self . attributes : <NEWLINE> self . fd . write ( <STRING> % self . domainname ) <NEWLINE> else : <NEWLINE> self . fd . write ( <STRING> % self . domainname ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"login_userdomain\"", "\"\"\".SH TERMINAL LOGIN\"\"\"", "\"login_userdomain\"", "\"\"\"The SELinux user %s_u is able to terminal login.\"\"\"", "\"\"\"The SELinux user %s_u is not able to terminal login.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["3b05be47617e53f5ed66d41fded86d9f", {"code_string": "def event(self, event):\n    if(event.type == pygame.KEYDOWN):\n        if(event.key == pygame.K_RIGHT):\n        self.nextTrack()\n", "code_toks_joined": "def event ( self , event ) : <NEWLINE> <INDENT> if ( event . type == pygame . KEYDOWN ) : <NEWLINE> <INDENT> if ( event . key == pygame . K_RIGHT ) : <NEWLINE> self . nextTrack ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["ba166e4657998816d6ab6dfe32778b63", {"code_string": "def test_simple(self, (before, after)):\n    self.assertEqual(unicode(_(before)), after)\n    self.assertEqual(unicode(escape(before)), after)\n", "code_toks_joined": "def test_simple ( self , ( before , after ) ) : <NEWLINE> <INDENT> self . assertEqual ( unicode ( _ ( before ) ) , after ) <NEWLINE> self . assertEqual ( unicode ( escape ( before ) ) , after ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["8c069266428c8b56986a23918bce6b02", {"code_string": "def parse_internal_feature_id(self, feature_id, user_feature_id = None):\n    if user_feature_id is None or user_feature_id is '':\n        logging.debug(\"UserFeatureProvider.parse_internal_feature_id -      feature_id: {0}\".format(feature_id))\n        self.feature_defs = UserFeatureDef.from_feature_id(feature_id)\n    else:\n        logging.debug(\"UserFeatureProvider.parse_internal_feature_id - user_feature_id: {0}\".format(user_feature_id)\n        self.feature_defs = UserFeatureDef.from_user_feature_id(user_feature_id)\n    for index, feature_def in enumerate(self.feature_defs):\n        feature_def.bq_row_id = index\n", "code_toks_joined": "def parse_internal_feature_id ( self , feature_id , user_feature_id = None ) : <NEWLINE> <INDENT> if user_feature_id is None or user_feature_id is <STRING> : <NEWLINE> <INDENT> logging . debug ( <STRING> . format ( feature_id ) ) <NEWLINE> self . feature_defs = UserFeatureDef . from_feature_id ( feature_id ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> logging . debug ( <STRING> . format ( user_feature_id ) <NEWLINE> self . feature_defs = UserFeatureDef . from_user_feature_id ( user_feature_id ) <NEWLINE> <DEDENT> for index , feature_def in enumerate ( self . feature_defs ) : <NEWLINE> <INDENT> feature_def . bq_row_id = index <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "\"UserFeatureProvider.parse_internal_feature_id -      feature_id: {0}\"", "\"UserFeatureProvider.parse_internal_feature_id - user_feature_id: {0}\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["4475a2749c72b29511e166125d286b7c", {"code_string": "def uuid_nodes():\n    \"\"\"A generator to every nodes supposed to have a uuid on them.\"\"\"\n    unwanted_nodes = config.DEFAULT_NODES + config.UNWANTED_NODES\n    for node in mc.ls(long = True,\n        type = config.TRACKABLE_NODE_TYPES):\n        if node in unwanted_nodes:\n        continue\n        yield node\n", "code_toks_joined": "def uuid_nodes ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> unwanted_nodes = config . DEFAULT_NODES + config . UNWANTED_NODES <NEWLINE> for node in mc . ls ( long = True , <NEWLINE> <INDENT> type = config . TRACKABLE_NODE_TYPES ) : <NEWLINE> if node in unwanted_nodes : <NEWLINE> continue <NEWLINE> yield node <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"A generator to every nodes supposed to have a uuid on them.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["d95ff1891765b6e3712f8109119c2917", {"code_string": "import numpy as np\nimport logging\nfrom pele.optimize import mylbfgs\nfrom pele.utils.rotations import vec_random_ndim\n__all__ = [\"minima_from_ts\"]\nlogger = logging.getLogger(\"pele.connect\")\ndef determine_pushoff(\n    pot, coords, vec, stepmin = .01, ** unused_kwargs):\n    \"\"\"apply the pushoff along the direction vec\"\"\"\n    if unused_kwargs:\n    print(\"keywords:\", unused_kwargs.keys(), \"are obsolete and ignored in determine_pushoff\")\n    return coords + stepmin * vec / np.linalg.norm(vec)\n", "code_toks_joined": "import numpy as np <NEWLINE> import logging <NEWLINE> from pele . optimize import mylbfgs <NEWLINE> from pele . utils . rotations import vec_random_ndim <NEWLINE> __all__ = [ <STRING> ] <NEWLINE> logger = logging . getLogger ( <STRING> ) <NEWLINE> def determine_pushoff ( <NEWLINE> <INDENT> pot , coords , vec , stepmin = .01 , ** unused_kwargs ) : <NEWLINE> <STRING> <NEWLINE> if unused_kwargs : <NEWLINE> print ( <STRING> , unused_kwargs . keys ( ) , <STRING> ) <NEWLINE> return coords + stepmin * vec / np . linalg . norm ( vec ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"minima_from_ts\"", "\"pele.connect\"", "\"\"\"apply the pushoff along the direction vec\"\"\"", "\"keywords:\"", "\"are obsolete and ignored in determine_pushoff\""]}, "err_obj": {"msg": "expected an indented block"}}], ["08ca67283be39884edd2f94ab4cfc80f", {"code_string": "def dictColCopy(fromDict, toDict, keyList):\n    \"\"\"Copies keys specified in keyList from the fromDict to the newDict.\"\"\"\n    for key in keyList:\n    if key not in fromDict:\n        raise Exception('Key ' + key + ' not found in: ' + str(fromDict))\n        toDict[key] = fromDict[key]\n", "code_toks_joined": "def dictColCopy ( fromDict , toDict , keyList ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for key in keyList : <NEWLINE> if key not in fromDict : <NEWLINE> <INDENT> raise Exception ( <STRING> + key + <STRING> + str ( fromDict ) ) <NEWLINE> toDict [ key ] = fromDict [ key ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Copies keys specified in keyList from the fromDict to the newDict.\"\"\"", "'Key '", "' not found in: '"]}, "err_obj": {"msg": "expected an indented block"}}], ["ce8fb04ea5ae98c7f667bc265cb8d502", {"code_string": "def data_entropy(labeled_data):\n    labels = [label for _, label in labeled_data]\n    probabilities = class_probabilities(labels)\n    return entropy(probabilities)]\n", "code_toks_joined": "def data_entropy ( labeled_data ) : <NEWLINE> <INDENT> labels = [ label for _ , label in labeled_data ] <NEWLINE> probabilities = class_probabilities ( labels ) <NEWLINE> return entropy ( probabilities ) ] <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["2f46f58506d23f025b1daa148e0e306b", {"code_string": "class GFF3OutStream(GenomeStream):\n    def __init__(self, genome_stream):\n        self.gs = gtlib.gt_gff3_out_stream_new(genome_stream, None)\n        self._as_parameter_ = self.gs\n    def from_param(cls, obj):\n        if not isinstance(obj, GFF3OutStream):\n            raise TypeError, \"argument must be a GFF3OutStream\"\n        return obj._as_parameter_\n    from_param = classmethod(from_param)\n", "code_toks_joined": "class GFF3OutStream ( GenomeStream ) : <NEWLINE> <INDENT> def __init__ ( self , genome_stream ) : <NEWLINE> <INDENT> self . gs = gtlib . gt_gff3_out_stream_new ( genome_stream , None ) <NEWLINE> self . _as_parameter_ = self . gs <NEWLINE> <DEDENT> def from_param ( cls , obj ) : <NEWLINE> <INDENT> if not isinstance ( obj , GFF3OutStream ) : <NEWLINE> <INDENT> raise TypeError , <STRING> <NEWLINE> <DEDENT> return obj . _as_parameter_ <NEWLINE> <DEDENT> from_param = classmethod ( from_param ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"argument must be a GFF3OutStream\""]}, "err_obj": {"msg": "invalid syntax"}}], ["6337f4a6c58d2b7abdd69d0ec98fed80", {"code_string": "def get_trailing_number(s):\n    m = re.search(r'\\d+$', s)\n    return int(m.group() if m else None\n", "code_toks_joined": "def get_trailing_number ( s ) : <NEWLINE> <INDENT> m = re . search ( <STRING> , s ) <NEWLINE> return int ( m . group ( ) if m else None <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["r'\\d+$'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["74cf4dbc3c6888ecbf794e8a29857571", {"code_string": "def add_impulse(self, delta_xdot, delta_ydot):\n    \"\"\" Change the momentum of the ball\"\"\"\n        self.xdot += delta_xdot / 5.0\n        self.ydot += delta_ydot / 5.0\n        self._clip(self.xdot)\n        self._clip(self.ydot)\n", "code_toks_joined": "def add_impulse ( self , delta_xdot , delta_ydot ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> self . xdot += delta_xdot / 5.0 <NEWLINE> self . ydot += delta_ydot / 5.0 <NEWLINE> self . _clip ( self . xdot ) <NEWLINE> self . _clip ( self . ydot ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Change the momentum of the ball\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["1e317947b45b9e2c966d40cdd3506073", {"code_string": "def GetClines(self):\n    print(\"Now getting Jokercccam clines!\")\n    jokerClines = []\n    jokerClines.append(self.__GetJokerCline(1))\n    jokerClines.append(self.__GetJokerCline(2))\n    jokerClines.append(self.__GetJokerCline(3))\n    jokerClines.append(self.__GetJokerCline(4))\n    jokerClines.append(self.__GetJokerCline(5))\n    jokerClines.append(self.__GetJokerCline(6))\n    jokerClines = filter(None, jokerClines)\n    if len(jokerClines) == 0: print \"No Jokercccam lines retrieved\"\n    return jokerClines\n", "code_toks_joined": "def GetClines ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> jokerClines = [ ] <NEWLINE> jokerClines . append ( self . __GetJokerCline ( 1 ) ) <NEWLINE> jokerClines . append ( self . __GetJokerCline ( 2 ) ) <NEWLINE> jokerClines . append ( self . __GetJokerCline ( 3 ) ) <NEWLINE> jokerClines . append ( self . __GetJokerCline ( 4 ) ) <NEWLINE> jokerClines . append ( self . __GetJokerCline ( 5 ) ) <NEWLINE> jokerClines . append ( self . __GetJokerCline ( 6 ) ) <NEWLINE> jokerClines = filter ( None , jokerClines ) <NEWLINE> if len ( jokerClines ) == 0 : print <STRING> <NEWLINE> return jokerClines <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Now getting Jokercccam clines!\"", "\"No Jokercccam lines retrieved\""]}, "err_obj": {"msg": "invalid syntax"}}], ["a46af954b210136b356308a722138907", {"code_string": "def retranslateUi(self, AddParamGui):\n    AddParamGui.setWindowTitle(QtGui.QApplication.translate(\"AddParamGui\", \"Add New Parameter\", None, QtGui.QApplication.UnicodeUTF8))\n    self.attributesBox.setTitle(QtGui.QApplication.translate(\"AddParamGui\", \"Parameter Attributes\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label.setText(QtGui.QApplication.translate(\"AddParamGui\", \"Name\", None, QtGui.QApplication.UnicodeUTF8))\n    self.typeComboBox.setItemText(0, QtGui.QApplication.translate(\"AddParamGui\", \"string\", None, QtGui.QApplication.UnicodeUTF8))\n    self.typeComboBox.setItemText(1, QtGui.QApplication.translate(\"AddParamGui\", \"dir_path\", None, QtGui.QApplication.UnicodeUTF8))\n    self.typeComboBox.setItemText(2, QtGui.QApplication.translate(\"AddParamGui\", \"file_path\", None, QtGui.QApplication.UnicodeUTF8))\n    self.typeComboBox.setItemText(3, QtGui.QApplication.translate(\"AddParamGui\", \"db_connection_hook\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_2.setText(QtGui.QApplication.translate(\"AddParamGui\", \"Type\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_3.setText(QtGui.QApplication.translate(\"AddParamGui\", \"Default\", None, QtGui.QApplication.UnicodeUTF8))\n    self.requiredComboBox.setItemText(0, QtGui.QApplication.translate(\"AddParamGui\", \"True\", None, QtGui.QApplication.UnicodeUTF8))\n    self.requiredComboBox.setItemText(1, QtGui.QApplication.translate(\"AddParamGui\", \"False\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_4.setText(QtGui.QApplication.translate(\"AddParamGui\", \"Required\", None, QtGui.QApplication.UnicodeUTF8))\n    self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_3), QtGui.QApplication.translate(\"AddParamGui\", \"Tool Setup\", None, QtGui.QApplication.UnicodeUTF8))\n    self.toolhelpEdit.setHtml(QtGui.QApplication.translate(\"AddParamGui\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , AddParamGui ) : <NEWLINE> <INDENT> AddParamGui . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . attributesBox . setTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . typeComboBox . setItemText ( 0 , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . typeComboBox . setItemText ( 1 , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . typeComboBox . setItemText ( 2 , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . typeComboBox . setItemText ( 3 , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_2 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_3 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . requiredComboBox . setItemText ( 0 , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . requiredComboBox . setItemText ( 1 , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_4 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . tabWidget . setTabText ( self . tabWidget . indexOf ( self . tab_3 ) , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . toolhelpEdit . setHtml ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"AddParamGui\"", "\"Add New Parameter\"", "\"AddParamGui\"", "\"Parameter Attributes\"", "\"AddParamGui\"", "\"Name\"", "\"AddParamGui\"", "\"string\"", "\"AddParamGui\"", "\"dir_path\"", "\"AddParamGui\"", "\"file_path\"", "\"AddParamGui\"", "\"db_connection_hook\"", "\"AddParamGui\"", "\"Type\"", "\"AddParamGui\"", "\"Default\"", "\"AddParamGui\"", "\"True\"", "\"AddParamGui\"", "\"False\"", "\"AddParamGui\"", "\"Required\"", "\"AddParamGui\"", "\"Tool Setup\"", "\"AddParamGui\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "window_span": [374, 386], "err_obj": {"msg": "unbalanced (){}[]"}}], ["06fdde9147d51d5ee8a00d889fd147d2", {"code_string": "Gauss Psudocode\nHave the function import two equations from equations.py\nHave the user input an initial guess for one of them.\nx = Do f2(user_input_guess)\nLoop till % error is small:\n    y = f1(x)\n    x = f2(y)\nIf the error keeps getting larger, then switch the functions.\nDisplay the intercection point to the user.\nClass Psudocode\ninput functions\ninput\ninput initial guess\nWhile error > desired error:\n    for i in range(\n        solve each function\n        calculate error\n            (x2 - x1) /(y2 - y1) = % error\n        check for divergence\n", "code_toks_joined": "Gauss Psudocode <NEWLINE> Have the function import two equations from equations . py <NEWLINE> Have the user input an initial guess for one of them . <NEWLINE> x = Do f2 ( user_input_guess ) <NEWLINE> Loop till % error is small : <NEWLINE> <INDENT> y = f1 ( x ) <NEWLINE> x = f2 ( y ) <NEWLINE> <DEDENT> If the error keeps getting larger , then switch the functions . <NEWLINE> Display the intercection point to the user . <NEWLINE> Class Psudocode <NEWLINE> input functions <NEWLINE> input <NEWLINE> input initial guess <NEWLINE> While error > desired error : <NEWLINE> <INDENT> for i in range ( <NEWLINE> <INDENT> solve each function <NEWLINE> calculate error <NEWLINE> <INDENT> ( x2 - x1 ) / ( y2 - y1 ) = % error <NEWLINE> <DEDENT> check for divergence <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "window_span": [105, 138], "err_obj": {"msg": "unbalanced (){}[]"}}], ["b442b12e77d5a2969b3b6a2beffe688a", {"code_string": "def getResult(endpoint, parameters = None):\n    if parameters:\n        parameter_string = urllib.urlencode(parameters)\n        path = ''.join([endpoint + '?', parameter_string])\n    else:\n        path = endpoint\n    endpoint_result = session.get(urljoin(baseurl, path))\n    httpErrors(endpoint_result.status_code, path, endpoint_result.json())\n    if debug:\n        print \">>>\\n\" + json.dumps(endpoint_result.json(), indent = 2) + \"\\n<<<\\n\"\n    return endpoint_result.json()\n", "code_toks_joined": "def getResult ( endpoint , parameters = None ) : <NEWLINE> <INDENT> if parameters : <NEWLINE> <INDENT> parameter_string = urllib . urlencode ( parameters ) <NEWLINE> path = <STRING> . join ( [ endpoint + <STRING> , parameter_string ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> path = endpoint <NEWLINE> <DEDENT> endpoint_result = session . get ( urljoin ( baseurl , path ) ) <NEWLINE> httpErrors ( endpoint_result . status_code , path , endpoint_result . json ( ) ) <NEWLINE> if debug : <NEWLINE> <INDENT> print <STRING> + json . dumps ( endpoint_result . json ( ) , indent = 2 ) + <STRING> <NEWLINE> <DEDENT> return endpoint_result . json ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "'?'", "\">>>\\n\"", "\"\\n<<<\\n\""]}, "err_obj": {"msg": "invalid syntax"}}], ["5f483f52083e3b65fc606a26ecac2f9e", {"code_string": "def test_init_defaults(self):\n    self.assertEqual(self.pageable, self.pyager.pageable)\n    self.assertEqual(self.url, self.pyager.url)\n    self.assertEqual(1, self.pyager.page)\n    self.assertEqual(10 self.pyager.page_size)\n    self.assertEqual(3, self.pyager.window)\n", "code_toks_joined": "def test_init_defaults ( self ) : <NEWLINE> <INDENT> self . assertEqual ( self . pageable , self . pyager . pageable ) <NEWLINE> self . assertEqual ( self . url , self . pyager . url ) <NEWLINE> self . assertEqual ( 1 , self . pyager . page ) <NEWLINE> self . assertEqual ( 10 self . pyager . page_size ) <NEWLINE> self . assertEqual ( 3 , self . pyager . window ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["fcb4136eceb27379e38afd484e82525b", {"code_string": "def retranslateUi(self, Dialog):\n    Dialog.setWindowTitle(_(\"This book is DRMed\"))\n    self.msg.setText(_(\"<p>This book is locked by <b>DRM</b>. To learn more about DRM and why you cannot read or convert this book in calibre, \\n\"\n", "code_toks_joined": "def retranslateUi ( self , Dialog ) : <NEWLINE> <INDENT> Dialog . setWindowTitle ( _ ( <STRING> ) ) <NEWLINE> self . msg . setText ( _ ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"This book is DRMed\"", "\"<p>This book is locked by <b>DRM</b>. To learn more about DRM and why you cannot read or convert this book in calibre, \\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e1367a1aa08d936af4dcc84f018ee055", {"code_string": "def test_default_is_empty(self):\n    \"\"\"Verify a new default collection is empty.\"\"\"\n    assert len(self._get_collection() == 0\n", "code_toks_joined": "def test_default_is_empty ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> assert len ( self . _get_collection ( ) == 0 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Verify a new default collection is empty.\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["5c81f0d74bd7936d522cb9b2eb360593", {"code_string": "def poll_for_decision_tasks(swf, domain, task_list, identity):\n    paginator = swf.get_paginator('poll_for_decision_task')\n    result = None\n    for page in paginator.paginate(domain = domain, taskList = {'name': task_list},\n        identity = identity):\n        if result is None:\n        result = page\n        else:\n        result['events'].extend(page['events'])\n    return result\n", "code_toks_joined": "def poll_for_decision_tasks ( swf , domain , task_list , identity ) : <NEWLINE> <INDENT> paginator = swf . get_paginator ( <STRING> ) <NEWLINE> result = None <NEWLINE> for page in paginator . paginate ( domain = domain , taskList = { <STRING> : task_list } , <NEWLINE> <INDENT> identity = identity ) : <NEWLINE> if result is None : <NEWLINE> result = page <NEWLINE> else : <NEWLINE> result [ <STRING> ] . extend ( page [ <STRING> ] ) <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'poll_for_decision_task'", "'name'", "'events'", "'events'"]}, "err_obj": {"msg": "expected an indented block"}}], ["db42f0d9a4c8ea5940c9905b9328c31a", {"code_string": "def addToPlaylist(user, name, songs):\n    scope = 'playlist-modify-public'\n    usageToken = util.prompt_for_user_token(username = user['username'],\n        client_id = user['client_id'],\n        client_secret = user['client_secret'],\n        redirect_uri = user['redirect_uri'],\n        scope = scope)\n    if usageToken:\n    sp = spotipy.Spotify(auth = usageToken)\n    playlist_id = getPlaylist(user, name)\n    sp.user_playlist_add_tracks(user['username'], playlist_id, songs)\n", "code_toks_joined": "def addToPlaylist ( user , name , songs ) : <NEWLINE> <INDENT> scope = <STRING> <NEWLINE> usageToken = util . prompt_for_user_token ( username = user [ <STRING> ] , <NEWLINE> <INDENT> client_id = user [ <STRING> ] , <NEWLINE> client_secret = user [ <STRING> ] , <NEWLINE> redirect_uri = user [ <STRING> ] , <NEWLINE> scope = scope ) <NEWLINE> <DEDENT> if usageToken : <NEWLINE> sp = spotipy . Spotify ( auth = usageToken ) <NEWLINE> playlist_id = getPlaylist ( user , name ) <NEWLINE> sp . user_playlist_add_tracks ( user [ <STRING> ] , playlist_id , songs ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'playlist-modify-public'", "'username'", "'client_id'", "'client_secret'", "'redirect_uri'", "'username'"]}, "err_obj": {"msg": "expected an indented block"}}], ["504a57fe017790b7562ebbd307d581b2", {"code_string": "def saveCredentials(self):\n    \"\"\"Save current state to the JSON file.\"\"\"\n        credentials = {\n            \"username\": self.username,\n            \"password\": self.password,\n            \"auth_basic\": self.auth_basic,\n            \"access_token\": self.access_token,\n            \"token_expiry\": self.token_expiry\n        }\n        with open(self.credentials_file, \"w\") as credentials_file:\n            json.dump(credentials, credentials_file, indent = 4)\n", "code_toks_joined": "def saveCredentials ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> credentials = { <NEWLINE> <INDENT> <STRING> : self . username , <NEWLINE> <STRING> : self . password , <NEWLINE> <STRING> : self . auth_basic , <NEWLINE> <STRING> : self . access_token , <NEWLINE> <STRING> : self . token_expiry <NEWLINE> <DEDENT> } <NEWLINE> with open ( self . credentials_file , <STRING> ) as credentials_file : <NEWLINE> <INDENT> json . dump ( credentials , credentials_file , indent = 4 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Save current state to the JSON file.\"\"\"", "\"username\"", "\"password\"", "\"auth_basic\"", "\"access_token\"", "\"token_expiry\"", "\"w\""]}, "err_obj": {"msg": "unexpected indent"}}], ["a5a98ac548a396780929a6ba9f58f99d", {"code_string": "def _scrollXNow(self, first, last):\n    self._horizScrollbar.set(first, last)\n    self._horizScrollbarNeeded = ((first, last) !=('0', '1'))\n    if self['hscrollmode'] == 'dynamic':\n    if self._horizScrollbarNeeded != self._horizScrollbarOn:\n    self._toggleHorizScrollbar()\n", "code_toks_joined": "def _scrollXNow ( self , first , last ) : <NEWLINE> <INDENT> self . _horizScrollbar . set ( first , last ) <NEWLINE> self . _horizScrollbarNeeded = ( ( first , last ) != ( <STRING> , <STRING> ) ) <NEWLINE> if self [ <STRING> ] == <STRING> : <NEWLINE> if self . _horizScrollbarNeeded != self . _horizScrollbarOn : <NEWLINE> self . _toggleHorizScrollbar ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'0'", "'1'", "'hscrollmode'", "'dynamic'"]}, "err_obj": {"msg": "expected an indented block"}}], ["402a03bcae8fb3f66af2aa84eecdef6d", {"code_string": "class ErrorHandler(pybindgen.settings.ErrorHandler):\n    def handle_error(self, wrapper, exception, traceback_):\n        warnings.warn(\"exception %r in wrapper %s\" %(exception, wrapper)\n        return True\n", "code_toks_joined": "class ErrorHandler ( pybindgen . settings . ErrorHandler ) : <NEWLINE> <INDENT> def handle_error ( self , wrapper , exception , traceback_ ) : <NEWLINE> <INDENT> warnings . warn ( <STRING> % ( exception , wrapper ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"exception %r in wrapper %s\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e6ea3bc9d2bc9666bef42279b4c2fbb2", {"code_string": "def getSubPanelBody(self):\n    refBugListText = \"\"\n    isUrgent = False\n    for b in self.bugs:\n        refBugListText += \"* Bug %s - %s\\n\" %(b.number, b.subject)\n        isUrgent = b.isUrgent\n        template = HPACTION_BODY\n        if isUrgent:\n        template = HPACTION_URGENT_BODY\n    body = template %(refBugListText, \",\".join(self.refBugNumbers))\n    return SUBPANEL_BODY %(self.refBugNumbers[0], body)\n", "code_toks_joined": "def getSubPanelBody ( self ) : <NEWLINE> <INDENT> refBugListText = <STRING> <NEWLINE> isUrgent = False <NEWLINE> for b in self . bugs : <NEWLINE> <INDENT> refBugListText += <STRING> % ( b . number , b . subject ) <NEWLINE> isUrgent = b . isUrgent <NEWLINE> template = HPACTION_BODY <NEWLINE> if isUrgent : <NEWLINE> template = HPACTION_URGENT_BODY <NEWLINE> <DEDENT> body = template % ( refBugListText , <STRING> . join ( self . refBugNumbers ) ) <NEWLINE> return SUBPANEL_BODY % ( self . refBugNumbers [ 0 ] , body ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"", "\"* Bug %s - %s\\n\"", "\",\""]}, "err_obj": {"msg": "expected an indented block"}}], ["6a044dea406190c338af9288ee06ec74", {"code_string": "def do_timed_action(self, duration = False):\n    if duration:\n    ms_duration = int(round(duration * 1000 / self.timestep) * self.timestep)\n    else: ms_duration = self.timestep\n    if self.getMode() == 0:\n    self.step(ms_duration)\n    else:\n    print(\"Doing timed robot action\")\n    self.step(ms_duration)\n    self.stop_moving()\n    self.step(self.timestep)\n", "code_toks_joined": "def do_timed_action ( self , duration = False ) : <NEWLINE> <INDENT> if duration : <NEWLINE> ms_duration = int ( round ( duration * 1000 / self . timestep ) * self . timestep ) <NEWLINE> else : ms_duration = self . timestep <NEWLINE> if self . getMode ( ) == 0 : <NEWLINE> self . step ( ms_duration ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> self . step ( ms_duration ) <NEWLINE> self . stop_moving ( ) <NEWLINE> self . step ( self . timestep ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Doing timed robot action\""]}, "err_obj": {"msg": "expected an indented block"}}], ["f39f8f3570cbde0e2682f4f3c17bcad2", {"code_string": "def main():\n    args = sys.argv[1: ]\n    if not args:\n        print('usage: [--summaryfile] file [file ...]')\n        sys.exit(1)\n    if args[0] == '--summaryfile':\n        global summary\n        summary = True\n        del args[0]\n    for one_file in args:\n    extract_names(one_file)\n", "code_toks_joined": "def main ( ) : <NEWLINE> <INDENT> args = sys . argv [ 1 : ] <NEWLINE> if not args : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> if args [ 0 ] == <STRING> : <NEWLINE> <INDENT> global summary <NEWLINE> summary = True <NEWLINE> del args [ 0 ] <NEWLINE> <DEDENT> for one_file in args : <NEWLINE> extract_names ( one_file ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'usage: [--summaryfile] file [file ...]'", "'--summaryfile'"]}, "err_obj": {"msg": "expected an indented block"}}], ["9e93da9ccc6397c293e56616c80d539a", {"code_string": "def pos_servo(servo, pos):\n    if(debugLevel): print \"rwp: pos_servo(Tilt0Pan1=%d, pos=%d)\" %(servo, pos)\n    if(servo == PANSERVO):\n        cpos = myPyLib.clamp(pos, PanPosLimitR, PanPosLimitL)\n    elif(servo == TILTSERVO):\n        cpos = myPyLib.clamp(pos, TiltPosLimitUp, TiltPosLimitDn)\n    if(debugLevel): print \"setting Tilt0Pan1=%d to pos: %d)\" %(servo, cpos)\n    myPDALib.servoWrite(servo, cpos)\n    return cpos\n", "code_toks_joined": "def pos_servo ( servo , pos ) : <NEWLINE> <INDENT> if ( debugLevel ) : print <STRING> % ( servo , pos ) <NEWLINE> if ( servo == PANSERVO ) : <NEWLINE> <INDENT> cpos = myPyLib . clamp ( pos , PanPosLimitR , PanPosLimitL ) <NEWLINE> <DEDENT> elif ( servo == TILTSERVO ) : <NEWLINE> <INDENT> cpos = myPyLib . clamp ( pos , TiltPosLimitUp , TiltPosLimitDn ) <NEWLINE> <DEDENT> if ( debugLevel ) : print <STRING> % ( servo , cpos ) <NEWLINE> myPDALib . servoWrite ( servo , cpos ) <NEWLINE> return cpos <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"rwp: pos_servo(Tilt0Pan1=%d, pos=%d)\"", "\"setting Tilt0Pan1=%d to pos: %d)\""]}, "err_obj": {"msg": "invalid syntax"}}], ["8c833a1167de319132e5798686667a87", {"code_string": "def _undo_pusher_selection(self, selection_moves):\n    path = [am.direction.opposite for am in selection_moves]\n    old_position = self._state.pusher_position(self._selected_pusher)\n    new_position = self._state.board.path_destination(old_position, path)\n    self.select_pusher(self._state.pusher_id_on(new_position)\n", "code_toks_joined": "def _undo_pusher_selection ( self , selection_moves ) : <NEWLINE> <INDENT> path = [ am . direction . opposite for am in selection_moves ] <NEWLINE> old_position = self . _state . pusher_position ( self . _selected_pusher ) <NEWLINE> new_position = self . _state . board . path_destination ( old_position , path ) <NEWLINE> self . select_pusher ( self . _state . pusher_id_on ( new_position ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["95ffeabaeb246b3daf60fba0b15c93d4", {"code_string": "def _get_rpls_from_purchase_requests(self, cr, uid, ids, context = None):\n    rpl_ids = []\n    for request in self.pool['purchase.request'].browse(\n        cr, uid, ids, context = context):\n        for request_line in request.line_ids:\n        for rpl in request_line.analytic_resource_plan_lines:\n            rpl_ids.append(rpl.id)\n    return list(set(rpl_ids))\n", "code_toks_joined": "def _get_rpls_from_purchase_requests ( self , cr , uid , ids , context = None ) : <NEWLINE> <INDENT> rpl_ids = [ ] <NEWLINE> for request in self . pool [ <STRING> ] . browse ( <NEWLINE> <INDENT> cr , uid , ids , context = context ) : <NEWLINE> for request_line in request . line_ids : <NEWLINE> for rpl in request_line . analytic_resource_plan_lines : <NEWLINE> <INDENT> rpl_ids . append ( rpl . id ) <NEWLINE> <DEDENT> <DEDENT> return list ( set ( rpl_ids ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'purchase.request'"]}, "err_obj": {"msg": "expected an indented block"}}], ["5ebd2f1275daec74a5ee18569afe6df8", {"code_string": "def unprefix(localpath, prefix):\n    if re.search('^' + prefix, localpath):\n    if re.search('/$', prefix):\n        prefix = prefix[: - 1];\n        return localpath[len(prefix): ];\n    else:\n        print(\"Path does not belong to systamp tree\")\n        sys.exit(1);\n", "code_toks_joined": "def unprefix ( localpath , prefix ) : <NEWLINE> <INDENT> if re . search ( <STRING> + prefix , localpath ) : <NEWLINE> if re . search ( <STRING> , prefix ) : <NEWLINE> <INDENT> prefix = prefix [ : - 1 ] ; <NEWLINE> return localpath [ len ( prefix ) : ] ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 1 ) ; <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'^'", "'/$'", "\"Path does not belong to systamp tree\""]}, "err_obj": {"msg": "expected an indented block"}}], ["454962267b2caa69fa4fa6e2de965073", {"code_string": "def test_scan_with_select_clause(self):\n    ns = 'test'\n    st = 'demo'\n    records = []\n    scan_obj = None\n    def callback((key, meta, bins)):\n        records.append(bins)\n    scan_obj = self.client.scan(ns, st)\n    scan_obj.select('name')\n    scan_obj.foreach(callback)\n    assert len(records) != 0\n", "code_toks_joined": "def test_scan_with_select_clause ( self ) : <NEWLINE> <INDENT> ns = <STRING> <NEWLINE> st = <STRING> <NEWLINE> records = [ ] <NEWLINE> scan_obj = None <NEWLINE> def callback ( ( key , meta , bins ) ) : <NEWLINE> <INDENT> records . append ( bins ) <NEWLINE> <DEDENT> scan_obj = self . client . scan ( ns , st ) <NEWLINE> scan_obj . select ( <STRING> ) <NEWLINE> scan_obj . foreach ( callback ) <NEWLINE> assert len ( records ) != 0 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'test'", "'demo'", "'name'"]}, "err_obj": {"msg": "invalid syntax"}}], ["dc9551bc5499229c3f23bf4c81e3551e", {"code_string": "def get_icon(name):\n    path = os.path.dirname(os.path.realpath(__file__)\n    path = os.path.join(path, \"icons/%s.png\" % name)\n    icon = QtGui.QIcon(path)\n    return icon\n", "code_toks_joined": "def get_icon ( name ) : <NEWLINE> <INDENT> path = os . path . dirname ( os . path . realpath ( __file__ ) <NEWLINE> path = os . path . join ( path , <STRING> % name ) <NEWLINE> icon = QtGui . QIcon ( path ) <NEWLINE> return icon <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"icons/%s.png\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["ba1e8deafd6613ae2b4254a08231a282", {"code_string": "from{{cookiecutter.project_slug}}.app import app\nflask_app = app.app\nflask_app.testing = True\nclient = flask_app.test_client()\n", "code_toks_joined": "from { { cookiecutter . project_slug } } . app import app <NEWLINE> flask_app = app . app <NEWLINE> flask_app . testing = True <NEWLINE> client = flask_app . test_client ( ) <NEWLINE>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["15fc00b15563f90e1791e0a53e2aa4fe", {"code_string": "def retranslateUi(self, ventanaprincipal):\n    ventanaprincipal.setWindowTitle(QtGui.QApplication.translate(\"ventanaprincipal\", \"Contrarreloj\", None, QtGui.QApplication.UnicodeUTF8))\n    self.labelTiempo.setText(QtGui.QApplication.translate(\"ventanaprincipal\", \"<center>00:00:00</center>\", None, QtGui.QApplication.UnicodeUTF8))\n    self.botonIniciar.setText(QtGui.QApplication.translate(\"ventanaprincipal\", \"Iniciar/Parar\", None, QtGui.QApplication.UnicodeUTF8))\n    self.botonCortar.setText(QtGui.QApplication.translate(\"ventanaprincipal\", \"Cortar\", None, QtGui.QApplication.UnicodeUTF8))\n    self.botonborrarultimo.setText(QtGui.QApplication.translate(\"ventanaprincipal\", \"Borrar el \u00faltimo\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_2.setText(QtGui.QApplication.translate(\"ventanaprincipal\", \"Inscritos:\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label.setText(QtGui.QApplication.translate(\"ventanaprincipal\", \"Han\\n\"\n", "code_toks_joined": "def retranslateUi ( self , ventanaprincipal ) : <NEWLINE> <INDENT> ventanaprincipal . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . labelTiempo . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . botonIniciar . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . botonCortar . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . botonborrarultimo . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_2 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"ventanaprincipal\"", "\"Contrarreloj\"", "\"ventanaprincipal\"", "\"<center>00:00:00</center>\"", "\"ventanaprincipal\"", "\"Iniciar/Parar\"", "\"ventanaprincipal\"", "\"Cortar\"", "\"ventanaprincipal\"", "\"Borrar el \u00faltimo\"", "\"ventanaprincipal\"", "\"Inscritos:\"", "\"ventanaprincipal\"", "\"Han\\n\""]}, "window_span": [169, 181], "err_obj": {"msg": "unbalanced (){}[]"}}], ["75e869cc128c0818aaa8cf6274697fbd", {"code_string": "def setupUi(self, ProdPrep):\n    ProdPrep.setObjectName(_fromUtf8(\"ProdPrep\"))\n    ProdPrep.resize(602, 551)\n    icon = QtGui.QIcon()\n    icon.addPixmap(QtGui.QPixmap(_fromUtf8(\":/icons/prep\")), QtGui.QIcon.Normal, QtGui.QIcon.Off)\n    ProdPrep.setWindowIcon(icon)\n    self.verticalLayout_2 = QtGui.QVBoxLayout(ProdPrep)\n    self.verticalLayout_2.setObjectName(_fromUtf8(\"verticalLayout_2\"))\n    self.verticalLayout = QtGui.QVBoxLayout()\n    self.verticalLayout.setObjectName(_fromUtf8(\"verticalLayout\"))\n    self.frame = QtGui.QFrame(ProdPrep)\n    self.frame.setFrameShape(QtGui.QFrame.StyledPanel)\n    self.frame.setFrameShadow(QtGui.QFrame.Raised)\n    self.frame.setObjectName(_fromUtf8(\"frame\"))\n    self.gridLayout = QtGui.QGridLayout(self.frame)\n    self.gridLayout.setObjectName(_fromUtf8(\"gridLayout\"))\n    self.label_11 = QtGui.QLabel(self.frame)\n    font = QtGui.QFont()\n    font.setFamily(_fromUtf8(\"Calibri\"))\n    font.setPointSize(20)\n    font.setBold(True)\n    font.setItalic(True)\n    font.setUnderline(True)\n    font.setWeight(75)\n    self.label_11.setFont(font)\n    self.label_11.setObjectName(_fromUtf8(\"label_11\"))\n    self.gridLayout.addWidget(self.label_11, 0, 0, 1, 1)\n    self.verticalLayout.addWidget(self.frame)\n    self.frame_4 = QtGui.QFrame(ProdPrep)\n    self.frame_4.setAutoFillBackground(False)\n    self.frame_4.setStyleSheet(_fromUtf8(\"QFrame {border: none;\\n\"\n", "code_toks_joined": "def setupUi ( self , ProdPrep ) : <NEWLINE> <INDENT> ProdPrep . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> ProdPrep . resize ( 602 , 551 ) <NEWLINE> icon = QtGui . QIcon ( ) <NEWLINE> icon . addPixmap ( QtGui . QPixmap ( _fromUtf8 ( <STRING> ) ) , QtGui . QIcon . Normal , QtGui . QIcon . Off ) <NEWLINE> ProdPrep . setWindowIcon ( icon ) <NEWLINE> self . verticalLayout_2 = QtGui . QVBoxLayout ( ProdPrep ) <NEWLINE> self . verticalLayout_2 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . verticalLayout = QtGui . QVBoxLayout ( ) <NEWLINE> self . verticalLayout . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . frame = QtGui . QFrame ( ProdPrep ) <NEWLINE> self . frame . setFrameShape ( QtGui . QFrame . StyledPanel ) <NEWLINE> self . frame . setFrameShadow ( QtGui . QFrame . Raised ) <NEWLINE> self . frame . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout = QtGui . QGridLayout ( self . frame ) <NEWLINE> self . gridLayout . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label_11 = QtGui . QLabel ( self . frame ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setFamily ( _fromUtf8 ( <STRING> ) ) <NEWLINE> font . setPointSize ( 20 ) <NEWLINE> font . setBold ( True ) <NEWLINE> font . setItalic ( True ) <NEWLINE> font . setUnderline ( True ) <NEWLINE> font . setWeight ( 75 ) <NEWLINE> self . label_11 . setFont ( font ) <NEWLINE> self . label_11 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout . addWidget ( self . label_11 , 0 , 0 , 1 , 1 ) <NEWLINE> self . verticalLayout . addWidget ( self . frame ) <NEWLINE> self . frame_4 = QtGui . QFrame ( ProdPrep ) <NEWLINE> self . frame_4 . setAutoFillBackground ( False ) <NEWLINE> self . frame_4 . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"ProdPrep\"", "\":/icons/prep\"", "\"verticalLayout_2\"", "\"verticalLayout\"", "\"frame\"", "\"gridLayout\"", "\"Calibri\"", "\"label_11\"", "\"QFrame {border: none;\\n\""]}, "window_span": [332, 338], "err_obj": {"msg": "unbalanced (){}[]"}}], ["ebdb5c38d056c89e39ea425fb3b02983", {"code_string": "from paravistest import datadir, Import_Med_Field\nimport pvserver as paravis\nmed_file = datadir + \"maill.0.med\"\nfield_names = [\"REQT_GD_________________________\", \"RESUTRQUDEPL____________________\", \"RESUTRQUERRE_ELGA_NORE__________\", \"RESUTRQUSIEF_ELGA_DEPL__________\", \"RESUTRQUSIGM_ELNO_DEPL__________\"]\nprs_list = [range(1, 10), range(1, 10), range(10), range(10), range(10)])\nImport_Med_Field(paravis.myParavis, med_file, field_names, 1, prs_list)\n", "code_toks_joined": "from paravistest import datadir , Import_Med_Field <NEWLINE> import pvserver as paravis <NEWLINE> med_file = datadir + <STRING> <NEWLINE> field_names = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> prs_list = [ range ( 1 , 10 ) , range ( 1 , 10 ) , range ( 10 ) , range ( 10 ) , range ( 10 ) ] ) <NEWLINE> Import_Med_Field ( paravis . myParavis , med_file , field_names , 1 , prs_list ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"maill.0.med\"", "\"REQT_GD_________________________\"", "\"RESUTRQUDEPL____________________\"", "\"RESUTRQUERRE_ELGA_NORE__________\"", "\"RESUTRQUSIEF_ELGA_DEPL__________\"", "\"RESUTRQUSIGM_ELNO_DEPL__________\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["339246ff31534c3821135bbfc5559763", {"code_string": "def Dump(self, indent_header = ' ', indent_body = ''):\n    header_size = 18;\n    if self.notes:\n        notes = ' // ' + ', '.join(self.notes);\n    else:\n        notes = '';\n    simplified_values = None;\n    if self.dump_simplified:\n        if hasattr(self, 'SimplifiedValue'):\n            dump_value = self.SimplifiedValue();\n            brackets = False;\n        elif hasattr(self, 'SimplifiedValues'):\n            dump_value = '%s (0x%X|%d members)' %(self.type_name, len(self.value), len(self.value));\n            simplified_values = self.SimplifiedValues();\n            brackets = True;\n        else:\n            dump_value = '%s (0x%X|%d members)' %(self.type_name, len(self.value), len(self.value));\n            brackets = False;\n    else:\n        dump_value = self.type_name;\n        brackets = True;\n    if brackets:\n        open_bracket = ' {';\n    else:\n        open_bracket = '';\n    print(indent_header +('%08X+%08X ' %(self.offset, self.size)).ljust(header_size) + indent_body + '%s = %s%s' %(self.name, dump_value, open_bracket) + notes)\n    for warning in self.warnings:\n        print(indent_header + ''.ljust(header_size) + indent_body + '// *** Heads up! ' + warning)\n    if not self.dump_simplified:\n        for member in self.value:\n            member.Dump(indent_header, indent_body + '  ');\n    elif simplified_values:\n        for simplified_value in simplified_values:\n            print(indent_header + ''.ljust(header_size) + indent_body + '  ' + simplified_value)\n    off_by = self.offset + self.size - self.current_offset;\n    if off_by > 0:\n        print(indent_header + ''.ljust(header_size) + indent_body + '// *** Heads up! 0x%X|%d more bytes have not been assigned any ' 'use!' %(off_by, off_by))\n    if self.contained_stream and self.contained_value:\n        print(indent_header)\n        print(indent_header +('  +- 00000000 -- contents of %s ---' % self.contained_name).ljust(80, '-'))\n        if len(self.contained_sources) == 1:\n            print(indent_header + '  | // Source: %s' % self.contained_sources[0])\n        elif len(self.contained_sources) > 1:\n            print(indent_header + '  | // Sources: %s' % ', '.join(self.contained_sources))\n        for contained_member in self.contained_value:\n            contained_member.Dump(indent_header + '  | ');\n        if self.contained_current_max_size > 0:\n            print(indent_header + '  | // *** Heads up! 0x%X|%d more bytes have ' 'not been assigned any use!' %(self.contained_current_max_size,\n                self.contained_current_max_size);\n        print(indent_header +('  +- %08X --- end contents %s ---' %(self.contained_max_size, self.contained_name)).ljust(80, '-'))\n        print(indent_header)\n    if brackets:\n        print(indent_header +('%08X' %(self.offset + self.size)).ljust(header_size) + indent_body + '} // end %s %s' %(self.type_name, self.name))\n", "code_toks_joined": "def Dump ( self , indent_header = <STRING> , indent_body = <STRING> ) : <NEWLINE> <INDENT> header_size = 18 ; <NEWLINE> if self . notes : <NEWLINE> <INDENT> notes = <STRING> + <STRING> . join ( self . notes ) ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> notes = <STRING> ; <NEWLINE> <DEDENT> simplified_values = None ; <NEWLINE> if self . dump_simplified : <NEWLINE> <INDENT> if hasattr ( self , <STRING> ) : <NEWLINE> <INDENT> dump_value = self . SimplifiedValue ( ) ; <NEWLINE> brackets = False ; <NEWLINE> <DEDENT> elif hasattr ( self , <STRING> ) : <NEWLINE> <INDENT> dump_value = <STRING> % ( self . type_name , len ( self . value ) , len ( self . value ) ) ; <NEWLINE> simplified_values = self . SimplifiedValues ( ) ; <NEWLINE> brackets = True ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dump_value = <STRING> % ( self . type_name , len ( self . value ) , len ( self . value ) ) ; <NEWLINE> brackets = False ; <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dump_value = self . type_name ; <NEWLINE> brackets = True ; <NEWLINE> <DEDENT> if brackets : <NEWLINE> <INDENT> open_bracket = <STRING> ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> open_bracket = <STRING> ; <NEWLINE> <DEDENT> print ( indent_header + ( <STRING> % ( self . offset , self . size ) ) . ljust ( header_size ) + indent_body + <STRING> % ( self . name , dump_value , open_bracket ) + notes ) <NEWLINE> for warning in self . warnings : <NEWLINE> <INDENT> print ( indent_header + <STRING> . ljust ( header_size ) + indent_body + <STRING> + warning ) <NEWLINE> <DEDENT> if not self . dump_simplified : <NEWLINE> <INDENT> for member in self . value : <NEWLINE> <INDENT> member . Dump ( indent_header , indent_body + <STRING> ) ; <NEWLINE> <DEDENT> <DEDENT> elif simplified_values : <NEWLINE> <INDENT> for simplified_value in simplified_values : <NEWLINE> <INDENT> print ( indent_header + <STRING> . ljust ( header_size ) + indent_body + <STRING> + simplified_value ) <NEWLINE> <DEDENT> <DEDENT> off_by = self . offset + self . size - self . current_offset ; <NEWLINE> if off_by > 0 : <NEWLINE> <INDENT> print ( indent_header + <STRING> . ljust ( header_size ) + indent_body + <STRING> <STRING> % ( off_by , off_by ) ) <NEWLINE> <DEDENT> if self . contained_stream and self . contained_value : <NEWLINE> <INDENT> print ( indent_header ) <NEWLINE> print ( indent_header + ( <STRING> % self . contained_name ) . ljust ( 80 , <STRING> ) ) <NEWLINE> if len ( self . contained_sources ) == 1 : <NEWLINE> <INDENT> print ( indent_header + <STRING> % self . contained_sources [ 0 ] ) <NEWLINE> <DEDENT> elif len ( self . contained_sources ) > 1 : <NEWLINE> <INDENT> print ( indent_header + <STRING> % <STRING> . join ( self . contained_sources ) ) <NEWLINE> <DEDENT> for contained_member in self . contained_value : <NEWLINE> <INDENT> contained_member . Dump ( indent_header + <STRING> ) ; <NEWLINE> <DEDENT> if self . contained_current_max_size > 0 : <NEWLINE> <INDENT> print ( indent_header + <STRING> <STRING> % ( self . contained_current_max_size , <NEWLINE> <INDENT> self . contained_current_max_size ) ; <NEWLINE> <DEDENT> <DEDENT> print ( indent_header + ( <STRING> % ( self . contained_max_size , self . contained_name ) ) . ljust ( 80 , <STRING> ) ) <NEWLINE> print ( indent_header ) <NEWLINE> <DEDENT> if brackets : <NEWLINE> <INDENT> print ( indent_header + ( <STRING> % ( self . offset + self . size ) ) . ljust ( header_size ) + indent_body + <STRING> % ( self . type_name , self . name ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["' '", "''", "' // '", "', '", "''", "'SimplifiedValue'", "'SimplifiedValues'", "'%s (0x%X|%d members)'", "'%s (0x%X|%d members)'", "' {'", "''", "'%08X+%08X '", "'%s = %s%s'", "''", "'// *** Heads up! '", "'  '", "''", "'  '", "''", "'// *** Heads up! 0x%X|%d more bytes have not been assigned any '", "'use!'", "'  +- 00000000 -- contents of %s ---'", "'-'", "'  | // Source: %s'", "'  | // Sources: %s'", "', '", "'  | '", "'  | // *** Heads up! 0x%X|%d more bytes have '", "'not been assigned any use!'", "'  +- %08X --- end contents %s ---'", "'-'", "'%08X'", "'} // end %s %s'"]}, "window_span": [513, 611], "err_obj": {"msg": "unbalanced (){}[]"}}], ["1dcc8eca146028ea56ee7cb62007f666", {"code_string": "def get_sync(self, byte_offset = 0):\n    block = ''\n        try:\n            block = os.read(self.file_fp, self.block_size)\n        except Exception as e:\n            frame = inspect.currentframe()\n            info = inspect.getframeinfo(frame)\n            print('\\t[read: an %s exception occured | line: %d]' %(type(e).__name__, info.lineno))\n            sys.exit(0);\n        return block\n", "code_toks_joined": "def get_sync ( self , byte_offset = 0 ) : <NEWLINE> <INDENT> block = <STRING> <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> block = os . read ( self . file_fp , self . block_size ) <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> <INDENT> frame = inspect . currentframe ( ) <NEWLINE> info = inspect . getframeinfo ( frame ) <NEWLINE> print ( <STRING> % ( type ( e ) . __name__ , info . lineno ) ) <NEWLINE> sys . exit ( 0 ) ; <NEWLINE> <DEDENT> return block <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "'\\t[read: an %s exception occured | line: %d]'"]}, "err_obj": {"msg": "unexpected indent"}}], ["f6610152e2915e211c208fe7fc751f1c", {"code_string": "def __init__(self):\n    super(BlobServiceAdapter, self).__init__(\n        BlobService(account_name = self.util.get_config(\"storage.azure.account_name\"),\n            account_key = self.util.get_config(\"storage.azure.account_key\"),\n            host_base = self.util.get_config(\"storage.azure.blob_service_host_base\"))\n", "code_toks_joined": "def __init__ ( self ) : <NEWLINE> <INDENT> super ( BlobServiceAdapter , self ) . __init__ ( <NEWLINE> <INDENT> BlobService ( account_name = self . util . get_config ( <STRING> ) , <NEWLINE> <INDENT> account_key = self . util . get_config ( <STRING> ) , <NEWLINE> host_base = self . util . get_config ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"storage.azure.account_name\"", "\"storage.azure.account_key\"", "\"storage.azure.blob_service_host_base\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["67767730577b2df4441c651582cd3a02", {"code_string": "def get_tileset_from_gid(self, gid):\n    \"\"\" Return tileset that owns the gid\"\"\"\n    try:\n        tiled_gid = self.tiledgidmap[gid]\n    except KeyError:\n        raise ValueError\n    for tileset in sorted(self.tilesets, key = attrgetter('firstgid'),\n        reverse = True):\n        if tiled_gid >= tileset.firstgid:\n        return tileset\n    raise ValueError\n", "code_toks_joined": "def get_tileset_from_gid ( self , gid ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> tiled_gid = self . tiledgidmap [ gid ] <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> raise ValueError <NEWLINE> <DEDENT> for tileset in sorted ( self . tilesets , key = attrgetter ( <STRING> ) , <NEWLINE> <INDENT> reverse = True ) : <NEWLINE> if tiled_gid >= tileset . firstgid : <NEWLINE> return tileset <NEWLINE> <DEDENT> raise ValueError <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Return tileset that owns the gid\"\"\"", "'firstgid'"]}, "err_obj": {"msg": "expected an indented block"}}], ["e7bca8a669ad34216c0f115d63bdec65", {"code_string": "def _assign_moving_average(self, variable, value, one_minus_decay):\n    with ops.name_scope(None, 'AssignMovingAvg',\n        [variable, value, one_minus_decay]) as scope:\n        with ops.colocate_with(variable):\n        update_delta = (variable.read_value() - value) * one_minus_decay\n        if isinstance(variable, resource_variable_ops.ResourceVariable):\n        return gen_resource_variable_ops.assign_sub_variable_op(\n        variable.handle, update_delta, name = scope)\n        else:\n        return state_ops.assign_sub(variable, update_delta, name = scope)\n", "code_toks_joined": "def _assign_moving_average ( self , variable , value , one_minus_decay ) : <NEWLINE> <INDENT> with ops . name_scope ( None , <STRING> , <NEWLINE> <INDENT> [ variable , value , one_minus_decay ] ) as scope : <NEWLINE> with ops . colocate_with ( variable ) : <NEWLINE> update_delta = ( variable . read_value ( ) - value ) * one_minus_decay <NEWLINE> if isinstance ( variable , resource_variable_ops . ResourceVariable ) : <NEWLINE> return gen_resource_variable_ops . assign_sub_variable_op ( <NEWLINE> variable . handle , update_delta , name = scope ) <NEWLINE> else : <NEWLINE> return state_ops . assign_sub ( variable , update_delta , name = scope ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'AssignMovingAvg'"]}, "err_obj": {"msg": "expected an indented block"}}], ["3587a3f71a456384ab113fbdfb498b15", {"code_string": "def parse(self, message):\n    message = message.strip(' \\t\\r\\n\\xff')\n    buf = \"\"\n    timestamp, message = self.parseTimestamp(message)\n    if timestamp is None:\n        buf += termcolor.colored(\"Server sent corrupt message: %s\" %(message), 'yellow') + \"\\n\"\n        return buf\n    for key in self.message_regex.keys():\n        match = self.message_regex[key].match(message)\n        if match:\n            result = match.groupdict()\n            exec \"buf += self.handle%s(result)\" % key\n            return buf\n    return buf\n", "code_toks_joined": "def parse ( self , message ) : <NEWLINE> <INDENT> message = message . strip ( <STRING> ) <NEWLINE> buf = <STRING> <NEWLINE> timestamp , message = self . parseTimestamp ( message ) <NEWLINE> if timestamp is None : <NEWLINE> <INDENT> buf += termcolor . colored ( <STRING> % ( message ) , <STRING> ) + <STRING> <NEWLINE> return buf <NEWLINE> <DEDENT> for key in self . message_regex . keys ( ) : <NEWLINE> <INDENT> match = self . message_regex [ key ] . match ( message ) <NEWLINE> if match : <NEWLINE> <INDENT> result = match . groupdict ( ) <NEWLINE> exec <STRING> % key <NEWLINE> return buf <NEWLINE> <DEDENT> <DEDENT> return buf <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["' \\t\\r\\n\\xff'", "\"\"", "\"Server sent corrupt message: %s\"", "'yellow'", "\"\\n\"", "\"buf += self.handle%s(result)\""]}, "err_obj": {"msg": "invalid syntax"}}], ["248f9c0d59a20a9ad3cd492c48d9b0a4", {"code_string": "def generateByteArray(size):\n    ba = mmh3.hash_bytes('', incrementSeed())\n    for i in xrange(size / 8):\n    ba = ba + mmh3.hash_bytes('', incrementSeed())\n    return bytearray(ba[0: size])\n", "code_toks_joined": "def generateByteArray ( size ) : <NEWLINE> <INDENT> ba = mmh3 . hash_bytes ( <STRING> , incrementSeed ( ) ) <NEWLINE> for i in xrange ( size / 8 ) : <NEWLINE> ba = ba + mmh3 . hash_bytes ( <STRING> , incrementSeed ( ) ) <NEWLINE> return bytearray ( ba [ 0 : size ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "''"]}, "err_obj": {"msg": "expected an indented block"}}], ["7b73883dac995bb679910224e10c0014", {"code_string": "def question(q):\n    global answer\n    answer = 0\n    print('SANDBOX %s' % q)\n    try:\n    time.sleep(3600)\n    except IOError:\n    pass\n    if answer == 0:\n    assert 0, 'User failed to respond within one hour'\n    print('User responded with ', answer)\n    return answer\n", "code_toks_joined": "def question ( q ) : <NEWLINE> <INDENT> global answer <NEWLINE> answer = 0 <NEWLINE> print ( <STRING> % q ) <NEWLINE> try : <NEWLINE> time . sleep ( 3600 ) <NEWLINE> except IOError : <NEWLINE> pass <NEWLINE> if answer == 0 : <NEWLINE> assert 0 , <STRING> <NEWLINE> print ( <STRING> , answer ) <NEWLINE> return answer <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'SANDBOX %s'", "'User failed to respond within one hour'", "'User responded with '"]}, "err_obj": {"msg": "expected an indented block"}}], ["34b3d9253dba5e5d51f775230118b4ec", {"code_string": "def combine_languages(self):\n    lang_list = [lang for lang in self.language_1, self.language_2, self.language_3 if lang]\n    languages = \", \".join(lang_list)\n    return languages\n", "code_toks_joined": "def combine_languages ( self ) : <NEWLINE> <INDENT> lang_list = [ lang for lang in self . language_1 , self . language_2 , self . language_3 if lang ] <NEWLINE> languages = <STRING> . join ( lang_list ) <NEWLINE> return languages <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\", \""]}, "err_obj": {"msg": "invalid syntax"}}], ["703cfe891dcad415b34adff0e9f7f048", {"code_string": "class LoggerDaemon(threading.Thread):\n    log = None\n    def __init__(self):\n        threading.Thread.__init__(self)\n        self.setDaemon(True)\n        self.log = logging.getLogger('digilogger')\n    def run(self):\n    self.log.debug(\"LoggerDaemon started.\")\n    canlogging_process(64, 0.1)\n    self.log.debug(\"LoggerDaemon exited.\")\n", "code_toks_joined": "class LoggerDaemon ( threading . Thread ) : <NEWLINE> <INDENT> log = None <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> threading . Thread . __init__ ( self ) <NEWLINE> self . setDaemon ( True ) <NEWLINE> self . log = logging . getLogger ( <STRING> ) <NEWLINE> <DEDENT> def run ( self ) : <NEWLINE> self . log . debug ( <STRING> ) <NEWLINE> canlogging_process ( 64 , 0.1 ) <NEWLINE> self . log . debug ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'digilogger'", "\"LoggerDaemon started.\"", "\"LoggerDaemon exited.\""]}, "err_obj": {"msg": "expected an indented block"}}], ["ec1a1cd98729120fb73996cab3e63c7e", {"code_string": "def test_failed_to_initialize_resolver(self):\n    err_msg = 'illegal default resolve initialization'\n    def mock_create_import_resolver(_):\n        raise ResolverInstantiationError(err_msg)\n    with mock.patch('dsl_parser.utils.create_import_resolver',\n        new = mock_create_import_resolver):\n        try:\n        self._update_provider_context()\n        self.fail('CloudifyClientError expected')\n        except CloudifyClientError, ex:\n        self.assertIn(err_msg, str(ex))\n", "code_toks_joined": "def test_failed_to_initialize_resolver ( self ) : <NEWLINE> <INDENT> err_msg = <STRING> <NEWLINE> def mock_create_import_resolver ( _ ) : <NEWLINE> <INDENT> raise ResolverInstantiationError ( err_msg ) <NEWLINE> <DEDENT> with mock . patch ( <STRING> , <NEWLINE> <INDENT> new = mock_create_import_resolver ) : <NEWLINE> try : <NEWLINE> self . _update_provider_context ( ) <NEWLINE> self . fail ( <STRING> ) <NEWLINE> except CloudifyClientError , ex : <NEWLINE> self . assertIn ( err_msg , str ( ex ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'illegal default resolve initialization'", "'dsl_parser.utils.create_import_resolver'", "'CloudifyClientError expected'"]}, "err_obj": {"msg": "expected an indented block"}}], ["7213d9419c304412e63ee244138ca85d", {"code_string": "def register_errorhandlers(app):\n    \"\"\"Register error handlers.\"\"\"\n    def render_error(error):\n        \"\"\"Render error template.\"\"\"\n        error_code = getattr(error, 'code', 500)\n        return render_template('{0}.html'.format(error_code))), error_code\n    for errcode in[401, 404, 500]:\n        app.errorhandler(errcode)(render_error)\n    return None\n", "code_toks_joined": "def register_errorhandlers ( app ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def render_error ( error ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> error_code = getattr ( error , <STRING> , 500 ) <NEWLINE> return render_template ( <STRING> . format ( error_code ) ) ) , error_code <NEWLINE> <DEDENT> for errcode in [ 401 , 404 , 500 ] : <NEWLINE> <INDENT> app . errorhandler ( errcode ) ( render_error ) <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Register error handlers.\"\"\"", "\"\"\"Render error template.\"\"\"", "'code'", "'{0}.html'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["06a81c3eb44cbeb2fb32cf6c9b1f6553", {"code_string": "import sys\nfrom osgpypp import osg\nfrom osgpypp import osgWidget\nMASK_2D = 0xF0000000\nLABEL1 = \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed\\n\"\n    \"do eiusmod tempor incididunt ut labore et dolore magna aliqua.\\n\"\n    \"Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris\\n\"\n    \"nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in...\"\nLABEL2 = \"...reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla\\n\"\n    \"pariatur. Excepteur sint occaecat cupidatat non proident, sunt in \\n\"\n    \"culpa qui officia deserunt mollit anim id est laborum. BBBBB\"\n", "code_toks_joined": "import sys <NEWLINE> from osgpypp import osg <NEWLINE> from osgpypp import osgWidget <NEWLINE> MASK_2D = 0xF0000000 <NEWLINE> LABEL1 = <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <DEDENT> LABEL2 = <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed\\n\"", "\"do eiusmod tempor incididunt ut labore et dolore magna aliqua.\\n\"", "\"Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris\\n\"", "\"nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in...\"", "\"...reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla\\n\"", "\"pariatur. Excepteur sint occaecat cupidatat non proident, sunt in \\n\"", "\"culpa qui officia deserunt mollit anim id est laborum. BBBBB\""]}, "err_obj": {"msg": "unexpected indent"}}], ["689bea9cecd4b66ca0b142990394a884", {"code_string": "class GridForm(GridFormHelp):\n    def __init__(self, screen, title, * args):\n    myargs = (self, screen, title, None) + args\n    apply(GridFormHelp.__init__, myargs)\n", "code_toks_joined": "class GridForm ( GridFormHelp ) : <NEWLINE> <INDENT> def __init__ ( self , screen , title , * args ) : <NEWLINE> myargs = ( self , screen , title , None ) + args <NEWLINE> apply ( GridFormHelp . __init__ , myargs ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["20529d871f3e8980561250ba2c2cc512", {"code_string": "def __ledit_update_value(self, field_name, new_value, type_fn, validator):\n    if self.__validated(validator, self.bindings[field_name][0],\n        new_value):\n        try:\n        setattr(self.__model, field_name, type_fn(new_value))\n        except ValueError:\n        if new_value != '':\n        raise\n        else:\n        dispatcher.send(\"model_update\", self.__model, field_name, self)\n", "code_toks_joined": "def __ledit_update_value ( self , field_name , new_value , type_fn , validator ) : <NEWLINE> <INDENT> if self . __validated ( validator , self . bindings [ field_name ] [ 0 ] , <NEWLINE> <INDENT> new_value ) : <NEWLINE> try : <NEWLINE> setattr ( self . __model , field_name , type_fn ( new_value ) ) <NEWLINE> except ValueError : <NEWLINE> if new_value != <STRING> : <NEWLINE> raise <NEWLINE> else : <NEWLINE> dispatcher . send ( <STRING> , self . __model , field_name , self ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "\"model_update\""]}, "err_obj": {"msg": "expected an indented block"}}], ["29b24df5ce1308151bda4cf5e06922fc", {"code_string": "def _got_session(session):\n    print('> got session: %s' % session)\n    container_name = 'some_test_container'\n    def _ok((response, v)):\n        ''''response' is a transport.Response() instance.'''\n        print('> got response: %s' % response)\n        print('> disabled logging for: %s' % container_name)\n        reactor.stop()\n    print('> sending request')\n    session.disable_container_logging(container = container_name).addCallback(_ok).addErrback(_error)\n", "code_toks_joined": "def _got_session ( session ) : <NEWLINE> <INDENT> print ( <STRING> % session ) <NEWLINE> container_name = <STRING> <NEWLINE> def _ok ( ( response , v ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> % response ) <NEWLINE> print ( <STRING> % container_name ) <NEWLINE> reactor . stop ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> session . disable_container_logging ( container = container_name ) . addCallback ( _ok ) . addErrback ( _error ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'> got session: %s'", "'some_test_container'", "''''response' is a transport.Response() instance.'''", "'> got response: %s'", "'> disabled logging for: %s'", "'> sending request'"]}, "err_obj": {"msg": "invalid syntax"}}], ["5fbdf011cb83f12ba69eda7c608bcfe0", {"code_string": "while 1:\n    try:\n        miles = float(input('Please enter the miles you drove: ')\n        gallons = float(input('Please enter the gallons of gas you put in the tank: '))\n        break\n    except ValueError:\n        print('Sorry, please only enter numbers.')\nmpg = miles / gallons\nprint('You got', mpg, 'mpg on that tank of gas.')\n", "code_toks_joined": "while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> miles = float ( input ( <STRING> ) <NEWLINE> gallons = float ( input ( <STRING> ) ) <NEWLINE> break <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> mpg = miles / gallons <NEWLINE> print ( <STRING> , mpg , <STRING> ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["'Please enter the miles you drove: '", "'Please enter the gallons of gas you put in the tank: '", "'Sorry, please only enter numbers.'", "'You got'", "'mpg on that tank of gas.'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["ed7e2852a34d019005658cc36c9e1e7e", {"code_string": "def _handle_text(self, msg):\n    payload = msg.get_payload()\n    if payload is None:\n        return\n    cset = msg.get_charset()\n    if cset is not None:\n        payload = cset.body_encode(payload)\n    if not isinstance(payload, basestring):\n        if type(payload) == type([]) and msg.is_multipart():\n            return 'this email is shit'\n        else:\n            raise TypeError, 'string payload expected: %s' % type(payload)\n    self._fp.write(payload)\n", "code_toks_joined": "def _handle_text ( self , msg ) : <NEWLINE> <INDENT> payload = msg . get_payload ( ) <NEWLINE> if payload is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> cset = msg . get_charset ( ) <NEWLINE> if cset is not None : <NEWLINE> <INDENT> payload = cset . body_encode ( payload ) <NEWLINE> <DEDENT> if not isinstance ( payload , basestring ) : <NEWLINE> <INDENT> if type ( payload ) == type ( [ ] ) and msg . is_multipart ( ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise TypeError , <STRING> % type ( payload ) <NEWLINE> <DEDENT> <DEDENT> self . _fp . write ( payload ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'this email is shit'", "'string payload expected: %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["b3996d724ff4b90c265e7fa1cb93df39", {"code_string": "def __init__(self, host, port, path, sleepTime)\n    self.host = host\n    self.port = port\n    self.path = path\n    self.sleepTime = sleepTime\n    self.stopped = False\n    threading.Thread.__init__(self)\n", "code_toks_joined": "def __init__ ( self , host , port , path , sleepTime ) <NEWLINE> <INDENT> self . host = host <NEWLINE> self . port = port <NEWLINE> self . path = path <NEWLINE> self . sleepTime = sleepTime <NEWLINE> self . stopped = False <NEWLINE> threading . Thread . __init__ ( self ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["8799074b8d36ea15906e731d3d8bc834", {"code_string": "def runSqlQueryPostgresql(connectSring, sqlCommand):\n    try:\n        os.environ['PGPASSWORD'] = password\n        session = Popen(connectSring + sqlCommand, stdin = PIPE, stdout = PIPE, stderr = PIPE)\n    except CalledProcessError, e:\n        logging.info(\"Failure: %s\" % e)\n        sys.exit(1)\n    return session.communicate()\n", "code_toks_joined": "def runSqlQueryPostgresql ( connectSring , sqlCommand ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> os . environ [ <STRING> ] = password <NEWLINE> session = Popen ( connectSring + sqlCommand , stdin = PIPE , stdout = PIPE , stderr = PIPE ) <NEWLINE> <DEDENT> except CalledProcessError , e : <NEWLINE> <INDENT> logging . info ( <STRING> % e ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> return session . communicate ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'PGPASSWORD'", "\"Failure: %s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["0b4a50791a7ddfda628bf0c8ea509e79", {"code_string": "def send_message(module, client_id, client_secret, topic, msg):\n    \"\"\"send message to typetalk\"\"\"\n    try:\n        access_token = get_access_token(module, client_id, client_secret)\n        url = 'https://typetalk.in/api/v1/topics/%d' % topic\n        headers = {\n            'Authorization': 'Bearer %s' % access_token,\n        }\n        do_request(module, url, {'message': msg}, headers)\n        return True, {'access_token': access_token}\n    except ConnectionError, e:\n        return False, e\n", "code_toks_joined": "def send_message ( module , client_id , client_secret , topic , msg ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> access_token = get_access_token ( module , client_id , client_secret ) <NEWLINE> url = <STRING> % topic <NEWLINE> headers = { <NEWLINE> <INDENT> <STRING> : <STRING> % access_token , <NEWLINE> <DEDENT> } <NEWLINE> do_request ( module , url , { <STRING> : msg } , headers ) <NEWLINE> return True , { <STRING> : access_token } <NEWLINE> <DEDENT> except ConnectionError , e : <NEWLINE> <INDENT> return False , e <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"send message to typetalk\"\"\"", "'https://typetalk.in/api/v1/topics/%d'", "'Authorization'", "'Bearer %s'", "'message'", "'access_token'"]}, "err_obj": {"msg": "invalid syntax"}}], ["f76fa7a4ddd31e80cc33b538257084cf", {"code_string": "def list(self, root_dir, include_inherited = False):\n    \"\"\"Lists all files in a directory.\"\"\"\n    files = []\n    for dirname, unused_dirnames, filenames in os.walk(\n        self._logical_to_physical(root_dir)):\n        for filename in filenames:\n        files.append(\n            self._physical_to_logical(os.path.join(dirname, filename)))\n    return sorted(files)\n", "code_toks_joined": "def list ( self , root_dir , include_inherited = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> files = [ ] <NEWLINE> for dirname , unused_dirnames , filenames in os . walk ( <NEWLINE> <INDENT> self . _logical_to_physical ( root_dir ) ) : <NEWLINE> for filename in filenames : <NEWLINE> files . append ( <NEWLINE> <INDENT> self . _physical_to_logical ( os . path . join ( dirname , filename ) ) ) <NEWLINE> <DEDENT> <DEDENT> return sorted ( files ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Lists all files in a directory.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["cc8b8d9280e02e11782457483de14e7a", {"code_string": "def hide(self):\n    self.screen = None\n    with self.disableMask(xcffib.xproto.EventMask.EnterWindow |\n        xcffib.xproto.EventMask.FocusChange |\n        xcffib.xproto.EventMask.LeaveWindow):\n        for i in self.windows:\n        i.hide()\n        self.layout.hide()\n", "code_toks_joined": "def hide ( self ) : <NEWLINE> <INDENT> self . screen = None <NEWLINE> with self . disableMask ( xcffib . xproto . EventMask . EnterWindow | <NEWLINE> <INDENT> xcffib . xproto . EventMask . FocusChange | <NEWLINE> xcffib . xproto . EventMask . LeaveWindow ) : <NEWLINE> for i in self . windows : <NEWLINE> i . hide ( ) <NEWLINE> self . layout . hide ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["c1c7a2dca2f87f70ba5c41ef146d2538", {"code_string": "def get_arg_spec():\n    if __arg_spec is not None: return __arg_spec\n    strats = [\"cluster\"]\n    states = [\"present\", \"absent\"]\n    __ arg_spec = ec2_argument_spec()\n    arg_spec.update({\n        \"name\": {\"required\": True, \"type\": \"str\"},\n        \"strategy\": {\"default\": \"cluster\", \"type\": \"str\", \"choices\": strats},\n        \"state\": {\"default\": \"present\", \"type\": \"str\", \"choices\": states},\n    })\n    return __arg_spec\n", "code_toks_joined": "def get_arg_spec ( ) : <NEWLINE> <INDENT> if __arg_spec is not None : return __arg_spec <NEWLINE> strats = [ <STRING> ] <NEWLINE> states = [ <STRING> , <STRING> ] <NEWLINE> __ arg_spec = ec2_argument_spec ( ) <NEWLINE> arg_spec . update ( { <NEWLINE> <INDENT> <STRING> : { <STRING> : True , <STRING> : <STRING> } , <NEWLINE> <STRING> : { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : strats } , <NEWLINE> <STRING> : { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : states } , <NEWLINE> <DEDENT> } ) <NEWLINE> return __arg_spec <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"cluster\"", "\"present\"", "\"absent\"", "\"name\"", "\"required\"", "\"type\"", "\"str\"", "\"strategy\"", "\"default\"", "\"cluster\"", "\"type\"", "\"str\"", "\"choices\"", "\"state\"", "\"default\"", "\"present\"", "\"type\"", "\"str\"", "\"choices\""]}, "err_obj": {"msg": "invalid syntax"}}], ["7bf6865d0cdf46f9b708eb8015fc0f8f", {"code_string": "def stop_pen():\n    subprocess.call(\"pidof pen > allpid.txt\", shell = True)\n    all_pid_file = open(\"/root/allpid.txt\", 'r')\n        all_pid_file_content = all_pid_file.read()\n        all_pid_file.close()\n    kill_command = \"kill \" + all_pid_file_content\n    print(kill_command)\n    subprocess.call(kill_command, shell = True)\n", "code_toks_joined": "def stop_pen ( ) : <NEWLINE> <INDENT> subprocess . call ( <STRING> , shell = True ) <NEWLINE> all_pid_file = open ( <STRING> , <STRING> ) <NEWLINE> <INDENT> all_pid_file_content = all_pid_file . read ( ) <NEWLINE> all_pid_file . close ( ) <NEWLINE> <DEDENT> kill_command = <STRING> + all_pid_file_content <NEWLINE> print ( kill_command ) <NEWLINE> subprocess . call ( kill_command , shell = True ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"pidof pen > allpid.txt\"", "\"/root/allpid.txt\"", "'r'", "\"kill \""]}, "err_obj": {"msg": "unexpected indent"}}], ["ab022f3b355d54dcd033ee464001cb70", {"code_string": "class MapFailureCase(PBSMapCase):\n    WorkerClass = CompleteFailureIdentityWorker\n    max_range = 10\n    def test_pbs_map(self):\n    xs = range(self.max_range)\n        try:\n            self.assertRaises(ppm.PBSMapError, self.run_pbs_map, self.WorkerClass, xs, queue_timeout = 5, num_clients = 10)\n        except Exception, e:\n            self.assertTrue(isinstance(e, TestException))\n", "code_toks_joined": "class MapFailureCase ( PBSMapCase ) : <NEWLINE> <INDENT> WorkerClass = CompleteFailureIdentityWorker <NEWLINE> max_range = 10 <NEWLINE> def test_pbs_map ( self ) : <NEWLINE> xs = range ( self . max_range ) <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . assertRaises ( ppm . PBSMapError , self . run_pbs_map , self . WorkerClass , xs , queue_timeout = 5 , num_clients = 10 ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> self . assertTrue ( isinstance ( e , TestException ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["c7aefc143cda8eadc71f4e37e025e05b", {"code_string": "def get_datatype(self):\n    \"\"\"Get the map type\"\"\"\n    if self.D.has_key(\"datatype\"):\n        return self.D[\"datatype\"]\n            else:\n        return None\n", "code_toks_joined": "def get_datatype ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . D . has_key ( <STRING> ) : <NEWLINE> <INDENT> return self . D [ <STRING> ] <NEWLINE> <INDENT> else : <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get the map type\"\"\"", "\"datatype\"", "\"datatype\""]}, "err_obj": {"msg": "unexpected indent"}}], ["ab72213821668ddfdec29865042e3502", {"code_string": "def find_merged_avatars(main_root):\n    print(cformat('%{white!}checking for merged avatars'))\n    avatar_id_map = {}\n    for avatar in verbose_iterator(main_root['avatars'].itervalues(), len(main_root['avatars']), attrgetter('id'),\n        lambda av: '{}, {}'.format(safe_upper(av.surName), av.name)):\n        for merged_avatar in getattr(avatar, '_mergeFrom', []):\n        avatar_id_map[merged_avatar.getId()] = avatar.getId()\n    return avatar_id_map\n", "code_toks_joined": "def find_merged_avatars ( main_root ) : <NEWLINE> <INDENT> print ( cformat ( <STRING> ) ) <NEWLINE> avatar_id_map = { } <NEWLINE> for avatar in verbose_iterator ( main_root [ <STRING> ] . itervalues ( ) , len ( main_root [ <STRING> ] ) , attrgetter ( <STRING> ) , <NEWLINE> <INDENT> lambda av : <STRING> . format ( safe_upper ( av . surName ) , av . name ) ) : <NEWLINE> for merged_avatar in getattr ( avatar , <STRING> , [ ] ) : <NEWLINE> avatar_id_map [ merged_avatar . getId ( ) ] = avatar . getId ( ) <NEWLINE> <DEDENT> return avatar_id_map <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'%{white!}checking for merged avatars'", "'avatars'", "'avatars'", "'id'", "'{}, {}'", "'_mergeFrom'"]}, "err_obj": {"msg": "expected an indented block"}}], ["fcc3fdc34cff0dcf46bd1e01ba191893", {"code_string": "def buildLESSFile(filename, output_filename):\n    if verbose:\n    print(\"compiling \" + filename + \" to \" + output_filename)\n    return call([\"lessc\", filename, '-x', '--clean-css', output_filename, \" > \" + output_filename])\n", "code_toks_joined": "def buildLESSFile ( filename , output_filename ) : <NEWLINE> <INDENT> if verbose : <NEWLINE> print ( <STRING> + filename + <STRING> + output_filename ) <NEWLINE> return call ( [ <STRING> , filename , <STRING> , <STRING> , output_filename , <STRING> + output_filename ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"compiling \"", "\" to \"", "\"lessc\"", "'-x'", "'--clean-css'", "\" > \""]}, "err_obj": {"msg": "expected an indented block"}}], ["bff380e2937fd4e029c1f35089c9296a", {"code_string": "def test_discovery(self):\n    \"\"\"Test discovery.\"\"\"\n    scanner = get_component('device_tracker.test').SCANNER\n    with patch.dict(device_tracker.DISCOVERY_PLATFORMS, {'test': 'test'}):\n        with patch.object(scanner, 'scan_devices',\n            autospec = True) as mock_scan:\n            with assert_setup_component(1, device_tracker.DOMAIN):\n            assert setup_component(\n            self.hass, device_tracker.DOMAIN, TEST_PLATFORM)\n            fire_service_discovered(self.hass, 'test', {})\n            self.assertTrue(mock_scan.called)\n", "code_toks_joined": "def test_discovery ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> scanner = get_component ( <STRING> ) . SCANNER <NEWLINE> with patch . dict ( device_tracker . DISCOVERY_PLATFORMS , { <STRING> : <STRING> } ) : <NEWLINE> <INDENT> with patch . object ( scanner , <STRING> , <NEWLINE> <INDENT> autospec = True ) as mock_scan : <NEWLINE> with assert_setup_component ( 1 , device_tracker . DOMAIN ) : <NEWLINE> assert setup_component ( <NEWLINE> self . hass , device_tracker . DOMAIN , TEST_PLATFORM ) <NEWLINE> fire_service_discovered ( self . hass , <STRING> , { } ) <NEWLINE> self . assertTrue ( mock_scan . called ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Test discovery.\"\"\"", "'device_tracker.test'", "'test'", "'test'", "'scan_devices'", "'test'"]}, "err_obj": {"msg": "expected an indented block"}}], ["5656178daabde459244db4977e50311a", {"code_string": "def __init__(self, argc, argv):\n    if argc != 2 or int(argv[1]) <= 0:\n        self.print_usage(argv)\n        exit()\n    self.max_generation = int(argv[1])\n    self.is_running = False\n    self.size = (1024, 768)\n    self.model = None\n    def print_usage(self, argv):\n    \"\"\" Print command line argument info to standard output \"\"\"\n    print(\"usage: python %s max_generation\" % argv[0])\n", "code_toks_joined": "def __init__ ( self , argc , argv ) : <NEWLINE> <INDENT> if argc != 2 or int ( argv [ 1 ] ) <= 0 : <NEWLINE> <INDENT> self . print_usage ( argv ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> self . max_generation = int ( argv [ 1 ] ) <NEWLINE> self . is_running = False <NEWLINE> self . size = ( 1024 , 768 ) <NEWLINE> self . model = None <NEWLINE> def print_usage ( self , argv ) : <NEWLINE> <STRING> <NEWLINE> print ( <STRING> % argv [ 0 ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Print command line argument info to standard output \"\"\"", "\"usage: python %s max_generation\""]}, "err_obj": {"msg": "expected an indented block"}}], ["44d9a2aba1e02b057e7992f531de1041", {"code_string": "def _ended_courses(self):\n    for course_id in[course\n        for sub in settings.COURSE_LISTINGS\n            for course in settings.COURSE_LISTINGS[sub]]:\n            course_loc = CourseDescriptor.id_to_location(course_id)\n            course = modulestore().get_instance(course_id, course_loc)\n            if course.has_ended():\n        yield course_id\n", "code_toks_joined": "def _ended_courses ( self ) : <NEWLINE> <INDENT> for course_id in [ course <NEWLINE> <INDENT> for sub in settings . COURSE_LISTINGS <NEWLINE> <INDENT> for course in settings . COURSE_LISTINGS [ sub ] ] : <NEWLINE> course_loc = CourseDescriptor . id_to_location ( course_id ) <NEWLINE> course = modulestore ( ) . get_instance ( course_id , course_loc ) <NEWLINE> if course . has_ended ( ) : <NEWLINE> <DEDENT> yield course_id <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unindent does not match any outer indentation level"}}], ["ed8f0414604cd74a9951ed55fdb65d65", {"code_string": "def _delete(self, x, key, d):\n    if x is None: return None\n    if d == len(key)()):\n        if x.val is not None: N -= 1\n        x.val = None\n    else:\n        c = key.charAt(d)\n        x._next[c] = self.delete(x._next[c], key, d + 1)\n    if x.val is not None: return x\n    for c in range(R):\n        if x._next[c] is not None:\n            return x\n    return None\n", "code_toks_joined": "def _delete ( self , x , key , d ) : <NEWLINE> <INDENT> if x is None : return None <NEWLINE> if d == len ( key ) ( ) ) : <NEWLINE> <INDENT> if x . val is not None : N -= 1 <NEWLINE> x . val = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = key . charAt ( d ) <NEWLINE> x . _next [ c ] = self . delete ( x . _next [ c ] , key , d + 1 ) <NEWLINE> <DEDENT> if x . val is not None : return x <NEWLINE> for c in range ( R ) : <NEWLINE> <INDENT> if x . _next [ c ] is not None : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> <DEDENT> return None <NEWLINE> <DEDENT>", "anonymize_dict": {}, "window_span": [22, 34], "err_obj": {"msg": "unbalanced (){}[]"}}], ["28c9a9911ddf607d2b87e71a41d84df3", {"code_string": "class OUI_data(DVBobject):\n    def pack(self):\n    fmt = \"!HBB%ds\" % len(self.selector_bytes)\n    return pack(fmt,\n        self.OUI >> 8,\n        self.OUI & 0xFF,\n        len(self.selector_bytes),\n        self.selector_bytes,\n        )\n", "code_toks_joined": "class OUI_data ( DVBobject ) : <NEWLINE> <INDENT> def pack ( self ) : <NEWLINE> fmt = <STRING> % len ( self . selector_bytes ) <NEWLINE> return pack ( fmt , <NEWLINE> <INDENT> self . OUI >> 8 , <NEWLINE> self . OUI & 0xFF , <NEWLINE> len ( self . selector_bytes ) , <NEWLINE> self . selector_bytes , <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"!HBB%ds\""]}, "err_obj": {"msg": "expected an indented block"}}], ["644f3d05609a79612eb4cdca3ded7109", {"code_string": "def test_header_start_exception():\n    '''Check certain Readers throw an exception if ``header_start`` is set'''\n    for readerclass in[ascii.NoHeader, ascii.SExtractor, ascii.Ipac,\n        ascii.BaseReader, ascii.FixedWidthNoHeader, ascii.Cds, ascii.Daophot]:\n        with pytest.raises(ValueError):\n        reader = ascii.core._get_reader(readerclass, header_start = 5)\n", "code_toks_joined": "def test_header_start_exception ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for readerclass in [ ascii . NoHeader , ascii . SExtractor , ascii . Ipac , <NEWLINE> <INDENT> ascii . BaseReader , ascii . FixedWidthNoHeader , ascii . Cds , ascii . Daophot ] : <NEWLINE> with pytest . raises ( ValueError ) : <NEWLINE> reader = ascii . core . _get_reader ( readerclass , header_start = 5 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Check certain Readers throw an exception if ``header_start`` is set'''"]}, "err_obj": {"msg": "expected an indented block"}}], ["6aeeb1b1963e9ed178db639324e34f0f", {"code_string": "def key_checker(expected_keys):\n    \"\"\"Returns a function that checks that specified keys are present in a dict\"\"\"\n    def check(d):\n        for k in expected_keys:\n            if k not in d:\n                raise InvalidTabsException(\"Key{0}not present in{1}\"\n                    .format(k, d)))\n    return check\n", "code_toks_joined": "def key_checker ( expected_keys ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def check ( d ) : <NEWLINE> <INDENT> for k in expected_keys : <NEWLINE> <INDENT> if k not in d : <NEWLINE> <INDENT> raise InvalidTabsException ( <STRING> <NEWLINE> <INDENT> . format ( k , d ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return check <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns a function that checks that specified keys are present in a dict\"\"\"", "\"Key{0}not present in{1}\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e8b346dcc4e7288901185b3ada458e65", {"code_string": "def run(db):\n    migrator = PostgresqlMigrator(db)\n    migrate(\n        migrator.add_column(\"student\", \"grade\", IntegerField()\n    )\n", "code_toks_joined": "def run ( db ) : <NEWLINE> <INDENT> migrator = PostgresqlMigrator ( db ) <NEWLINE> migrate ( <NEWLINE> <INDENT> migrator . add_column ( <STRING> , <STRING> , IntegerField ( ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"student\"", "\"grade\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["b479c7f7195f18a2ae0904921aad65b4", {"code_string": "def get_currency_precision(currency = None):\n    if not currency:\n        currency = frappe.db.get_value(\"Company\"\n            frappe.db.get_default(\"company\"), \"default_currency\")\n    currency_format = frappe.db.get_value(\"Currency\", currency, \"number_format\")\n    from frappe.utils import get_number_format_info\n    return get_number_format_info(currency_format)[2]\n", "code_toks_joined": "def get_currency_precision ( currency = None ) : <NEWLINE> <INDENT> if not currency : <NEWLINE> <INDENT> currency = frappe . db . get_value ( <STRING> <NEWLINE> <INDENT> frappe . db . get_default ( <STRING> ) , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> currency_format = frappe . db . get_value ( <STRING> , currency , <STRING> ) <NEWLINE> from frappe . utils import get_number_format_info <NEWLINE> return get_number_format_info ( currency_format ) [ 2 ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Company\"", "\"company\"", "\"default_currency\"", "\"Currency\"", "\"number_format\""]}, "err_obj": {"msg": "invalid syntax"}}], ["5ed1f3912099d184c7588647ed45c05b", {"code_string": "class PictureNonVisual(Serialisable):\n    tagname = \"nvPicPr\"\n    cNvPr = Typed(expected_type = NonVisualDrawingProps, )\n    cNvPicPr = Typed(expected_type = NonVisualPictureProperties, )\n    __elements__ = (\"cNvPr\", \"cNvPicPr\")\n    def __init__(self,\n        cNvPr = None,\n        cNvPicPr = None,\n        ):\n        if cNvPr is None:\n        cNvPr = NonVisualDrawingProps(id = 0, name = \"Image 1\", descr = \"Name of file\")\n        self.cNvPr = cNvPr\n        if cNvPicPr is None:\n        cNvPicPr = NonVisualPictureProperties()\n        self.cNvPicPr = cNvPicPr\n", "code_toks_joined": "class PictureNonVisual ( Serialisable ) : <NEWLINE> <INDENT> tagname = <STRING> <NEWLINE> cNvPr = Typed ( expected_type = NonVisualDrawingProps , ) <NEWLINE> cNvPicPr = Typed ( expected_type = NonVisualPictureProperties , ) <NEWLINE> __elements__ = ( <STRING> , <STRING> ) <NEWLINE> def __init__ ( self , <NEWLINE> <INDENT> cNvPr = None , <NEWLINE> cNvPicPr = None , <NEWLINE> ) : <NEWLINE> if cNvPr is None : <NEWLINE> cNvPr = NonVisualDrawingProps ( id = 0 , name = <STRING> , descr = <STRING> ) <NEWLINE> self . cNvPr = cNvPr <NEWLINE> if cNvPicPr is None : <NEWLINE> cNvPicPr = NonVisualPictureProperties ( ) <NEWLINE> self . cNvPicPr = cNvPicPr <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"nvPicPr\"", "\"cNvPr\"", "\"cNvPicPr\"", "\"Image 1\"", "\"Name of file\""]}, "err_obj": {"msg": "expected an indented block"}}], ["21fb7c90032c0cf0ea0008362df3c69b", {"code_string": "def max(dictionary):\n    max = None\n    highest = None\n    for key in dictionary:\n        if max < dictionary[key]:\n        max = dictionary[key]\n        highest = key\n    return highest\n", "code_toks_joined": "def max ( dictionary ) : <NEWLINE> <INDENT> max = None <NEWLINE> highest = None <NEWLINE> for key in dictionary : <NEWLINE> <INDENT> if max < dictionary [ key ] : <NEWLINE> max = dictionary [ key ] <NEWLINE> highest = key <NEWLINE> <DEDENT> return highest <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["04f331cb013cb43457ffd7a3229e8ffc", {"code_string": "def test_allocate_VF_fail(self):\n    self._create_fake_instance()\n    with mock.patch.object(objects.PciDevice, 'get_by_dev_addr',\n        side_effect = self._fake_pci_device_get_by_addr):\n        self._create_pci_devices()\n        devobj = self.sriov_vf_devices[0]\n        parent = self._fake_pci_device_get_by_addr(None, None,\n            devobj.parent_addr)\n            parent.status = fields.PciDeviceStatus.CLAIMED\n            self.assertRaises(exception.PciDevicePFInvalidStatus,\n            devobj.allocate, self.inst)\n", "code_toks_joined": "def test_allocate_VF_fail ( self ) : <NEWLINE> <INDENT> self . _create_fake_instance ( ) <NEWLINE> with mock . patch . object ( objects . PciDevice , <STRING> , <NEWLINE> <INDENT> side_effect = self . _fake_pci_device_get_by_addr ) : <NEWLINE> self . _create_pci_devices ( ) <NEWLINE> devobj = self . sriov_vf_devices [ 0 ] <NEWLINE> parent = self . _fake_pci_device_get_by_addr ( None , None , <NEWLINE> <INDENT> devobj . parent_addr ) <NEWLINE> parent . status = fields . PciDeviceStatus . CLAIMED <NEWLINE> self . assertRaises ( exception . PciDevicePFInvalidStatus , <NEWLINE> devobj . allocate , self . inst ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'get_by_dev_addr'"]}, "err_obj": {"msg": "unexpected indent"}}], ["a9f534579c8b38f2a366b39a9802d66a", {"code_string": "def check_and_react(self, record_to_check):\n    \"\"\"For every possible combination of conditions in the channel and\"\"\"\n    for cond, f in product(self.conditionandreaction_set.all(),\n        record_to_check.field_set.all()):\n        reaction = cond.check_condition(f)\n        if reaction:\n        cond.react(record_to_check)\n        return\n", "code_toks_joined": "def check_and_react ( self , record_to_check ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for cond , f in product ( self . conditionandreaction_set . all ( ) , <NEWLINE> <INDENT> record_to_check . field_set . all ( ) ) : <NEWLINE> reaction = cond . check_condition ( f ) <NEWLINE> if reaction : <NEWLINE> cond . react ( record_to_check ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"For every possible combination of conditions in the channel and\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["47460e5b388766210c7cc4a5f3dd28aa", {"code_string": "def file_handle(filename):\n    file_base = os.path.splitext(filename)[0]\n    data = xlrd.open_workbook(filename)\n    table = data.sheets()[1]\n    x = table.col_values(0)[1: ]\n    y = table.col_values(1)[1: ]\n    z = zip(x, y)\n    s = sorted(set(y))\n    result = {}\n    for i in s:\n        l = []\n        for j in z:\n            if i in j:\n                l.append(j[0])\n        result[i] = l\n    file = xlwt.Workbook()\n    table = file.add_sheet('result', cell_overwrite_ok = True)\n    table.write(0, 0, u'\u7269\u6599')\n    table.write(0, 1, u'\u673a\u578b')\n    m = 1\n    for(k, v) in result.items():\n        table.write(m, 0, k)\n        table.write(m, 1, ','.join(str(v))\n        m = m + 1\n    result_file = '%s_result.xls' % file_base\n    file.save(result_file)\n", "code_toks_joined": "def file_handle ( filename ) : <NEWLINE> <INDENT> file_base = os . path . splitext ( filename ) [ 0 ] <NEWLINE> data = xlrd . open_workbook ( filename ) <NEWLINE> table = data . sheets ( ) [ 1 ] <NEWLINE> x = table . col_values ( 0 ) [ 1 : ] <NEWLINE> y = table . col_values ( 1 ) [ 1 : ] <NEWLINE> z = zip ( x , y ) <NEWLINE> s = sorted ( set ( y ) ) <NEWLINE> result = { } <NEWLINE> for i in s : <NEWLINE> <INDENT> l = [ ] <NEWLINE> for j in z : <NEWLINE> <INDENT> if i in j : <NEWLINE> <INDENT> l . append ( j [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> result [ i ] = l <NEWLINE> <DEDENT> file = xlwt . Workbook ( ) <NEWLINE> table = file . add_sheet ( <STRING> , cell_overwrite_ok = True ) <NEWLINE> table . write ( 0 , 0 , <STRING> ) <NEWLINE> table . write ( 0 , 1 , <STRING> ) <NEWLINE> m = 1 <NEWLINE> for ( k , v ) in result . items ( ) : <NEWLINE> <INDENT> table . write ( m , 0 , k ) <NEWLINE> table . write ( m , 1 , <STRING> . join ( str ( v ) ) <NEWLINE> m = m + 1 <NEWLINE> <DEDENT> result_file = <STRING> % file_base <NEWLINE> file . save ( result_file ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'result'", "u'\u7269\u6599'", "u'\u673a\u578b'", "','", "'%s_result.xls'"]}, "window_span": [214, 250], "err_obj": {"msg": "unbalanced (){}[]"}}], ["9885341ecaa8abd3e303add7e452f831", {"code_string": "\"\"\"Functions\"\"\"\nfrom __future__ import division, print_function, absolute_import\nimport numpy as np\nfrom numpy import array, asarray, float64, int32, zeros\nfrom.import _lbfgsb\nfrom.optimize import approx_fprime, MemoizeJac, Result, _check_unknown_options\n__all__ = ['fmin_l_bfgs_b']\ndef fmin_l_bfgs_b(func, x0, fprime = None, args = (),\n    approx_grad = 0,\n    bounds = None, m = 10, factr = 1e7, pgtol = 1e-5,\n    epsilon = 1e-8,\n    iprint = - 1, maxfun = 15000, maxiter = 15000, disp = None,\n    callback = None):\n    \"\"\"Minimize a function func using the L-BFGS-B algorithm.\"\"\"\n    if approx_grad:\n    fun = func\n    jac = None\n    elif fprime is None:\n    fun = MemoizeJac(func)\n    jac = fun.derivative\n    else:\n    fun = func\n    jac = fprime\n    if disp is None:\n    disp = iprint\n    opts = {'disp': disp,\n    'iprint': iprint,\n    'maxcor': m,\n    'ftol': factr * np.finfo(float).eps,\n    'gtol': pgtol,\n    'eps': epsilon,\n    'maxfun': maxfun,\n    'maxiter': maxiter,\n    'callback': callback}\n    res = _minimize_lbfgsb(fun, x0, args = args, jac = jac, bounds = bounds,\n        ** opts)\n        d = {'grad': res['jac'],\n        'task': res['message'],\n        'funcalls': res['nfev'],\n        'nit': res['nit'],\n        'warnflag': res['status']}\n        f = res['fun']\n        x = res['x']\n        return x, f, d\ndef _minimize_lbfgsb(fun, x0, args = (), jac = None, bounds = None,\n    disp = None, maxcor = 10, ftol = 2.2204460492503131e-09,\n    gtol = 1e-5, eps = 1e-8, maxfun = 15000, maxiter = 15000,\n    iprint = - 1, callback = None, ** unknown_options):\n    \"\"\"Minimize a scalar function of one or more variables using the L-BFGS-B\"\"\"\n    _check_unknown_options(unknown_options)\n    m = maxcor\n    epsilon = eps\n    pgtol = gtol\n    factr = ftol / np.finfo(float).eps\n    x0 = asarray(x0).ravel()\n    n, = x0.shape\n    if bounds is None:\n    bounds = [(None, None)] * n\n    if len(bounds) != n:\n    raise ValueError('length of x0 != length of bounds')\n    if disp is not None:\n    if disp == 0:\n    iprint = - 1\n    else:\n    iprint = disp\n    if jac is None:\n    def func_and_grad(x):\n    f = fun(x, * args)\n    g = approx_fprime(x, fun, epsilon, * args)\n    return f, g\n    else:\n    def func_and_grad(x):\n    f = fun(x, * args)\n    g = jac(x, * args)\n    return f, g\n    nbd = zeros(n, int32)\n    low_bnd = zeros(n, float64)\n    upper_bnd = zeros(n, float64)\n    bounds_map = {(None, None): 0,\n    (1, None): 1,\n    (1, 1): 2,\n    (None, 1): 3}\n    for i in range(0, n):\n    l, u = bounds[i]\n    if l is not None:\n    low_bnd[i] = l\n    l = 1\n    if u is not None:\n    upper_bnd[i] = u\n    u = 1\n    nbd[i] = bounds_map[l, u]\n    x = array(x0, float64)\n    f = array(0.0, float64)\n    g = zeros((n, ), float64)\n    wa = zeros(2 * m * n + 5 * n + 11 * m * m + 8 * m, float64)\n    iwa = zeros(3 * n, int32)\n    task = zeros(1, 'S60')\n    csave = zeros(1, 'S60')\n    lsave = zeros(4, int32)\n    isave = zeros(44, int32)\n    dsave = zeros(29, float64)\n    task[: ] = 'START'\n    n_function_evals = 0\n    n_iterations = 0\n    while 1:\n        pgtol, wa, iwa, task, iprint, csave, lsave,\n        isave, dsave)\n        task_str = task.tostring()\n        if task_str.startswith(b'FG'):\n        if n_function_evals > maxfun:\n        task[: ] = ('STOP: TOTAL NO. of f AND g EVALUATIONS '\n            'EXCEEDS LIMIT')\n            else:\n            n_function_evals += 1\n            f, g = func_and_grad(x)\n            elif task_str.startswith(b'NEW_X'):\n            if n_iterations > maxiter:\n            task[: ] = 'STOP: TOTAL NO. of ITERATIONS EXCEEDS LIMIT'\n            else:\n            n_iterations += 1\n            if callback is not None:\n            callback(x)\n            else:\n            break\n            task_str = task.tostring().strip(b'\\x00').strip()\n            if task_str.startswith(b'CONV'):\n            warnflag = 0\n            elif n_function_evals > maxfun:\n            warnflag = 1\n            elif n_iterations > maxiter:\n            warnflag = 1\n            else:\n            warnflag = 2\n            return Result(fun = f, jac = g, nfev = n_function_evals, nit = n_iterations,\n            status = warnflag, message = task_str, x = x,\n            success = (warnflag == 0))\nif __name__ == '__main__':\n    def func(x):\n        f = 0.25 *(x[0] - 1) ** 2\n        for i in range(1, x.shape[0]):\n            f +=(x[i] - x[i - 1] ** 2) ** 2\n        f *= 4\n        return f\n    def grad(x):\n        g = zeros(x.shape, float64)\n        t1 = x[1] - x[0] ** 2\n        g[0] = 2 *(x[0] - 1) - 16 * x[0] * t1\n        for i in range(1, g.shape[0] - 1):\n            t2 = t1\n            t1 = x[i + 1] - x[i] ** 2\n            g[i] = 8 * t2 - 16 * x[i] * t1\n        g[- 1] = 8 * t1\n        return g\n    def func_and_grad(x):\n        return func(x), grad(x)\n    class Problem(object):\n        def fun(self, x):\n            return func_and_grad(x)\n    factr = 1e7\n    pgtol = 1e-5\n    n = 25\n    m = 10\n    bounds = [(None, None)] * n\n    for i in range(0, n, 2):\n        bounds[i] = (1.0, 100)\n    for i in range(1, n, 2):\n        bounds[i] = (- 100, 100)\n    x0 = zeros((n, ), float64)\n    x0[: ] = 3\n    x, f, d = fmin_l_bfgs_b(func, x0, fprime = grad, m = m,\n        factr = factr, pgtol = pgtol)\n    print(x)\n    print(f)\n    print(d)\n    x, f, d = fmin_l_bfgs_b(func, x0, approx_grad = 1,\n        m = m, factr = factr, pgtol = pgtol)\n    print(x)\n    print(f)\n    print(d)\n    x, f, d = fmin_l_bfgs_b(func_and_grad, x0, approx_grad = 0,\n        m = m, factr = factr, pgtol = pgtol)\n    print(x)\n    print(f)\n    print(d)\n    p = Problem()\n    x, f, d = fmin_l_bfgs_b(p.fun, x0, approx_grad = 0,\n        m = m, factr = factr, pgtol = pgtol)\n    print(x)\n    print(f)\n    print(d)\n", "code_toks_joined": "<STRING> <NEWLINE> from __future__ import division , print_function , absolute_import <NEWLINE> import numpy as np <NEWLINE> from numpy import array , asarray , float64 , int32 , zeros <NEWLINE> from . import _lbfgsb <NEWLINE> from . optimize import approx_fprime , MemoizeJac , Result , _check_unknown_options <NEWLINE> __all__ = [ <STRING> ] <NEWLINE> def fmin_l_bfgs_b ( func , x0 , fprime = None , args = ( ) , <NEWLINE> <INDENT> approx_grad = 0 , <NEWLINE> bounds = None , m = 10 , factr = 1e7 , pgtol = 1e-5 , <NEWLINE> epsilon = 1e-8 , <NEWLINE> iprint = - 1 , maxfun = 15000 , maxiter = 15000 , disp = None , <NEWLINE> callback = None ) : <NEWLINE> <STRING> <NEWLINE> if approx_grad : <NEWLINE> fun = func <NEWLINE> jac = None <NEWLINE> elif fprime is None : <NEWLINE> fun = MemoizeJac ( func ) <NEWLINE> jac = fun . derivative <NEWLINE> else : <NEWLINE> fun = func <NEWLINE> jac = fprime <NEWLINE> if disp is None : <NEWLINE> disp = iprint <NEWLINE> opts = { <STRING> : disp , <NEWLINE> <STRING> : iprint , <NEWLINE> <STRING> : m , <NEWLINE> <STRING> : factr * np . finfo ( float ) . eps , <NEWLINE> <STRING> : pgtol , <NEWLINE> <STRING> : epsilon , <NEWLINE> <STRING> : maxfun , <NEWLINE> <STRING> : maxiter , <NEWLINE> <STRING> : callback } <NEWLINE> res = _minimize_lbfgsb ( fun , x0 , args = args , jac = jac , bounds = bounds , <NEWLINE> <INDENT> ** opts ) <NEWLINE> d = { <STRING> : res [ <STRING> ] , <NEWLINE> <STRING> : res [ <STRING> ] , <NEWLINE> <STRING> : res [ <STRING> ] , <NEWLINE> <STRING> : res [ <STRING> ] , <NEWLINE> <STRING> : res [ <STRING> ] } <NEWLINE> f = res [ <STRING> ] <NEWLINE> x = res [ <STRING> ] <NEWLINE> return x , f , d <NEWLINE> <DEDENT> <DEDENT> def _minimize_lbfgsb ( fun , x0 , args = ( ) , jac = None , bounds = None , <NEWLINE> <INDENT> disp = None , maxcor = 10 , ftol = 2.2204460492503131e-09 , <NEWLINE> gtol = 1e-5 , eps = 1e-8 , maxfun = 15000 , maxiter = 15000 , <NEWLINE> iprint = - 1 , callback = None , ** unknown_options ) : <NEWLINE> <STRING> <NEWLINE> _check_unknown_options ( unknown_options ) <NEWLINE> m = maxcor <NEWLINE> epsilon = eps <NEWLINE> pgtol = gtol <NEWLINE> factr = ftol / np . finfo ( float ) . eps <NEWLINE> x0 = asarray ( x0 ) . ravel ( ) <NEWLINE> n , = x0 . shape <NEWLINE> if bounds is None : <NEWLINE> bounds = [ ( None , None ) ] * n <NEWLINE> if len ( bounds ) != n : <NEWLINE> raise ValueError ( <STRING> ) <NEWLINE> if disp is not None : <NEWLINE> if disp == 0 : <NEWLINE> iprint = - 1 <NEWLINE> else : <NEWLINE> iprint = disp <NEWLINE> if jac is None : <NEWLINE> def func_and_grad ( x ) : <NEWLINE> f = fun ( x , * args ) <NEWLINE> g = approx_fprime ( x , fun , epsilon , * args ) <NEWLINE> return f , g <NEWLINE> else : <NEWLINE> def func_and_grad ( x ) : <NEWLINE> f = fun ( x , * args ) <NEWLINE> g = jac ( x , * args ) <NEWLINE> return f , g <NEWLINE> nbd = zeros ( n , int32 ) <NEWLINE> low_bnd = zeros ( n , float64 ) <NEWLINE> upper_bnd = zeros ( n , float64 ) <NEWLINE> bounds_map = { ( None , None ) : 0 , <NEWLINE> ( 1 , None ) : 1 , <NEWLINE> ( 1 , 1 ) : 2 , <NEWLINE> ( None , 1 ) : 3 } <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> l , u = bounds [ i ] <NEWLINE> if l is not None : <NEWLINE> low_bnd [ i ] = l <NEWLINE> l = 1 <NEWLINE> if u is not None : <NEWLINE> upper_bnd [ i ] = u <NEWLINE> u = 1 <NEWLINE> nbd [ i ] = bounds_map [ l , u ] <NEWLINE> x = array ( x0 , float64 ) <NEWLINE> f = array ( 0.0 , float64 ) <NEWLINE> g = zeros ( ( n , ) , float64 ) <NEWLINE> wa = zeros ( 2 * m * n + 5 * n + 11 * m * m + 8 * m , float64 ) <NEWLINE> iwa = zeros ( 3 * n , int32 ) <NEWLINE> task = zeros ( 1 , <STRING> ) <NEWLINE> csave = zeros ( 1 , <STRING> ) <NEWLINE> lsave = zeros ( 4 , int32 ) <NEWLINE> isave = zeros ( 44 , int32 ) <NEWLINE> dsave = zeros ( 29 , float64 ) <NEWLINE> task [ : ] = <STRING> <NEWLINE> n_function_evals = 0 <NEWLINE> n_iterations = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> pgtol , wa , iwa , task , iprint , csave , lsave , <NEWLINE> isave , dsave ) <NEWLINE> task_str = task . tostring ( ) <NEWLINE> if task_str . startswith ( <STRING> ) : <NEWLINE> if n_function_evals > maxfun : <NEWLINE> task [ : ] = ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> else : <NEWLINE> n_function_evals += 1 <NEWLINE> f , g = func_and_grad ( x ) <NEWLINE> elif task_str . startswith ( <STRING> ) : <NEWLINE> if n_iterations > maxiter : <NEWLINE> task [ : ] = <STRING> <NEWLINE> else : <NEWLINE> n_iterations += 1 <NEWLINE> if callback is not None : <NEWLINE> callback ( x ) <NEWLINE> else : <NEWLINE> break <NEWLINE> task_str = task . tostring ( ) . strip ( <STRING> ) . strip ( ) <NEWLINE> if task_str . startswith ( <STRING> ) : <NEWLINE> warnflag = 0 <NEWLINE> elif n_function_evals > maxfun : <NEWLINE> warnflag = 1 <NEWLINE> elif n_iterations > maxiter : <NEWLINE> warnflag = 1 <NEWLINE> else : <NEWLINE> warnflag = 2 <NEWLINE> return Result ( fun = f , jac = g , nfev = n_function_evals , nit = n_iterations , <NEWLINE> status = warnflag , message = task_str , x = x , <NEWLINE> success = ( warnflag == 0 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> def func ( x ) : <NEWLINE> <INDENT> f = 0.25 * ( x [ 0 ] - 1 ) ** 2 <NEWLINE> for i in range ( 1 , x . shape [ 0 ] ) : <NEWLINE> <INDENT> f += ( x [ i ] - x [ i - 1 ] ** 2 ) ** 2 <NEWLINE> <DEDENT> f *= 4 <NEWLINE> return f <NEWLINE> <DEDENT> def grad ( x ) : <NEWLINE> <INDENT> g = zeros ( x . shape , float64 ) <NEWLINE> t1 = x [ 1 ] - x [ 0 ] ** 2 <NEWLINE> g [ 0 ] = 2 * ( x [ 0 ] - 1 ) - 16 * x [ 0 ] * t1 <NEWLINE> for i in range ( 1 , g . shape [ 0 ] - 1 ) : <NEWLINE> <INDENT> t2 = t1 <NEWLINE> t1 = x [ i + 1 ] - x [ i ] ** 2 <NEWLINE> g [ i ] = 8 * t2 - 16 * x [ i ] * t1 <NEWLINE> <DEDENT> g [ - 1 ] = 8 * t1 <NEWLINE> return g <NEWLINE> <DEDENT> def func_and_grad ( x ) : <NEWLINE> <INDENT> return func ( x ) , grad ( x ) <NEWLINE> <DEDENT> class Problem ( object ) : <NEWLINE> <INDENT> def fun ( self , x ) : <NEWLINE> <INDENT> return func_and_grad ( x ) <NEWLINE> <DEDENT> <DEDENT> factr = 1e7 <NEWLINE> pgtol = 1e-5 <NEWLINE> n = 25 <NEWLINE> m = 10 <NEWLINE> bounds = [ ( None , None ) ] * n <NEWLINE> for i in range ( 0 , n , 2 ) : <NEWLINE> <INDENT> bounds [ i ] = ( 1.0 , 100 ) <NEWLINE> <DEDENT> for i in range ( 1 , n , 2 ) : <NEWLINE> <INDENT> bounds [ i ] = ( - 100 , 100 ) <NEWLINE> <DEDENT> x0 = zeros ( ( n , ) , float64 ) <NEWLINE> x0 [ : ] = 3 <NEWLINE> x , f , d = fmin_l_bfgs_b ( func , x0 , fprime = grad , m = m , <NEWLINE> <INDENT> factr = factr , pgtol = pgtol ) <NEWLINE> <DEDENT> print ( x ) <NEWLINE> print ( f ) <NEWLINE> print ( d ) <NEWLINE> x , f , d = fmin_l_bfgs_b ( func , x0 , approx_grad = 1 , <NEWLINE> <INDENT> m = m , factr = factr , pgtol = pgtol ) <NEWLINE> <DEDENT> print ( x ) <NEWLINE> print ( f ) <NEWLINE> print ( d ) <NEWLINE> x , f , d = fmin_l_bfgs_b ( func_and_grad , x0 , approx_grad = 0 , <NEWLINE> <INDENT> m = m , factr = factr , pgtol = pgtol ) <NEWLINE> <DEDENT> print ( x ) <NEWLINE> print ( f ) <NEWLINE> print ( d ) <NEWLINE> p = Problem ( ) <NEWLINE> x , f , d = fmin_l_bfgs_b ( p . fun , x0 , approx_grad = 0 , <NEWLINE> <INDENT> m = m , factr = factr , pgtol = pgtol ) <NEWLINE> <DEDENT> print ( x ) <NEWLINE> print ( f ) <NEWLINE> print ( d ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Functions\"\"\"", "'fmin_l_bfgs_b'", "\"\"\"Minimize a function func using the L-BFGS-B algorithm.\"\"\"", "'disp'", "'iprint'", "'maxcor'", "'ftol'", "'gtol'", "'eps'", "'maxfun'", "'maxiter'", "'callback'", "'grad'", "'jac'", "'task'", "'message'", "'funcalls'", "'nfev'", "'nit'", "'nit'", "'warnflag'", "'status'", "'fun'", "'x'", "\"\"\"Minimize a scalar function of one or more variables using the L-BFGS-B\"\"\"", "'length of x0 != length of bounds'", "'S60'", "'S60'", "'START'", "b'FG'", "'STOP: TOTAL NO. of f AND g EVALUATIONS '", "'EXCEEDS LIMIT'", "b'NEW_X'", "'STOP: TOTAL NO. of ITERATIONS EXCEEDS LIMIT'", "b'\\x00'", "b'CONV'", "'__main__'"]}, "window_span": [857, 862], "err_obj": {"msg": "unbalanced (){}[]"}}], ["80e0013e2b8fa8385c471808362ac5fc", {"code_string": "def add(self, protocol, port, instances = [], policies = [], cert = None, comment = None, connection_idle_timeout = None):\n    try:\n        self.add_protocol_port(protocol, port, policies, cert, comment, connection_idle_timeout = connection_idle_timeout)\n        for instance in instances:\n            self.add_backend(port, instance, policies)\n    except Exception, err:\n        servo.log.error('failed to add protocol-port: %s' % err)\n    return self\n", "code_toks_joined": "def add ( self , protocol , port , instances = [ ] , policies = [ ] , cert = None , comment = None , connection_idle_timeout = None ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . add_protocol_port ( protocol , port , policies , cert , comment , connection_idle_timeout = connection_idle_timeout ) <NEWLINE> for instance in instances : <NEWLINE> <INDENT> self . add_backend ( port , instance , policies ) <NEWLINE> <DEDENT> <DEDENT> except Exception , err : <NEWLINE> <INDENT> servo . log . error ( <STRING> % err ) <NEWLINE> <DEDENT> return self <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'failed to add protocol-port: %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["7b7e854bd79d1222f9f5b46672380459", {"code_string": "def search(folder_to_search = os.getcwd(), wildcard = '*'):\n    matches = []\n    for root, dirnames, filenames in os.walk(folder_to_search):\n        for filename in fnmatch.filter(filenames, wildcard):\n        matches.append(os.path.join(root, filename))\n    return matches\n", "code_toks_joined": "def search ( folder_to_search = os . getcwd ( ) , wildcard = <STRING> ) : <NEWLINE> <INDENT> matches = [ ] <NEWLINE> for root , dirnames , filenames in os . walk ( folder_to_search ) : <NEWLINE> <INDENT> for filename in fnmatch . filter ( filenames , wildcard ) : <NEWLINE> matches . append ( os . path . join ( root , filename ) ) <NEWLINE> <DEDENT> return matches <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'*'"]}, "err_obj": {"msg": "expected an indented block"}}], ["3e401344932555dbac4a364cf4085154", {"code_string": "def add_arguments(self, parser):\n    parser.add_argument('--force-import-all', action = 'store_true',\n        default = False, help = 'Import even if files are up-to-date.'\n    ),\n    parser.add_argument('--force-all', action = 'store_true', default = False,\n        help = 'Download and import if files are up-to-date.'\n    ),\n    parser.add_argument('--force-import', action = 'append', default = [],\n        help = 'Import even if files matching files are up-to-date'\n    ),\n    parser.add_argument('--force', action = 'append', default = [],\n        help = 'Download and import even if matching files are up-to-date'\n    ),\n    parser.add_argument('--noinsert', action = 'store_true',\n        default = False,\n        help = 'Update existing data only'\n    ),\n    parser.add_argument('--hack-translations', action = 'store_true',\n        default = False,\n        help = 'Set this if you intend to import translations a lot'\n    ),\n    parser.add_argument('--keep-slugs', action = 'store_true',\n        default = False,\n        help = 'Do not update slugs'\n    ),\n    parser.add_argument('--progress', action = 'store_true',\n        default = False,\n        help = 'Show progress bar'\n", "code_toks_joined": "def add_arguments ( self , parser ) : <NEWLINE> <INDENT> parser . add_argument ( <STRING> , action = <STRING> , <NEWLINE> <INDENT> default = False , help = <STRING> <NEWLINE> <DEDENT> ) , <NEWLINE> parser . add_argument ( <STRING> , action = <STRING> , default = False , <NEWLINE> <INDENT> help = <STRING> <NEWLINE> <DEDENT> ) , <NEWLINE> parser . add_argument ( <STRING> , action = <STRING> , default = [ ] , <NEWLINE> <INDENT> help = <STRING> <NEWLINE> <DEDENT> ) , <NEWLINE> parser . add_argument ( <STRING> , action = <STRING> , default = [ ] , <NEWLINE> <INDENT> help = <STRING> <NEWLINE> <DEDENT> ) , <NEWLINE> parser . add_argument ( <STRING> , action = <STRING> , <NEWLINE> <INDENT> default = False , <NEWLINE> help = <STRING> <NEWLINE> <DEDENT> ) , <NEWLINE> parser . add_argument ( <STRING> , action = <STRING> , <NEWLINE> <INDENT> default = False , <NEWLINE> help = <STRING> <NEWLINE> <DEDENT> ) , <NEWLINE> parser . add_argument ( <STRING> , action = <STRING> , <NEWLINE> <INDENT> default = False , <NEWLINE> help = <STRING> <NEWLINE> <DEDENT> ) , <NEWLINE> parser . add_argument ( <STRING> , action = <STRING> , <NEWLINE> <INDENT> default = False , <NEWLINE> help = <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'--force-import-all'", "'store_true'", "'Import even if files are up-to-date.'", "'--force-all'", "'store_true'", "'Download and import if files are up-to-date.'", "'--force-import'", "'append'", "'Import even if files matching files are up-to-date'", "'--force'", "'append'", "'Download and import even if matching files are up-to-date'", "'--noinsert'", "'store_true'", "'Update existing data only'", "'--hack-translations'", "'store_true'", "'Set this if you intend to import translations a lot'", "'--keep-slugs'", "'store_true'", "'Do not update slugs'", "'--progress'", "'store_true'", "'Show progress bar'"]}, "window_span": [186, 206], "err_obj": {"msg": "unbalanced (){}[]"}}], ["8c2b8bc24032f4744b720a1d17cfc770", {"code_string": "def test_reverse(self):\n    m = self.populate_MessageOfTypes()\n    m2 = dict_to_protobuf(MessageOfTypes, protobuf_to_dict(m)\n    assert m == m2\n    m2.dubl = 0\n    assert m2 != m\n", "code_toks_joined": "def test_reverse ( self ) : <NEWLINE> <INDENT> m = self . populate_MessageOfTypes ( ) <NEWLINE> m2 = dict_to_protobuf ( MessageOfTypes , protobuf_to_dict ( m ) <NEWLINE> assert m == m2 <NEWLINE> m2 . dubl = 0 <NEWLINE> assert m2 != m <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["7e19c37bfa5d0f5928c500f953e26f49", {"code_string": "def resolve_name(rule, tokens, id, args):\n    if id in[x[0] for x in tokens]:\n    if args:\n        print('Warning: ignoring parameters on TOKEN %s<<%s>>' %(id, args))\n            return parsetree.Terminal(rule, id)\n    else:\n        return parsetree.NonTerminal(rule, id, args)\n", "code_toks_joined": "def resolve_name ( rule , tokens , id , args ) : <NEWLINE> <INDENT> if id in [ x [ 0 ] for x in tokens ] : <NEWLINE> if args : <NEWLINE> <INDENT> print ( <STRING> % ( id , args ) ) <NEWLINE> <INDENT> return parsetree . Terminal ( rule , id ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return parsetree . NonTerminal ( rule , id , args ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Warning: ignoring parameters on TOKEN %s<<%s>>'"]}, "err_obj": {"msg": "expected an indented block"}}], ["0012f76ec67575a9cd7b424e0e8d09b7", {"code_string": "categories = [\"compare_and_write_mask\",\n    \"compare_and_write_minimum_or_maximum\"]\nmicrocode = ''''''\nfor category in categories:\n    exec \"import %s as cat\" % category\n    microcode += cat.microcode\n", "code_toks_joined": "categories = [ <STRING> , <NEWLINE> <INDENT> <STRING> ] <NEWLINE> <DEDENT> microcode = <STRING> <NEWLINE> for category in categories : <NEWLINE> <INDENT> exec <STRING> % category <NEWLINE> microcode += cat . microcode <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"compare_and_write_mask\"", "\"compare_and_write_minimum_or_maximum\"", "''''''", "\"import %s as cat\""]}, "err_obj": {"msg": "invalid syntax"}}], ["f2d866c182a6f93155f18fb59f934e28", {"code_string": "def _build_lang_data():\n    ret = []\n    for lang, (ignore, newname) in _build_po_list().items():\n        targetpath = os.path.join(\"share\", \"locale\", lang, \"LC_MESSAGES\")\n        ret.append((targetpath, [newname])))\n    return ret\n", "code_toks_joined": "def _build_lang_data ( ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> for lang , ( ignore , newname ) in _build_po_list ( ) . items ( ) : <NEWLINE> <INDENT> targetpath = os . path . join ( <STRING> , <STRING> , lang , <STRING> ) <NEWLINE> ret . append ( ( targetpath , [ newname ] ) ) ) <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"share\"", "\"locale\"", "\"LC_MESSAGES\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e27d2b357b1e82b1f7ed34ad8f8b0a09", {"code_string": "def __setattr__(self, attr, value):\n    if attr in[\n        \"__initialized__\",\n        \"chunks_dir\",\n        \"db_file\",\n        \"db_path\",\n        ]:\n        if self.__initialized__:\n        raise AttributeError(\"Attribute %s in %s object is read ony.\" %(self.__class__.__name__, attr))\n        else:\n        self.__dict__[attr] = value\n    elif attr in[\"connection\"]:\n        self.__dict__[attr] = value\n    else:\n        self.config_attrib_set(attr, value)\n    return value\n", "code_toks_joined": "def __setattr__ ( self , attr , value ) : <NEWLINE> <INDENT> if attr in [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> ] : <NEWLINE> if self . __initialized__ : <NEWLINE> raise AttributeError ( <STRING> % ( self . __class__ . __name__ , attr ) ) <NEWLINE> else : <NEWLINE> self . __dict__ [ attr ] = value <NEWLINE> <DEDENT> elif attr in [ <STRING> ] : <NEWLINE> <INDENT> self . __dict__ [ attr ] = value <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . config_attrib_set ( attr , value ) <NEWLINE> <DEDENT> return value <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"__initialized__\"", "\"chunks_dir\"", "\"db_file\"", "\"db_path\"", "\"Attribute %s in %s object is read ony.\"", "\"connection\""]}, "err_obj": {"msg": "expected an indented block"}}], ["15d30ebc37aeac5509c965818a632f10", {"code_string": "class ExternalData:\n    stored_in_cache = 0\n    filename = ''\n    def __init__(self, filename = '', do_cache = 1):\n    if filename and do_cache:\n        self.stored_in_cache = 1\n        instance_cache[filename] = self\n            if filename:\n                self.filename = filename\n    def __del__(self):\n    if self.stored_in_cache and instance_cache.has_key(self.filename):\n        del instance_cache[self.filename]\n    def Filename(self):\n    return self.filename\n", "code_toks_joined": "class ExternalData : <NEWLINE> <INDENT> stored_in_cache = 0 <NEWLINE> filename = <STRING> <NEWLINE> def __init__ ( self , filename = <STRING> , do_cache = 1 ) : <NEWLINE> if filename and do_cache : <NEWLINE> <INDENT> self . stored_in_cache = 1 <NEWLINE> instance_cache [ filename ] = self <NEWLINE> <INDENT> if filename : <NEWLINE> <INDENT> self . filename = filename <NEWLINE> <DEDENT> <DEDENT> <DEDENT> def __del__ ( self ) : <NEWLINE> if self . stored_in_cache and instance_cache . has_key ( self . filename ) : <NEWLINE> <INDENT> del instance_cache [ self . filename ] <NEWLINE> <DEDENT> def Filename ( self ) : <NEWLINE> return self . filename <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "''"]}, "err_obj": {"msg": "expected an indented block"}}], ["b5254cff8fa174800e59ec8895d87d1e", {"code_string": "class simpserial:\n    \"\"\"This is the SimpSerial application\"\"\"\n    def __init__(self):\n        self.gladefile = os.path.join(glade_dir, 'simpserial.glade')\n        self.wTree = gtk.glade.XML(self.gladefile, \"mainWindow\")\n            dic = {\"on_mainWindow_destroy\": self.quit,\n                \"on_quit_activate\": self.quit,\n                \"on_import_activate\": self.on_import_activate,\n                \"on_export_activate\": self.on_export_activate,\n                \"on_cut_activate\": self.on_cut_activate,\n                \"on_copy_activate\": self.on_copy_activate,\n                \"on_paste_activate\": self.on_paste_activate,\n                }\n            self.wTree.signal_autoconnect(dic)\n", "code_toks_joined": "class simpserial : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> self . gladefile = os . path . join ( glade_dir , <STRING> ) <NEWLINE> self . wTree = gtk . glade . XML ( self . gladefile , <STRING> ) <NEWLINE> <INDENT> dic = { <STRING> : self . quit , <NEWLINE> <INDENT> <STRING> : self . quit , <NEWLINE> <STRING> : self . on_import_activate , <NEWLINE> <STRING> : self . on_export_activate , <NEWLINE> <STRING> : self . on_cut_activate , <NEWLINE> <STRING> : self . on_copy_activate , <NEWLINE> <STRING> : self . on_paste_activate , <NEWLINE> } <NEWLINE> <DEDENT> self . wTree . signal_autoconnect ( dic ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"This is the SimpSerial application\"\"\"", "'simpserial.glade'", "\"mainWindow\"", "\"on_mainWindow_destroy\"", "\"on_quit_activate\"", "\"on_import_activate\"", "\"on_export_activate\"", "\"on_cut_activate\"", "\"on_copy_activate\"", "\"on_paste_activate\""]}, "err_obj": {"msg": "unexpected indent"}}], ["4a333de63ffba03e4a827bee84ff0b3f", {"code_string": "class URLPatternReverse(TestCase):\n    urls = 'regressiontests.urlpatterns_reverse.urls'\n    def test_urlpattern_reverse(self):\n        for name, expected, args, kwargs in test_data:\n            try:\n                got = reverse(name, args = args, kwargs = kwargs)\n            except NoReverseMatch, e:\n                self.assertEqual(expected, NoReverseMatch)\n            else:\n                self.assertEquals(got, expected)\n    def test_reverse_none(self):\n        self.assertRaises(NoReverseMatch, reverse, None)\n", "code_toks_joined": "class URLPatternReverse ( TestCase ) : <NEWLINE> <INDENT> urls = <STRING> <NEWLINE> def test_urlpattern_reverse ( self ) : <NEWLINE> <INDENT> for name , expected , args , kwargs in test_data : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> got = reverse ( name , args = args , kwargs = kwargs ) <NEWLINE> <DEDENT> except NoReverseMatch , e : <NEWLINE> <INDENT> self . assertEqual ( expected , NoReverseMatch ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . assertEquals ( got , expected ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> def test_reverse_none ( self ) : <NEWLINE> <INDENT> self . assertRaises ( NoReverseMatch , reverse , None ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'regressiontests.urlpatterns_reverse.urls'"]}, "err_obj": {"msg": "invalid syntax"}}], ["ab336d1ad81198a9619141799c350458", {"code_string": "def sync_user_email_addresses(user):\n    \"\"\"Keep user.email in sync with user.emailadress_set.\"\"\"\n    email = user_email(user)\n    if email and not bloodon.accounts.models.EmailAddress.objects.filter(user = user,\n        email__iexact = email).exists():\n        if app_settings.UNIQUE_EMAIL and bloodon.accounts.models.EmailAddress.objects.filter(email__iexact = email).exists():\n        return\n        bloodon.accounts.models.EmailAddress.objects.create(user = user,\n        email = email,\n        primary = False,\n        verified = False)\n", "code_toks_joined": "def sync_user_email_addresses ( user ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> email = user_email ( user ) <NEWLINE> if email and not bloodon . accounts . models . EmailAddress . objects . filter ( user = user , <NEWLINE> <INDENT> email__iexact = email ) . exists ( ) : <NEWLINE> if app_settings . UNIQUE_EMAIL and bloodon . accounts . models . EmailAddress . objects . filter ( email__iexact = email ) . exists ( ) : <NEWLINE> return <NEWLINE> bloodon . accounts . models . EmailAddress . objects . create ( user = user , <NEWLINE> email = email , <NEWLINE> primary = False , <NEWLINE> verified = False ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Keep user.email in sync with user.emailadress_set.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["180f32060812181aec5632700b8d37f0", {"code_string": "def main():\n    children = [] Child()\n    p = Parent(1000, children)\n    print('parent:', p)\n    c1 = p.create_child(1, p)\n    c2 = p.create_child(2, p)\n    c3 = p.create_child(3, p)\n    print('children:')\n    print(c1)\n    print(c2)\n    print(c3)\n", "code_toks_joined": "def main ( ) : <NEWLINE> <INDENT> children = [ ] Child ( ) <NEWLINE> p = Parent ( 1000 , children ) <NEWLINE> print ( <STRING> , p ) <NEWLINE> c1 = p . create_child ( 1 , p ) <NEWLINE> c2 = p . create_child ( 2 , p ) <NEWLINE> c3 = p . create_child ( 3 , p ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( c1 ) <NEWLINE> print ( c2 ) <NEWLINE> print ( c3 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'parent:'", "'children:'"]}, "err_obj": {"msg": "invalid syntax"}}], ["5afd8f2540ef0bcc2af3cc20ac9d01d8", {"code_string": "class MockPlatform(object):\n    \"\"\"Provide a fake platform.\"\"\"\n    def __init__(self, setup_platform = None, dependencies = None,\n        platform_schema = None):\n        \"\"\"Initialize the platform.\"\"\"\n        self.DEPENDENCIES = dependencies or[]\n        self._setup_platform = setup_platform\n        if platform_schema is not None:\n        self.PLATFORM_SCHEMA = platform_schema\n    def setup_platform(self, hass, config, add_devices, discovery_info = None):\n        \"\"\"Setup the platform.\"\"\"\n        if self._setup_platform is not None:\n            self._setup_platform(hass, config, add_devices, discovery_info)\n", "code_toks_joined": "class MockPlatform ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , setup_platform = None , dependencies = None , <NEWLINE> <INDENT> platform_schema = None ) : <NEWLINE> <STRING> <NEWLINE> self . DEPENDENCIES = dependencies or [ ] <NEWLINE> self . _setup_platform = setup_platform <NEWLINE> if platform_schema is not None : <NEWLINE> self . PLATFORM_SCHEMA = platform_schema <NEWLINE> <DEDENT> def setup_platform ( self , hass , config , add_devices , discovery_info = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . _setup_platform is not None : <NEWLINE> <INDENT> self . _setup_platform ( hass , config , add_devices , discovery_info ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Provide a fake platform.\"\"\"", "\"\"\"Initialize the platform.\"\"\"", "\"\"\"Setup the platform.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["0a136d68abec8bcbbfaccbe1d65e8eed", {"code_string": "def _check(self, sock_info):\n    \"\"\"This side-effecty function checks if this pool has been reset since\"\"\"\n    error = False\n    age = _time() - sock_info.last_checkout\n    if(self._check_interval_seconds is not None\n        and(\n            0 == self._check_interval_seconds\n            or age > self._check_interval_seconds)):\n            if socket_closed(sock_info.sock):\n        sock_info.close()\n        error = True\n    if not error:\n        return sock_info\n    else:\n        return self.connect()\n", "code_toks_joined": "def _check ( self , sock_info ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> error = False <NEWLINE> age = _time ( ) - sock_info . last_checkout <NEWLINE> if ( self . _check_interval_seconds is not None <NEWLINE> <INDENT> and ( <NEWLINE> <INDENT> 0 == self . _check_interval_seconds <NEWLINE> or age > self . _check_interval_seconds ) ) : <NEWLINE> if socket_closed ( sock_info . sock ) : <NEWLINE> <DEDENT> sock_info . close ( ) <NEWLINE> error = True <NEWLINE> <DEDENT> if not error : <NEWLINE> <INDENT> return sock_info <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . connect ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"This side-effecty function checks if this pool has been reset since\"\"\""]}, "err_obj": {"msg": "unindent does not match any outer indentation level"}}], ["6bd4d39b7cd5a31a53e53142d14fe994", {"code_string": "import sys\nimport os\nfrom stat import S_IRUSR, S_IWUSR, S_IRGRP, S_IROTH\nfrom distutils.core import setup\nfrom distutils.command.install import install as _install\nfrom distutils.command.install_data import install_data as _install_data\ntry:\n    from Cython.Build import cythonize\n    extensions = cythonize(\"printrun/gcoder_line.pyx\")\n    from Cython.Distutils import build_ext\nexcept ImportError, e:\n    print(\"WARNING: Failed to cythonize: %s\" % e)\n    extensions = None\n    build_ext = None\nfrom printrun.printcore import __version__ as printcore_version\nINSTALLED_FILES = \"installed_files\"\n", "code_toks_joined": "import sys <NEWLINE> import os <NEWLINE> from stat import S_IRUSR , S_IWUSR , S_IRGRP , S_IROTH <NEWLINE> from distutils . core import setup <NEWLINE> from distutils . command . install import install as _install <NEWLINE> from distutils . command . install_data import install_data as _install_data <NEWLINE> try : <NEWLINE> <INDENT> from Cython . Build import cythonize <NEWLINE> extensions = cythonize ( <STRING> ) <NEWLINE> from Cython . Distutils import build_ext <NEWLINE> <DEDENT> except ImportError , e : <NEWLINE> <INDENT> print ( <STRING> % e ) <NEWLINE> extensions = None <NEWLINE> build_ext = None <NEWLINE> <DEDENT> from printrun . printcore import __version__ as printcore_version <NEWLINE> INSTALLED_FILES = <STRING> <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"printrun/gcoder_line.pyx\"", "\"WARNING: Failed to cythonize: %s\"", "\"installed_files\""]}, "err_obj": {"msg": "invalid syntax"}}], ["09a88c7a87e6d42518df2f06335fee7c", {"code_string": "def __init__(self, * args, ** kwargs):\n    self.num = Walker.number\n    Walker.number += 1\n    self.initialPosition()\n    self.initialVelocity()\n    self.a = 1000000 git\n    self.markerSize = 4\n", "code_toks_joined": "def __init__ ( self , * args , ** kwargs ) : <NEWLINE> <INDENT> self . num = Walker . number <NEWLINE> Walker . number += 1 <NEWLINE> self . initialPosition ( ) <NEWLINE> self . initialVelocity ( ) <NEWLINE> self . a = 1000000 git <NEWLINE> self . markerSize = 4 <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["19ce976f86c63e4b77d81668a57b794c", {"code_string": "def __init__(self, lines, generate = custom_generator)\n    self.lines = lines\n    self._generate = generate\n", "code_toks_joined": "def __init__ ( self , lines , generate = custom_generator ) <NEWLINE> <INDENT> self . lines = lines <NEWLINE> self . _generate = generate <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["3c75014632b963a0337fafacad88492c", {"code_string": "def collect((sql, hostname, username, password, db_name)):\n    print(\"Running on %s\" % db_name)\n    current_process_name = current_process().name\n    if current_process_name not in CONNECTIONS:\n        print(\"Creating a new connection for worker %s\" % current_process_name)\n        CONNECTIONS[current_process_name] = get_connection(\n            hostname, username, password)\n    conn = CONNECTIONS[current_process_name]\n    query(conn, \"USE %s\" % db_name)\n    collected = query(conn, sql.format(db_name = db_name))\n    print(\"%d rows returned for %s\" %(len(collected), db_name))\n    return db_name, collected\n", "code_toks_joined": "def collect ( ( sql , hostname , username , password , db_name ) ) : <NEWLINE> <INDENT> print ( <STRING> % db_name ) <NEWLINE> current_process_name = current_process ( ) . name <NEWLINE> if current_process_name not in CONNECTIONS : <NEWLINE> <INDENT> print ( <STRING> % current_process_name ) <NEWLINE> CONNECTIONS [ current_process_name ] = get_connection ( <NEWLINE> <INDENT> hostname , username , password ) <NEWLINE> <DEDENT> <DEDENT> conn = CONNECTIONS [ current_process_name ] <NEWLINE> query ( conn , <STRING> % db_name ) <NEWLINE> collected = query ( conn , sql . format ( db_name = db_name ) ) <NEWLINE> print ( <STRING> % ( len ( collected ) , db_name ) ) <NEWLINE> return db_name , collected <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Running on %s\"", "\"Creating a new connection for worker %s\"", "\"USE %s\"", "\"%d rows returned for %s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["88e1a48fa3734c33ce474b685dd1759b", {"code_string": "def _execute(self, all_targets):\n    test_targets = self._get_test_targets()\n    if test_targets:\n        self.context.release_lock()\n        with self.context.new_workunit(name = 'run',\n            labels = [WorkUnitLabel.TOOL, WorkUnitLabel.TEST]) as workunit:\n            cols = os.environ.get('COLUMNS', 80)\n            with environment_as(COLUMNS = str(int(cols) - 30)):\n            self.run_tests(test_targets, workunit)\n", "code_toks_joined": "def _execute ( self , all_targets ) : <NEWLINE> <INDENT> test_targets = self . _get_test_targets ( ) <NEWLINE> if test_targets : <NEWLINE> <INDENT> self . context . release_lock ( ) <NEWLINE> with self . context . new_workunit ( name = <STRING> , <NEWLINE> <INDENT> labels = [ WorkUnitLabel . TOOL , WorkUnitLabel . TEST ] ) as workunit : <NEWLINE> cols = os . environ . get ( <STRING> , 80 ) <NEWLINE> with environment_as ( COLUMNS = str ( int ( cols ) - 30 ) ) : <NEWLINE> self . run_tests ( test_targets , workunit ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'run'", "'COLUMNS'"]}, "err_obj": {"msg": "expected an indented block"}}], ["3ffda44ff3d6379a2e2a24c2c6e5403e", {"code_string": "def get_value_for_attribute(attribute):\n    \"\"\"For a given key return the value.\"\"\"\n    path = '/computeMetadata/v1/instance/attributes/%s' % attribute\n    try:\n        http_response = _issue_http_request(\n            path, HTTP_GET, REQUIRED_METADATA_HEADER)\n        read_response = http_response.read()\n        return read_response\n    except(TypeError, ValueError,\n        errors.MetadataServerHttpError) as e:\n        LOGGER.error('Unable to read value for attribute key %s '\n            'from metadata server: %s', attribute, e)\n            return None\n", "code_toks_joined": "def get_value_for_attribute ( attribute ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> path = <STRING> % attribute <NEWLINE> try : <NEWLINE> <INDENT> http_response = _issue_http_request ( <NEWLINE> <INDENT> path , HTTP_GET , REQUIRED_METADATA_HEADER ) <NEWLINE> <DEDENT> read_response = http_response . read ( ) <NEWLINE> return read_response <NEWLINE> <DEDENT> except ( TypeError , ValueError , <NEWLINE> <INDENT> errors . MetadataServerHttpError ) as e : <NEWLINE> LOGGER . error ( <STRING> <NEWLINE> <INDENT> <STRING> , attribute , e ) <NEWLINE> return None <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"For a given key return the value.\"\"\"", "'/computeMetadata/v1/instance/attributes/%s'", "'Unable to read value for attribute key %s '", "'from metadata server: %s'"]}, "err_obj": {"msg": "unexpected indent"}}], ["589db06c71ba62457049acc0031de597", {"code_string": "def input_from_file(filename, mode = 'r'):\n    with contextlib.closing(open(filename, mode)) as port:\n    with CURRENT_INPUT_PORT.let(port):\n        yield\n", "code_toks_joined": "def input_from_file ( filename , mode = <STRING> ) : <NEWLINE> <INDENT> with contextlib . closing ( open ( filename , mode ) ) as port : <NEWLINE> with CURRENT_INPUT_PORT . let ( port ) : <NEWLINE> <INDENT> yield <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'r'"]}, "err_obj": {"msg": "expected an indented block"}}], ["f14d253907f0cbf4db4679f3b01a196a", {"code_string": "def _predictions_mean(predictions, weights = None, name = None):\n    with ops.name_scope(\n        name, 'predictions_mean', (predictions, weights)) as scope:\n        predictions = math_ops.to_float(predictions, name = 'predictions')\n        if weights is not None:\n        weights = weights_broadcast_ops.broadcast_weights(weights, predictions)\n        return metrics_lib.mean(predictions, weights = weights, name = scope)\n", "code_toks_joined": "def _predictions_mean ( predictions , weights = None , name = None ) : <NEWLINE> <INDENT> with ops . name_scope ( <NEWLINE> <INDENT> name , <STRING> , ( predictions , weights ) ) as scope : <NEWLINE> predictions = math_ops . to_float ( predictions , name = <STRING> ) <NEWLINE> if weights is not None : <NEWLINE> weights = weights_broadcast_ops . broadcast_weights ( weights , predictions ) <NEWLINE> return metrics_lib . mean ( predictions , weights = weights , name = scope ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'predictions_mean'", "'predictions'"]}, "err_obj": {"msg": "expected an indented block"}}], ["7e74e8493e4400019d834a8df367c4c0", {"code_string": "def rm(dest):\n    \"\"\" Remove a file \"\"\"\n    try:\n        _os.unlink(native(dest))\n    except OSError, e:\n        if _errno.ENOENT != e.errno:\n            raise\n", "code_toks_joined": "def rm ( dest ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> _os . unlink ( native ( dest ) ) <NEWLINE> <DEDENT> except OSError , e : <NEWLINE> <INDENT> if _errno . ENOENT != e . errno : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Remove a file \"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["20a02deeaee5b789e8d30190894d78dc", {"code_string": "def sparse_softmax_cross_entropy(logits, labels, weights = 1.0, scope = None):\n    \"\"\"Cross-entropy loss using `tf.nn.sparse_softmax_cross_entropy_with_logits`.\"\"\"\n    with ops.name_scope(scope, \"sparse_softmax_cross_entropy_loss\",\n        [logits, labels, weights]) as scope:\n        labels = array_ops.reshape(labels, shape = [array_ops.shape(labels)[0]])\n        weights = array_ops.squeeze(weights)\n        losses = nn.sparse_softmax_cross_entropy_with_logits(logits, labels,\n            name = \"xentropy\")\n            return compute_weighted_loss(losses, weights, scope = scope)\n", "code_toks_joined": "def sparse_softmax_cross_entropy ( logits , labels , weights = 1.0 , scope = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with ops . name_scope ( scope , <STRING> , <NEWLINE> <INDENT> [ logits , labels , weights ] ) as scope : <NEWLINE> labels = array_ops . reshape ( labels , shape = [ array_ops . shape ( labels ) [ 0 ] ] ) <NEWLINE> weights = array_ops . squeeze ( weights ) <NEWLINE> losses = nn . sparse_softmax_cross_entropy_with_logits ( logits , labels , <NEWLINE> <INDENT> name = <STRING> ) <NEWLINE> return compute_weighted_loss ( losses , weights , scope = scope ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Cross-entropy loss using `tf.nn.sparse_softmax_cross_entropy_with_logits`.\"\"\"", "\"sparse_softmax_cross_entropy_loss\"", "\"xentropy\""]}, "err_obj": {"msg": "unexpected indent"}}], ["4af13ac535b0a13071cc2e55c26481fb", {"code_string": "def test_integer(self):\n    ctx = typing.Context()\n    for aty, bty in itertools.product(types.integer_domain,\n        types.integer_domain):\n        key = (str(aty), str(bty))\n        try:\n        expected = self.int_unify[key]\n        except KeyError:\n        expected = self.int_unify[key[: : - 1]]\n        self.assert_unify(aty, bty, getattr(types, expected))\n", "code_toks_joined": "def test_integer ( self ) : <NEWLINE> <INDENT> ctx = typing . Context ( ) <NEWLINE> for aty , bty in itertools . product ( types . integer_domain , <NEWLINE> <INDENT> types . integer_domain ) : <NEWLINE> key = ( str ( aty ) , str ( bty ) ) <NEWLINE> try : <NEWLINE> expected = self . int_unify [ key ] <NEWLINE> except KeyError : <NEWLINE> expected = self . int_unify [ key [ : : - 1 ] ] <NEWLINE> self . assert_unify ( aty , bty , getattr ( types , expected ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["738bd276e3baf8caed0743fa7a3d657e", {"code_string": "def key_even_by_priority(self):\n    hasHost = 0\n    if self.JobStatus.hostsOnJob() > 0: hasHost = 1\n    sortKey = '%01d-%03d-%04d-%04d-%10d' %(hasHost, self.Job.priority(), self.JobStatus.hostsOnJob(), self.JobStatus.errorCount(), self.Job.submittedts().toTime_t())\n    if VERBOSE_DEBUG:\n        print 'job %s has sortKey %s' %(self.Job.name(), sortKey)\n    return sortKey\n", "code_toks_joined": "def key_even_by_priority ( self ) : <NEWLINE> <INDENT> hasHost = 0 <NEWLINE> if self . JobStatus . hostsOnJob ( ) > 0 : hasHost = 1 <NEWLINE> sortKey = <STRING> % ( hasHost , self . Job . priority ( ) , self . JobStatus . hostsOnJob ( ) , self . JobStatus . errorCount ( ) , self . Job . submittedts ( ) . toTime_t ( ) ) <NEWLINE> if VERBOSE_DEBUG : <NEWLINE> <INDENT> print <STRING> % ( self . Job . name ( ) , sortKey ) <NEWLINE> <DEDENT> return sortKey <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'%01d-%03d-%04d-%04d-%10d'", "'job %s has sortKey %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["2682e982bf94a58011964295fb4093cf", {"code_string": "def retranslateUi(self, TabnannyDialog):\n    _translate = QtCore.QCoreApplication.translate\n    TabnannyDialog.setWindowTitle(_translate(\"TabnannyDialog\", \"Tabnanny Result\"))\n    TabnannyDialog.setWhatsThis(_translate(\"TabnannyDialog\", \"<b>Tabnanny Results</b>\\n\"\n", "code_toks_joined": "def retranslateUi ( self , TabnannyDialog ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> TabnannyDialog . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> TabnannyDialog . setWhatsThis ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"TabnannyDialog\"", "\"Tabnanny Result\"", "\"TabnannyDialog\"", "\"<b>Tabnanny Results</b>\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["1be6c2d3c3280de6952185915663d723", {"code_string": "def select_vendor():\n    vendors = get_vendors()['params']['vendors']\n    if not vendors:\n        print(\"\\n    No vendors found. Please install guh-plugins and restart guhd.\")\n        return \"\"\n    vendorList = []\n    vendorIdList = []\n    for i in range(0, len(vendors)):\n        vendorList.append(vendors[i]['name'])\n        vendorIdList.append(vendors[i]['id'])\n    selection = get_selection(\"Please select vendor\", vendorList)\n    if selection != None:\n    return vendorIdList[selection]\n", "code_toks_joined": "def select_vendor ( ) : <NEWLINE> <INDENT> vendors = get_vendors ( ) [ <STRING> ] [ <STRING> ] <NEWLINE> if not vendors : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <STRING> <NEWLINE> <DEDENT> vendorList = [ ] <NEWLINE> vendorIdList = [ ] <NEWLINE> for i in range ( 0 , len ( vendors ) ) : <NEWLINE> <INDENT> vendorList . append ( vendors [ i ] [ <STRING> ] ) <NEWLINE> vendorIdList . append ( vendors [ i ] [ <STRING> ] ) <NEWLINE> <DEDENT> selection = get_selection ( <STRING> , vendorList ) <NEWLINE> if selection != None : <NEWLINE> return vendorIdList [ selection ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'params'", "'vendors'", "\"\\n    No vendors found. Please install guh-plugins and restart guhd.\"", "\"\"", "'name'", "'id'", "\"Please select vendor\""]}, "err_obj": {"msg": "expected an indented block"}}], ["3f6e33e96c1646d05a245637788de476", {"code_string": "def _noncvx_id_to_idx(dims, var_offsets, var_sizes):\n    \"\"\"Converts the nonconvex constraint variable ids in dims into indices.\"\"\"\n    bool_idx = []\n    int_idx = []\n    for indices, constr_type in zip([bool_idx, int_idx],\n        [s.BOOL_IDS, s.INT_IDS]):\n        for var_id in dims[constr_type]:\n        offset = var_offsets[var_id]\n        size = var_sizes[var_id]\n        for i in range(size[0] * size[1]):\n        indices.append(offset + i)\n        del dims[constr_type]\n    return bool_idx, int_idx\n", "code_toks_joined": "def _noncvx_id_to_idx ( dims , var_offsets , var_sizes ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> bool_idx = [ ] <NEWLINE> int_idx = [ ] <NEWLINE> for indices , constr_type in zip ( [ bool_idx , int_idx ] , <NEWLINE> <INDENT> [ s . BOOL_IDS , s . INT_IDS ] ) : <NEWLINE> for var_id in dims [ constr_type ] : <NEWLINE> offset = var_offsets [ var_id ] <NEWLINE> size = var_sizes [ var_id ] <NEWLINE> for i in range ( size [ 0 ] * size [ 1 ] ) : <NEWLINE> indices . append ( offset + i ) <NEWLINE> del dims [ constr_type ] <NEWLINE> <DEDENT> return bool_idx , int_idx <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Converts the nonconvex constraint variable ids in dims into indices.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["9655839b6ea90e1c9c3b09c64bafb552", {"code_string": "def test_ToEPCTagUri(self):\n    print(\"***==== Test To EPC Tag Uri Value ====***\"\n    epc = self._sgln96.encode(self._companyPrefix, None, self._locationReference, self._filter, self._extension)\n    print(epc.toEPCTagUri())\n    print(\"***==== END  Test To EPC Tag Uri Value ====***\"\n    print(\"\"\n", "code_toks_joined": "def test_ToEPCTagUri ( self ) : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> epc = self . _sgln96 . encode ( self . _companyPrefix , None , self . _locationReference , self . _filter , self . _extension ) <NEWLINE> print ( epc . toEPCTagUri ( ) ) <NEWLINE> print ( <STRING> <NEWLINE> print ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"***==== Test To EPC Tag Uri Value ====***\"", "\"***==== END  Test To EPC Tag Uri Value ====***\"", "\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e1f394a273918b0a8170776b264da67d", {"code_string": "def setupUi(self, StartForm):\n    StartForm.setObjectName(\"StartForm\")\n    StartForm.resize(604, 347)\n    StartForm.setMinimumSize(QtCore.QSize(604, 347))\n    StartForm.setMaximumSize(QtCore.QSize(604, 347))\n    icon = QtGui.QIcon()\n    icon.addPixmap(QtGui.QPixmap(\"images/app.ico\"), QtGui.QIcon.Normal, QtGui.QIcon.Off)\n    StartForm.setWindowIcon(icon)\n    self.label = QtWidgets.QLabel(StartForm)\n    self.label.setGeometry(QtCore.QRect(- 30, - 90, 641, 521))\n    self.label.setText(\"\")\n    self.label.setPixmap(QtGui.QPixmap(\"images/desktopwallpapers.org.ua-2725.jpg\"))\n    self.label.setObjectName(\"label\")\n    self.label_2 = QtWidgets.QLabel(StartForm)\n    self.label_2.setGeometry(QtCore.QRect(0, - 10, 601, 81))\n    font = QtGui.QFont()\n    font.setFamily(\"Arial Black\")\n    self.label_2.setFont(font)\n    self.label_2.setAlignment(QtCore.Qt.AlignCenter)\n    self.label_2.setObjectName(\"label_2\")\n    self.label_3 = QtWidgets.QLabel(StartForm)\n    self.label_3.setGeometry(QtCore.QRect(0, 50, 601, 91))\n    font = QtGui.QFont()\n    font.setFamily(\"Arial Black\")\n    self.label_3.setFont(font)\n    self.label_3.setAlignment(QtCore.Qt.AlignCenter)\n    self.label_3.setObjectName(\"label_3\")\n    self.label_5 = QtWidgets.QLabel(StartForm)\n    self.label_5.setGeometry(QtCore.QRect(110, 150, 291, 51))\n    font = QtGui.QFont()\n    font.setFamily(\"Arial Black\")\n    self.label_5.setFont(font)\n    self.label_5.setAlignment(QtCore.Qt.AlignCenter)\n    self.label_5.setObjectName(\"label_5\")\n    self.edDiff = QtWidgets.QLineEdit(StartForm)\n    self.edDiff.setGeometry(QtCore.QRect(410, 160, 61, 31))\n    font = QtGui.QFont()\n    font.setFamily(\"Arial\")\n    font.setPointSize(15)\n    font.setBold(True)\n    font.setItalic(False)\n    font.setWeight(75)\n    self.edDiff.setFont(font)\n    self.edDiff.setStyleSheet(\"QLineEdit {\\n\"\n", "code_toks_joined": "def setupUi ( self , StartForm ) : <NEWLINE> <INDENT> StartForm . setObjectName ( <STRING> ) <NEWLINE> StartForm . resize ( 604 , 347 ) <NEWLINE> StartForm . setMinimumSize ( QtCore . QSize ( 604 , 347 ) ) <NEWLINE> StartForm . setMaximumSize ( QtCore . QSize ( 604 , 347 ) ) <NEWLINE> icon = QtGui . QIcon ( ) <NEWLINE> icon . addPixmap ( QtGui . QPixmap ( <STRING> ) , QtGui . QIcon . Normal , QtGui . QIcon . Off ) <NEWLINE> StartForm . setWindowIcon ( icon ) <NEWLINE> self . label = QtWidgets . QLabel ( StartForm ) <NEWLINE> self . label . setGeometry ( QtCore . QRect ( - 30 , - 90 , 641 , 521 ) ) <NEWLINE> self . label . setText ( <STRING> ) <NEWLINE> self . label . setPixmap ( QtGui . QPixmap ( <STRING> ) ) <NEWLINE> self . label . setObjectName ( <STRING> ) <NEWLINE> self . label_2 = QtWidgets . QLabel ( StartForm ) <NEWLINE> self . label_2 . setGeometry ( QtCore . QRect ( 0 , - 10 , 601 , 81 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setFamily ( <STRING> ) <NEWLINE> self . label_2 . setFont ( font ) <NEWLINE> self . label_2 . setAlignment ( QtCore . Qt . AlignCenter ) <NEWLINE> self . label_2 . setObjectName ( <STRING> ) <NEWLINE> self . label_3 = QtWidgets . QLabel ( StartForm ) <NEWLINE> self . label_3 . setGeometry ( QtCore . QRect ( 0 , 50 , 601 , 91 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setFamily ( <STRING> ) <NEWLINE> self . label_3 . setFont ( font ) <NEWLINE> self . label_3 . setAlignment ( QtCore . Qt . AlignCenter ) <NEWLINE> self . label_3 . setObjectName ( <STRING> ) <NEWLINE> self . label_5 = QtWidgets . QLabel ( StartForm ) <NEWLINE> self . label_5 . setGeometry ( QtCore . QRect ( 110 , 150 , 291 , 51 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setFamily ( <STRING> ) <NEWLINE> self . label_5 . setFont ( font ) <NEWLINE> self . label_5 . setAlignment ( QtCore . Qt . AlignCenter ) <NEWLINE> self . label_5 . setObjectName ( <STRING> ) <NEWLINE> self . edDiff = QtWidgets . QLineEdit ( StartForm ) <NEWLINE> self . edDiff . setGeometry ( QtCore . QRect ( 410 , 160 , 61 , 31 ) ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setFamily ( <STRING> ) <NEWLINE> font . setPointSize ( 15 ) <NEWLINE> font . setBold ( True ) <NEWLINE> font . setItalic ( False ) <NEWLINE> font . setWeight ( 75 ) <NEWLINE> self . edDiff . setFont ( font ) <NEWLINE> self . edDiff . setStyleSheet ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"StartForm\"", "\"images/app.ico\"", "\"\"", "\"images/desktopwallpapers.org.ua-2725.jpg\"", "\"label\"", "\"Arial Black\"", "\"label_2\"", "\"Arial Black\"", "\"label_3\"", "\"Arial Black\"", "\"label_5\"", "\"Arial\"", "\"QLineEdit {\\n\""]}, "window_span": [478, 482], "err_obj": {"msg": "unbalanced (){}[]"}}], ["85c323e5a538bdf967c630e233eb607e", {"code_string": "def post_install(self, branch):\n    if os.path.isfile(postscript):\n        if os.access(postscript, os.X_OK):\n            logger.debug(\"Running post-install script: %s\" % postscript)\n            run_command(\"%s %s\" %(postscript, branch.replace('_', '-').lower()))\n        else:\n            logger.debug(\"Post-install script is not executable: %s\" %\n                postscript)\n                return\n", "code_toks_joined": "def post_install ( self , branch ) : <NEWLINE> <INDENT> if os . path . isfile ( postscript ) : <NEWLINE> <INDENT> if os . access ( postscript , os . X_OK ) : <NEWLINE> <INDENT> logger . debug ( <STRING> % postscript ) <NEWLINE> run_command ( <STRING> % ( postscript , branch . replace ( <STRING> , <STRING> ) . lower ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> logger . debug ( <STRING> % <NEWLINE> <INDENT> postscript ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Running post-install script: %s\"", "\"%s %s\"", "'_'", "'-'", "\"Post-install script is not executable: %s\""]}, "err_obj": {"msg": "unexpected indent"}}], ["12d459eb1626d8dcbd2ee0fdc8a5bf6e", {"code_string": "def printColLabels(board):\n    (rows, cols) = (7, 7)\n    print(\"  \", )\n    for col in xrange(cols):\n        print chr(ord(\"A\") + col),\n    print\n", "code_toks_joined": "def printColLabels ( board ) : <NEWLINE> <INDENT> ( rows , cols ) = ( 7 , 7 ) <NEWLINE> print ( <STRING> , ) <NEWLINE> for col in xrange ( cols ) : <NEWLINE> <INDENT> print chr ( ord ( <STRING> ) + col ) , <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"  \"", "\"A\""]}, "err_obj": {"msg": "invalid syntax"}}], ["852bfdf5632802f93a56f7fc8fcb5656", {"code_string": "class ExprGraph:\n    var graph: Code\n    var term: Term\n", "code_toks_joined": "class ExprGraph : <NEWLINE> <INDENT> var graph : Code <NEWLINE> var term : Term <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["9787ad4c36758680eb748047817ca2a8", {"code_string": "def setUp(self):\n    UTConversionDataArrayNumPy.setUp(self)\n    size = self.footprint // np.nbytes[self.dtype]\n    digits, shape = shapeopt(1000, size, ndims = 3, ecc = 0.3)\n    if self.verbose >= 1:\n        print 'digits=%8.3f, shape=%s' %(digits, shape)\n    self.shape = shape +(1, )\n    self.assertAlmostEqual(np.prod(self.shape) * np.nbytes[self.dtype], self.footprint, - 4)\n", "code_toks_joined": "def setUp ( self ) : <NEWLINE> <INDENT> UTConversionDataArrayNumPy . setUp ( self ) <NEWLINE> size = self . footprint // np . nbytes [ self . dtype ] <NEWLINE> digits , shape = shapeopt ( 1000 , size , ndims = 3 , ecc = 0.3 ) <NEWLINE> if self . verbose >= 1 : <NEWLINE> <INDENT> print <STRING> % ( digits , shape ) <NEWLINE> <DEDENT> self . shape = shape + ( 1 , ) <NEWLINE> self . assertAlmostEqual ( np . prod ( self . shape ) * np . nbytes [ self . dtype ] , self . footprint , - 4 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'digits=%8.3f, shape=%s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["2f3768e3e625f3cd6892a6b29d10cd45", {"code_string": "def CompareLines():\n    MAX_VAL = - 1\n    preSet()\n    for i in range(0, m_lines.size()):\n        for j in range(0, m_lines.size()):\n            if(i == j): continue\n            lossMatrix[i][j] = getLossFunc(m_lines[i]), m_lines[j])\n            if(lossMatrix[i][j] > MAX_VAL):\n                MAX_VAL = lossMatrix[i][j]\n                resultLine.first = m_lines[i]\n                resultLine.second = m_lines[j]\n    return resultLine\n", "code_toks_joined": "def CompareLines ( ) : <NEWLINE> <INDENT> MAX_VAL = - 1 <NEWLINE> preSet ( ) <NEWLINE> for i in range ( 0 , m_lines . size ( ) ) : <NEWLINE> <INDENT> for j in range ( 0 , m_lines . size ( ) ) : <NEWLINE> <INDENT> if ( i == j ) : continue <NEWLINE> lossMatrix [ i ] [ j ] = getLossFunc ( m_lines [ i ] ) , m_lines [ j ] ) <NEWLINE> if ( lossMatrix [ i ] [ j ] > MAX_VAL ) : <NEWLINE> <INDENT> MAX_VAL = lossMatrix [ i ] [ j ] <NEWLINE> resultLine . first = m_lines [ i ] <NEWLINE> resultLine . second = m_lines [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return resultLine <NEWLINE> <DEDENT>", "anonymize_dict": {}, "window_span": [57, 79], "err_obj": {"msg": "unbalanced (){}[]"}}], ["241e150ecf9bf7ad24f5f414db5a6aa2", {"code_string": "    difference = datetime.datetime.now() - birthday\n    for vaccine in vaccineTimes:\n        if difference >= vaccineTimes[vaccine] and db[from_number][vaccine] == 0:\n            response.sms(\"VaMoNoS! LET'S GO get your \" + vaccine.upper() + \" vaccine!\")\n", "code_toks_joined": "<INDENT> difference = datetime . datetime . now ( ) - birthday <NEWLINE> for vaccine in vaccineTimes : <NEWLINE> <INDENT> if difference >= vaccineTimes [ vaccine ] and db [ from_number ] [ vaccine ] == 0 : <NEWLINE> <INDENT> response . sms ( <STRING> + vaccine . upper ( ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"VaMoNoS! LET'S GO get your \"", "\" vaccine!\""]}, "err_obj": {"msg": "unexpected indent"}}], ["d2decf5437faa2d3cc6525f0febef24c", {"code_string": "def returnSearch():\n    assert request.method == 'POST'\n    searchTerm = request.form['searchTerm']\n    ll = findCenterMinLargest(listOfOrigin)[0]\n    businessJson = yelpSearch(ll, searchTerm)\n        teles = timeSearch(ll)\n    return render_template('home.html', dest = businessJson, teles3 = teles, listOfOrigin = listOfOrigin, latC = ll[0], lngC = ll[1])\n", "code_toks_joined": "def returnSearch ( ) : <NEWLINE> <INDENT> assert request . method == <STRING> <NEWLINE> searchTerm = request . form [ <STRING> ] <NEWLINE> ll = findCenterMinLargest ( listOfOrigin ) [ 0 ] <NEWLINE> businessJson = yelpSearch ( ll , searchTerm ) <NEWLINE> <INDENT> teles = timeSearch ( ll ) <NEWLINE> <DEDENT> return render_template ( <STRING> , dest = businessJson , teles3 = teles , listOfOrigin = listOfOrigin , latC = ll [ 0 ] , lngC = ll [ 1 ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'POST'", "'searchTerm'", "'home.html'"]}, "err_obj": {"msg": "unexpected indent"}}], ["24d184515de3acc04fe40e8e5078846e", {"code_string": "def collect(self):\n    methods = self.methods()\n    for socket in sorted(self.session.plugins.collect(\"socket\"),\n        key = lambda socket: socket.last_pid):\n        row = [socket]\n        for method in methods:\n        row.append(method in socket.obj_producers)\n        yield row\n", "code_toks_joined": "def collect ( self ) : <NEWLINE> <INDENT> methods = self . methods ( ) <NEWLINE> for socket in sorted ( self . session . plugins . collect ( <STRING> ) , <NEWLINE> <INDENT> key = lambda socket : socket . last_pid ) : <NEWLINE> row = [ socket ] <NEWLINE> for method in methods : <NEWLINE> row . append ( method in socket . obj_producers ) <NEWLINE> yield row <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"socket\""]}, "err_obj": {"msg": "expected an indented block"}}], ["711866a69421004216b894a98a6c36db", {"code_string": "def entropyGain(data, clposition = LAST):\n    \"\"\"Computes the entropy gain of each attributes and returns a list\"\"\"\n    assert type(clposition) is IntType\n    data = _checkData(data)\n    egains = []\n    for a in range(len(data[0]):\n        egains.append(egain(data, a, clposition))\n    egains.pop(clposition)\n    return egains\n", "code_toks_joined": "def entropyGain ( data , clposition = LAST ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> assert type ( clposition ) is IntType <NEWLINE> data = _checkData ( data ) <NEWLINE> egains = [ ] <NEWLINE> for a in range ( len ( data [ 0 ] ) : <NEWLINE> <INDENT> egains . append ( egain ( data , a , clposition ) ) <NEWLINE> <DEDENT> egains . pop ( clposition ) <NEWLINE> return egains <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Computes the entropy gain of each attributes and returns a list\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["ef240bcbc0e933af9e6938323c16f98a", {"code_string": "from BoostBuild import Tester, List\nt = Tester()\nt.set_tree(\"test1\")\nt.run_build_system(\"-sTOOLSET=yfc\")\nt.expect_addition(\"bin/a.obj/yfc/debug/runtime-link-dynamic/a.obj\")\nt.expect_addition(\"auxillary/bin/b.obj/yfc/debug/runtime-link-dynamic/optimization-space/b.obj\")\nt.expect_addition(\"bin/a/yfc/debug/runtime-link-dynamic/a\")\nt.expect_nothing_more()\nt.fail(t.read(\"bin/a.obj/yfc/debug/runtime-link-dynamic/a.obj\") != \"\"\"<optimization>off <rtti>on <runtime-link>dynamic <toolset>yfc <variant>debug\"\"\")\nt.fail(t.read(\"auxillary/bin/b.obj/yfc/debug/runtime-link-dynamic/b.obj\") != \"\"\"<optimization>space <rtti>on <runtime-link>dynamic <toolset>yfc <variant>debug\"\"\")\nt.fail(t.read(\"bin/a/yfc/debug/runtime-link-dynamic/a\") != \"\"\"<optimization>off <rtti>on <runtime-link>dynamic <toolset>yfc <variant>debug\"\"\")\nt.touch(\"auxillary/b.cpp\")\nt.run_build_system(\"-sTOOLSET b.obj\", subdir = \"auxillary\")\nt.expect_touch(\"auxillary/bin/b.obj/yfc/debug/runtime-link-dynamic/optimization-space/b.obj\")\nt.expect_no_modification(\"bin/a.obj/yfc/debug/runtime-link-dynamic/a.obj\")\nt.expect_no_modification(\"bin/a/yfc/debug/runtime-link-dynamic/a\")\nt.write('Jamfile', t.read('Jamfile2'))\nstdout = \"\"\"Error: subvariant of target ./a with properties\"\"\"\nt.run_build_system(\"-sTOOLSET=yfc\", stdout = stdout)\nt.write('Jamfile3', t.read('Jamfile3'))\nt.write('auxillary/Jamfile3', t.read('auxillary/Jamfile3'))\nstdout = \"\"\"Warning: cannot exactly satisfy request for auxillary/b.obj with properties\"\"\"\nt.run_build_system(\"-sTOOLSET=yfc\", stdout = stdout)\nt.write('Jamfile4', t.read('Jamfile4'))\nt.write('auxillary/Jamfile4', t.read('auxillary/Jamfile4'))\nstdout = \"\"\"Warning: cannot satisfy request for auxillary/b.obj with properties\"\"\")\nt.pass_test()\n", "code_toks_joined": "from BoostBuild import Tester , List <NEWLINE> t = Tester ( ) <NEWLINE> t . set_tree ( <STRING> ) <NEWLINE> t . run_build_system ( <STRING> ) <NEWLINE> t . expect_addition ( <STRING> ) <NEWLINE> t . expect_addition ( <STRING> ) <NEWLINE> t . expect_addition ( <STRING> ) <NEWLINE> t . expect_nothing_more ( ) <NEWLINE> t . fail ( t . read ( <STRING> ) != <STRING> ) <NEWLINE> t . fail ( t . read ( <STRING> ) != <STRING> ) <NEWLINE> t . fail ( t . read ( <STRING> ) != <STRING> ) <NEWLINE> t . touch ( <STRING> ) <NEWLINE> t . run_build_system ( <STRING> , subdir = <STRING> ) <NEWLINE> t . expect_touch ( <STRING> ) <NEWLINE> t . expect_no_modification ( <STRING> ) <NEWLINE> t . expect_no_modification ( <STRING> ) <NEWLINE> t . write ( <STRING> , t . read ( <STRING> ) ) <NEWLINE> stdout = <STRING> <NEWLINE> t . run_build_system ( <STRING> , stdout = stdout ) <NEWLINE> t . write ( <STRING> , t . read ( <STRING> ) ) <NEWLINE> t . write ( <STRING> , t . read ( <STRING> ) ) <NEWLINE> stdout = <STRING> <NEWLINE> t . run_build_system ( <STRING> , stdout = stdout ) <NEWLINE> t . write ( <STRING> , t . read ( <STRING> ) ) <NEWLINE> t . write ( <STRING> , t . read ( <STRING> ) ) <NEWLINE> stdout = <STRING> ) <NEWLINE> t . pass_test ( ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"test1\"", "\"-sTOOLSET=yfc\"", "\"bin/a.obj/yfc/debug/runtime-link-dynamic/a.obj\"", "\"auxillary/bin/b.obj/yfc/debug/runtime-link-dynamic/optimization-space/b.obj\"", "\"bin/a/yfc/debug/runtime-link-dynamic/a\"", "\"bin/a.obj/yfc/debug/runtime-link-dynamic/a.obj\"", "\"\"\"<optimization>off <rtti>on <runtime-link>dynamic <toolset>yfc <variant>debug\"\"\"", "\"auxillary/bin/b.obj/yfc/debug/runtime-link-dynamic/b.obj\"", "\"\"\"<optimization>space <rtti>on <runtime-link>dynamic <toolset>yfc <variant>debug\"\"\"", "\"bin/a/yfc/debug/runtime-link-dynamic/a\"", "\"\"\"<optimization>off <rtti>on <runtime-link>dynamic <toolset>yfc <variant>debug\"\"\"", "\"auxillary/b.cpp\"", "\"-sTOOLSET b.obj\"", "\"auxillary\"", "\"auxillary/bin/b.obj/yfc/debug/runtime-link-dynamic/optimization-space/b.obj\"", "\"bin/a.obj/yfc/debug/runtime-link-dynamic/a.obj\"", "\"bin/a/yfc/debug/runtime-link-dynamic/a\"", "'Jamfile'", "'Jamfile2'", "\"\"\"Error: subvariant of target ./a with properties\"\"\"", "\"-sTOOLSET=yfc\"", "'Jamfile3'", "'Jamfile3'", "'auxillary/Jamfile3'", "'auxillary/Jamfile3'", "\"\"\"Warning: cannot exactly satisfy request for auxillary/b.obj with properties\"\"\"", "\"-sTOOLSET=yfc\"", "'Jamfile4'", "'Jamfile4'", "'auxillary/Jamfile4'", "'auxillary/Jamfile4'", "\"\"\"Warning: cannot satisfy request for auxillary/b.obj with properties\"\"\""]}, "window_span": [235, 240], "err_obj": {"msg": "unbalanced (){}[]"}}], ["ae6b764dd585c0f6ed257d4040752ac8", {"code_string": "def read(self, size = 1, timeout = None):\n    timeout_errmsg = \"timeout on socket(%s, %d)\" %(self._host, self._port)\n    with gevent.Timeout(timeout or self._timeout,\n        SocketTimeout(timeout_errmsg)):\n        while len(self._data) < size:\n        self._event.wait()\n        self._event.clear()\n    msg = self._data[: size]\n    self._data = self._data[size: ]\n    return msg\n", "code_toks_joined": "def read ( self , size = 1 , timeout = None ) : <NEWLINE> <INDENT> timeout_errmsg = <STRING> % ( self . _host , self . _port ) <NEWLINE> with gevent . Timeout ( timeout or self . _timeout , <NEWLINE> <INDENT> SocketTimeout ( timeout_errmsg ) ) : <NEWLINE> while len ( self . _data ) < size : <NEWLINE> self . _event . wait ( ) <NEWLINE> self . _event . clear ( ) <NEWLINE> <DEDENT> msg = self . _data [ : size ] <NEWLINE> self . _data = self . _data [ size : ] <NEWLINE> return msg <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"timeout on socket(%s, %d)\""]}, "err_obj": {"msg": "expected an indented block"}}], ["ba282edf4eb5e1ce47cb8c86054cff79", {"code_string": "def reservecommit(client, nsi_header, connection_id):\n    try:\n        yield client.reserveCommit(nsi_header, connection_id)\n        log.msg(\"Reservation committed at %s\" % nsi_header.provider_nsa)\n    except error.NSIError, e:\n        _logError(e)\n", "code_toks_joined": "def reservecommit ( client , nsi_header , connection_id ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> yield client . reserveCommit ( nsi_header , connection_id ) <NEWLINE> log . msg ( <STRING> % nsi_header . provider_nsa ) <NEWLINE> <DEDENT> except error . NSIError , e : <NEWLINE> <INDENT> _logError ( e ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Reservation committed at %s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["8897ad1c96a7ab1223a7523bc69ba0a9", {"code_string": "def flip_images(images):\n    new = []\n    for i in images:\n        new.append(pygame.transform.flip(i, 1, 0)\n    return new\n", "code_toks_joined": "def flip_images ( images ) : <NEWLINE> <INDENT> new = [ ] <NEWLINE> for i in images : <NEWLINE> <INDENT> new . append ( pygame . transform . flip ( i , 1 , 0 ) <NEWLINE> <DEDENT> return new <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["a1a0b0d336863bced491ad7d06879355", {"code_string": "def get_service_function_chains_data():\n    return{\n    \"service-function-chains\": {\n        \"service-function-chain\": [\n            {\n                \"name\": \"SFCGBP\",\n                \"symmetric\": \"true\",\n                \"sfc-service-function\": [\n                    {\n                        \"name\": \"firewall-abstract1\",\n                        \"type\": \"service-function-type:firewall\"\n                    },\n                    {\n                        \"name\": \"dpi-abstract1\",\n                        \"type\": \"service-function-type:dpi\"\n                    }\n                ]\n            }\n        ]\n    }\n", "code_toks_joined": "def get_service_function_chains_data ( ) : <NEWLINE> <INDENT> return { <NEWLINE> <STRING> : { <NEWLINE> <INDENT> <STRING> : [ <NEWLINE> <INDENT> { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : [ <NEWLINE> <INDENT> { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> <DEDENT> } , <NEWLINE> { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"service-function-chains\"", "\"service-function-chain\"", "\"name\"", "\"SFCGBP\"", "\"symmetric\"", "\"true\"", "\"sfc-service-function\"", "\"name\"", "\"firewall-abstract1\"", "\"type\"", "\"service-function-type:firewall\"", "\"name\"", "\"dpi-abstract1\"", "\"type\"", "\"service-function-type:dpi\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["5aa9d7878224019eb5b11c47f09956f8", {"code_string": "def verify_add():\n    \"\"\" Verify email address. Send the email as param.\"\"\"\n    email = request.params.get('email', None)\n    if not email:\n        return error_msg('Missing field email')\n    try:\n        v = ses.verifyEmailAddress(email)\n    except AmazonError, e:\n        return error_msg(e.__unicode__())\n    resp = {'status': 'ok', 'message': v.requestId, }\n    return json_encode(resp)\n", "code_toks_joined": "def verify_add ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> email = request . params . get ( <STRING> , None ) <NEWLINE> if not email : <NEWLINE> <INDENT> return error_msg ( <STRING> ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> v = ses . verifyEmailAddress ( email ) <NEWLINE> <DEDENT> except AmazonError , e : <NEWLINE> <INDENT> return error_msg ( e . __unicode__ ( ) ) <NEWLINE> <DEDENT> resp = { <STRING> : <STRING> , <STRING> : v . requestId , } <NEWLINE> return json_encode ( resp ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Verify email address. Send the email as param.\"\"\"", "'email'", "'Missing field email'", "'status'", "'ok'", "'message'"]}, "err_obj": {"msg": "invalid syntax"}}], ["04d8471c02d56c69d5b07b24815f0b2a", {"code_string": "import sys\nn = sys.argv[1]\nn = int(n)\nsecond time lucky\nresult = n / 2 *(n + 1)\nprint(\"XXSum\", result)\nresult = 0\nfor i in xrange(n + 1):\n    result = i + result\nprint(\"XSum:\", result)\nresult = 0\nfor i in range(n + 1):\n    result = i + result\nprint(\"Sum:\", result)\n", "code_toks_joined": "import sys <NEWLINE> n = sys . argv [ 1 ] <NEWLINE> n = int ( n ) <NEWLINE> second time lucky <NEWLINE> result = n / 2 * ( n + 1 ) <NEWLINE> print ( <STRING> , result ) <NEWLINE> result = 0 <NEWLINE> for i in xrange ( n + 1 ) : <NEWLINE> <INDENT> result = i + result <NEWLINE> <DEDENT> print ( <STRING> , result ) <NEWLINE> result = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> result = i + result <NEWLINE> <DEDENT> print ( <STRING> , result ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"XXSum\"", "\"XSum:\"", "\"Sum:\""]}, "err_obj": {"msg": "invalid syntax"}}], ["8dd6459e9765a47bfb27c2333b17793d", {"code_string": "def run_query(query = ''):\n    datos = [DB_HOST, DB_USER, DB_PASS, DB_NAME]\n    conn = MySQLdb.connect(* datos)\n    cursor = conn.cursor()\n    cursor.execute(query)\n    if query.upper().startswith('SELECT'):\n    data = cursor.fetchall()\n    else:\n    conn.commit()\n    data = None\n    cursor.close()\n    conn.close()\n    return data\n", "code_toks_joined": "def run_query ( query = <STRING> ) : <NEWLINE> <INDENT> datos = [ DB_HOST , DB_USER , DB_PASS , DB_NAME ] <NEWLINE> conn = MySQLdb . connect ( * datos ) <NEWLINE> cursor = conn . cursor ( ) <NEWLINE> cursor . execute ( query ) <NEWLINE> if query . upper ( ) . startswith ( <STRING> ) : <NEWLINE> data = cursor . fetchall ( ) <NEWLINE> else : <NEWLINE> conn . commit ( ) <NEWLINE> data = None <NEWLINE> cursor . close ( ) <NEWLINE> conn . close ( ) <NEWLINE> return data <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "'SELECT'"]}, "err_obj": {"msg": "expected an indented block"}}], ["d42d61e65c28d16b54da5b6b684589f5", {"code_string": "def f(self, y, t):\n    \"\"\"Right-hand side of 1st-order ODE system.\"\"\"\n    A, w, b, c, m = [p[k] for k in 'A', 'w', 'b', 'c', 'm']\n    f = self._fy[self.p['func']]\n    return[y[1], (A * cos(w * t) - b * y[1] - c * f(y[0])) / m]\n", "code_toks_joined": "def f ( self , y , t ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> A , w , b , c , m = [ p [ k ] for k in <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> f = self . _fy [ self . p [ <STRING> ] ] <NEWLINE> return [ y [ 1 ] , ( A * cos ( w * t ) - b * y [ 1 ] - c * f ( y [ 0 ] ) ) / m ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Right-hand side of 1st-order ODE system.\"\"\"", "'A'", "'w'", "'b'", "'c'", "'m'", "'func'"]}, "err_obj": {"msg": "invalid syntax"}}], ["f55c6d6caecaab08f11052a2b6a6b667", {"code_string": "def load_metrics(filename)\n    metric_list = []\n    f = open(filename, \"r\")\n    for l in f:\n        items = l.split()\n        print(items)\n        metric_list.append(items)\n    f.close()\n    return metric_list\n", "code_toks_joined": "def load_metrics ( filename ) <NEWLINE> <INDENT> metric_list = [ ] <NEWLINE> f = open ( filename , <STRING> ) <NEWLINE> for l in f : <NEWLINE> <INDENT> items = l . split ( ) <NEWLINE> print ( items ) <NEWLINE> metric_list . append ( items ) <NEWLINE> <DEDENT> f . close ( ) <NEWLINE> return metric_list <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"r\""]}, "err_obj": {"msg": "invalid syntax"}}], ["a1c77ea94dc1b108d7ddb9d871be8df0", {"code_string": "class PostgresqlImpl(DefaultImpl):\n    __dialect__ = 'postgresql'\n    transactional_ddl = True\n    def compare_server_default(self, inspector_column,\n        metadata_column,\n        rendered_metadata_default):\n        if metadata_column.primary_key and metadata_column is metadata_column.table._autoincrement_column:\n        return False\n        conn_col_default = inspector_column['default']\n        if metadata_column.type._type_affinity is not sqltypes.String:\n        rendered_metadata_default = re.sub(r\"^'|'$\", \"\", rendered_metadata_default)\n        return not self.connection.scalar(\n        \"SELECT %s = %s\" %(\n        conn_col_default,\n        rendered_metadata_default\n        )\n        )\n", "code_toks_joined": "class PostgresqlImpl ( DefaultImpl ) : <NEWLINE> <INDENT> __dialect__ = <STRING> <NEWLINE> transactional_ddl = True <NEWLINE> def compare_server_default ( self , inspector_column , <NEWLINE> <INDENT> metadata_column , <NEWLINE> rendered_metadata_default ) : <NEWLINE> if metadata_column . primary_key and metadata_column is metadata_column . table . _autoincrement_column : <NEWLINE> return False <NEWLINE> conn_col_default = inspector_column [ <STRING> ] <NEWLINE> if metadata_column . type . _type_affinity is not sqltypes . String : <NEWLINE> rendered_metadata_default = re . sub ( <STRING> , <STRING> , rendered_metadata_default ) <NEWLINE> return not self . connection . scalar ( <NEWLINE> <STRING> % ( <NEWLINE> conn_col_default , <NEWLINE> rendered_metadata_default <NEWLINE> ) <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'postgresql'", "'default'", "r\"^'|'$\"", "\"\"", "\"SELECT %s = %s\""]}, "err_obj": {"msg": "expected an indented block"}}], ["10adfd7e84d730855d492d0fa80bbbc4", {"code_string": "def test_positive_create_with_password(self):\n    \"\"\"Create User for all variations of Password\"\"\"\n    for password in generate_strings_list(\n        exclude_types = ['html'], max_length = 50):\n        with self.subTest(password):\n        user = entities.User(password = password).create()\n        self.assertIsNotNone(user)\n", "code_toks_joined": "def test_positive_create_with_password ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for password in generate_strings_list ( <NEWLINE> <INDENT> exclude_types = [ <STRING> ] , max_length = 50 ) : <NEWLINE> with self . subTest ( password ) : <NEWLINE> user = entities . User ( password = password ) . create ( ) <NEWLINE> self . assertIsNotNone ( user ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Create User for all variations of Password\"\"\"", "'html'"]}, "err_obj": {"msg": "expected an indented block"}}], ["9e16e324c90185314d58664e8489f1f9", {"code_string": "def run(args):\n    if(len(args) == 0):\n        folders = [\".\"]\n    else:\n        folders = args\n    from libtbx.path import walk_source_tree\n    mod_count_total = 0\n    mod_file_count = 0\n    for folder in folders:\n        for path in walk_source_tree(folder):\n            if(not path.endswith(\".py\")): continue\n            txt = open(path).read()\n            mod_lines = []\n            mod_count = 0\n            for line in txt.splitlines():\n                ls = line.strip()\n                if(ls.startswith(\"except\")\n                    and ls[6: ].strip().startswith(\":\")\n                    and not ls.endswith(\" # intentional\")):\n                    line = line.replace(\"except\", \"except Exception\", 1)\n                    mod_count += 1\n                mod_lines.append(line)\n            if(mod_count != 0):\n                print(\"w\"), \"\\n\".join(mod_lines))\n                mod_count_total += mod_count\n                mod_file_count += 1\n    print(\"Number of modifications: %d in %d files\" %(\n        mod_count_total, mod_file_count))\n", "code_toks_joined": "def run ( args ) : <NEWLINE> <INDENT> if ( len ( args ) == 0 ) : <NEWLINE> <INDENT> folders = [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> folders = args <NEWLINE> <DEDENT> from libtbx . path import walk_source_tree <NEWLINE> mod_count_total = 0 <NEWLINE> mod_file_count = 0 <NEWLINE> for folder in folders : <NEWLINE> <INDENT> for path in walk_source_tree ( folder ) : <NEWLINE> <INDENT> if ( not path . endswith ( <STRING> ) ) : continue <NEWLINE> txt = open ( path ) . read ( ) <NEWLINE> mod_lines = [ ] <NEWLINE> mod_count = 0 <NEWLINE> for line in txt . splitlines ( ) : <NEWLINE> <INDENT> ls = line . strip ( ) <NEWLINE> if ( ls . startswith ( <STRING> ) <NEWLINE> <INDENT> and ls [ 6 : ] . strip ( ) . startswith ( <STRING> ) <NEWLINE> and not ls . endswith ( <STRING> ) ) : <NEWLINE> line = line . replace ( <STRING> , <STRING> , 1 ) <NEWLINE> mod_count += 1 <NEWLINE> <DEDENT> mod_lines . append ( line ) <NEWLINE> <DEDENT> if ( mod_count != 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) , <STRING> . join ( mod_lines ) ) <NEWLINE> mod_count_total += mod_count <NEWLINE> mod_file_count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> % ( <NEWLINE> <INDENT> mod_count_total , mod_file_count ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\".\"", "\".py\"", "\"except\"", "\":\"", "\" # intentional\"", "\"except\"", "\"except Exception\"", "\"w\"", "\"\\n\"", "\"Number of modifications: %d in %d files\""]}, "window_span": [191, 205], "err_obj": {"msg": "unbalanced (){}[]"}}], ["af8de75f5d7061c5020969f4520f07b5", {"code_string": "def _getDbfile(self, session_id):\n    session_dir = self._getSessionDir(session_id);\n    db_file = None\n    try:\n    for fname in os.listdir(session_dir):\n        if fname.endswith(DBFILE_SFX):\n            return os.path.join(session_dir, fname)\n    except:\n        raise cherrypy.HTTPError(400, \"Requested JobID: %s was not found.\" % session_id)\n    raise cherrypy.HTTPError(500, \"No dbfile found for jobID: %s.\" % session_id)\n", "code_toks_joined": "def _getDbfile ( self , session_id ) : <NEWLINE> <INDENT> session_dir = self . _getSessionDir ( session_id ) ; <NEWLINE> db_file = None <NEWLINE> try : <NEWLINE> for fname in os . listdir ( session_dir ) : <NEWLINE> <INDENT> if fname . endswith ( DBFILE_SFX ) : <NEWLINE> <INDENT> return os . path . join ( session_dir , fname ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> raise cherrypy . HTTPError ( 400 , <STRING> % session_id ) <NEWLINE> <DEDENT> raise cherrypy . HTTPError ( 500 , <STRING> % session_id ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Requested JobID: %s was not found.\"", "\"No dbfile found for jobID: %s.\""]}, "err_obj": {"msg": "expected an indented block"}}], ["88e74d7a1c4565323863829c4e9b599a", {"code_string": "def chunk_IHDR(self, offset, bytes):\n    \"IHDR -- full image follows\"\n    if self.count == 0:\n        raise SyntaxError, \"misplaced IHDR chunk\"\n    s = self.fp.read(bytes)\n    size, mode, rawmode = self.__getmodesize(s)\n    self.action = (\"IHDR\", )\n    self.im = Image.core.new(mode, size)\n    self.decoder = Image.core.zip_decoder(rawmode)\n    self.decoder.setimage(self.im, (0, 0) + size)\n    self.data = \"\"\n    return s\n", "code_toks_joined": "def chunk_IHDR ( self , offset , bytes ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . count == 0 : <NEWLINE> <INDENT> raise SyntaxError , <STRING> <NEWLINE> <DEDENT> s = self . fp . read ( bytes ) <NEWLINE> size , mode , rawmode = self . __getmodesize ( s ) <NEWLINE> self . action = ( <STRING> , ) <NEWLINE> self . im = Image . core . new ( mode , size ) <NEWLINE> self . decoder = Image . core . zip_decoder ( rawmode ) <NEWLINE> self . decoder . setimage ( self . im , ( 0 , 0 ) + size ) <NEWLINE> self . data = <STRING> <NEWLINE> return s <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"IHDR -- full image follows\"", "\"misplaced IHDR chunk\"", "\"IHDR\"", "\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["6ee3ac23f4992530d325bb57a95564dd", {"code_string": "def call_command(self, command, args):\n    try:\n        with hou.undos.disabler():\n            call = getattr(self, command)\n            call(args)\n    except Exception, e:\n        error = (command, args, e)\n        self.log.error('Error invoking command: %s %s %s' % error)\n        raise e\n", "code_toks_joined": "def call_command ( self , command , args ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> with hou . undos . disabler ( ) : <NEWLINE> <INDENT> call = getattr ( self , command ) <NEWLINE> call ( args ) <NEWLINE> <DEDENT> <DEDENT> except Exception , e : <NEWLINE> <INDENT> error = ( command , args , e ) <NEWLINE> self . log . error ( <STRING> % error ) <NEWLINE> raise e <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Error invoking command: %s %s %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["d0577625cf2105a8a705ff371e420720", {"code_string": "def _detach_all_attachments(self, ctxt, volume):\n    attachments = volume['volume_attachment'] or[]\n    for attachment in attachments:\n        if(attachment['attached_host'] == self.host and\n            attachment['instance_uuid'] is None):\n            try:\n            rpcapi = self.volume_rpcapi\n            rpcapi.detach_volume(ctxt, volume, attachment['id'])\n            except Exception:\n            LOG.exception(_LE(\"Detach attachment %(attach_id)s\"\n                \" failed.\"),\n                {'attach_id': attachment['id']},\n                resource = volume)\n", "code_toks_joined": "def _detach_all_attachments ( self , ctxt , volume ) : <NEWLINE> <INDENT> attachments = volume [ <STRING> ] or [ ] <NEWLINE> for attachment in attachments : <NEWLINE> <INDENT> if ( attachment [ <STRING> ] == self . host and <NEWLINE> <INDENT> attachment [ <STRING> ] is None ) : <NEWLINE> try : <NEWLINE> rpcapi = self . volume_rpcapi <NEWLINE> rpcapi . detach_volume ( ctxt , volume , attachment [ <STRING> ] ) <NEWLINE> except Exception : <NEWLINE> LOG . exception ( _LE ( <STRING> <NEWLINE> <INDENT> <STRING> ) , <NEWLINE> { <STRING> : attachment [ <STRING> ] } , <NEWLINE> resource = volume ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'volume_attachment'", "'attached_host'", "'instance_uuid'", "'id'", "\"Detach attachment %(attach_id)s\"", "\" failed.\"", "'attach_id'", "'id'"]}, "err_obj": {"msg": "expected an indented block"}}], ["b9cebf41c9cd4ab818ed06b0930f12d2", {"code_string": "def check_preconditions(cls):\n    super(TestNetworkBasicOps, cls).check_preconditions()\n    if not(CONF.network.tenant_networks_reachable\n        or CONF.network.public_network_id):\n        msg = ('Either tenant_networks_reachable must be \"true\", or '\n            'public_network_id must be defined.')\n            raise cls.skipException(msg)\n", "code_toks_joined": "def check_preconditions ( cls ) : <NEWLINE> <INDENT> super ( TestNetworkBasicOps , cls ) . check_preconditions ( ) <NEWLINE> if not ( CONF . network . tenant_networks_reachable <NEWLINE> <INDENT> or CONF . network . public_network_id ) : <NEWLINE> msg = ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> raise cls . skipException ( msg ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Either tenant_networks_reachable must be \"true\", or '", "'public_network_id must be defined.'"]}, "err_obj": {"msg": "unexpected indent"}}], ["9e4a2ed194f84b4dbae94d20eaf99024", {"code_string": "def pathsplit(p, rest = []):\n    (h t) = os.path.split(p)\n    if len(h) < 1: return[t] + rest\n    if len(t) < 1: return[h] + rest\n    return pathsplit(h, [t] + rest)\n", "code_toks_joined": "def pathsplit ( p , rest = [ ] ) : <NEWLINE> <INDENT> ( h t ) = os . path . split ( p ) <NEWLINE> if len ( h ) < 1 : return [ t ] + rest <NEWLINE> if len ( t ) < 1 : return [ h ] + rest <NEWLINE> return pathsplit ( h , [ t ] + rest ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["08abc812fb43f69b97cda6f736e5bed7", {"code_string": "class TimeStamp(DateTime):\n    def __init__(self, name = None, values = None, data_type = 'python', * args,\n        ** kwargs):\n        def default():\n        return datetime.now()\n        kwargs['default'] = default\n        super().__init__(name = name, values = values, data_type = data_type,\n            max_values = 1, overwrite_last_value = False, * args,\n            ** kwargs)\n    def can_set(self, value):\n        return False\n", "code_toks_joined": "class TimeStamp ( DateTime ) : <NEWLINE> <INDENT> def __init__ ( self , name = None , values = None , data_type = <STRING> , * args , <NEWLINE> <INDENT> ** kwargs ) : <NEWLINE> def default ( ) : <NEWLINE> return datetime . now ( ) <NEWLINE> kwargs [ <STRING> ] = default <NEWLINE> super ( ) . __init__ ( name = name , values = values , data_type = data_type , <NEWLINE> <INDENT> max_values = 1 , overwrite_last_value = False , * args , <NEWLINE> ** kwargs ) <NEWLINE> <DEDENT> <DEDENT> def can_set ( self , value ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'python'", "'default'"]}, "err_obj": {"msg": "expected an indented block"}}], ["b5053cc376785185d7f8754472a8689f", {"code_string": "def poly(order):\n    def f():\n        pass\n    fstr = 'def f(x'\n    statement = ', a1, a0): return '\n    for i in range(order, 1, - 1):\n        fstr += ', a' + str(i)\n        statement += 'x**' + str(i) + ' * a' + str(i) + ' + '\n    fstr += statement + 'x * a1 + a0'\n    exec fstr\n    return f\n", "code_toks_joined": "def poly ( order ) : <NEWLINE> <INDENT> def f ( ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> fstr = <STRING> <NEWLINE> statement = <STRING> <NEWLINE> for i in range ( order , 1 , - 1 ) : <NEWLINE> <INDENT> fstr += <STRING> + str ( i ) <NEWLINE> statement += <STRING> + str ( i ) + <STRING> + str ( i ) + <STRING> <NEWLINE> <DEDENT> fstr += statement + <STRING> <NEWLINE> exec fstr <NEWLINE> return f <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'def f(x'", "', a1, a0): return '", "', a'", "'x**'", "' * a'", "' + '", "'x * a1 + a0'"]}, "err_obj": {"msg": "invalid syntax"}}], ["97054b09222afa3142c95a0960d19a09", {"code_string": "def test_add_ovs_flow_with_dest_mac(self):\n    with mock.patch.object(self.ovs_firewall.sg_br, 'deferred',\n        return_value = self.mock_br), mock.patch.object(self.mock_br, 'add_flow') as mock_add_flow:\n        dest_mac = \"01:00:00:00:00:00\"\n        self.ovs_firewall._add_ovs_flow(self.mock_br, 0, 1, \"normal\",\n            dl_dest = dest_mac)\n            mock_add_flow.assert_called_with(table = 1, priority = 0,\n                dl_dst = dest_mac,\n                actions = \"normal\")\n", "code_toks_joined": "def test_add_ovs_flow_with_dest_mac ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( self . ovs_firewall . sg_br , <STRING> , <NEWLINE> <INDENT> return_value = self . mock_br ) , mock . patch . object ( self . mock_br , <STRING> ) as mock_add_flow : <NEWLINE> dest_mac = <STRING> <NEWLINE> self . ovs_firewall . _add_ovs_flow ( self . mock_br , 0 , 1 , <STRING> , <NEWLINE> <INDENT> dl_dest = dest_mac ) <NEWLINE> mock_add_flow . assert_called_with ( table = 1 , priority = 0 , <NEWLINE> <INDENT> dl_dst = dest_mac , <NEWLINE> actions = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'deferred'", "'add_flow'", "\"01:00:00:00:00:00\"", "\"normal\"", "\"normal\""]}, "err_obj": {"msg": "unexpected indent"}}], ["79a99c75a2b7165e9eafa88d050523ca", {"code_string": "class Configuration(ConfigurationMixIn):\n    \"\"\"class for simple configurations which don't need the\"\"\"\n    def __init__(self, config_file = None, options = None, name = None,\n        usage = None, doc = None, version = None):\n        if options is not None:\n        self.options = options\n        if name is not None:\n        self.name = name\n        if doc is not None:\n        self.__doc__ = doc\n        super(Configuration, self).__init__(config_file = config_file, usage = usage, version = version)\n", "code_toks_joined": "class Configuration ( ConfigurationMixIn ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , config_file = None , options = None , name = None , <NEWLINE> <INDENT> usage = None , doc = None , version = None ) : <NEWLINE> if options is not None : <NEWLINE> self . options = options <NEWLINE> if name is not None : <NEWLINE> self . name = name <NEWLINE> if doc is not None : <NEWLINE> self . __doc__ = doc <NEWLINE> super ( Configuration , self ) . __init__ ( config_file = config_file , usage = usage , version = version ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"class for simple configurations which don't need the\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["9fd14bea1c7db4bc08582bbbcd50204c", {"code_string": "def got_zone_id(response):\n    ''''response' is a txcloudflare.response.Response() instance.'''\n    print('< got first response(zone id lookup)')\n    zone_id = response.data.get(domain_name, '')\n    print('< zone{0}has zone id{1}'.format(domain_name, zone_id)))\n    print('> requesting snapshot update for zone: ', zone_id)\n    def updated_snapshot(response):\n        print('< got second response(updated snapshot)')\n        print(response.data)\n        reactor.stop()\n    cloudflare.zone_grab(zone_id = zone_id).addCallback(updated_snapshot).addErrback(got_error)\n", "code_toks_joined": "def got_zone_id ( response ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> ) <NEWLINE> zone_id = response . data . get ( domain_name , <STRING> ) <NEWLINE> print ( <STRING> . format ( domain_name , zone_id ) ) ) <NEWLINE> print ( <STRING> , zone_id ) <NEWLINE> def updated_snapshot ( response ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( response . data ) <NEWLINE> reactor . stop ( ) <NEWLINE> <DEDENT> cloudflare . zone_grab ( zone_id = zone_id ) . addCallback ( updated_snapshot ) . addErrback ( got_error ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''''response' is a txcloudflare.response.Response() instance.'''", "'< got first response(zone id lookup)'", "''", "'< zone{0}has zone id{1}'", "'> requesting snapshot update for zone: '", "'< got second response(updated snapshot)'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["028d6f36ad618b821f973772cc8f6ef8", {"code_string": "def setupUi(self, Interpretation):\n    Interpretation.setObjectName(\"Interpretation\")\n    Interpretation.resize(631, 561)\n    self.horizontalLayout = QtWidgets.QHBoxLayout(Interpretation)\n    self.horizontalLayout.setContentsMargins(0, 0, 0, 0)\n    self.horizontalLayout.setSpacing(0)\n    self.horizontalLayout.setObjectName(\"horizontalLayout\")\n    self.scrollArea = ScrollArea(Interpretation)\n    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Expanding)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(self.scrollArea.sizePolicy().hasHeightForWidth())\n    self.scrollArea.setSizePolicy(sizePolicy)\n    self.scrollArea.setAcceptDrops(True)\n    self.scrollArea.setStyleSheet(\"\")\n    self.scrollArea.setFrameShape(QtWidgets.QFrame.NoFrame)\n    self.scrollArea.setLineWidth(0)\n    self.scrollArea.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)\n    self.scrollArea.setWidgetResizable(True)\n    self.scrollArea.setObjectName(\"scrollArea\")\n    self.scrlAreaSignals = QtWidgets.QWidget()\n    self.scrlAreaSignals.setGeometry(QtCore.QRect(0, 0, 631, 561))\n    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Expanding)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(self.scrlAreaSignals.sizePolicy().hasHeightForWidth())\n    self.scrlAreaSignals.setSizePolicy(sizePolicy)\n    self.scrlAreaSignals.setAutoFillBackground(True)\n    self.scrlAreaSignals.setStyleSheet(\"\")\n    self.scrlAreaSignals.setObjectName(\"scrlAreaSignals\")\n    self.verticalLayout = QtWidgets.QVBoxLayout(self.scrlAreaSignals)\n    self.verticalLayout.setContentsMargins(0, 0, 0, 0)\n    self.verticalLayout.setObjectName(\"verticalLayout\")\n    self.splitter = QtWidgets.QSplitter(self.scrlAreaSignals)\n    self.splitter.setStyleSheet(\"QSplitter::handle:vertical {\\n\"\n", "code_toks_joined": "def setupUi ( self , Interpretation ) : <NEWLINE> <INDENT> Interpretation . setObjectName ( <STRING> ) <NEWLINE> Interpretation . resize ( 631 , 561 ) <NEWLINE> self . horizontalLayout = QtWidgets . QHBoxLayout ( Interpretation ) <NEWLINE> self . horizontalLayout . setContentsMargins ( 0 , 0 , 0 , 0 ) <NEWLINE> self . horizontalLayout . setSpacing ( 0 ) <NEWLINE> self . horizontalLayout . setObjectName ( <STRING> ) <NEWLINE> self . scrollArea = ScrollArea ( Interpretation ) <NEWLINE> sizePolicy = QtWidgets . QSizePolicy ( QtWidgets . QSizePolicy . Preferred , QtWidgets . QSizePolicy . Expanding ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( self . scrollArea . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> self . scrollArea . setSizePolicy ( sizePolicy ) <NEWLINE> self . scrollArea . setAcceptDrops ( True ) <NEWLINE> self . scrollArea . setStyleSheet ( <STRING> ) <NEWLINE> self . scrollArea . setFrameShape ( QtWidgets . QFrame . NoFrame ) <NEWLINE> self . scrollArea . setLineWidth ( 0 ) <NEWLINE> self . scrollArea . setVerticalScrollBarPolicy ( QtCore . Qt . ScrollBarAsNeeded ) <NEWLINE> self . scrollArea . setWidgetResizable ( True ) <NEWLINE> self . scrollArea . setObjectName ( <STRING> ) <NEWLINE> self . scrlAreaSignals = QtWidgets . QWidget ( ) <NEWLINE> self . scrlAreaSignals . setGeometry ( QtCore . QRect ( 0 , 0 , 631 , 561 ) ) <NEWLINE> sizePolicy = QtWidgets . QSizePolicy ( QtWidgets . QSizePolicy . Preferred , QtWidgets . QSizePolicy . Expanding ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( self . scrlAreaSignals . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> self . scrlAreaSignals . setSizePolicy ( sizePolicy ) <NEWLINE> self . scrlAreaSignals . setAutoFillBackground ( True ) <NEWLINE> self . scrlAreaSignals . setStyleSheet ( <STRING> ) <NEWLINE> self . scrlAreaSignals . setObjectName ( <STRING> ) <NEWLINE> self . verticalLayout = QtWidgets . QVBoxLayout ( self . scrlAreaSignals ) <NEWLINE> self . verticalLayout . setContentsMargins ( 0 , 0 , 0 , 0 ) <NEWLINE> self . verticalLayout . setObjectName ( <STRING> ) <NEWLINE> self . splitter = QtWidgets . QSplitter ( self . scrlAreaSignals ) <NEWLINE> self . splitter . setStyleSheet ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Interpretation\"", "\"horizontalLayout\"", "\"\"", "\"scrollArea\"", "\"\"", "\"scrlAreaSignals\"", "\"verticalLayout\"", "\"QSplitter::handle:vertical {\\n\""]}, "window_span": [380, 384], "err_obj": {"msg": "unbalanced (){}[]"}}], ["ff973f21f91ac36732ed3f6522695f5c", {"code_string": "def test_from_crawler_init_call(self):\n    with mock.patch.object(self.spider_class, '__init__',\n        return_value = None) as mock_init:\n        self.spider_class.from_crawler(get_crawler(), 'example.com',\n            foo = 'bar')\n            mock_init.assert_called_once_with('example.com', foo = 'bar')\n", "code_toks_joined": "def test_from_crawler_init_call ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( self . spider_class , <STRING> , <NEWLINE> <INDENT> return_value = None ) as mock_init : <NEWLINE> self . spider_class . from_crawler ( get_crawler ( ) , <STRING> , <NEWLINE> <INDENT> foo = <STRING> ) <NEWLINE> mock_init . assert_called_once_with ( <STRING> , foo = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'__init__'", "'example.com'", "'bar'", "'example.com'", "'bar'"]}, "err_obj": {"msg": "unexpected indent"}}], ["df413ea76c4507f8e9c11c80fc8d3e34", {"code_string": "def test_doesnt_challenges_on_401_with_WWW_Authenticate(self):\n    decider = self._getFUT()\n    self.failIf(decider({}, '401 Ok', [('WWW-Authenticate', 'xxx')])\n", "code_toks_joined": "def test_doesnt_challenges_on_401_with_WWW_Authenticate ( self ) : <NEWLINE> <INDENT> decider = self . _getFUT ( ) <NEWLINE> self . failIf ( decider ( { } , <STRING> , [ ( <STRING> , <STRING> ) ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'401 Ok'", "'WWW-Authenticate'", "'xxx'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["ecc329053f8caf7e099f4eaef5989eca", {"code_string": "def init_servo():\n    pigpio.set_PWM_frequency(PIN, 50)\n    pigpio.set_PWM_range(PIN, 20000)\n        print('Initializing...')\n        move_servo(CENTER)\n", "code_toks_joined": "def init_servo ( ) : <NEWLINE> <INDENT> pigpio . set_PWM_frequency ( PIN , 50 ) <NEWLINE> pigpio . set_PWM_range ( PIN , 20000 ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> move_servo ( CENTER ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Initializing...'"]}, "err_obj": {"msg": "unexpected indent"}}], ["6f2904efd75397a050f8e42990040fee", {"code_string": "\"\"\"Virtual Socket implementation, unifies all the Transports into one\"\"\"\nimport random\nimport weakref\nimport gevent\nfrom gevent.queue import Queue\nfrom gevent.event import Event\nfrom socketio import packet\ndef default_error_handler(socket, error_name, error_message, endpoint,\n    msg_id, quiet):\n    \"\"\"This is the default error handler, you can override this when\"\"\"\n    pkt = dict(type = 'event', name = 'error',\n    args = [error_name, error_message],\n    endpoint = endpoint)\n    if msg_id:\n    pkt['id'] = msg_id\n    if not quiet:\n    socket.send_packet(pkt)\n    print(\"default_error_handler: %s, %s (endpoint=%s, msg_id=%s)\" %(\n    error_name, error_message, endpoint, msg_id))\n", "code_toks_joined": "<STRING> <NEWLINE> import random <NEWLINE> import weakref <NEWLINE> import gevent <NEWLINE> from gevent . queue import Queue <NEWLINE> from gevent . event import Event <NEWLINE> from socketio import packet <NEWLINE> def default_error_handler ( socket , error_name , error_message , endpoint , <NEWLINE> <INDENT> msg_id , quiet ) : <NEWLINE> <STRING> <NEWLINE> pkt = dict ( type = <STRING> , name = <STRING> , <NEWLINE> args = [ error_name , error_message ] , <NEWLINE> endpoint = endpoint ) <NEWLINE> if msg_id : <NEWLINE> pkt [ <STRING> ] = msg_id <NEWLINE> if not quiet : <NEWLINE> socket . send_packet ( pkt ) <NEWLINE> print ( <STRING> % ( <NEWLINE> error_name , error_message , endpoint , msg_id ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Virtual Socket implementation, unifies all the Transports into one\"\"\"", "\"\"\"This is the default error handler, you can override this when\"\"\"", "'event'", "'error'", "'id'", "\"default_error_handler: %s, %s (endpoint=%s, msg_id=%s)\""]}, "err_obj": {"msg": "expected an indented block"}}], ["c6370188262e697e30b55257c019b802", {"code_string": "def putAnnouncement(self, request):\n    \"\"\"Put Announcement into memcache\"\"\"\n    return StringMessage(data = self._cacheAnnouncement()))\n", "code_toks_joined": "def putAnnouncement ( self , request ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return StringMessage ( data = self . _cacheAnnouncement ( ) ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Put Announcement into memcache\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["09ec7feb85bf80f201567271de5d3104", {"code_string": "def test_normalize_summary(self):\n    self.assertEqual(\n        'This is a sentence.',\n        docformatter.normalize_summary('This \\n\\t is\\na sentence')\n", "code_toks_joined": "def test_normalize_summary ( self ) : <NEWLINE> <INDENT> self . assertEqual ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> docformatter . normalize_summary ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'This is a sentence.'", "'This \\n\\t is\\na sentence'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["cf3ae0fe348241b1d6cafcb6774393ef", {"code_string": "import os\nimport sys\nfrom argparse import ArgumentParser\nparser = ArgumentParser()\nparser = ArgumentParser(description = \"Process run data from the detector server to the analysis servers, saving the reconstructed images. This uses DataConvert4 and Kim's C++ and MATLAB code\")\nparser.add_argument(\"-start\", \"--start-run\", type = int, dest = \"start\", required = True,\n    help = \"first run to process\")\nparser.add_argument(\"-stop\", \"--stop-run\", type = int, dest = \"stop\", default = 0,\n<< << << < HEAD\n    help = \"last run to process (default: only process first run)\")\nparser.add_argument(\"-exp\", \"--exp-year\", type = int, dest = \"exp\", default = 2016,\n    help = \"experimental year to compress (default: 2016)\")\n== == == =\n    help = \"last run to process (default: only process 1 run)\")\nparser.add_argument(\"-exp\", \"--exp-year\", type = int, dest = \"exp\", default = 2016,\n    help = \"experimental year to compress\")\n>> >> >> > 43 d607f1967774866172ae9d0ada5ef21e658d2b\nparser.add_argument(\"-multi\", \"--multi-run\", action = \"store_true\", dest = \"multi\", required = False, default = False,\n    help = \"process multi-file run converted using DataConvert4\")\nparser.add_argument(\"-force\", \"--force-run\", action = \"store_true\", dest = \"force\", required = False, default = False,\n    help = \"force run to process (overwrite existing folder)\")\nparser.add_argument(\"-tag\", \"--output-tag\", type = str, dest = \"tag\", default = \"run\",\n    help = \"tag for output folder (default: run)\")\nparser.add_argument(\"-o\", \"--output-flag\", type = str, dest = \"outputFlag\",\n<< << << < HEAD\n    help = \"where to process runs. 'W' refers to /work/perakis/ and 'UD' refers to '/UserData/fperakis' (default: UD)\",\n== == == =\n    help = \"where to process runs. 'W' refers to /work/perakis/ and 'UD' refers to '/UserData/fperakis'\",\n>> >> >> > 43 d607f1967774866172ae9d0ada5ef21e658d2b\n    choices = ['W', 'UD'], default = 'UD')\nargs = parser.parse_args()\nif args.outputFlag == 'W':\n    outdir = '/work/fperakis/'\n    print(\"Running dataCompress3.py in '%s' is currently not supported...\" % outdir)\n    sys.exit(1)\nelif args.outputFlag == 'UD':\n    basedir = '/UserData/fperakis/'\n<< << << < HEAD\n    src_dir = '/home/fperakis/2016_06/git/SACLA2016A8015/code/'\n== == == =\n    src_dir = basedir + 'code/'\n>> >> >> > 43 d607f1967774866172ae9d0ada5ef21e658d2b\n    outdir = basedir + '%d_6/' % args.exp\nif(args.stop < args.start):\n    args.stop = args.start\nassert(args.stop >= args.start)\nfor run in xrange(args.start, args.stop + 1):\n    RUN = str(run)\n    runFolder = os.path.join(outdir, '%s%s' %(args.tag, RUN))\n    warning_msg = 'Folder \"%s\" already exists! Please rename it and try again, or use -force to overwrite existing folder.' % runFolder\n    assert(not os.path.exists(runFolder) or args.force), warning_msg\n    if(args.force and os.path.exists(runFolder)):\n        print('Overwriting existing folder: %s' % runFolder)\n        os.system('rm -r %s' % runFolder)\n    else:\n        print('Creating run folder: %s' % runFolder)\n    os.mkdir(runFolder)\n    print(\"Copying Kim's code to run folder:\")\n    scripts = ['matlab_background.csh', 'sacla_2016_6.m', 'av.out', 'integ.out', 'data_process.out', 'fit2d_old']\n    for s in scripts:\n        os.system('cp %s/%s %s/.' %(src_dir, s, runFolder))\n        print('\\t%s' % s)\n    org_dir = os.getcwd()\n    os.chdir(runFolder)\n    os.system(\"sed -i -e 's/448539/%s/g' sacla_2016_6.m\" % RUN)\n    sys.stdout.flush()\n    os.system('./data_process.out %s' % RUN)\n", "code_toks_joined": "import os <NEWLINE> import sys <NEWLINE> from argparse import ArgumentParser <NEWLINE> parser = ArgumentParser ( ) <NEWLINE> parser = ArgumentParser ( description = <STRING> ) <NEWLINE> parser . add_argument ( <STRING> , <STRING> , type = int , dest = <STRING> , required = True , <NEWLINE> <INDENT> help = <STRING> ) <NEWLINE> <DEDENT> parser . add_argument ( <STRING> , <STRING> , type = int , dest = <STRING> , default = 0 , <NEWLINE> << << << < HEAD <NEWLINE> <INDENT> help = <STRING> ) <NEWLINE> <DEDENT> parser . add_argument ( <STRING> , <STRING> , type = int , dest = <STRING> , default = 2016 , <NEWLINE> <INDENT> help = <STRING> ) <NEWLINE> <DEDENT> == == == = <NEWLINE> <INDENT> help = <STRING> ) <NEWLINE> <DEDENT> parser . add_argument ( <STRING> , <STRING> , type = int , dest = <STRING> , default = 2016 , <NEWLINE> <INDENT> help = <STRING> ) <NEWLINE> <DEDENT> >> >> >> > 43 d607f1967774866172ae9d0ada5ef21e658d2b <NEWLINE> parser . add_argument ( <STRING> , <STRING> , action = <STRING> , dest = <STRING> , required = False , default = False , <NEWLINE> <INDENT> help = <STRING> ) <NEWLINE> <DEDENT> parser . add_argument ( <STRING> , <STRING> , action = <STRING> , dest = <STRING> , required = False , default = False , <NEWLINE> <INDENT> help = <STRING> ) <NEWLINE> <DEDENT> parser . add_argument ( <STRING> , <STRING> , type = str , dest = <STRING> , default = <STRING> , <NEWLINE> <INDENT> help = <STRING> ) <NEWLINE> <DEDENT> parser . add_argument ( <STRING> , <STRING> , type = str , dest = <STRING> , <NEWLINE> << << << < HEAD <NEWLINE> <INDENT> help = <STRING> , <NEWLINE> <DEDENT> == == == = <NEWLINE> <INDENT> help = <STRING> , <NEWLINE> <DEDENT> >> >> >> > 43 d607f1967774866172ae9d0ada5ef21e658d2b <NEWLINE> <INDENT> choices = [ <STRING> , <STRING> ] , default = <STRING> ) <NEWLINE> <DEDENT> args = parser . parse_args ( ) <NEWLINE> if args . outputFlag == <STRING> : <NEWLINE> <INDENT> outdir = <STRING> <NEWLINE> print ( <STRING> % outdir ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> elif args . outputFlag == <STRING> : <NEWLINE> <INDENT> basedir = <STRING> <NEWLINE> <DEDENT> << << << < HEAD <NEWLINE> <INDENT> src_dir = <STRING> <NEWLINE> <DEDENT> == == == = <NEWLINE> <INDENT> src_dir = basedir + <STRING> <NEWLINE> <DEDENT> >> >> >> > 43 d607f1967774866172ae9d0ada5ef21e658d2b <NEWLINE> <INDENT> outdir = basedir + <STRING> % args . exp <NEWLINE> <DEDENT> if ( args . stop < args . start ) : <NEWLINE> <INDENT> args . stop = args . start <NEWLINE> <DEDENT> assert ( args . stop >= args . start ) <NEWLINE> for run in xrange ( args . start , args . stop + 1 ) : <NEWLINE> <INDENT> RUN = str ( run ) <NEWLINE> runFolder = os . path . join ( outdir , <STRING> % ( args . tag , RUN ) ) <NEWLINE> warning_msg = <STRING> % runFolder <NEWLINE> assert ( not os . path . exists ( runFolder ) or args . force ) , warning_msg <NEWLINE> if ( args . force and os . path . exists ( runFolder ) ) : <NEWLINE> <INDENT> print ( <STRING> % runFolder ) <NEWLINE> os . system ( <STRING> % runFolder ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> % runFolder ) <NEWLINE> <DEDENT> os . mkdir ( runFolder ) <NEWLINE> print ( <STRING> ) <NEWLINE> scripts = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for s in scripts : <NEWLINE> <INDENT> os . system ( <STRING> % ( src_dir , s , runFolder ) ) <NEWLINE> print ( <STRING> % s ) <NEWLINE> <DEDENT> org_dir = os . getcwd ( ) <NEWLINE> os . chdir ( runFolder ) <NEWLINE> os . system ( <STRING> % RUN ) <NEWLINE> sys . stdout . flush ( ) <NEWLINE> os . system ( <STRING> % RUN ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Process run data from the detector server to the analysis servers, saving the reconstructed images. This uses DataConvert4 and Kim's C++ and MATLAB code\"", "\"-start\"", "\"--start-run\"", "\"start\"", "\"first run to process\"", "\"-stop\"", "\"--stop-run\"", "\"stop\"", "\"last run to process (default: only process first run)\"", "\"-exp\"", "\"--exp-year\"", "\"exp\"", "\"experimental year to compress (default: 2016)\"", "\"last run to process (default: only process 1 run)\"", "\"-exp\"", "\"--exp-year\"", "\"exp\"", "\"experimental year to compress\"", "\"-multi\"", "\"--multi-run\"", "\"store_true\"", "\"multi\"", "\"process multi-file run converted using DataConvert4\"", "\"-force\"", "\"--force-run\"", "\"store_true\"", "\"force\"", "\"force run to process (overwrite existing folder)\"", "\"-tag\"", "\"--output-tag\"", "\"tag\"", "\"run\"", "\"tag for output folder (default: run)\"", "\"-o\"", "\"--output-flag\"", "\"outputFlag\"", "\"where to process runs. 'W' refers to /work/perakis/ and 'UD' refers to '/UserData/fperakis' (default: UD)\"", "\"where to process runs. 'W' refers to /work/perakis/ and 'UD' refers to '/UserData/fperakis'\"", "'W'", "'UD'", "'UD'", "'W'", "'/work/fperakis/'", "\"Running dataCompress3.py in '%s' is currently not supported...\"", "'UD'", "'/UserData/fperakis/'", "'/home/fperakis/2016_06/git/SACLA2016A8015/code/'", "'code/'", "'%d_6/'", "'%s%s'", "'Folder \"%s\" already exists! Please rename it and try again, or use -force to overwrite existing folder.'", "'Overwriting existing folder: %s'", "'rm -r %s'", "'Creating run folder: %s'", "\"Copying Kim's code to run folder:\"", "'matlab_background.csh'", "'sacla_2016_6.m'", "'av.out'", "'integ.out'", "'data_process.out'", "'fit2d_old'", "'cp %s/%s %s/.'", "'\\t%s'", "\"sed -i -e 's/448539/%s/g' sacla_2016_6.m\"", "'./data_process.out %s'"]}, "window_span": [121, 127], "err_obj": {"msg": "unbalanced (){}[]"}}], ["bfa5018004217052f02dff04688ebff4", {"code_string": "def checkExistence(self, name):\n    found = 0\n    for x in g_attribs:\n        if x == name:\n        found = 1\n        break\n    if not found:\n        raise UnknownPropertyException(\"Property \" + name + \" is unknown\", self)\n", "code_toks_joined": "def checkExistence ( self , name ) : <NEWLINE> <INDENT> found = 0 <NEWLINE> for x in g_attribs : <NEWLINE> <INDENT> if x == name : <NEWLINE> found = 1 <NEWLINE> break <NEWLINE> <DEDENT> if not found : <NEWLINE> <INDENT> raise UnknownPropertyException ( <STRING> + name + <STRING> , self ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Property \"", "\" is unknown\""]}, "err_obj": {"msg": "expected an indented block"}}], ["0e5b1d197f9b3210f8cac84f3f9a2c07", {"code_string": "def add_new_to_container_url(regrouped):\n    try:\n        container = regrouped['grouper']\n        containertypename = type(container).__name__.lower()\n        try:\n            subtypename = subtypenames[containertypename]\n        except KeyError:\n            raise ValueError('Container type \"%s\" is not supported.' % containertypename)\n        return reverse('admin:feed_%s_add' % subtypename) + '?%s=%d' %(containertypename container.id)\n    except KeyError:\n        raise ImproperlyConfigured('add_new_to_container_url requires as an argument a \"regrouped\" item container')\n", "code_toks_joined": "def add_new_to_container_url ( regrouped ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> container = regrouped [ <STRING> ] <NEWLINE> containertypename = type ( container ) . __name__ . lower ( ) <NEWLINE> try : <NEWLINE> <INDENT> subtypename = subtypenames [ containertypename ] <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> raise ValueError ( <STRING> % containertypename ) <NEWLINE> <DEDENT> return reverse ( <STRING> % subtypename ) + <STRING> % ( containertypename container . id ) <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> raise ImproperlyConfigured ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'grouper'", "'Container type \"%s\" is not supported.'", "'admin:feed_%s_add'", "'?%s=%d'", "'add_new_to_container_url requires as an argument a \"regrouped\" item container'"]}, "err_obj": {"msg": "invalid syntax"}}], ["96077b6ab004a61ef18ce7c65f6373ea", {"code_string": "class Node():\n    def __init__(self, id):\n    self.id = id\n    self.neighbours = []\n    def addNeighbour(self, nb):\n    self.neighbours.append(nb)\n", "code_toks_joined": "class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , id ) : <NEWLINE> self . id = id <NEWLINE> self . neighbours = [ ] <NEWLINE> def addNeighbour ( self , nb ) : <NEWLINE> self . neighbours . append ( nb ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["089dd8a08a1363bae1419d3c9658c7f4", {"code_string": "def on_window_state_change(self, widget, event, * args)\n    if event.new_window_state & gtk.gdk.WINDOW_STATE_FULLSCREEN:\n        self.window_in_fullscreen = True\n    else:\n        self.window_in_fullscreen = False\n    self.draw_base()\n", "code_toks_joined": "def on_window_state_change ( self , widget , event , * args ) <NEWLINE> <INDENT> if event . new_window_state & gtk . gdk . WINDOW_STATE_FULLSCREEN : <NEWLINE> <INDENT> self . window_in_fullscreen = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . window_in_fullscreen = False <NEWLINE> <DEDENT> self . draw_base ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["5d7bd5d6499044a8e2c51e756db932ee", {"code_string": "import logging\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.web\nimport sys\nimport os\nfrom tornado.options import options\ncurrent_directory = os.path.dirname(os.path.realpath(__file__))\nfor target_path in[current_directory,\n    os.path.join(current_directory, 'cozyindexer')]:\n    if os.path.exists(target_path):\n    if target_path not in sys.path:\n    sys.path.insert(0, target_path)\nfrom app import CozyDataIndexer\napp = CozyDataIndexer()\n", "code_toks_joined": "import logging <NEWLINE> import tornado . httpserver <NEWLINE> import tornado . ioloop <NEWLINE> import tornado . web <NEWLINE> import sys <NEWLINE> import os <NEWLINE> from tornado . options import options <NEWLINE> current_directory = os . path . dirname ( os . path . realpath ( __file__ ) ) <NEWLINE> for target_path in [ current_directory , <NEWLINE> <INDENT> os . path . join ( current_directory , <STRING> ) ] : <NEWLINE> if os . path . exists ( target_path ) : <NEWLINE> if target_path not in sys . path : <NEWLINE> sys . path . insert ( 0 , target_path ) <NEWLINE> <DEDENT> from app import CozyDataIndexer <NEWLINE> app = CozyDataIndexer ( ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["'cozyindexer'"]}, "err_obj": {"msg": "expected an indented block"}}], ["90e24d5cb8c35a8406b58c55b64b3b20", {"code_string": "def delname(self, name):\n    syminf = self.scope.tbl.get(name)\n    if syminf and syminf.flags & GLOBAL: return self.delCode('delglobal', name)\n    if not self.fast_locals: return self.delCode('dellocal', name)\n    if syminf.flags & CELL: raise NameError, \"can not delete variable '%s' referenced in nested scope\" % name\n    return self.delCode('dellocal', syminf.locals_index)\n", "code_toks_joined": "def delname ( self , name ) : <NEWLINE> <INDENT> syminf = self . scope . tbl . get ( name ) <NEWLINE> if syminf and syminf . flags & GLOBAL : return self . delCode ( <STRING> , name ) <NEWLINE> if not self . fast_locals : return self . delCode ( <STRING> , name ) <NEWLINE> if syminf . flags & CELL : raise NameError , <STRING> % name <NEWLINE> return self . delCode ( <STRING> , syminf . locals_index ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'delglobal'", "'dellocal'", "\"can not delete variable '%s' referenced in nested scope\"", "'dellocal'"]}, "err_obj": {"msg": "invalid syntax"}}], ["9cb47cd2d4bf02c98e13193c20d681a1", {"code_string": "class Collector(DefaultProcess):\n    \"\"\"A basic class for collectors processors.\"\"\"\n    def __init__(self,\n        name = 'Default Collector',\n        queue = None,\n        shutdown = None,\n        config = None):\n        DefaultProcess.__init__(self,\n            name = name,\n            shutdown = shutdown,\n            config = config)\n            self.queue = queue\n            self.interval = 30\n    def shutdown(self):\n        self.log.info('Stopping')\n        sys.exit()\n    def run(self):\n        \"\"\"This method must be overridden in inherited class.\"\"\"\n        raise NotImplementedError\n", "code_toks_joined": "class Collector ( DefaultProcess ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> queue = None , <NEWLINE> shutdown = None , <NEWLINE> config = None ) : <NEWLINE> DefaultProcess . __init__ ( self , <NEWLINE> <INDENT> name = name , <NEWLINE> shutdown = shutdown , <NEWLINE> config = config ) <NEWLINE> self . queue = queue <NEWLINE> self . interval = 30 <NEWLINE> <DEDENT> <DEDENT> def shutdown ( self ) : <NEWLINE> <INDENT> self . log . info ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> def run ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> raise NotImplementedError <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"A basic class for collectors processors.\"\"\"", "'Default Collector'", "'Stopping'", "\"\"\"This method must be overridden in inherited class.\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["babe817208038ae53c310e8626669035", {"code_string": "def taskDetail(request, task_id):\n    task = get_object_or_404(Task, pk = task_id)\n        if task.publication_date >= datetime.now() and not request.user.is_trainer:\n        raise Http404\n    my_solutions = Task.objects.get(pk = task_id).solution_set.filter(author = request.user)\n        return render_to_response(\n            'tasks/task_detail.html',\n            {\n                'task': task,\n                'solutions': my_solutions,\n            },\n            context_instance = RequestContext(request))\n", "code_toks_joined": "def taskDetail ( request , task_id ) : <NEWLINE> <INDENT> task = get_object_or_404 ( Task , pk = task_id ) <NEWLINE> <INDENT> if task . publication_date >= datetime . now ( ) and not request . user . is_trainer : <NEWLINE> raise Http404 <NEWLINE> <DEDENT> my_solutions = Task . objects . get ( pk = task_id ) . solution_set . filter ( author = request . user ) <NEWLINE> <INDENT> return render_to_response ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> { <NEWLINE> <INDENT> <STRING> : task , <NEWLINE> <STRING> : my_solutions , <NEWLINE> <DEDENT> } , <NEWLINE> context_instance = RequestContext ( request ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'tasks/task_detail.html'", "'task'", "'solutions'"]}, "err_obj": {"msg": "unexpected indent"}}], ["4df1aa7e6f4664ca8f2de252428dfb96", {"code_string": "class WsgiApplication(_SpyneWsgiApplication):\n    def __init__(self, app, chunked = True, max_content_length = 2 * 1024 * 1024,\n        block_length = 8 * 1024):\n        super(WsgiApplication, self).__init__(app, chunked, max_content_length,\n            block_length)\n            self.doc = _AllYourInterfaceDocuments(app.interface)\n", "code_toks_joined": "class WsgiApplication ( _SpyneWsgiApplication ) : <NEWLINE> <INDENT> def __init__ ( self , app , chunked = True , max_content_length = 2 * 1024 * 1024 , <NEWLINE> <INDENT> block_length = 8 * 1024 ) : <NEWLINE> super ( WsgiApplication , self ) . __init__ ( app , chunked , max_content_length , <NEWLINE> <INDENT> block_length ) <NEWLINE> self . doc = _AllYourInterfaceDocuments ( app . interface ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["6ddb18357dfa6df75ca2765b86129599", {"code_string": "from __future__ import absolute_import\nimport subprocess\nimport os\nfrom dmp_packs.actions.models import StreamingActionExecution, MESSAGE_TYPES\ndef streaming_action_runner_callback(execution_id, pack, action,\n    cleaned_parameters):\n    streaming_action = StreamingActionExecution.objects.get(\n    id_execution = execution_id,\n    pack_slug = pack.slug,\n    action_slug = action.slug)\n    if action.runner_type == \"local-shell-script\":\n    local_shell_script_runner(action, cleaned_parameters, streaming_action)\n", "code_toks_joined": "from __future__ import absolute_import <NEWLINE> import subprocess <NEWLINE> import os <NEWLINE> from dmp_packs . actions . models import StreamingActionExecution , MESSAGE_TYPES <NEWLINE> def streaming_action_runner_callback ( execution_id , pack , action , <NEWLINE> <INDENT> cleaned_parameters ) : <NEWLINE> streaming_action = StreamingActionExecution . objects . get ( <NEWLINE> id_execution = execution_id , <NEWLINE> pack_slug = pack . slug , <NEWLINE> action_slug = action . slug ) <NEWLINE> if action . runner_type == <STRING> : <NEWLINE> local_shell_script_runner ( action , cleaned_parameters , streaming_action ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"local-shell-script\""]}, "err_obj": {"msg": "expected an indented block"}}], ["756edc7312f69e97822a4adc6f15bee5", {"code_string": "def changedEntry(self):\n    for x in self.onChangedEntry:\n        x()\n            def keyCancel(self):\n                for x in self['config'].list:\n                    x[1].cancel()\n                self.close()\n", "code_toks_joined": "def changedEntry ( self ) : <NEWLINE> <INDENT> for x in self . onChangedEntry : <NEWLINE> <INDENT> x ( ) <NEWLINE> <INDENT> def keyCancel ( self ) : <NEWLINE> <INDENT> for x in self [ <STRING> ] . list : <NEWLINE> <INDENT> x [ 1 ] . cancel ( ) <NEWLINE> <DEDENT> self . close ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'config'"]}, "err_obj": {"msg": "unexpected indent"}}], ["8268882f42fbc6189318cf66c64f8d69", {"code_string": "\"\"\"\"\"\"\n__version__ = \"$Id$\"\nimport string\nfor name in(s\n    for s in dir(string)\n    if not s.startswith('_')):\n    value = getattr(string, name)\n    if isinstance(value, basestring):\n    print('%s=%r\\n' %(name, value))\n", "code_toks_joined": "<STRING> <NEWLINE> __version__ = <STRING> <NEWLINE> import string <NEWLINE> for name in ( s <NEWLINE> <INDENT> for s in dir ( string ) <NEWLINE> if not s . startswith ( <STRING> ) ) : <NEWLINE> value = getattr ( string , name ) <NEWLINE> if isinstance ( value , basestring ) : <NEWLINE> print ( <STRING> % ( name , value ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"\"\"\"", "\"$Id$\"", "'_'", "'%s=%r\\n'"]}, "err_obj": {"msg": "expected an indented block"}}], ["52684db4dfa12511f1d78f8dccaa214d", {"code_string": "def resolve(self, url, title, iconimage, meta):\n    r = client.request(url)\n    r = BeautifulSoup(r)\n    r = r.findAll('iframe')\n    for src in r:\n    url = src['src'].encode('utf-8')\n    try: host = re.findall('([\\w]+[.][\\w]+)$', urlparse.urlparse(url.strip().lower()).netloc)[0]\n    except: host = 'Unknown'\n    control.addLink(host, url, 'play', iconimage, control.fanart, meta)\n", "code_toks_joined": "def resolve ( self , url , title , iconimage , meta ) : <NEWLINE> <INDENT> r = client . request ( url ) <NEWLINE> r = BeautifulSoup ( r ) <NEWLINE> r = r . findAll ( <STRING> ) <NEWLINE> for src in r : <NEWLINE> url = src [ <STRING> ] . encode ( <STRING> ) <NEWLINE> try : host = re . findall ( <STRING> , urlparse . urlparse ( url . strip ( ) . lower ( ) ) . netloc ) [ 0 ] <NEWLINE> except : host = <STRING> <NEWLINE> control . addLink ( host , url , <STRING> , iconimage , control . fanart , meta ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'iframe'", "'src'", "'utf-8'", "'([\\w]+[.][\\w]+)$'", "'Unknown'", "'play'"]}, "err_obj": {"msg": "expected an indented block"}}], ["5914c6107771b1252b5dbf5eaccc1aed", {"code_string": "def get_patient(patient_id):\n    try\n        if not patient_id:\n            return None\n        patient = Patient.objects.get(pk = patient_id)\n        return patient\n    except Patient.DoesNotExist:\n        return None\n", "code_toks_joined": "def get_patient ( patient_id ) : <NEWLINE> <INDENT> try <NEWLINE> <INDENT> if not patient_id : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> patient = Patient . objects . get ( pk = patient_id ) <NEWLINE> return patient <NEWLINE> <DEDENT> except Patient . DoesNotExist : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["26f8aef22cd9f93d7f644f4b4cdb517a", {"code_string": "def _lift_substructure_match(self, subm):\n    if not self._is_liftable_substructure_match(subm):\n        return None\n    if all(map(lambda r: r == SubstructureMatch.WHOLE_CONCEPT),\n        subm.constituent_ranges):\n        ancestors = map(lambda c: concept.ancestors(c),\n            subm.concepts)\n            longest_common_ancestors = longest_common_prefix(ancestors)\n            ancestral_parent = longest_common_ancestors[- 1]\n            ancestral_constituents = []\n            for ancs in ancestors:\n            pass\n", "code_toks_joined": "def _lift_substructure_match ( self , subm ) : <NEWLINE> <INDENT> if not self . _is_liftable_substructure_match ( subm ) : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> if all ( map ( lambda r : r == SubstructureMatch . WHOLE_CONCEPT ) , <NEWLINE> <INDENT> subm . constituent_ranges ) : <NEWLINE> ancestors = map ( lambda c : concept . ancestors ( c ) , <NEWLINE> <INDENT> subm . concepts ) <NEWLINE> longest_common_ancestors = longest_common_prefix ( ancestors ) <NEWLINE> ancestral_parent = longest_common_ancestors [ - 1 ] <NEWLINE> ancestral_constituents = [ ] <NEWLINE> for ancs in ancestors : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["fa6fd4f8843898be8a94a51344efce6c", {"code_string": "def check_content_type(fuzzresult, which):\n    ctype = None\n    if 'Content-Type' in fuzzresult.history.headers.response:\n    ctype = fuzzresult.history.headers.response['Content-Type']\n    if which == 'text':\n    return not ctype or(ctype and any(map(lambda x: ctype.find(x) >= 0, ['text/plain'])))\n    else:\n    raise FuzzExceptBadAPI(\"Unknown content type\")\n", "code_toks_joined": "def check_content_type ( fuzzresult , which ) : <NEWLINE> <INDENT> ctype = None <NEWLINE> if <STRING> in fuzzresult . history . headers . response : <NEWLINE> ctype = fuzzresult . history . headers . response [ <STRING> ] <NEWLINE> if which == <STRING> : <NEWLINE> return not ctype or ( ctype and any ( map ( lambda x : ctype . find ( x ) >= 0 , [ <STRING> ] ) ) ) <NEWLINE> else : <NEWLINE> raise FuzzExceptBadAPI ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Content-Type'", "'Content-Type'", "'text'", "'text/plain'", "\"Unknown content type\""]}, "err_obj": {"msg": "expected an indented block"}}], ["97e1fb7dd7b748266a77b9fdc0775e15", {"code_string": "def onExecute(self, ec_id):\n    duration = time.clock() - self._activatedClock\n    if self._statusIn.isNew():\n    self._d_status = self._statusIn.read()\n    self._received = True\n    self._d_command.acceleratorPressMeter = math.sin(duration / self._interval * 2 * math.pi)\n    print(self._d_command)\n    self._commandOut.write()\n    return RTC.RTC_OK\n", "code_toks_joined": "def onExecute ( self , ec_id ) : <NEWLINE> <INDENT> duration = time . clock ( ) - self . _activatedClock <NEWLINE> if self . _statusIn . isNew ( ) : <NEWLINE> self . _d_status = self . _statusIn . read ( ) <NEWLINE> self . _received = True <NEWLINE> self . _d_command . acceleratorPressMeter = math . sin ( duration / self . _interval * 2 * math . pi ) <NEWLINE> print ( self . _d_command ) <NEWLINE> self . _commandOut . write ( ) <NEWLINE> return RTC . RTC_OK <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["1f828d374f2b240f0b7a459aea66ea69", {"code_string": "def send_loop(empty_queue_sleep = None):\n    \"\"\"Loop indefinitely, checking queue at intervals and sending and queued\"\"\"\n    empty_queue_sleep = empty_queue_sleep or settings.EMPTY_QUEUE_SLEEP\n    while True:\n        while not models.QueuedMessage.objects.all()\n            logger.debug(\"Sleeping for %s seconds before checking queue \"\n                \"again.\" % empty_queue_sleep)\n            time.sleep(empty_queue_sleep)\n        send_all()\n", "code_toks_joined": "def send_loop ( empty_queue_sleep = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> empty_queue_sleep = empty_queue_sleep or settings . EMPTY_QUEUE_SLEEP <NEWLINE> while True : <NEWLINE> <INDENT> while not models . QueuedMessage . objects . all ( ) <NEWLINE> <INDENT> logger . debug ( <STRING> <NEWLINE> <INDENT> <STRING> % empty_queue_sleep ) <NEWLINE> <DEDENT> time . sleep ( empty_queue_sleep ) <NEWLINE> <DEDENT> send_all ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Loop indefinitely, checking queue at intervals and sending and queued\"\"\"", "\"Sleeping for %s seconds before checking queue \"", "\"again.\""]}, "err_obj": {"msg": "invalid syntax"}}], ["b2932af2535ecd4d4e3c6936215abddb", {"code_string": "import os\ndef update_privoxy_list(blocked_urls,\n    version, title, last_modified,\n    homepage, license, issue_tracker):\n    script_dir = os.path.dirname(__file__)\n    list_path = os.path.join(script_dir, 'user.action')\n    with open(list_path, 'wt') as privoxy_list:\n    print(f'{{+block{{{title}}}}}', file = privoxy_list)\n    for url in blocked_urls:\n    print(f'.{url}', file = privoxy_list)\n", "code_toks_joined": "import os <NEWLINE> def update_privoxy_list ( blocked_urls , <NEWLINE> <INDENT> version , title , last_modified , <NEWLINE> homepage , license , issue_tracker ) : <NEWLINE> script_dir = os . path . dirname ( __file__ ) <NEWLINE> list_path = os . path . join ( script_dir , <STRING> ) <NEWLINE> with open ( list_path , <STRING> ) as privoxy_list : <NEWLINE> print ( <STRING> , file = privoxy_list ) <NEWLINE> for url in blocked_urls : <NEWLINE> print ( <STRING> , file = privoxy_list ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'user.action'", "'wt'", "f'{{+block{{{title}}}}}'", "f'.{url}'"]}, "err_obj": {"msg": "expected an indented block"}}], ["a28a4bfe0682915e3a19cbcd87cd5774", {"code_string": "[[[cog\nimport sys\nsys.path.append('/opt/robocomp/python')\nimport cog\n", "code_toks_joined": "[ [ [ cog <NEWLINE> import sys <NEWLINE> sys . path . append ( <STRING> ) <NEWLINE> import cog <NEWLINE>", "anonymize_dict": {"<STRING>": ["'/opt/robocomp/python'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["2aeeeb6221c61628bd9ff4a2a8bf15b1", {"code_string": "\"\"\"A compatible impl to get username on Windows or Linux\"\"\"\nimport os\nimport psutil\nimport datetime\nimport pytz\nimport sys\nimport subprocess\nmswindows = (sys.platform == \"win32\")\nlinux = (sys.platform == \"linux2\")\nfor name in('LOGNAME', 'USER', 'LNAME', 'USERNAME'):\n    user = os.environ.get(name)\n    if user:\n        print(user)\n        break\nif linux:\n    proc_obj = subprocess.Popen(r'tty', shell = True, stdout = subprocess.PIPE,\n        stderr = subprocess.STDOUT)\n    tty = proc_obj.communicate()[0]\nelse:\n    tty = []\nfor login in psutil.users():\n    username, login_tty, login_host, login_time = [suser for suser in login]\n    print(username, login_tty, login_host, login_time, )\n    print(datetime.datetime.fromtimestamp(login_time, pytz.timezone('Asia/Shanghai')).strftime(\n        '%Y-%m-%d %H:%M:%S %Z%z'),\n    if login_tty in tty:\n        print('**current user**')\n    else:\n        print\n", "code_toks_joined": "<STRING> <NEWLINE> import os <NEWLINE> import psutil <NEWLINE> import datetime <NEWLINE> import pytz <NEWLINE> import sys <NEWLINE> import subprocess <NEWLINE> mswindows = ( sys . platform == <STRING> ) <NEWLINE> linux = ( sys . platform == <STRING> ) <NEWLINE> for name in ( <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> user = os . environ . get ( name ) <NEWLINE> if user : <NEWLINE> <INDENT> print ( user ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if linux : <NEWLINE> <INDENT> proc_obj = subprocess . Popen ( <STRING> , shell = True , stdout = subprocess . PIPE , <NEWLINE> <INDENT> stderr = subprocess . STDOUT ) <NEWLINE> <DEDENT> tty = proc_obj . communicate ( ) [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tty = [ ] <NEWLINE> <DEDENT> for login in psutil . users ( ) : <NEWLINE> <INDENT> username , login_tty , login_host , login_time = [ suser for suser in login ] <NEWLINE> print ( username , login_tty , login_host , login_time , ) <NEWLINE> print ( datetime . datetime . fromtimestamp ( login_time , pytz . timezone ( <STRING> ) ) . strftime ( <NEWLINE> <INDENT> <STRING> ) , <NEWLINE> <DEDENT> if login_tty in tty : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"A compatible impl to get username on Windows or Linux\"\"\"", "\"win32\"", "\"linux2\"", "'LOGNAME'", "'USER'", "'LNAME'", "'USERNAME'", "r'tty'", "'Asia/Shanghai'", "'%Y-%m-%d %H:%M:%S %Z%z'", "'**current user**'"]}, "window_span": [175, 222], "err_obj": {"msg": "unbalanced (){}[]"}}], ["5082f62608d9b136886540a3537003c5", {"code_string": "def plotStarDist(text, xlabel, ylabel, data):\n    x = [data[key] for key in data]\n    n, bins, patches = P.hist(x, 10, normed = 0, histtype = 'stepfilled')\n        P.xlabel(xlabel)\n        P.ylabel(ylabel)\n        P.setp(patches, 'facecolor', 'g', 'alpha', 0.75)\n        P.title(text)\n        P.show()\n", "code_toks_joined": "def plotStarDist ( text , xlabel , ylabel , data ) : <NEWLINE> <INDENT> x = [ data [ key ] for key in data ] <NEWLINE> n , bins , patches = P . hist ( x , 10 , normed = 0 , histtype = <STRING> ) <NEWLINE> <INDENT> P . xlabel ( xlabel ) <NEWLINE> P . ylabel ( ylabel ) <NEWLINE> P . setp ( patches , <STRING> , <STRING> , <STRING> , 0.75 ) <NEWLINE> P . title ( text ) <NEWLINE> P . show ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'stepfilled'", "'facecolor'", "'g'", "'alpha'"]}, "err_obj": {"msg": "unexpected indent"}}], ["65f41d3fff1ef1a571a4a59a8b41eeb9", {"code_string": "def _get_next_open_batch(self) -> Batch:\n    \"\"\":return: Next open batch for this task type\"\"\"\n    for batch in Batch.objects.filter(\n        task_type = self.type_name,\n        closed__ne = True).order_by('id'):\n        if batch.tasks_count == batch.tasks_processed:\n        continue\n        return batch\n    return None\n", "code_toks_joined": "def _get_next_open_batch ( self ) -> Batch : <NEWLINE> <INDENT> <STRING> <NEWLINE> for batch in Batch . objects . filter ( <NEWLINE> <INDENT> task_type = self . type_name , <NEWLINE> closed__ne = True ) . order_by ( <STRING> ) : <NEWLINE> if batch . tasks_count == batch . tasks_processed : <NEWLINE> continue <NEWLINE> return batch <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\":return: Next open batch for this task type\"\"\"", "'id'"]}, "err_obj": {"msg": "expected an indented block"}}], ["fc53421380ca600d790c584418c7ca3c", {"code_string": "def hasplugin(self, name):\n    \"\"\"Return True if the plugin with the given name is registered.\"\"\"\n    return bool(self.get_plugin(name)\n", "code_toks_joined": "def hasplugin ( self , name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return bool ( self . get_plugin ( name ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return True if the plugin with the given name is registered.\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["08e5373c07a3277a84872207921085ca", {"code_string": "class UnknownTashkeel:\n    \"\"\"Arabic Tashkeel Class\"\"\"\n    def __init__(self):\n        pass\n    def lookup(self, word)\n        \"\"\"return a vocalized form of an unknown word, from a word list\"\"\"\n        return unkown_const.Table.get(word, word)\n", "code_toks_joined": "class UnknownTashkeel : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def lookup ( self , word ) <NEWLINE> <INDENT> <STRING> <NEWLINE> return unkown_const . Table . get ( word , word ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Arabic Tashkeel Class\"\"\"", "\"\"\"return a vocalized form of an unknown word, from a word list\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["86ae49ca971da264379339df3bbe2402", {"code_string": "import salome\nsalome.salome_init()\nimport GEOM\nfrom salome.geom import geomBuilder\ngeompy = geomBuilder.New(salome.myStudy)\nbox = geompy.MakeBoxDXDYDZ(100, 30, 100)\nIsValid = geompy.CheckSelfIntersections(box)\nif IsValid == 0:\n    raise RuntimeError, \"Box with self-intersections created\"\nelse:\n    print(\"\\nBox is valid\")\n", "code_toks_joined": "import salome <NEWLINE> salome . salome_init ( ) <NEWLINE> import GEOM <NEWLINE> from salome . geom import geomBuilder <NEWLINE> geompy = geomBuilder . New ( salome . myStudy ) <NEWLINE> box = geompy . MakeBoxDXDYDZ ( 100 , 30 , 100 ) <NEWLINE> IsValid = geompy . CheckSelfIntersections ( box ) <NEWLINE> if IsValid == 0 : <NEWLINE> <INDENT> raise RuntimeError , <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Box with self-intersections created\"", "\"\\nBox is valid\""]}, "err_obj": {"msg": "invalid syntax"}}], ["dfca4840185012098d92e9056c7d18ad", {"code_string": "class TestEC2ClientContext(TestCase):\n    def test_aws_ec2_client_ontext_proper_initialized(self):\n        aws_session_manager = Mock()\n        expected_client = Mock()\n        aws_session_manager.get_ec2_client = Mock(return_value = expected_client)\n        cloudshell_session = Mock()\n        aws_ec2_resource_model = Mock()\n        with EC2ClientContext(aws_session_manager = aws_session_manager,\n            cloudshell_session = cloudshell_session,\n            aws_ec2_resource_model = aws_ec2_resource_model) as ec2_client:\n            aws_session_manager.get_ec2_client.assert_called_with(cloudshell_session = cloudshell_session,\n                aws_ec2_data_model = aws_ec2_resource_model)\n                self.assertEquals(ec2_client, expected_client)\n", "code_toks_joined": "class TestEC2ClientContext ( TestCase ) : <NEWLINE> <INDENT> def test_aws_ec2_client_ontext_proper_initialized ( self ) : <NEWLINE> <INDENT> aws_session_manager = Mock ( ) <NEWLINE> expected_client = Mock ( ) <NEWLINE> aws_session_manager . get_ec2_client = Mock ( return_value = expected_client ) <NEWLINE> cloudshell_session = Mock ( ) <NEWLINE> aws_ec2_resource_model = Mock ( ) <NEWLINE> with EC2ClientContext ( aws_session_manager = aws_session_manager , <NEWLINE> <INDENT> cloudshell_session = cloudshell_session , <NEWLINE> aws_ec2_resource_model = aws_ec2_resource_model ) as ec2_client : <NEWLINE> aws_session_manager . get_ec2_client . assert_called_with ( cloudshell_session = cloudshell_session , <NEWLINE> <INDENT> aws_ec2_data_model = aws_ec2_resource_model ) <NEWLINE> self . assertEquals ( ec2_client , expected_client ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["4f9adfd8973be6d314b010affee14d2f", {"code_string": "import logging\nBLACK = '\\033[30m'\nRED = '\\033[31m'\nGREEN = '\\033[32m'\nORANGE = '\\033[33m'\nBLUE = '\\033[34m'\nPURPLE = '\\033[35m'\nCYAN = '\\033[36m'\nLIGHTGREY = '\\033[37m'\nDARKGRAY = '\\033[90m'\nLIGHTRED = '\\033[91m'\nLIGHTGREEN = '\\033[92m'\nYELLOW = '\\033[93m'\nLIGHTBLUE = '\\033[94m'\nPINK = '\\033[95m'\nLIGHTCYAN = '\\033[96m'\nRED_BKGND = '\\033[1;41m'\nENDC = '\\033[0m'\nBOLD = '\\033[1m' a\nUNDERLINE = '\\033[4m'\nLOG_FILE_FORMAT = '[%(asctime)s] %(levelname)-8s %(filename)s(%(lineno)s)-%(funcName)s() : %(message)s'\nLOG_FILE_DATEFMT = '%Y-%m-%d %H:%M:%S'\nLOG_FILE_LEVEL = logging.DEBUG\nLOG_FILE_NAME = 'temp.log'\nLOG_CONSOLE_FORMAT = DARKGRAY + '%(asctime)s ' + ENDC + '%(message)s'\nLOG_CONSOLE_DATEFMT = '%m-%d %H:%M'\nLOG_CONSOLE_LEVEL = logging.DEBUG\n", "code_toks_joined": "import logging <NEWLINE> BLACK = <STRING> <NEWLINE> RED = <STRING> <NEWLINE> GREEN = <STRING> <NEWLINE> ORANGE = <STRING> <NEWLINE> BLUE = <STRING> <NEWLINE> PURPLE = <STRING> <NEWLINE> CYAN = <STRING> <NEWLINE> LIGHTGREY = <STRING> <NEWLINE> DARKGRAY = <STRING> <NEWLINE> LIGHTRED = <STRING> <NEWLINE> LIGHTGREEN = <STRING> <NEWLINE> YELLOW = <STRING> <NEWLINE> LIGHTBLUE = <STRING> <NEWLINE> PINK = <STRING> <NEWLINE> LIGHTCYAN = <STRING> <NEWLINE> RED_BKGND = <STRING> <NEWLINE> ENDC = <STRING> <NEWLINE> BOLD = <STRING> a <NEWLINE> UNDERLINE = <STRING> <NEWLINE> LOG_FILE_FORMAT = <STRING> <NEWLINE> LOG_FILE_DATEFMT = <STRING> <NEWLINE> LOG_FILE_LEVEL = logging . DEBUG <NEWLINE> LOG_FILE_NAME = <STRING> <NEWLINE> LOG_CONSOLE_FORMAT = DARKGRAY + <STRING> + ENDC + <STRING> <NEWLINE> LOG_CONSOLE_DATEFMT = <STRING> <NEWLINE> LOG_CONSOLE_LEVEL = logging . DEBUG <NEWLINE>", "anonymize_dict": {"<STRING>": ["'\\033[30m'", "'\\033[31m'", "'\\033[32m'", "'\\033[33m'", "'\\033[34m'", "'\\033[35m'", "'\\033[36m'", "'\\033[37m'", "'\\033[90m'", "'\\033[91m'", "'\\033[92m'", "'\\033[93m'", "'\\033[94m'", "'\\033[95m'", "'\\033[96m'", "'\\033[1;41m'", "'\\033[0m'", "'\\033[1m'", "'\\033[4m'", "'[%(asctime)s] %(levelname)-8s %(filename)s(%(lineno)s)-%(funcName)s() : %(message)s'", "'%Y-%m-%d %H:%M:%S'", "'temp.log'", "'%(asctime)s '", "'%(message)s'", "'%m-%d %H:%M'"]}, "err_obj": {"msg": "invalid syntax"}}], ["8adefb12091882b819116e63a61fcc01", {"code_string": "def _checkBitsAndHex(self, epc):\n    bits = epc.toBinary()\n    hex = epc.toHex()\n    headerValue = bits[epc.getField(\"Header\").getOffset(): epc.getField(\"Header\").getBitLength()]\n    self.assertEquals(int(headerValue, 2), 51)\n    headerValue = hex[: 2]\n    self.assertEquals(int(headerValue, 16), 51)\n    filterValue = bits[epc.getField(\"Filter\").getOffset(): int(epc.getField(\"Filter\").getOffset()) + int(epc.getField(\"Filter\").getBitLength())]\n    self.assertEquals(int(filterValue, 2), int(self._filter))\n    hexBodyBits = BitArray(hex = hex).bin[2: ]\n    partitionValue = bits[epc.getField(\"Partition\").getOffset(): int(epc.getField(\"Partition\").getOffset()) + int(epc.getField(\"Partition\").getBitLength())]\n    partitionValue = int(partitionValue, 2)\n    companyPrefixBits = hexBodyBits[epc.getField(\"CompanyPrefix\").getOffset(): epc.getField(\"CompanyPrefix\").getOffset() + epc.getField(\"CompanyPrefix\").getBitLength()]\n    companyPrefixValue = BitArray(bin = companyPrefixBits).uint\n    self.assertEquals(companyPrefixValue, int(self._companyPrefix))\n    epc.getField(\"CompanyPrefix\").getBitLength()\n    assetTypeBits = hexBodyBits[epc.getField(\"CompanyPrefix\").getOffset() + epc.getField(\"CompanyPrefix\").getBitLength(): epc.getField(\"AssetType\").getOffset() + epc.getField(\"AssetType\").getBitLength()]\n    assetTypeValue = str(int(assetTypeBits, 2)).zfill(epc.getField(\"AssetType\").getDigitLength())\n    self.assertEquals(str(assetTypeValue), str(self._assetType))\n    print(\"Bits and Hex are valid\"\n", "code_toks_joined": "def _checkBitsAndHex ( self , epc ) : <NEWLINE> <INDENT> bits = epc . toBinary ( ) <NEWLINE> hex = epc . toHex ( ) <NEWLINE> headerValue = bits [ epc . getField ( <STRING> ) . getOffset ( ) : epc . getField ( <STRING> ) . getBitLength ( ) ] <NEWLINE> self . assertEquals ( int ( headerValue , 2 ) , 51 ) <NEWLINE> headerValue = hex [ : 2 ] <NEWLINE> self . assertEquals ( int ( headerValue , 16 ) , 51 ) <NEWLINE> filterValue = bits [ epc . getField ( <STRING> ) . getOffset ( ) : int ( epc . getField ( <STRING> ) . getOffset ( ) ) + int ( epc . getField ( <STRING> ) . getBitLength ( ) ) ] <NEWLINE> self . assertEquals ( int ( filterValue , 2 ) , int ( self . _filter ) ) <NEWLINE> hexBodyBits = BitArray ( hex = hex ) . bin [ 2 : ] <NEWLINE> partitionValue = bits [ epc . getField ( <STRING> ) . getOffset ( ) : int ( epc . getField ( <STRING> ) . getOffset ( ) ) + int ( epc . getField ( <STRING> ) . getBitLength ( ) ) ] <NEWLINE> partitionValue = int ( partitionValue , 2 ) <NEWLINE> companyPrefixBits = hexBodyBits [ epc . getField ( <STRING> ) . getOffset ( ) : epc . getField ( <STRING> ) . getOffset ( ) + epc . getField ( <STRING> ) . getBitLength ( ) ] <NEWLINE> companyPrefixValue = BitArray ( bin = companyPrefixBits ) . uint <NEWLINE> self . assertEquals ( companyPrefixValue , int ( self . _companyPrefix ) ) <NEWLINE> epc . getField ( <STRING> ) . getBitLength ( ) <NEWLINE> assetTypeBits = hexBodyBits [ epc . getField ( <STRING> ) . getOffset ( ) + epc . getField ( <STRING> ) . getBitLength ( ) : epc . getField ( <STRING> ) . getOffset ( ) + epc . getField ( <STRING> ) . getBitLength ( ) ] <NEWLINE> assetTypeValue = str ( int ( assetTypeBits , 2 ) ) . zfill ( epc . getField ( <STRING> ) . getDigitLength ( ) ) <NEWLINE> self . assertEquals ( str ( assetTypeValue ) , str ( self . _assetType ) ) <NEWLINE> print ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Header\"", "\"Header\"", "\"Filter\"", "\"Filter\"", "\"Filter\"", "\"Partition\"", "\"Partition\"", "\"Partition\"", "\"CompanyPrefix\"", "\"CompanyPrefix\"", "\"CompanyPrefix\"", "\"CompanyPrefix\"", "\"CompanyPrefix\"", "\"CompanyPrefix\"", "\"AssetType\"", "\"AssetType\"", "\"AssetType\"", "\"Bits and Hex are valid\""]}, "window_span": [387, 391], "err_obj": {"msg": "unbalanced (){}[]"}}], ["e1a74d03b983cc8a30e8ef8f6dc2f7fe", {"code_string": "def p_courier(p):\n    '''courier : COURIER'''\n    if len(p) == 3:\n    p[0] = p[1] + p[2]\n    else:\n    p[0] = p[1]\n    parser_verbose(p)\n", "code_toks_joined": "def p_courier ( p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if len ( p ) == 3 : <NEWLINE> p [ 0 ] = p [ 1 ] + p [ 2 ] <NEWLINE> else : <NEWLINE> p [ 0 ] = p [ 1 ] <NEWLINE> parser_verbose ( p ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''courier : COURIER'''"]}, "err_obj": {"msg": "expected an indented block"}}], ["c50b65ad8a01091c5a99e94a52a75b80", {"code_string": "def test_invalid_mixing_encrypt_decrypt(self):\n    for method1_name, method2_name in((\"encrypt\", \"decrypt\"),\n        (\"decrypt\", \"encrypt\")):\n        for assoc_data_present in(True, False):\n        cipher = AES.new(self.key_128, AES.MODE_EAX,\n        nonce = self.nonce_96)\n        if assoc_data_present:\n        cipher.update(self.data_128)\n        getattr(cipher, method1_name)(self.data_128)\n        self.assertRaises(TypeError, getattr(cipher, method2_name),\n        self.data_128)\n", "code_toks_joined": "def test_invalid_mixing_encrypt_decrypt ( self ) : <NEWLINE> <INDENT> for method1_name , method2_name in ( ( <STRING> , <STRING> ) , <NEWLINE> <INDENT> ( <STRING> , <STRING> ) ) : <NEWLINE> for assoc_data_present in ( True , False ) : <NEWLINE> cipher = AES . new ( self . key_128 , AES . MODE_EAX , <NEWLINE> nonce = self . nonce_96 ) <NEWLINE> if assoc_data_present : <NEWLINE> cipher . update ( self . data_128 ) <NEWLINE> getattr ( cipher , method1_name ) ( self . data_128 ) <NEWLINE> self . assertRaises ( TypeError , getattr ( cipher , method2_name ) , <NEWLINE> self . data_128 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"encrypt\"", "\"decrypt\"", "\"decrypt\"", "\"encrypt\""]}, "err_obj": {"msg": "expected an indented block"}}], ["4ee2035b6796231a0cd6970cc59c3b8b", {"code_string": "import os\nimport sys\nimport site\nfrom peewee import *\nimport datetime\nreload(sys) sys.setdefaultencoding('utf8')\ndatabase = SqliteDatabase('/storage/extSdCard/english-notes-exercises.sqlite', **{})\n", "code_toks_joined": "import os <NEWLINE> import sys <NEWLINE> import site <NEWLINE> from peewee import * <NEWLINE> import datetime <NEWLINE> reload ( sys ) sys . setdefaultencoding ( <STRING> ) <NEWLINE> database = SqliteDatabase ( <STRING> , ** { } ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["'utf8'", "'/storage/extSdCard/english-notes-exercises.sqlite'"]}, "err_obj": {"msg": "invalid syntax"}}], ["9c488d02be58117feaa5a2688d5710b7", {"code_string": "def create(self, vals):\n    if(\n        'transmit_method_id' not in vals and\n        vals.get('type') and\n        vals.get('partner_id')):\n        partner = self.env['res.partner'].browse(vals['partner_id'])\n        if vals['type'] in('out_invoice', 'out_refund'):\n        vals['transmit_method_id'] = partner.customer_invoice_transmit_method_id.id or False\n        else:\n        vals['transmit_method_id'] = partner.supplier_invoice_transmit_method_id.id or False\n    return super(AccountInvoice, self).create(vals)\n", "code_toks_joined": "def create ( self , vals ) : <NEWLINE> <INDENT> if ( <NEWLINE> <INDENT> <STRING> not in vals and <NEWLINE> vals . get ( <STRING> ) and <NEWLINE> vals . get ( <STRING> ) ) : <NEWLINE> partner = self . env [ <STRING> ] . browse ( vals [ <STRING> ] ) <NEWLINE> if vals [ <STRING> ] in ( <STRING> , <STRING> ) : <NEWLINE> vals [ <STRING> ] = partner . customer_invoice_transmit_method_id . id or False <NEWLINE> else : <NEWLINE> vals [ <STRING> ] = partner . supplier_invoice_transmit_method_id . id or False <NEWLINE> <DEDENT> return super ( AccountInvoice , self ) . create ( vals ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'transmit_method_id'", "'type'", "'partner_id'", "'res.partner'", "'partner_id'", "'type'", "'out_invoice'", "'out_refund'", "'transmit_method_id'", "'transmit_method_id'"]}, "err_obj": {"msg": "expected an indented block"}}], ["d8369ad9cde505c97d1532456b5a2ab9", {"code_string": "class Ui_SelectionQueryWindow(object):\n    def setupUi(self, SelectionQueryWindow):\n        SelectionQueryWindow.setObjectName(_fromUtf8(\"SelectionQueryWindow\"))\n        SelectionQueryWindow.setWindowModality(QtCore.Qt.ApplicationModal)\n        SelectionQueryWindow.resize(500, 370)\n        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(SelectionQueryWindow.sizePolicy().hasHeightForWidth())\n        SelectionQueryWindow.setSizePolicy(sizePolicy)\n        SelectionQueryWindow.setMinimumSize(QtCore.QSize(500, 370))\n        SelectionQueryWindow.setMaximumSize(QtCore.QSize(500, 370))\n        icon = QtGui.QIcon()\n        icon.addPixmap(QtGui.QPixmap(_fromUtf8(\":/resources/icon_mmas.png\")), QtGui.QIcon.Normal, QtGui.QIcon.Off)\n        SelectionQueryWindow.setWindowIcon(icon)\n        self.centralWidget = QtGui.QWidget(SelectionQueryWindow)\n        self.centralWidget.setStyleSheet(_fromUtf8(\"QWidget {\\n\"\n", "code_toks_joined": "class Ui_SelectionQueryWindow ( object ) : <NEWLINE> <INDENT> def setupUi ( self , SelectionQueryWindow ) : <NEWLINE> <INDENT> SelectionQueryWindow . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> SelectionQueryWindow . setWindowModality ( QtCore . Qt . ApplicationModal ) <NEWLINE> SelectionQueryWindow . resize ( 500 , 370 ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Fixed , QtGui . QSizePolicy . Fixed ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( SelectionQueryWindow . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> SelectionQueryWindow . setSizePolicy ( sizePolicy ) <NEWLINE> SelectionQueryWindow . setMinimumSize ( QtCore . QSize ( 500 , 370 ) ) <NEWLINE> SelectionQueryWindow . setMaximumSize ( QtCore . QSize ( 500 , 370 ) ) <NEWLINE> icon = QtGui . QIcon ( ) <NEWLINE> icon . addPixmap ( QtGui . QPixmap ( _fromUtf8 ( <STRING> ) ) , QtGui . QIcon . Normal , QtGui . QIcon . Off ) <NEWLINE> SelectionQueryWindow . setWindowIcon ( icon ) <NEWLINE> self . centralWidget = QtGui . QWidget ( SelectionQueryWindow ) <NEWLINE> self . centralWidget . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"SelectionQueryWindow\"", "\":/resources/icon_mmas.png\"", "\"QWidget {\\n\""]}, "window_span": [189, 196], "err_obj": {"msg": "unbalanced (){}[]"}}], ["8744fe1937ba4e5991851eff249a606b", {"code_string": "def writeList(self, reg, list):\n    \"Writes an array of bytes using I2C format\"\n    try:\n        if self.debug:\n            print(\"I2C: Writing list to register 0x%02X:\" % reg)\n            print(list)\n        self.bus.write_i2c_block_data(self.address, reg, list)\n    except IOError, err:\n        return self.errMsg()\n", "code_toks_joined": "def writeList ( self , reg , list ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> if self . debug : <NEWLINE> <INDENT> print ( <STRING> % reg ) <NEWLINE> print ( list ) <NEWLINE> <DEDENT> self . bus . write_i2c_block_data ( self . address , reg , list ) <NEWLINE> <DEDENT> except IOError , err : <NEWLINE> <INDENT> return self . errMsg ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Writes an array of bytes using I2C format\"", "\"I2C: Writing list to register 0x%02X:\""]}, "err_obj": {"msg": "invalid syntax"}}], ["7ccc8a0d6da5f382a37cef333af3e204", {"code_string": "def enqueue(self, vals, name = None):\n    \"\"\"Enqueues one element to this queue.\"\"\"\n    with ops.op_scope(self._scope_vals(vals), name,\n        \"%s_enqueue\" % self._name) as scope:\n        vals = self._check_enqueue_dtypes(vals)\n        for val, shape in zip(vals, self._shapes):\n        val.get_shape().assert_is_compatible_with(shape)\n        return gen_data_flow_ops._queue_enqueue(self._queue_ref, vals, name = scope)\n", "code_toks_joined": "def enqueue ( self , vals , name = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with ops . op_scope ( self . _scope_vals ( vals ) , name , <NEWLINE> <INDENT> <STRING> % self . _name ) as scope : <NEWLINE> vals = self . _check_enqueue_dtypes ( vals ) <NEWLINE> for val , shape in zip ( vals , self . _shapes ) : <NEWLINE> val . get_shape ( ) . assert_is_compatible_with ( shape ) <NEWLINE> return gen_data_flow_ops . _queue_enqueue ( self . _queue_ref , vals , name = scope ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Enqueues one element to this queue.\"\"\"", "\"%s_enqueue\""]}, "err_obj": {"msg": "expected an indented block"}}], ["126a38011e854c99eac35141f9478f32", {"code_string": "def test_getParameterNames_php_function_doesnt_have_parameters(self):\n    functionName = \"aMemberFunctionWithoutParameters\"\n    fileDir = path.join(os.sep, \"MyProject1\", \"library\", \"aaeTest\", \"mvc\", \"ControllerTest.php\")\n    expected = []\n        obj = self._getInstance()\n        parameterNames = obj._getParameterNames(functionName, fileDir)\n        self.assertEqual(expected, parameterNames)\n", "code_toks_joined": "def test_getParameterNames_php_function_doesnt_have_parameters ( self ) : <NEWLINE> <INDENT> functionName = <STRING> <NEWLINE> fileDir = path . join ( os . sep , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> expected = [ ] <NEWLINE> <INDENT> obj = self . _getInstance ( ) <NEWLINE> parameterNames = obj . _getParameterNames ( functionName , fileDir ) <NEWLINE> self . assertEqual ( expected , parameterNames ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"aMemberFunctionWithoutParameters\"", "\"MyProject1\"", "\"library\"", "\"aaeTest\"", "\"mvc\"", "\"ControllerTest.php\""]}, "err_obj": {"msg": "unexpected indent"}}], ["998d5dd790df58f50842dbafd5ad82cb", {"code_string": "from django.http import QueryDict\nfrom django_facebook import settings as facebook_settings\ndef generate_oauth_url(scope = facebook_settings.FACEBOOK_DEFAULT_SCOPE,\n    next = None, extra_data = None):\n    query_dict = QueryDict('', True)\n    canvas_page = (next if next is not None else\n    facebook_settings.FACEBOOK_CANVAS_PAGE)\n    query_dict.update(dict(client_id = facebook_settings.FACEBOOK_APP_ID,\n        redirect_uri = canvas_page, scope = scope))\n        if extra_data:\n        query_dict.update(extra_data)\n        auth_url = 'http://www.facebook.com/dialog/oauth?%s' %(\n        query_dict.urlencode(), )\n        return auth_url\n", "code_toks_joined": "from django . http import QueryDict <NEWLINE> from django_facebook import settings as facebook_settings <NEWLINE> def generate_oauth_url ( scope = facebook_settings . FACEBOOK_DEFAULT_SCOPE , <NEWLINE> <INDENT> next = None , extra_data = None ) : <NEWLINE> query_dict = QueryDict ( <STRING> , True ) <NEWLINE> canvas_page = ( next if next is not None else <NEWLINE> facebook_settings . FACEBOOK_CANVAS_PAGE ) <NEWLINE> query_dict . update ( dict ( client_id = facebook_settings . FACEBOOK_APP_ID , <NEWLINE> <INDENT> redirect_uri = canvas_page , scope = scope ) ) <NEWLINE> if extra_data : <NEWLINE> query_dict . update ( extra_data ) <NEWLINE> auth_url = <STRING> % ( <NEWLINE> query_dict . urlencode ( ) , ) <NEWLINE> return auth_url <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "'http://www.facebook.com/dialog/oauth?%s'"]}, "err_obj": {"msg": "unexpected indent"}}], ["d6233c3a0363a24bfec77931020f0252", {"code_string": "def test_model_insert(self):\n    \"\"\" based on test_generate_model. Tests if a model can insert values\"\"\"\n    from{{appname}}.models.sql.pow_test_model import PowTestModel\n    m = PowTestModel()\n    m.name = \"Testname\"\n    assert isinstance(m, PowTestModel)\n", "code_toks_joined": "def test_model_insert ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> from { { appname } } . models . sql . pow_test_model import PowTestModel <NEWLINE> m = PowTestModel ( ) <NEWLINE> m . name = <STRING> <NEWLINE> assert isinstance ( m , PowTestModel ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" based on test_generate_model. Tests if a model can insert values\"\"\"", "\"Testname\""]}, "err_obj": {"msg": "invalid syntax"}}], ["a8603fe824e2938941cdab49e9463ed7", {"code_string": "class FirstCase(TestCase):\n    def test_1(self):\n    Spec = self.heapy.Spec\n    TestEnv = Spec.mkTestEnv(_Specification_)\n    TestEnv.test(self.guppy.heapy.AbstractAlgebra)\n", "code_toks_joined": "class FirstCase ( TestCase ) : <NEWLINE> <INDENT> def test_1 ( self ) : <NEWLINE> Spec = self . heapy . Spec <NEWLINE> TestEnv = Spec . mkTestEnv ( _Specification_ ) <NEWLINE> TestEnv . test ( self . guppy . heapy . AbstractAlgebra ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["fa582bffb229001624222612836c13d7", {"code_string": "def test_reenable_replication_fail_on_cinder_exception(self):\n    \"\"\"Test that reenable_replication fails on driver raising exception.\"\"\"\n    self.driver.do_setup(None)\n    replicated_volume = copy.deepcopy(REPLICATED_VOLUME)\n    replicated_volume['replication_status'] = 'invalid_status_val'\n    self.assertRaises(\n        exception.CinderException,\n        self.driver.reenable_replication\n        CONTEXT,\n        replicated_volume\n    )\n", "code_toks_joined": "def test_reenable_replication_fail_on_cinder_exception ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . driver . do_setup ( None ) <NEWLINE> replicated_volume = copy . deepcopy ( REPLICATED_VOLUME ) <NEWLINE> replicated_volume [ <STRING> ] = <STRING> <NEWLINE> self . assertRaises ( <NEWLINE> <INDENT> exception . CinderException , <NEWLINE> self . driver . reenable_replication <NEWLINE> CONTEXT , <NEWLINE> replicated_volume <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Test that reenable_replication fails on driver raising exception.\"\"\"", "'replication_status'", "'invalid_status_val'"]}, "err_obj": {"msg": "invalid syntax"}}], ["4b462a9a5c4c3ddccd5ef37b3aa77542", {"code_string": "def ListCompare(l1, l2):\n    if len(l1) is not len(l2):\n        return False\n    for i in range(len(l1))\n        if l1[i] is not l2[i]:\n            return False\n    return True\n", "code_toks_joined": "def ListCompare ( l1 , l2 ) : <NEWLINE> <INDENT> if len ( l1 ) is not len ( l2 ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for i in range ( len ( l1 ) ) <NEWLINE> <INDENT> if l1 [ i ] is not l2 [ i ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["a079552fd7c49132195e69c8f7811829", {"code_string": "class ZipNumpyUnpickler(NumpyUnpickler):\n    \"\"\"A subclass of our Unpickler to unpickle on the fly from\"\"\"\n    def __init__(self, filename, file_handle):\n        NumpyUnpickler.__init__(self, filename,\n            file_handle\n            mmap_mode = None)\n    def _open_pickle(self, file_handle):\n        return BytesIO(read_zfile(file_handle))\n", "code_toks_joined": "class ZipNumpyUnpickler ( NumpyUnpickler ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , filename , file_handle ) : <NEWLINE> <INDENT> NumpyUnpickler . __init__ ( self , filename , <NEWLINE> <INDENT> file_handle <NEWLINE> mmap_mode = None ) <NEWLINE> <DEDENT> <DEDENT> def _open_pickle ( self , file_handle ) : <NEWLINE> <INDENT> return BytesIO ( read_zfile ( file_handle ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"A subclass of our Unpickler to unpickle on the fly from\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["ba8cf1815394167d6f8ba26e32ba4cc6", {"code_string": "def __init__(self):\n    super(RecordingDatePlugin, self).__init__()\n    for recording_field in(\n        u'recording_year',\n        u'recording_month',\n        u'recording_day',\n        u'recording_disambiguation'):\n        field = mediafile.MediaField(\n            mediafile.MP3DescStorageStyle(recording_field),\n            mediafile.MP4StorageStyle('----:com.apple.iTunes:{}'.format(\n                recording_field)),\n            mediafile.StorageStyle(recording_field))\n            self.add_media_field(recording_field, field)\n", "code_toks_joined": "def __init__ ( self ) : <NEWLINE> <INDENT> super ( RecordingDatePlugin , self ) . __init__ ( ) <NEWLINE> for recording_field in ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ) : <NEWLINE> field = mediafile . MediaField ( <NEWLINE> <INDENT> mediafile . MP3DescStorageStyle ( recording_field ) , <NEWLINE> mediafile . MP4StorageStyle ( <STRING> . format ( <NEWLINE> <INDENT> recording_field ) ) , <NEWLINE> <DEDENT> mediafile . StorageStyle ( recording_field ) ) <NEWLINE> self . add_media_field ( recording_field , field ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["u'recording_year'", "u'recording_month'", "u'recording_day'", "u'recording_disambiguation'", "'----:com.apple.iTunes:{}'"]}, "err_obj": {"msg": "unexpected indent"}}], ["a9b6f82d48d566f4ede1f52d6e66324b", {"code_string": "def test_var7(self):\n    self.top.oneout.ratio2 = 20\n    try:\n        self.top.connect('oneout.ratio2', 'oneinp.ratio3')\n    except Exception, err:\n        msg = \": Can't connect 'oneout.ratio2' to 'oneinp.ratio3': : \" + \"The 'ratio3' trait of an Oneinp instance must be a\" \" boolean, but a value of 20 <type 'int'> was specified.\"\n        self.assertEqual(str(err), msg)\n    else:\n        self.fail('Exception Expected')\n", "code_toks_joined": "def test_var7 ( self ) : <NEWLINE> <INDENT> self . top . oneout . ratio2 = 20 <NEWLINE> try : <NEWLINE> <INDENT> self . top . connect ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> except Exception , err : <NEWLINE> <INDENT> msg = <STRING> + <STRING> <STRING> <NEWLINE> self . assertEqual ( str ( err ) , msg ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . fail ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'oneout.ratio2'", "'oneinp.ratio3'", "\": Can't connect 'oneout.ratio2' to 'oneinp.ratio3': : \"", "\"The 'ratio3' trait of an Oneinp instance must be a\"", "\" boolean, but a value of 20 <type 'int'> was specified.\"", "'Exception Expected'"]}, "err_obj": {"msg": "invalid syntax"}}], ["a9f2f0c994045554a9b607c49c63e665", {"code_string": "import geo_utils\nfrom fiona import collection\nfrom shapely import wkt, geometry\nimport csv\nimport os\n\"\"\"Create new shapefiles using Shapely and Fiona\"\"\"\ncsv.field_size_limit(500 * 1024 * 1024)\ntown = {}\nshapes = {}\nwith open(\"ltgeom.csv\", 'r') as f:\n    reader = csv.DictReader(f)\n    for row in reader:\n        geom = row['geom']\n        id = row['FID']\n        t_name = row['name']\n        t_males = row['male2011']\n        t_females = row['female2011']\n        t_total = t_females + t_males\n        town[id] = (t_name, geometry.MultiPolygon(wkt.loads(geom)), t_females, t_males, t_total)\npath = r\"C:\\Users\\admin\\Google Drive\\College\\RepositoryDataDump\\IrelandShapeFiles\"\nwith collection(os.path.join(path, 'natural.shp'), 'r') as ip:\n    with collection('rivers.shp', 'w') as op:\n        for feature in ip:\n            if(feature['properties']['type']) == \"water\":\n                output.write({feature['properties']['name']: }, 'geometry': mapping(shape)})\n", "code_toks_joined": "import geo_utils <NEWLINE> from fiona import collection <NEWLINE> from shapely import wkt , geometry <NEWLINE> import csv <NEWLINE> import os <NEWLINE> <STRING> <NEWLINE> csv . field_size_limit ( 500 * 1024 * 1024 ) <NEWLINE> town = { } <NEWLINE> shapes = { } <NEWLINE> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> reader = csv . DictReader ( f ) <NEWLINE> for row in reader : <NEWLINE> <INDENT> geom = row [ <STRING> ] <NEWLINE> id = row [ <STRING> ] <NEWLINE> t_name = row [ <STRING> ] <NEWLINE> t_males = row [ <STRING> ] <NEWLINE> t_females = row [ <STRING> ] <NEWLINE> t_total = t_females + t_males <NEWLINE> town [ id ] = ( t_name , geometry . MultiPolygon ( wkt . loads ( geom ) ) , t_females , t_males , t_total ) <NEWLINE> <DEDENT> <DEDENT> path = <STRING> <NEWLINE> with collection ( os . path . join ( path , <STRING> ) , <STRING> ) as ip : <NEWLINE> <INDENT> with collection ( <STRING> , <STRING> ) as op : <NEWLINE> <INDENT> for feature in ip : <NEWLINE> <INDENT> if ( feature [ <STRING> ] [ <STRING> ] ) == <STRING> : <NEWLINE> <INDENT> output . write ( { feature [ <STRING> ] [ <STRING> ] : } , <STRING> : mapping ( shape ) } ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Create new shapefiles using Shapely and Fiona\"\"\"", "\"ltgeom.csv\"", "'r'", "'geom'", "'FID'", "'name'", "'male2011'", "'female2011'", "r\"C:\\Users\\admin\\Google Drive\\College\\RepositoryDataDump\\IrelandShapeFiles\"", "'natural.shp'", "'r'", "'rivers.shp'", "'w'", "'properties'", "'type'", "\"water\"", "'properties'", "'name'", "'geometry'"]}, "window_span": [200, 225], "err_obj": {"msg": "unbalanced (){}[]"}}], ["434622439b995744d008078043e180d7", {"code_string": "def split_unidirectional_migration(params, (n1, n2), pts):\n    nuW, nuC, T, m12 = params\n    xx = Numerics.default_grid(pts)\n    phi = PhiManip.phi_1D(xx)\n    phi = PhiManip.phi_1D_to_2D(xx, phi)\n    phi = Integration.two_pops(phi, xx, T, nuW, nuC, m12 = m12)\n    model_sfs = Spectrum.from_phi(phi, (n1, n2), (xx, xx))\n    return model_sfs\n", "code_toks_joined": "def split_unidirectional_migration ( params , ( n1 , n2 ) , pts ) : <NEWLINE> <INDENT> nuW , nuC , T , m12 = params <NEWLINE> xx = Numerics . default_grid ( pts ) <NEWLINE> phi = PhiManip . phi_1D ( xx ) <NEWLINE> phi = PhiManip . phi_1D_to_2D ( xx , phi ) <NEWLINE> phi = Integration . two_pops ( phi , xx , T , nuW , nuC , m12 = m12 ) <NEWLINE> model_sfs = Spectrum . from_phi ( phi , ( n1 , n2 ) , ( xx , xx ) ) <NEWLINE> return model_sfs <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["649f552e4161734c92cbd71e92e4be52", {"code_string": "def generate_strongly_correlated(profits, delta):\n    weights = []\n    max_profit = max(profits)\n    for i in range(len(profits)):\n    weights.append(profits[i] + max_profit / delta)\n    return weights\n", "code_toks_joined": "def generate_strongly_correlated ( profits , delta ) : <NEWLINE> <INDENT> weights = [ ] <NEWLINE> max_profit = max ( profits ) <NEWLINE> for i in range ( len ( profits ) ) : <NEWLINE> weights . append ( profits [ i ] + max_profit / delta ) <NEWLINE> return weights <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["e8a25d82b03f5d07719e84d710839cd4", {"code_string": "def install_default_probe(self, session):\n    \"\"\"Installs the default probe bundles (doesn't enable it)\"\"\"\n    for bundle in(\"herald.probe.core\", \"herald.probe.store_log\",\n        \"herald.probe.store_sqlite\"):\n        try:\n        self._context.install_bundle(bundle).start()\n        except pelix.constants.BundleException as ex:\n        session.write_line(\"Error installing {0}: {1}\", bundle, ex)\n    with use_ipopo(self._context) as ipopo:\n        ipopo.instantiate(\n            'herald-probe-log-factory', 'herald-probe-log',\n            {'logger.prefix': 'herald.debug'})\n        ipopo.instantiate(\n            'herald-probe-sqlite-factory', 'herald-probe-sqlite',\n            {'db.file': 'herald_probe.db'})\n", "code_toks_joined": "def install_default_probe ( self , session ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for bundle in ( <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> try : <NEWLINE> self . _context . install_bundle ( bundle ) . start ( ) <NEWLINE> except pelix . constants . BundleException as ex : <NEWLINE> session . write_line ( <STRING> , bundle , ex ) <NEWLINE> <DEDENT> with use_ipopo ( self . _context ) as ipopo : <NEWLINE> <INDENT> ipopo . instantiate ( <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> { <STRING> : <STRING> } ) <NEWLINE> <DEDENT> ipopo . instantiate ( <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> { <STRING> : <STRING> } ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Installs the default probe bundles (doesn't enable it)\"\"\"", "\"herald.probe.core\"", "\"herald.probe.store_log\"", "\"herald.probe.store_sqlite\"", "\"Error installing {0}: {1}\"", "'herald-probe-log-factory'", "'herald-probe-log'", "'logger.prefix'", "'herald.debug'", "'herald-probe-sqlite-factory'", "'herald-probe-sqlite'", "'db.file'", "'herald_probe.db'"]}, "err_obj": {"msg": "expected an indented block"}}], ["e3d8146436e2ab8ab8941544aa0e46fc", {"code_string": "def render_user_profile__menu(self, h, comp, * args):\n    return h.ul(\n        h.li(\n            h.a(\n                entry.label\n                class_ = (\n                    'active {}'.format(id_)\n                    if id_ == self.selected\n                    else id_\n                )\n            ).action(self._on_menu_entry, id_)\n        )\n        for id_, entry in self.menu.iteritems()\n    )\n", "code_toks_joined": "def render_user_profile__menu ( self , h , comp , * args ) : <NEWLINE> <INDENT> return h . ul ( <NEWLINE> <INDENT> h . li ( <NEWLINE> <INDENT> h . a ( <NEWLINE> <INDENT> entry . label <NEWLINE> class_ = ( <NEWLINE> <INDENT> <STRING> . format ( id_ ) <NEWLINE> if id_ == self . selected <NEWLINE> else id_ <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> ) . action ( self . _on_menu_entry , id_ ) <NEWLINE> <DEDENT> ) <NEWLINE> for id_ , entry in self . menu . iteritems ( ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'active {}'"]}, "err_obj": {"msg": "invalid syntax"}}], ["678b9366d7df85ac214a3563f61f8a08", {"code_string": "class ComponentData:\n    def __init__(self, componentID, elementID):\n    self.CadType = \"\"\n    self.CadName = \"\"\n    self.FEAElementType = \"\"\n    self.MaterialID = \"\"\n    self.ComponentID = componentID\n    self.ElementID = elementID\n    self.FEAResults = dict()\n    self.Parts = []\n", "code_toks_joined": "class ComponentData : <NEWLINE> <INDENT> def __init__ ( self , componentID , elementID ) : <NEWLINE> self . CadType = <STRING> <NEWLINE> self . CadName = <STRING> <NEWLINE> self . FEAElementType = <STRING> <NEWLINE> self . MaterialID = <STRING> <NEWLINE> self . ComponentID = componentID <NEWLINE> self . ElementID = elementID <NEWLINE> self . FEAResults = dict ( ) <NEWLINE> self . Parts = [ ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"", "\"\"", "\"\"", "\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["b04a8556ec06ef04d902586cd98f3f2b", {"code_string": "def setupUi(self, Form):\n    Form.setObjectName(_fromUtf8(\"Form\"))\n    Form.resize(753, 547)\n    Form.setWindowTitle(_(\"Form\"))\n    self.gridLayout = QtGui.QGridLayout(Form)\n    self.gridLayout.setObjectName(_fromUtf8(\"gridLayout\"))\n    self.tabWidget = QtGui.QTabWidget(Form)\n    self.tabWidget.setObjectName(_fromUtf8(\"tabWidget\"))\n    self.tab_3 = QtGui.QWidget()\n    self.tab_3.setObjectName(_fromUtf8(\"tab_3\"))\n    self.gridLayout_2 = QtGui.QGridLayout(self.tab_3)\n    self.gridLayout_2.setObjectName(_fromUtf8(\"gridLayout_2\"))\n    self.label_6 = QtGui.QLabel(self.tab_3)\n    self.label_6.setText(_(\"Here you can control how calibre will read metadata from the files you add to it. calibre can either read metadata from the contents of the file, or from the filename.\"))\n    self.label_6.setWordWrap(True)\n    self.label_6.setObjectName(_fromUtf8(\"label_6\"))\n    self.gridLayout_2.addWidget(self.label_6, 0, 0, 1, 3)\n    self.opt_read_file_metadata = QtGui.QCheckBox(self.tab_3)\n    self.opt_read_file_metadata.setText(_(\"Read &metadata from file contents rather than file name\"))\n    self.opt_read_file_metadata.setObjectName(_fromUtf8(\"opt_read_file_metadata\"))\n    self.gridLayout_2.addWidget(self.opt_read_file_metadata, 1, 0, 1, 1)\n    self.horizontalLayout = QtGui.QHBoxLayout()\n    self.horizontalLayout.setObjectName(_fromUtf8(\"horizontalLayout\"))\n    spacerItem = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)\n    self.horizontalLayout.addItem(spacerItem)\n    self.opt_swap_author_names = QtGui.QCheckBox(self.tab_3)\n    self.opt_swap_author_names.setToolTip(_(\"Swap the firstname and lastname of the author. This affects only metadata read from file names.\"))\n    self.opt_swap_author_names.setText(_(\"&Swap author firstname and lastname\"))\n    self.opt_swap_author_names.setObjectName(_fromUtf8(\"opt_swap_author_names\"))\n    self.horizontalLayout.addWidget(self.opt_swap_author_names)\n    self.gridLayout_2.addLayout(self.horizontalLayout, 1, 1, 1, 2)\n    self.opt_preserve_date_on_ctl = QtGui.QCheckBox(self.tab_3)\n    self.opt_preserve_date_on_ctl.setText(_(\"When using the  \\\"&Copy to library\\\" action to copy books between libraries, preserve the date\"))\n    self.opt_preserve_date_on_ctl.setObjectName(_fromUtf8(\"opt_preserve_date_on_ctl\"))\n    self.gridLayout_2.addWidget(self.opt_preserve_date_on_ctl, 2, 0, 1, 3)\n    self.opt_add_formats_to_existing = QtGui.QCheckBox(self.tab_3)\n    self.opt_add_formats_to_existing.setToolTip(_(\"Automerge: If books with similar titles and authors found, merge the incoming formats automatically into\\n\"\n", "code_toks_joined": "def setupUi ( self , Form ) : <NEWLINE> <INDENT> Form . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> Form . resize ( 753 , 547 ) <NEWLINE> Form . setWindowTitle ( _ ( <STRING> ) ) <NEWLINE> self . gridLayout = QtGui . QGridLayout ( Form ) <NEWLINE> self . gridLayout . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . tabWidget = QtGui . QTabWidget ( Form ) <NEWLINE> self . tabWidget . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . tab_3 = QtGui . QWidget ( ) <NEWLINE> self . tab_3 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_2 = QtGui . QGridLayout ( self . tab_3 ) <NEWLINE> self . gridLayout_2 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . label_6 = QtGui . QLabel ( self . tab_3 ) <NEWLINE> self . label_6 . setText ( _ ( <STRING> ) ) <NEWLINE> self . label_6 . setWordWrap ( True ) <NEWLINE> self . label_6 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_2 . addWidget ( self . label_6 , 0 , 0 , 1 , 3 ) <NEWLINE> self . opt_read_file_metadata = QtGui . QCheckBox ( self . tab_3 ) <NEWLINE> self . opt_read_file_metadata . setText ( _ ( <STRING> ) ) <NEWLINE> self . opt_read_file_metadata . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_2 . addWidget ( self . opt_read_file_metadata , 1 , 0 , 1 , 1 ) <NEWLINE> self . horizontalLayout = QtGui . QHBoxLayout ( ) <NEWLINE> self . horizontalLayout . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> spacerItem = QtGui . QSpacerItem ( 40 , 20 , QtGui . QSizePolicy . Expanding , QtGui . QSizePolicy . Minimum ) <NEWLINE> self . horizontalLayout . addItem ( spacerItem ) <NEWLINE> self . opt_swap_author_names = QtGui . QCheckBox ( self . tab_3 ) <NEWLINE> self . opt_swap_author_names . setToolTip ( _ ( <STRING> ) ) <NEWLINE> self . opt_swap_author_names . setText ( _ ( <STRING> ) ) <NEWLINE> self . opt_swap_author_names . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . horizontalLayout . addWidget ( self . opt_swap_author_names ) <NEWLINE> self . gridLayout_2 . addLayout ( self . horizontalLayout , 1 , 1 , 1 , 2 ) <NEWLINE> self . opt_preserve_date_on_ctl = QtGui . QCheckBox ( self . tab_3 ) <NEWLINE> self . opt_preserve_date_on_ctl . setText ( _ ( <STRING> ) ) <NEWLINE> self . opt_preserve_date_on_ctl . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_2 . addWidget ( self . opt_preserve_date_on_ctl , 2 , 0 , 1 , 3 ) <NEWLINE> self . opt_add_formats_to_existing = QtGui . QCheckBox ( self . tab_3 ) <NEWLINE> self . opt_add_formats_to_existing . setToolTip ( _ ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Form\"", "\"Form\"", "\"gridLayout\"", "\"tabWidget\"", "\"tab_3\"", "\"gridLayout_2\"", "\"Here you can control how calibre will read metadata from the files you add to it. calibre can either read metadata from the contents of the file, or from the filename.\"", "\"label_6\"", "\"Read &metadata from file contents rather than file name\"", "\"opt_read_file_metadata\"", "\"horizontalLayout\"", "\"Swap the firstname and lastname of the author. This affects only metadata read from file names.\"", "\"&Swap author firstname and lastname\"", "\"opt_swap_author_names\"", "\"When using the  \\\"&Copy to library\\\" action to copy books between libraries, preserve the date\"", "\"opt_preserve_date_on_ctl\"", "\"Automerge: If books with similar titles and authors found, merge the incoming formats automatically into\\n\""]}, "window_span": [460, 466], "err_obj": {"msg": "unbalanced (){}[]"}}], ["afb05303bf2937b2886ddc9c37accb91", {"code_string": "class Treenode(object):\n    def __init__(self):\n    def __repr__(self):\n        return \"<Treenode('%s')>\" %(self.id)\n", "code_toks_joined": "class Treenode ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> def __repr__ ( self ) : <NEWLINE> <INDENT> return <STRING> % ( self . id ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"<Treenode('%s')>\""]}, "err_obj": {"msg": "expected an indented block"}}], ["4c3859327b0b85a194b0e9dcf9ad7a86", {"code_string": "def digitSum(n):\n    arr = []\n    for i in range(10):\n        arr[i] = n % 10\n        n = n // 10\n    sum = 0\n    for i in range(10)\n        sum += arr[i]\n    return sum\n", "code_toks_joined": "def digitSum ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> arr [ i ] = n % 10 <NEWLINE> n = n // 10 <NEWLINE> <DEDENT> sum = 0 <NEWLINE> for i in range ( 10 ) <NEWLINE> <INDENT> sum += arr [ i ] <NEWLINE> <DEDENT> return sum <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["0a3c95c5af7ac1af23586e63522ce657", {"code_string": "def test_get_assigned_devices_info_multiple_slots(self, * args):\n    emb_switch = esm.EmbSwitch(self.PHYS_NET, self.DEV_NAME, ())\n    with mock.patch(\"neutron.plugins.ml2.drivers.mech_sriov.agent.pci_lib.\"\n        \"PciDeviceIPWrapper.get_assigned_macs\",\n        return_value = self.VF_TO_MAC_MAPPING), mock.patch(\"neutron.plugins.ml2.drivers.mech_sriov.agent.\"\n            \"eswitch_manager.PciOsWrapper.is_assigned_vf\",\n            return_value = True):\n            devices_info = emb_switch.get_assigned_devices_info()\n            for device_info in devices_info:\n            mac = device_info[0]\n            pci_slot = device_info[1]\n            self.assertEqual(\n            self.EXPECTED_MAC_TO_PCI[mac], pci_slot)\n", "code_toks_joined": "def test_get_assigned_devices_info_multiple_slots ( self , * args ) : <NEWLINE> <INDENT> emb_switch = esm . EmbSwitch ( self . PHYS_NET , self . DEV_NAME , ( ) ) <NEWLINE> with mock . patch ( <STRING> <NEWLINE> <INDENT> <STRING> , <NEWLINE> return_value = self . VF_TO_MAC_MAPPING ) , mock . patch ( <STRING> <NEWLINE> <INDENT> <STRING> , <NEWLINE> return_value = True ) : <NEWLINE> devices_info = emb_switch . get_assigned_devices_info ( ) <NEWLINE> for device_info in devices_info : <NEWLINE> mac = device_info [ 0 ] <NEWLINE> pci_slot = device_info [ 1 ] <NEWLINE> self . assertEqual ( <NEWLINE> self . EXPECTED_MAC_TO_PCI [ mac ] , pci_slot ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"neutron.plugins.ml2.drivers.mech_sriov.agent.pci_lib.\"", "\"PciDeviceIPWrapper.get_assigned_macs\"", "\"neutron.plugins.ml2.drivers.mech_sriov.agent.\"", "\"eswitch_manager.PciOsWrapper.is_assigned_vf\""]}, "err_obj": {"msg": "expected an indented block"}}], ["a9ce93c50ab993d72d2be8898e7acae2", {"code_string": "def forwards(self, orm):\n    \"Write your forwards migration here\"\n    for channel in orm.Channel.objects.all():\n        for field in('owner', 'featured_by', 'moderator_shared_by',\n            'last_moderated_by'):\n            value = getattr(channel, '%s_id' % field)\n            if value:\n            profile = orm['user_profile.UserProfile'].objects.get(\n            pk = value)\n            setattr(channel, field, profile.user)\n            else:\n            setattr(channel, field, None)\n        channel.save()\n", "code_toks_joined": "def forwards ( self , orm ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for channel in orm . Channel . objects . all ( ) : <NEWLINE> <INDENT> for field in ( <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> value = getattr ( channel , <STRING> % field ) <NEWLINE> if value : <NEWLINE> profile = orm [ <STRING> ] . objects . get ( <NEWLINE> pk = value ) <NEWLINE> setattr ( channel , field , profile . user ) <NEWLINE> else : <NEWLINE> setattr ( channel , field , None ) <NEWLINE> <DEDENT> channel . save ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Write your forwards migration here\"", "'owner'", "'featured_by'", "'moderator_shared_by'", "'last_moderated_by'", "'%s_id'", "'user_profile.UserProfile'"]}, "err_obj": {"msg": "expected an indented block"}}], ["629376607d989c1109283588245707ce", {"code_string": "def launchHyperlinkButton(exe = None):\n    '''Launch Moonlight HyperlinkButton with accessibility enabled and return a'''\n    if exe is None:\n        exe = '%s/samples/moonlight/HyperlinkButton/HyperlinkButtonSample.html' % uiaqa_path\n        if not exists(exe):\n            raise IOError, \"Could not find file %s\" % exe\n    args = [firefox_path, exe]\n    (app, subproc) = cache.launchApplication(args = args, name = \"Firefox\", wait = config.LONG_DELAY)\n    hyperlinkbutton = HyperlinkButton(app, subproc)\n    cache.addApplication(hyperlinkbutton)\n    hyperlinkbutton.hyperlinkButtonFrame.app = hyperlinkbutton\n    return hyperlinkbutton\n", "code_toks_joined": "def launchHyperlinkButton ( exe = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if exe is None : <NEWLINE> <INDENT> exe = <STRING> % uiaqa_path <NEWLINE> if not exists ( exe ) : <NEWLINE> <INDENT> raise IOError , <STRING> % exe <NEWLINE> <DEDENT> <DEDENT> args = [ firefox_path , exe ] <NEWLINE> ( app , subproc ) = cache . launchApplication ( args = args , name = <STRING> , wait = config . LONG_DELAY ) <NEWLINE> hyperlinkbutton = HyperlinkButton ( app , subproc ) <NEWLINE> cache . addApplication ( hyperlinkbutton ) <NEWLINE> hyperlinkbutton . hyperlinkButtonFrame . app = hyperlinkbutton <NEWLINE> return hyperlinkbutton <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Launch Moonlight HyperlinkButton with accessibility enabled and return a'''", "'%s/samples/moonlight/HyperlinkButton/HyperlinkButtonSample.html'", "\"Could not find file %s\"", "\"Firefox\""]}, "err_obj": {"msg": "invalid syntax"}}], ["a43b2a5646f96d1e36a74bd5eb3223c1", {"code_string": "class ForExpr(object):\n    varInExprs = []\n    def __init__(self, tokens):\n        i = 1\n        while(i < len(tokens):\n            self.varInExprs.append(VarInExpr(tokens[i], tokens[i + 2]))\n            i += 4\n    def __repr__(self):\n        return 'ForExpr ' + str(self.varInExprs)\n", "code_toks_joined": "class ForExpr ( object ) : <NEWLINE> <INDENT> varInExprs = [ ] <NEWLINE> def __init__ ( self , tokens ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> while ( i < len ( tokens ) : <NEWLINE> <INDENT> self . varInExprs . append ( VarInExpr ( tokens [ i ] , tokens [ i + 2 ] ) ) <NEWLINE> i += 4 <NEWLINE> <DEDENT> <DEDENT> def __repr__ ( self ) : <NEWLINE> <INDENT> return <STRING> + str ( self . varInExprs ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'ForExpr '"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c6775265cf5a19952f78d1cd636b2c3d", {"code_string": "def combine_deltas(self, (share_count1, share_hashes1), (share_count2, share_hashes2)):\n    if share_hashes1 & share_hashes2:\n        raise AssertionError()\n    return share_count1 + share_count2, share_hashes1 | share_hashes2\n", "code_toks_joined": "def combine_deltas ( self , ( share_count1 , share_hashes1 ) , ( share_count2 , share_hashes2 ) ) : <NEWLINE> <INDENT> if share_hashes1 & share_hashes2 : <NEWLINE> <INDENT> raise AssertionError ( ) <NEWLINE> <DEDENT> return share_count1 + share_count2 , share_hashes1 | share_hashes2 <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["da40af71b1de995fd1638a4ef977e659", {"code_string": "def retrieve_list(self):\n    if Blocked.select().count() > 0:\n        l = Blocked.select()\n        else:\n        l = None\n    return l\n", "code_toks_joined": "def retrieve_list ( self ) : <NEWLINE> <INDENT> if Blocked . select ( ) . count ( ) > 0 : <NEWLINE> <INDENT> l = Blocked . select ( ) <NEWLINE> else : <NEWLINE> l = None <NEWLINE> <DEDENT> return l <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["635d1711e34ad597124c1e881a97e95d", {"code_string": "def test_module_retrieve(self):\n    with mock.patch.object(troveclient.v1.modules.Module, '__getattr__',\n        mock.Mock(return_value = '4321')):\n        with mock.patch.object(builtins, 'open'):\n        self.run_command('module-retrieve 1234')\n        self.assert_called(\n        'GET',\n        '/instances/1234/modules?'\n        'include_contents=True&from_guest=True')\n", "code_toks_joined": "def test_module_retrieve ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( troveclient . v1 . modules . Module , <STRING> , <NEWLINE> <INDENT> mock . Mock ( return_value = <STRING> ) ) : <NEWLINE> with mock . patch . object ( builtins , <STRING> ) : <NEWLINE> self . run_command ( <STRING> ) <NEWLINE> self . assert_called ( <NEWLINE> <STRING> , <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'__getattr__'", "'4321'", "'open'", "'module-retrieve 1234'", "'GET'", "'/instances/1234/modules?'", "'include_contents=True&from_guest=True'"]}, "err_obj": {"msg": "expected an indented block"}}], ["ed2edebd1f8d4b0651a381ed8afeb314", {"code_string": "def read(self, nbytes = 0):\n    if not self.buf:\n        if self.__next() is None:\n        return ''\n    if nbytes:\n        e = self.buf[: nbytes]\n        self.buf = self.buf[nbytes: ]\n        return e\n    else:\n        e = self.buf\n        self.buf = ''\n        return e\n", "code_toks_joined": "def read ( self , nbytes = 0 ) : <NEWLINE> <INDENT> if not self . buf : <NEWLINE> <INDENT> if self . __next ( ) is None : <NEWLINE> return <STRING> <NEWLINE> <DEDENT> if nbytes : <NEWLINE> <INDENT> e = self . buf [ : nbytes ] <NEWLINE> self . buf = self . buf [ nbytes : ] <NEWLINE> return e <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e = self . buf <NEWLINE> self . buf = <STRING> <NEWLINE> return e <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "''"]}, "err_obj": {"msg": "expected an indented block"}}], ["aace4836e24e77a6501ccd0b401f9f16", {"code_string": "def get_ids(client, what):\n    \"\"\"Get all pages of friends or followers IDs and add them to a list.\"\"\"\n    page = 0\n    cursor = - 1\n    idlist = []\n    while True:\n    page += 1\n    print(\"Getting %s page %d...\" %(what, page))\n    result = twlib.twitter_retry(client, 'get',\n    path = '/1.1/%s/ids.json' % what,\n    params = {\"cursor\": str(cursor)})\n    jsn = twlib.parse_json(result)\n    cursor = jsn['next_cursor']\n    idlist += jsn['ids']\n    if cursor == 0:\n        break\n        time.sleep(1)\n    return idlist\n", "code_toks_joined": "def get_ids ( client , what ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> page = 0 <NEWLINE> cursor = - 1 <NEWLINE> idlist = [ ] <NEWLINE> while True : <NEWLINE> page += 1 <NEWLINE> print ( <STRING> % ( what , page ) ) <NEWLINE> result = twlib . twitter_retry ( client , <STRING> , <NEWLINE> path = <STRING> % what , <NEWLINE> params = { <STRING> : str ( cursor ) } ) <NEWLINE> jsn = twlib . parse_json ( result ) <NEWLINE> cursor = jsn [ <STRING> ] <NEWLINE> idlist += jsn [ <STRING> ] <NEWLINE> if cursor == 0 : <NEWLINE> <INDENT> break <NEWLINE> time . sleep ( 1 ) <NEWLINE> <DEDENT> return idlist <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get all pages of friends or followers IDs and add them to a list.\"\"\"", "\"Getting %s page %d...\"", "'get'", "'/1.1/%s/ids.json'", "\"cursor\"", "'next_cursor'", "'ids'"]}, "err_obj": {"msg": "expected an indented block"}}], ["562ee2eafdac820b41936db44a71581a", {"code_string": "class ClientDispatcher(asyncore.dispatcher_with_send):\n    def __init__(self, (sock, addr)):\n        asyncore.dispatcher_with_send.__init__(self, sock)\n        self.addr = addr\n    def handle_read(self):\n        data = self.recv(1024)\n", "code_toks_joined": "class ClientDispatcher ( asyncore . dispatcher_with_send ) : <NEWLINE> <INDENT> def __init__ ( self , ( sock , addr ) ) : <NEWLINE> <INDENT> asyncore . dispatcher_with_send . __init__ ( self , sock ) <NEWLINE> self . addr = addr <NEWLINE> <DEDENT> def handle_read ( self ) : <NEWLINE> <INDENT> data = self . recv ( 1024 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["98e3ac73a296b78167431953e1359a3f", {"code_string": "def feed(self, data):\n    self._result = u''\n    self._openelems = []\n    data = '<div>' + data + '</div>'\n    data = data.replace('&', '&amp;')\n    data = iqeq_re.sub(to_html_minus, data)\n        self._parser.Parse(data, 0)\n", "code_toks_joined": "def feed ( self , data ) : <NEWLINE> <INDENT> self . _result = <STRING> <NEWLINE> self . _openelems = [ ] <NEWLINE> data = <STRING> + data + <STRING> <NEWLINE> data = data . replace ( <STRING> , <STRING> ) <NEWLINE> data = iqeq_re . sub ( to_html_minus , data ) <NEWLINE> <INDENT> self . _parser . Parse ( data , 0 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["u''", "'<div>'", "'</div>'", "'&'", "'&amp;'"]}, "err_obj": {"msg": "unexpected indent"}}], ["1e7b0d86607721dd59a50efd9a85e05f", {"code_string": "def db_create(data_path):\n    import sqlite3 as sql\n    conn = sql.connect(data_path)\n    obj = conn.cursor()\n    try:\n        obj.executescript(\"\"\"CREATE TABLE IF NOT EXISTS parsing (echo TEXT, time_local REAL, http_host TEXT, cache_status TEXT, request_time REAL, src_addr TEXT, dst_addr TEXT, type_request TEXT, request BINARY, proto TEXT, status INTEGER, body_size TEXT, referer TEXT, user_agent TEXT, row_string TXT);\"\"\")\n    except sqlite.DatabaseError, err:\n        print(u\"Error:\", err)\n    else:\n        print(u\"Question is comleted\")\n    conn.commit()\n    conn.close()\n", "code_toks_joined": "def db_create ( data_path ) : <NEWLINE> <INDENT> import sqlite3 as sql <NEWLINE> conn = sql . connect ( data_path ) <NEWLINE> obj = conn . cursor ( ) <NEWLINE> try : <NEWLINE> <INDENT> obj . executescript ( <STRING> ) <NEWLINE> <DEDENT> except sqlite . DatabaseError , err : <NEWLINE> <INDENT> print ( <STRING> , err ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> conn . commit ( ) <NEWLINE> conn . close ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"CREATE TABLE IF NOT EXISTS parsing (echo TEXT, time_local REAL, http_host TEXT, cache_status TEXT, request_time REAL, src_addr TEXT, dst_addr TEXT, type_request TEXT, request BINARY, proto TEXT, status INTEGER, body_size TEXT, referer TEXT, user_agent TEXT, row_string TXT);\"\"\"", "u\"Error:\"", "u\"Question is comleted\""]}, "err_obj": {"msg": "invalid syntax"}}], ["c3af57af39625aa696328bad77957c57", {"code_string": "def generate_security_groups_for_given_count(user, count):\n    print\n    print(\"=== GENERATE SECURITY GROUPS AS USER ===\")\n    print\n    print(\"SECURITY GROUP COUNT: \" + str(count))\n    print\n    group = \"\"\n    for i in xrange(count):\n    security_group_name = \"my-security-group-\" + str(i) + \"t\" + str(int(time.time()))\n    group = user.add_group(group_name = security_group_name)\n    user.authorize_group(group)\n    return group\n", "code_toks_joined": "def generate_security_groups_for_given_count ( user , count ) : <NEWLINE> <INDENT> print <NEWLINE> print ( <STRING> ) <NEWLINE> print <NEWLINE> print ( <STRING> + str ( count ) ) <NEWLINE> print <NEWLINE> group = <STRING> <NEWLINE> for i in xrange ( count ) : <NEWLINE> security_group_name = <STRING> + str ( i ) + <STRING> + str ( int ( time . time ( ) ) ) <NEWLINE> group = user . add_group ( group_name = security_group_name ) <NEWLINE> user . authorize_group ( group ) <NEWLINE> return group <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"=== GENERATE SECURITY GROUPS AS USER ===\"", "\"SECURITY GROUP COUNT: \"", "\"\"", "\"my-security-group-\"", "\"t\""]}, "err_obj": {"msg": "expected an indented block"}}], ["59600e582652e90b54bc8da507d14385", {"code_string": "def read(self, size):\n    res = \"\"\n    while size > 0:\n        data = self.socket.recv(size)\n            l = len(data)\n        if l == 0:\n            print(\"WARNING, 0 size read\")\n            return res\n        size = size - l\n            res = res + data\n    return res\n", "code_toks_joined": "def read ( self , size ) : <NEWLINE> <INDENT> res = <STRING> <NEWLINE> while size > 0 : <NEWLINE> <INDENT> data = self . socket . recv ( size ) <NEWLINE> <INDENT> l = len ( data ) <NEWLINE> <DEDENT> if l == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return res <NEWLINE> <DEDENT> size = size - l <NEWLINE> <INDENT> res = res + data <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"", "\"WARNING, 0 size read\""]}, "err_obj": {"msg": "unexpected indent"}}], ["168ba8306248d81f687df9f00f5e6f49", {"code_string": "def read_list(self, object_list, bundle):\n    q = Q(status = 'published')\n    if(hasattr(bundle.request, 'user') and\n        bundle.request.user.is_authenticated()):\n        if bundle.request.user.is_superuser:\n        return object_list\n        else:\n        q_args = {\n            self.owner_field: bundle.request.user\n        }\n        q = q | Q(** q_args)\n    return object_list.filter(q)\n", "code_toks_joined": "def read_list ( self , object_list , bundle ) : <NEWLINE> <INDENT> q = Q ( status = <STRING> ) <NEWLINE> if ( hasattr ( bundle . request , <STRING> ) and <NEWLINE> <INDENT> bundle . request . user . is_authenticated ( ) ) : <NEWLINE> if bundle . request . user . is_superuser : <NEWLINE> return object_list <NEWLINE> else : <NEWLINE> q_args = { <NEWLINE> <INDENT> self . owner_field : bundle . request . user <NEWLINE> <DEDENT> } <NEWLINE> q = q | Q ( ** q_args ) <NEWLINE> <DEDENT> return object_list . filter ( q ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'published'", "'user'"]}, "err_obj": {"msg": "expected an indented block"}}], ["60150d02e1b82523943092f1b8c34818", {"code_string": "def fastFree(params, cwd):\n    param = params['param']\n        p15 = open(param, 'r')\n        m1 = 'num_mod'\n        m2 = grep(m1, p15)\n        m3 = m2.split()\n        num_mod = int(m3[2])\n    mod = 1\n    while mod <= num_mod:\n        mod = mod - 1\n        iteration = fastFree_run(params, cwd, mod)\n        wait(params, iteration)\n        mod = mod + 2\n", "code_toks_joined": "def fastFree ( params , cwd ) : <NEWLINE> <INDENT> param = params [ <STRING> ] <NEWLINE> <INDENT> p15 = open ( param , <STRING> ) <NEWLINE> m1 = <STRING> <NEWLINE> m2 = grep ( m1 , p15 ) <NEWLINE> m3 = m2 . split ( ) <NEWLINE> num_mod = int ( m3 [ 2 ] ) <NEWLINE> <DEDENT> mod = 1 <NEWLINE> while mod <= num_mod : <NEWLINE> <INDENT> mod = mod - 1 <NEWLINE> iteration = fastFree_run ( params , cwd , mod ) <NEWLINE> wait ( params , iteration ) <NEWLINE> mod = mod + 2 <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'param'", "'r'", "'num_mod'"]}, "err_obj": {"msg": "unexpected indent"}}], ["262825b58c653eed113eb3e63b0d680e", {"code_string": "def get_floating_ip(self, context, id):\n    \"\"\"Returns a floating IP as a dict.\"\"\"\n    return dict(floating_ip_obj.FloatingIP.get_by_id(\n        context, id).iteritems()\n", "code_toks_joined": "def get_floating_ip ( self , context , id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return dict ( floating_ip_obj . FloatingIP . get_by_id ( <NEWLINE> <INDENT> context , id ) . iteritems ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns a floating IP as a dict.\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["f038b30b15af7ef0531858f8e7c6de4e", {"code_string": "def retranslateUi(self, ItemProperties):\n    ItemProperties.setWindowTitle(QtWidgets.QApplication.translate(\"ItemProperties\", \"Item Properties\", None, QtWidgets.QApplication.UnicodeUTF8))\n    self.label.setText(QtWidgets.QApplication.translate(\"ItemProperties\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , ItemProperties ) : <NEWLINE> <INDENT> ItemProperties . setWindowTitle ( QtWidgets . QApplication . translate ( <STRING> , <STRING> , None , QtWidgets . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label . setText ( QtWidgets . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"ItemProperties\"", "\"Item Properties\"", "\"ItemProperties\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["8c53f1621a4598bdec5b51bbe67624a5", {"code_string": "def readHumidity():\n    global DHT11_PIN, humidity\n    try:\n        count = 0\n        while True:\n            dht11var = dht11driver.DHT11(pin = DHT11_PIN)\n            result = dht11var.read()\n            if result.is_valid():\n            humidity = int(result.humidity)\n            break\n            count += 1\n            if count > 10:\n            break\n            time.sleep(1)\n    except:\n        pass\n", "code_toks_joined": "def readHumidity ( ) : <NEWLINE> <INDENT> global DHT11_PIN , humidity <NEWLINE> try : <NEWLINE> <INDENT> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> dht11var = dht11driver . DHT11 ( pin = DHT11_PIN ) <NEWLINE> result = dht11var . read ( ) <NEWLINE> if result . is_valid ( ) : <NEWLINE> humidity = int ( result . humidity ) <NEWLINE> break <NEWLINE> count += 1 <NEWLINE> if count > 10 : <NEWLINE> break <NEWLINE> time . sleep ( 1 ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["5c68e56f3a2cc861daef90a891bd32bb", {"code_string": "def enumerateVRFY(self, accounts, processes):\n    \"\"\"Enumerate accounts through VRFY SMTP method\"\"\"\n    if not self.vrfy_available:\n    return[]\n    accounts_input = multiprocessing.Manager().list()\n    accounts_input.extend(accounts)\n    accounts_output = multiprocessing.Manager().list()\n    m_pool = multiprocessing.Pool(processes)\n    for p in range(processes):\n    m_pool.apply_async(enumerateVRFYWorker, (self.host, self.port, self.domain, accounts_input, accounts_output))\n    m_pool.close()\n    m_pool.join()\n    return accounts_output\n", "code_toks_joined": "def enumerateVRFY ( self , accounts , processes ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not self . vrfy_available : <NEWLINE> return [ ] <NEWLINE> accounts_input = multiprocessing . Manager ( ) . list ( ) <NEWLINE> accounts_input . extend ( accounts ) <NEWLINE> accounts_output = multiprocessing . Manager ( ) . list ( ) <NEWLINE> m_pool = multiprocessing . Pool ( processes ) <NEWLINE> for p in range ( processes ) : <NEWLINE> m_pool . apply_async ( enumerateVRFYWorker , ( self . host , self . port , self . domain , accounts_input , accounts_output ) ) <NEWLINE> m_pool . close ( ) <NEWLINE> m_pool . join ( ) <NEWLINE> return accounts_output <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Enumerate accounts through VRFY SMTP method\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["dd026741fed9b3ce96d05ba673b83cc2", {"code_string": "def _match_profile_for_kernel_base(self, kernel_base, test_as):\n    threshold = self.session.GetParameter(\"autodetect_threshold\")\n    for profile, match in self.nt_index.LookupIndex(\n        kernel_base, address_space = test_as):\n        if match < threshold:\n        break\n        profile_obj = self.session.LoadProfile(profile)\n        if profile_obj:\n        return profile_obj\n", "code_toks_joined": "def _match_profile_for_kernel_base ( self , kernel_base , test_as ) : <NEWLINE> <INDENT> threshold = self . session . GetParameter ( <STRING> ) <NEWLINE> for profile , match in self . nt_index . LookupIndex ( <NEWLINE> <INDENT> kernel_base , address_space = test_as ) : <NEWLINE> if match < threshold : <NEWLINE> break <NEWLINE> profile_obj = self . session . LoadProfile ( profile ) <NEWLINE> if profile_obj : <NEWLINE> return profile_obj <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"autodetect_threshold\""]}, "err_obj": {"msg": "expected an indented block"}}], ["369f71808eecfe2358805cb0ec952c36", {"code_string": "def fake_quals(fa):\n    faq = fa.rsplit(\".\", 1)[0] + \".qual\"\n    if op.exists(faq):\n        logging.debug(\"Qual file `{0}` found.\".format(faq))\n    else:\n        sh(\"fakeQuals.py{0}{1}\".format(fa, faq)\n    return fa, faq\n", "code_toks_joined": "def fake_quals ( fa ) : <NEWLINE> <INDENT> faq = fa . rsplit ( <STRING> , 1 ) [ 0 ] + <STRING> <NEWLINE> if op . exists ( faq ) : <NEWLINE> <INDENT> logging . debug ( <STRING> . format ( faq ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sh ( <STRING> . format ( fa , faq ) <NEWLINE> <DEDENT> return fa , faq <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\".\"", "\".qual\"", "\"Qual file `{0}` found.\"", "\"fakeQuals.py{0}{1}\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["4f7f16c64f47f256c92925bca5a478b3", {"code_string": "class ORCIDSerializer(object):\n    \"\"\"Orcid serializer for records.\"\"\"\n    def serialize(self, pid, record, links_factory = None):\n        \"\"\"Serialize a single orcid from a record.\"\"\"\n        return json.dumps(convert_to_orcid(record.dumps()))\n    def serialize_search(self, pid_fetcher, search_result, links = None,\n        item_links_factory = None):\n        \"\"\"Serialize a search result.\"\"\"\n        records = []\n        for hit in search_result['hits']['hits']:\n        records.append(json.dumps((convert_to_orcid(hit['_source']))))\n        return \"\\n\".join(records)\n", "code_toks_joined": "class ORCIDSerializer ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def serialize ( self , pid , record , links_factory = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return json . dumps ( convert_to_orcid ( record . dumps ( ) ) ) <NEWLINE> <DEDENT> def serialize_search ( self , pid_fetcher , search_result , links = None , <NEWLINE> <INDENT> item_links_factory = None ) : <NEWLINE> <STRING> <NEWLINE> records = [ ] <NEWLINE> for hit in search_result [ <STRING> ] [ <STRING> ] : <NEWLINE> records . append ( json . dumps ( ( convert_to_orcid ( hit [ <STRING> ] ) ) ) ) <NEWLINE> return <STRING> . join ( records ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Orcid serializer for records.\"\"\"", "\"\"\"Serialize a single orcid from a record.\"\"\"", "\"\"\"Serialize a search result.\"\"\"", "'hits'", "'hits'", "'_source'", "\"\\n\""]}, "err_obj": {"msg": "expected an indented block"}}], ["06aae0aac09d98d2bbe345bacd9ce303", {"code_string": "def get_angle_from_coordinates((x1, y1), (x2, y2)):\n    \"\"\"Given two points, calculate the vector direction from point1 to point2, directions are multiples of 90 degrees.\"\"\"\n    if y1 == y2:\n        if x2 > x1: return 0\n        else: return 180\n    else:\n        if y2 > y1: return 270\n        else: return 90\n", "code_toks_joined": "def get_angle_from_coordinates ( ( x1 , y1 ) , ( x2 , y2 ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if y1 == y2 : <NEWLINE> <INDENT> if x2 > x1 : return 0 <NEWLINE> else : return 180 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if y2 > y1 : return 270 <NEWLINE> else : return 90 <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Given two points, calculate the vector direction from point1 to point2, directions are multiples of 90 degrees.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["518e7f0f916cd289ae7255595dbf952c", {"code_string": "def __init__(self, display):\n    self._display = display\n    if self._display.verbosity >= 4:\n        name = getattr(self, 'CALLBACK_NAME', 'unnamed')\n        ctype = getattr(self, 'CALLBACK_TYPE', 'old')\n        version = getattr(self, 'CALLBACK_VERSION', '1.0')\n        self._display.vvvv('Loaded callback %s of type %s, v%s' %(name, ctype, version)\n", "code_toks_joined": "def __init__ ( self , display ) : <NEWLINE> <INDENT> self . _display = display <NEWLINE> if self . _display . verbosity >= 4 : <NEWLINE> <INDENT> name = getattr ( self , <STRING> , <STRING> ) <NEWLINE> ctype = getattr ( self , <STRING> , <STRING> ) <NEWLINE> version = getattr ( self , <STRING> , <STRING> ) <NEWLINE> self . _display . vvvv ( <STRING> % ( name , ctype , version ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'CALLBACK_NAME'", "'unnamed'", "'CALLBACK_TYPE'", "'old'", "'CALLBACK_VERSION'", "'1.0'", "'Loaded callback %s of type %s, v%s'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["9b2182b957013ad6c2dabb7661341265", {"code_string": "import utils\nSEVERITY_FINE = 1\nSEVERITY_WARNING = 2\nSEVERITY_ERROR = 3\nSTR_SEVERITY = {\n    SEVERITY_FINE: \"FINE\"\n    SEVERITY_WARNING: \"WARNING\"\n    SEVERITY_ERROR: \"ERROR\"\n}\nLOG_TEMPLATE = \"%s %s: %s\\n\"\n", "code_toks_joined": "import utils <NEWLINE> SEVERITY_FINE = 1 <NEWLINE> SEVERITY_WARNING = 2 <NEWLINE> SEVERITY_ERROR = 3 <NEWLINE> STR_SEVERITY = { <NEWLINE> <INDENT> SEVERITY_FINE : <STRING> <NEWLINE> SEVERITY_WARNING : <STRING> <NEWLINE> SEVERITY_ERROR : <STRING> <NEWLINE> <DEDENT> } <NEWLINE> LOG_TEMPLATE = <STRING> <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"FINE\"", "\"WARNING\"", "\"ERROR\"", "\"%s %s: %s\\n\""]}, "err_obj": {"msg": "invalid syntax"}}], ["b130fb2ce8161bbf4b4e76222ec709a6", {"code_string": "def setupUi(self, MainWindow):\n    MainWindow.setObjectName(\"MainWindow\")\n    MainWindow.setWindowModality(QtCore.Qt.NonModal)\n    MainWindow.resize(800, 480)\n    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Maximum, QtWidgets.QSizePolicy.Maximum)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(MainWindow.sizePolicy().hasHeightForWidth())\n    MainWindow.setSizePolicy(sizePolicy)\n    font = QtGui.QFont()\n    font.setFamily(\"Cronus Round\")\n    font.setPointSize(19)\n    font.setBold(True)\n    font.setWeight(75)\n    MainWindow.setFont(font)\n    MainWindow.setContextMenuPolicy(QtCore.Qt.PreventContextMenu)\n    MainWindow.setProperty(\"dockNestingEnabled\", False)\n    MainWindow.setProperty(\"unifiedTitleAndToolBarOnMac\", False)\n    self.gridLayout = QtWidgets.QGridLayout(MainWindow)\n    self.gridLayout.setContentsMargins(0, 0, 0, 6)\n    self.gridLayout.setSpacing(0)\n    self.gridLayout.setObjectName(\"gridLayout\")\n    self.gridLayout_3 = QtWidgets.QGridLayout()\n    self.gridLayout_3.setContentsMargins(7, - 1, 6, 6)\n    self.gridLayout_3.setObjectName(\"gridLayout_3\")\n    spacerItem = QtWidgets.QSpacerItem(6, 20, QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Minimum)\n    self.gridLayout_3.addItem(spacerItem, 0, 2, 1, 1)\n    spacerItem1 = QtWidgets.QSpacerItem(6, 20, QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Minimum)\n    self.gridLayout_3.addItem(spacerItem1, 0, 6, 1, 1)\n    self.recItemsRemoveBtn = TouchButton(MainWindow)\n    self.recItemsRemoveBtn.setStyleSheet(\"background-color: transparent;\\n\"\n", "code_toks_joined": "def setupUi ( self , MainWindow ) : <NEWLINE> <INDENT> MainWindow . setObjectName ( <STRING> ) <NEWLINE> MainWindow . setWindowModality ( QtCore . Qt . NonModal ) <NEWLINE> MainWindow . resize ( 800 , 480 ) <NEWLINE> sizePolicy = QtWidgets . QSizePolicy ( QtWidgets . QSizePolicy . Maximum , QtWidgets . QSizePolicy . Maximum ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( MainWindow . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> MainWindow . setSizePolicy ( sizePolicy ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setFamily ( <STRING> ) <NEWLINE> font . setPointSize ( 19 ) <NEWLINE> font . setBold ( True ) <NEWLINE> font . setWeight ( 75 ) <NEWLINE> MainWindow . setFont ( font ) <NEWLINE> MainWindow . setContextMenuPolicy ( QtCore . Qt . PreventContextMenu ) <NEWLINE> MainWindow . setProperty ( <STRING> , False ) <NEWLINE> MainWindow . setProperty ( <STRING> , False ) <NEWLINE> self . gridLayout = QtWidgets . QGridLayout ( MainWindow ) <NEWLINE> self . gridLayout . setContentsMargins ( 0 , 0 , 0 , 6 ) <NEWLINE> self . gridLayout . setSpacing ( 0 ) <NEWLINE> self . gridLayout . setObjectName ( <STRING> ) <NEWLINE> self . gridLayout_3 = QtWidgets . QGridLayout ( ) <NEWLINE> self . gridLayout_3 . setContentsMargins ( 7 , - 1 , 6 , 6 ) <NEWLINE> self . gridLayout_3 . setObjectName ( <STRING> ) <NEWLINE> spacerItem = QtWidgets . QSpacerItem ( 6 , 20 , QtWidgets . QSizePolicy . Fixed , QtWidgets . QSizePolicy . Minimum ) <NEWLINE> self . gridLayout_3 . addItem ( spacerItem , 0 , 2 , 1 , 1 ) <NEWLINE> spacerItem1 = QtWidgets . QSpacerItem ( 6 , 20 , QtWidgets . QSizePolicy . Fixed , QtWidgets . QSizePolicy . Minimum ) <NEWLINE> self . gridLayout_3 . addItem ( spacerItem1 , 0 , 6 , 1 , 1 ) <NEWLINE> self . recItemsRemoveBtn = TouchButton ( MainWindow ) <NEWLINE> self . recItemsRemoveBtn . setStyleSheet ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"MainWindow\"", "\"Cronus Round\"", "\"dockNestingEnabled\"", "\"unifiedTitleAndToolBarOnMac\"", "\"gridLayout\"", "\"gridLayout_3\"", "\"background-color: transparent;\\n\""]}, "window_span": [337, 341], "err_obj": {"msg": "unbalanced (){}[]"}}], ["c6243587007e9d9d285031b6a67cb1c8", {"code_string": "def color_water(imask):\n    \"\"\" Set each body of water to a different value, return number of\"\"\"\n    count = 2\n    Mp, Lp = imask.shape\n    for j in range(1, Mp - 1):\n        for i in range(1, Lp - 1):\n        if(imask[j, i] == 1):\n    flood_fill_water(imask, i, j, count)\n        warning(\"New body!\", i, j)\n        count += 1\n    warning(\"There are\", count - 2, \" bodies of water.\")\n    return count - 2\n", "code_toks_joined": "def color_water ( imask ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> count = 2 <NEWLINE> Mp , Lp = imask . shape <NEWLINE> for j in range ( 1 , Mp - 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , Lp - 1 ) : <NEWLINE> if ( imask [ j , i ] == 1 ) : <NEWLINE> <DEDENT> flood_fill_water ( imask , i , j , count ) <NEWLINE> <INDENT> warning ( <STRING> , i , j ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> warning ( <STRING> , count - 2 , <STRING> ) <NEWLINE> return count - 2 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Set each body of water to a different value, return number of\"\"\"", "\"New body!\"", "\"There are\"", "\" bodies of water.\""]}, "err_obj": {"msg": "expected an indented block"}}], ["b7f70ba2609801b17aa6eae7069aa7ef", {"code_string": "def test_get_local_port_mac_raises_exception_for_missing_mac(self):\n    with mock.patch('neutron.agent.linux.ip_lib.IpLinkCommand',\n        return_value = mock.Mock(address = None)):\n        with testtools.ExpectedException(Exception):\n        self.br.get_local_port_mac()\n", "code_toks_joined": "def test_get_local_port_mac_raises_exception_for_missing_mac ( self ) : <NEWLINE> <INDENT> with mock . patch ( <STRING> , <NEWLINE> <INDENT> return_value = mock . Mock ( address = None ) ) : <NEWLINE> with testtools . ExpectedException ( Exception ) : <NEWLINE> self . br . get_local_port_mac ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'neutron.agent.linux.ip_lib.IpLinkCommand'"]}, "err_obj": {"msg": "expected an indented block"}}], ["251694045a6fd69aac97da84611b0723", {"code_string": "def __eq__(self, other):\n    if type(other) == type(self)\n        return(abs(self.t0 == other.t0) < 1e-15) and(abs(self.t1 == other.t1) < 1e-15) and(self.n_step == other.n_step)\n    else:\n        raise ValueError\n", "code_toks_joined": "def __eq__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == type ( self ) <NEWLINE> <INDENT> return ( abs ( self . t0 == other . t0 ) < 1e-15 ) and ( abs ( self . t1 == other . t1 ) < 1e-15 ) and ( self . n_step == other . n_step ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise ValueError <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["1a58769b500f23269ba7b1e29b644c1e", {"code_string": "class InsertionSort(SortAlgorithm):\n    \"\"\"The INSERTION SORT Algorithm.\"\"\"\n    def sort(self, data):\n        for i in range(1, len(data):\n            k = i\n            while k > 0 and data[k] < data[k - 1]:\n                self.swap(data, k, k - 1)\n                k -= 1\n        return data\n", "code_toks_joined": "class InsertionSort ( SortAlgorithm ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def sort ( self , data ) : <NEWLINE> <INDENT> for i in range ( 1 , len ( data ) : <NEWLINE> <INDENT> k = i <NEWLINE> while k > 0 and data [ k ] < data [ k - 1 ] : <NEWLINE> <INDENT> self . swap ( data , k , k - 1 ) <NEWLINE> k -= 1 <NEWLINE> <DEDENT> <DEDENT> return data <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"The INSERTION SORT Algorithm.\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["edae5c25563f768b2e2bcb23520493fb", {"code_string": "def step(context):\n    from numpy import all, abs, identity\n    for survivor, qmatrix, value in zip(context.survivors, context.qmatrices,\n        context.survivor_values):\n        try:\n        assert all(abs(value - identity(value.shape[0])) < context.tolerance)\n        except:\n        print(survivor)\n        print(qmatrix)\n        raise\n", "code_toks_joined": "def step ( context ) : <NEWLINE> <INDENT> from numpy import all , abs , identity <NEWLINE> for survivor , qmatrix , value in zip ( context . survivors , context . qmatrices , <NEWLINE> <INDENT> context . survivor_values ) : <NEWLINE> try : <NEWLINE> assert all ( abs ( value - identity ( value . shape [ 0 ] ) ) < context . tolerance ) <NEWLINE> except : <NEWLINE> print ( survivor ) <NEWLINE> print ( qmatrix ) <NEWLINE> raise <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["9913feba2affcb502eadfe775d879e6d", {"code_string": "def get_good_peers(self, max_count):\n    t = time.time()\n    return[x[0] for x in sorted(self.addr_store.iteritems(), key = lambda(k, (services, first_seen, last_seen)):\n        - math.log(max(3600, last_seen - first_seen)) / math.log(max(3600, t - last_seen)) * random.expovariate(1)\n    )][: max_count]\n", "code_toks_joined": "def get_good_peers ( self , max_count ) : <NEWLINE> <INDENT> t = time . time ( ) <NEWLINE> return [ x [ 0 ] for x in sorted ( self . addr_store . iteritems ( ) , key = lambda ( k , ( services , first_seen , last_seen ) ) : <NEWLINE> <INDENT> - math . log ( max ( 3600 , last_seen - first_seen ) ) / math . log ( max ( 3600 , t - last_seen ) ) * random . expovariate ( 1 ) <NEWLINE> <DEDENT> ) ] [ : max_count ] <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["d749e309bc8e00a1a5a91b14dc60813a", {"code_string": "def raise_if_not_int_vector2(v):\n    if not isinstance(v, numpy.ndarray):\n        raise ValueError('{}: {}: {} is not a numpy array'.format(\n            v, repr(v), type(v)))\n    if not numpy.issubdtype(v.dtype.type, numpy.integer):\n        raise ValueError('{}: {} is not an int vector2'.format(v, v.dtype)\n", "code_toks_joined": "def raise_if_not_int_vector2 ( v ) : <NEWLINE> <INDENT> if not isinstance ( v , numpy . ndarray ) : <NEWLINE> <INDENT> raise ValueError ( <STRING> . format ( <NEWLINE> <INDENT> v , repr ( v ) , type ( v ) ) ) <NEWLINE> <DEDENT> <DEDENT> if not numpy . issubdtype ( v . dtype . type , numpy . integer ) : <NEWLINE> <INDENT> raise ValueError ( <STRING> . format ( v , v . dtype ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'{}: {}: {} is not a numpy array'", "'{}: {} is not an int vector2'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["72664edf5eeaf17a4873c02d8854440a", {"code_string": "def rename_combining(seq):\n    filtered_sequence = []\n    for ks in seq:\n        if findall('^combining_', ks):\n            ks = sub('^combining_', 'dead_', ks)\n                if ks == 'dead_double_grave':\n                    ks = 'dead_doublegrave'\n                if ks == 'dead_inverted_breve':\n                    ks = 'dead_invertedbreve'\n        filtered_sequence.append(ks)\n    return filtered_sequence\n", "code_toks_joined": "def rename_combining ( seq ) : <NEWLINE> <INDENT> filtered_sequence = [ ] <NEWLINE> for ks in seq : <NEWLINE> <INDENT> if findall ( <STRING> , ks ) : <NEWLINE> <INDENT> ks = sub ( <STRING> , <STRING> , ks ) <NEWLINE> <INDENT> if ks == <STRING> : <NEWLINE> <INDENT> ks = <STRING> <NEWLINE> <DEDENT> if ks == <STRING> : <NEWLINE> <INDENT> ks = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> filtered_sequence . append ( ks ) <NEWLINE> <DEDENT> return filtered_sequence <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'^combining_'", "'^combining_'", "'dead_'", "'dead_double_grave'", "'dead_doublegrave'", "'dead_inverted_breve'", "'dead_invertedbreve'"]}, "err_obj": {"msg": "unexpected indent"}}], ["559c0d3ed69c449aa67074bc6ce263cb", {"code_string": "def containsDigitAndSlashOperator(form):\n    if re.match('[0-9]+/[0-9]+', form):\n        return[int(True)]\n        else:\n        return[int(False)]\n", "code_toks_joined": "def containsDigitAndSlashOperator ( form ) : <NEWLINE> <INDENT> if re . match ( <STRING> , form ) : <NEWLINE> <INDENT> return [ int ( True ) ] <NEWLINE> else : <NEWLINE> return [ int ( False ) ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'[0-9]+/[0-9]+'"]}, "err_obj": {"msg": "invalid syntax"}}], ["63757395f7927c2495a6b9eb67840d26", {"code_string": "def __init__(self, name, , cfg, paths):\n    distros.Distro.__init__(self, name, cfg, paths)\n    self._runner = helpers.Runners(paths)\n    self.osfamily = 'debian'\n", "code_toks_joined": "def __init__ ( self , name , , cfg , paths ) : <NEWLINE> <INDENT> distros . Distro . __init__ ( self , name , cfg , paths ) <NEWLINE> self . _runner = helpers . Runners ( paths ) <NEWLINE> self . osfamily = <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'debian'"]}, "err_obj": {"msg": "invalid syntax"}}], ["865e143979f735ea3c3ec733254170ce", {"code_string": "def _check_imt(self, imt):\n    \"\"\"Make sure that ``imt`` is valid and is supported by this GSIM.\"\"\"\n    if not issubclass(type(imt), imt_module._IMT):\n        raise ValueError('imt must be an instance of IMT subclass')\n    if not type(imt) in self.DEFINED_FOR_INTENSITY_MEASURE_TYPES:\n        raise ValueError('imt %s is not supported by %s' %\n            (type(imt).__name__, type(self).__name__)))\n", "code_toks_joined": "def _check_imt ( self , imt ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not issubclass ( type ( imt ) , imt_module . _IMT ) : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> if not type ( imt ) in self . DEFINED_FOR_INTENSITY_MEASURE_TYPES : <NEWLINE> <INDENT> raise ValueError ( <STRING> % <NEWLINE> <INDENT> ( type ( imt ) . __name__ , type ( self ) . __name__ ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Make sure that ``imt`` is valid and is supported by this GSIM.\"\"\"", "'imt must be an instance of IMT subclass'", "'imt %s is not supported by %s'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["4140b70029c8f7df0a28f60d23881b28", {"code_string": "def sendScript(self, string):\n    warnings.warn(\n        \"[0.5] nevow.livepage.ClientHandle.sendScript is deprecated, use send instead.\"\n        DeprecationWarning,\n        2)\n    self.send(string)\n", "code_toks_joined": "def sendScript ( self , string ) : <NEWLINE> <INDENT> warnings . warn ( <NEWLINE> <INDENT> <STRING> <NEWLINE> DeprecationWarning , <NEWLINE> 2 ) <NEWLINE> <DEDENT> self . send ( string ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"[0.5] nevow.livepage.ClientHandle.sendScript is deprecated, use send instead.\""]}, "err_obj": {"msg": "invalid syntax"}}], ["73658504bbc0153eb10b33e8c078d2d6", {"code_string": "def testOverrideFlavor(self):\n    def override(flavor1, flavor2):\n        return overrideFlavor(parseFlavor(flavor1),\n            parseFlavor(flavor2).freeze()\n    assert(override('foo, bar is: x86(i686)', '!foo is: x86_64') == '1#x86_64|5#use: bar: !foo')\n    foo = override('foo is: x86(i686, !i586)', '!foo is: x86(i586)')\n    assert(override('foo is: x86(i686, !i586)x86_64', '!foo is: x86(i586)') == '1#x86: i586: i686|5#use: !foo')\n", "code_toks_joined": "def testOverrideFlavor ( self ) : <NEWLINE> <INDENT> def override ( flavor1 , flavor2 ) : <NEWLINE> <INDENT> return overrideFlavor ( parseFlavor ( flavor1 ) , <NEWLINE> <INDENT> parseFlavor ( flavor2 ) . freeze ( ) <NEWLINE> <DEDENT> <DEDENT> assert ( override ( <STRING> , <STRING> ) == <STRING> ) <NEWLINE> foo = override ( <STRING> , <STRING> ) <NEWLINE> assert ( override ( <STRING> , <STRING> ) == <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'foo, bar is: x86(i686)'", "'!foo is: x86_64'", "'1#x86_64|5#use: bar: !foo'", "'foo is: x86(i686, !i586)'", "'!foo is: x86(i586)'", "'foo is: x86(i686, !i586)x86_64'", "'!foo is: x86(i586)'", "'1#x86: i586: i686|5#use: !foo'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["a3d54a249faa8f49a9b217e9172c9a33", {"code_string": "def retranslateUi(self, DlgAbout):\n    DlgAbout.setWindowTitle(_translate(\"DlgAbout\", \"About Vector Tile Reader\", None))\n    self.btnClose.setText(_translate(\"DlgAbout\", \"Close\", None))\n    self.txtAbout.setHtml(_translate(\"DlgAbout\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , DlgAbout ) : <NEWLINE> <INDENT> DlgAbout . setWindowTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . btnClose . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . txtAbout . setHtml ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"DlgAbout\"", "\"About Vector Tile Reader\"", "\"DlgAbout\"", "\"Close\"", "\"DlgAbout\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["94f633b5843ffca6aa2e685427f6fbc6", {"code_string": "def _shareLease(self, dstImgPath):\n    \"\"\"Internal utility method used to share the template volume lease file\"\"\"\n    self.log.debug(\"Share volume lease of %s to %s\", self.volUUID\n        dstImgPath)\n    dstLeasePath = self._getLeaseVolumePath(\n        os.path.join(dstImgPath, self.volUUID))\n    self.oop.utils.forceLink(self._getLeaseVolumePath(), dstLeasePath)\n", "code_toks_joined": "def _shareLease ( self , dstImgPath ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . log . debug ( <STRING> , self . volUUID <NEWLINE> <INDENT> dstImgPath ) <NEWLINE> <DEDENT> dstLeasePath = self . _getLeaseVolumePath ( <NEWLINE> <INDENT> os . path . join ( dstImgPath , self . volUUID ) ) <NEWLINE> <DEDENT> self . oop . utils . forceLink ( self . _getLeaseVolumePath ( ) , dstLeasePath ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Internal utility method used to share the template volume lease file\"\"\"", "\"Share volume lease of %s to %s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["7f216dd597b5f8c55416fb405525f7d7", {"code_string": "class Player(Thread):\n    def __init__(self, startX, startY, player):\n    self.fd = open(config.STASH_PATH + player + \"stash.txt\", \"r+\")\n    self.playerStash = mmap.mmap(self.fd.fileno(), 0)\n    self.player = getattr(imp.load_source(player, config.PLAYER_PATH + player + \".py\"), \"Supervisor\")(startX, startY, self.playerStash)\n    self.fd.close()\n", "code_toks_joined": "class Player ( Thread ) : <NEWLINE> <INDENT> def __init__ ( self , startX , startY , player ) : <NEWLINE> self . fd = open ( config . STASH_PATH + player + <STRING> , <STRING> ) <NEWLINE> self . playerStash = mmap . mmap ( self . fd . fileno ( ) , 0 ) <NEWLINE> self . player = getattr ( imp . load_source ( player , config . PLAYER_PATH + player + <STRING> ) , <STRING> ) ( startX , startY , self . playerStash ) <NEWLINE> self . fd . close ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"stash.txt\"", "\"r+\"", "\".py\"", "\"Supervisor\""]}, "err_obj": {"msg": "expected an indented block"}}], ["be530bc3a0eca854213bbc59c1f4643a", {"code_string": "def resolve_name(tokens, id, args):\n    if id in map(lambda x: x[0], tokens):\n    if args:\n        print('Warning: ignoring parameters on TOKEN %s<<%s>>' %(id, args))\n            return Terminal(id)\n    else:\n        return NonTerminal(id, args)\n", "code_toks_joined": "def resolve_name ( tokens , id , args ) : <NEWLINE> <INDENT> if id in map ( lambda x : x [ 0 ] , tokens ) : <NEWLINE> if args : <NEWLINE> <INDENT> print ( <STRING> % ( id , args ) ) <NEWLINE> <INDENT> return Terminal ( id ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return NonTerminal ( id , args ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Warning: ignoring parameters on TOKEN %s<<%s>>'"]}, "err_obj": {"msg": "expected an indented block"}}], ["c156e65c60f3fe0b162c8220c1ec7d37", {"code_string": "class DebugSWFilter(BaseSWFilter):\n    \"\"\"...\"\"\"\n    __logger = logging.getLogger(__name__)\n    def aggregate_windows(self,\n        window_seq,\n        if_index = None,\n        true_factor = 1,\n        true_summand = 0,\n        false_factor = 1,\n        false_summand = 0,\n        ** kwargs):\n        \"\"\":param window_seq:\"\"\"\n        for window in window_seq:\n        for win_index, win_item in enumerate(window):\n        if if_index == win_index:\n        yield true_factor * win_item + true_summand\n        else:\n        yield false_factor * win_item + false_summand\n", "code_toks_joined": "class DebugSWFilter ( BaseSWFilter ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> __logger = logging . getLogger ( __name__ ) <NEWLINE> def aggregate_windows ( self , <NEWLINE> <INDENT> window_seq , <NEWLINE> if_index = None , <NEWLINE> true_factor = 1 , <NEWLINE> true_summand = 0 , <NEWLINE> false_factor = 1 , <NEWLINE> false_summand = 0 , <NEWLINE> ** kwargs ) : <NEWLINE> <STRING> <NEWLINE> for window in window_seq : <NEWLINE> for win_index , win_item in enumerate ( window ) : <NEWLINE> if if_index == win_index : <NEWLINE> yield true_factor * win_item + true_summand <NEWLINE> else : <NEWLINE> yield false_factor * win_item + false_summand <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"...\"\"\"", "\"\"\":param window_seq:\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["22be60e54c3bbca080e3867a0a19b7fc", {"code_string": "N = int(input())\nk = 2\nbad_delta = 20001\ns = 0\ndelta_min = bad_delta\nfor i in range(N):\n    x, y = [int(word) for word in input().split()]\n    s += min(x, y)\n    if abs(x - y) % k != 0 and abs(x - y) < delta_min:\n        delta_min = abs(x - y)\nif s % k != 0:\n    print(s)\nelif delta_min != bad_delta:\n    print(s + delta_min)\nelse:\n    print(0\n", "code_toks_joined": "N = int ( input ( ) ) <NEWLINE> k = 2 <NEWLINE> bad_delta = 20001 <NEWLINE> s = 0 <NEWLINE> delta_min = bad_delta <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = [ int ( word ) for word in input ( ) . split ( ) ] <NEWLINE> s += min ( x , y ) <NEWLINE> if abs ( x - y ) % k != 0 and abs ( x - y ) < delta_min : <NEWLINE> <INDENT> delta_min = abs ( x - y ) <NEWLINE> <DEDENT> <DEDENT> if s % k != 0 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> elif delta_min != bad_delta : <NEWLINE> <INDENT> print ( s + delta_min ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 <NEWLINE> <DEDENT>", "anonymize_dict": {}, "window_span": [134, 138], "err_obj": {"msg": "unbalanced (){}[]"}}], ["2eabad3f67ab801e7eb6ce261cecd4f8", {"code_string": "def add_known_arguments(self, parser):\n    parser.add_argument(\n        'name', metavar = 'NAME',\n        help = _('Name of queue'))\n    parser.add_argument(\n        '--min',\n        help = _('min-rate')),\n    parser.add_argument(\n        '--max',\n        help = _('max-rate')),\n    parser.add_argument(\n        '--qos-marking',\n        help = _('QOS marking untrusted/trusted')),\n    parser.add_argument(\n        '--default',\n        default = False,\n        help = _('If true all ports created with be the size of this queue'\n", "code_toks_joined": "def add_known_arguments ( self , parser ) : <NEWLINE> <INDENT> parser . add_argument ( <NEWLINE> <INDENT> <STRING> , metavar = <STRING> , <NEWLINE> help = _ ( <STRING> ) ) <NEWLINE> <DEDENT> parser . add_argument ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> help = _ ( <STRING> ) ) , <NEWLINE> <DEDENT> parser . add_argument ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> help = _ ( <STRING> ) ) , <NEWLINE> <DEDENT> parser . add_argument ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> help = _ ( <STRING> ) ) , <NEWLINE> <DEDENT> parser . add_argument ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> default = False , <NEWLINE> help = _ ( <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'name'", "'NAME'", "'Name of queue'", "'--min'", "'min-rate'", "'--max'", "'max-rate'", "'--qos-marking'", "'QOS marking untrusted/trusted'", "'--default'", "'If true all ports created with be the size of this queue'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["29572b48a3c4ef9b4478843671f6fcd7", {"code_string": "def showColorWellUI():\n    global dialog\n    if dialog is not None:\n    dialog.enter()\n        return\n    dialog = ColorWellDialog()\n", "code_toks_joined": "def showColorWellUI ( ) : <NEWLINE> <INDENT> global dialog <NEWLINE> if dialog is not None : <NEWLINE> dialog . enter ( ) <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> dialog = ColorWellDialog ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["15c84117d845ac4224243fc9c24b7f90", {"code_string": "def reset(self):\n    self.token = None\n    self.unary_operators = \"!\"\n    self.binary_operators = frozenset([\"&&\", \"||\", \"==\"])\n    self.tokenizer = Tokenizer()\n    self.token_generator = None\n    self.tree = Treebuilder(DataNode(None)\n    self.expr_builder = None\n    self.expr_builders = []\n", "code_toks_joined": "def reset ( self ) : <NEWLINE> <INDENT> self . token = None <NEWLINE> self . unary_operators = <STRING> <NEWLINE> self . binary_operators = frozenset ( [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> self . tokenizer = Tokenizer ( ) <NEWLINE> self . token_generator = None <NEWLINE> self . tree = Treebuilder ( DataNode ( None ) <NEWLINE> self . expr_builder = None <NEWLINE> self . expr_builders = [ ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"!\"", "\"&&\"", "\"||\"", "\"==\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["157bbc10e773b6f84995cf754e9913dd", {"code_string": "def new_figure_manager(num, * args, ** kwargs):\n    \"\"\"Create a new figure manager instance\"\"\"\n    if _debug:\n        print 'backend_gtkcairo.%s()' % fn_name()\n    FigureClass = kwargs.pop('FigureClass', Figure)\n    thisFig = FigureClass(* args, ** kwargs)\n    canvas = FigureCanvasGTKCairo(thisFig)\n    return FigureManagerGTK(canvas, num)\n", "code_toks_joined": "def new_figure_manager ( num , * args , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if _debug : <NEWLINE> <INDENT> print <STRING> % fn_name ( ) <NEWLINE> <DEDENT> FigureClass = kwargs . pop ( <STRING> , Figure ) <NEWLINE> thisFig = FigureClass ( * args , ** kwargs ) <NEWLINE> canvas = FigureCanvasGTKCairo ( thisFig ) <NEWLINE> return FigureManagerGTK ( canvas , num ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Create a new figure manager instance\"\"\"", "'backend_gtkcairo.%s()'", "'FigureClass'"]}, "err_obj": {"msg": "invalid syntax"}}], ["215122814ea43b1026822b7d478e20ce", {"code_string": "def mpc_cos_pi((a, b), prec, rnd = round_fast):\n    b = mpf_mul(b, mpf_pi(prec + 5), prec + 5)\n    if a == fzero:\n        return mpf_cosh(b, prec, rnd), fzero\n    wp = prec + 6\n    c, s = mpf_cos_sin_pi(a, wp)\n    ch, sh = cosh_sinh(b, wp)\n    re = mpf_mul(c, ch, prec, rnd)\n    im = mpf_mul(s, sh, prec, rnd)\n    return re, mpf_neg(im)\n", "code_toks_joined": "def mpc_cos_pi ( ( a , b ) , prec , rnd = round_fast ) : <NEWLINE> <INDENT> b = mpf_mul ( b , mpf_pi ( prec + 5 ) , prec + 5 ) <NEWLINE> if a == fzero : <NEWLINE> <INDENT> return mpf_cosh ( b , prec , rnd ) , fzero <NEWLINE> <DEDENT> wp = prec + 6 <NEWLINE> c , s = mpf_cos_sin_pi ( a , wp ) <NEWLINE> ch , sh = cosh_sinh ( b , wp ) <NEWLINE> re = mpf_mul ( c , ch , prec , rnd ) <NEWLINE> im = mpf_mul ( s , sh , prec , rnd ) <NEWLINE> return re , mpf_neg ( im ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["0df7ef74103d6dc4d98494ed0e948a67", {"code_string": "def _get_consumer(self, session, consumer_id):\n    consumer_ref = session.query(Consumer).get(consumer_id)\n    if consumer_ref is None:\n        raise exception.NotFound(_('No Consumer found with id: %s' % consumer_id)\n    return consumer_ref\n", "code_toks_joined": "def _get_consumer ( self , session , consumer_id ) : <NEWLINE> <INDENT> consumer_ref = session . query ( Consumer ) . get ( consumer_id ) <NEWLINE> if consumer_ref is None : <NEWLINE> <INDENT> raise exception . NotFound ( _ ( <STRING> % consumer_id ) <NEWLINE> <DEDENT> return consumer_ref <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'No Consumer found with id: %s'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["35071c053916927ad26d61cacf583104", {"code_string": "def with_right_justify():\n    with progressbar.ProgressBar(max_value = range_count, term_width = 20,\n        left_justify = False) as progress:\n        assert progress.term_width is not None\n        for i in range(range_count):\n        del_from_list()\n        progress.update(i)\n", "code_toks_joined": "def with_right_justify ( ) : <NEWLINE> <INDENT> with progressbar . ProgressBar ( max_value = range_count , term_width = 20 , <NEWLINE> <INDENT> left_justify = False ) as progress : <NEWLINE> assert progress . term_width is not None <NEWLINE> for i in range ( range_count ) : <NEWLINE> del_from_list ( ) <NEWLINE> progress . update ( i ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["8c8efb4ef7c0df6246e82ff221c31833", {"code_string": "def get_ssaname(self, varname, line):\n    if vim.current.buffer.name == None:\n        raise AnnExc(\"Empty buffer\")\n    if vim.current.buffer.name != self.filename or os.stat(self.filename).st_mtime > self.timestamp:\n    filename = self.filename\n    self.parse(filename)\n    ssaname = varname\n    try:\n        ssaname = self.annot[(str(varname), int(line))]\n    except:\n        pass\n    return ssaname\n", "code_toks_joined": "def get_ssaname ( self , varname , line ) : <NEWLINE> <INDENT> if vim . current . buffer . name == None : <NEWLINE> <INDENT> raise AnnExc ( <STRING> ) <NEWLINE> <DEDENT> if vim . current . buffer . name != self . filename or os . stat ( self . filename ) . st_mtime > self . timestamp : <NEWLINE> filename = self . filename <NEWLINE> self . parse ( filename ) <NEWLINE> ssaname = varname <NEWLINE> try : <NEWLINE> <INDENT> ssaname = self . annot [ ( str ( varname ) , int ( line ) ) ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> return ssaname <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Empty buffer\""]}, "err_obj": {"msg": "expected an indented block"}}], ["a8686faf9d7e61f653b33d1165c9bf24", {"code_string": "def Warn(self, msg):\n    if GetOption('release_debug'): print 'Warn: %s' % msg\n    self.warns.append(msg)\n", "code_toks_joined": "def Warn ( self , msg ) : <NEWLINE> <INDENT> if GetOption ( <STRING> ) : print <STRING> % msg <NEWLINE> self . warns . append ( msg ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'release_debug'", "'Warn: %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["fc63041f7f35e47c3162314cbf00e502", {"code_string": "def handle_data(self, command = None, payload = None):\n    \"\"\"Calls the instance method with name on_[command]with argument payload\"\"\"\n    method_name = \"on_%s\" % command\n    if command and hasattr(self, method_name) and callable(getattr(self, method_name):\n        return getattr(self, method_name)(payload)\n", "code_toks_joined": "def handle_data ( self , command = None , payload = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> method_name = <STRING> % command <NEWLINE> if command and hasattr ( self , method_name ) and callable ( getattr ( self , method_name ) : <NEWLINE> <INDENT> return getattr ( self , method_name ) ( payload ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Calls the instance method with name on_[command]with argument payload\"\"\"", "\"on_%s\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["5e0bab735cecda4ae8a53c8c0f2ff956", {"code_string": "def write(self, text, * args):\n    newArgs = []\n    for arg in args:\n        try:\n        arg = arg.sourceString()\n        except(TypeError):\n        arg = arg\n        newArgs.append(arg)\n    if self.startLine:\n        self.text.append(self.indent * self.indentation)\n        self.startLine = 0\n    if len(args) > 0:\n        text = text % tuple(newArgs)\n    self.text.append(text)\n", "code_toks_joined": "def write ( self , text , * args ) : <NEWLINE> <INDENT> newArgs = [ ] <NEWLINE> for arg in args : <NEWLINE> <INDENT> try : <NEWLINE> arg = arg . sourceString ( ) <NEWLINE> except ( TypeError ) : <NEWLINE> arg = arg <NEWLINE> newArgs . append ( arg ) <NEWLINE> <DEDENT> if self . startLine : <NEWLINE> <INDENT> self . text . append ( self . indent * self . indentation ) <NEWLINE> self . startLine = 0 <NEWLINE> <DEDENT> if len ( args ) > 0 : <NEWLINE> <INDENT> text = text % tuple ( newArgs ) <NEWLINE> <DEDENT> self . text . append ( text ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["d5693ba61409a1cb95443ce47e0d3f2f", {"code_string": "def getTiposEvaluacion():\n    tipos = []\n    for tipo in rs1.find(\n        'select', {'id': 'ddlExamen'}\n            ).find_all('option'):\n            if tipo['value'].isdigit():\n            tipos.append([tipo['value'], tipo['text']])\n    return tipos\n", "code_toks_joined": "def getTiposEvaluacion ( ) : <NEWLINE> <INDENT> tipos = [ ] <NEWLINE> for tipo in rs1 . find ( <NEWLINE> <INDENT> <STRING> , { <STRING> : <STRING> } <NEWLINE> <INDENT> ) . find_all ( <STRING> ) : <NEWLINE> if tipo [ <STRING> ] . isdigit ( ) : <NEWLINE> tipos . append ( [ tipo [ <STRING> ] , tipo [ <STRING> ] ] ) <NEWLINE> <DEDENT> <DEDENT> return tipos <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'select'", "'id'", "'ddlExamen'", "'option'", "'value'", "'value'", "'text'"]}, "err_obj": {"msg": "expected an indented block"}}], ["2d0706716048a3efda2c82ee2fc5a24c", {"code_string": "class XmlEventDebug:\n    def start(self, tag, attrib): print '<%s...>' % tag,\n    def end(self, tag):\n        print '</%s>' % tag,\n    def data(self, data):\n        print(data.encode('utf8', 'ignore'), )\n    def close(self): pass\n", "code_toks_joined": "class XmlEventDebug : <NEWLINE> <INDENT> def start ( self , tag , attrib ) : print <STRING> % tag , <NEWLINE> def end ( self , tag ) : <NEWLINE> <INDENT> print <STRING> % tag , <NEWLINE> <DEDENT> def data ( self , data ) : <NEWLINE> <INDENT> print ( data . encode ( <STRING> , <STRING> ) , ) <NEWLINE> <DEDENT> def close ( self ) : pass <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'<%s...>'", "'</%s>'", "'utf8'", "'ignore'"]}, "err_obj": {"msg": "invalid syntax"}}], ["417a146d53ecebee1afd9757aa4d289b", {"code_string": "def test_sinkstate_callable(self):\n    def spam(state = [0]):\n        i = state[0]\n        state[0] = i + 1\n        if i == 10:\n            raise AssertionError, \"shouldn't have gotten this far\"\n        return i\n    b = iter(spam, 5)\n    self.assertEqual(list(b), range(5))\n    self.assertEqual(list(b), [])\n", "code_toks_joined": "def test_sinkstate_callable ( self ) : <NEWLINE> <INDENT> def spam ( state = [ 0 ] ) : <NEWLINE> <INDENT> i = state [ 0 ] <NEWLINE> state [ 0 ] = i + 1 <NEWLINE> if i == 10 : <NEWLINE> <INDENT> raise AssertionError , <STRING> <NEWLINE> <DEDENT> return i <NEWLINE> <DEDENT> b = iter ( spam , 5 ) <NEWLINE> self . assertEqual ( list ( b ) , range ( 5 ) ) <NEWLINE> self . assertEqual ( list ( b ) , [ ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"shouldn't have gotten this far\""]}, "err_obj": {"msg": "invalid syntax"}}], ["1c41b313b0f5e768acd601d552345cb0", {"code_string": "def myi2cWriteBlock(bus, addr, addr2, data):\n    try:\n    bus.write_i2c_block_data(addr, addr2, data)\n    return 1\n    except:\n        print(\"i2c error: addr=\", hex(addr), \" addr2=\", hex(addr2), \" val=\", hex(data[0]))\n        return 0\n", "code_toks_joined": "def myi2cWriteBlock ( bus , addr , addr2 , data ) : <NEWLINE> <INDENT> try : <NEWLINE> bus . write_i2c_block_data ( addr , addr2 , data ) <NEWLINE> return 1 <NEWLINE> except : <NEWLINE> <INDENT> print ( <STRING> , hex ( addr ) , <STRING> , hex ( addr2 ) , <STRING> , hex ( data [ 0 ] ) ) <NEWLINE> return 0 <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"i2c error: addr=\"", "\" addr2=\"", "\" val=\""]}, "err_obj": {"msg": "expected an indented block"}}], ["c23e58625906d4148f1924f3f68564bb", {"code_string": "def initialize_options(self):\n    self.podir = 'po'\n    self.msgmerge = 'msgmerge'\n    self.options = Options()\n        self.escape = 0\n        self.width = 78\n    self.extract_all = 0\n    self.default_domain = None\n    self.keyword = None\n    self.no_default_keywords = 0\n    self.no_location = 0\n    self.style = None\n    self.output = None\n    self.output_dir = None\n        self.docstrings = 0\n    self.exclude_file = None\n        self.all_linguas = []\n", "code_toks_joined": "def initialize_options ( self ) : <NEWLINE> <INDENT> self . podir = <STRING> <NEWLINE> self . msgmerge = <STRING> <NEWLINE> self . options = Options ( ) <NEWLINE> <INDENT> self . escape = 0 <NEWLINE> self . width = 78 <NEWLINE> <DEDENT> self . extract_all = 0 <NEWLINE> self . default_domain = None <NEWLINE> self . keyword = None <NEWLINE> self . no_default_keywords = 0 <NEWLINE> self . no_location = 0 <NEWLINE> self . style = None <NEWLINE> self . output = None <NEWLINE> self . output_dir = None <NEWLINE> <INDENT> self . docstrings = 0 <NEWLINE> <DEDENT> self . exclude_file = None <NEWLINE> <INDENT> self . all_linguas = [ ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'po'", "'msgmerge'"]}, "err_obj": {"msg": "unexpected indent"}}], ["01685b05119f0ae747f7f578ca769939", {"code_string": "def merge(taxonomy_1, taxonomy_2, alignment_graph, rename = ('t1_', 't2_'):\n    union_graph = nx.union(taxonomy_1, taxonomy_2, rename = rename)\n    merge_graph = nx.compose(union_graph, alignment_graph)\n    return merge_graph\n", "code_toks_joined": "def merge ( taxonomy_1 , taxonomy_2 , alignment_graph , rename = ( <STRING> , <STRING> ) : <NEWLINE> <INDENT> union_graph = nx . union ( taxonomy_1 , taxonomy_2 , rename = rename ) <NEWLINE> merge_graph = nx . compose ( union_graph , alignment_graph ) <NEWLINE> return merge_graph <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'t1_'", "'t2_'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["f7b90eb56735ed09074e8af916cbc890", {"code_string": "class Flag1(smach.State):\n    def __init__(self):\n        smach.State.__init__(self, outcomes = ['outcome1', 'outcome2'])\n    def execute(self, userdata):\n    global receivedflag1\n    receivedflag1 = 0\n    rospy.sleep(0.001)\n    rospy.Subscriber('gpl_is_ok', Int8, callback1)\n    if receivedflag1 == 1:\n    global start\n    start = time.time()\n    receivedflag1 = 0\n    return 'outcome1'\n        else:\n    return 'outcome2'\n", "code_toks_joined": "class Flag1 ( smach . State ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> smach . State . __init__ ( self , outcomes = [ <STRING> , <STRING> ] ) <NEWLINE> <DEDENT> def execute ( self , userdata ) : <NEWLINE> global receivedflag1 <NEWLINE> receivedflag1 = 0 <NEWLINE> rospy . sleep ( 0.001 ) <NEWLINE> rospy . Subscriber ( <STRING> , Int8 , callback1 ) <NEWLINE> if receivedflag1 == 1 : <NEWLINE> global start <NEWLINE> start = time . time ( ) <NEWLINE> receivedflag1 = 0 <NEWLINE> return <STRING> <NEWLINE> <INDENT> else : <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'outcome1'", "'outcome2'", "'gpl_is_ok'", "'outcome1'", "'outcome2'"]}, "err_obj": {"msg": "expected an indented block"}}], ["791e8e4d01783bf5a770c398c1fac6bd", {"code_string": "def all_active(user):\n    \"\"\"turn on all feeds\"\"\"\n    try:\n        db_session.query(UserFeeds).filter_by(userid = user.id).update(\n            {\n                \"is_active\": True\n            })\n        db_session.commit()\n    except Exception, e:\n        logger.exception('errrror with existing is_active record. rolling back DB')\n        db_session.rollback()\n", "code_toks_joined": "def all_active ( user ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> db_session . query ( UserFeeds ) . filter_by ( userid = user . id ) . update ( <NEWLINE> <INDENT> { <NEWLINE> <INDENT> <STRING> : True <NEWLINE> <DEDENT> } ) <NEWLINE> <DEDENT> db_session . commit ( ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> logger . exception ( <STRING> ) <NEWLINE> db_session . rollback ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"turn on all feeds\"\"\"", "\"is_active\"", "'errrror with existing is_active record. rolling back DB'"]}, "err_obj": {"msg": "invalid syntax"}}], ["972de7fb3b626305dd774535a66d9057", {"code_string": "def _render_status_text(self, name, status):\n    if not name:\n        name = \"\"\n    return \"%s\\n<small>%s</small>\" %(utf8(name), utf8(status)\n", "code_toks_joined": "def _render_status_text ( self , name , status ) : <NEWLINE> <INDENT> if not name : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> <DEDENT> return <STRING> % ( utf8 ( name ) , utf8 ( status ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"", "\"%s\\n<small>%s</small>\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["862934c51a745d6c8ebcba3c59af676b", {"code_string": "def displayBufferOnScreen(screen, font, buff):\n    if(buff == \"\"):\n    color = const.COLOR_BLACK\n    else:\n    color = const.COLOR_WHITE\n    pygame.draw.rect(screen, color, pygame.rect.Rect(0, 0, 800, 100))\n    screen.blit(font.render(buff, 0, (0, 0, 0)), (10, 10))\n", "code_toks_joined": "def displayBufferOnScreen ( screen , font , buff ) : <NEWLINE> <INDENT> if ( buff == <STRING> ) : <NEWLINE> color = const . COLOR_BLACK <NEWLINE> else : <NEWLINE> color = const . COLOR_WHITE <NEWLINE> pygame . draw . rect ( screen , color , pygame . rect . Rect ( 0 , 0 , 800 , 100 ) ) <NEWLINE> screen . blit ( font . render ( buff , 0 , ( 0 , 0 , 0 ) ) , ( 10 , 10 ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["8a603a48a58a2c4d542c586e778ad906", {"code_string": "def runningAsOSXApp():\n    \"\"\"Returns True if Python is running from within an app on OSX.\"\"\"\n    global _appbundle\n    if _appbundle is None\n        _appbundle = (sys.platform == 'darwin' and '.app' in sys.executable)\n    return _appbundle\n", "code_toks_joined": "def runningAsOSXApp ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> global _appbundle <NEWLINE> if _appbundle is None <NEWLINE> <INDENT> _appbundle = ( sys . platform == <STRING> and <STRING> in sys . executable ) <NEWLINE> <DEDENT> return _appbundle <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns True if Python is running from within an app on OSX.\"\"\"", "'darwin'", "'.app'"]}, "err_obj": {"msg": "invalid syntax"}}], ["2fb9d45051c95acafb05ded47dd8d8a4", {"code_string": "def anagrams_for(word):\n    word_array = array('u', word)\n    [print new_word.tobytes()\n        for new_word in\n            list(itertools.permutations(word_array, word_array.length))\n            if new_word in\n                words.words())]\n", "code_toks_joined": "def anagrams_for ( word ) : <NEWLINE> <INDENT> word_array = array ( <STRING> , word ) <NEWLINE> [ print new_word . tobytes ( ) <NEWLINE> <INDENT> for new_word in <NEWLINE> <INDENT> list ( itertools . permutations ( word_array , word_array . length ) ) <NEWLINE> if new_word in <NEWLINE> <INDENT> words . words ( ) ) ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'u'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["0c5e7d203adc4f1264c1499322e0a4a3", {"code_string": "def __import(importCommand, importCommand2):\n    try:\n        exec importCommand\n    except ImportError:\n        exec importCommand2\n", "code_toks_joined": "def __import ( importCommand , importCommand2 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> exec importCommand <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> exec importCommand2 <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["22cea261877c8a22f30d337ef849656f", {"code_string": "def log(level, s):\n    if level > DEBUG:\n        return\n    print(s.encode('utf8'))\n        print(time.strftime(u\"%Y-%m-%d %H:%M:%S\") + u\" [%d]: %s\" %(\n        os.getpid(),\n        s)).encode(\"utf8\")\n", "code_toks_joined": "def log ( level , s ) : <NEWLINE> <INDENT> if level > DEBUG : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> print ( s . encode ( <STRING> ) ) <NEWLINE> <INDENT> print ( time . strftime ( <STRING> ) + <STRING> % ( <NEWLINE> os . getpid ( ) , <NEWLINE> s ) ) . encode ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'utf8'", "u\"%Y-%m-%d %H:%M:%S\"", "u\" [%d]: %s\"", "\"utf8\""]}, "err_obj": {"msg": "unexpected indent"}}], ["5f0b5e9e36fd9b76c952e16ed012e6d4", {"code_string": "\"\"\"api URL Configuration\"\"\"\nfrom django.conf.urls import url, include\nfrom django.contrib import admin\nurlpatterns = [\n    url(r'^admin/', admin.site.urls),\n    url(r'^auth/', include('rest_auth.urls'))),\n    url(r'^auth/registration', include('rest_auth.registration.urls')),\n]\n", "code_toks_joined": "<STRING> <NEWLINE> from django . conf . urls import url , include <NEWLINE> from django . contrib import admin <NEWLINE> urlpatterns = [ <NEWLINE> <INDENT> url ( <STRING> , admin . site . urls ) , <NEWLINE> url ( <STRING> , include ( <STRING> ) ) ) , <NEWLINE> url ( <STRING> , include ( <STRING> ) ) , <NEWLINE> <DEDENT> ] <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"\"\"api URL Configuration\"\"\"", "r'^admin/'", "r'^auth/'", "'rest_auth.urls'", "r'^auth/registration'", "'rest_auth.registration.urls'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["47f816b5ea5a4fd964d824e76f30b17f", {"code_string": "def PatternPwd(pattern):\n    newpasswd = ''\n    for i in range(len(pattern)):\n    if pattern[i] == 'x':\n        chars = string.ascii_lowercase\n            newpasswd = newpasswd + choice(chars)\n            if pattern[i] == 'X':\n        chars = string.ascii_uppercase\n            newpasswd = newpasswd + choice(chars)\n            if pattern[i] == 'N':\n        chars = string.digits\n            newpasswd = newpasswd + choice(chars)\n    return newpasswd\n", "code_toks_joined": "def PatternPwd ( pattern ) : <NEWLINE> <INDENT> newpasswd = <STRING> <NEWLINE> for i in range ( len ( pattern ) ) : <NEWLINE> if pattern [ i ] == <STRING> : <NEWLINE> <INDENT> chars = string . ascii_lowercase <NEWLINE> <INDENT> newpasswd = newpasswd + choice ( chars ) <NEWLINE> if pattern [ i ] == <STRING> : <NEWLINE> <DEDENT> chars = string . ascii_uppercase <NEWLINE> <INDENT> newpasswd = newpasswd + choice ( chars ) <NEWLINE> if pattern [ i ] == <STRING> : <NEWLINE> <DEDENT> chars = string . digits <NEWLINE> <INDENT> newpasswd = newpasswd + choice ( chars ) <NEWLINE> <DEDENT> <DEDENT> return newpasswd <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "'x'", "'X'", "'N'"]}, "err_obj": {"msg": "expected an indented block"}}], ["1c4358867599acf45bb5836f89306d97", {"code_string": "def commit(self):\n    try:\n        with open(self.fname, 'w') as f:\n            f.write(str(self._second))\n    except OSError, e:\n        CONSUMER_LOG.exception(\n            'Can\\'t open last second file %s: %s' %(\n                self.fname, str(e)))\n", "code_toks_joined": "def commit ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> with open ( self . fname , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( str ( self . _second ) ) <NEWLINE> <DEDENT> <DEDENT> except OSError , e : <NEWLINE> <INDENT> CONSUMER_LOG . exception ( <NEWLINE> <INDENT> <STRING> % ( <NEWLINE> <INDENT> self . fname , str ( e ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'w'", "'Can\\'t open last second file %s: %s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["981e1effb61314e15c820891d790c4d3", {"code_string": "def return_ball(self, ball):\n    \"\"\"Return ball `ball` to the table\"\"\"\n    if ball in self.balls_on_table():\n        return\n    for p in self.players.values()\n        if ball in p.init_balls:\n            p.balls.append(ball)\n            break\n    else:\n        self.unclaimed_balls.balls.append(ball)\n", "code_toks_joined": "def return_ball ( self , ball ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ball in self . balls_on_table ( ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for p in self . players . values ( ) <NEWLINE> <INDENT> if ball in p . init_balls : <NEWLINE> <INDENT> p . balls . append ( ball ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> self . unclaimed_balls . balls . append ( ball ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return ball `ball` to the table\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["2c2f4cce5b4692cdbfd8b267f9a72bb0", {"code_string": "def post(self, id = None):\n    if self.acl_write_check():\n        self.bundle = self.model()\n        self.bundle[\"_id\"] = str(ObjectId(id))\n        self.preprocess_bundle()\n        setattrs = self.set_attrs()\n        if setattrs.get(\"resp\") == 200:\n        return self.save_bundle()\n        else:\n        return bundle_400(setattrs.get(\"msg\"))\n    else:\n        return action_401()\n", "code_toks_joined": "def post ( self , id = None ) : <NEWLINE> <INDENT> if self . acl_write_check ( ) : <NEWLINE> <INDENT> self . bundle = self . model ( ) <NEWLINE> self . bundle [ <STRING> ] = str ( ObjectId ( id ) ) <NEWLINE> self . preprocess_bundle ( ) <NEWLINE> setattrs = self . set_attrs ( ) <NEWLINE> if setattrs . get ( <STRING> ) == 200 : <NEWLINE> return self . save_bundle ( ) <NEWLINE> else : <NEWLINE> return bundle_400 ( setattrs . get ( <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return action_401 ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"_id\"", "\"resp\"", "\"msg\""]}, "err_obj": {"msg": "expected an indented block"}}], ["2814f0f2fe247abfd92ceca85af12fe5", {"code_string": "def requestNextWeek(curWeek):\n    url_planning = self.url + \"faces/Planning.xhtm\"\n    next_WeekData = {'form': 'form', 'javax.faces.ViewState': self.viewState}\n        print(\"\u00f8\")\n", "code_toks_joined": "def requestNextWeek ( curWeek ) : <NEWLINE> <INDENT> url_planning = self . url + <STRING> <NEWLINE> next_WeekData = { <STRING> : <STRING> , <STRING> : self . viewState } <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"faces/Planning.xhtm\"", "'form'", "'form'", "'javax.faces.ViewState'", "\"\u00f8\""]}, "err_obj": {"msg": "unexpected indent"}}], ["c8b00d3febef6a1d92e7215ab51a44b3", {"code_string": "class ExtraTreeClassifier(DecisionTreeClassifier):\n    \"\"\"An extremely randomized tree classifier.\"\"\"\n    def __init__(self,\n        criterion = \"gini\",\n        max_depth = None,\n        min_samples_split = 2,\n        min_samples_leaf = 1,\n        min_density = 0.1,\n        max_features = \"auto\",\n        compute_importances = False,\n        random_state = None):\n        super(ExtraTreeClassifier, self).__init__(criterion,\n            max_depth,\n            min_samples_split,\n            min_samples_leaf,\n            min_density,\n            max_features,\n            compute_importances,\n            random_state)\n            self.find_split_ = _tree.TREE_SPLIT_RANDOM\n", "code_toks_joined": "class ExtraTreeClassifier ( DecisionTreeClassifier ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , <NEWLINE> <INDENT> criterion = <STRING> , <NEWLINE> max_depth = None , <NEWLINE> min_samples_split = 2 , <NEWLINE> min_samples_leaf = 1 , <NEWLINE> min_density = 0.1 , <NEWLINE> max_features = <STRING> , <NEWLINE> compute_importances = False , <NEWLINE> random_state = None ) : <NEWLINE> super ( ExtraTreeClassifier , self ) . __init__ ( criterion , <NEWLINE> <INDENT> max_depth , <NEWLINE> min_samples_split , <NEWLINE> min_samples_leaf , <NEWLINE> min_density , <NEWLINE> max_features , <NEWLINE> compute_importances , <NEWLINE> random_state ) <NEWLINE> self . find_split_ = _tree . TREE_SPLIT_RANDOM <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"An extremely randomized tree classifier.\"\"\"", "\"gini\"", "\"auto\""]}, "err_obj": {"msg": "unexpected indent"}}], ["9dd5d975988b7a5f27438a97f1c7fe1b", {"code_string": "def random_key(self):\n    try:\n        random_key = self.redis_client.randomkey()\n    except Exception, e:\n        return str(e)\n    return random_key\n", "code_toks_joined": "def random_key ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> random_key = self . redis_client . randomkey ( ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> return str ( e ) <NEWLINE> <DEDENT> return random_key <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["a18cba143493ad3d831ac1501c692675", {"code_string": "def post(self, request, * args, ** kwargs):\n    if self.game.status == 'in_progress':\n        self.player = get_object_or_404(Player, game = self.game, active = True, user = request.user)\n        if not self.player.lead_zombie:\n            raise PermissionDenied\n        return super(SendZombieText, self).post(request, * args, ** kwargs)\n        else:\n        raise PermissionDenied\n", "code_toks_joined": "def post ( self , request , * args , ** kwargs ) : <NEWLINE> <INDENT> if self . game . status == <STRING> : <NEWLINE> <INDENT> self . player = get_object_or_404 ( Player , game = self . game , active = True , user = request . user ) <NEWLINE> if not self . player . lead_zombie : <NEWLINE> <INDENT> raise PermissionDenied <NEWLINE> <DEDENT> return super ( SendZombieText , self ) . post ( request , * args , ** kwargs ) <NEWLINE> else : <NEWLINE> raise PermissionDenied <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'in_progress'"]}, "err_obj": {"msg": "invalid syntax"}}], ["7162be0e6f3fa1223b3d3daabe968d03", {"code_string": "def timer():\n    global t0\n    for c in clients:\n        t = time.time() - t0\n        print(t0)\n        c.write_message(json.dumps({'t': t, 'x': 0, 'y': math.sin(t) * 0, 'z': 0 * math.sin(t), 'roll_deg': math.sin(t) * 5, 'pitch_deg': math.cos(t) * 5, 'yaw_deg': 0, 'coordinates': 'EulerAngles'})\n", "code_toks_joined": "def timer ( ) : <NEWLINE> <INDENT> global t0 <NEWLINE> for c in clients : <NEWLINE> <INDENT> t = time . time ( ) - t0 <NEWLINE> print ( t0 ) <NEWLINE> c . write_message ( json . dumps ( { <STRING> : t , <STRING> : 0 , <STRING> : math . sin ( t ) * 0 , <STRING> : 0 * math . sin ( t ) , <STRING> : math . sin ( t ) * 5 , <STRING> : math . cos ( t ) * 5 , <STRING> : 0 , <STRING> : <STRING> } ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'t'", "'x'", "'y'", "'z'", "'roll_deg'", "'pitch_deg'", "'yaw_deg'", "'coordinates'", "'EulerAngles'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["ce1d86737a78e3eae804d3dae8942767", {"code_string": "def check_iteration(self, tko_iterations, pb_iterations):\n    \"\"\"Check if the iteration objects are the same.\"\"\"\n    for tko_iteration, pb_iteration in zip(tko_iterations,\n        pb_iterations):\n        self.assertEqual(tko_iteration.index, pb_iteration.index)\n        self.check_dict(tko_iteration.attr_keyval,\n        self.convert_keyval_to_dict(pb_iteration,\n            'attr_keyval'))\n            self.check_dict(tko_iteration.perf_keyval,\n            self.convert_keyval_to_dict(pb_iteration,\n            'perf_keyval'))\n", "code_toks_joined": "def check_iteration ( self , tko_iterations , pb_iterations ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for tko_iteration , pb_iteration in zip ( tko_iterations , <NEWLINE> <INDENT> pb_iterations ) : <NEWLINE> self . assertEqual ( tko_iteration . index , pb_iteration . index ) <NEWLINE> self . check_dict ( tko_iteration . attr_keyval , <NEWLINE> self . convert_keyval_to_dict ( pb_iteration , <NEWLINE> <INDENT> <STRING> ) ) <NEWLINE> self . check_dict ( tko_iteration . perf_keyval , <NEWLINE> self . convert_keyval_to_dict ( pb_iteration , <NEWLINE> <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Check if the iteration objects are the same.\"\"\"", "'attr_keyval'", "'perf_keyval'"]}, "err_obj": {"msg": "unexpected indent"}}], ["6503c383cc1327eca70f81d4b109542e", {"code_string": "class DummyModelTestCase(TestCase):\n    \"\"\"Tests for the ``DummyModel`` model.\"\"\"\n    def setUp(self):\n    def test_model(self):\n        self.assertTrue(True)\n", "code_toks_joined": "class DummyModelTestCase ( TestCase ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def setUp ( self ) : <NEWLINE> def test_model ( self ) : <NEWLINE> <INDENT> self . assertTrue ( True ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Tests for the ``DummyModel`` model.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["221a162d8936026527e7fdd7d80aff1d", {"code_string": "def write(self):\n    \"\"\" Writes data to files.\"\"\"\n    if self.log_file is not None:\n        for data_type in self.data:\n            with open('{}/{}.{}.csv'.format(self.data_dir, self.log_file,\n                data_type), 'a') as f:\n                for data in self.data[data_type]:\n                f.write(data + '\\n')\n", "code_toks_joined": "def write ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . log_file is not None : <NEWLINE> <INDENT> for data_type in self . data : <NEWLINE> <INDENT> with open ( <STRING> . format ( self . data_dir , self . log_file , <NEWLINE> <INDENT> data_type ) , <STRING> ) as f : <NEWLINE> for data in self . data [ data_type ] : <NEWLINE> f . write ( data + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Writes data to files.\"\"\"", "'{}/{}.{}.csv'", "'a'", "'\\n'"]}, "err_obj": {"msg": "expected an indented block"}}], ["b215f3b19fcd390cfb31e71654bbc5c6", {"code_string": "def read_maps(self, db):\n    for row in db.conn.execute(\n        'SELECT book, {0} FROM {1}'.format(\n            self.metadata['link_column'], self.link_table)):\n            if row[1] not in self.col_book_map:\n        self.col_book_map[row[1]] = set()\n        self.col_book_map[row[1]].add(row[0])\n        self.book_col_map[row[0]] = row[1]\n", "code_toks_joined": "def read_maps ( self , db ) : <NEWLINE> <INDENT> for row in db . conn . execute ( <NEWLINE> <INDENT> <STRING> . format ( <NEWLINE> <INDENT> self . metadata [ <STRING> ] , self . link_table ) ) : <NEWLINE> if row [ 1 ] not in self . col_book_map : <NEWLINE> <DEDENT> self . col_book_map [ row [ 1 ] ] = set ( ) <NEWLINE> self . col_book_map [ row [ 1 ] ] . add ( row [ 0 ] ) <NEWLINE> self . book_col_map [ row [ 0 ] ] = row [ 1 ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'SELECT book, {0} FROM {1}'", "'link_column'"]}, "err_obj": {"msg": "unindent does not match any outer indentation level"}}], ["9dff908e1a5563e1ba81e7f7566ad5a7", {"code_string": "def queue_edit(quality, imdb_id = None, tmdb_id = None, session = None):\n    \"\"\": param quality: Change the required quality for a movie in the queue\"\"\"\n    try:\n        item = session.query(QueuedMovie).filter(QueuedMovie.imdb_id == imdb_id).one()\n        item.quality = quality\n        return item.title\n    except NoResultFound as e:\n        raise QueueError('imdb_id=%s, tmdb_id=%s not found from queue' %(imdb_id, tmdb_id)\n", "code_toks_joined": "def queue_edit ( quality , imdb_id = None , tmdb_id = None , session = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> item = session . query ( QueuedMovie ) . filter ( QueuedMovie . imdb_id == imdb_id ) . one ( ) <NEWLINE> item . quality = quality <NEWLINE> return item . title <NEWLINE> <DEDENT> except NoResultFound as e : <NEWLINE> <INDENT> raise QueueError ( <STRING> % ( imdb_id , tmdb_id ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\": param quality: Change the required quality for a movie in the queue\"\"\"", "'imdb_id=%s, tmdb_id=%s not found from queue'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["9ef4c93b9ec56ccbb7aef0ba1307a3cf", {"code_string": "def __str__(self):\n    str = [\"Axes: %s\" % self.axesOri,\n        \"Axes orientation: %s\" %\n        self.__axesOriName[self.__axesOri[self._axesOri]]\n        \"Bearing orientation: %s\" % self.bearingOri]\n    return \"\\n\".join(str)\n", "code_toks_joined": "def __str__ ( self ) : <NEWLINE> <INDENT> str = [ <STRING> % self . axesOri , <NEWLINE> <INDENT> <STRING> % <NEWLINE> self . __axesOriName [ self . __axesOri [ self . _axesOri ] ] <NEWLINE> <STRING> % self . bearingOri ] <NEWLINE> <DEDENT> return <STRING> . join ( str ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Axes: %s\"", "\"Axes orientation: %s\"", "\"Bearing orientation: %s\"", "\"\\n\""]}, "err_obj": {"msg": "invalid syntax"}}], ["5b234c32a177ebafbb6d285c3d5d154d", {"code_string": "for aaa in range(0, 10):\nfor bbb in range(0.0, 10.0):\n", "code_toks_joined": "for aaa in range ( 0 , 10 ) : <NEWLINE> for bbb in range ( 0.0 , 10.0 ) : <NEWLINE>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["d7be9c2da6c3c03682a3b54582207398", {"code_string": "def add_commit(repo, path):\n    \"\"\" adds given file to commit and commits it\"\"\"\n    repo.git.add(path)\n    repo.git.commit(m = 'Jupyter autocommit: {}'.format(path)\n", "code_toks_joined": "def add_commit ( repo , path ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> repo . git . add ( path ) <NEWLINE> repo . git . commit ( m = <STRING> . format ( path ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" adds given file to commit and commits it\"\"\"", "'Jupyter autocommit: {}'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["2390aabf6b908d0837c47f23823081e5", {"code_string": "def get_source_version(source_root):\n    try:\n        with open(os.path.join(source_root, 'version.txt')) as f:\n            version = f.readline().strip()\n    except(IOError, OSError), e:\n        abort('Error reading version.txt from \"%s\".' % source_root, e)\n    assert version is not None\n    return version\n", "code_toks_joined": "def get_source_version ( source_root ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> with open ( os . path . join ( source_root , <STRING> ) ) as f : <NEWLINE> <INDENT> version = f . readline ( ) . strip ( ) <NEWLINE> <DEDENT> <DEDENT> except ( IOError , OSError ) , e : <NEWLINE> <INDENT> abort ( <STRING> % source_root , e ) <NEWLINE> <DEDENT> assert version is not None <NEWLINE> return version <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'version.txt'", "'Error reading version.txt from \"%s\".'"]}, "err_obj": {"msg": "invalid syntax"}}], ["2628c58e56efa78f3576c00733d662b0", {"code_string": "def run(self, option_dict = None):\n    cmd = [self.executable]\n    if option_dict:\n        for key, value in option_dict.items():\n        value = option_dict[key]\n        self.opt_dict[key] = value\n    for key, value in self.opt_dict.items():\n        cmd.extend([key, value])\n            if self.running:\n                self.stop()\n            self.running = True\n    self.child = Popen(cmd)\n    return self.child\n", "code_toks_joined": "def run ( self , option_dict = None ) : <NEWLINE> <INDENT> cmd = [ self . executable ] <NEWLINE> if option_dict : <NEWLINE> <INDENT> for key , value in option_dict . items ( ) : <NEWLINE> value = option_dict [ key ] <NEWLINE> self . opt_dict [ key ] = value <NEWLINE> <DEDENT> for key , value in self . opt_dict . items ( ) : <NEWLINE> <INDENT> cmd . extend ( [ key , value ] ) <NEWLINE> <INDENT> if self . running : <NEWLINE> <INDENT> self . stop ( ) <NEWLINE> <DEDENT> self . running = True <NEWLINE> <DEDENT> <DEDENT> self . child = Popen ( cmd ) <NEWLINE> return self . child <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["eb03ff77b6cb4b0aeede2ef66ed94e04", {"code_string": "class ConfigOption:\n    def __init__(self, name, default_value = None, required = False,\n        description = None, data_type = None):\n        self.name = name\n        self.default_value = default_value\n        self.required = required\n        self.description = description\n        if data_type is None and self.default_value is not None:\n        self.data_type = type(self.default_value)\n        elif data_type is None:\n        self.data_type = str\n        else:\n        self.data_type = data_type\n", "code_toks_joined": "class ConfigOption : <NEWLINE> <INDENT> def __init__ ( self , name , default_value = None , required = False , <NEWLINE> <INDENT> description = None , data_type = None ) : <NEWLINE> self . name = name <NEWLINE> self . default_value = default_value <NEWLINE> self . required = required <NEWLINE> self . description = description <NEWLINE> if data_type is None and self . default_value is not None : <NEWLINE> self . data_type = type ( self . default_value ) <NEWLINE> elif data_type is None : <NEWLINE> self . data_type = str <NEWLINE> else : <NEWLINE> self . data_type = data_type <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["8e3a0e032eff72e8584a71238e8263b6", {"code_string": "class Monitor:\n    def __init__(self):\n        self.exit = False\n    def __del__(self):\n    return\n    def waitForAbort(self, t):\n        if self.exit:\n            return True\n        time.sleep(t)\n        return False\n    def setAbort(self):\n        self.exit = True\n", "code_toks_joined": "class Monitor : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . exit = False <NEWLINE> <DEDENT> def __del__ ( self ) : <NEWLINE> return <NEWLINE> def waitForAbort ( self , t ) : <NEWLINE> <INDENT> if self . exit : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> time . sleep ( t ) <NEWLINE> return False <NEWLINE> <DEDENT> def setAbort ( self ) : <NEWLINE> <INDENT> self . exit = True <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["dc426a62fed375dc03fdc922ba66d03e", {"code_string": "def voidresp(self):\n    \"\"\"Expect a response beginning with '2'.\"\"\"\n    resp = self.getresp()\n    if resp[: 1] != '2':\n        raise error_reply, resp\n    return resp\n", "code_toks_joined": "def voidresp ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> resp = self . getresp ( ) <NEWLINE> if resp [ : 1 ] != <STRING> : <NEWLINE> <INDENT> raise error_reply , resp <NEWLINE> <DEDENT> return resp <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Expect a response beginning with '2'.\"\"\"", "'2'"]}, "err_obj": {"msg": "invalid syntax"}}], ["ad6f712dae942eab6c79e9533b1b07a9", {"code_string": "def main()\n    configuration = Configuration()\n    options = parse_command_line(configuration)\n    send_message(options, configuration)\n", "code_toks_joined": "def main ( ) <NEWLINE> <INDENT> configuration = Configuration ( ) <NEWLINE> options = parse_command_line ( configuration ) <NEWLINE> send_message ( options , configuration ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["1f46007e7976175b390ee4a1aef807d4", {"code_string": "class LoggingReceiver(SocketServer.ThreadingTCPServer):\n    'Simple TCP socket-based logging receiver'\n    logname = None\n    def __init__(self, host = 'localhost',\n        port = None,\n        handler = LogRecordStreamHandler):\n        if port is None:\n        port = logging.handlers.DEFAULT_TCP_LOGGING_PORT\n        SocketServer.ThreadingTCPServer.__init__(self, (host, port), handler)\n", "code_toks_joined": "class LoggingReceiver ( SocketServer . ThreadingTCPServer ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> logname = None <NEWLINE> def __init__ ( self , host = <STRING> , <NEWLINE> <INDENT> port = None , <NEWLINE> handler = LogRecordStreamHandler ) : <NEWLINE> if port is None : <NEWLINE> port = logging . handlers . DEFAULT_TCP_LOGGING_PORT <NEWLINE> SocketServer . ThreadingTCPServer . __init__ ( self , ( host , port ) , handler ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Simple TCP socket-based logging receiver'", "'localhost'"]}, "err_obj": {"msg": "expected an indented block"}}], ["5c5a157469903b4a971fac752f7ace24", {"code_string": "def GetRawCharFunction():\n    \"\"\"Returns a function that reads one character from stdin with no echo.\"\"\"\n    for get_raw_char_function in(_GetRawCharFunctionPosix,\n        _GetRawCharFunctionWindows):\n        try:\n        return get_raw_char_function()\n        except:\n        pass\n    return lambda: None\n", "code_toks_joined": "def GetRawCharFunction ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for get_raw_char_function in ( _GetRawCharFunctionPosix , <NEWLINE> <INDENT> _GetRawCharFunctionWindows ) : <NEWLINE> try : <NEWLINE> return get_raw_char_function ( ) <NEWLINE> except : <NEWLINE> pass <NEWLINE> <DEDENT> return lambda : None <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns a function that reads one character from stdin with no echo.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["898e1ccf9f494f5d7f2e2c3449ce60e7", {"code_string": "def setUp(self):\n    wiki = WikiPage(self.env)\n    wiki.name = 'WikiStart'\n    wiki.text = '--'\n    wiki.save('joe', 'Entry page', ': :1', datetime.now(utc)\n    if self._setup:\n        self._setup(self)\n", "code_toks_joined": "def setUp ( self ) : <NEWLINE> <INDENT> wiki = WikiPage ( self . env ) <NEWLINE> wiki . name = <STRING> <NEWLINE> wiki . text = <STRING> <NEWLINE> wiki . save ( <STRING> , <STRING> , <STRING> , datetime . now ( utc ) <NEWLINE> if self . _setup : <NEWLINE> <INDENT> self . _setup ( self ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'WikiStart'", "'--'", "'joe'", "'Entry page'", "': :1'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["62d08add9b5cfd676c07b0433018aa1a", {"code_string": "def __eq__(self, other):\n    \"\"\"Two elements are equals when they are the same type() and the same id\"\"\"\n    if type(self) == type(other):\n    return self.getId() == other.getId()\n    else:\n    return False\n", "code_toks_joined": "def __eq__ ( self , other ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if type ( self ) == type ( other ) : <NEWLINE> return self . getId ( ) == other . getId ( ) <NEWLINE> else : <NEWLINE> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Two elements are equals when they are the same type() and the same id\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["69f4fa36926cb8759a8dfb4e3d892972", {"code_string": "def fake_get_object(self, context, model, ** kwargs):\n    objects = self.model_map[model]\n    if not objects:\n        return None\n    return[obj for obj in objects if obj['id'] == kwargs['id'][0]\n", "code_toks_joined": "def fake_get_object ( self , context , model , ** kwargs ) : <NEWLINE> <INDENT> objects = self . model_map [ model ] <NEWLINE> if not objects : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> return [ obj for obj in objects if obj [ <STRING> ] == kwargs [ <STRING> ] [ 0 ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'id'", "'id'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["47de1268e9e3ee383c5ac7df09877634", {"code_string": "def test_guest_log_action_publish_user(self):\n    with patch.object(manager.Manager, 'guest_log_enable',\n        return_value = False) as mock_enable:\n        with patch.object(os.path, 'isfile', return_value = True):\n        log_details = self.manager.guest_log_action(self.context,\n            self.log_name_user,\n            False, False,\n            True, False)\n            assert_equal(log_details, self.expected_details_user,\n            \"Wrong details: %s (expected %s)\" %\n            (log_details, self.expected_details_user))\n            assert_equal(1, mock_enable.call_count)\n", "code_toks_joined": "def test_guest_log_action_publish_user ( self ) : <NEWLINE> <INDENT> with patch . object ( manager . Manager , <STRING> , <NEWLINE> <INDENT> return_value = False ) as mock_enable : <NEWLINE> with patch . object ( os . path , <STRING> , return_value = True ) : <NEWLINE> log_details = self . manager . guest_log_action ( self . context , <NEWLINE> <INDENT> self . log_name_user , <NEWLINE> False , False , <NEWLINE> True , False ) <NEWLINE> assert_equal ( log_details , self . expected_details_user , <NEWLINE> <STRING> % <NEWLINE> ( log_details , self . expected_details_user ) ) <NEWLINE> assert_equal ( 1 , mock_enable . call_count ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'guest_log_enable'", "'isfile'", "\"Wrong details: %s (expected %s)\""]}, "err_obj": {"msg": "expected an indented block"}}], ["2ba3da7e6818d21f839294e133fedb06", {"code_string": "def get_device_BDF(self, device_name):\n    device = self.Cfg.CONFIG_PCI[device_name]\n    if device is None or device =={}: raise DeviceNotFoundError, ('DeviceNotFound: %s' % device_name)\n    b = int(device['bus'], 16)\n    d = int(device['dev'], 16)\n    f = int(device['fun'], 16)\n    return(b, d, f)\n", "code_toks_joined": "def get_device_BDF ( self , device_name ) : <NEWLINE> <INDENT> device = self . Cfg . CONFIG_PCI [ device_name ] <NEWLINE> if device is None or device == { } : raise DeviceNotFoundError , ( <STRING> % device_name ) <NEWLINE> b = int ( device [ <STRING> ] , 16 ) <NEWLINE> d = int ( device [ <STRING> ] , 16 ) <NEWLINE> f = int ( device [ <STRING> ] , 16 ) <NEWLINE> return ( b , d , f ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'DeviceNotFound: %s'", "'bus'", "'dev'", "'fun'"]}, "err_obj": {"msg": "invalid syntax"}}], ["a53e132f3e279b917abc5ef8359cc354", {"code_string": "def xm_vbfs_attach(args):\n    arg_check(args, 'vbfs-attach', 2, 3)\n    dom = args[0]\n    vbfs = ['vbfs']\n    if len(args) == 3:\n    vbfs.append(['backend', args[2]])\n    vbfs.append(args[1].split(\"=\"))\n    server.xend.domain.device_create(dom, vbfs)\n", "code_toks_joined": "def xm_vbfs_attach ( args ) : <NEWLINE> <INDENT> arg_check ( args , <STRING> , 2 , 3 ) <NEWLINE> dom = args [ 0 ] <NEWLINE> vbfs = [ <STRING> ] <NEWLINE> if len ( args ) == 3 : <NEWLINE> vbfs . append ( [ <STRING> , args [ 2 ] ] ) <NEWLINE> vbfs . append ( args [ 1 ] . split ( <STRING> ) ) <NEWLINE> server . xend . domain . device_create ( dom , vbfs ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'vbfs-attach'", "'vbfs'", "'backend'", "\"=\""]}, "err_obj": {"msg": "expected an indented block"}}], ["4fbe2f1c4abe0e66e586d16e0b3450a0", {"code_string": "def set_border_width(self, value):\n    \"sets the border width in points\"\n        self.borderwidth = value\n", "code_toks_joined": "def set_border_width ( self , value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> self . borderwidth = value <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"sets the border width in points\""]}, "err_obj": {"msg": "unexpected indent"}}], ["1de6f4d6f27c3b8057c8103c7f80578a", {"code_string": "def __setattr__(self, attr, value):\n    if attr in{'nus', 'bunlen', 'emitx', 'emity', 'espread', }:\n        if isinstance(value, (_np.ndarray, list, tuple) and len(value) != len(self.cur_bun):\n            raise Exception('Length of input must match length of self.cur_bun.')\n        self.__dict__['_' + attr] = value\n    else:\n        self.__dict__[attr] = value\n", "code_toks_joined": "def __setattr__ ( self , attr , value ) : <NEWLINE> <INDENT> if attr in { <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , } : <NEWLINE> <INDENT> if isinstance ( value , ( _np . ndarray , list , tuple ) and len ( value ) != len ( self . cur_bun ) : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> self . __dict__ [ <STRING> + attr ] = value <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . __dict__ [ attr ] = value <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'nus'", "'bunlen'", "'emitx'", "'emity'", "'espread'", "'Length of input must match length of self.cur_bun.'", "'_'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["eae1712d0bc9a9cf7f30f0f6f31a0b1a", {"code_string": "class FileRepository(object):\n    def find_file(self host, filename\n    ):\n    \"\"\"returns a list of tuples (host, location)\"\"\"\n", "code_toks_joined": "class FileRepository ( object ) : <NEWLINE> <INDENT> def find_file ( self host , filename <NEWLINE> ) : <NEWLINE> <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"returns a list of tuples (host, location)\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["0dc9a604a1e8c50393b715d0c99996a9", {"code_string": "class runlength_smearing(PluginFunction):\n    \"\"\"Segments a page with the *Run Length Smearing* algorithm.\"\"\"\n    self_type = ImageType([ONEBIT])\n    return_type = ImageList(\"ccs\")\n    args = Args([Int('Cx', default = - 1), Int('Cy', default = - 1), Int('Csm', default = - 1)])\n    author = \"Christoph Dalitz and Iliya Stoyanov\"\n    def __call__(image, Cx = - 1, Cy = - 1, Csm = - 1):\n    return _pagesegmentation.runlength_smearing(image, Cx, Cy, Csm)\n    __call__ = staticmethod(__call__)\n", "code_toks_joined": "class runlength_smearing ( PluginFunction ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self_type = ImageType ( [ ONEBIT ] ) <NEWLINE> return_type = ImageList ( <STRING> ) <NEWLINE> args = Args ( [ Int ( <STRING> , default = - 1 ) , Int ( <STRING> , default = - 1 ) , Int ( <STRING> , default = - 1 ) ] ) <NEWLINE> author = <STRING> <NEWLINE> def __call__ ( image , Cx = - 1 , Cy = - 1 , Csm = - 1 ) : <NEWLINE> return _pagesegmentation . runlength_smearing ( image , Cx , Cy , Csm ) <NEWLINE> __call__ = staticmethod ( __call__ ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Segments a page with the *Run Length Smearing* algorithm.\"\"\"", "\"ccs\"", "'Cx'", "'Cy'", "'Csm'", "\"Christoph Dalitz and Iliya Stoyanov\""]}, "err_obj": {"msg": "expected an indented block"}}], ["55827d1f277a593185b41046f8952fe3", {"code_string": "def get_records_with_attachments(attachment_table, rel_object_field = \"REL_OBJECTID\"):\n    \"\"\"returns a list of ObjectIDs for rows in the attachment table\"\"\"\n    if arcpyFound == False:\n        raise Exception(\"ArcPy is required to use this function\")\n    OIDs = []\n    with arcpy.da.SearchCursor(attachment_table,\n        [rel_object_field]) as rows:\n        for row in rows:\n        if not str(row[0]) in OIDs:\n        OIDs.append(\"%s\" % str(row[0]))\n        del row\n    del rows\n    return OIDs\n", "code_toks_joined": "def get_records_with_attachments ( attachment_table , rel_object_field = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if arcpyFound == False : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> OIDs = [ ] <NEWLINE> with arcpy . da . SearchCursor ( attachment_table , <NEWLINE> <INDENT> [ rel_object_field ] ) as rows : <NEWLINE> for row in rows : <NEWLINE> if not str ( row [ 0 ] ) in OIDs : <NEWLINE> OIDs . append ( <STRING> % str ( row [ 0 ] ) ) <NEWLINE> del row <NEWLINE> <DEDENT> del rows <NEWLINE> return OIDs <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"REL_OBJECTID\"", "\"\"\"returns a list of ObjectIDs for rows in the attachment table\"\"\"", "\"ArcPy is required to use this function\"", "\"%s\""]}, "err_obj": {"msg": "expected an indented block"}}], ["4ad33239918ee4bbddf187e4f0c1b3b1", {"code_string": "def standoff_main(words, docid):\n    global output_directory\n    output_directory = None\n    fail_count = 0\n    try:\n    process(words, docid)\n    except Exception, e:\n    print(\"Error processing, %s\" %(e))\n    fail_count += 1\n    if fail_count > 0:\n        print(\"\"\"\"\"\" %(fail_count))\n    return 0\n", "code_toks_joined": "def standoff_main ( words , docid ) : <NEWLINE> <INDENT> global output_directory <NEWLINE> output_directory = None <NEWLINE> fail_count = 0 <NEWLINE> try : <NEWLINE> process ( words , docid ) <NEWLINE> except Exception , e : <NEWLINE> print ( <STRING> % ( e ) ) <NEWLINE> fail_count += 1 <NEWLINE> if fail_count > 0 : <NEWLINE> <INDENT> print ( <STRING> % ( fail_count ) ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Error processing, %s\"", "\"\"\"\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["91402fbe656fdb63c80ce609f442a8d1", {"code_string": "import unittest\nimport types\nfrom mock import MagicMock\nfrom mock import patch\nfrom xscontainer.util import tls_secret\ndef _add_vm_other_config_record(vm_records, vm_uuid, other_config_key,\n    other_config_value):\n    if not isinstance(vm_records, types.DictType):\n    vm_records = {}\n    if vm_uuid not in vm_records:\n    vm_records[vm_uuid] = {}\n    if 'other_config' not in vm_records[vm_uuid]:\n    vm_records[vm_uuid]['other_config'] = {}\n    vm_records[vm_uuid]['other_config'][other_config_key] = other_config_value\n", "code_toks_joined": "import unittest <NEWLINE> import types <NEWLINE> from mock import MagicMock <NEWLINE> from mock import patch <NEWLINE> from xscontainer . util import tls_secret <NEWLINE> def _add_vm_other_config_record ( vm_records , vm_uuid , other_config_key , <NEWLINE> <INDENT> other_config_value ) : <NEWLINE> if not isinstance ( vm_records , types . DictType ) : <NEWLINE> vm_records = { } <NEWLINE> if vm_uuid not in vm_records : <NEWLINE> vm_records [ vm_uuid ] = { } <NEWLINE> if <STRING> not in vm_records [ vm_uuid ] : <NEWLINE> vm_records [ vm_uuid ] [ <STRING> ] = { } <NEWLINE> vm_records [ vm_uuid ] [ <STRING> ] [ other_config_key ] = other_config_value <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'other_config'", "'other_config'", "'other_config'"]}, "err_obj": {"msg": "expected an indented block"}}], ["37bdd3c869b9d605a7a7250d4a9ab84b", {"code_string": "def convertToStr(self, value, type):\n    if value is not None:\n        if type == 'date':\n        return value.isoformat()\n        elif type == 'datetime':\n        return value.strftime('%Y-%m-%d %H:%M:%S')\n        else:\n        return str(value)\n    return ''\n", "code_toks_joined": "def convertToStr ( self , value , type ) : <NEWLINE> <INDENT> if value is not None : <NEWLINE> <INDENT> if type == <STRING> : <NEWLINE> return value . isoformat ( ) <NEWLINE> elif type == <STRING> : <NEWLINE> return value . strftime ( <STRING> ) <NEWLINE> else : <NEWLINE> return str ( value ) <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'date'", "'datetime'", "'%Y-%m-%d %H:%M:%S'", "''"]}, "err_obj": {"msg": "expected an indented block"}}], ["18bb041eb6b1e18389f5fe47c7f34d40", {"code_string": "def test_mpsk_snr_est_svn(self):\n    expected_result = [10.92, 6.02, 4.78, 4.98, 5.51]\n        N = 10000\n        alpha = 0.001\n        op = digital.mpsk_snr_est_cc(digital.SNR_EST_SVR, N, alpha)\n        actual_result = self.mpsk_snr_est_setup(op)\n        self.assertFloatTuplesAlmostEqual(expected_result, actual_result, 2)\n", "code_toks_joined": "def test_mpsk_snr_est_svn ( self ) : <NEWLINE> <INDENT> expected_result = [ 10.92 , 6.02 , 4.78 , 4.98 , 5.51 ] <NEWLINE> <INDENT> N = 10000 <NEWLINE> alpha = 0.001 <NEWLINE> op = digital . mpsk_snr_est_cc ( digital . SNR_EST_SVR , N , alpha ) <NEWLINE> actual_result = self . mpsk_snr_est_setup ( op ) <NEWLINE> self . assertFloatTuplesAlmostEqual ( expected_result , actual_result , 2 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["c2b3f795105c1f4c977baf0cb23ffcac", {"code_string": "def specialized_langinfo_from_content(self, li, text):\n    hints, specialized_li = self._specialization_hints_from_lang.get(\n        li.name, (None, None)\n    if not hints:\n        return None\n    for hint_str, hint_re in hints:\n        if hint_str not in text:\n            continue\n        if hint_re and not hint_re.search(text):\n            continue\n        return specialized_li\n    return None\n", "code_toks_joined": "def specialized_langinfo_from_content ( self , li , text ) : <NEWLINE> <INDENT> hints , specialized_li = self . _specialization_hints_from_lang . get ( <NEWLINE> <INDENT> li . name , ( None , None ) <NEWLINE> <DEDENT> if not hints : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> for hint_str , hint_re in hints : <NEWLINE> <INDENT> if hint_str not in text : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if hint_re and not hint_re . search ( text ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> return specialized_li <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["fae8b51b9e892013bc9ba54ca803249f", {"code_string": "def print_packet(self):\n    if self.oper == 1:\n        print('where is %s? Tell %s' %(self.dip, self.sip))\n    if self.oper == 2:\n        print('%s is at %s' %(self.sip, self.smac)\n", "code_toks_joined": "def print_packet ( self ) : <NEWLINE> <INDENT> if self . oper == 1 : <NEWLINE> <INDENT> print ( <STRING> % ( self . dip , self . sip ) ) <NEWLINE> <DEDENT> if self . oper == 2 : <NEWLINE> <INDENT> print ( <STRING> % ( self . sip , self . smac ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'where is %s? Tell %s'", "'%s is at %s'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["68c9006082297b33bc99bfa662817d2b", {"code_string": "def errback(self, e, info):\n    \"\"\"Error callback.\"\"\"\n    e.trap(Exception)\n    print(\"AMP Error for %(info)s: %(e)s\" %{'info': info,\n        'e': e.getErrorMessage()}\n", "code_toks_joined": "def errback ( self , e , info ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> e . trap ( Exception ) <NEWLINE> print ( <STRING> % { <STRING> : info , <NEWLINE> <INDENT> <STRING> : e . getErrorMessage ( ) } <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Error callback.\"\"\"", "\"AMP Error for %(info)s: %(e)s\"", "'info'", "'e'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["3b1f9f5272c6a1b96883668d7a5b7c68", {"code_string": "def process_commkit(self, commkit_data):\n    \"\"\" Household Major Revision \"\"\"\n    household_ids = list()\n    household_mapping = HouseHoldMapping(self.env)\n    for household_data in commkit_data.get('BeneficiaryHouseholdList',\n        [commkit_data]):\n        household = self.search([\n        ('household_id', '=', household_data.get('Household_ID'))])\n        if household:\n        household_ids.append(household.id)\n        household_vals = household_mapping.get_vals_from_connect(\n        household_data)\n        household._major_revision(household_vals)\n    return household_ids\n", "code_toks_joined": "def process_commkit ( self , commkit_data ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> household_ids = list ( ) <NEWLINE> household_mapping = HouseHoldMapping ( self . env ) <NEWLINE> for household_data in commkit_data . get ( <STRING> , <NEWLINE> <INDENT> [ commkit_data ] ) : <NEWLINE> household = self . search ( [ <NEWLINE> ( <STRING> , <STRING> , household_data . get ( <STRING> ) ) ] ) <NEWLINE> if household : <NEWLINE> household_ids . append ( household . id ) <NEWLINE> household_vals = household_mapping . get_vals_from_connect ( <NEWLINE> household_data ) <NEWLINE> household . _major_revision ( household_vals ) <NEWLINE> <DEDENT> return household_ids <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Household Major Revision \"\"\"", "'BeneficiaryHouseholdList'", "'household_id'", "'='", "'Household_ID'"]}, "err_obj": {"msg": "expected an indented block"}}], ["477fce24e679589520287f5e3ac2ebd2", {"code_string": "class TestUtilsEnvironment(unittest.TestCase):\n    \"\"\"Test utils functions.\"\"\"\n    def test_program_version(self):\n        self.assertEqual({{cookiecutter.package_name}} _version(), __version__)\n    def test_python_version(self):\n        self.assertIn(python_version(), shell_python())\n    def test_python_major_version(self):\n        self.assertEqual(python_version('major'), '3')\n", "code_toks_joined": "class TestUtilsEnvironment ( unittest . TestCase ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def test_program_version ( self ) : <NEWLINE> <INDENT> self . assertEqual ( { { cookiecutter . package_name } } _version ( ) , __version__ ) <NEWLINE> <DEDENT> def test_python_version ( self ) : <NEWLINE> <INDENT> self . assertIn ( python_version ( ) , shell_python ( ) ) <NEWLINE> <DEDENT> def test_python_major_version ( self ) : <NEWLINE> <INDENT> self . assertEqual ( python_version ( <STRING> ) , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Test utils functions.\"\"\"", "'major'", "'3'"]}, "err_obj": {"msg": "invalid syntax"}}], ["ddff19214e333a7c4f98b339013d9e74", {"code_string": "def set_default_headers(self):\n    self.set_header(\"Access-Control-Allow-Origin\", \"*\")\n        def check_origin(self, origin):\n            if 'localhost' in origin or self.domain in origin:\n                return True\n            return False\n", "code_toks_joined": "def set_default_headers ( self ) : <NEWLINE> <INDENT> self . set_header ( <STRING> , <STRING> ) <NEWLINE> <INDENT> def check_origin ( self , origin ) : <NEWLINE> <INDENT> if <STRING> in origin or self . domain in origin : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Access-Control-Allow-Origin\"", "\"*\"", "'localhost'"]}, "err_obj": {"msg": "unexpected indent"}}], ["8b5b76944e4d4240d820a05b9c8d22db", {"code_string": "class FwdCashManager(InstrumentManager):\n    def get_data(self, id,\n        curncy = '',\n        value_date = None,\n        ** kwargs):\n        data = super(FwdCashManager, self).get_data(id, ** kwargs)\n        value_date = convert('bonddate', value_date)\n        data.update({'curncy': convert('curncy', curncy),\n            'value_date': value_date})\n            return data\n", "code_toks_joined": "class FwdCashManager ( InstrumentManager ) : <NEWLINE> <INDENT> def get_data ( self , id , <NEWLINE> <INDENT> curncy = <STRING> , <NEWLINE> value_date = None , <NEWLINE> ** kwargs ) : <NEWLINE> data = super ( FwdCashManager , self ) . get_data ( id , ** kwargs ) <NEWLINE> value_date = convert ( <STRING> , value_date ) <NEWLINE> data . update ( { <STRING> : convert ( <STRING> , curncy ) , <NEWLINE> <INDENT> <STRING> : value_date } ) <NEWLINE> return data <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "'bonddate'", "'curncy'", "'curncy'", "'value_date'"]}, "err_obj": {"msg": "unexpected indent"}}], ["03463b63c6b0dd01d35c93d7a92f7ed3", {"code_string": "def get_alarms():\n    alarm_vals = np.zeros(len(blm_names))\n    for i in xrange(len(blm_names)):\n    blm_channel = blms[i].id + '/CH00.TD'\n    h = np.array(dcs.get_device_td(blm_channel))\n        blm_alarm_ch = blms[i].id.replace('BLM', 'BLM.ALARM') + '/THRFHI'\n        alarm_val = dcs.get_device_val(blm_alarm_ch) * 1.25e-3\n        alarm_vals[i] = np.max(np.abs(h)) / alarm_val\n    return alarm_vals\n", "code_toks_joined": "def get_alarms ( ) : <NEWLINE> <INDENT> alarm_vals = np . zeros ( len ( blm_names ) ) <NEWLINE> for i in xrange ( len ( blm_names ) ) : <NEWLINE> blm_channel = blms [ i ] . id + <STRING> <NEWLINE> h = np . array ( dcs . get_device_td ( blm_channel ) ) <NEWLINE> <INDENT> blm_alarm_ch = blms [ i ] . id . replace ( <STRING> , <STRING> ) + <STRING> <NEWLINE> alarm_val = dcs . get_device_val ( blm_alarm_ch ) * 1.25e-3 <NEWLINE> alarm_vals [ i ] = np . max ( np . abs ( h ) ) / alarm_val <NEWLINE> <DEDENT> return alarm_vals <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'/CH00.TD'", "'BLM'", "'BLM.ALARM'", "'/THRFHI'"]}, "err_obj": {"msg": "expected an indented block"}}], ["7057afcda55323ec0ec1673e458fc053", {"code_string": "from django.conf.urls.defaults import patterns, include, url\nurlpatterns = patterns('',\n    url(r'^', include('thesaurus.urls'),\n)\n", "code_toks_joined": "from django . conf . urls . defaults import patterns , include , url <NEWLINE> urlpatterns = patterns ( <STRING> , <NEWLINE> <INDENT> url ( <STRING> , include ( <STRING> ) , <NEWLINE> <DEDENT> ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["''", "r'^'", "'thesaurus.urls'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["03b3e26147fbfd196ab04f7bd7967f34", {"code_string": "class FlashLayerCodeUpdate(FlashAssetCodeUpdate):\n    SEARCH_TYPE = 'flash/layer'\n    def get_default_code(my):\n        return \"flash-layer_default\"\n    def get_naming(my):\n        return FlashLayerNaming()\n    def execute(my):\n    if not my.sobject.is_insert():\n        return\n", "code_toks_joined": "class FlashLayerCodeUpdate ( FlashAssetCodeUpdate ) : <NEWLINE> <INDENT> SEARCH_TYPE = <STRING> <NEWLINE> def get_default_code ( my ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> def get_naming ( my ) : <NEWLINE> <INDENT> return FlashLayerNaming ( ) <NEWLINE> <DEDENT> def execute ( my ) : <NEWLINE> if not my . sobject . is_insert ( ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'flash/layer'", "\"flash-layer_default\""]}, "err_obj": {"msg": "expected an indented block"}}], ["cacc2e98976612843b51d82a9ade6a41", {"code_string": "def isarchive(cls, filename):\n    try:\n        return tarfile.is_tarfile(encode(filename)\n    except:\n        return False\n", "code_toks_joined": "def isarchive ( cls , filename ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return tarfile . is_tarfile ( encode ( filename ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["983301888a37bd6323e07326ae216a5c", {"code_string": "def test_get_by_instance_and_network(self):\n    with mock.patch.object(db,\n        'virtual_interface_get_by_instance_and_network') as get:\n        get.return_value = fake_vif\n        vif = vif_obj.VirtualInterface.get_by_instance_and_network(\n            self.context, 'fake-uuid', 123)\n            self._compare(self, fake_vif, vif)\n", "code_toks_joined": "def test_get_by_instance_and_network ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( db , <NEWLINE> <INDENT> <STRING> ) as get : <NEWLINE> get . return_value = fake_vif <NEWLINE> vif = vif_obj . VirtualInterface . get_by_instance_and_network ( <NEWLINE> <INDENT> self . context , <STRING> , 123 ) <NEWLINE> self . _compare ( self , fake_vif , vif ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'virtual_interface_get_by_instance_and_network'", "'fake-uuid'"]}, "err_obj": {"msg": "unexpected indent"}}], ["ef6e71bc4455bb10196df4f620028a0c", {"code_string": "def test_validate(self):\n    fixture = TModel.objects.create(name = self.id())\n    form = TForm(http.QueryDict('name=%s&test=%s' %(\n        self.id(), self.get_value(fixture))))\n    form.fields['test'].queryset = QuerySetSequence(\n        TModel.objects.exclude(pk = fixture.pk))\n    self.assertFalse(form.is_valid()\n", "code_toks_joined": "def test_validate ( self ) : <NEWLINE> <INDENT> fixture = TModel . objects . create ( name = self . id ( ) ) <NEWLINE> form = TForm ( http . QueryDict ( <STRING> % ( <NEWLINE> <INDENT> self . id ( ) , self . get_value ( fixture ) ) ) ) <NEWLINE> <DEDENT> form . fields [ <STRING> ] . queryset = QuerySetSequence ( <NEWLINE> <INDENT> TModel . objects . exclude ( pk = fixture . pk ) ) <NEWLINE> <DEDENT> self . assertFalse ( form . is_valid ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'name=%s&test=%s'", "'test'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c20aa2d8f64f2a6b370bc9dc92307ad8", {"code_string": "def fstore_dump(url_addr):\n    store = HTTP4Store('http://localhost:8067')\n    status = store.status()\n    response = store.add_from_uri('http://example.com/nodetypes/2012/05/25/mouse/')\n        return response\n", "code_toks_joined": "def fstore_dump ( url_addr ) : <NEWLINE> <INDENT> store = HTTP4Store ( <STRING> ) <NEWLINE> status = store . status ( ) <NEWLINE> response = store . add_from_uri ( <STRING> ) <NEWLINE> <INDENT> return response <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'http://localhost:8067'", "'http://example.com/nodetypes/2012/05/25/mouse/'"]}, "err_obj": {"msg": "unexpected indent"}}], ["fd3b8e05c0cd7ecd294d5b1b86fc05af", {"code_string": "def main(number):\n    rospy.init_node('assertion3', anonymous = True)\n    global globaltime\n    globaltime = time.time()\n    global fileno\n    fileno = number\n        sm = smach.StateMachine(outcomes = ['Done'])\n        with sm:\n        smach.StateMachine.add('Flag1', Flag1(),\n            transitions = {'outcome1': 'Check1', 'outcome2': 'Flag1'})\n            smach.StateMachine.add('Check1', Gazebo_check1(),\n            transitions = {'outcome1': 'Flag1'})\n        outcome = sm.execute()\n", "code_toks_joined": "def main ( number ) : <NEWLINE> <INDENT> rospy . init_node ( <STRING> , anonymous = True ) <NEWLINE> global globaltime <NEWLINE> globaltime = time . time ( ) <NEWLINE> global fileno <NEWLINE> fileno = number <NEWLINE> <INDENT> sm = smach . StateMachine ( outcomes = [ <STRING> ] ) <NEWLINE> with sm : <NEWLINE> smach . StateMachine . add ( <STRING> , Flag1 ( ) , <NEWLINE> <INDENT> transitions = { <STRING> : <STRING> , <STRING> : <STRING> } ) <NEWLINE> smach . StateMachine . add ( <STRING> , Gazebo_check1 ( ) , <NEWLINE> transitions = { <STRING> : <STRING> } ) <NEWLINE> <DEDENT> outcome = sm . execute ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'assertion3'", "'Done'", "'Flag1'", "'outcome1'", "'Check1'", "'outcome2'", "'Flag1'", "'Check1'", "'outcome1'", "'Flag1'"]}, "err_obj": {"msg": "unexpected indent"}}], ["24a7fff7cf67027f7328c1215e8844ec", {"code_string": "def validate(self):\n    res = super(SaharaClusterTemplate, self).validate()\n    if res:\n        return res\n    if(self.is_using_neutron() and\n        not self.properties[self.MANAGEMENT_NETWORK]):\n        msg = _(\"%s must be provided\"\n            ) % self.MANAGEMENT_NETWORK\n            raise exception.StackValidationFailed(message = msg)\n    self.client_plugin().validate_hadoop_version(\n        self.properties[self.PLUGIN_NAME],\n        self.properties[self.HADOOP_VERSION]\n    )\n", "code_toks_joined": "def validate ( self ) : <NEWLINE> <INDENT> res = super ( SaharaClusterTemplate , self ) . validate ( ) <NEWLINE> if res : <NEWLINE> <INDENT> return res <NEWLINE> <DEDENT> if ( self . is_using_neutron ( ) and <NEWLINE> <INDENT> not self . properties [ self . MANAGEMENT_NETWORK ] ) : <NEWLINE> msg = _ ( <STRING> <NEWLINE> <INDENT> ) % self . MANAGEMENT_NETWORK <NEWLINE> raise exception . StackValidationFailed ( message = msg ) <NEWLINE> <DEDENT> <DEDENT> self . client_plugin ( ) . validate_hadoop_version ( <NEWLINE> <INDENT> self . properties [ self . PLUGIN_NAME ] , <NEWLINE> self . properties [ self . HADOOP_VERSION ] <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"%s must be provided\""]}, "err_obj": {"msg": "unexpected indent"}}], ["abc9a79e8693bbd1477003d171d5c671", {"code_string": "def blast_to_df_iter(fn, delimiter = '\\t', chunksize = 10000, remap = False):\n    '''Iterator of DataFrames of length chunksize parsed from an'''\n    for group in pd.read_table(fn, header = None, skipinitialspace = True,\n        names = [k for k, _ in blast_cols],\n        delimiter = delimiter, chunksize = chunksize):\n        convert_dtypes(group, dict(blast_cols))\n        if remap:\n        remap_blast(group)\n        yield group\n", "code_toks_joined": "def blast_to_df_iter ( fn , delimiter = <STRING> , chunksize = 10000 , remap = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for group in pd . read_table ( fn , header = None , skipinitialspace = True , <NEWLINE> <INDENT> names = [ k for k , _ in blast_cols ] , <NEWLINE> delimiter = delimiter , chunksize = chunksize ) : <NEWLINE> convert_dtypes ( group , dict ( blast_cols ) ) <NEWLINE> if remap : <NEWLINE> remap_blast ( group ) <NEWLINE> yield group <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'\\t'", "'''Iterator of DataFrames of length chunksize parsed from an'''"]}, "err_obj": {"msg": "expected an indented block"}}], ["b1b6568320955b7d211d41d40b1939e5", {"code_string": "def dashboard():\n    user_count = User.query.filter_by(status = USER_STATUS.ACTIVE).count()\n    mau = db.session.query('mau').from_statement(db.text(\n        '''SELECT COUNT(DISTINCT(user_session.user_id)) AS mau FROM user_session, \"user\" WHERE user_session.user_id = \"user\".id AND \"user\".status = :status AND user_session.accessed_at >= (NOW() AT TIME ZONE 'UTC') - INTERVAL '30 days' '''\n        )).params(status = USER_STATUS.ACTIVE).first()[0]\n    return render_template('dashboard.html.jinja2',\n        user_count = user_count,\n        ,\n        mau = mau\n        )\n", "code_toks_joined": "def dashboard ( ) : <NEWLINE> <INDENT> user_count = User . query . filter_by ( status = USER_STATUS . ACTIVE ) . count ( ) <NEWLINE> mau = db . session . query ( <STRING> ) . from_statement ( db . text ( <NEWLINE> <INDENT> <STRING> <NEWLINE> ) ) . params ( status = USER_STATUS . ACTIVE ) . first ( ) [ 0 ] <NEWLINE> <DEDENT> return render_template ( <STRING> , <NEWLINE> <INDENT> user_count = user_count , <NEWLINE> , <NEWLINE> mau = mau <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'mau'", "'''SELECT COUNT(DISTINCT(user_session.user_id)) AS mau FROM user_session, \"user\" WHERE user_session.user_id = \"user\".id AND \"user\".status = :status AND user_session.accessed_at >= (NOW() AT TIME ZONE 'UTC') - INTERVAL '30 days' '''", "'dashboard.html.jinja2'"]}, "err_obj": {"msg": "invalid syntax"}}], ["7bf2de9ee2b9772bcd73ba9330f7b0a3", {"code_string": "\"\"\"The dokomo JSON API\"\"\"\nfrom collections import Iterator\nfrom sqlalchemy.engine import ResultProxy, Connection\nfrom sqlalchemy.exc import IntegrityError\nfrom sqlalchemy.sql import Insert, Update\ndef execute_with_exceptions(connection: Connection,\n    executable: [Insert, Update],\n    exceptions: Iterator) -> ResultProxy:\n    \"\"\"Execute the given executable (a SQLAlchemy Insert or Update) within a\"\"\"\n    try:\n    return connection.execute(executable)\n    except IntegrityError as exc:\n    error = str(exc.orig)\n    for name, exception in exceptions:\n    if name in error:\n    raise exception\n    raise\n", "code_toks_joined": "<STRING> <NEWLINE> from collections import Iterator <NEWLINE> from sqlalchemy . engine import ResultProxy , Connection <NEWLINE> from sqlalchemy . exc import IntegrityError <NEWLINE> from sqlalchemy . sql import Insert , Update <NEWLINE> def execute_with_exceptions ( connection : Connection , <NEWLINE> <INDENT> executable : [ Insert , Update ] , <NEWLINE> exceptions : Iterator ) -> ResultProxy : <NEWLINE> <STRING> <NEWLINE> try : <NEWLINE> return connection . execute ( executable ) <NEWLINE> except IntegrityError as exc : <NEWLINE> error = str ( exc . orig ) <NEWLINE> for name , exception in exceptions : <NEWLINE> if name in error : <NEWLINE> raise exception <NEWLINE> raise <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"The dokomo JSON API\"\"\"", "\"\"\"Execute the given executable (a SQLAlchemy Insert or Update) within a\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["741518fe36807b844b64e911c4840497", {"code_string": "def run(self, logger, jira_env, args):\n    global soap, auth\n    try:\n        groupname = \"jira-users\"\n        group = soap.service.getGroup(auth, groupname)\n        return group['users']\n    except Exception, e:\n        logger.exception(e)\n", "code_toks_joined": "def run ( self , logger , jira_env , args ) : <NEWLINE> <INDENT> global soap , auth <NEWLINE> try : <NEWLINE> <INDENT> groupname = <STRING> <NEWLINE> group = soap . service . getGroup ( auth , groupname ) <NEWLINE> return group [ <STRING> ] <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> logger . exception ( e ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"jira-users\"", "'users'"]}, "err_obj": {"msg": "invalid syntax"}}], ["e3b903228408167a96f12cce7ddcbfa9", {"code_string": "def test_unknown(self):\n    header = self._header(0)\n    with mock.patch('iris.fileformats.ff.NewDynamics',\n        mock.Mock(return_value = mock.sentinel.grid)):\n        with mock.patch('warnings.warn') as warn:\n        grid = header.grid()\n    warn.assert_called_with('Staggered grid type: 0 not currently'\n        ' interpreted, assuming standard C-grid')\n    self.assertIs(grid, mock.sentinel.grid)\n", "code_toks_joined": "def test_unknown ( self ) : <NEWLINE> <INDENT> header = self . _header ( 0 ) <NEWLINE> with mock . patch ( <STRING> , <NEWLINE> <INDENT> mock . Mock ( return_value = mock . sentinel . grid ) ) : <NEWLINE> with mock . patch ( <STRING> ) as warn : <NEWLINE> grid = header . grid ( ) <NEWLINE> <DEDENT> warn . assert_called_with ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> self . assertIs ( grid , mock . sentinel . grid ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'iris.fileformats.ff.NewDynamics'", "'warnings.warn'", "'Staggered grid type: 0 not currently'", "' interpreted, assuming standard C-grid'"]}, "err_obj": {"msg": "expected an indented block"}}], ["db19aade42ccb6bccbfde7a6376f4b6c", {"code_string": "def get_inst(self, batch_sys_name):\n    \"\"\"Return an instance of the class for \"batch_sys_name\".\"\"\"\n    if batch_sys_name in self._INSTANCES:\n        return self._INSTANCES[batch_sys_name]\n    for key in[\n        \"cylc.batch_sys_handlers.\" + batch_sys_name,\n        batch_sys_name]:\n        try:\n        mod_of_name = __import__(key, fromlist = [key])\n        self._INSTANCES[batch_sys_name] = getattr(\n            mod_of_name, \"BATCH_SYS_HANDLER\")\n        return self._INSTANCES[batch_sys_name]\n        except ImportError:\n        if key == batch_sys_name:\n            raise\n", "code_toks_joined": "def get_inst ( self , batch_sys_name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if batch_sys_name in self . _INSTANCES : <NEWLINE> <INDENT> return self . _INSTANCES [ batch_sys_name ] <NEWLINE> <DEDENT> for key in [ <NEWLINE> <INDENT> <STRING> + batch_sys_name , <NEWLINE> batch_sys_name ] : <NEWLINE> try : <NEWLINE> mod_of_name = __import__ ( key , fromlist = [ key ] ) <NEWLINE> self . _INSTANCES [ batch_sys_name ] = getattr ( <NEWLINE> <INDENT> mod_of_name , <STRING> ) <NEWLINE> <DEDENT> return self . _INSTANCES [ batch_sys_name ] <NEWLINE> except ImportError : <NEWLINE> if key == batch_sys_name : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return an instance of the class for \"batch_sys_name\".\"\"\"", "\"cylc.batch_sys_handlers.\"", "\"BATCH_SYS_HANDLER\""]}, "err_obj": {"msg": "expected an indented block"}}], ["f8ec11464c4f2513bae50222d9b1d9e4", {"code_string": "def attach_cache_database(self):\n    try:\n        self.cur.execute(\"ATTACH DATABASE '%s' AS cache\" % CACHE_DB_PATH.replace(\"'\", \"''\"))\n    except sqlite.Error, e:\n        log.debug(\"Failed to attach cache database: %s\" % str(e))\n", "code_toks_joined": "def attach_cache_database ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . cur . execute ( <STRING> % CACHE_DB_PATH . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT> except sqlite . Error , e : <NEWLINE> <INDENT> log . debug ( <STRING> % str ( e ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"ATTACH DATABASE '%s' AS cache\"", "\"'\"", "\"''\"", "\"Failed to attach cache database: %s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["2259aff454b7cfe4ce2f4024e5745fc5", {"code_string": "def test_geolocate():\n    with open(os.path.join(os.path.dirname(__file__),\n        'fixtures', 'journey.yaml')) as journey_file:\n        fixtures = yaml.load(journey_file)\n        for fixture in fixtures:\n        result = Greengraph(** fixture)\n        assert_equal(result.start, fixture['start'])\n        assert_equal(result.end, fixture['end'])\n        assert_equal(result.geocoder.domain, \"maps.google.co.uk\")\n", "code_toks_joined": "def test_geolocate ( ) : <NEWLINE> <INDENT> with open ( os . path . join ( os . path . dirname ( __file__ ) , <NEWLINE> <INDENT> <STRING> , <STRING> ) ) as journey_file : <NEWLINE> fixtures = yaml . load ( journey_file ) <NEWLINE> for fixture in fixtures : <NEWLINE> result = Greengraph ( ** fixture ) <NEWLINE> assert_equal ( result . start , fixture [ <STRING> ] ) <NEWLINE> assert_equal ( result . end , fixture [ <STRING> ] ) <NEWLINE> assert_equal ( result . geocoder . domain , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'fixtures'", "'journey.yaml'", "'start'", "'end'", "\"maps.google.co.uk\""]}, "err_obj": {"msg": "expected an indented block"}}], ["76068f35f89545ac530c1ba7afac2c68", {"code_string": "def dump(self):\n    \"\"\"Print rubbish about self.\"\"\"\n    print('%15s: %s' %('name', self.name))\n    if self.comment:\n        print '%15s: %s' %('comment', self.comment)\n    if self.sequence:\n        print('%15s: %s' %('sequence', self.sequence[: 25]), )\n        if len(self.sequence) > 25: print \"...\"\n        else: print ''\n", "code_toks_joined": "def dump ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> % ( <STRING> , self . name ) ) <NEWLINE> if self . comment : <NEWLINE> <INDENT> print <STRING> % ( <STRING> , self . comment ) <NEWLINE> <DEDENT> if self . sequence : <NEWLINE> <INDENT> print ( <STRING> % ( <STRING> , self . sequence [ : 25 ] ) , ) <NEWLINE> if len ( self . sequence ) > 25 : print <STRING> <NEWLINE> else : print <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Print rubbish about self.\"\"\"", "'%15s: %s'", "'name'", "'%15s: %s'", "'comment'", "'%15s: %s'", "'sequence'", "\"...\"", "''"]}, "err_obj": {"msg": "invalid syntax"}}], ["5c57234102e2101219bc05eff1f00ba3", {"code_string": "def AcquireSamples(nSamples = 1000):\n    global device\n    colored(\"Start samples acquisition\", \"green\")\n    samples = []\n    i = 0\n    while True:\n        res = device.read(nSamples)\n            hr = heart_rate(res[: , - 2])\n            step = step_calc(res[: , - 1], res[: , - 3], res[: , - 4])\n            format2json(hr, step)\n", "code_toks_joined": "def AcquireSamples ( nSamples = 1000 ) : <NEWLINE> <INDENT> global device <NEWLINE> colored ( <STRING> , <STRING> ) <NEWLINE> samples = [ ] <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> res = device . read ( nSamples ) <NEWLINE> <INDENT> hr = heart_rate ( res [ : , - 2 ] ) <NEWLINE> step = step_calc ( res [ : , - 1 ] , res [ : , - 3 ] , res [ : , - 4 ] ) <NEWLINE> format2json ( hr , step ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Start samples acquisition\"", "\"green\""]}, "err_obj": {"msg": "unexpected indent"}}], ["07ed2521d52b2f473f16a2b0ad080634", {"code_string": "def euler(n):\n    \"\"\"Return an array of the Euler numbers E0..En (inclusive)\"\"\"\n    if not isscalar(n) or(n < 0):\n        raise ValueError, \"n must be a non-negative integer.\"\n    n = int(n)\n    if(n < 2): n1 = 2\n    else: n1 = n\n    return specfun.eulerb(n1)[: (n + 1)]\n", "code_toks_joined": "def euler ( n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not isscalar ( n ) or ( n < 0 ) : <NEWLINE> <INDENT> raise ValueError , <STRING> <NEWLINE> <DEDENT> n = int ( n ) <NEWLINE> if ( n < 2 ) : n1 = 2 <NEWLINE> else : n1 = n <NEWLINE> return specfun . eulerb ( n1 ) [ : ( n + 1 ) ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return an array of the Euler numbers E0..En (inclusive)\"\"\"", "\"n must be a non-negative integer.\""]}, "err_obj": {"msg": "invalid syntax"}}], ["dfb9dae8a01dcf6f3a5981a41e9df4dc", {"code_string": "class AssertionIDRequest(Request):\n    msgtype = \"assertion_id_request\"\n    def __init__(self, sec_context, receiver_addrs, attribute_converters,\n        timeslack = 0):\n        Request.__init__(self, sec_context, receiver_addrs,\n            attribute_converters, timeslack)\n            self.signature_check = self.sec.correctly_signed_assertion_id_request\n    def attributes(self):\n        return to_local(self.attribute_converters, self.message)\n", "code_toks_joined": "class AssertionIDRequest ( Request ) : <NEWLINE> <INDENT> msgtype = <STRING> <NEWLINE> def __init__ ( self , sec_context , receiver_addrs , attribute_converters , <NEWLINE> <INDENT> timeslack = 0 ) : <NEWLINE> Request . __init__ ( self , sec_context , receiver_addrs , <NEWLINE> <INDENT> attribute_converters , timeslack ) <NEWLINE> self . signature_check = self . sec . correctly_signed_assertion_id_request <NEWLINE> <DEDENT> <DEDENT> def attributes ( self ) : <NEWLINE> <INDENT> return to_local ( self . attribute_converters , self . message ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"assertion_id_request\""]}, "err_obj": {"msg": "unexpected indent"}}], ["5f1d6bbfbb81f2a6f8bf8c27be5bbc27", {"code_string": "class Config(object):\n    DEBUG = os.environ.get('DEBUG', False)\n    PREFERRED_URL_SCHEME = os.environ.get('PREFERRED_URL_SCHEME', 'https')\n    MONGODB_HOST = os.environ.get('MONGO_URI', None)\n    SECRET_KEY = os.environ.get('SECRET_KEY', None)\n    DATABASE_ENCRYPTION_KEY = os.environ.get('DATABASE_ENCRYPTION_KEY', None)\n    TWILLIO_SID = os.environ.get('TWILLIO_SID', None)\n    TWILLIO_AUTH_TOKEN = os.environ.get('TWILLIO_AUTH_TOKEN', None)\n    TWILLIO_PHONE_NUMBER = os.environ.get('TWILLIO_PHONE_NUMBER', None)\n    GOCARDLESS_ACCESS_TOKEN = os.environ.get('GOCARDLESS_ACCESS_TOKEN', None)\n    GOCARDLESS_ENVIRONMENT = os.environ.get('GOCARDLESS_ENVIRONMENT', 'sandbox')\n    BECKTON_TARGET = int(os.environ.get('BECKTON_TARGET', 0))\n    BECKTON_STATEMENT = os.environ.get('BECKTON_STATEMENT', None)\n    BECKTON_TERMS = os.environ.get('BECKTON_TERMS', None)\n    BECKTON_EXPLANATION = os.environ.get('BECKTON_EXPLANATION', None)\n    BECKTON_RATES_LABEL = os.environ.get('BECKTON_RATES_LABEL', '')\n    BECKTON_RATES_CSV = os.environ.get('BECKTON_RATES_CSV', '')\n    BECKTON_POSTCODE_AREAS_CSV = os.environ.get('BECKTON_POSTCODE_AREAS_CSV', False)\n    BECKTON_SUCCESS = os.environ.get('BECKTON_SUCCESS', '')\n    BECKTON_DIRECT_DEBIT_CURRENCY = os.environ.get('BECKTON_DIRECT_DEBIT_CURRENCY', 'GBP')\n    BECKTON_DIRECT_DEBIT_NAME = os.environ.get('BECKTON_DIRECT_DEBIT_NAME', '')\n    CELERY_TIMEZONE = 'UTC'\n    CELERY_ACCEPT_CONTENT = ['json']\n    CELERY_TASK_SERIALIZER = 'json'\n    CELERY_RESULT_SERIALIZER = 'json'\n    CELERY_REDIS_MAX_CONNECTIONS = 20\n    CELERY_BROKER_URL = os.environ.get('REDIS_URL', None)\n    CELERY_RESULT_BACKEND = os.environ.get('REDIS_URL', None)\n    CELERYBEAT_SCHEDULE = {\n    'send_halfway_message': {\n        'task': 'beckton.tasks.send_halfway_message',\n        'schedule': timedelta(seconds = 30)\n    },\n    'send_target_complete_message': {\n        'task': 'beckton.tasks.send_target_complete_message',\n        'schedule': timedelta(seconds = 30)\n    },\n    'create_subscriptions': {\n        'task': 'beckton.tasks.create_subscriptions',\n        'schedule': timedelta(seconds = 30)\n", "code_toks_joined": "class Config ( object ) : <NEWLINE> <INDENT> DEBUG = os . environ . get ( <STRING> , False ) <NEWLINE> PREFERRED_URL_SCHEME = os . environ . get ( <STRING> , <STRING> ) <NEWLINE> MONGODB_HOST = os . environ . get ( <STRING> , None ) <NEWLINE> SECRET_KEY = os . environ . get ( <STRING> , None ) <NEWLINE> DATABASE_ENCRYPTION_KEY = os . environ . get ( <STRING> , None ) <NEWLINE> TWILLIO_SID = os . environ . get ( <STRING> , None ) <NEWLINE> TWILLIO_AUTH_TOKEN = os . environ . get ( <STRING> , None ) <NEWLINE> TWILLIO_PHONE_NUMBER = os . environ . get ( <STRING> , None ) <NEWLINE> GOCARDLESS_ACCESS_TOKEN = os . environ . get ( <STRING> , None ) <NEWLINE> GOCARDLESS_ENVIRONMENT = os . environ . get ( <STRING> , <STRING> ) <NEWLINE> BECKTON_TARGET = int ( os . environ . get ( <STRING> , 0 ) ) <NEWLINE> BECKTON_STATEMENT = os . environ . get ( <STRING> , None ) <NEWLINE> BECKTON_TERMS = os . environ . get ( <STRING> , None ) <NEWLINE> BECKTON_EXPLANATION = os . environ . get ( <STRING> , None ) <NEWLINE> BECKTON_RATES_LABEL = os . environ . get ( <STRING> , <STRING> ) <NEWLINE> BECKTON_RATES_CSV = os . environ . get ( <STRING> , <STRING> ) <NEWLINE> BECKTON_POSTCODE_AREAS_CSV = os . environ . get ( <STRING> , False ) <NEWLINE> BECKTON_SUCCESS = os . environ . get ( <STRING> , <STRING> ) <NEWLINE> BECKTON_DIRECT_DEBIT_CURRENCY = os . environ . get ( <STRING> , <STRING> ) <NEWLINE> BECKTON_DIRECT_DEBIT_NAME = os . environ . get ( <STRING> , <STRING> ) <NEWLINE> CELERY_TIMEZONE = <STRING> <NEWLINE> CELERY_ACCEPT_CONTENT = [ <STRING> ] <NEWLINE> CELERY_TASK_SERIALIZER = <STRING> <NEWLINE> CELERY_RESULT_SERIALIZER = <STRING> <NEWLINE> CELERY_REDIS_MAX_CONNECTIONS = 20 <NEWLINE> CELERY_BROKER_URL = os . environ . get ( <STRING> , None ) <NEWLINE> CELERY_RESULT_BACKEND = os . environ . get ( <STRING> , None ) <NEWLINE> CELERYBEAT_SCHEDULE = { <NEWLINE> <STRING> : { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : timedelta ( seconds = 30 ) <NEWLINE> <DEDENT> } , <NEWLINE> <STRING> : { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : timedelta ( seconds = 30 ) <NEWLINE> <DEDENT> } , <NEWLINE> <STRING> : { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : timedelta ( seconds = 30 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'DEBUG'", "'PREFERRED_URL_SCHEME'", "'https'", "'MONGO_URI'", "'SECRET_KEY'", "'DATABASE_ENCRYPTION_KEY'", "'TWILLIO_SID'", "'TWILLIO_AUTH_TOKEN'", "'TWILLIO_PHONE_NUMBER'", "'GOCARDLESS_ACCESS_TOKEN'", "'GOCARDLESS_ENVIRONMENT'", "'sandbox'", "'BECKTON_TARGET'", "'BECKTON_STATEMENT'", "'BECKTON_TERMS'", "'BECKTON_EXPLANATION'", "'BECKTON_RATES_LABEL'", "''", "'BECKTON_RATES_CSV'", "''", "'BECKTON_POSTCODE_AREAS_CSV'", "'BECKTON_SUCCESS'", "''", "'BECKTON_DIRECT_DEBIT_CURRENCY'", "'GBP'", "'BECKTON_DIRECT_DEBIT_NAME'", "''", "'UTC'", "'json'", "'json'", "'json'", "'REDIS_URL'", "'REDIS_URL'", "'send_halfway_message'", "'task'", "'beckton.tasks.send_halfway_message'", "'schedule'", "'send_target_complete_message'", "'task'", "'beckton.tasks.send_target_complete_message'", "'schedule'", "'create_subscriptions'", "'task'", "'beckton.tasks.create_subscriptions'", "'schedule'"]}, "window_span": [321, 390], "err_obj": {"msg": "unbalanced (){}[]"}}], ["26df3eb5bf05822c62f73ca78102d61f", {"code_string": "def post(self, rv, * args, ** kwargs):\n    LOG.debug(\n        \"driver_init_host_hook post: rv= %s, args = %s, kwargs = %s\"\n        %(rv, args, kwargs)\n    self._compute_driver = args[0]\n    self._init_fault_events()\n    LOG.debug(\"init the DntManager...\")\n    dnt_mgr = DntManager(self._compute_driver)\n    dnt_mgr.init_thread()\n", "code_toks_joined": "def post ( self , rv , * args , ** kwargs ) : <NEWLINE> <INDENT> LOG . debug ( <NEWLINE> <INDENT> <STRING> <NEWLINE> % ( rv , args , kwargs ) <NEWLINE> <DEDENT> self . _compute_driver = args [ 0 ] <NEWLINE> self . _init_fault_events ( ) <NEWLINE> LOG . debug ( <STRING> ) <NEWLINE> dnt_mgr = DntManager ( self . _compute_driver ) <NEWLINE> dnt_mgr . init_thread ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"driver_init_host_hook post: rv= %s, args = %s, kwargs = %s\"", "\"init the DntManager...\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["976751f4c46acb52d543b2585f109898", {"code_string": "def __call__(self, history, predicted):\n    backOffWeight = 1.0\n    while True:\n        if(history, predicted) in self.prob:\n        return backOffWeight * self.prob[(history, predicted)]\n        backOffWeight *= self.prob.get((history, None), 1.0)\n        if history:\n        history = history[1: ]\n        else:\n        break\n    return backOffWeight\n", "code_toks_joined": "def __call__ ( self , history , predicted ) : <NEWLINE> <INDENT> backOffWeight = 1.0 <NEWLINE> while True : <NEWLINE> <INDENT> if ( history , predicted ) in self . prob : <NEWLINE> return backOffWeight * self . prob [ ( history , predicted ) ] <NEWLINE> backOffWeight *= self . prob . get ( ( history , None ) , 1.0 ) <NEWLINE> if history : <NEWLINE> history = history [ 1 : ] <NEWLINE> else : <NEWLINE> break <NEWLINE> <DEDENT> return backOffWeight <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["fbb394de550eca8a9cfed640d014a412", {"code_string": "def rollbackTransaction(self):\n    self.transactionDepth = 0\n    try:\n        self.getConn().execute(\"rollback transaction\")\n    except Exception, e:\n        print(e)\n", "code_toks_joined": "def rollbackTransaction ( self ) : <NEWLINE> <INDENT> self . transactionDepth = 0 <NEWLINE> try : <NEWLINE> <INDENT> self . getConn ( ) . execute ( <STRING> ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> print ( e ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"rollback transaction\""]}, "err_obj": {"msg": "invalid syntax"}}], ["7b88770eaa8758cbc421f869f4a76c74", {"code_string": "def testDepthwiseConv2DInputGrad(self):\n    for index, (input_size, filter_size, output_size, stride,\n        padding) in enumerate(CheckGradConfigsToTest()):\n        print(\"Testing DepthwiseConv2DInputGrad,\", index, \"th config:\",\n        input_size, \"*\", filter_size, \"stride:\", stride, \"padding:\",\n        padding)\n        for data_type in[dtypes.float32, dtypes.float64]:\n        self._ConstructAndTestGradient(\n        input_size,\n        filter_size,\n        output_size,\n        stride,\n        padding,\n        data_type,\n        test_input = True,\n        use_gpu = True)\n", "code_toks_joined": "def testDepthwiseConv2DInputGrad ( self ) : <NEWLINE> <INDENT> for index , ( input_size , filter_size , output_size , stride , <NEWLINE> <INDENT> padding ) in enumerate ( CheckGradConfigsToTest ( ) ) : <NEWLINE> print ( <STRING> , index , <STRING> , <NEWLINE> input_size , <STRING> , filter_size , <STRING> , stride , <STRING> , <NEWLINE> padding ) <NEWLINE> for data_type in [ dtypes . float32 , dtypes . float64 ] : <NEWLINE> self . _ConstructAndTestGradient ( <NEWLINE> input_size , <NEWLINE> filter_size , <NEWLINE> output_size , <NEWLINE> stride , <NEWLINE> padding , <NEWLINE> data_type , <NEWLINE> test_input = True , <NEWLINE> use_gpu = True ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Testing DepthwiseConv2DInputGrad,\"", "\"th config:\"", "\"*\"", "\"stride:\"", "\"padding:\""]}, "err_obj": {"msg": "expected an indented block"}}], ["b923ec596eaabcfd05a830144d7b10ee", {"code_string": "def getresp(self):\n    \"\"\"Internal: get a response from the server.\"\"\"\n    resp = self.getline()\n    if self.debugging: print '*resp*', repr(resp)\n    c = resp[: 1]\n    if c == '4':\n        raise NNTPTemporaryError(resp)\n    if c == '5':\n        raise NNTPPermanentError(resp)\n    if c not in '123':\n        raise NNTPProtocolError(resp)\n    return resp\n", "code_toks_joined": "def getresp ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> resp = self . getline ( ) <NEWLINE> if self . debugging : print <STRING> , repr ( resp ) <NEWLINE> c = resp [ : 1 ] <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> raise NNTPTemporaryError ( resp ) <NEWLINE> <DEDENT> if c == <STRING> : <NEWLINE> <INDENT> raise NNTPPermanentError ( resp ) <NEWLINE> <DEDENT> if c not in <STRING> : <NEWLINE> <INDENT> raise NNTPProtocolError ( resp ) <NEWLINE> <DEDENT> return resp <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Internal: get a response from the server.\"\"\"", "'*resp*'", "'4'", "'5'", "'123'"]}, "err_obj": {"msg": "invalid syntax"}}], ["09cd0fd8928a3a25cabd791cfc83c798", {"code_string": "def validate_record(self, data_fields, field_descs):\n    \"\"\"\"Hook is in place for record  level validaiton\"\"\"\n    errors = 0\n    for index, field_value, field_desc in zip(\n        xrange(len(data_fields)),\n        data_fields,\n        field_descs):\n        new_value = self.validate_field(field_value, field_desc)\n        if new_value:\n        data_fields[index] = new_value\n        else:\n        errors += 1\n    return errors\n", "code_toks_joined": "def validate_record ( self , data_fields , field_descs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> errors = 0 <NEWLINE> for index , field_value , field_desc in zip ( <NEWLINE> <INDENT> xrange ( len ( data_fields ) ) , <NEWLINE> data_fields , <NEWLINE> field_descs ) : <NEWLINE> new_value = self . validate_field ( field_value , field_desc ) <NEWLINE> if new_value : <NEWLINE> data_fields [ index ] = new_value <NEWLINE> else : <NEWLINE> errors += 1 <NEWLINE> <DEDENT> return errors <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"\"Hook is in place for record  level validaiton\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["323156c4bdf88537ac06ac0bbb189c44", {"code_string": "def rx_callback(self, data):\n    if 'selector' in data[1][1] and 'on' == data[1][2]:\n        if data[1][0] == 'main':\n            self.receiver_monitor.send_command('main.input-selector=query')\n        else:\n            self.receiver_monitor.send_command('%s.selector=query' %(data[1][0], )\n    else:\n        self.__event_dispatch.send('status', data)\n", "code_toks_joined": "def rx_callback ( self , data ) : <NEWLINE> <INDENT> if <STRING> in data [ 1 ] [ 1 ] and <STRING> == data [ 1 ] [ 2 ] : <NEWLINE> <INDENT> if data [ 1 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> self . receiver_monitor . send_command ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . receiver_monitor . send_command ( <STRING> % ( data [ 1 ] [ 0 ] , ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> self . __event_dispatch . send ( <STRING> , data ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'selector'", "'on'", "'main'", "'main.input-selector=query'", "'%s.selector=query'", "'status'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["13595aa78d9746cc27f0fc82b69d9690", {"code_string": "def fly_wrapper(BOUNCE_COEFF, * args):\n    \"\"\":param bias_scale_BOUNCE_COEFF:\"\"\"\n    print(\"\"\"BOUNCE_COEFF: {}\"\"\")\n    Trial end.FINAL BOUNCE_COEFF: {0}\n    SCORE: {1}\n        {2}\n    logging.info(msg)\n    print(msg)\n", "code_toks_joined": "def fly_wrapper ( BOUNCE_COEFF , * args ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> ) <NEWLINE> Trial end . FINAL BOUNCE_COEFF : { 0 } <NEWLINE> SCORE : { 1 } <NEWLINE> <INDENT> { 2 } <NEWLINE> <DEDENT> logging . info ( msg ) <NEWLINE> print ( msg ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\":param bias_scale_BOUNCE_COEFF:\"\"\"", "\"\"\"BOUNCE_COEFF: {}\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["040de8ff0090b2ff7adb50749cf64524", {"code_string": "def rpm_install_pkg(package_path package_name):\n    code, output = run_cmd('rpm -q ' + package_name)\n    if code == 0:\n        hutil.log(package_name + ' is already installed')\n        return\n    else:\n        code, output = run_cmd('rpm -Uvh ' + package_path)\n        if code == 0:\n            hutil.log(package_name + ' is installed successfully')\n        else:\n            raise Exception('Failed to install package {0}: {1}'.format(package_name, output))\n", "code_toks_joined": "def rpm_install_pkg ( package_path package_name ) : <NEWLINE> <INDENT> code , output = run_cmd ( <STRING> + package_name ) <NEWLINE> if code == 0 : <NEWLINE> <INDENT> hutil . log ( package_name + <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> code , output = run_cmd ( <STRING> + package_path ) <NEWLINE> if code == 0 : <NEWLINE> <INDENT> hutil . log ( package_name + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> . format ( package_name , output ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'rpm -q '", "' is already installed'", "'rpm -Uvh '", "' is installed successfully'", "'Failed to install package {0}: {1}'"]}, "err_obj": {"msg": "invalid syntax"}}], ["8beb23ba071b410f00adc35593004c88", {"code_string": "def cache(self, subject, session):\n    \"Make sure the cache is up to date\"\n    path = self.path.format(subject = subject, session = session)\n    if(not exists(path) or getmtime(path) <\n        self.mtime(subject, session, self._bad_chs_affect_cache)):\n        dir_path = dirname(path)\n        if not exists(dir_path):\n        mkdir(dir_path)\n        with CaptureLog(path[: - 3] + 'log'):\n        raw = self._make(subject, session)\n        raw.save(path, overwrite = True)\n", "code_toks_joined": "def cache ( self , subject , session ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> path = self . path . format ( subject = subject , session = session ) <NEWLINE> if ( not exists ( path ) or getmtime ( path ) < <NEWLINE> <INDENT> self . mtime ( subject , session , self . _bad_chs_affect_cache ) ) : <NEWLINE> dir_path = dirname ( path ) <NEWLINE> if not exists ( dir_path ) : <NEWLINE> mkdir ( dir_path ) <NEWLINE> with CaptureLog ( path [ : - 3 ] + <STRING> ) : <NEWLINE> raw = self . _make ( subject , session ) <NEWLINE> raw . save ( path , overwrite = True ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Make sure the cache is up to date\"", "'log'"]}, "err_obj": {"msg": "expected an indented block"}}], ["fe424eb8662beece5a9673756473dbf1", {"code_string": "def open_cover(self, ** kwargs):\n    \"\"\"Move the roller shutter up.\"\"\"\n    for value in self._node.get_values(\n        class_id = zwave.const.COMMAND_CLASS_SWITCH_MULTILEVEL).values():\n        if value.command_class == zwave.const.COMMAND_CLASS_SWITCH_MULTILEVEL and value.label == 'Open' or value.command_class == zwave.const.COMMAND_CLASS_SWITCH_MULTILEVEL and value.label == 'Up':\n        self._lozwmgr.pressButton(value.value_id)\n        break\n", "code_toks_joined": "def open_cover ( self , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for value in self . _node . get_values ( <NEWLINE> <INDENT> class_id = zwave . const . COMMAND_CLASS_SWITCH_MULTILEVEL ) . values ( ) : <NEWLINE> if value . command_class == zwave . const . COMMAND_CLASS_SWITCH_MULTILEVEL and value . label == <STRING> or value . command_class == zwave . const . COMMAND_CLASS_SWITCH_MULTILEVEL and value . label == <STRING> : <NEWLINE> self . _lozwmgr . pressButton ( value . value_id ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Move the roller shutter up.\"\"\"", "'Open'", "'Up'"]}, "err_obj": {"msg": "expected an indented block"}}], ["a83737d195be6a460722222fecb19581", {"code_string": "def set_corpus_path(self, path):\n    if path == \"\":\n        print(\"Corpus path set to current directory.\")\n    elif osp.isdir(path): self.graph(flags)\n        self.corpus_path = path\n        if self.corpus_path[- 1] != \"/\":\n            self.corpus_path += \"/\"\n        print(\"Corpus path set to '\" + self.corpus_path + \"'.\")\n    else:\n        print(\"Error: '\" + path + \"' is not a directory.\")\n", "code_toks_joined": "def set_corpus_path ( self , path ) : <NEWLINE> <INDENT> if path == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif osp . isdir ( path ) : self . graph ( flags ) <NEWLINE> <INDENT> self . corpus_path = path <NEWLINE> if self . corpus_path [ - 1 ] != <STRING> : <NEWLINE> <INDENT> self . corpus_path += <STRING> <NEWLINE> <DEDENT> print ( <STRING> + self . corpus_path + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + path + <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"", "\"Corpus path set to current directory.\"", "\"/\"", "\"/\"", "\"Corpus path set to '\"", "\"'.\"", "\"Error: '\"", "\"' is not a directory.\""]}, "err_obj": {"msg": "unexpected indent"}}], ["5e3b94eae2b711e5573e33149ce3e8ee", {"code_string": "def writeMoreBlocksReportToFile(self, filename):\n    \"\"\"writeMoreBlocksReportToFile(self,filename)\"\"\"\n        reportStr = \"\"\n    for aSprite in self.sprites:\n        reportStr += aSprite.name\n        reportStr +=(\"\\n\" + \"=\" * len(aSprite.name) + \"\\n\")\n        for aMoreBlocksDef in aSprite.moreBlocks:\n            reportStr += aMoreBlocksDef\n            reportStr +=(\"\\n\" + \"-\" * len(aMoreBlocksDef) + \"\\n\")\n    with open(filename + \".mbs\", \"w\") as f:\n        f.write(reportStr)\n", "code_toks_joined": "def writeMoreBlocksReportToFile ( self , filename ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> reportStr = <STRING> <NEWLINE> <DEDENT> for aSprite in self . sprites : <NEWLINE> <INDENT> reportStr += aSprite . name <NEWLINE> reportStr += ( <STRING> + <STRING> * len ( aSprite . name ) + <STRING> ) <NEWLINE> for aMoreBlocksDef in aSprite . moreBlocks : <NEWLINE> <INDENT> reportStr += aMoreBlocksDef <NEWLINE> reportStr += ( <STRING> + <STRING> * len ( aMoreBlocksDef ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> with open ( filename + <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( reportStr ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"writeMoreBlocksReportToFile(self,filename)\"\"\"", "\"\"", "\"\\n\"", "\"=\"", "\"\\n\"", "\"\\n\"", "\"-\"", "\"\\n\"", "\".mbs\"", "\"w\""]}, "err_obj": {"msg": "unexpected indent"}}], ["f84438dd24cae87d4a84891db1e3e843", {"code_string": "class fileForm(Form):\n    title = TextField(u'file title', validators = [validators.required()])\n        link = TextField(u'link', validators = [validators.required()])\n        comment = TextAreaField(u'Comment')\n        adddate = ndb.DateTimeProperty(auto_now_add = True)\n", "code_toks_joined": "class fileForm ( Form ) : <NEWLINE> <INDENT> title = TextField ( <STRING> , validators = [ validators . required ( ) ] ) <NEWLINE> <INDENT> link = TextField ( <STRING> , validators = [ validators . required ( ) ] ) <NEWLINE> comment = TextAreaField ( <STRING> ) <NEWLINE> adddate = ndb . DateTimeProperty ( auto_now_add = True ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["u'file title'", "u'link'", "u'Comment'"]}, "err_obj": {"msg": "unexpected indent"}}], ["9da90852f0e5eecfa8da610dac7f9d22", {"code_string": "def setupUi(self, MainWindow):\n    MainWindow.setObjectName(\"MainWindow\")\n    MainWindow.resize(973, 632)\n    MainWindow.setMinimumSize(QtCore.QSize(973, 632))\n    MainWindow.setMaximumSize(QtCore.QSize(973, 632))\n    palette = QtGui.QPalette()\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(63, 63, 63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(52, 52, 52))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(21, 21, 21))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(28, 28, 28))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(21, 21, 21))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(63, 63, 63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(52, 52, 52))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(21, 21, 21))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(28, 28, 28))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(21, 21, 21))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(21, 21, 21))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(63, 63, 63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(52, 52, 52))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(21, 21, 21))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(28, 28, 28))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(21, 21, 21))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(21, 21, 21))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(42, 42, 42))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipText, brush)\n    MainWindow.setPalette(palette)\n    icon = QtGui.QIcon()\n    icon.addPixmap(QtGui.QPixmap(\":/res/res/icon.png\"), QtGui.QIcon.Normal, QtGui.QIcon.Off)\n    MainWindow.setWindowIcon(icon)\n    MainWindow.setAutoFillBackground(False)\n    MainWindow.setStyleSheet(\"QMainWindow { background: #fff;}\\n\"\n", "code_toks_joined": "def setupUi ( self , MainWindow ) : <NEWLINE> <INDENT> MainWindow . setObjectName ( <STRING> ) <NEWLINE> MainWindow . resize ( 973 , 632 ) <NEWLINE> MainWindow . setMinimumSize ( QtCore . QSize ( 973 , 632 ) ) <NEWLINE> MainWindow . setMaximumSize ( QtCore . QSize ( 973 , 632 ) ) <NEWLINE> palette = QtGui . QPalette ( ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . WindowText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Button , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 63 , 63 , 63 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Light , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 52 , 52 , 52 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Midlight , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 21 , 21 , 21 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Dark , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 28 , 28 , 28 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Mid , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Text , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . BrightText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . ButtonText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Base , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Window , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 0 , 0 , 0 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Shadow , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 21 , 21 , 21 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . AlternateBase , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 220 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . ToolTipBase , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 0 , 0 , 0 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . ToolTipText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . WindowText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Button , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 63 , 63 , 63 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Light , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 52 , 52 , 52 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Midlight , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 21 , 21 , 21 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Dark , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 28 , 28 , 28 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Mid , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Text , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . BrightText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . ButtonText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Base , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Window , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 0 , 0 , 0 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Shadow , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 21 , 21 , 21 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . AlternateBase , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 220 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . ToolTipBase , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 0 , 0 , 0 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . ToolTipText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 21 , 21 , 21 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . WindowText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Button , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 63 , 63 , 63 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Light , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 52 , 52 , 52 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Midlight , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 21 , 21 , 21 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Dark , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 28 , 28 , 28 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Mid , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 21 , 21 , 21 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Text , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . BrightText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 21 , 21 , 21 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . ButtonText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Base , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Window , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 0 , 0 , 0 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Shadow , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 42 , 42 , 42 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . AlternateBase , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 220 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . ToolTipBase , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 0 , 0 , 0 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . ToolTipText , brush ) <NEWLINE> MainWindow . setPalette ( palette ) <NEWLINE> icon = QtGui . QIcon ( ) <NEWLINE> icon . addPixmap ( QtGui . QPixmap ( <STRING> ) , QtGui . QIcon . Normal , QtGui . QIcon . Off ) <NEWLINE> MainWindow . setWindowIcon ( icon ) <NEWLINE> MainWindow . setAutoFillBackground ( False ) <NEWLINE> MainWindow . setStyleSheet ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"MainWindow\"", "\":/res/res/icon.png\"", "\"QMainWindow { background: #fff;}\\n\""]}, "window_span": [2278, 2282], "err_obj": {"msg": "unbalanced (){}[]"}}], ["86ad7ddd94ef03704b278ae1fb83d48f", {"code_string": "def retranslateUi(self, HgStatusDialog):\n    _translate = QtCore.QCoreApplication.translate\n    HgStatusDialog.setWindowTitle(_translate(\"HgStatusDialog\", \"Mercurial Status\"))\n    HgStatusDialog.setWhatsThis(_translate(\"HgStatusDialog\", \"<b>Mercurial Status</b>\\n\"\n", "code_toks_joined": "def retranslateUi ( self , HgStatusDialog ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> HgStatusDialog . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> HgStatusDialog . setWhatsThis ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"HgStatusDialog\"", "\"Mercurial Status\"", "\"HgStatusDialog\"", "\"<b>Mercurial Status</b>\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["92c52e29106de3ba5c384cfd5165376b", {"code_string": "def move_up(self, ** kwargs):\n    \"\"\"Move the roller shutter up.\"\"\"\n    for value in self._node.get_values(\n        class_id = COMMAND_CLASS_SWITCH_MULTILEVEL).values():\n        if value.command_class == zwave.COMMAND_CLASS_SWITCH_MULTILEVEL and value.label == 'Open' or value.command_class == zwave.COMMAND_CLASS_SWITCH_MULTILEVEL and value.label == 'Down':\n        self._lozwmgr.pressButton(value.value_id)\n        break\n", "code_toks_joined": "def move_up ( self , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for value in self . _node . get_values ( <NEWLINE> <INDENT> class_id = COMMAND_CLASS_SWITCH_MULTILEVEL ) . values ( ) : <NEWLINE> if value . command_class == zwave . COMMAND_CLASS_SWITCH_MULTILEVEL and value . label == <STRING> or value . command_class == zwave . COMMAND_CLASS_SWITCH_MULTILEVEL and value . label == <STRING> : <NEWLINE> self . _lozwmgr . pressButton ( value . value_id ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Move the roller shutter up.\"\"\"", "'Open'", "'Down'"]}, "err_obj": {"msg": "expected an indented block"}}], ["f7ff2f06e575060e301f98a794a63db4", {"code_string": "def test_star_imports():\n    result = tlint(''' from os.path import *''', Project()\n    assert not result\n", "code_toks_joined": "def test_star_imports ( ) : <NEWLINE> <INDENT> result = tlint ( <STRING> , Project ( ) <NEWLINE> assert not result <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''' from os.path import *'''"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["d0f9c68854684cefaf9b73c3da08d394", {"code_string": "def test0010currencies(self):\n    '''Create currencies'''\n    with Transaction().start(DB_NAME, USER,\n        context = CONTEXT) as transaction:\n        cu1, cu2 = self.currency.create([{\n            'name': 'cu1',\n            'symbol': 'cu1',\n            'code': 'cu1'\n            }, {\n            'name': 'cu2',\n            'symbol': 'cu2',\n            'code': 'cu2'\n            }])\n            self.assert_(cu1)\n            self.assert_(cu2)\n            transaction.cursor.commit()\n", "code_toks_joined": "def test0010currencies ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with Transaction ( ) . start ( DB_NAME , USER , <NEWLINE> <INDENT> context = CONTEXT ) as transaction : <NEWLINE> cu1 , cu2 = self . currency . create ( [ { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> } , { <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> } ] ) <NEWLINE> self . assert_ ( cu1 ) <NEWLINE> self . assert_ ( cu2 ) <NEWLINE> transaction . cursor . commit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Create currencies'''", "'name'", "'cu1'", "'symbol'", "'cu1'", "'code'", "'cu1'", "'name'", "'cu2'", "'symbol'", "'cu2'", "'code'", "'cu2'"]}, "err_obj": {"msg": "unexpected indent"}}], ["5c7593e0f5bcd8a34090b0d17e274e34", {"code_string": "def readPackets(self, num, maxlen = None):\n    packets = []\n    for i in range(0, num):\n        if self.debug > 0:\n            print \"Reading packet %d of %d\" %(i + 1, num)\n        packets.append(self.readPacket(maxlen))\n    return packets\n", "code_toks_joined": "def readPackets ( self , num , maxlen = None ) : <NEWLINE> <INDENT> packets = [ ] <NEWLINE> for i in range ( 0 , num ) : <NEWLINE> <INDENT> if self . debug > 0 : <NEWLINE> <INDENT> print <STRING> % ( i + 1 , num ) <NEWLINE> <DEDENT> packets . append ( self . readPacket ( maxlen ) ) <NEWLINE> <DEDENT> return packets <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Reading packet %d of %d\""]}, "err_obj": {"msg": "invalid syntax"}}], ["32b2e1dc27bdf2b769d523f3e36ebbf8", {"code_string": "class FakeSessionForVolumeTests(fake.SessionBase):\n    \"\"\"Stubs out a XenAPISession for Volume tests.\"\"\"\n    def VDI_introduce(self, _1, uuid, _2, _3, _4, _5,\n        _6, _7, _8, _9, _10, _11):\n        valid_vdi = False\n        refs = fake.get_all('VDI')\n        for ref in refs:\n        rec = fake.get_record('VDI', ref)\n        if rec['uuid'] == uuid:\n        valid_vdi = True\n        if not valid_vdi:\n        raise fake.Failure([['INVALID_VDI', 'session', self._session]])\n", "code_toks_joined": "class FakeSessionForVolumeTests ( fake . SessionBase ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def VDI_introduce ( self , _1 , uuid , _2 , _3 , _4 , _5 , <NEWLINE> <INDENT> _6 , _7 , _8 , _9 , _10 , _11 ) : <NEWLINE> valid_vdi = False <NEWLINE> refs = fake . get_all ( <STRING> ) <NEWLINE> for ref in refs : <NEWLINE> rec = fake . get_record ( <STRING> , ref ) <NEWLINE> if rec [ <STRING> ] == uuid : <NEWLINE> valid_vdi = True <NEWLINE> if not valid_vdi : <NEWLINE> raise fake . Failure ( [ [ <STRING> , <STRING> , self . _session ] ] ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Stubs out a XenAPISession for Volume tests.\"\"\"", "'VDI'", "'VDI'", "'uuid'", "'INVALID_VDI'", "'session'"]}, "err_obj": {"msg": "expected an indented block"}}], ["755b3a9cea9bb7408cd5f7b6bf7ae8ad", {"code_string": "def GetMediaWithPlace(self, placeid, sort_col = \"NULL\"):\n    print(\"iphoto.db: Retrieving media with Place ID %s\" %(smart_utf8(placeid)))\n    media = []\n    cur = self.dbconn.cursor()\n    try:\n        if(sort_col != \"NULL\"):\n        sort_col = \"M.\" + sort_col\n        cur.execute(\"\"\"SELECT M.caption, M.mediapath, M.thumbpath, M.originalpath, M.rating, M.mediadate, M.mediasize\"\"\" %(sort_col), (placeid, ))\n        for tuple in cur:\n        media.append(tuple)\n    except Exception, e:\n        print(\"iphoto.db: GetMediaWithPlace: \" + smart_utf8(e))\n        pass\n    cur.close()\n    return media\n", "code_toks_joined": "def GetMediaWithPlace ( self , placeid , sort_col = <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> % ( smart_utf8 ( placeid ) ) ) <NEWLINE> media = [ ] <NEWLINE> cur = self . dbconn . cursor ( ) <NEWLINE> try : <NEWLINE> <INDENT> if ( sort_col != <STRING> ) : <NEWLINE> sort_col = <STRING> + sort_col <NEWLINE> cur . execute ( <STRING> % ( sort_col ) , ( placeid , ) ) <NEWLINE> for tuple in cur : <NEWLINE> media . append ( tuple ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> print ( <STRING> + smart_utf8 ( e ) ) <NEWLINE> pass <NEWLINE> <DEDENT> cur . close ( ) <NEWLINE> return media <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"NULL\"", "\"iphoto.db: Retrieving media with Place ID %s\"", "\"NULL\"", "\"M.\"", "\"\"\"SELECT M.caption, M.mediapath, M.thumbpath, M.originalpath, M.rating, M.mediadate, M.mediasize\"\"\"", "\"iphoto.db: GetMediaWithPlace: \""]}, "err_obj": {"msg": "expected an indented block"}}], ["02446185615df2ca36ad8c4254fa90c8", {"code_string": "def mergeCombiners((bw1, req_count1), (bw2, req_count2)):\n    for region in bw1:\n        bw1[region] = bw1[region] + bw2[region]\n        req_count1[region] = req_count1[region] + req_count2[region]\n    return(bw1, req_count1)\n", "code_toks_joined": "def mergeCombiners ( ( bw1 , req_count1 ) , ( bw2 , req_count2 ) ) : <NEWLINE> <INDENT> for region in bw1 : <NEWLINE> <INDENT> bw1 [ region ] = bw1 [ region ] + bw2 [ region ] <NEWLINE> req_count1 [ region ] = req_count1 [ region ] + req_count2 [ region ] <NEWLINE> <DEDENT> return ( bw1 , req_count1 ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["3ff859df0efb24bf74b6242a3fc59fbd", {"code_string": "from PyQt5.QtWidgets import(QWidget, QLineEdit, QPushButton, QSystemTrayIcon\n    QFileDialog, QFormLayout, QApplication)\nfrom PyQt5.QtCore import QThread, QRegExp\nimport requests\nimport sys\n", "code_toks_joined": "from PyQt5 . QtWidgets import ( QWidget , QLineEdit , QPushButton , QSystemTrayIcon <NEWLINE> <INDENT> QFileDialog , QFormLayout , QApplication ) <NEWLINE> <DEDENT> from PyQt5 . QtCore import QThread , QRegExp <NEWLINE> import requests <NEWLINE> import sys <NEWLINE>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["affb14e2e1fd48447adac06b0c6670a0", {"code_string": "try:\n    basestring\nexcept NameError:\n    basestring = str\ntry:\n    bool\nexcept NameError:\n    def bool(x):\n    return not not x\ntry:\n    True\nexcept NameError:\n    False = 0\n    True = 1\ntry:\n    enumerate\nexcept NameError:\n    def enumerate(lt):\n    return map(None, xrange(len(lt)), lt)\n", "code_toks_joined": "try : <NEWLINE> <INDENT> basestring <NEWLINE> <DEDENT> except NameError : <NEWLINE> <INDENT> basestring = str <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> bool <NEWLINE> <DEDENT> except NameError : <NEWLINE> <INDENT> def bool ( x ) : <NEWLINE> return not not x <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> True <NEWLINE> <DEDENT> except NameError : <NEWLINE> <INDENT> False = 0 <NEWLINE> True = 1 <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> enumerate <NEWLINE> <DEDENT> except NameError : <NEWLINE> <INDENT> def enumerate ( lt ) : <NEWLINE> return map ( None , xrange ( len ( lt ) ) , lt ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["49f12dfae68e55085963f7e6e16fd25c", {"code_string": "def hot():\n    \"\"\"Returns a list of hit terms via google trends\"\"\"\n    try:\n        listing = feedparser.parse(TRENDING_URL)['entries']\n        trends = [item['title'] for item in listing]\n        return trends\n    except Exception as e:\n        print('ERR hot terms failed!', str(e)))\n        return None\n", "code_toks_joined": "def hot ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> listing = feedparser . parse ( TRENDING_URL ) [ <STRING> ] <NEWLINE> trends = [ item [ <STRING> ] for item in listing ] <NEWLINE> return trends <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> <INDENT> print ( <STRING> , str ( e ) ) ) <NEWLINE> return None <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns a list of hit terms via google trends\"\"\"", "'entries'", "'title'", "'ERR hot terms failed!'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["c143b7f81a6e810da6ca5e05afd5df1b", {"code_string": "def label(g, r):\n    \"\"\"label(graph, resource)\"\"\"\n    queries = [\"\"\"PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\"\"\", \"\"\"PREFIX dct: <http://purl.org/dc/terms/>\"\"\", \"\"\"PREFIX bqbiol: <http://biomodels.net/biology-qualifiers/>\"\"\", \"\"\"PREFIX bqbiol: <http://biomodels.net/biology-qualifiers/>\"\"\", \"\"\"PREFIX dct: <http://purl.org/dc/terms/>\"\"\"\n", "code_toks_joined": "def label ( g , r ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> queries = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"label(graph, resource)\"\"\"", "\"\"\"PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\"\"\"", "\"\"\"PREFIX dct: <http://purl.org/dc/terms/>\"\"\"", "\"\"\"PREFIX bqbiol: <http://biomodels.net/biology-qualifiers/>\"\"\"", "\"\"\"PREFIX bqbiol: <http://biomodels.net/biology-qualifiers/>\"\"\"", "\"\"\"PREFIX dct: <http://purl.org/dc/terms/>\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["b6d346cd7d1ccd47410144567cacd441", {"code_string": "def setContent(self, content, ext = '.new')\n    sib = self.siblingExtension(ext)\n    sib.open('w').write(content)\n    os.rename(sib.path, self.path)\n", "code_toks_joined": "def setContent ( self , content , ext = <STRING> ) <NEWLINE> <INDENT> sib = self . siblingExtension ( ext ) <NEWLINE> sib . open ( <STRING> ) . write ( content ) <NEWLINE> os . rename ( sib . path , self . path ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'.new'", "'w'"]}, "err_obj": {"msg": "invalid syntax"}}], ["e5da94bfa06021a2a66c4c2183bde65f", {"code_string": "def on_adapter_property_changed(self, List, adapter, (key, value)):\n    if key == \"Discovering\":\n        if value:\n            self.b_search.props.sensitive = False\n        else:\n            self.b_search.props.sensitive = True\n", "code_toks_joined": "def on_adapter_property_changed ( self , List , adapter , ( key , value ) ) : <NEWLINE> <INDENT> if key == <STRING> : <NEWLINE> <INDENT> if value : <NEWLINE> <INDENT> self . b_search . props . sensitive = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . b_search . props . sensitive = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Discovering\""]}, "err_obj": {"msg": "invalid syntax"}}], ["02473efe37c896e1ea9af457aeea6a5c", {"code_string": "def main(args):\n    feature_files = glob.glob(os.path.join(args.feature_directory, \"*.npz\")\n    (files, time_points,\n        features) = morphine.sample_feature_files(feature_files,\n            args.num_samples)\n    connections = morphine.build_kneighbors_table(features, args.k_neighbors)\n    path = morphine.rand_acyclic_walk(connections)\n    print(path)\n", "code_toks_joined": "def main ( args ) : <NEWLINE> <INDENT> feature_files = glob . glob ( os . path . join ( args . feature_directory , <STRING> ) <NEWLINE> ( files , time_points , <NEWLINE> <INDENT> features ) = morphine . sample_feature_files ( feature_files , <NEWLINE> <INDENT> args . num_samples ) <NEWLINE> <DEDENT> <DEDENT> connections = morphine . build_kneighbors_table ( features , args . k_neighbors ) <NEWLINE> path = morphine . rand_acyclic_walk ( connections ) <NEWLINE> print ( path ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"*.npz\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["51711ac9903fa03acd72b45d3e8399de", {"code_string": "class Institucion(models.Model):\n    nombre = models.CharField(, max_length = 144)\n    publica = models.BooleanField(default = False)\n        class Meta:\n            verbose_name = _('Institucion de prevision')\n            verbose_name_plural = _('Instituciones de prevision')\n        def __unicode__(self):\n            return self.nombre\n", "code_toks_joined": "class Institucion ( models . Model ) : <NEWLINE> <INDENT> nombre = models . CharField ( , max_length = 144 ) <NEWLINE> publica = models . BooleanField ( default = False ) <NEWLINE> <INDENT> class Meta : <NEWLINE> <INDENT> verbose_name = _ ( <STRING> ) <NEWLINE> verbose_name_plural = _ ( <STRING> ) <NEWLINE> <DEDENT> def __unicode__ ( self ) : <NEWLINE> <INDENT> return self . nombre <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Institucion de prevision'", "'Instituciones de prevision'"]}, "err_obj": {"msg": "invalid syntax"}}], ["0c1610e1194b5c5459cf52d7f71beb26", {"code_string": "def GET(self):\n    global session\n    chdir(path[0] + sep + 'index')\n    render = template.render('templates/')\n    fo = loginform()\n    if session == None:\n        session = webconfig._session\n    if session.login == 0:\n        return render.index(False, fo)\n        elif session.login == 1:\n        return render.index(True, fo)\n", "code_toks_joined": "def GET ( self ) : <NEWLINE> <INDENT> global session <NEWLINE> chdir ( path [ 0 ] + sep + <STRING> ) <NEWLINE> render = template . render ( <STRING> ) <NEWLINE> fo = loginform ( ) <NEWLINE> if session == None : <NEWLINE> <INDENT> session = webconfig . _session <NEWLINE> <DEDENT> if session . login == 0 : <NEWLINE> <INDENT> return render . index ( False , fo ) <NEWLINE> elif session . login == 1 : <NEWLINE> return render . index ( True , fo ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'index'", "'templates/'"]}, "err_obj": {"msg": "invalid syntax"}}], ["c706030c16d95847864ed0fe2eb71696", {"code_string": "def __getstate__(self):\n    \"\"\"Exclude certain cached properties from pickling.\"\"\"\n    state = filter(\n        lambda(k, v): k not in['_settings', '_ldap'],\n        self.__dict__.iteritems()\n    )\n    return dict(state)\n", "code_toks_joined": "def __getstate__ ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> state = filter ( <NEWLINE> <INDENT> lambda ( k , v ) : k not in [ <STRING> , <STRING> ] , <NEWLINE> self . __dict__ . iteritems ( ) <NEWLINE> <DEDENT> ) <NEWLINE> return dict ( state ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Exclude certain cached properties from pickling.\"\"\"", "'_settings'", "'_ldap'"]}, "err_obj": {"msg": "invalid syntax"}}], ["792fcf25bd14f9eee6585aab313b9df3", {"code_string": "def libtool_version_menu():\n    \"\"\"Manage libtool version setting\"\"\"\n    current = get_libtool_version()\n    if confirm(\"Current libtool version is '%s'. Do you want to change the \"\n        \"version?\" % current):\n        library = confirm(\" Has the source code changed since last release?\")\n        added = confirm(\" Have interfaces been added since last release?\")\n        removed = confirm(\" Have interfaces been removed since last release?\")\n        changed = confirm(\" Have interfaces changed since last release?\")\n        set_libtool_version(library = library, added = added, removed = removed,\n            changed = changed)\n            version = get_libtool_version()\n            print(\"Libtool version changed to '%s'\" % version)\n    return\n", "code_toks_joined": "def libtool_version_menu ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> current = get_libtool_version ( ) <NEWLINE> if confirm ( <STRING> <NEWLINE> <INDENT> <STRING> % current ) : <NEWLINE> library = confirm ( <STRING> ) <NEWLINE> added = confirm ( <STRING> ) <NEWLINE> removed = confirm ( <STRING> ) <NEWLINE> changed = confirm ( <STRING> ) <NEWLINE> set_libtool_version ( library = library , added = added , removed = removed , <NEWLINE> <INDENT> changed = changed ) <NEWLINE> version = get_libtool_version ( ) <NEWLINE> print ( <STRING> % version ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Manage libtool version setting\"\"\"", "\"Current libtool version is '%s'. Do you want to change the \"", "\"version?\"", "\" Has the source code changed since last release?\"", "\" Have interfaces been added since last release?\"", "\" Have interfaces been removed since last release?\"", "\" Have interfaces changed since last release?\"", "\"Libtool version changed to '%s'\""]}, "err_obj": {"msg": "unexpected indent"}}], ["43653dd927a24daf233212bbfa99b90a", {"code_string": "def ui_command_version(self):\n    '''Displays the targetcli and support libraries versions.'''\n    from rtslib import __version__ as rtslib_version\n    from targetcli import __version__ as targetcli_version\n    from configshell import __version__ as configshell_version\n    for package, version in dict(targetcli = targetcli_version,\n        rtslib = rtslib_version,\n        configshell = configshell_version).items():\n        if version == 'GIT_VERSION':\n        self.shell.log.error(\"Cannot find %s version. The %s package \"\n        %(package, package)\n        + \"has probably not been built properly \"\n        + \"from either the git repository or a \"\n        + \"public tarball.\")\n        else:\n        self.shell.log.info(\"Using %s version %s\" %(package, version))\n", "code_toks_joined": "def ui_command_version ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> from rtslib import __version__ as rtslib_version <NEWLINE> from targetcli import __version__ as targetcli_version <NEWLINE> from configshell import __version__ as configshell_version <NEWLINE> for package , version in dict ( targetcli = targetcli_version , <NEWLINE> <INDENT> rtslib = rtslib_version , <NEWLINE> configshell = configshell_version ) . items ( ) : <NEWLINE> if version == <STRING> : <NEWLINE> self . shell . log . error ( <STRING> <NEWLINE> % ( package , package ) <NEWLINE> + <STRING> <NEWLINE> + <STRING> <NEWLINE> + <STRING> ) <NEWLINE> else : <NEWLINE> self . shell . log . info ( <STRING> % ( package , version ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Displays the targetcli and support libraries versions.'''", "'GIT_VERSION'", "\"Cannot find %s version. The %s package \"", "\"has probably not been built properly \"", "\"from either the git repository or a \"", "\"public tarball.\"", "\"Using %s version %s\""]}, "err_obj": {"msg": "expected an indented block"}}], ["c0c44ccb7230f238b7715e7aafca6459", {"code_string": "class TestRsqrt(unittest.TestCase):\n    def test_rsqrt(self):\n        x = numpy.random.uniform(0.1, 5, (3, 2)).astype(numpy.float32)\n        testing.assert_allclose(F.rsqrt(x).data, rsqrt(x)\n", "code_toks_joined": "class TestRsqrt ( unittest . TestCase ) : <NEWLINE> <INDENT> def test_rsqrt ( self ) : <NEWLINE> <INDENT> x = numpy . random . uniform ( 0.1 , 5 , ( 3 , 2 ) ) . astype ( numpy . float32 ) <NEWLINE> testing . assert_allclose ( F . rsqrt ( x ) . data , rsqrt ( x ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["193a80bbfe1c9fcf5db7f48b35191aab", {"code_string": "def serve_thread_tcp(host, port, handler):\n    try:\n        if OsInterfaceIsSupported():\n            server = ThreadingTCPServer((settings.Config.Bind_To, port), handler)\n            server.serve_forever()\n        else:\n            server = ThreadingTCPServer((host, port), handler)\n            server.serve_forever()\n    except:\n        print(color(\"[!] \", 1, 1) + \"Error starting TCP server on port \" + str(\n            port) + \", check permissions or other servers running.\"\n", "code_toks_joined": "def serve_thread_tcp ( host , port , handler ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if OsInterfaceIsSupported ( ) : <NEWLINE> <INDENT> server = ThreadingTCPServer ( ( settings . Config . Bind_To , port ) , handler ) <NEWLINE> server . serve_forever ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> server = ThreadingTCPServer ( ( host , port ) , handler ) <NEWLINE> server . serve_forever ( ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> print ( color ( <STRING> , 1 , 1 ) + <STRING> + str ( <NEWLINE> <INDENT> port ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"[!] \"", "\"Error starting TCP server on port \"", "\", check permissions or other servers running.\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["1fb25399104bacccd08da1fe9659e3c2", {"code_string": "from django.conf.urls import patterns, include, url\nfrom django.contrib import admin\nurlpatterns = patterns('',\n    url(r'^admin/', include(admin.site.urls))),\n    url(r'^', include('TaxiService.urls'))\n)\n", "code_toks_joined": "from django . conf . urls import patterns , include , url <NEWLINE> from django . contrib import admin <NEWLINE> urlpatterns = patterns ( <STRING> , <NEWLINE> <INDENT> url ( <STRING> , include ( admin . site . urls ) ) ) , <NEWLINE> url ( <STRING> , include ( <STRING> ) ) <NEWLINE> <DEDENT> ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["''", "r'^admin/'", "r'^'", "'TaxiService.urls'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["3f42f45dccf57c356c0e1c5ac4474bf7", {"code_string": "categories = [\"control_registers\",\n    \"halt\",\n    \"invlpg\",\n    \"undefined_operation\",\n    \"msrs\",\n    \"segmentation\"]\nmicrocode = \"\"\nfor category in categories:\n    exec \"import %s as cat\" % category\n    microcode += cat.microcode\n", "code_toks_joined": "categories = [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ] <NEWLINE> <DEDENT> microcode = <STRING> <NEWLINE> for category in categories : <NEWLINE> <INDENT> exec <STRING> % category <NEWLINE> microcode += cat . microcode <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"control_registers\"", "\"halt\"", "\"invlpg\"", "\"undefined_operation\"", "\"msrs\"", "\"segmentation\"", "\"\"", "\"import %s as cat\""]}, "err_obj": {"msg": "invalid syntax"}}], ["1475e6381e0e0cedf4ccb2a30cc3bb4c", {"code_string": "class ChoiceWidget(WidgetBase, forms.Select):\n    \"\"\"Widget that provides an autocomplete for zero to one choice.\"\"\"\n    def __init__(self, autocomplete = None, widget_js_attributes = None,\n        autocomplete_js_attributes = None, extra_context = None, registry = None,\n        widget_template = None, widget_attrs = None, * args,\n        ** kwargs):\n        forms.Select.__init__(self, * args, ** kwargs)\n        WidgetBase.__init__(self, autocomplete, widget_js_attributes,\n            autocomplete_js_attributes, extra_context, registry,\n            widget_template, widget_attrs)\n            self.widget_attrs.setdefault('data-widget-maximum-values', 1)\n", "code_toks_joined": "class ChoiceWidget ( WidgetBase , forms . Select ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , autocomplete = None , widget_js_attributes = None , <NEWLINE> <INDENT> autocomplete_js_attributes = None , extra_context = None , registry = None , <NEWLINE> widget_template = None , widget_attrs = None , * args , <NEWLINE> ** kwargs ) : <NEWLINE> forms . Select . __init__ ( self , * args , ** kwargs ) <NEWLINE> WidgetBase . __init__ ( self , autocomplete , widget_js_attributes , <NEWLINE> <INDENT> autocomplete_js_attributes , extra_context , registry , <NEWLINE> widget_template , widget_attrs ) <NEWLINE> self . widget_attrs . setdefault ( <STRING> , 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Widget that provides an autocomplete for zero to one choice.\"\"\"", "'data-widget-maximum-values'"]}, "err_obj": {"msg": "unexpected indent"}}], ["549b6a5c05498e64b521ff72f3cb301b", {"code_string": "def _get_precedential_statuses(self):\n    statuses = []\n    for _ in range(0, len(self.case_names))):\n        if 'opinion' in self.url.lower():\n            statuses.append('Published')\n        elif 'memoranda' in self.url.lower():\n            statuses.append('Unpublished')\n        else:\n            statuses.append('Unknown')\n    return statuses\n", "code_toks_joined": "def _get_precedential_statuses ( self ) : <NEWLINE> <INDENT> statuses = [ ] <NEWLINE> for _ in range ( 0 , len ( self . case_names ) ) ) : <NEWLINE> <INDENT> if <STRING> in self . url . lower ( ) : <NEWLINE> <INDENT> statuses . append ( <STRING> ) <NEWLINE> <DEDENT> elif <STRING> in self . url . lower ( ) : <NEWLINE> <INDENT> statuses . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> statuses . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return statuses <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'opinion'", "'Published'", "'memoranda'", "'Unpublished'", "'Unknown'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["7168895c53ee9e3e19456a8f43bcb9ed", {"code_string": "def _send(self, msg):\n    loop = asyncio.get_event_loop()\n    coro = asyncio.ensure_future(self._send_coro(msg, loop)))\n    loop.run_until_complete(coro)\n    return coro.result()\n", "code_toks_joined": "def _send ( self , msg ) : <NEWLINE> <INDENT> loop = asyncio . get_event_loop ( ) <NEWLINE> coro = asyncio . ensure_future ( self . _send_coro ( msg , loop ) ) ) <NEWLINE> loop . run_until_complete ( coro ) <NEWLINE> return coro . result ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["793a061df52a2f875ef16a47bc6a8cab", {"code_string": "def makeDirectory(self, path):\n    d = self._get_root(path)\n    d.addCallback(lambda(root, path):\n        self._get_or_create_directories(root, path))\n    return d\n", "code_toks_joined": "def makeDirectory ( self , path ) : <NEWLINE> <INDENT> d = self . _get_root ( path ) <NEWLINE> d . addCallback ( lambda ( root , path ) : <NEWLINE> <INDENT> self . _get_or_create_directories ( root , path ) ) <NEWLINE> <DEDENT> return d <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["f63517abc56071bdf20aa51b123afac1", {"code_string": "def count1(dna, base):\n    i = 0\n    for c in dna:\n        if c == base:\n        i += 1\n    return i\n", "code_toks_joined": "def count1 ( dna , base ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> for c in dna : <NEWLINE> <INDENT> if c == base : <NEWLINE> i += 1 <NEWLINE> <DEDENT> return i <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["95adf7c89b6f76dbaad8ce5bc0ce549d", {"code_string": "ass Solution(object):\n    def canConstruct(self, ransomNote, magazine):\n        for i in ransomNote:\n            if i not in magazine:\n                return False\n            elif ransomNote.count(i) > magazine.count(i):\n                return False\n            else:\n                continue\n        return True\n", "code_toks_joined": "ass Solution ( object ) : <NEWLINE> <INDENT> def canConstruct ( self , ransomNote , magazine ) : <NEWLINE> <INDENT> for i in ransomNote : <NEWLINE> <INDENT> if i not in magazine : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif ransomNote . count ( i ) > magazine . count ( i ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["54e9fc40e2504cbab305b2abf7506b42", {"code_string": "def testDepthwiseConv2DInputGradCompare(self):\n    for index, (input_size, filter_size, output_size, stride,\n        padding) in enumerate(ConfigsToTest()):\n        print(\"Processing \", index, \"th config.\")\n        self._CompareBackpropInputFloat(input_size, filter_size, output_size,\n            stride, padding)\n            self._CompareBackpropInputDouble(input_size, filter_size, output_size,\n                stride, padding)\n", "code_toks_joined": "def testDepthwiseConv2DInputGradCompare ( self ) : <NEWLINE> <INDENT> for index , ( input_size , filter_size , output_size , stride , <NEWLINE> <INDENT> padding ) in enumerate ( ConfigsToTest ( ) ) : <NEWLINE> print ( <STRING> , index , <STRING> ) <NEWLINE> self . _CompareBackpropInputFloat ( input_size , filter_size , output_size , <NEWLINE> <INDENT> stride , padding ) <NEWLINE> self . _CompareBackpropInputDouble ( input_size , filter_size , output_size , <NEWLINE> <INDENT> stride , padding ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Processing \"", "\"th config.\""]}, "err_obj": {"msg": "unexpected indent"}}], ["691324c6259f13a18c10319ca6ef356c", {"code_string": "def search(self, ** kwargs):\n    args = kwargs\n    req_url = '%s/records/v%s.%s?api_key=%s&%s' %(self.base_url,\n        self.version,\n        self.format\n        self.api_key,\n        uenc(kwargs))\n    rsp = urllib2.urlopen(req_url).read()\n    return DigitalNZResponse(self, rsp)\n", "code_toks_joined": "def search ( self , ** kwargs ) : <NEWLINE> <INDENT> args = kwargs <NEWLINE> req_url = <STRING> % ( self . base_url , <NEWLINE> <INDENT> self . version , <NEWLINE> self . format <NEWLINE> self . api_key , <NEWLINE> uenc ( kwargs ) ) <NEWLINE> <DEDENT> rsp = urllib2 . urlopen ( req_url ) . read ( ) <NEWLINE> return DigitalNZResponse ( self , rsp ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'%s/records/v%s.%s?api_key=%s&%s'"]}, "err_obj": {"msg": "invalid syntax"}}], ["cfa3cb32b1eae2aace63ce7f85d2ba7f", {"code_string": "def close(self):\n    sock = self.sock\n    istream = self.istream\n    ostream = self.ostream\n    self.sock = 0\n    self.istream = 0\n    self.ostream = 0\n        if self.file_count == 0:\n        if istream:\n            istream.close()\n            if ostream:\n            ostream.close()\n            if sock:\n            sock.close()\n", "code_toks_joined": "def close ( self ) : <NEWLINE> <INDENT> sock = self . sock <NEWLINE> istream = self . istream <NEWLINE> ostream = self . ostream <NEWLINE> self . sock = 0 <NEWLINE> self . istream = 0 <NEWLINE> self . ostream = 0 <NEWLINE> <INDENT> if self . file_count == 0 : <NEWLINE> if istream : <NEWLINE> <INDENT> istream . close ( ) <NEWLINE> if ostream : <NEWLINE> ostream . close ( ) <NEWLINE> if sock : <NEWLINE> sock . close ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["7d3df389f1e770bf43958b1a7acd1b6c", {"code_string": "def canvas_detect(self):\n    self.lilnew1.delete(0, END)\n    holddevices = pcapy.findalldevs()\n    for devices in holddevices:\n        if devices == \"any\":\n            self.lilnew1.insert(0, )\n            elif devices == \"lo\":\n            self.lilnew1.insert(0, )\n        else:\n            self.lilnew1.insert(0, devices)\n", "code_toks_joined": "def canvas_detect ( self ) : <NEWLINE> <INDENT> self . lilnew1 . delete ( 0 , END ) <NEWLINE> holddevices = pcapy . findalldevs ( ) <NEWLINE> for devices in holddevices : <NEWLINE> <INDENT> if devices == <STRING> : <NEWLINE> <INDENT> self . lilnew1 . insert ( 0 , ) <NEWLINE> elif devices == <STRING> : <NEWLINE> self . lilnew1 . insert ( 0 , ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . lilnew1 . insert ( 0 , devices ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"any\"", "\"lo\""]}, "err_obj": {"msg": "invalid syntax"}}], ["afe514e242bebe825fde32bd39ea15cc", {"code_string": "def parse_timezone(tzstring, default_timezone = UTC):\n    \"\"\"Parses ISO 8601 time zone specs into tzinfo offsets\"\"\"\n    if tzstring == \"Z\":\n    return default_timezone\n    if tzstring is None:\n    return default_timezone\n    m = TIMEZONE_REGEX.match(tzstring)\n    prefix, hours, minutes = m.groups()\n    hours, minutes = int(hours), int(minutes)\n    if prefix == \"-\":\n    hours = - hours\n    minutes = - minutes\n    return FixedOffset(hours, minutes, tzstring)\n", "code_toks_joined": "def parse_timezone ( tzstring , default_timezone = UTC ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if tzstring == <STRING> : <NEWLINE> return default_timezone <NEWLINE> if tzstring is None : <NEWLINE> return default_timezone <NEWLINE> m = TIMEZONE_REGEX . match ( tzstring ) <NEWLINE> prefix , hours , minutes = m . groups ( ) <NEWLINE> hours , minutes = int ( hours ) , int ( minutes ) <NEWLINE> if prefix == <STRING> : <NEWLINE> hours = - hours <NEWLINE> minutes = - minutes <NEWLINE> return FixedOffset ( hours , minutes , tzstring ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Parses ISO 8601 time zone specs into tzinfo offsets\"\"\"", "\"Z\"", "\"-\""]}, "err_obj": {"msg": "expected an indented block"}}], ["f9dfe607454787762b0f3fc2c7c45aa2", {"code_string": "def on_action_ExecuteCode(self):\n    try:\n        code = self.dlg.CodeField.Model.Text\n        exec code\n    except:\n        debugexception()\n    self.updateOutputInCreatorDialog()\n", "code_toks_joined": "def on_action_ExecuteCode ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> code = self . dlg . CodeField . Model . Text <NEWLINE> exec code <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> debugexception ( ) <NEWLINE> <DEDENT> self . updateOutputInCreatorDialog ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["d11e7ab33658fa1a44014985264b7d17", {"code_string": "def calculating_l():\n    X = [1.0, 0]\n    g = [10.0 ** 14.0, 10.0 ** 14.3, 10.0 ** 14.6, 10 ** 14.385]\n    Teff = [0.075, 0.1, 0.125, 0.272643294692, 0.008621738, 0.0343237572043\n", "code_toks_joined": "def calculating_l ( ) : <NEWLINE> <INDENT> X = [ 1.0 , 0 ] <NEWLINE> g = [ 10.0 ** 14.0 , 10.0 ** 14.3 , 10.0 ** 14.6 , 10 ** 14.385 ] <NEWLINE> Teff = [ 0.075 , 0.1 , 0.125 , 0.272643294692 , 0.008621738 , 0.0343237572043 <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["22bc9005e661be1d0202d9914e71e774", {"code_string": "def test_forceacquire(self):\n    with utils.NonBlockingLock(project = self.project_mock,\n        version = self.version_mock) as f_lock:\n        try:\n        with utils.NonBlockingLock(project = self.project_mock,\n            version = self.version_mock, max_lock_age = 0) as f_lock:\n            pass\n            except utils.LockTimeout:\n            raise AssertionError('Should have thrown LockTimeout')\n", "code_toks_joined": "def test_forceacquire ( self ) : <NEWLINE> <INDENT> with utils . NonBlockingLock ( project = self . project_mock , <NEWLINE> <INDENT> version = self . version_mock ) as f_lock : <NEWLINE> try : <NEWLINE> with utils . NonBlockingLock ( project = self . project_mock , <NEWLINE> <INDENT> version = self . version_mock , max_lock_age = 0 ) as f_lock : <NEWLINE> pass <NEWLINE> except utils . LockTimeout : <NEWLINE> raise AssertionError ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Should have thrown LockTimeout'"]}, "err_obj": {"msg": "expected an indented block"}}], ["ac70a9a5f0d4ade6f62d2b8cc975a37d", {"code_string": "def main():\n    num = int(input(\"Enter a number to be factorized: \"))\n    print(\"Its factors are: \" + str(trial_division(num))\n", "code_toks_joined": "def main ( ) : <NEWLINE> <INDENT> num = int ( input ( <STRING> ) ) <NEWLINE> print ( <STRING> + str ( trial_division ( num ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Enter a number to be factorized: \"", "\"Its factors are: \""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["0b59cb63ece4e4b5c74cb49b0e26ff44", {"code_string": "def __init__(self):\n    \"\"\"Constructor\"\"\"\n        self.data = {}\n", "code_toks_joined": "def __init__ ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> self . data = { } <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Constructor\"\"\""]}, "err_obj": {"msg": "unexpected indent"}}], ["3a6888758d6eabfcf949df68c4681771", {"code_string": "def add_grid(self, grid_name, grid):\n    \"\"\"adds a new grid from a hdf filesystem with:\"\"\"\n    gname_new = grid_name\n        while(gname_new in self.d_grids):\n            gname_new += \"1\"\n    self.d_grids[gname_new] = grid\n    return gname_new\n", "code_toks_joined": "def add_grid ( self , grid_name , grid ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> gname_new = grid_name <NEWLINE> <INDENT> while ( gname_new in self . d_grids ) : <NEWLINE> <INDENT> gname_new += <STRING> <NEWLINE> <DEDENT> <DEDENT> self . d_grids [ gname_new ] = grid <NEWLINE> return gname_new <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"adds a new grid from a hdf filesystem with:\"\"\"", "\"1\""]}, "err_obj": {"msg": "unexpected indent"}}], ["07f1aff11e2bbd22a2a270317da5931b", {"code_string": "def readkeys(module, filename):\n    if not os.path.isfile(filename)\n        return{}\n    keys = {}\n    f = open(filename)\n    for line in f.readlines():\n        key_data = parsekey(module, line)\n        if key_data:\n            keys[key_data[0]] = key_data\n        else:\n            keys[line] = line\n    f.close()\n    return keys\n", "code_toks_joined": "def readkeys ( module , filename ) : <NEWLINE> <INDENT> if not os . path . isfile ( filename ) <NEWLINE> <INDENT> return { } <NEWLINE> <DEDENT> keys = { } <NEWLINE> f = open ( filename ) <NEWLINE> for line in f . readlines ( ) : <NEWLINE> <INDENT> key_data = parsekey ( module , line ) <NEWLINE> if key_data : <NEWLINE> <INDENT> keys [ key_data [ 0 ] ] = key_data <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> keys [ line ] = line <NEWLINE> <DEDENT> <DEDENT> f . close ( ) <NEWLINE> return keys <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["2f34337ac3c6896cf72f07192f02749d", {"code_string": "def parse_and_install_all(lines, tag, skip_functions = None):\n    if skip_functions == None:\n        skip_functions = []\n    (structs, functions, const_globals) = parse_all(lines)\n    for f in skip_functions:\n        if f in functions:\n        del functions[f]\n    target_objects.structs.update(structs)\n    target_objects.functions.update(functions)\n    target_objects.const_globals.update(const_globals)\n    if tag != None:\n        target_objects.functions_by_tag[tag] = set(functions)\n    return(structs, functions, const_globals)\n", "code_toks_joined": "def parse_and_install_all ( lines , tag , skip_functions = None ) : <NEWLINE> <INDENT> if skip_functions == None : <NEWLINE> <INDENT> skip_functions = [ ] <NEWLINE> <DEDENT> ( structs , functions , const_globals ) = parse_all ( lines ) <NEWLINE> for f in skip_functions : <NEWLINE> <INDENT> if f in functions : <NEWLINE> del functions [ f ] <NEWLINE> <DEDENT> target_objects . structs . update ( structs ) <NEWLINE> target_objects . functions . update ( functions ) <NEWLINE> target_objects . const_globals . update ( const_globals ) <NEWLINE> if tag != None : <NEWLINE> <INDENT> target_objects . functions_by_tag [ tag ] = set ( functions ) <NEWLINE> <DEDENT> return ( structs , functions , const_globals ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["1321059e088cc75c217d125afa75e595", {"code_string": "def backprop(self, x, y):\n    \"\"\"Return a tuple (\"nabla_b, nabla_w\" representing the gradient\"\"\"\n    nabla_b = [np.zeros(b.shape) for b in self.biases]\n    nabla_w = [np.zeros(w.shape) for w in self.biases]\n    activation = x\n    activations = [x]\n    zs = []\n    for b, w in zip(self.biases, self.weights):\n        z = np.dot(w, activation) + b\n        zs.append(z)\n        activation = sigmoid(z)\n        activations.append(activation)\n    delta = self.cost_derivative(activations[- 1]], y) * sigmoid_prime(zs[- 1])\n    nabla_b[- 1] = delta\n    nabla_w[- 1] = np.dot(delta, activations[- 2].transpose())\n    for \u03bb in xrange(2, self.num_layers):\n        z = zs[- \u03bb]\n        zp = sigmoid_prime(z)\n        delta = np.dot(self.weights[- \u03bb + 1].transpose(), delta) * sp\n        nabla_b[- \u03bb] = delta\n        nabla_w[- \u03bb] = np.dot(delta, activations[- \u03bb - 1].transpose())\n    return(nabla_b, nabla_w)\n", "code_toks_joined": "def backprop ( self , x , y ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> nabla_b = [ np . zeros ( b . shape ) for b in self . biases ] <NEWLINE> nabla_w = [ np . zeros ( w . shape ) for w in self . biases ] <NEWLINE> activation = x <NEWLINE> activations = [ x ] <NEWLINE> zs = [ ] <NEWLINE> for b , w in zip ( self . biases , self . weights ) : <NEWLINE> <INDENT> z = np . dot ( w , activation ) + b <NEWLINE> zs . append ( z ) <NEWLINE> activation = sigmoid ( z ) <NEWLINE> activations . append ( activation ) <NEWLINE> <DEDENT> delta = self . cost_derivative ( activations [ - 1 ] ] , y ) * sigmoid_prime ( zs [ - 1 ] ) <NEWLINE> nabla_b [ - 1 ] = delta <NEWLINE> nabla_w [ - 1 ] = np . dot ( delta , activations [ - 2 ] . transpose ( ) ) <NEWLINE> for \u03bb in xrange ( 2 , self . num_layers ) : <NEWLINE> <INDENT> z = zs [ - \u03bb ] <NEWLINE> zp = sigmoid_prime ( z ) <NEWLINE> delta = np . dot ( self . weights [ - \u03bb + 1 ] . transpose ( ) , delta ) * sp <NEWLINE> nabla_b [ - \u03bb ] = delta <NEWLINE> nabla_w [ - \u03bb ] = np . dot ( delta , activations [ - \u03bb - 1 ] . transpose ( ) ) <NEWLINE> <DEDENT> return ( nabla_b , nabla_w ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return a tuple (\"nabla_b, nabla_w\" representing the gradient\"\"\""]}, "window_span": [119, 145], "err_obj": {"msg": "unbalanced (){}[]"}}], ["f0c8a735a5f4b94db35128264d681646", {"code_string": "def add(self, (s, p, o), context = None):\n    \"\"\"Add to to the given context or to the default context\"\"\"\n    if context is not None:\n        c = self.get_context(context)\n        assert c.identifier == context, \"%s != %s\" %(c.identifier, context)\n    else:\n        c = self.default_context\n    self.store.add((s, p, o), context = c, quoted = False)\n", "code_toks_joined": "def add ( self , ( s , p , o ) , context = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if context is not None : <NEWLINE> <INDENT> c = self . get_context ( context ) <NEWLINE> assert c . identifier == context , <STRING> % ( c . identifier , context ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = self . default_context <NEWLINE> <DEDENT> self . store . add ( ( s , p , o ) , context = c , quoted = False ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Add to to the given context or to the default context\"\"\"", "\"%s != %s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["8772f433da21102c380cd0ddcd896a6b", {"code_string": "def is_false_positive(i, j, all_gs, path_conditions):\n    pathi = path_conditions[i]\n    pathj = path_conditions[j]\n    statei = all_gs[i]\n    set_of_pcs, statei = rename_vars(pathi, statei)\n    if PRINT_MODE:\n        print \"Set of PCs after renaming global vars\" + str(set_of_pcs)\n    if PRINT_MODE:\n        print \"Global state values in path \" + str(i) + \" after renaming: \" + str(statei)\n    if is_feasible(set_of_pcs, statei, pathj):\n        return 0\n    else:\n        return 1\n", "code_toks_joined": "def is_false_positive ( i , j , all_gs , path_conditions ) : <NEWLINE> <INDENT> pathi = path_conditions [ i ] <NEWLINE> pathj = path_conditions [ j ] <NEWLINE> statei = all_gs [ i ] <NEWLINE> set_of_pcs , statei = rename_vars ( pathi , statei ) <NEWLINE> if PRINT_MODE : <NEWLINE> <INDENT> print <STRING> + str ( set_of_pcs ) <NEWLINE> <DEDENT> if PRINT_MODE : <NEWLINE> <INDENT> print <STRING> + str ( i ) + <STRING> + str ( statei ) <NEWLINE> <DEDENT> if is_feasible ( set_of_pcs , statei , pathj ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Set of PCs after renaming global vars\"", "\"Global state values in path \"", "\" after renaming: \""]}, "err_obj": {"msg": "invalid syntax"}}], ["5f857fa89a7012773c996ed79851ed9e", {"code_string": "def feed_data(self, data, size = 0):\n    has_waiter = self._waiter is not None and not self._waiter.cancelled()\n    super().feed_data(data)\n    if(not self._stream.paused and\n        not has_waiter and self._buffer_size > self._b_limit):\n        try:\n        self._stream.transport.pause_reading()\n        except(AttributeError, NotImplementedError):\n        pass\n        else:\n        self._stream.paused = True\n", "code_toks_joined": "def feed_data ( self , data , size = 0 ) : <NEWLINE> <INDENT> has_waiter = self . _waiter is not None and not self . _waiter . cancelled ( ) <NEWLINE> super ( ) . feed_data ( data ) <NEWLINE> if ( not self . _stream . paused and <NEWLINE> <INDENT> not has_waiter and self . _buffer_size > self . _b_limit ) : <NEWLINE> try : <NEWLINE> self . _stream . transport . pause_reading ( ) <NEWLINE> except ( AttributeError , NotImplementedError ) : <NEWLINE> pass <NEWLINE> else : <NEWLINE> self . _stream . paused = True <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["61e60654dc6b56644fde0075fe01c08d", {"code_string": "def apply_key_map(key_map, table):\n    new_dict = {}\n    for key in table\n        new_key = key_map.get(key)\n        if new_key:\n            new_dict[new_key] = table.get(key)\n    return new_dict\n", "code_toks_joined": "def apply_key_map ( key_map , table ) : <NEWLINE> <INDENT> new_dict = { } <NEWLINE> for key in table <NEWLINE> <INDENT> new_key = key_map . get ( key ) <NEWLINE> if new_key : <NEWLINE> <INDENT> new_dict [ new_key ] = table . get ( key ) <NEWLINE> <DEDENT> <DEDENT> return new_dict <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["c947cf03a41d8e858bd6e8c1ca021f34", {"code_string": "def render(i):\n    rank, fil = divmod(i - A1, 10)\n    return chr(fil + ord('a') + str(- rank + 1)\n", "code_toks_joined": "def render ( i ) : <NEWLINE> <INDENT> rank , fil = divmod ( i - A1 , 10 ) <NEWLINE> return chr ( fil + ord ( <STRING> ) + str ( - rank + 1 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'a'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e938a7701816bd2adcc87714fff5704f", {"code_string": "def serialize_data_type(data_type):\n    if is_instance(data_type, basestring) or is_instance(data_type, int)\n        return str(data_type)\n", "code_toks_joined": "def serialize_data_type ( data_type ) : <NEWLINE> <INDENT> if is_instance ( data_type , basestring ) or is_instance ( data_type , int ) <NEWLINE> <INDENT> return str ( data_type ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["ec27856631f929025d21c74b94d81c8a", {"code_string": "def findUSB(query):\n    c = 0\n    try:\n        while True:\n            print(_winreg.EnumKey(query, c))\n            c += 1\n    except WindowsError:\n    pass\n", "code_toks_joined": "def findUSB ( query ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> try : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> print ( _winreg . EnumKey ( query , c ) ) <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> except WindowsError : <NEWLINE> pass <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["f9d96ce754e3cf86b56a75784489755d", {"code_string": "def sql_remove_table_constraints(self, model, references_to_delete, style)\n    \"SQLite3 doesn't support constraints\"\n    return[]\n", "code_toks_joined": "def sql_remove_table_constraints ( self , model , references_to_delete , style ) <NEWLINE> <INDENT> <STRING> <NEWLINE> return [ ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"SQLite3 doesn't support constraints\""]}, "err_obj": {"msg": "invalid syntax"}}], ["62b437d094dc14d18c25fdc784df3ee7", {"code_string": "def test_equality(self):\n    \"\"\"It should be possible to check if a statement\"\"\"\n    self.statement.add_response(Statement(\"Yo\")\n    self.assertEqual(len(self.statement.in_response_to), 1)\n    self.assertIn(\n        Statement(\"Yo\"),\n        self.statement.in_response_to\n    )\n", "code_toks_joined": "def test_equality ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . statement . add_response ( Statement ( <STRING> ) <NEWLINE> self . assertEqual ( len ( self . statement . in_response_to ) , 1 ) <NEWLINE> self . assertIn ( <NEWLINE> <INDENT> Statement ( <STRING> ) , <NEWLINE> self . statement . in_response_to <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"It should be possible to check if a statement\"\"\"", "\"Yo\"", "\"Yo\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["26ddf8b72f8fa3bf1bd8f27fe2f002b1", {"code_string": "def save_state(self):\n    if self.has_saved_state():\n        raise RuntimeError, \"There is already a saved state! Restore that first.\"\n    if os.environ.has_key('X509_USER_PROXY'):\n        self.x509_proxy_saved_state = os.environ['X509_USER_PROXY']\n    else:\n        self.x509_proxy_saved_state = None\n    ProtoRequest.save_state(self)\n", "code_toks_joined": "def save_state ( self ) : <NEWLINE> <INDENT> if self . has_saved_state ( ) : <NEWLINE> <INDENT> raise RuntimeError , <STRING> <NEWLINE> <DEDENT> if os . environ . has_key ( <STRING> ) : <NEWLINE> <INDENT> self . x509_proxy_saved_state = os . environ [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . x509_proxy_saved_state = None <NEWLINE> <DEDENT> ProtoRequest . save_state ( self ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"There is already a saved state! Restore that first.\"", "'X509_USER_PROXY'", "'X509_USER_PROXY'"]}, "err_obj": {"msg": "invalid syntax"}}], ["bd36f8f5bafa26a1cbf967671a03d58e", {"code_string": "def options(self, inject):\n    options = {\n        'bucket': self.bucket,\n        'profile': self.profile,\n        'region': self.region,\n    }\n    if inject:\n        for option, var in[\n            ('bucket', self.bucket_var),\n            ('profile', self.profile_var),\n            ('region', self.region_var),\n            ]:\n            if var and var in inject:\n            options[option] = inject[var]\n    return options\n", "code_toks_joined": "def options ( self , inject ) : <NEWLINE> <INDENT> options = { <NEWLINE> <INDENT> <STRING> : self . bucket , <NEWLINE> <STRING> : self . profile , <NEWLINE> <STRING> : self . region , <NEWLINE> <DEDENT> } <NEWLINE> if inject : <NEWLINE> <INDENT> for option , var in [ <NEWLINE> <INDENT> ( <STRING> , self . bucket_var ) , <NEWLINE> ( <STRING> , self . profile_var ) , <NEWLINE> ( <STRING> , self . region_var ) , <NEWLINE> ] : <NEWLINE> if var and var in inject : <NEWLINE> options [ option ] = inject [ var ] <NEWLINE> <DEDENT> <DEDENT> return options <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'bucket'", "'profile'", "'region'", "'bucket'", "'profile'", "'region'"]}, "err_obj": {"msg": "expected an indented block"}}], ["18ea0485ae7fb6834e2f10a24518dbdf", {"code_string": "def print_version():\n    print(\"{} - {} - {}\".format(Constants.APP_NAME,\n        Constants.APP_VERSION,\n        Constants.APP_AUTHOR);\n    print(Constants.APP_COPYRIGHT)\n    print\n", "code_toks_joined": "def print_version ( ) : <NEWLINE> <INDENT> print ( <STRING> . format ( Constants . APP_NAME , <NEWLINE> <INDENT> Constants . APP_VERSION , <NEWLINE> Constants . APP_AUTHOR ) ; <NEWLINE> <DEDENT> print ( Constants . APP_COPYRIGHT ) <NEWLINE> print <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"{} - {} - {}\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["df9f5a1595596313564b13163e82c586", {"code_string": "def drawString(dst, (x, y), s):\n    cv2.putText(dst, s, (x + 1, y + 1), cv2.FONT_HERSHEY_PLAIN, 1.0, (0, 0, 0), thickness = 2, lineType = cv2.CV_AA)\n    cv2.putText(dst, s, (x, y), cv2.FONT_HERSHEY_PLAIN, 1.0, (255, 255, 255), lineType = cv2.CV_AA)\n", "code_toks_joined": "def drawString ( dst , ( x , y ) , s ) : <NEWLINE> <INDENT> cv2 . putText ( dst , s , ( x + 1 , y + 1 ) , cv2 . FONT_HERSHEY_PLAIN , 1.0 , ( 0 , 0 , 0 ) , thickness = 2 , lineType = cv2 . CV_AA ) <NEWLINE> cv2 . putText ( dst , s , ( x , y ) , cv2 . FONT_HERSHEY_PLAIN , 1.0 , ( 255 , 255 , 255 ) , lineType = cv2 . CV_AA ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["39a98b50f453322090d71a51bc28b93a", {"code_string": "def __len__(self):\n    if self.stop is None:\n        raise TypeError(\"infinite range\")\n    if self._has_neg_step:\n        calc = self.start - self.stop\n    else:\n        calc = self.stop - self.start\n    return int(ceil(abs(calc.total_seconds() / self.step.total_seconds()))\n", "code_toks_joined": "def __len__ ( self ) : <NEWLINE> <INDENT> if self . stop is None : <NEWLINE> <INDENT> raise TypeError ( <STRING> ) <NEWLINE> <DEDENT> if self . _has_neg_step : <NEWLINE> <INDENT> calc = self . start - self . stop <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> calc = self . stop - self . start <NEWLINE> <DEDENT> return int ( ceil ( abs ( calc . total_seconds ( ) / self . step . total_seconds ( ) ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"infinite range\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["bc1a1b6a38d1eeea7e7f3c25a67e1409", {"code_string": "def define_residuals(self, model_name, residuals, residuals_dictionnary):\n    keys = ['time', 'delta_mag', 'err_mag']\n    self.residuals[model_name] = collections.namedtuple('RESIDUALS', keys)\n    values = [residuals[: , residuals_dictionnary['time']],\n        residuals[: , residuals_dictionnary['delta_mag']],\n        residuals[: , residuals_dictionnary['err_mag']]\n        ]\n    count = 0\n        for key in keys:\n            setattr(self.residuals[model_name], key, values[count])\n            count += 1\n", "code_toks_joined": "def define_residuals ( self , model_name , residuals , residuals_dictionnary ) : <NEWLINE> <INDENT> keys = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> self . residuals [ model_name ] = collections . namedtuple ( <STRING> , keys ) <NEWLINE> values = [ residuals [ : , residuals_dictionnary [ <STRING> ] ] , <NEWLINE> <INDENT> residuals [ : , residuals_dictionnary [ <STRING> ] ] , <NEWLINE> residuals [ : , residuals_dictionnary [ <STRING> ] ] <NEWLINE> ] <NEWLINE> <DEDENT> count = 0 <NEWLINE> <INDENT> for key in keys : <NEWLINE> <INDENT> setattr ( self . residuals [ model_name ] , key , values [ count ] ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'time'", "'delta_mag'", "'err_mag'", "'RESIDUALS'", "'time'", "'delta_mag'", "'err_mag'"]}, "err_obj": {"msg": "unexpected indent"}}], ["a96a8c66ea79bd87c4bfcb36a63cc5f7", {"code_string": "def getflags(self):\n    try:\n        if self.flags:\n            pass\n    except AttributeError:\n        self.flags = [\"\"]\n    try:\n        if self.cl.c_display:\n            self.flags +=[\"console\"]\n    except AttributeError:\n        pass\n    try:\n        if self.cl.g_display:\n            self.flags +=[\"gui\"]\n    except AttributeError:\n    pass\n", "code_toks_joined": "def getflags ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if self . flags : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> except AttributeError : <NEWLINE> <INDENT> self . flags = [ <STRING> ] <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> if self . cl . c_display : <NEWLINE> <INDENT> self . flags += [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT> except AttributeError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> if self . cl . g_display : <NEWLINE> <INDENT> self . flags += [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT> except AttributeError : <NEWLINE> pass <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"", "\"console\"", "\"gui\""]}, "err_obj": {"msg": "expected an indented block"}}], ["e78aaa74e73db16aac4c9a746e19fec1", {"code_string": "def run_once(self, test_path = ''):\n    \"\"\"Trigger test run\"\"\"\n    try:\n        os.environ[\"LTPBIN\"] = \"%s/shared\" %(test_path)\n        ret_val = subprocess.call(test_path + '/urlview' + '/urlview.sh', shell = True)\n        if ret_val != 0:\n            self.nfail += 1\n    except error.CmdError, e:\n        self.nfail += 1\n        logging.error(\"Test Failed: %s\", e)\n", "code_toks_joined": "def run_once ( self , test_path = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> os . environ [ <STRING> ] = <STRING> % ( test_path ) <NEWLINE> ret_val = subprocess . call ( test_path + <STRING> + <STRING> , shell = True ) <NEWLINE> if ret_val != 0 : <NEWLINE> <INDENT> self . nfail += 1 <NEWLINE> <DEDENT> <DEDENT> except error . CmdError , e : <NEWLINE> <INDENT> self . nfail += 1 <NEWLINE> logging . error ( <STRING> , e ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''", "\"\"\"Trigger test run\"\"\"", "\"LTPBIN\"", "\"%s/shared\"", "'/urlview'", "'/urlview.sh'", "\"Test Failed: %s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["fd36a64671dbacbc11675595cf31410e", {"code_string": "def testDeviceWrapper(self):\n    with variable_scope.variable_scope(\n        \"root\", initializer = init_ops.constant_initializer(0.5)):\n        x = array_ops.zeros([1, 3])\n        m = array_ops.zeros([1, 3])\n        cell = core_rnn_cell_impl.DeviceWrapper(\n            core_rnn_cell_impl.GRUCell(3), \"/cpu:14159\")\n            outputs, _ = cell(x, m)\n            self.assertTrue(\"cpu:14159\" in outputs.device.lower())\n", "code_toks_joined": "def testDeviceWrapper ( self ) : <NEWLINE> <INDENT> with variable_scope . variable_scope ( <NEWLINE> <INDENT> <STRING> , initializer = init_ops . constant_initializer ( 0.5 ) ) : <NEWLINE> x = array_ops . zeros ( [ 1 , 3 ] ) <NEWLINE> m = array_ops . zeros ( [ 1 , 3 ] ) <NEWLINE> cell = core_rnn_cell_impl . DeviceWrapper ( <NEWLINE> <INDENT> core_rnn_cell_impl . GRUCell ( 3 ) , <STRING> ) <NEWLINE> outputs , _ = cell ( x , m ) <NEWLINE> self . assertTrue ( <STRING> in outputs . device . lower ( ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"root\"", "\"/cpu:14159\"", "\"cpu:14159\""]}, "err_obj": {"msg": "unexpected indent"}}], ["63b7ec9c30a69a4f78f6da59d55baf18", {"code_string": "def assertCollection(self, obj, observed):\n    observed_json = json.loads(observed)\n    for what, fn in[(\"kinds\", self.assertKind),\n        (\"mixins\", self.assertMixin),\n        (\"actions\", self.assertAction),\n        (\"links\", self.assertLink),\n        (\"resources\", self.assertResource)]:\n        objs = getattr(obj, what)\n        if objs:\n        dumped_objs = [json.dumps(o) for o in observed_json[what]]\n        map(fn, objs, dumped_objs)\n", "code_toks_joined": "def assertCollection ( self , obj , observed ) : <NEWLINE> <INDENT> observed_json = json . loads ( observed ) <NEWLINE> for what , fn in [ ( <STRING> , self . assertKind ) , <NEWLINE> <INDENT> ( <STRING> , self . assertMixin ) , <NEWLINE> ( <STRING> , self . assertAction ) , <NEWLINE> ( <STRING> , self . assertLink ) , <NEWLINE> ( <STRING> , self . assertResource ) ] : <NEWLINE> objs = getattr ( obj , what ) <NEWLINE> if objs : <NEWLINE> dumped_objs = [ json . dumps ( o ) for o in observed_json [ what ] ] <NEWLINE> map ( fn , objs , dumped_objs ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"kinds\"", "\"mixins\"", "\"actions\"", "\"links\"", "\"resources\""]}, "err_obj": {"msg": "expected an indented block"}}], ["68f6c370d6e2747ff10087bb2f0c6f31", {"code_string": "class Error(Exception):\n    \"base class for our errors.\"\n    def __init__(self, msg, status = None)\n        Exception.__init__(self)\n        self.msg = msg\n        self.resultcode = 1\n        if status is not None:\n            self.resultcode = status\n    def __str__(self):\n        return self.msg\n", "code_toks_joined": "class Error ( Exception ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , msg , status = None ) <NEWLINE> <INDENT> Exception . __init__ ( self ) <NEWLINE> self . msg = msg <NEWLINE> self . resultcode = 1 <NEWLINE> if status is not None : <NEWLINE> <INDENT> self . resultcode = status <NEWLINE> <DEDENT> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return self . msg <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"base class for our errors.\""]}, "err_obj": {"msg": "invalid syntax"}}], ["60abab39931827dcde31845a1f0cb700", {"code_string": "def setStartPoint(self, x, y):\n    \"\"\"Set the start point of the parking space.\"\"\"\n        if not isinstance(x, int) and not isinstance(y, int):\n            print(\"ERROR: Cannot set start point: x & y must be integers.\")\n        self.__start_point = [x, y]\n        return self\n", "code_toks_joined": "def setStartPoint ( self , x , y ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> if not isinstance ( x , int ) and not isinstance ( y , int ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> self . __start_point = [ x , y ] <NEWLINE> return self <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Set the start point of the parking space.\"\"\"", "\"ERROR: Cannot set start point: x & y must be integers.\""]}, "err_obj": {"msg": "unexpected indent"}}], ["12e27beecde0d2087c51128780ab10f1", {"code_string": "def retranslateUi(self, OptionsDialogBase):\n    OptionsDialogBase.setWindowTitle(_translate(\"OptionsDialogBase\", \"InaSAFE - Options\", None))\n    self.cbxVisibleLayersOnly.setText(_translate(\"OptionsDialogBase\", \"Only show visible layers in InaSAFE dock\", None))\n    self.cbxSetLayerNameFromTitle.setText(_translate(\"OptionsDialogBase\", \"Set QGIS layer name from \\'title\\' in keywords\", None))\n    self.cbxZoomToImpact.setText(_translate(\"OptionsDialogBase\", \"Zoom to impact layer on scenario estimate completion\", None))\n    self.cbxHideExposure.setText(_translate(\"OptionsDialogBase\", \"Hide exposure layer on scenario estimate completion\", None))\n    self.cbxClipToViewport.setToolTip(_translate(\"OptionsDialogBase\", \"Turn on to clip hazard and exposure layers to the currently  visible extent on the map canvas\", None))\n    self.cbxClipToViewport.setText(_translate(\"OptionsDialogBase\", \"Clip datasets to visible extent before analysis\", None))\n    self.cbxClipHard.setText(_translate(\"OptionsDialogBase\", \"When clipping, also clip features (i.e. will clip polygon smaller)\", None))\n    self.cbxShowPostprocessingLayers.setToolTip(_translate(\"OptionsDialogBase\", \"Turn on to see the intermediate files generated by the postprocessing steps in the map canvas\", None))\n    self.cbxShowPostprocessingLayers.setText(_translate(\"OptionsDialogBase\", \"Show intermediate layers generated by postprocessing\", None))\n    self.label_6.setText(_translate(\"OptionsDialogBase\", \"Female ratio default value\", None))\n    self.grpNotImplemented.setTitle(_translate(\"OptionsDialogBase\", \"Not yet implemented\", None))\n    self.toolButton_4.setText(_translate(\"OptionsDialogBase\", \"...\", None))\n    self.label_4.setText(_translate(\"OptionsDialogBase\", \"Organisation name (for maps, reports etc.)\", None))\n    self.cbxBubbleLayersUp.setText(_translate(\"OptionsDialogBase\", \"Bubble exposure and hazard layers to top when selected\", None))\n    self.label_5.setText(_translate(\"OptionsDialogBase\", \"DPI (Maps and reports)\", None))\n    self.toolButton.setText(_translate(\"OptionsDialogBase\", \"...\", None))\n    self.label.setText(_translate(\"OptionsDialogBase\", \"Location for results\", None))\n    self.cbxUseThread.setText(_translate(\"OptionsDialogBase\", \"Run analysis in a separate thread (experimental)\", None))\n    self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_basic), _translate(\"OptionsDialogBase\", \"Basic Options\", None))\n    self.lblOrganisationLogo.setText(_translate(\"OptionsDialogBase\", \"Organisation logo\", None))\n    self.toolOrgLogoPath.setText(_translate(\"OptionsDialogBase\", \"...\", None))\n    self.lblNorthArrowPath.setText(_translate(\"OptionsDialogBase\", \"North arrow image\", None))\n    self.toolNorthArrowPath.setText(_translate(\"OptionsDialogBase\", \"...\", None))\n    self.lblReportTemplate.setText(_translate(\"OptionsDialogBase\", \"Report templates directory\", None))\n    self.toolReportTemplatePath.setText(_translate(\"OptionsDialogBase\", \"...\", None))\n    self.label_2.setText(_translate(\"OptionsDialogBase\", \"Organisation disclaimer text\", None))\n    self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_templates), _translate(\"OptionsDialogBase\", \"Template Options\", None))\n    self.lblKeywordCache.setText(_translate(\"OptionsDialogBase\", \"Keyword cache for remote datasources\", None))\n    self.toolKeywordCachePath.setText(_translate(\"OptionsDialogBase\", \"...\", None))\n    self.cbxUseSentry.setText(_translate(\"OptionsDialogBase\", \"Help to improve InaSAFE by submitting errors to a remote server\", None))\n    self.textBrowser.setHtml(_translate(\"OptionsDialogBase\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , OptionsDialogBase ) : <NEWLINE> <INDENT> OptionsDialogBase . setWindowTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . cbxVisibleLayersOnly . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . cbxSetLayerNameFromTitle . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . cbxZoomToImpact . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . cbxHideExposure . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . cbxClipToViewport . setToolTip ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . cbxClipToViewport . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . cbxClipHard . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . cbxShowPostprocessingLayers . setToolTip ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . cbxShowPostprocessingLayers . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_6 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . grpNotImplemented . setTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . toolButton_4 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_4 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . cbxBubbleLayersUp . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_5 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . toolButton . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . cbxUseThread . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . tabWidget . setTabText ( self . tabWidget . indexOf ( self . tab_basic ) , _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . lblOrganisationLogo . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . toolOrgLogoPath . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . lblNorthArrowPath . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . toolNorthArrowPath . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . lblReportTemplate . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . toolReportTemplatePath . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_2 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . tabWidget . setTabText ( self . tabWidget . indexOf ( self . tab_templates ) , _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . lblKeywordCache . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . toolKeywordCachePath . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . cbxUseSentry . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . textBrowser . setHtml ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"OptionsDialogBase\"", "\"InaSAFE - Options\"", "\"OptionsDialogBase\"", "\"Only show visible layers in InaSAFE dock\"", "\"OptionsDialogBase\"", "\"Set QGIS layer name from \\'title\\' in keywords\"", "\"OptionsDialogBase\"", "\"Zoom to impact layer on scenario estimate completion\"", "\"OptionsDialogBase\"", "\"Hide exposure layer on scenario estimate completion\"", "\"OptionsDialogBase\"", "\"Turn on to clip hazard and exposure layers to the currently  visible extent on the map canvas\"", "\"OptionsDialogBase\"", "\"Clip datasets to visible extent before analysis\"", "\"OptionsDialogBase\"", "\"When clipping, also clip features (i.e. will clip polygon smaller)\"", "\"OptionsDialogBase\"", "\"Turn on to see the intermediate files generated by the postprocessing steps in the map canvas\"", "\"OptionsDialogBase\"", "\"Show intermediate layers generated by postprocessing\"", "\"OptionsDialogBase\"", "\"Female ratio default value\"", "\"OptionsDialogBase\"", "\"Not yet implemented\"", "\"OptionsDialogBase\"", "\"...\"", "\"OptionsDialogBase\"", "\"Organisation name (for maps, reports etc.)\"", "\"OptionsDialogBase\"", "\"Bubble exposure and hazard layers to top when selected\"", "\"OptionsDialogBase\"", "\"DPI (Maps and reports)\"", "\"OptionsDialogBase\"", "\"...\"", "\"OptionsDialogBase\"", "\"Location for results\"", "\"OptionsDialogBase\"", "\"Run analysis in a separate thread (experimental)\"", "\"OptionsDialogBase\"", "\"Basic Options\"", "\"OptionsDialogBase\"", "\"Organisation logo\"", "\"OptionsDialogBase\"", "\"...\"", "\"OptionsDialogBase\"", "\"North arrow image\"", "\"OptionsDialogBase\"", "\"...\"", "\"OptionsDialogBase\"", "\"Report templates directory\"", "\"OptionsDialogBase\"", "\"...\"", "\"OptionsDialogBase\"", "\"Organisation disclaimer text\"", "\"OptionsDialogBase\"", "\"Template Options\"", "\"OptionsDialogBase\"", "\"Keyword cache for remote datasources\"", "\"OptionsDialogBase\"", "\"...\"", "\"OptionsDialogBase\"", "\"Help to improve InaSAFE by submitting errors to a remote server\"", "\"OptionsDialogBase\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "window_span": [531, 539], "err_obj": {"msg": "unbalanced (){}[]"}}], ["d3caaa86eebd95742a41874576fcaca3", {"code_string": "def add_polygon_rec(self, node, new_segment):\n    \"\"\"add new polygon in tree. right position is found recursively.\"\"\"\n    if self.is_included(new_segment, node.content):\n        for child in sorted(list(node.alive_children.values()),\n            key = lambda c: c.height, reverse = True):\n            if self.add_polygon_rec(child, new_segment):\n            return True\n        if node.is_polygon or new_segment.height == node.height:\n            self.add_child_in_tree(node, new_segment)\n            return True\n    return False\n", "code_toks_joined": "def add_polygon_rec ( self , node , new_segment ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . is_included ( new_segment , node . content ) : <NEWLINE> <INDENT> for child in sorted ( list ( node . alive_children . values ( ) ) , <NEWLINE> <INDENT> key = lambda c : c . height , reverse = True ) : <NEWLINE> if self . add_polygon_rec ( child , new_segment ) : <NEWLINE> return True <NEWLINE> <DEDENT> if node . is_polygon or new_segment . height == node . height : <NEWLINE> <INDENT> self . add_child_in_tree ( node , new_segment ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"add new polygon in tree. right position is found recursively.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["e76dfe9b2972d8d53d4dd1727d47539c", {"code_string": "def setupRedLedOff(self):\n    imRedLedOffTk = ImageTk.PhotoImage(Image.open(\"redoff.jpg\"))\n    label1 = Label(Tk, image = imRedLedOffTk)\n    label1.image = imRedLedOffTk\n    label1.place(x = 180, y = 20)\n    try\n        bus.write('red off\\r')\n        bus.close()\n    except:\n        bus.close()\n    raise\n", "code_toks_joined": "def setupRedLedOff ( self ) : <NEWLINE> <INDENT> imRedLedOffTk = ImageTk . PhotoImage ( Image . open ( <STRING> ) ) <NEWLINE> label1 = Label ( Tk , image = imRedLedOffTk ) <NEWLINE> label1 . image = imRedLedOffTk <NEWLINE> label1 . place ( x = 180 , y = 20 ) <NEWLINE> try <NEWLINE> <INDENT> bus . write ( <STRING> ) <NEWLINE> bus . close ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> bus . close ( ) <NEWLINE> <DEDENT> raise <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"redoff.jpg\"", "'red off\\r'"]}, "err_obj": {"msg": "invalid syntax"}}], ["95980fbc229a402bad0f54b3b65a9e34", {"code_string": "def push_args(self):\n    '''Arguments to pass to push to push this ref.'''\n    return('%(force)s%(source)s:%(target)s' %{\n        'force': '+' if self.force else '',\n        'source': self.source,\n        'target': self.target\n", "code_toks_joined": "def push_args ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return ( <STRING> % { <NEWLINE> <INDENT> <STRING> : <STRING> if self . force else <STRING> , <NEWLINE> <STRING> : self . source , <NEWLINE> <STRING> : self . target <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Arguments to pass to push to push this ref.'''", "'%(force)s%(source)s:%(target)s'", "'force'", "'+'", "''", "'source'", "'target'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["79eb8b3115ce763c1a073873249ef546", {"code_string": "def stop(self):\n    if not self.pid:\n        return False\n    try:\n        os.kill(self.pid, signal.SIGTERM)\n            os.waitpid(self.pid, 0)\n    except Exception, e:\n        print('Vlc wasn\\'t here anymore', e)\n        pass\n    return True\n", "code_toks_joined": "def stop ( self ) : <NEWLINE> <INDENT> if not self . pid : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> os . kill ( self . pid , signal . SIGTERM ) <NEWLINE> <INDENT> os . waitpid ( self . pid , 0 ) <NEWLINE> <DEDENT> <DEDENT> except Exception , e : <NEWLINE> <INDENT> print ( <STRING> , e ) <NEWLINE> pass <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Vlc wasn\\'t here anymore'"]}, "err_obj": {"msg": "unexpected indent"}}], ["deb81d60e0522f497d2e13134877ac7b", {"code_string": "class FakeFeedParser(dict):\n    def __init__(self, uri, etag = None, modified = None):\n        self.update(dict(\n            uri = uri,\n            bozo = 0,\n            feed = FakeParsedFeed('Example'),\n            entries = [\n                FakeParsedEntry(name) for name in 'E1', 'E2', 'E3', 'E4'],\n            status = 304 if etag else 200,\n            etag = etag,\n            modified = modified,\n            ))\n    def __getattr__(self, name):\n        return self[name]\n", "code_toks_joined": "class FakeFeedParser ( dict ) : <NEWLINE> <INDENT> def __init__ ( self , uri , etag = None , modified = None ) : <NEWLINE> <INDENT> self . update ( dict ( <NEWLINE> <INDENT> uri = uri , <NEWLINE> bozo = 0 , <NEWLINE> feed = FakeParsedFeed ( <STRING> ) , <NEWLINE> entries = [ <NEWLINE> <INDENT> FakeParsedEntry ( name ) for name in <STRING> , <STRING> , <STRING> , <STRING> ] , <NEWLINE> <DEDENT> status = 304 if etag else 200 , <NEWLINE> etag = etag , <NEWLINE> modified = modified , <NEWLINE> ) ) <NEWLINE> <DEDENT> <DEDENT> def __getattr__ ( self , name ) : <NEWLINE> <INDENT> return self [ name ] <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Example'", "'E1'", "'E2'", "'E3'", "'E4'"]}, "err_obj": {"msg": "invalid syntax"}}], ["ec2ee5785e89e44c5e752d8c4ff2c35f", {"code_string": "def value(self, value):\n    if isinstance(value, (six.string_types, six.integer_types, float, bool):\n        self._value = value\n", "code_toks_joined": "def value ( self , value ) : <NEWLINE> <INDENT> if isinstance ( value , ( six . string_types , six . integer_types , float , bool ) : <NEWLINE> <INDENT> self . _value = value <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["b2f1bf98d58addab4474695ad049d448", {"code_string": "def parse_nodename(nodename):\n    global NODE_EXPR\n    parts = re.search(r'%s' % NODE_EXPR, nodename, re.VERBOSE)\n    try:\n        racknr = parts.group('racknr')\n    except Exception:\n    racknr = 0\n    try:\n        nodenr = parts.group('nodenr')\n    except Exception:\n        nodenr = 0\n    return int(racknr), int(nodenr)\n", "code_toks_joined": "def parse_nodename ( nodename ) : <NEWLINE> <INDENT> global NODE_EXPR <NEWLINE> parts = re . search ( <STRING> % NODE_EXPR , nodename , re . VERBOSE ) <NEWLINE> try : <NEWLINE> <INDENT> racknr = parts . group ( <STRING> ) <NEWLINE> <DEDENT> except Exception : <NEWLINE> racknr = 0 <NEWLINE> try : <NEWLINE> <INDENT> nodenr = parts . group ( <STRING> ) <NEWLINE> <DEDENT> except Exception : <NEWLINE> <INDENT> nodenr = 0 <NEWLINE> <DEDENT> return int ( racknr ) , int ( nodenr ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["r'%s'", "'racknr'", "'nodenr'"]}, "err_obj": {"msg": "expected an indented block"}}], ["d34c3197ea1c81313c4ca707e991b134", {"code_string": "def test_distance_mi(self, precision = 3):\n    index = GeoGridIndex(precision = precision)\n    map(index.add_point, self.points)\n    for pt, distance in index.get_nearest_points(\n        self.point_1bluxome, 10, 'mi'):\n        if pt == self.point_1bluxome:\n        self.assertEquals(distance, 0)\n        if pt == self.point_market_street:\n        self.assertEquals(distance, 0.808573403337458)\n", "code_toks_joined": "def test_distance_mi ( self , precision = 3 ) : <NEWLINE> <INDENT> index = GeoGridIndex ( precision = precision ) <NEWLINE> map ( index . add_point , self . points ) <NEWLINE> for pt , distance in index . get_nearest_points ( <NEWLINE> <INDENT> self . point_1bluxome , 10 , <STRING> ) : <NEWLINE> if pt == self . point_1bluxome : <NEWLINE> self . assertEquals ( distance , 0 ) <NEWLINE> if pt == self . point_market_street : <NEWLINE> self . assertEquals ( distance , 0.808573403337458 ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'mi'"]}, "err_obj": {"msg": "expected an indented block"}}], ["f83b4f38a4c4ffe0e3fc6635cf6f8ec8", {"code_string": "def help_query(self):\n    print(_(\"The query command allows querying package information,\\n\")\n        \"and accepts the same options available in the command\\n\"\n        \"line interface.\")\n    print\n    print(_(\"Usage: query [options] [<pkgname>] ...\"))\n", "code_toks_joined": "def help_query ( self ) : <NEWLINE> <INDENT> print ( _ ( <STRING> ) <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> print <NEWLINE> print ( _ ( <STRING> ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"The query command allows querying package information,\\n\"", "\"and accepts the same options available in the command\\n\"", "\"line interface.\"", "\"Usage: query [options] [<pkgname>] ...\""]}, "err_obj": {"msg": "invalid syntax"}}], ["29f58dbca6afab900c3efe1af51b815b", {"code_string": "def read_file(option, opt, value, parser):\n    try:\n        with open(value) as f:\n            setattr(parser.values, option.dest, f.read())\n    except Exception, e:\n        raise OptionValueError(\"Error opening '%s' for %s: %s\" %\n            (value, opt, e))\n", "code_toks_joined": "def read_file ( option , opt , value , parser ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> with open ( value ) as f : <NEWLINE> <INDENT> setattr ( parser . values , option . dest , f . read ( ) ) <NEWLINE> <DEDENT> <DEDENT> except Exception , e : <NEWLINE> <INDENT> raise OptionValueError ( <STRING> % <NEWLINE> <INDENT> ( value , opt , e ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Error opening '%s' for %s: %s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["85ed4f630746dc5f7c49b95581170292", {"code_string": "def get_tx_confirmations(self, txhash):\n    url = \"https: //%s.helloblock.io/v1/transactions/%s\" %(self.net_prefix, txhash)\n    try:\n        resp = json.loads(urllib2.urlopen(url).read()\n        if resp['status'] == 'success':\n            return resp['data']['transaction']['confirmations']\n    except:\n        raise\n    return 0\n", "code_toks_joined": "def get_tx_confirmations ( self , txhash ) : <NEWLINE> <INDENT> url = <STRING> % ( self . net_prefix , txhash ) <NEWLINE> try : <NEWLINE> <INDENT> resp = json . loads ( urllib2 . urlopen ( url ) . read ( ) <NEWLINE> if resp [ <STRING> ] == <STRING> : <NEWLINE> <INDENT> return resp [ <STRING> ] [ <STRING> ] [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"https: //%s.helloblock.io/v1/transactions/%s\"", "'status'", "'success'", "'data'", "'transaction'", "'confirmations'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["73df9933d4b1302683aa50c09660fcc7", {"code_string": "def _duplicateQualityChangesForMachineType(self, quality_changes_name, base_name, machine_definition):\n    new_change_instances = []\n    for container in QualityManager.getInstance().findQualityChangesByName(quality_changes_name,\n        machine_definition):\n        base_id = container.getMetaDataEntry(\"extruder\")\n        if not base_id:\n        base_id = container.getDefinition().getId()\n        new_unique_id = self._createUniqueId(base_id, base_name)\n        new_container = container.duplicate(new_unique_id, base_name)\n        new_change_instances.append(new_container)\n        self._container_registry.addContainer(new_container)\n    return new_change_instances\n", "code_toks_joined": "def _duplicateQualityChangesForMachineType ( self , quality_changes_name , base_name , machine_definition ) : <NEWLINE> <INDENT> new_change_instances = [ ] <NEWLINE> for container in QualityManager . getInstance ( ) . findQualityChangesByName ( quality_changes_name , <NEWLINE> <INDENT> machine_definition ) : <NEWLINE> base_id = container . getMetaDataEntry ( <STRING> ) <NEWLINE> if not base_id : <NEWLINE> base_id = container . getDefinition ( ) . getId ( ) <NEWLINE> new_unique_id = self . _createUniqueId ( base_id , base_name ) <NEWLINE> new_container = container . duplicate ( new_unique_id , base_name ) <NEWLINE> new_change_instances . append ( new_container ) <NEWLINE> self . _container_registry . addContainer ( new_container ) <NEWLINE> <DEDENT> return new_change_instances <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"extruder\""]}, "err_obj": {"msg": "expected an indented block"}}], ["c6f5bb64eae22c8a40097484df22a8be", {"code_string": "def sentence_word_order_vector(s, joint_word_set):\n    s_words = re.sub(\"[^\\w-]\", \" \", s1).split()\n    wov = [0] * len(joint_word_set)\n    for i in range(0, len(joint_word_set))\n        try:\n            index = s_words.index(joint_word_set[i])\n            wov[i] = index\n        except ValueError:\n            index = word_semantic_similarity(joint_word_set[i], s)[2]\n            wov[i] = index\n", "code_toks_joined": "def sentence_word_order_vector ( s , joint_word_set ) : <NEWLINE> <INDENT> s_words = re . sub ( <STRING> , <STRING> , s1 ) . split ( ) <NEWLINE> wov = [ 0 ] * len ( joint_word_set ) <NEWLINE> for i in range ( 0 , len ( joint_word_set ) ) <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> index = s_words . index ( joint_word_set [ i ] ) <NEWLINE> wov [ i ] = index <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> index = word_semantic_similarity ( joint_word_set [ i ] , s ) [ 2 ] <NEWLINE> wov [ i ] = index <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"[^\\w-]\"", "\" \""]}, "err_obj": {"msg": "invalid syntax"}}], ["ce22f4710776cc4f642b70754e922169", {"code_string": "def dss_command(self, command):\n    self.ser.flushInput()\n    command.insert(0, self.options[\"pre_request\"])\n    while len(command) > 0:\n        a = command.pop(0)\n        if debug:\n            print \".. sending \" + str(a)\n        self.ser.write(chr(a))\n    return self.__get_reply()\n", "code_toks_joined": "def dss_command ( self , command ) : <NEWLINE> <INDENT> self . ser . flushInput ( ) <NEWLINE> command . insert ( 0 , self . options [ <STRING> ] ) <NEWLINE> while len ( command ) > 0 : <NEWLINE> <INDENT> a = command . pop ( 0 ) <NEWLINE> if debug : <NEWLINE> <INDENT> print <STRING> + str ( a ) <NEWLINE> <DEDENT> self . ser . write ( chr ( a ) ) <NEWLINE> <DEDENT> return self . __get_reply ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"pre_request\"", "\".. sending \""]}, "err_obj": {"msg": "invalid syntax"}}], ["cd12f93a88a5817c3faceb1abced1d59", {"code_string": "class Mixin(category.Category):\n    \"\"\"OCCI Mixin.\"\"\"\n    def __init__(self, scheme, term, title, attributes = None, location = None,\n        related = [], actions = []):\n        super(Mixin, self).__init__(scheme, term, title, attributes = attributes,\n            location = location)\n            helpers.check_type(related, Mixin)\n            helpers.check_type(actions, action.Action)\n            self.related = related\n            self.actions = actions\n    def _class_name(self):\n        return \"mixin\"\n", "code_toks_joined": "class Mixin ( category . Category ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , scheme , term , title , attributes = None , location = None , <NEWLINE> <INDENT> related = [ ] , actions = [ ] ) : <NEWLINE> super ( Mixin , self ) . __init__ ( scheme , term , title , attributes = attributes , <NEWLINE> <INDENT> location = location ) <NEWLINE> helpers . check_type ( related , Mixin ) <NEWLINE> helpers . check_type ( actions , action . Action ) <NEWLINE> self . related = related <NEWLINE> self . actions = actions <NEWLINE> <DEDENT> <DEDENT> def _class_name ( self ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"OCCI Mixin.\"\"\"", "\"mixin\""]}, "err_obj": {"msg": "unexpected indent"}}], ["33dc3dfca19d20f5ed9341679c3bd7b4", {"code_string": "def replace_astral(log_list):\n    for item in log_list:\n        for key in[\"test\", \"subtest\", \"message\", \"stack\", \"stackwalk_stdout\",\n            \"stackwalk_stderr\"]:\n            if key in item:\n            item[key] = astral_filter(item[key])\n        yield item\n", "code_toks_joined": "def replace_astral ( log_list ) : <NEWLINE> <INDENT> for item in log_list : <NEWLINE> <INDENT> for key in [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ] : <NEWLINE> if key in item : <NEWLINE> item [ key ] = astral_filter ( item [ key ] ) <NEWLINE> <DEDENT> yield item <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"test\"", "\"subtest\"", "\"message\"", "\"stack\"", "\"stackwalk_stdout\"", "\"stackwalk_stderr\""]}, "err_obj": {"msg": "expected an indented block"}}], ["ed58fb39e4728756dd78e8967979b471", {"code_string": "def stop(self):\n    \"\"\"Stop the motor and turn off all leds\"\"\"\n    if not self.conexion_status:\n        raise Exception, 'There is not connection'\n    reply = self.send_and_receive(\"S\")\n    self._debug(reply)\n    if reply == \"s\":\n        return True\n    else:\n        return False\n", "code_toks_joined": "def stop ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not self . conexion_status : <NEWLINE> <INDENT> raise Exception , <STRING> <NEWLINE> <DEDENT> reply = self . send_and_receive ( <STRING> ) <NEWLINE> self . _debug ( reply ) <NEWLINE> if reply == <STRING> : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Stop the motor and turn off all leds\"\"\"", "'There is not connection'", "\"S\"", "\"s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["ad8fd9f4f88057d5fa0d398259d3fa2e", {"code_string": "def worker_kill(self, pid, sig):\n    try:\n        os.kill(pid, sig)\n    except OSError, e:\n        if e.errno == errno.ESRCH:\n            self.worker_pop(pid)\n", "code_toks_joined": "def worker_kill ( self , pid , sig ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> os . kill ( pid , sig ) <NEWLINE> <DEDENT> except OSError , e : <NEWLINE> <INDENT> if e . errno == errno . ESRCH : <NEWLINE> <INDENT> self . worker_pop ( pid ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["432861123c8622b44b6371a1b1d0c620", {"code_string": "def all_checked(self):\n    amber = Status.query.filter(Status.status_name == 'Amber').first()\n    green = Status.query.filter(Status.status_name == 'Green').first()\n    return self.filter(or_(Version.statuses == amber, Version.statuses == green)).filter(Version.checked == True).order_by(Version.version_number.desc())]\n", "code_toks_joined": "def all_checked ( self ) : <NEWLINE> <INDENT> amber = Status . query . filter ( Status . status_name == <STRING> ) . first ( ) <NEWLINE> green = Status . query . filter ( Status . status_name == <STRING> ) . first ( ) <NEWLINE> return self . filter ( or_ ( Version . statuses == amber , Version . statuses == green ) ) . filter ( Version . checked == True ) . order_by ( Version . version_number . desc ( ) ) ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Amber'", "'Green'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e39683dfb048a7eb2c49d5ceaf07dab7", {"code_string": "def Dot(self, vector):\n    dotProduct = 0.0 f\n    dotProduct += self._x * vector.x\n    dotProduct += self._y * vector.y\n    dotProduct += self._z * vector.z\n    return dotProduct\n", "code_toks_joined": "def Dot ( self , vector ) : <NEWLINE> <INDENT> dotProduct = 0.0 f <NEWLINE> dotProduct += self . _x * vector . x <NEWLINE> dotProduct += self . _y * vector . y <NEWLINE> dotProduct += self . _z * vector . z <NEWLINE> return dotProduct <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["34e11aabfe491f867eb13a496ff3a8ac", {"code_string": "def find_goroutine(goid):\n    vp = gdb.lookup_type('void').pointer()\n    for ptr in linked_list(gdb.parse_and_eval(\"'runtime.allg'\"), 'alllink'):\n        if ptr['status'] == 6:\n            continue\n        if ptr['goid'] == goid:\n            return[ptr['sched'][x].cast(vp) for x in 'pc', 'sp']\n    return None, None\n", "code_toks_joined": "def find_goroutine ( goid ) : <NEWLINE> <INDENT> vp = gdb . lookup_type ( <STRING> ) . pointer ( ) <NEWLINE> for ptr in linked_list ( gdb . parse_and_eval ( <STRING> ) , <STRING> ) : <NEWLINE> <INDENT> if ptr [ <STRING> ] == 6 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ptr [ <STRING> ] == goid : <NEWLINE> <INDENT> return [ ptr [ <STRING> ] [ x ] . cast ( vp ) for x in <STRING> , <STRING> ] <NEWLINE> <DEDENT> <DEDENT> return None , None <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'void'", "\"'runtime.allg'\"", "'alllink'", "'status'", "'goid'", "'sched'", "'pc'", "'sp'"]}, "err_obj": {"msg": "invalid syntax"}}], ["436e23aaff08418995296f1992bde0d7", {"code_string": "def retranslateUi(self, SynoptiquesAtlas):\n    SynoptiquesAtlas.setWindowTitle(QtGui.QApplication.translate(\"SynoptiquesAtlas\", \"Grids for Atlas\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lblComp.setText(QtGui.QApplication.translate(\"SynoptiquesAtlas\", \"Composer :\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lblOverlap.setText(QtGui.QApplication.translate(\"SynoptiquesAtlas\", \"Overlap %:\", None, QtGui.QApplication.UnicodeUTF8))\n    self.lblOutDir.setText(QtGui.QApplication.translate(\"SynoptiquesAtlas\", \"Outfiles\\n\"\n", "code_toks_joined": "def retranslateUi ( self , SynoptiquesAtlas ) : <NEWLINE> <INDENT> SynoptiquesAtlas . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lblComp . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lblOverlap . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lblOutDir . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"SynoptiquesAtlas\"", "\"Grids for Atlas\"", "\"SynoptiquesAtlas\"", "\"Composer :\"", "\"SynoptiquesAtlas\"", "\"Overlap %:\"", "\"SynoptiquesAtlas\"", "\"Outfiles\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["8abdc1a573cbe9a0b12bfdc34ce17cd3", {"code_string": "def get_posts_count(user):\n    return r.table('posts')\n        .filter(lambda post: post.user_id == user.age})\n        .count()\n", "code_toks_joined": "def get_posts_count ( user ) : <NEWLINE> <INDENT> return r . table ( <STRING> ) <NEWLINE> <INDENT> . filter ( lambda post : post . user_id == user . age } ) <NEWLINE> . count ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'posts'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["73556858b615d0e0fda901f3c1cafa31", {"code_string": "def retranslateUi(self, EricdocExecDialog):\n    _translate = QtCore.QCoreApplication.translate\n    EricdocExecDialog.setWindowTitle(_translate(\"EricdocExecDialog\", \"Ericdoc\"))\n    self.messagesGroup.setTitle(_translate(\"EricdocExecDialog\", \"Messages\"))\n    self.contents.setWhatsThis(_translate(\"EricdocExecDialog\", \"<b>Ericdoc Execution</b>\\n\"\n", "code_toks_joined": "def retranslateUi ( self , EricdocExecDialog ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> EricdocExecDialog . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . messagesGroup . setTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . contents . setWhatsThis ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"EricdocExecDialog\"", "\"Ericdoc\"", "\"EricdocExecDialog\"", "\"Messages\"", "\"EricdocExecDialog\"", "\"<b>Ericdoc Execution</b>\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["0e350ade61c98c92e519ea8f41bdbdf0", {"code_string": "def euclidean_distance(v1, v2):\n    \"\"\"calculates distance between two vectors in n-dimensional space of features(vector parameters)\"\"\"\n    sub = []\n    for i, f in enumerate(v1):\n        sub.append(math.pow((v1[i] - v2[i]), 2)\n    dist = math.sqrt(sum(sub))\n    return dist\n", "code_toks_joined": "def euclidean_distance ( v1 , v2 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> sub = [ ] <NEWLINE> for i , f in enumerate ( v1 ) : <NEWLINE> <INDENT> sub . append ( math . pow ( ( v1 [ i ] - v2 [ i ] ) , 2 ) <NEWLINE> <DEDENT> dist = math . sqrt ( sum ( sub ) ) <NEWLINE> return dist <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"calculates distance between two vectors in n-dimensional space of features(vector parameters)\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["7b3d582ef1d3a6b1445fe3ad77876888", {"code_string": "import sys\nimport antlr\nimport SimpleLexer5\nimport LexerTester\nif __name__ == '__main__':\n    try:\n    lexer = SimpleLexer5.Lexer(sys.stdin)\n    parser = LexerTester.Parser(lexer)\n    parser.setFilename('<stdin>')\n    parser.source_text()\n    except antlr.TokenStreamException, e:\n    sys.stderr.write('exception: ' + str(e) + '\\n')\n    except antlr.RecognitionException, e:\n    sys.stderr.write('exception: ' + str(e) + '\\n')\n", "code_toks_joined": "import sys <NEWLINE> import antlr <NEWLINE> import SimpleLexer5 <NEWLINE> import LexerTester <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> lexer = SimpleLexer5 . Lexer ( sys . stdin ) <NEWLINE> parser = LexerTester . Parser ( lexer ) <NEWLINE> parser . setFilename ( <STRING> ) <NEWLINE> parser . source_text ( ) <NEWLINE> except antlr . TokenStreamException , e : <NEWLINE> sys . stderr . write ( <STRING> + str ( e ) + <STRING> ) <NEWLINE> except antlr . RecognitionException , e : <NEWLINE> sys . stderr . write ( <STRING> + str ( e ) + <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'__main__'", "'<stdin>'", "'exception: '", "'\\n'", "'exception: '", "'\\n'"]}, "err_obj": {"msg": "expected an indented block"}}], ["041360e783f77ee289906e9141ada728", {"code_string": "def gen((a, b, c)):\n    if b != 0:\n        pts = [(0, - c / b), (1, (- c - 1) / b)]\n    elif a != 0:\n        pts = [(- c / a, 0), ((- c - 1) / a, 1)]\n    return pts\n", "code_toks_joined": "def gen ( ( a , b , c ) ) : <NEWLINE> <INDENT> if b != 0 : <NEWLINE> <INDENT> pts = [ ( 0 , - c / b ) , ( 1 , ( - c - 1 ) / b ) ] <NEWLINE> <DEDENT> elif a != 0 : <NEWLINE> <INDENT> pts = [ ( - c / a , 0 ) , ( ( - c - 1 ) / a , 1 ) ] <NEWLINE> <DEDENT> return pts <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["a724246e5a6355b21290eb0907ac2765", {"code_string": "def __init__(self, * args, ** kwargs)\n    super(LuckyshopsSider, self).__init__(* args, ** kwargs)\n    settings.set('RETRY_HTTP_CODES', [500, 503, 504, 400, 408, 404])\n    settings.set('RETRY_TIMES', 5)\n    settings.set('REDIRECT_ENABLED', True)\n    settings.set('METAREFRESH_ENABLED', True)\n    settings.set('USER_AGENT', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.90 Safari/537.36')\n", "code_toks_joined": "def __init__ ( self , * args , ** kwargs ) <NEWLINE> <INDENT> super ( LuckyshopsSider , self ) . __init__ ( * args , ** kwargs ) <NEWLINE> settings . set ( <STRING> , [ 500 , 503 , 504 , 400 , 408 , 404 ] ) <NEWLINE> settings . set ( <STRING> , 5 ) <NEWLINE> settings . set ( <STRING> , True ) <NEWLINE> settings . set ( <STRING> , True ) <NEWLINE> settings . set ( <STRING> , <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'RETRY_HTTP_CODES'", "'RETRY_TIMES'", "'REDIRECT_ENABLED'", "'METAREFRESH_ENABLED'", "'USER_AGENT'", "'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.90 Safari/537.36'"]}, "err_obj": {"msg": "invalid syntax"}}], ["043eb4a10becc4a0e28fff1894265470", {"code_string": "def test_autogen_process_directives(self, get_version_branch_path):\n    get_version_branch_path.side_effect = lambda cfg, release, branch: (\n        \"/foo/expand\" if branch == 'expand' else \"/foo/contract\")\n    migration_script = alembic_ops.MigrationScript(\n        'eced083f5df',\n        alembic_ops.UpgradeOps(\n            ops = [\n                alembic_ops.CreateTableOp(\n                    'organization',\n                    [\n                        sa.Column('id', sa.Integer(), primary_key = True),\n                        sa.Column('name', sa.String(50), nullable = False)\n                    ]\n                ),\n                alembic_ops.ModifyTableOps(\n                    'user',\n                    ops = [\n                        alembic_ops.AddColumnOp(\n                            'user',\n                            sa.Column('organization_id', sa.Integer())\n                        ),\n                        alembic_ops.CreateForeignKeyOp(\n                            'org_fk', 'user', 'organization',\n                            ['organization_id'], ['id']\n                        ),\n                        alembic_ops.DropConstraintOp(\n                            'user', 'uq_user_org'\n                        ),\n                        alembic_ops.DropColumnOp(\n                            'user', 'organization_name'\n                        )\n                    ]\n                )\n            ]\n        ),\n        alembic_ops.DowngradeOps(\n            ops = [\n                alembic_ops.AddColumnOp(\n                    'user', sa.Column(\n                        'organization_name', sa.String(50), nullable = True)\n                ),\n                alembic_ops.CreateUniqueConstraintOp(\n                    'uq_user_org', 'user',\n                    ['user_name', 'organization_name']\n                ),\n                alembic_ops.ModifyTableOps(\n                    'user',\n                    ops = [\n                        alembic_ops.DropConstraintOp('org_fk', 'user'),\n                        alembic_ops.DropColumnOp('user', 'organization_id')\n                    ]\n                ),\n                alembic_ops.DropTableOp('organization')\n            ]\n        ),\n        message = 'create the organization table and '\n        'replace user.organization_name'\n    )\n    directives = [migration_script]\n    autogen.process_revision_directives(\n        mock.Mock(), mock.Mock(), directives\n    )\n    expand = directives[0]\n    contract = directives[1]\n    self.assertEqual(\"/foo/expand\", expand.version_path)\n    self.assertEqual(\"/foo/contract\", contract.version_path)\n    self.assertTrue(expand.downgrade_ops.is_empty())\n    self.assertTrue(contract.downgrade_ops.is_empty())\n    self.assertEqual(\n        textwrap.dedent(\"\"\" ### commands auto generated by Alembic - please adjust! ###\"\"\"\n            \"\"\"sa.Column('organization_id', sa.Integer(), nullable=True))\"\"\"\n            \"\"\"'organization', ['organization_id'], ['id'])\"\"\"\n            op.drop_constraint('user', 'uq_user_org', type_ = None)\n            op.drop_column('user', 'organization_name')\n        alembic_ag_api.render_python_code(contract.upgrade_ops)\n    )\n", "code_toks_joined": "def test_autogen_process_directives ( self , get_version_branch_path ) : <NEWLINE> <INDENT> get_version_branch_path . side_effect = lambda cfg , release , branch : ( <NEWLINE> <INDENT> <STRING> if branch == <STRING> else <STRING> ) <NEWLINE> <DEDENT> migration_script = alembic_ops . MigrationScript ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> alembic_ops . UpgradeOps ( <NEWLINE> <INDENT> ops = [ <NEWLINE> <INDENT> alembic_ops . CreateTableOp ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> [ <NEWLINE> <INDENT> sa . Column ( <STRING> , sa . Integer ( ) , primary_key = True ) , <NEWLINE> sa . Column ( <STRING> , sa . String ( 50 ) , nullable = False ) <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT> ) , <NEWLINE> alembic_ops . ModifyTableOps ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> ops = [ <NEWLINE> <INDENT> alembic_ops . AddColumnOp ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> sa . Column ( <STRING> , sa . Integer ( ) ) <NEWLINE> <DEDENT> ) , <NEWLINE> alembic_ops . CreateForeignKeyOp ( <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <NEWLINE> [ <STRING> ] , [ <STRING> ] <NEWLINE> <DEDENT> ) , <NEWLINE> alembic_ops . DropConstraintOp ( <NEWLINE> <INDENT> <STRING> , <STRING> <NEWLINE> <DEDENT> ) , <NEWLINE> alembic_ops . DropColumnOp ( <NEWLINE> <INDENT> <STRING> , <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT> ) , <NEWLINE> alembic_ops . DowngradeOps ( <NEWLINE> <INDENT> ops = [ <NEWLINE> <INDENT> alembic_ops . AddColumnOp ( <NEWLINE> <INDENT> <STRING> , sa . Column ( <NEWLINE> <INDENT> <STRING> , sa . String ( 50 ) , nullable = True ) <NEWLINE> <DEDENT> <DEDENT> ) , <NEWLINE> alembic_ops . CreateUniqueConstraintOp ( <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> [ <STRING> , <STRING> ] <NEWLINE> <DEDENT> ) , <NEWLINE> alembic_ops . ModifyTableOps ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> ops = [ <NEWLINE> <INDENT> alembic_ops . DropConstraintOp ( <STRING> , <STRING> ) , <NEWLINE> alembic_ops . DropColumnOp ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT> ) , <NEWLINE> alembic_ops . DropTableOp ( <STRING> ) <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT> ) , <NEWLINE> message = <STRING> <NEWLINE> <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> directives = [ migration_script ] <NEWLINE> autogen . process_revision_directives ( <NEWLINE> <INDENT> mock . Mock ( ) , mock . Mock ( ) , directives <NEWLINE> <DEDENT> ) <NEWLINE> expand = directives [ 0 ] <NEWLINE> contract = directives [ 1 ] <NEWLINE> self . assertEqual ( <STRING> , expand . version_path ) <NEWLINE> self . assertEqual ( <STRING> , contract . version_path ) <NEWLINE> self . assertTrue ( expand . downgrade_ops . is_empty ( ) ) <NEWLINE> self . assertTrue ( contract . downgrade_ops . is_empty ( ) ) <NEWLINE> self . assertEqual ( <NEWLINE> <INDENT> textwrap . dedent ( <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> op . drop_constraint ( <STRING> , <STRING> , type_ = None ) <NEWLINE> op . drop_column ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> alembic_ag_api . render_python_code ( contract . upgrade_ops ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"/foo/expand\"", "'expand'", "\"/foo/contract\"", "'eced083f5df'", "'organization'", "'id'", "'name'", "'user'", "'user'", "'organization_id'", "'org_fk'", "'user'", "'organization'", "'organization_id'", "'id'", "'user'", "'uq_user_org'", "'user'", "'organization_name'", "'user'", "'organization_name'", "'uq_user_org'", "'user'", "'user_name'", "'organization_name'", "'user'", "'org_fk'", "'user'", "'user'", "'organization_id'", "'organization'", "'create the organization table and '", "'replace user.organization_name'", "\"/foo/expand\"", "\"/foo/contract\"", "\"\"\" ### commands auto generated by Alembic - please adjust! ###\"\"\"", "\"\"\"sa.Column('organization_id', sa.Integer(), nullable=True))\"\"\"", "\"\"\"'organization', ['organization_id'], ['id'])\"\"\"", "'user'", "'uq_user_org'", "'user'", "'organization_name'"]}, "window_span": [438, 488], "err_obj": {"msg": "unbalanced (){}[]"}}], ["976d35337730603103cc13f17609c048", {"code_string": "def _getName(self):\n    name = re.search(self.PATTERN_FILENAME, self.html)\n    if name is None:\n        self.fail(_(\"Plugin broken\")\n    return name.group(1)\n", "code_toks_joined": "def _getName ( self ) : <NEWLINE> <INDENT> name = re . search ( self . PATTERN_FILENAME , self . html ) <NEWLINE> if name is None : <NEWLINE> <INDENT> self . fail ( _ ( <STRING> ) <NEWLINE> <DEDENT> return name . group ( 1 ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Plugin broken\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["1aaf3460e8ee4cf401fbaaafe2913a45", {"code_string": "def retranslateUi(self, Dialog):\n    Dialog.setWindowTitle(QtGui.QApplication.translate(\"Dialog\", \"Version Creator - oyProjectManager\", None, QtGui.QApplication.UnicodeUTF8))\n    self.projects_label.setText(QtGui.QApplication.translate(\"Dialog\", \"Project\", None, QtGui.QApplication.UnicodeUTF8))\n    self.client_label.setText(QtGui.QApplication.translate(\"Dialog\", \"Client:\", None, QtGui.QApplication.UnicodeUTF8))\n    self.client_name_label.setText(QtGui.QApplication.translate(\"Dialog\", \"TextLabel\", None, QtGui.QApplication.UnicodeUTF8))\n    self.user_label.setText(QtGui.QApplication.translate(\"Dialog\", \"User\", None, QtGui.QApplication.UnicodeUTF8))\n    self.asset_info_groupBox.setTitle(QtGui.QApplication.translate(\"Dialog\", \"Asset Information\", None, QtGui.QApplication.UnicodeUTF8))\n    self.asset_name_label.setText(QtGui.QApplication.translate(\"Dialog\", \"Name\", None, QtGui.QApplication.UnicodeUTF8))\n    self.create_asset_pushButton.setText(QtGui.QApplication.translate(\"Dialog\", \"Create New Asset\", None, QtGui.QApplication.UnicodeUTF8))\n    self.assets_tableWidget.setToolTip(QtGui.QApplication.translate(\"Dialog\", \"<html><head/><body><p>Right click to</p><ul style=\\\"margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;\\\"><li style=\\\" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\\\"><span style=\\\" font-weight:600;\\\">Rename Asset</span></li></ul></body></html>\", None, QtGui.QApplication.UnicodeUTF8))\n    item = self.assets_tableWidget.horizontalHeaderItem(0)\n    item.setText(QtGui.QApplication.translate(\"Dialog\", \"Type\", None, QtGui.QApplication.UnicodeUTF8))\n    item = self.assets_tableWidget.horizontalHeaderItem(1)\n    item.setText(QtGui.QApplication.translate(\"Dialog\", \"Name\", None, QtGui.QApplication.UnicodeUTF8))\n    self.tabWidget.setTabText(self.tabWidget.indexOf(self.assets_tab), QtGui.QApplication.translate(\"Dialog\", \"Assets\", None, QtGui.QApplication.UnicodeUTF8))\n    self.sequences_label.setText(QtGui.QApplication.translate(\"Dialog\", \"Sequence\", None, QtGui.QApplication.UnicodeUTF8))\n    self.asset_info_groupBox_2.setTitle(QtGui.QApplication.translate(\"Dialog\", \"Shot Information\", None, QtGui.QApplication.UnicodeUTF8))\n    self.shot_name_label.setText(QtGui.QApplication.translate(\"Dialog\", \"Name\", None, QtGui.QApplication.UnicodeUTF8))\n    self.create_shot_pushButton.setText(QtGui.QApplication.translate(\"Dialog\", \"Create New Shot\", None, QtGui.QApplication.UnicodeUTF8))\n    self.frame_range_label.setText(QtGui.QApplication.translate(\"Dialog\", \"Range\", None, QtGui.QApplication.UnicodeUTF8))\n    self.handles_label.setText(QtGui.QApplication.translate(\"Dialog\", \"Handles\", None, QtGui.QApplication.UnicodeUTF8))\n    self.shot_info_update_pushButton.setText(QtGui.QApplication.translate(\"Dialog\", \"Update\", None, QtGui.QApplication.UnicodeUTF8))\n    self.tabWidget.setTabText(self.tabWidget.indexOf(self.shots_tab), QtGui.QApplication.translate(\"Dialog\", \"Shots\", None, QtGui.QApplication.UnicodeUTF8))\n    self.upload_thumbnail_pushButton.setText(QtGui.QApplication.translate(\"Dialog\", \"Upload Thumbnail...\", None, QtGui.QApplication.UnicodeUTF8))\n    self.new_version_groupBox.setTitle(QtGui.QApplication.translate(\"Dialog\", \"New Version\", None, QtGui.QApplication.UnicodeUTF8))\n    self.takes_label.setText(QtGui.QApplication.translate(\"Dialog\", \"Take\", None, QtGui.QApplication.UnicodeUTF8))\n    self.note_label.setText(QtGui.QApplication.translate(\"Dialog\", \"Note\", None, QtGui.QApplication.UnicodeUTF8))\n    self.version_types_label.setText(QtGui.QApplication.translate(\"Dialog\", \"Type\", None, QtGui.QApplication.UnicodeUTF8))\n    self.add_type_toolButton.setText(QtGui.QApplication.translate(\"Dialog\", \"+\", None, QtGui.QApplication.UnicodeUTF8))\n    self.add_take_toolButton.setText(QtGui.QApplication.translate(\"Dialog\", \"+\", None, QtGui.QApplication.UnicodeUTF8))\n    self.note_textEdit.setHtml(QtGui.QApplication.translate(\"Dialog\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , Dialog ) : <NEWLINE> <INDENT> Dialog . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . projects_label . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . client_label . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . client_name_label . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . user_label . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . asset_info_groupBox . setTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . asset_name_label . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . create_asset_pushButton . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . assets_tableWidget . setToolTip ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> item = self . assets_tableWidget . horizontalHeaderItem ( 0 ) <NEWLINE> item . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> item = self . assets_tableWidget . horizontalHeaderItem ( 1 ) <NEWLINE> item . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . tabWidget . setTabText ( self . tabWidget . indexOf ( self . assets_tab ) , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . sequences_label . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . asset_info_groupBox_2 . setTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . shot_name_label . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . create_shot_pushButton . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . frame_range_label . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . handles_label . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . shot_info_update_pushButton . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . tabWidget . setTabText ( self . tabWidget . indexOf ( self . shots_tab ) , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . upload_thumbnail_pushButton . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . new_version_groupBox . setTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . takes_label . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . note_label . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . version_types_label . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . add_type_toolButton . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . add_take_toolButton . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . note_textEdit . setHtml ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Dialog\"", "\"Version Creator - oyProjectManager\"", "\"Dialog\"", "\"Project\"", "\"Dialog\"", "\"Client:\"", "\"Dialog\"", "\"TextLabel\"", "\"Dialog\"", "\"User\"", "\"Dialog\"", "\"Asset Information\"", "\"Dialog\"", "\"Name\"", "\"Dialog\"", "\"Create New Asset\"", "\"Dialog\"", "\"<html><head/><body><p>Right click to</p><ul style=\\\"margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;\\\"><li style=\\\" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\\\"><span style=\\\" font-weight:600;\\\">Rename Asset</span></li></ul></body></html>\"", "\"Dialog\"", "\"Type\"", "\"Dialog\"", "\"Name\"", "\"Dialog\"", "\"Assets\"", "\"Dialog\"", "\"Sequence\"", "\"Dialog\"", "\"Shot Information\"", "\"Dialog\"", "\"Name\"", "\"Dialog\"", "\"Create New Shot\"", "\"Dialog\"", "\"Range\"", "\"Dialog\"", "\"Handles\"", "\"Dialog\"", "\"Update\"", "\"Dialog\"", "\"Shots\"", "\"Dialog\"", "\"Upload Thumbnail...\"", "\"Dialog\"", "\"New Version\"", "\"Dialog\"", "\"Take\"", "\"Dialog\"", "\"Note\"", "\"Dialog\"", "\"Type\"", "\"Dialog\"", "\"+\"", "\"Dialog\"", "\"+\"", "\"Dialog\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "window_span": [755, 767], "err_obj": {"msg": "unbalanced (){}[]"}}], ["0581798f8f8bae3dc077c8502f93955a", {"code_string": "def hello(request):\n    from django.db import connection, transaction\n    cursor = connection.cursor()\n    query = ''' INSERT INTO test'''\n    queryList = [('a', 'b')]\n    cursor.executemany(query, queryList)\n    transaction.commit()\n        return HttpResponse('Hello World!')\n", "code_toks_joined": "def hello ( request ) : <NEWLINE> <INDENT> from django . db import connection , transaction <NEWLINE> cursor = connection . cursor ( ) <NEWLINE> query = <STRING> <NEWLINE> queryList = [ ( <STRING> , <STRING> ) ] <NEWLINE> cursor . executemany ( query , queryList ) <NEWLINE> transaction . commit ( ) <NEWLINE> <INDENT> return HttpResponse ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["''' INSERT INTO test'''", "'a'", "'b'", "'Hello World!'"]}, "err_obj": {"msg": "unexpected indent"}}], ["ec15531768858506aa33fd32634c4e01", {"code_string": "def product_review_row(product, admin_type):\n    rating_subjects = [subject[1] for subject in Rating.SUBJECT_OPTIONS]\n    return{'product': product,\n        'rating_subjects': rating_subjects\n        'rating_values': range(1, 6),\n        'admin_type': admin_type\n        }\n", "code_toks_joined": "def product_review_row ( product , admin_type ) : <NEWLINE> <INDENT> rating_subjects = [ subject [ 1 ] for subject in Rating . SUBJECT_OPTIONS ] <NEWLINE> return { <STRING> : product , <NEWLINE> <INDENT> <STRING> : rating_subjects <NEWLINE> <STRING> : range ( 1 , 6 ) , <NEWLINE> <STRING> : admin_type <NEWLINE> } <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'product'", "'rating_subjects'", "'rating_values'", "'admin_type'"]}, "err_obj": {"msg": "invalid syntax"}}], ["a36dac0b70d8fc75a905d4b5b7247388", {"code_string": "def setupUi(self, Form):\n    Form.setObjectName(_fromUtf8(\"Form\"))\n    Form.resize(658, 603)\n    sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Preferred)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(Form.sizePolicy().hasHeightForWidth())\n    Form.setSizePolicy(sizePolicy)\n    Form.setWindowTitle(_(\"Form\"))\n    self.verticalLayout = QtGui.QVBoxLayout(Form)\n    self.verticalLayout.setObjectName(_fromUtf8(\"verticalLayout\"))\n    self.includedSections = QtGui.QGroupBox(Form)\n    sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Maximum)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(self.includedSections.sizePolicy().hasHeightForWidth())\n    self.includedSections.setSizePolicy(sizePolicy)\n    self.includedSections.setMinimumSize(QtCore.QSize(0, 0))\n    self.includedSections.setToolTip(_(\"Enabled sections will be included in the generated catalog.\"))\n    self.includedSections.setTitle(_(\"Included sections\"))\n    self.includedSections.setObjectName(_fromUtf8(\"includedSections\"))\n    self.gridLayout_2 = QtGui.QGridLayout(self.includedSections)\n    self.gridLayout_2.setObjectName(_fromUtf8(\"gridLayout_2\"))\n    self.generate_authors = QtGui.QCheckBox(self.includedSections)\n    self.generate_authors.setEnabled(True)\n    self.generate_authors.setText(_(\"&Authors\"))\n    self.generate_authors.setChecked(False)\n    self.generate_authors.setObjectName(_fromUtf8(\"generate_authors\"))\n    self.gridLayout_2.addWidget(self.generate_authors, 0, 0, 1, 1)\n    self.generate_titles = QtGui.QCheckBox(self.includedSections)\n    self.generate_titles.setText(_(\"&Titles\"))\n    self.generate_titles.setObjectName(_fromUtf8(\"generate_titles\"))\n    self.gridLayout_2.addWidget(self.generate_titles, 0, 2, 1, 1)\n    self.generate_series = QtGui.QCheckBox(self.includedSections)\n    self.generate_series.setText(_(\"&Series\"))\n    self.generate_series.setObjectName(_fromUtf8(\"generate_series\"))\n    self.gridLayout_2.addWidget(self.generate_series, 0, 3, 1, 1)\n    self.generate_genres = QtGui.QCheckBox(self.includedSections)\n    self.generate_genres.setText(_(\"&Genres\"))\n    self.generate_genres.setObjectName(_fromUtf8(\"generate_genres\"))\n    self.gridLayout_2.addWidget(self.generate_genres, 4, 0, 1, 1)\n    self.generate_recently_added = QtGui.QCheckBox(self.includedSections)\n    self.generate_recently_added.setText(_(\"&Recently Added\"))\n    self.generate_recently_added.setObjectName(_fromUtf8(\"generate_recently_added\"))\n    self.gridLayout_2.addWidget(self.generate_recently_added, 4, 2, 1, 1)\n    self.generate_descriptions = QtGui.QCheckBox(self.includedSections)\n    self.generate_descriptions.setText(_(\"&Descriptions\"))\n    self.generate_descriptions.setObjectName(_fromUtf8(\"generate_descriptions\"))\n    self.gridLayout_2.addWidget(self.generate_descriptions, 4, 3, 1, 1)\n    self.verticalLayout.addWidget(self.includedSections)\n    self.prefix_rules_gb = QtGui.QGroupBox(Form)\n    sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Maximum)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(self.prefix_rules_gb.sizePolicy().hasHeightForWidth())\n    self.prefix_rules_gb.setSizePolicy(sizePolicy)\n    self.prefix_rules_gb.setToolTip(_(\"The first matching prefix rule applies a prefix to book listings in the generated catalog.\"))\n    self.prefix_rules_gb.setTitle(_(\"Prefixes\"))\n    self.prefix_rules_gb.setObjectName(_fromUtf8(\"prefix_rules_gb\"))\n    self.horizontalLayout_8 = QtGui.QHBoxLayout(self.prefix_rules_gb)\n    self.horizontalLayout_8.setObjectName(_fromUtf8(\"horizontalLayout_8\"))\n    self.horizontalLayout_6 = QtGui.QHBoxLayout()\n    self.horizontalLayout_6.setObjectName(_fromUtf8(\"horizontalLayout_6\"))\n    self.horizontalLayout_8.addLayout(self.horizontalLayout_6)\n    self.verticalLayout.addWidget(self.prefix_rules_gb)\n    self.exclusion_rules_gb = QtGui.QGroupBox(Form)\n    sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Maximum)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(self.exclusion_rules_gb.sizePolicy().hasHeightForWidth())\n    self.exclusion_rules_gb.setSizePolicy(sizePolicy)\n    self.exclusion_rules_gb.setMinimumSize(QtCore.QSize(0, 0))\n    self.exclusion_rules_gb.setToolTip(_(\"Books matching any of the exclusion rules will be excluded from the generated catalog. \"))\n    self.exclusion_rules_gb.setTitle(_(\"Excluded books\"))\n    self.exclusion_rules_gb.setObjectName(_fromUtf8(\"exclusion_rules_gb\"))\n    self.horizontalLayout_4 = QtGui.QHBoxLayout(self.exclusion_rules_gb)\n    self.horizontalLayout_4.setObjectName(_fromUtf8(\"horizontalLayout_4\"))\n    self.horizontalLayout_3 = QtGui.QHBoxLayout()\n    self.horizontalLayout_3.setObjectName(_fromUtf8(\"horizontalLayout_3\"))\n    self.horizontalLayout_4.addLayout(self.horizontalLayout_3)\n    self.verticalLayout.addWidget(self.exclusion_rules_gb)\n    self.excludedGenres = QtGui.QGroupBox(Form)\n    sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Maximum)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(self.excludedGenres.sizePolicy().hasHeightForWidth())\n    self.excludedGenres.setSizePolicy(sizePolicy)\n    self.excludedGenres.setMinimumSize(QtCore.QSize(0, 0))\n    self.excludedGenres.setToolTip(_(\"A regular expression describing genres to be excluded from the generated catalog. Genres are derived from the tags applied to your books.\\n\"\n", "code_toks_joined": "def setupUi ( self , Form ) : <NEWLINE> <INDENT> Form . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> Form . resize ( 658 , 603 ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Preferred , QtGui . QSizePolicy . Preferred ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( Form . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> Form . setSizePolicy ( sizePolicy ) <NEWLINE> Form . setWindowTitle ( _ ( <STRING> ) ) <NEWLINE> self . verticalLayout = QtGui . QVBoxLayout ( Form ) <NEWLINE> self . verticalLayout . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . includedSections = QtGui . QGroupBox ( Form ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Preferred , QtGui . QSizePolicy . Maximum ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( self . includedSections . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> self . includedSections . setSizePolicy ( sizePolicy ) <NEWLINE> self . includedSections . setMinimumSize ( QtCore . QSize ( 0 , 0 ) ) <NEWLINE> self . includedSections . setToolTip ( _ ( <STRING> ) ) <NEWLINE> self . includedSections . setTitle ( _ ( <STRING> ) ) <NEWLINE> self . includedSections . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_2 = QtGui . QGridLayout ( self . includedSections ) <NEWLINE> self . gridLayout_2 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . generate_authors = QtGui . QCheckBox ( self . includedSections ) <NEWLINE> self . generate_authors . setEnabled ( True ) <NEWLINE> self . generate_authors . setText ( _ ( <STRING> ) ) <NEWLINE> self . generate_authors . setChecked ( False ) <NEWLINE> self . generate_authors . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_2 . addWidget ( self . generate_authors , 0 , 0 , 1 , 1 ) <NEWLINE> self . generate_titles = QtGui . QCheckBox ( self . includedSections ) <NEWLINE> self . generate_titles . setText ( _ ( <STRING> ) ) <NEWLINE> self . generate_titles . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_2 . addWidget ( self . generate_titles , 0 , 2 , 1 , 1 ) <NEWLINE> self . generate_series = QtGui . QCheckBox ( self . includedSections ) <NEWLINE> self . generate_series . setText ( _ ( <STRING> ) ) <NEWLINE> self . generate_series . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_2 . addWidget ( self . generate_series , 0 , 3 , 1 , 1 ) <NEWLINE> self . generate_genres = QtGui . QCheckBox ( self . includedSections ) <NEWLINE> self . generate_genres . setText ( _ ( <STRING> ) ) <NEWLINE> self . generate_genres . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_2 . addWidget ( self . generate_genres , 4 , 0 , 1 , 1 ) <NEWLINE> self . generate_recently_added = QtGui . QCheckBox ( self . includedSections ) <NEWLINE> self . generate_recently_added . setText ( _ ( <STRING> ) ) <NEWLINE> self . generate_recently_added . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_2 . addWidget ( self . generate_recently_added , 4 , 2 , 1 , 1 ) <NEWLINE> self . generate_descriptions = QtGui . QCheckBox ( self . includedSections ) <NEWLINE> self . generate_descriptions . setText ( _ ( <STRING> ) ) <NEWLINE> self . generate_descriptions . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . gridLayout_2 . addWidget ( self . generate_descriptions , 4 , 3 , 1 , 1 ) <NEWLINE> self . verticalLayout . addWidget ( self . includedSections ) <NEWLINE> self . prefix_rules_gb = QtGui . QGroupBox ( Form ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Preferred , QtGui . QSizePolicy . Maximum ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( self . prefix_rules_gb . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> self . prefix_rules_gb . setSizePolicy ( sizePolicy ) <NEWLINE> self . prefix_rules_gb . setToolTip ( _ ( <STRING> ) ) <NEWLINE> self . prefix_rules_gb . setTitle ( _ ( <STRING> ) ) <NEWLINE> self . prefix_rules_gb . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . horizontalLayout_8 = QtGui . QHBoxLayout ( self . prefix_rules_gb ) <NEWLINE> self . horizontalLayout_8 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . horizontalLayout_6 = QtGui . QHBoxLayout ( ) <NEWLINE> self . horizontalLayout_6 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . horizontalLayout_8 . addLayout ( self . horizontalLayout_6 ) <NEWLINE> self . verticalLayout . addWidget ( self . prefix_rules_gb ) <NEWLINE> self . exclusion_rules_gb = QtGui . QGroupBox ( Form ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Preferred , QtGui . QSizePolicy . Maximum ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( self . exclusion_rules_gb . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> self . exclusion_rules_gb . setSizePolicy ( sizePolicy ) <NEWLINE> self . exclusion_rules_gb . setMinimumSize ( QtCore . QSize ( 0 , 0 ) ) <NEWLINE> self . exclusion_rules_gb . setToolTip ( _ ( <STRING> ) ) <NEWLINE> self . exclusion_rules_gb . setTitle ( _ ( <STRING> ) ) <NEWLINE> self . exclusion_rules_gb . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . horizontalLayout_4 = QtGui . QHBoxLayout ( self . exclusion_rules_gb ) <NEWLINE> self . horizontalLayout_4 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . horizontalLayout_3 = QtGui . QHBoxLayout ( ) <NEWLINE> self . horizontalLayout_3 . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . horizontalLayout_4 . addLayout ( self . horizontalLayout_3 ) <NEWLINE> self . verticalLayout . addWidget ( self . exclusion_rules_gb ) <NEWLINE> self . excludedGenres = QtGui . QGroupBox ( Form ) <NEWLINE> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Preferred , QtGui . QSizePolicy . Maximum ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( self . excludedGenres . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> self . excludedGenres . setSizePolicy ( sizePolicy ) <NEWLINE> self . excludedGenres . setMinimumSize ( QtCore . QSize ( 0 , 0 ) ) <NEWLINE> self . excludedGenres . setToolTip ( _ ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Form\"", "\"Form\"", "\"verticalLayout\"", "\"Enabled sections will be included in the generated catalog.\"", "\"Included sections\"", "\"includedSections\"", "\"gridLayout_2\"", "\"&Authors\"", "\"generate_authors\"", "\"&Titles\"", "\"generate_titles\"", "\"&Series\"", "\"generate_series\"", "\"&Genres\"", "\"generate_genres\"", "\"&Recently Added\"", "\"generate_recently_added\"", "\"&Descriptions\"", "\"generate_descriptions\"", "\"The first matching prefix rule applies a prefix to book listings in the generated catalog.\"", "\"Prefixes\"", "\"prefix_rules_gb\"", "\"horizontalLayout_8\"", "\"horizontalLayout_6\"", "\"Books matching any of the exclusion rules will be excluded from the generated catalog. \"", "\"Excluded books\"", "\"exclusion_rules_gb\"", "\"horizontalLayout_4\"", "\"horizontalLayout_3\"", "\"A regular expression describing genres to be excluded from the generated catalog. Genres are derived from the tags applied to your books.\\n\""]}, "window_span": [1086, 1092], "err_obj": {"msg": "unbalanced (){}[]"}}], ["c330602709edd0c045d2a17219749814", {"code_string": "def test_int_input(self):\n    self.assertEqual(io.input_value('int topic', default_value = 1, prompt_fn = lambda(m): '123'), 123)\n    self.assertRaises(ValueError, io.input_value, 'int topic', default_value = 1, prompt_fn = lambda(m): 'aaa')\n", "code_toks_joined": "def test_int_input ( self ) : <NEWLINE> <INDENT> self . assertEqual ( io . input_value ( <STRING> , default_value = 1 , prompt_fn = lambda ( m ) : <STRING> ) , 123 ) <NEWLINE> self . assertRaises ( ValueError , io . input_value , <STRING> , default_value = 1 , prompt_fn = lambda ( m ) : <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'int topic'", "'123'", "'int topic'", "'aaa'"]}, "err_obj": {"msg": "invalid syntax"}}], ["b90e8c1cbc0022c90235ef12bc823256", {"code_string": "def rename(self, fromname, toname):\n    '''Rename a file.'''\n    resp = self.sendcmd('RNFR ' + fromname)\n    if resp[0] != '3':\n        raise error_reply, resp\n    return self.voidcmd('RNTO ' + toname)\n", "code_toks_joined": "def rename ( self , fromname , toname ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> resp = self . sendcmd ( <STRING> + fromname ) <NEWLINE> if resp [ 0 ] != <STRING> : <NEWLINE> <INDENT> raise error_reply , resp <NEWLINE> <DEDENT> return self . voidcmd ( <STRING> + toname ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''Rename a file.'''", "'RNFR '", "'3'", "'RNTO '"]}, "err_obj": {"msg": "invalid syntax"}}], ["28a42714ff0de990605604b45f0a76bd", {"code_string": "def test__publish_event_async(self):\n    body = {\"action\": \"update\", \"Prev\": \"Prev1\", \"Curr\": \"Curr1\"}\n    event_type = \"ObjectSettingChanged\"\n    with patch('org.o3project.odenos.remoteobject.transport.message_dispatcher.'\n        'MessageDispatcher.publish_event_async'\n        ) as m_publish_event_async:\n        self.result = self.target._publish_event_async(event_type,\n            body)\n            m_publish_event_async.assert_called_one_with(self.ObkectId,\n            event_type,\n            body)\n            self.assertNotEqual(self.result, None)\n", "code_toks_joined": "def test__publish_event_async ( self ) : <NEWLINE> <INDENT> body = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> event_type = <STRING> <NEWLINE> with patch ( <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> ) as m_publish_event_async : <NEWLINE> self . result = self . target . _publish_event_async ( event_type , <NEWLINE> <INDENT> body ) <NEWLINE> m_publish_event_async . assert_called_one_with ( self . ObkectId , <NEWLINE> event_type , <NEWLINE> body ) <NEWLINE> self . assertNotEqual ( self . result , None ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"action\"", "\"update\"", "\"Prev\"", "\"Prev1\"", "\"Curr\"", "\"Curr1\"", "\"ObjectSettingChanged\"", "'org.o3project.odenos.remoteobject.transport.message_dispatcher.'", "'MessageDispatcher.publish_event_async'"]}, "err_obj": {"msg": "unexpected indent"}}], ["ac280e2545efc35dd61fdaa14e1855d2", {"code_string": "def initGPIO(self):\n    \"\"\"Initialise the GPIO pins - note we use GPIO pin numbers, not physical\"\"\"\n    global haveGPIO\n    pinNo = self.cfg.getConfigInt(\"gpiono\")\n    self.pinNo = pinNo\n    if(self.debug): print \"gpioNo = %d\" % pinNo\n    if(haveGPIO):\n        GPIO.setmode(GPIO.BCM)\n        GPIO.setup(pinNo, GPIO.IN, pull_up_down = GPIO.PUD_UP)\n    else:\n        print(\"no GPIO - simulating camera move\")\n        self.moveCamera(1)\n    self.lastButtonVal = 1\n    self.lastButtonTime = time.time()\n", "code_toks_joined": "def initGPIO ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> global haveGPIO <NEWLINE> pinNo = self . cfg . getConfigInt ( <STRING> ) <NEWLINE> self . pinNo = pinNo <NEWLINE> if ( self . debug ) : print <STRING> % pinNo <NEWLINE> if ( haveGPIO ) : <NEWLINE> <INDENT> GPIO . setmode ( GPIO . BCM ) <NEWLINE> GPIO . setup ( pinNo , GPIO . IN , pull_up_down = GPIO . PUD_UP ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> self . moveCamera ( 1 ) <NEWLINE> <DEDENT> self . lastButtonVal = 1 <NEWLINE> self . lastButtonTime = time . time ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Initialise the GPIO pins - note we use GPIO pin numbers, not physical\"\"\"", "\"gpiono\"", "\"gpioNo = %d\"", "\"no GPIO - simulating camera move\""]}, "err_obj": {"msg": "invalid syntax"}}], ["126f9e801ee3ffffcdb60bee75e38073", {"code_string": "def test_abort(self):\n    print('test_abort')\n    def __time_cb():\n        raise NotImplementedError, 'abort failed!'\n    event.timeout(5, __time_cb)\n    event.timeout(1, event.abort)\n    event.dispatch()\n", "code_toks_joined": "def test_abort ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> def __time_cb ( ) : <NEWLINE> <INDENT> raise NotImplementedError , <STRING> <NEWLINE> <DEDENT> event . timeout ( 5 , __time_cb ) <NEWLINE> event . timeout ( 1 , event . abort ) <NEWLINE> event . dispatch ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'test_abort'", "'abort failed!'"]}, "err_obj": {"msg": "invalid syntax"}}], ["f2b3f3a5f897f9e70913ccf7bb433ea5", {"code_string": "def ensure_env_vars():\n    for var in['DX_FS_ROOT',\n        'DX_TEST_CODE_PATH',\n        'DX_TEST_JOB_HOMEDIRS']:\n        if var not in environ:\n        sys.exit('Error: Cannot run an entry point locally if the environment variable ' + var + ' has not been set')\n", "code_toks_joined": "def ensure_env_vars ( ) : <NEWLINE> <INDENT> for var in [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ] : <NEWLINE> if var not in environ : <NEWLINE> sys . exit ( <STRING> + var + <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'DX_FS_ROOT'", "'DX_TEST_CODE_PATH'", "'DX_TEST_JOB_HOMEDIRS'", "'Error: Cannot run an entry point locally if the environment variable '", "' has not been set'"]}, "err_obj": {"msg": "expected an indented block"}}], ["3db6fe5fc7de6ab8a2dcadf233edd57c", {"code_string": "def do_transmit(self line):\n    \"\"\"This function handles manager access for the pypy sandbox environment.\"\"\"\n    if self.api_access is not None:\n        self.api_access.send(self.api_access.create(line))\n", "code_toks_joined": "def do_transmit ( self line ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . api_access is not None : <NEWLINE> <INDENT> self . api_access . send ( self . api_access . create ( line ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"This function handles manager access for the pypy sandbox environment.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["e2689f7c26058de140b008a011df529a", {"code_string": "def aiff(self):\n    if self._nframeswritten:\n        raise Error, 'cannot change parameters after starting to write'\n    self._aifc = 0\n", "code_toks_joined": "def aiff ( self ) : <NEWLINE> <INDENT> if self . _nframeswritten : <NEWLINE> <INDENT> raise Error , <STRING> <NEWLINE> <DEDENT> self . _aifc = 0 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'cannot change parameters after starting to write'"]}, "err_obj": {"msg": "invalid syntax"}}], ["bd595d0e7e7f6c3674e2178d65ae8e8c", {"code_string": "def _get_and_create_snapshots_dir(self):\n    \"\"\"Create (if necessary) and return the snapshots directory\"\"\"\n    snapshots_dir = os.path.join(\n        self._config.file_server_root\n        FILE_SERVER_SNAPSHOTS_FOLDER\n    )\n    if not os.path.exists(snapshots_dir):\n        os.makedirs(snapshots_dir)\n    return snapshots_dir\n", "code_toks_joined": "def _get_and_create_snapshots_dir ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> snapshots_dir = os . path . join ( <NEWLINE> <INDENT> self . _config . file_server_root <NEWLINE> FILE_SERVER_SNAPSHOTS_FOLDER <NEWLINE> <DEDENT> ) <NEWLINE> if not os . path . exists ( snapshots_dir ) : <NEWLINE> <INDENT> os . makedirs ( snapshots_dir ) <NEWLINE> <DEDENT> return snapshots_dir <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Create (if necessary) and return the snapshots directory\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["4c75a16f205e6ab8b4387bac5bc8552f", {"code_string": "def printResult(classification):\n    if classification == 0:\n    print('0')\n    else:\n    print('1')\n", "code_toks_joined": "def printResult ( classification ) : <NEWLINE> <INDENT> if classification == 0 : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'0'", "'1'"]}, "err_obj": {"msg": "expected an indented block"}}], ["a172cdbe99cbb5688d04d187f541de62", {"code_string": "def serviceInterruptRain(self, channel):\n    currentTime = (micros() - SDL_Pi_Weather_80422._lastRainTime);\n    SDL_Pi_Weather_80422._lastRainTime = micros();\n    if(currentTime > 500):\n        SDL_Pi_Weather_80422._currentRainCount = SDL_Pi_Weather_80422._currentRainCount + 1\n        if(currentTime < SDL_Pi_Weather_80422._currentRainMin):\n        SDL_Pi_Weather_80422._currentRainMin = currentTime;\n", "code_toks_joined": "def serviceInterruptRain ( self , channel ) : <NEWLINE> <INDENT> currentTime = ( micros ( ) - SDL_Pi_Weather_80422 . _lastRainTime ) ; <NEWLINE> SDL_Pi_Weather_80422 . _lastRainTime = micros ( ) ; <NEWLINE> if ( currentTime > 500 ) : <NEWLINE> <INDENT> SDL_Pi_Weather_80422 . _currentRainCount = SDL_Pi_Weather_80422 . _currentRainCount + 1 <NEWLINE> if ( currentTime < SDL_Pi_Weather_80422 . _currentRainMin ) : <NEWLINE> SDL_Pi_Weather_80422 . _currentRainMin = currentTime ; <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["b092555acf297e04399955a567bf51bb", {"code_string": "class string_loop_item(DVBobject):\n    def pack(self):\n    assert len(self.ISO639_language_code) == 3\n    data_bytes = string.join(\n    map(lambda x: x.pack(),\n    self.segment_loop),\n    \"\")\n    self.number_segments = len(self.segment_loop)\n    fmt = \"!%dsB%ds\" %(len(self.ISO639_language_code), len(data_bytes))\n    return pack(fmt,\n    self.ISO639_language_code,\n    self.number_segments,\n    data_bytes\n    )\n", "code_toks_joined": "class string_loop_item ( DVBobject ) : <NEWLINE> <INDENT> def pack ( self ) : <NEWLINE> assert len ( self . ISO639_language_code ) == 3 <NEWLINE> data_bytes = string . join ( <NEWLINE> map ( lambda x : x . pack ( ) , <NEWLINE> self . segment_loop ) , <NEWLINE> <STRING> ) <NEWLINE> self . number_segments = len ( self . segment_loop ) <NEWLINE> fmt = <STRING> % ( len ( self . ISO639_language_code ) , len ( data_bytes ) ) <NEWLINE> return pack ( fmt , <NEWLINE> self . ISO639_language_code , <NEWLINE> self . number_segments , <NEWLINE> data_bytes <NEWLINE> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"", "\"!%dsB%ds\""]}, "err_obj": {"msg": "expected an indented block"}}], ["fde8b8cf8c4be8e414ed6732506d4a9b", {"code_string": "def __set_year_and_month(self, (y, m)):\n    \"\"\"Expects a month from 1 - 12 and a year more recent than 1900\"\"\"\n    if self.__current_month != m or self.__current_year != y:\n        self.__current_month = m if 1 <= m <= 12 else datetime.now().month\n        self.__current_year = y if 1900 <= y else datetime.now().year\n        self.__reload_events()\n", "code_toks_joined": "def __set_year_and_month ( self , ( y , m ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . __current_month != m or self . __current_year != y : <NEWLINE> <INDENT> self . __current_month = m if 1 <= m <= 12 else datetime . now ( ) . month <NEWLINE> self . __current_year = y if 1900 <= y else datetime . now ( ) . year <NEWLINE> self . __reload_events ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Expects a month from 1 - 12 and a year more recent than 1900\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["32fd682f13787279216d4b393c95dd1f", {"code_string": "def render_helprequest_as_html(fooditem):\n    return render_template(\n        'fooditem.html',\n        transactions = reversed(list(enumerate(TRANSACTION)))\n", "code_toks_joined": "def render_helprequest_as_html ( fooditem ) : <NEWLINE> <INDENT> return render_template ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> transactions = reversed ( list ( enumerate ( TRANSACTION ) ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'fooditem.html'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["0d32cc512e1165f7240b538140b1e225", {"code_string": "index = 20\nbets = 25\nnames = (\"Plain\", \"Cheval H\", \"Cheval V\", \"Trans\", \"Trans S\", \"Carre\", \"Colonne\", \"Simple\")\nfor bet in range(bets):\n    col = 40\n    print(\"\"\"when %d =>\"\"\" %(index, bet, bet, col))\n    index += 1\n    col += 2\n    for m in range(5, - 1, - 1):\n        print(\"\"\"when %d =>\"\"\" %(index, bet, bet, col, bet, m))\n        index += 1\n        col += 1\n        if m == 5:\n            col += 1\n        if m == 2:\n            print(\"\"\"when %d =>\"\"\" %(index, bet, bet, col))\n            index += 1\n            col += 1\n    col += 1\n    for n in range(8):\n        print(\"\"\"when %d =>\"\"\" %(index, bet, bet, col, bet))\n        for kind in range(1, 9):\n            if n < len(names[kind - 1]) and names[kind - 1][n] != ' ':\n                print(\"\"\"           when %d => fb_a_dat_in <= x\"%02x\"\n        print(\"\"\" when others = > fb_a_dat_in <= x \"20\"\n        index += 1\n        col += 1\n", "code_toks_joined": "index = 20 <NEWLINE> bets = 25 <NEWLINE> names = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> for bet in range ( bets ) : <NEWLINE> <INDENT> col = 40 <NEWLINE> print ( <STRING> % ( index , bet , bet , col ) ) <NEWLINE> index += 1 <NEWLINE> col += 2 <NEWLINE> for m in range ( 5 , - 1 , - 1 ) : <NEWLINE> <INDENT> print ( <STRING> % ( index , bet , bet , col , bet , m ) ) <NEWLINE> index += 1 <NEWLINE> col += 1 <NEWLINE> if m == 5 : <NEWLINE> <INDENT> col += 1 <NEWLINE> <DEDENT> if m == 2 : <NEWLINE> <INDENT> print ( <STRING> % ( index , bet , bet , col ) ) <NEWLINE> index += 1 <NEWLINE> col += 1 <NEWLINE> <DEDENT> <DEDENT> col += 1 <NEWLINE> for n in range ( 8 ) : <NEWLINE> <INDENT> print ( <STRING> % ( index , bet , bet , col , bet ) ) <NEWLINE> for kind in range ( 1 , 9 ) : <NEWLINE> <INDENT> if n < len ( names [ kind - 1 ] ) and names [ kind - 1 ] [ n ] != <STRING> : <NEWLINE> <INDENT> print ( <STRING> when others = > fb_a_dat_in <= x <STRING> <NEWLINE> <DEDENT> <DEDENT> index += 1 <NEWLINE> col += 1 <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Plain\"", "\"Cheval H\"", "\"Cheval V\"", "\"Trans\"", "\"Trans S\"", "\"Carre\"", "\"Colonne\"", "\"Simple\"", "\"\"\"when %d =>\"\"\"", "\"\"\"when %d =>\"\"\"", "\"\"\"when %d =>\"\"\"", "\"\"\"when %d =>\"\"\"", "' '", "\"\"\"           when %d => fb_a_dat_in <= x\"%02x\"\n        print(\"\"\"", "\"20\""]}, "window_span": [223, 246], "err_obj": {"msg": "unbalanced (){}[]"}}], ["277387ee8213c0433ed654bed812fea9", {"code_string": "def hover(self, (width, height), (posx, posy)):\n    posx1, posy1 = pygame.mouse.get_pos()\n    if(posx1 >= posx - width and posx1 <=(posx + width)) and(posy1 >= posy - height and posy1 <=(posy + height)):\n        return True\n    return False\n", "code_toks_joined": "def hover ( self , ( width , height ) , ( posx , posy ) ) : <NEWLINE> <INDENT> posx1 , posy1 = pygame . mouse . get_pos ( ) <NEWLINE> if ( posx1 >= posx - width and posx1 <= ( posx + width ) ) and ( posy1 >= posy - height and posy1 <= ( posy + height ) ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["6dd7866a57626a9d7b96e6ad9cc3863e", {"code_string": "def run(self, args, opts):\n    spider_loader = self.crawler_process.spider_loader\n    for spidername in args or spider_loader.list():\n        print(\"*********start spidername************\" + spidername)\n        self.crawler_process.crawl(spidername, ** opts.spargs)\n            self.crawler_process.start()\n", "code_toks_joined": "def run ( self , args , opts ) : <NEWLINE> <INDENT> spider_loader = self . crawler_process . spider_loader <NEWLINE> for spidername in args or spider_loader . list ( ) : <NEWLINE> <INDENT> print ( <STRING> + spidername ) <NEWLINE> self . crawler_process . crawl ( spidername , ** opts . spargs ) <NEWLINE> <INDENT> self . crawler_process . start ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"*********start spidername************\""]}, "err_obj": {"msg": "unexpected indent"}}], ["d97e3cda2368fe1fdb66d090c0f25d6d", {"code_string": "\"\"\"Finishes the process and cancels all other active tasks\"\"\"\nfrom..activation import EndActivation\nfrom.import base\nclass End(base.TaskDescriptionMixin,\n    base.DetailsViewMixin,\n    base.UndoViewMixin,\n    base.CancelViewMixin,\n    base.PerformViewMixin,\n    base.Event):\n    \"\"\"Ends process event.\"\"\"\n    task_type = 'END'\n    activation_cls = EndActivation\n    def __init__(self, ** kwargs):\n    super(End, self).__init__(** kwargs)\n    def _outgoing(self):\n    return iter([])\n", "code_toks_joined": "<STRING> <NEWLINE> from . . activation import EndActivation <NEWLINE> from . import base <NEWLINE> class End ( base . TaskDescriptionMixin , <NEWLINE> <INDENT> base . DetailsViewMixin , <NEWLINE> base . UndoViewMixin , <NEWLINE> base . CancelViewMixin , <NEWLINE> base . PerformViewMixin , <NEWLINE> base . Event ) : <NEWLINE> <STRING> <NEWLINE> task_type = <STRING> <NEWLINE> activation_cls = EndActivation <NEWLINE> def __init__ ( self , ** kwargs ) : <NEWLINE> super ( End , self ) . __init__ ( ** kwargs ) <NEWLINE> def _outgoing ( self ) : <NEWLINE> return iter ( [ ] ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Finishes the process and cancels all other active tasks\"\"\"", "\"\"\"Ends process event.\"\"\"", "'END'"]}, "err_obj": {"msg": "expected an indented block"}}], ["d6e1a5b16eb440b2e3a0b99a29fd102b", {"code_string": "def check_pattern((s, p, o)):\n    if s and not(isinstance(s, URIRef) or isinstance(s, BNode)):\n        raise SubjectTypeError(s)\n    if p and not isinstance(p, URIRef):\n        raise PredicateTypeError(p)\n    if o and not(isinstance(o, URIRef) or isinstance(o, Literal) or isinstance(o, BNode)):\n        raise ObjectTypeError(o)\n", "code_toks_joined": "def check_pattern ( ( s , p , o ) ) : <NEWLINE> <INDENT> if s and not ( isinstance ( s , URIRef ) or isinstance ( s , BNode ) ) : <NEWLINE> <INDENT> raise SubjectTypeError ( s ) <NEWLINE> <DEDENT> if p and not isinstance ( p , URIRef ) : <NEWLINE> <INDENT> raise PredicateTypeError ( p ) <NEWLINE> <DEDENT> if o and not ( isinstance ( o , URIRef ) or isinstance ( o , Literal ) or isinstance ( o , BNode ) ) : <NEWLINE> <INDENT> raise ObjectTypeError ( o ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["165e48cf03553178f78901078071a7af", {"code_string": "def set_topleft(self, (x, y)):\n    self.r.x = int(x)\n    self.r.y = int(y)\n", "code_toks_joined": "def set_topleft ( self , ( x , y ) ) : <NEWLINE> <INDENT> self . r . x = int ( x ) <NEWLINE> self . r . y = int ( y ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["16ef386c064d04ffdd7b779e4b472d5c", {"code_string": "def readme(self):\n    'returns(filename, unicode text)if a readme file is found'\n    for x in self.blob_ids:\n        if README_RE.match(x.name):\n            name = x.name\n            blob = self[name]\n            return(x.name, h.really_unicode(blob.text)))\n    return None, None\n", "code_toks_joined": "def readme ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for x in self . blob_ids : <NEWLINE> <INDENT> if README_RE . match ( x . name ) : <NEWLINE> <INDENT> name = x . name <NEWLINE> blob = self [ name ] <NEWLINE> return ( x . name , h . really_unicode ( blob . text ) ) ) <NEWLINE> <DEDENT> <DEDENT> return None , None <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'returns(filename, unicode text)if a readme file is found'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["f68532776cc29aae2a392b3fa890fbe6", {"code_string": "def retranslateUi(self, Page01):\n    Page01.setWindowTitle(QtGui.QApplication.translate(\"Page01\", \"Form\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_2.setText(QtGui.QApplication.translate(\"Page01\", \"A| ETAT CIVIL\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_2.setProperty(\"class\", QtGui.QApplication.translate(\"Page01\", \"titreA\", None, QtGui.QApplication.UnicodeUTF8))\n    self.nomM.setText(QtGui.QApplication.translate(\"Page01\", \"Mari\u00e9s\", None, QtGui.QApplication.UnicodeUTF8))\n    self.nomM.setProperty(\"class\", QtGui.QApplication.translate(\"Page01\", \"texte01\", None, QtGui.QApplication.UnicodeUTF8))\n    self.codeM.setText(QtGui.QApplication.translate(\"Page01\", \"M\", None, QtGui.QApplication.UnicodeUTF8))\n    self.codeM.setProperty(\"class\", QtGui.QApplication.translate(\"Page01\", \"code\", None, QtGui.QApplication.UnicodeUTF8))\n    self.nomO.setText(QtGui.QApplication.translate(\"Page01\", \"Pacs\u00e9s\", None, QtGui.QApplication.UnicodeUTF8))\n    self.nomO.setProperty(\"class\", QtGui.QApplication.translate(\"Page01\", \"texte01\", None, QtGui.QApplication.UnicodeUTF8))\n    self.codeO.setText(QtGui.QApplication.translate(\"Page01\", \"O\", None, QtGui.QApplication.UnicodeUTF8))\n    self.codeO.setProperty(\"class\", QtGui.QApplication.translate(\"Page01\", \"code\", None, QtGui.QApplication.UnicodeUTF8))\n    self.nomC.setText(QtGui.QApplication.translate(\"Page01\", \"C\u00e9libataire\", None, QtGui.QApplication.UnicodeUTF8))\n    self.nomC.setProperty(\"class\", QtGui.QApplication.translate(\"Page01\", \"texte01\", None, QtGui.QApplication.UnicodeUTF8))\n    self.codeC.setText(QtGui.QApplication.translate(\"Page01\", \"C\", None, QtGui.QApplication.UnicodeUTF8))\n    self.codeC.setProperty(\"class\", QtGui.QApplication.translate(\"Page01\", \"code\", None, QtGui.QApplication.UnicodeUTF8))\n    self.nomD.setText(QtGui.QApplication.translate(\"Page01\", \"Divorc\u00e9\", None, QtGui.QApplication.UnicodeUTF8))\n    self.nomD.setProperty(\"class\", QtGui.QApplication.translate(\"Page01\", \"texte01\", None, QtGui.QApplication.UnicodeUTF8))\n    self.codeD.setText(QtGui.QApplication.translate(\"Page01\", \"D\", None, QtGui.QApplication.UnicodeUTF8))\n    self.codeD.setProperty(\"class\", QtGui.QApplication.translate(\"Page01\", \"code\", None, QtGui.QApplication.UnicodeUTF8))\n    self.nomV.setText(QtGui.QApplication.translate(\"Page01\", \"Veuf\", None, QtGui.QApplication.UnicodeUTF8))\n    self.nomV.setProperty(\"class\", QtGui.QApplication.translate(\"Page01\", \"texte01\", None, QtGui.QApplication.UnicodeUTF8))\n    self.codeV.setText(QtGui.QApplication.translate(\"Page01\", \"V\", None, QtGui.QApplication.UnicodeUTF8))\n    self.codeV.setProperty(\"class\", QtGui.QApplication.translate(\"Page01\", \"code\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_3.setText(QtGui.QApplication.translate(\"Page01\", \"C| PERSONNES A CHARGE en 2010\", None, QtGui.QApplication.UnicodeUTF8))\n    self.label_3.setProperty(\"class\", QtGui.QApplication.translate(\"Page01\", \"titreA\", None, QtGui.QApplication.UnicodeUTF8))\n    self.nomM_2.setText(QtGui.QApplication.translate(\"Page01\", \"Nombre d\\'enfants non mari\u00e9s de moins de 18 ans au 1er janvier 2010, ou n\u00e9s en 2010, ou handicap\u00e9s quel que soit leur \u00e2ge\", None, QtGui.QApplication.UnicodeUTF8))\n    self.nomM_2.setProperty(\"class\", QtGui.QApplication.translate(\"Page01\", \"texte01\", None, QtGui.QApplication.UnicodeUTF8))\n    self.codeM_2.setText(QtGui.QApplication.translate(\"Page01\", \"F\", None, QtGui.QApplication.UnicodeUTF8))\n    self.codeM_2.setProperty(\"class\", QtGui.QApplication.translate(\"Page01\", \"code\", None, QtGui.QApplication.UnicodeUTF8))\n    self.nomO_2.setText(QtGui.QApplication.translate(\"Page01\", \"Dont enfants titulaires de la carte d\\'invalidit\u00e9 \", None, QtGui.QApplication.UnicodeUTF8))\n    self.nomO_2.setProperty(\"class\", QtGui.QApplication.translate(\"Page01\", \"texte01\", None, QtGui.QApplication.UnicodeUTF8))\n    self.codeO_2.setText(QtGui.QApplication.translate(\"Page01\", \"G\", None, QtGui.QApplication.UnicodeUTF8))\n    self.codeO_2.setProperty(\"class\", QtGui.QApplication.translate(\"Page01\", \"code\", None, QtGui.QApplication.UnicodeUTF8))\n    self.nomC_2.setText(QtGui.QApplication.translate(\"Page01\", \"Nombre d\\'enfants non mari\u00e9s en r\u00e9sidence altern\u00e9e de moins de 18 ans au 1er janvier 2010 ou n\u00e9s en 2010\\n\"\n", "code_toks_joined": "def retranslateUi ( self , Page01 ) : <NEWLINE> <INDENT> Page01 . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_2 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_2 . setProperty ( <STRING> , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . nomM . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . nomM . setProperty ( <STRING> , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . codeM . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . codeM . setProperty ( <STRING> , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . nomO . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . nomO . setProperty ( <STRING> , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . codeO . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . codeO . setProperty ( <STRING> , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . nomC . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . nomC . setProperty ( <STRING> , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . codeC . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . codeC . setProperty ( <STRING> , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . nomD . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . nomD . setProperty ( <STRING> , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . codeD . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . codeD . setProperty ( <STRING> , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . nomV . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . nomV . setProperty ( <STRING> , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . codeV . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . codeV . setProperty ( <STRING> , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_3 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_3 . setProperty ( <STRING> , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . nomM_2 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . nomM_2 . setProperty ( <STRING> , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . codeM_2 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . codeM_2 . setProperty ( <STRING> , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . nomO_2 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . nomO_2 . setProperty ( <STRING> , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . codeO_2 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . codeO_2 . setProperty ( <STRING> , QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . nomC_2 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Page01\"", "\"Form\"", "\"Page01\"", "\"A| ETAT CIVIL\"", "\"class\"", "\"Page01\"", "\"titreA\"", "\"Page01\"", "\"Mari\u00e9s\"", "\"class\"", "\"Page01\"", "\"texte01\"", "\"Page01\"", "\"M\"", "\"class\"", "\"Page01\"", "\"code\"", "\"Page01\"", "\"Pacs\u00e9s\"", "\"class\"", "\"Page01\"", "\"texte01\"", "\"Page01\"", "\"O\"", "\"class\"", "\"Page01\"", "\"code\"", "\"Page01\"", "\"C\u00e9libataire\"", "\"class\"", "\"Page01\"", "\"texte01\"", "\"Page01\"", "\"C\"", "\"class\"", "\"Page01\"", "\"code\"", "\"Page01\"", "\"Divorc\u00e9\"", "\"class\"", "\"Page01\"", "\"texte01\"", "\"Page01\"", "\"D\"", "\"class\"", "\"Page01\"", "\"code\"", "\"Page01\"", "\"Veuf\"", "\"class\"", "\"Page01\"", "\"texte01\"", "\"Page01\"", "\"V\"", "\"class\"", "\"Page01\"", "\"code\"", "\"Page01\"", "\"C| PERSONNES A CHARGE en 2010\"", "\"class\"", "\"Page01\"", "\"titreA\"", "\"Page01\"", "\"Nombre d\\'enfants non mari\u00e9s de moins de 18 ans au 1er janvier 2010, ou n\u00e9s en 2010, ou handicap\u00e9s quel que soit leur \u00e2ge\"", "\"class\"", "\"Page01\"", "\"texte01\"", "\"Page01\"", "\"F\"", "\"class\"", "\"Page01\"", "\"code\"", "\"Page01\"", "\"Dont enfants titulaires de la carte d\\'invalidit\u00e9 \"", "\"class\"", "\"Page01\"", "\"texte01\"", "\"Page01\"", "\"G\"", "\"class\"", "\"Page01\"", "\"code\"", "\"Page01\"", "\"Nombre d\\'enfants non mari\u00e9s en r\u00e9sidence altern\u00e9e de moins de 18 ans au 1er janvier 2010 ou n\u00e9s en 2010\\n\""]}, "window_span": [903, 915], "err_obj": {"msg": "unbalanced (){}[]"}}], ["9fa1776fca8096b91120b84f2ad2a63b", {"code_string": "def putline(self, line):\n    line = line + CRLF\n    if self.debugging > 1:\n        print '*put*', self.sanitize(line)\n    self.sock.sendall(line)\n", "code_toks_joined": "def putline ( self , line ) : <NEWLINE> <INDENT> line = line + CRLF <NEWLINE> if self . debugging > 1 : <NEWLINE> <INDENT> print <STRING> , self . sanitize ( line ) <NEWLINE> <DEDENT> self . sock . sendall ( line ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'*put*'"]}, "err_obj": {"msg": "invalid syntax"}}], ["ceee071c9af701ce076d3b3d7706a2ff", {"code_string": "def get_version(self):\n    '''--version Displays gpstart utility version'''\n        return(self.run_gpstart_cmd(version = 'y'))\n", "code_toks_joined": "def get_version ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> return ( self . run_gpstart_cmd ( version = <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''--version Displays gpstart utility version'''", "'y'"]}, "err_obj": {"msg": "unexpected indent"}}], ["3d9cfd538785bae231fe8c447cc3981f", {"code_string": "def has_perm(cls, user, permission):\n    \"\"\"Convenience method for testing if a user has our custom permissions.\"\"\"\n    return user.has_perm(cls.perm_name(permission)\n", "code_toks_joined": "def has_perm ( cls , user , permission ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return user . has_perm ( cls . perm_name ( permission ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Convenience method for testing if a user has our custom permissions.\"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["597bd0d99582650f2774573d68935596", {"code_string": "def pv(v, digits = 5, left_digits = None):\n    if isinstance(v, scipy.matrix):\n        v = scipy.array(v)[0]\n    (c, ) = v.shape\n    print(\"[ \",\n    for j in xrange(c):\n        if left_digits != None:\n            d = left_digits[0, j]\n        else:\n            d = 0\n        fmt = (\"%\" +\n            str(d + digits + 1) +\n            \".\" + str(digits) + \"f \")\n        print(fmt % v[j]),\n    print(\"]\")\n", "code_toks_joined": "def pv ( v , digits = 5 , left_digits = None ) : <NEWLINE> <INDENT> if isinstance ( v , scipy . matrix ) : <NEWLINE> <INDENT> v = scipy . array ( v ) [ 0 ] <NEWLINE> <DEDENT> ( c , ) = v . shape <NEWLINE> print ( <STRING> , <NEWLINE> for j in xrange ( c ) : <NEWLINE> <INDENT> if left_digits != None : <NEWLINE> <INDENT> d = left_digits [ 0 , j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = 0 <NEWLINE> <DEDENT> fmt = ( <STRING> + <NEWLINE> <INDENT> str ( d + digits + 1 ) + <NEWLINE> <STRING> + str ( digits ) + <STRING> ) <NEWLINE> <DEDENT> print ( fmt % v [ j ] ) , <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"[ \"", "\"%\"", "\".\"", "\"f \"", "\"]\""]}, "window_span": [51, 137], "err_obj": {"msg": "unbalanced (){}[]"}}], ["5de5079e8ee3b44e261ceaeab2826d46", {"code_string": "def load_printer(self, name):\n    \"\"\"Load the printer configuration under this `name`.\"\"\"\n    serial = cbpos.config['printing', 'p.' + name]\n    if serial is None:\n        raise InvalidPrinterName, 'Does not exist'\n    printer = Printer(name, serial)\n    return printer\n", "code_toks_joined": "def load_printer ( self , name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> serial = cbpos . config [ <STRING> , <STRING> + name ] <NEWLINE> if serial is None : <NEWLINE> <INDENT> raise InvalidPrinterName , <STRING> <NEWLINE> <DEDENT> printer = Printer ( name , serial ) <NEWLINE> return printer <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Load the printer configuration under this `name`.\"\"\"", "'printing'", "'p.'", "'Does not exist'"]}, "err_obj": {"msg": "invalid syntax"}}], ["9895886d9fc1804b7beb5c00324ea59d", {"code_string": "def keys_to_output(keys):\n    output = [0, 0, 0]\n    if 'A' in keys:\n        output[0] = 1\n    elif 'D' in keys:\n        output[2] = 1\n    else\n        output[1] = 1\n    return output\n", "code_toks_joined": "def keys_to_output ( keys ) : <NEWLINE> <INDENT> output = [ 0 , 0 , 0 ] <NEWLINE> if <STRING> in keys : <NEWLINE> <INDENT> output [ 0 ] = 1 <NEWLINE> <DEDENT> elif <STRING> in keys : <NEWLINE> <INDENT> output [ 2 ] = 1 <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> output [ 1 ] = 1 <NEWLINE> <DEDENT> return output <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'A'", "'D'"]}, "err_obj": {"msg": "invalid syntax"}}], ["51b415ed83c1fd3d56e7549870afdab7", {"code_string": "def get(self):\n    \"\"\" \u67e5\u8be2\u8282\u70b9 \"\"\"\n    return g.node.GET(node = request.args.get(\"node\", None)\n", "code_toks_joined": "def get ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return g . node . GET ( node = request . args . get ( <STRING> , None ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" \u67e5\u8be2\u8282\u70b9 \"\"\"", "\"node\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["53e7a0eaa5f6679411b681753243fd7e", {"code_string": "def index():\n    contexto = {'save_path' router.to_path(salvar)}\n    return TemplateResponse(contexto);\n", "code_toks_joined": "def index ( ) : <NEWLINE> <INDENT> contexto = { <STRING> router . to_path ( salvar ) } <NEWLINE> return TemplateResponse ( contexto ) ; <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'save_path'"]}, "err_obj": {"msg": "invalid syntax"}}], ["5e8727052df19f9c434e4873402d9dc9", {"code_string": "def test_authenticated(self):\n    with mock.patch.object(self.dbapi, 'get_node_by_uuid',\n        autospec = True) as mock_get_node:\n        mock_get_node.return_value = self.fake_db_node\n        response = self.get_json(self.node_path,\n            headers = {'X-Auth-Token': utils.ADMIN_TOKEN})\n            self.assertEqual(self.fake_db_node['uuid'], response['uuid'])\n            mock_get_node.assert_called_once_with(self.fake_db_node['uuid'])\n", "code_toks_joined": "def test_authenticated ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( self . dbapi , <STRING> , <NEWLINE> <INDENT> autospec = True ) as mock_get_node : <NEWLINE> mock_get_node . return_value = self . fake_db_node <NEWLINE> response = self . get_json ( self . node_path , <NEWLINE> <INDENT> headers = { <STRING> : utils . ADMIN_TOKEN } ) <NEWLINE> self . assertEqual ( self . fake_db_node [ <STRING> ] , response [ <STRING> ] ) <NEWLINE> mock_get_node . assert_called_once_with ( self . fake_db_node [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'get_node_by_uuid'", "'X-Auth-Token'", "'uuid'", "'uuid'", "'uuid'"]}, "err_obj": {"msg": "unexpected indent"}}], ["c00f1e5b8f72e8e8c4dcf9b0abe0acde", {"code_string": "def test_missing_trailing_slash(self):\n    try:\n        self._execute('trace', 'missing_trailing_slash.isolate', [], True)\n        self.fail()\n    except subprocess.CalledProcessError, e:\n        out = e.output\n    self._expect_no_tree()\n    self._expect_no_result()\n    expected = 'Input directory %s must have a trailing slash\\n' % os.path.join(\n        ROOT_DIR, 'data', 'isolate', 'files1')\n    self.assertEquals(expected, out)\n", "code_toks_joined": "def test_missing_trailing_slash ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . _execute ( <STRING> , <STRING> , [ ] , True ) <NEWLINE> self . fail ( ) <NEWLINE> <DEDENT> except subprocess . CalledProcessError , e : <NEWLINE> <INDENT> out = e . output <NEWLINE> <DEDENT> self . _expect_no_tree ( ) <NEWLINE> self . _expect_no_result ( ) <NEWLINE> expected = <STRING> % os . path . join ( <NEWLINE> <INDENT> ROOT_DIR , <STRING> , <STRING> , <STRING> ) <NEWLINE> <DEDENT> self . assertEquals ( expected , out ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'trace'", "'missing_trailing_slash.isolate'", "'Input directory %s must have a trailing slash\\n'", "'data'", "'isolate'", "'files1'"]}, "err_obj": {"msg": "invalid syntax"}}], ["64b1d4bb89ea33e73434219b0ebab7dc", {"code_string": "def addperm(self, sender, res = None):\n    \"Add a permanent sender.\"\n    lsender = sender.lower()\n    if self.has_key(lsender):\n        ts, res = self.cache[lsender]\n        if not ts: return\n    self.cache[lsender] = (None, res)\n    if not res:\n        print('a'), sender)\n", "code_toks_joined": "def addperm ( self , sender , res = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> lsender = sender . lower ( ) <NEWLINE> if self . has_key ( lsender ) : <NEWLINE> <INDENT> ts , res = self . cache [ lsender ] <NEWLINE> if not ts : return <NEWLINE> <DEDENT> self . cache [ lsender ] = ( None , res ) <NEWLINE> if not res : <NEWLINE> <INDENT> print ( <STRING> ) , sender ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Add a permanent sender.\"", "'a'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["4a6387ef226431f2cfa55938eee491a0", {"code_string": "class InstallAndUpdateDataDirectory(DistUtilsExtra.auto.install_auto):\n    def run(self):\n        values = {'__ojo_data_directory__': \"'%s'\" %(self.prefix + '/share/ojo/')\n            '__version__': \"'%s'\" %(self.distribution.get_version())}\n        previous_values = update_config(values)\n        DistUtilsExtra.auto.install_auto.run(self)\n        update_config(previous_values)\n", "code_toks_joined": "class InstallAndUpdateDataDirectory ( DistUtilsExtra . auto . install_auto ) : <NEWLINE> <INDENT> def run ( self ) : <NEWLINE> <INDENT> values = { <STRING> : <STRING> % ( self . prefix + <STRING> ) <NEWLINE> <INDENT> <STRING> : <STRING> % ( self . distribution . get_version ( ) ) } <NEWLINE> <DEDENT> previous_values = update_config ( values ) <NEWLINE> DistUtilsExtra . auto . install_auto . run ( self ) <NEWLINE> update_config ( previous_values ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'__ojo_data_directory__'", "\"'%s'\"", "'/share/ojo/'", "'__version__'", "\"'%s'\""]}, "err_obj": {"msg": "invalid syntax"}}], ["de08ea406e137360d2925043054f320e", {"code_string": "def get_project_data(self):\n    if self._project_data is None:\n        if not os.path.exists(self.path()):\n            logging.info(\"Couldn't find the project at this path: \")\n            logging.info(self.path()\n            return None\n        project_file = open(self.path(), 'r')\n        self._project_data = project_file.read()\n    return self._project_data\n", "code_toks_joined": "def get_project_data ( self ) : <NEWLINE> <INDENT> if self . _project_data is None : <NEWLINE> <INDENT> if not os . path . exists ( self . path ( ) ) : <NEWLINE> <INDENT> logging . info ( <STRING> ) <NEWLINE> logging . info ( self . path ( ) <NEWLINE> return None <NEWLINE> <DEDENT> project_file = open ( self . path ( ) , <STRING> ) <NEWLINE> self . _project_data = project_file . read ( ) <NEWLINE> <DEDENT> return self . _project_data <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Couldn't find the project at this path: \"", "'r'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["14fa5f9943d4363dbc6d92da8d147c1d", {"code_string": "def run(self):\n    try:\n        if((timeit.default_timer() - self.starttime) <= 10 and\n", "code_toks_joined": "def run ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if ( ( timeit . default_timer ( ) - self . starttime ) <= 10 and <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["d639ff09a15fb2fcf597ed79be044a48", {"code_string": "def save_maxvel_pref(self):\n    self.prefs.putpref('maxvel', self.mv_val, int)\n    def postgui(self):\n    postgui_halfile = self.ini.find(\"HAL\", \"POSTGUI_HALFILE\")\n    return postgui_halfile, sys.argv[2]\n", "code_toks_joined": "def save_maxvel_pref ( self ) : <NEWLINE> <INDENT> self . prefs . putpref ( <STRING> , self . mv_val , int ) <NEWLINE> def postgui ( self ) : <NEWLINE> postgui_halfile = self . ini . find ( <STRING> , <STRING> ) <NEWLINE> return postgui_halfile , sys . argv [ 2 ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'maxvel'", "\"HAL\"", "\"POSTGUI_HALFILE\""]}, "err_obj": {"msg": "expected an indented block"}}], ["f8ac21b86a91d5c44bdeb49c773e942d", {"code_string": "def retranslateUi(self, wavepeak1dDialog):\n    wavepeak1dDialog.setWindowTitle(QtGui.QApplication.translate(\"wavepeak1dDialog\", \"select values for 1d peak search\", None, QtGui.QApplication.UnicodeUTF8))\n    self.typeComboBox.setToolTip(QtGui.QApplication.translate(\"wavepeak1dDialog\", \"The dataset in which peaks will be identified.\", None, QtGui.QApplication.UnicodeUTF8))\n    self.typeLabel.setText(QtGui.QApplication.translate(\"wavepeak1dDialog\", \"select\", None, QtGui.QApplication.UnicodeUTF8))\n    self.maxqs_spinBox.setToolTip(QtGui.QApplication.translate(\"wavepeak1dDialog\", \"If the global maximum of the wavelet transform intensity in a ridge occurs at a wavelet scale above this value, the ridge will not be counted as a peak. Ancestor ridges are not considered in the global maximum.\", None, QtGui.QApplication.UnicodeUTF8))\n    self.wavenoisecutoff_spinBox.setToolTip(QtGui.QApplication.translate(\"wavepeak1dDialog\", \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\"\n", "code_toks_joined": "def retranslateUi ( self , wavepeak1dDialog ) : <NEWLINE> <INDENT> wavepeak1dDialog . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . typeComboBox . setToolTip ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . typeLabel . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . maxqs_spinBox . setToolTip ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . wavenoisecutoff_spinBox . setToolTip ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"wavepeak1dDialog\"", "\"select values for 1d peak search\"", "\"wavepeak1dDialog\"", "\"The dataset in which peaks will be identified.\"", "\"wavepeak1dDialog\"", "\"select\"", "\"wavepeak1dDialog\"", "\"If the global maximum of the wavelet transform intensity in a ridge occurs at a wavelet scale above this value, the ridge will not be counted as a peak. Ancestor ridges are not considered in the global maximum.\"", "\"wavepeak1dDialog\"", "\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\">\\n\""]}, "window_span": [117, 129], "err_obj": {"msg": "unbalanced (){}[]"}}], ["e369784bf88679e42ce60f6022875dfe", {"code_string": "def unproject(self, (x, y)):\n    \"\"\"Returns the coordinates from position in meters\"\"\"\n    lng = x / EARTH_RADIUS * RAD_TO_DEG\n    lat = 2 * atan(exp(y / EARTH_RADIUS)) - pi / 2 * RAD_TO_DEG\n    return(lng, lat)\n", "code_toks_joined": "def unproject ( self , ( x , y ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> lng = x / EARTH_RADIUS * RAD_TO_DEG <NEWLINE> lat = 2 * atan ( exp ( y / EARTH_RADIUS ) ) - pi / 2 * RAD_TO_DEG <NEWLINE> return ( lng , lat ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns the coordinates from position in meters\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["c625df47849dfbe54e89d3a6b29ca767", {"code_string": "def allowed(self, request, instance = None):\n    return((instance.status in ACTIVE_STATES\n        or instance.status == 'SHUTDOWN')\n", "code_toks_joined": "def allowed ( self , request , instance = None ) : <NEWLINE> <INDENT> return ( ( instance . status in ACTIVE_STATES <NEWLINE> <INDENT> or instance . status == <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'SHUTDOWN'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["243e352e51f90b4e22fef50cd52d1022", {"code_string": "def handle_token(tokenType, token, (startRow, startCol), (endRow, endCol), line):\n    global useCounts\n    if tokenize.tok_name[tokenType] == 'STRING':\n        for obj in useCounts:\n            useCounts[obj] += str(token).count(\"'%s'\" % obj)\n            useCounts[obj] += str(token).count('\"%s\"' % obj)\n", "code_toks_joined": "def handle_token ( tokenType , token , ( startRow , startCol ) , ( endRow , endCol ) , line ) : <NEWLINE> <INDENT> global useCounts <NEWLINE> if tokenize . tok_name [ tokenType ] == <STRING> : <NEWLINE> <INDENT> for obj in useCounts : <NEWLINE> <INDENT> useCounts [ obj ] += str ( token ) . count ( <STRING> % obj ) <NEWLINE> useCounts [ obj ] += str ( token ) . count ( <STRING> % obj ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'STRING'", "\"'%s'\"", "'\"%s\"'"]}, "err_obj": {"msg": "invalid syntax"}}], ["2b5c3684e33528e294cdd487489bf040", {"code_string": "def setCommand(self, cmd)\n    if self.showDebug:\n        self.setInfo('<tt>' + cmd + '<tt>')\n", "code_toks_joined": "def setCommand ( self , cmd ) <NEWLINE> <INDENT> if self . showDebug : <NEWLINE> <INDENT> self . setInfo ( <STRING> + cmd + <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'<tt>'", "'<tt>'"]}, "err_obj": {"msg": "invalid syntax"}}], ["97fa15b7bd99de8ae3420dcb6dd5014d", {"code_string": "class ServerGroupSoftAffinityWeigher(_SoftAffinityWeigherBase):\n    policy_name = 'soft-affinity'\n    warning_sent = False\n    def weight_multiplier(self):\n        if(CONF.soft_affinity_weight_multiplier < 0 and\n            not self.warning_sent):\n            LOG.warn(_LW('For the soft_affinity_weight_multiplier only a '\n                'positive value is meaningful as a negative value '\n                'would mean that the affinity weigher would '\n                'prefer non-collocating placement.'))\n                self.warning_sent = True\n        return CONF.soft_affinity_weight_multiplier\n", "code_toks_joined": "class ServerGroupSoftAffinityWeigher ( _SoftAffinityWeigherBase ) : <NEWLINE> <INDENT> policy_name = <STRING> <NEWLINE> warning_sent = False <NEWLINE> def weight_multiplier ( self ) : <NEWLINE> <INDENT> if ( CONF . soft_affinity_weight_multiplier < 0 and <NEWLINE> <INDENT> not self . warning_sent ) : <NEWLINE> LOG . warn ( _LW ( <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) ) <NEWLINE> self . warning_sent = True <NEWLINE> <DEDENT> <DEDENT> return CONF . soft_affinity_weight_multiplier <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'soft-affinity'", "'For the soft_affinity_weight_multiplier only a '", "'positive value is meaningful as a negative value '", "'would mean that the affinity weigher would '", "'prefer non-collocating placement.'"]}, "err_obj": {"msg": "unexpected indent"}}], ["5cb9a660952250c7b7fc986f597d7625", {"code_string": "def sign_request(self, web_resource):\n    ''' sign request to generate request_url with sharedaccesssignature info for web_resource.'''\n    if self.permission_set:\n        for shared_access_signature in self.permission_set:\n            if self._permission_matches_request(shared_access_signature, web_resource,\n                web_resource.properties[SIGNED_RESOURCE_TYPE],\n                web_resource.properties[SHARED_ACCESS_PERMISSION]):\n                if web_resource.request_url.find('?') == - 1:\n                web_resource.request_url += '?'\n                else:\n                web_resource.request_url += '&'\n                web_resource.request_url += self._convert_query_string(shared_access_signature.query_string)\n                break\n    return web_resource\n", "code_toks_joined": "def sign_request ( self , web_resource ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . permission_set : <NEWLINE> <INDENT> for shared_access_signature in self . permission_set : <NEWLINE> <INDENT> if self . _permission_matches_request ( shared_access_signature , web_resource , <NEWLINE> <INDENT> web_resource . properties [ SIGNED_RESOURCE_TYPE ] , <NEWLINE> web_resource . properties [ SHARED_ACCESS_PERMISSION ] ) : <NEWLINE> if web_resource . request_url . find ( <STRING> ) == - 1 : <NEWLINE> web_resource . request_url += <STRING> <NEWLINE> else : <NEWLINE> web_resource . request_url += <STRING> <NEWLINE> web_resource . request_url += self . _convert_query_string ( shared_access_signature . query_string ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return web_resource <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["''' sign request to generate request_url with sharedaccesssignature info for web_resource.'''", "'?'", "'?'", "'&'"]}, "err_obj": {"msg": "expected an indented block"}}], ["7cac2bc9f917406f22b548c43c843335", {"code_string": "def diff(self, other):\n    for t in Event.terms:\n        if not self.has_key(t) or not other.has_key(t):\n            continue\n        if not self.compare_data(self[t], other[t]):\n        log.warning(\"expected %s=%s, got %s\" %(t, self[t], other[t]))\n", "code_toks_joined": "def diff ( self , other ) : <NEWLINE> <INDENT> for t in Event . terms : <NEWLINE> <INDENT> if not self . has_key ( t ) or not other . has_key ( t ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if not self . compare_data ( self [ t ] , other [ t ] ) : <NEWLINE> log . warning ( <STRING> % ( t , self [ t ] , other [ t ] ) ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"expected %s=%s, got %s\""]}, "err_obj": {"msg": "expected an indented block"}}], ["93cf7e432c7482537ef89c54dfdb799c", {"code_string": "def _handleAuthenticate(self):\n    \"\"\" Handle click on form.button.Save \"\"\"\n    client_id = self.flattr.customer_key\n    if client_id:\n        callback_uri = '%s/collective_flattr' % self.context.absolute_url()\n        self.request.response.redirect('%s?scope=thing&response_type=code'\n            '&redirect_uri=%s&client_id=%s' %(\n                self.flattr.authorize_url,\n                callback_uri,\n                client_id)\n        return True\n    IStatusMessage(self.request).add(_(u'Unable to create authorize '\n        'url.consumer and consumer_secret not configured: ('),\n        type = 'error')\n    return False\n", "code_toks_joined": "def _handleAuthenticate ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> client_id = self . flattr . customer_key <NEWLINE> if client_id : <NEWLINE> <INDENT> callback_uri = <STRING> % self . context . absolute_url ( ) <NEWLINE> self . request . response . redirect ( <STRING> <NEWLINE> <INDENT> <STRING> % ( <NEWLINE> <INDENT> self . flattr . authorize_url , <NEWLINE> callback_uri , <NEWLINE> client_id ) <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> IStatusMessage ( self . request ) . add ( _ ( <STRING> <NEWLINE> <INDENT> <STRING> ) , <NEWLINE> type = <STRING> ) <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Handle click on form.button.Save \"\"\"", "'%s/collective_flattr'", "'%s?scope=thing&response_type=code'", "'&redirect_uri=%s&client_id=%s'", "u'Unable to create authorize '", "'url.consumer and consumer_secret not configured: ('", "'error'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["05b635fb1fa2310a89fe0bd076729465", {"code_string": "def test_016_disconnect_output(self):\n    hblock = gr.hier_block2(\"test_block\",\n        gr.io_signature(1, 1, gr.sizeof_int),\n        gr.io_signature(1, 1, gr.sizeof_int))\n    nop1 = blocks.nop(gr.sizeof_int)\n    hblock.connect(nop1, hblock)\n        hblock.disconnect(nop1, hblock)\n", "code_toks_joined": "def test_016_disconnect_output ( self ) : <NEWLINE> <INDENT> hblock = gr . hier_block2 ( <STRING> , <NEWLINE> <INDENT> gr . io_signature ( 1 , 1 , gr . sizeof_int ) , <NEWLINE> gr . io_signature ( 1 , 1 , gr . sizeof_int ) ) <NEWLINE> <DEDENT> nop1 = blocks . nop ( gr . sizeof_int ) <NEWLINE> hblock . connect ( nop1 , hblock ) <NEWLINE> <INDENT> hblock . disconnect ( nop1 , hblock ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"test_block\""]}, "err_obj": {"msg": "unexpected indent"}}], ["5587c4a4020aa61c75a621e4748ab695", {"code_string": "def get_emails(self):\n    \"\"\"Returns an iterator of matched emails found in string text.\"\"\"\n    regex = re.compile((\"([a-zA-Z0-9!#$%&'*+\\/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+\\/=?^_`\"\n", "code_toks_joined": "def get_emails ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> regex = re . compile ( ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns an iterator of matched emails found in string text.\"\"\"", "\"([a-zA-Z0-9!#$%&'*+\\/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+\\/=?^_`\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["ab3f26d4825ce92085217ee3dd8698b9", {"code_string": "def retranslateUi(self, Form):\n    Form.setWindowTitle(_(\"Form\"))\n    self.mm_label.setText(_(\"Me&tadata management:\"))\n    self.opt_manage_device_metadata.setItemText(0, _(\"Manual management\"))\n    self.opt_manage_device_metadata.setItemText(1, _(\"Only on send\"))\n    self.opt_manage_device_metadata.setItemText(2, _(\"Automatic management\"))\n    self.label_41.setText(_(\"<li><b>Manual management</b>: Calibre updates the metadata and adds collections only when a book is sent. With this option, calibre will never remove a collection.</li>\\n\"\n", "code_toks_joined": "def retranslateUi ( self , Form ) : <NEWLINE> <INDENT> Form . setWindowTitle ( _ ( <STRING> ) ) <NEWLINE> self . mm_label . setText ( _ ( <STRING> ) ) <NEWLINE> self . opt_manage_device_metadata . setItemText ( 0 , _ ( <STRING> ) ) <NEWLINE> self . opt_manage_device_metadata . setItemText ( 1 , _ ( <STRING> ) ) <NEWLINE> self . opt_manage_device_metadata . setItemText ( 2 , _ ( <STRING> ) ) <NEWLINE> self . label_41 . setText ( _ ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"Form\"", "\"Me&tadata management:\"", "\"Manual management\"", "\"Only on send\"", "\"Automatic management\"", "\"<li><b>Manual management</b>: Calibre updates the metadata and adds collections only when a book is sent. With this option, calibre will never remove a collection.</li>\\n\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["b5411e3b0122925d969a7266f3811748", {"code_string": "def register_template_library(package_name):\n    \"\"\"Registers a template extension module to make it usable in templates.\"\"\"\n    if not django.template.libraries.get(package_name, None):\n    django.template.add_to_builtins(package_name)\n", "code_toks_joined": "def register_template_library ( package_name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not django . template . libraries . get ( package_name , None ) : <NEWLINE> django . template . add_to_builtins ( package_name ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Registers a template extension module to make it usable in templates.\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["9da54b676f87f79162d6d57363b29c8e", {"code_string": "def disconnect(self):\n    self.remove_listeners()\n    self._last_track = None\n    self._clip_record_slot = None\n        self._midi_clip_length_slot = None\n    self._parent = None\n    if IS_LIVE_9:\n        ControlSurfaceComponent.disconnect(self)\n", "code_toks_joined": "def disconnect ( self ) : <NEWLINE> <INDENT> self . remove_listeners ( ) <NEWLINE> self . _last_track = None <NEWLINE> self . _clip_record_slot = None <NEWLINE> <INDENT> self . _midi_clip_length_slot = None <NEWLINE> <DEDENT> self . _parent = None <NEWLINE> if IS_LIVE_9 : <NEWLINE> <INDENT> ControlSurfaceComponent . disconnect ( self ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unexpected indent"}}], ["a7825c34691b7166f372cf9da73905ad", {"code_string": "class MaxPool1D(_Pooling):\n    \"\"\"Max pooling operation for one dimensional data.\"\"\"\n    def __init__(self, pool_size = 2, strides = None, padding = 0, layout = 'NCW',\n        ceil_mode = False, ** kwargs):\n        assert layout == 'NCW', \"Only supports NCW layout for now\"\n        if isinstance(pool_size, numeric_types):\n        pool_size = (pool_size, )\n        assert len(pool_size) == 1, \"pool_size must be a number or a list of 1 ints\"\n        super(MaxPool1D, self).__init__(\n        pool_size, strides, padding, ceil_mode, False, 'max', ** kwargs)\n", "code_toks_joined": "class MaxPool1D ( _Pooling ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , pool_size = 2 , strides = None , padding = 0 , layout = <STRING> , <NEWLINE> <INDENT> ceil_mode = False , ** kwargs ) : <NEWLINE> assert layout == <STRING> , <STRING> <NEWLINE> if isinstance ( pool_size , numeric_types ) : <NEWLINE> pool_size = ( pool_size , ) <NEWLINE> assert len ( pool_size ) == 1 , <STRING> <NEWLINE> super ( MaxPool1D , self ) . __init__ ( <NEWLINE> pool_size , strides , padding , ceil_mode , False , <STRING> , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Max pooling operation for one dimensional data.\"\"\"", "'NCW'", "'NCW'", "\"Only supports NCW layout for now\"", "\"pool_size must be a number or a list of 1 ints\"", "'max'"]}, "err_obj": {"msg": "expected an indented block"}}], ["72cccaae777b8e9b9fe248a9a05c727e", {"code_string": "def _get_instance_health(self, lb):\n    \"\"\"Check instance health, should return status object or None under\"\"\"\n    try:\n        status = lb.get_instance_health([self.instance_id])[0]\n    except boto.exception.BotoServerError, e:\n        if e.error_code == 'InvalidInstance':\n            return None\n        else:\n            raise\n    return status\n", "code_toks_joined": "def _get_instance_health ( self , lb ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> status = lb . get_instance_health ( [ self . instance_id ] ) [ 0 ] <NEWLINE> <DEDENT> except boto . exception . BotoServerError , e : <NEWLINE> <INDENT> if e . error_code == <STRING> : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> <DEDENT> return status <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Check instance health, should return status object or None under\"\"\"", "'InvalidInstance'"]}, "err_obj": {"msg": "invalid syntax"}}], ["2e31e9d4f5c9d1e540ed8512e62b991e", {"code_string": "def docycle(iterations = 10000, experiments = 10000):\n    step = pi * sqrt(2)\n    for i in xrange(experiments):\n    sum = 0\n    x = 0\n    for j in xrange(experiments):\n        x += step\n        sum += cos(x)\n", "code_toks_joined": "def docycle ( iterations = 10000 , experiments = 10000 ) : <NEWLINE> <INDENT> step = pi * sqrt ( 2 ) <NEWLINE> for i in xrange ( experiments ) : <NEWLINE> sum = 0 <NEWLINE> x = 0 <NEWLINE> for j in xrange ( experiments ) : <NEWLINE> <INDENT> x += step <NEWLINE> sum += cos ( x ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["fec202f0caf138554c691073e38e98e0", {"code_string": "def pull_states(tis):\n    res = []\n    for idx in xrange(tis.config[\"nstate\"]):\n    state = State(tis, idx)\n    state.pull_disk()\n    state.rollup()\n    res.append(state)\n    return res\n", "code_toks_joined": "def pull_states ( tis ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> for idx in xrange ( tis . config [ <STRING> ] ) : <NEWLINE> state = State ( tis , idx ) <NEWLINE> state . pull_disk ( ) <NEWLINE> state . rollup ( ) <NEWLINE> res . append ( state ) <NEWLINE> return res <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"nstate\""]}, "err_obj": {"msg": "expected an indented block"}}], ["54ba3c75b85f4dbb790250fb1b78565e", {"code_string": "def test_manual_true():\n    assert integrate(exp(x) * sin(x), x, manual = True) ==(exp(x) * sin(x))) / 2 -(exp(x) * cos(x)) / 2\n    assert integrate(sin(x) * cos(x), x, manual = True) in[sin(x) ** 2 / 2, - cos(x) ** 2 / 2]\n", "code_toks_joined": "def test_manual_true ( ) : <NEWLINE> <INDENT> assert integrate ( exp ( x ) * sin ( x ) , x , manual = True ) == ( exp ( x ) * sin ( x ) ) ) / 2 - ( exp ( x ) * cos ( x ) ) / 2 <NEWLINE> assert integrate ( sin ( x ) * cos ( x ) , x , manual = True ) in [ sin ( x ) ** 2 / 2 , - cos ( x ) ** 2 / 2 ] <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["e5453dff4d8100225e3d7d1f6f532dca", {"code_string": "def _ProcessNewPreferences(self):\n    \"\"\"Find and process modifications.\"\"\"\n    modified = False\n    for pref in(launcher.Preferences.PREF_PYTHON,\n        launcher.Preferences.PREF_APPENGINE,\n        launcher.Preferences.PREF_DEPLOY_SERVER,\n        launcher.Preferences.PREF_EDITOR):\n        oldval = self._preferences.Get(pref)\n        newval = self._dialog.Get(pref)\n        if newval != oldval:\n        modified = True\n        self._preferences[pref] = newval\n    if modified and hasattr(self._preferences, \"Save\"):\n        self._preferences.Save()\n", "code_toks_joined": "def _ProcessNewPreferences ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> modified = False <NEWLINE> for pref in ( launcher . Preferences . PREF_PYTHON , <NEWLINE> <INDENT> launcher . Preferences . PREF_APPENGINE , <NEWLINE> launcher . Preferences . PREF_DEPLOY_SERVER , <NEWLINE> launcher . Preferences . PREF_EDITOR ) : <NEWLINE> oldval = self . _preferences . Get ( pref ) <NEWLINE> newval = self . _dialog . Get ( pref ) <NEWLINE> if newval != oldval : <NEWLINE> modified = True <NEWLINE> self . _preferences [ pref ] = newval <NEWLINE> <DEDENT> if modified and hasattr ( self . _preferences , <STRING> ) : <NEWLINE> <INDENT> self . _preferences . Save ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Find and process modifications.\"\"\"", "\"Save\""]}, "err_obj": {"msg": "expected an indented block"}}], ["401d1e312a74dcadd33d2feb9b5ebf92", {"code_string": "import sublime_plugin\nclass AwesomeFooCommand(sublime_plugin.ApplicationCommand)\n    \"\"\"I'm missing a colon\"\"\"\n    def run(self):\n        print(\"Hello, world!\")\n", "code_toks_joined": "import sublime_plugin <NEWLINE> class AwesomeFooCommand ( sublime_plugin . ApplicationCommand ) <NEWLINE> <INDENT> <STRING> <NEWLINE> def run ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"I'm missing a colon\"\"\"", "\"Hello, world!\""]}, "err_obj": {"msg": "invalid syntax"}}], ["50f5545218c2359c02c23fa71dcba978", {"code_string": "def _get_index_of_data(self, fact):\n    try:\n        return self.database.index(fact)\n    except ValueError as ve:\n        if \"BaseRules\" in str(self.type_son):\n            print \"Rule is not in the rules list !\"\n        else:\n            print \"Fact is not in the facts list !\"\n", "code_toks_joined": "def _get_index_of_data ( self , fact ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return self . database . index ( fact ) <NEWLINE> <DEDENT> except ValueError as ve : <NEWLINE> <INDENT> if <STRING> in str ( self . type_son ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"BaseRules\"", "\"Rule is not in the rules list !\"", "\"Fact is not in the facts list !\""]}, "err_obj": {"msg": "invalid syntax"}}], ["f87116e10efe320c3fbf195da81de588", {"code_string": "def _update_table_constraints(table, distribution_column):\n    for c in table.constraints:\n        if(isinstance(c, PrimaryKeyConstraint) or\n            isinstance(c, UniqueConstraint)):\n            if distribution_column not in c.columns:\n            c.columns.add(table.columns[distribution_column])\n    return table\n", "code_toks_joined": "def _update_table_constraints ( table , distribution_column ) : <NEWLINE> <INDENT> for c in table . constraints : <NEWLINE> <INDENT> if ( isinstance ( c , PrimaryKeyConstraint ) or <NEWLINE> <INDENT> isinstance ( c , UniqueConstraint ) ) : <NEWLINE> if distribution_column not in c . columns : <NEWLINE> c . columns . add ( table . columns [ distribution_column ] ) <NEWLINE> <DEDENT> <DEDENT> return table <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["f5cc2059a00bfb5fc6c3e4a55565cb35", {"code_string": "def _GetMessage(node):\n    for c in(n for n in node.childNodes\n        if n.nodeType == xml.dom.Node.ELEMENT_NODE):\n        if c.tagName == 'Message':\n        if(len(c.childNodes) == 1\n        and c.childNodes[0].nodeType == xml.dom.Node.TEXT_NODE):\n        return c.childNodes[0].data\n    return None\n", "code_toks_joined": "def _GetMessage ( node ) : <NEWLINE> <INDENT> for c in ( n for n in node . childNodes <NEWLINE> <INDENT> if n . nodeType == xml . dom . Node . ELEMENT_NODE ) : <NEWLINE> if c . tagName == <STRING> : <NEWLINE> if ( len ( c . childNodes ) == 1 <NEWLINE> and c . childNodes [ 0 ] . nodeType == xml . dom . Node . TEXT_NODE ) : <NEWLINE> return c . childNodes [ 0 ] . data <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Message'"]}, "err_obj": {"msg": "expected an indented block"}}], ["e6f5e2b1f48c6348428b5ee61f2b46dc", {"code_string": "class FeeDialog(Factory.Popup):\n    def __init__(self, app, config, callback):\n        Factory.Popup.__init__(self)\n        self.app = app\n        self.config = config\n        self.callback = callback\n        self.update_text()\n    def update_text(self):\n        value = int(self.get_fee_text(value))\n        self.ids.fee_per_kb.text = self.get_fee_text(value)\n    def get_fee_text(self, value):\n        return self.app.format_amount_and_units(value) + '/kB'\n    def on_ok(self):\n        value = int(self.config.set_key('fee_per_kb', value)\n        self.callback()\n    def on_checkbox(self, b):\n        self.update_text()\n", "code_toks_joined": "class FeeDialog ( Factory . Popup ) : <NEWLINE> <INDENT> def __init__ ( self , app , config , callback ) : <NEWLINE> <INDENT> Factory . Popup . __init__ ( self ) <NEWLINE> self . app = app <NEWLINE> self . config = config <NEWLINE> self . callback = callback <NEWLINE> self . update_text ( ) <NEWLINE> <DEDENT> def update_text ( self ) : <NEWLINE> <INDENT> value = int ( self . get_fee_text ( value ) ) <NEWLINE> self . ids . fee_per_kb . text = self . get_fee_text ( value ) <NEWLINE> <DEDENT> def get_fee_text ( self , value ) : <NEWLINE> <INDENT> return self . app . format_amount_and_units ( value ) + <STRING> <NEWLINE> <DEDENT> def on_ok ( self ) : <NEWLINE> <INDENT> value = int ( self . config . set_key ( <STRING> , value ) <NEWLINE> self . callback ( ) <NEWLINE> <DEDENT> def on_checkbox ( self , b ) : <NEWLINE> <INDENT> self . update_text ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'/kB'", "'fee_per_kb'"]}, "window_span": [128, 165], "err_obj": {"msg": "unbalanced (){}[]"}}], ["7f16843b59a32670d04e2db771e4c792", {"code_string": "def process_response(self, resp, data):\n    for metric, facet in resp.get('facets', {}).items():\n        count = facet.get('count', 0)\n        if count > 0:\n            for field in('max', 'mean', 'min', 'std_deviation',\n                'sum_of_squares', 'total', 'variance'):\n                value = facet.get(field)\n                if value is not None:\n                data[metric][field] = value\n", "code_toks_joined": "def process_response ( self , resp , data ) : <NEWLINE> <INDENT> for metric , facet in resp . get ( <STRING> , { } ) . items ( ) : <NEWLINE> <INDENT> count = facet . get ( <STRING> , 0 ) <NEWLINE> if count > 0 : <NEWLINE> <INDENT> for field in ( <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> ) : <NEWLINE> value = facet . get ( field ) <NEWLINE> if value is not None : <NEWLINE> data [ metric ] [ field ] = value <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'facets'", "'count'", "'max'", "'mean'", "'min'", "'std_deviation'", "'sum_of_squares'", "'total'", "'variance'"]}, "err_obj": {"msg": "expected an indented block"}}], ["547d53a57d34307ded31bec2625142f2", {"code_string": "def process_spider_output(self, response, result, spider):\n    \"\"\"Store page tag details if page clustering was not available.\"\"\"\n    saved = False\n    for out in result:\n        if(not saved and self.clustering_enabled and\n            hasattr(out, 'get') and\n            out.get('_template_cluster') == _CLUSTER_NA):\n            key = request_fingerprint(response.request)\n            logging.debug('Saving %s for clustering on next crawl',\n                response.request)\n                self.db[key] = json.dumps([response.body_as_unicode(),\n                    response.encoding])\n                    saved = True\n        yield out\n", "code_toks_joined": "def process_spider_output ( self , response , result , spider ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> saved = False <NEWLINE> for out in result : <NEWLINE> <INDENT> if ( not saved and self . clustering_enabled and <NEWLINE> <INDENT> hasattr ( out , <STRING> ) and <NEWLINE> out . get ( <STRING> ) == _CLUSTER_NA ) : <NEWLINE> key = request_fingerprint ( response . request ) <NEWLINE> logging . debug ( <STRING> , <NEWLINE> <INDENT> response . request ) <NEWLINE> self . db [ key ] = json . dumps ( [ response . body_as_unicode ( ) , <NEWLINE> <INDENT> response . encoding ] ) <NEWLINE> saved = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> yield out <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Store page tag details if page clustering was not available.\"\"\"", "'get'", "'_template_cluster'", "'Saving %s for clustering on next crawl'"]}, "err_obj": {"msg": "unexpected indent"}}], ["a19fc01873ee8cb2710f75d471810b4f", {"code_string": "def _lock_state_file(self):\n    if not self.lock:\n        return\n    self._lockfile = LockFile(self.path)\n    if(self._lockfile.is_locked() and\n        (time() - getmtime(self._lockfile.lock_file) > 10):\n        self._lockfile.break_lock()\n    self._lockfile.acquire()\n", "code_toks_joined": "def _lock_state_file ( self ) : <NEWLINE> <INDENT> if not self . lock : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> self . _lockfile = LockFile ( self . path ) <NEWLINE> if ( self . _lockfile . is_locked ( ) and <NEWLINE> <INDENT> ( time ( ) - getmtime ( self . _lockfile . lock_file ) > 10 ) : <NEWLINE> self . _lockfile . break_lock ( ) <NEWLINE> <DEDENT> self . _lockfile . acquire ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["8963ff62f71e531b4c11bbae63faf7f8", {"code_string": "def test_get_test_filename():\n    assert_get_test_filename_finds(\n        os.path.join('p1', 'f1.py'),\n        os.path.join('p1', 'unittests', 'f1-tests.py')\n    )\n    assert_get_test_filename_finds(\n        os.path.join('p1', 'f1.py')\n        os.path.join('p1', 'f1-tests.py')\n    )\n", "code_toks_joined": "def test_get_test_filename ( ) : <NEWLINE> <INDENT> assert_get_test_filename_finds ( <NEWLINE> <INDENT> os . path . join ( <STRING> , <STRING> ) , <NEWLINE> os . path . join ( <STRING> , <STRING> , <STRING> ) <NEWLINE> <DEDENT> ) <NEWLINE> assert_get_test_filename_finds ( <NEWLINE> <INDENT> os . path . join ( <STRING> , <STRING> ) <NEWLINE> os . path . join ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'p1'", "'f1.py'", "'p1'", "'unittests'", "'f1-tests.py'", "'p1'", "'f1.py'", "'p1'", "'f1-tests.py'"]}, "err_obj": {"msg": "invalid syntax"}}], ["37fd1f5fb3268916ba0e6afe60c110d8", {"code_string": "def _convert_to_ascii(self, * values):\n    \"\"\"Converts all values to ascii strings.\"\"\"\n    for value in values:\n        if isinstance(value, unicode):\n            try:\n                value = value.encode('us-ascii')\n            except UnicodeError, e:\n                e.reason += ', HTTP response headers must be in US-ASCII format'\n                raise\n        else:\n            value = str(value)\n        if '\\n' in value or '\\r' in value:\n            raise BadHeaderError(\"Header values can't contain newlines (got %r)\" %(value))\n        yield value\n", "code_toks_joined": "def _convert_to_ascii ( self , * values ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for value in values : <NEWLINE> <INDENT> if isinstance ( value , unicode ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> value = value . encode ( <STRING> ) <NEWLINE> <DEDENT> except UnicodeError , e : <NEWLINE> <INDENT> e . reason += <STRING> <NEWLINE> raise <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> value = str ( value ) <NEWLINE> <DEDENT> if <STRING> in value or <STRING> in value : <NEWLINE> <INDENT> raise BadHeaderError ( <STRING> % ( value ) ) <NEWLINE> <DEDENT> yield value <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Converts all values to ascii strings.\"\"\"", "'us-ascii'", "', HTTP response headers must be in US-ASCII format'", "'\\n'", "'\\r'", "\"Header values can't contain newlines (got %r)\""]}, "err_obj": {"msg": "invalid syntax"}}], ["6911b42bcd601958d3e743890ea5cb16", {"code_string": "def split_array(arr):\n    \"\"\"Split arr into a 2-level trie.\"\"\"\n    return min(\n        (try_split(arr, shift) for shift in xrange(len(arr).bit_length())),\n        key = lambda(t1, t2, shift): bytes_needed(t1)[1] * len(t1)\n            + bytes_needed(t2)[1] * len(t2)\n    )\n", "code_toks_joined": "def split_array ( arr ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return min ( <NEWLINE> <INDENT> ( try_split ( arr , shift ) for shift in xrange ( len ( arr ) . bit_length ( ) ) ) , <NEWLINE> key = lambda ( t1 , t2 , shift ) : bytes_needed ( t1 ) [ 1 ] * len ( t1 ) <NEWLINE> <INDENT> + bytes_needed ( t2 ) [ 1 ] * len ( t2 ) <NEWLINE> <DEDENT> <DEDENT> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Split arr into a 2-level trie.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["2a5cf8997ea240a89c958dd1a118fcc2", {"code_string": "def get_mathjax_header():\n    \"\"\"Return the snippet of HTML code to put in HTML HEAD tag, in order to\"\"\"\n    if CFG_MATHJAX_HOSTING.lower() == 'cdn':\n        mathjax_path = \"http://cdn.mathjax.org/mathjax/1.1-latest\"\n    else:\n        mathjax_path = \"/MathJax\"\n    return \"\"\"<script type=\"text/x-mathjax-config\">\"\"\" %{\n    'mathjax_path': mathjax_path\n", "code_toks_joined": "def get_mathjax_header ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if CFG_MATHJAX_HOSTING . lower ( ) == <STRING> : <NEWLINE> <INDENT> mathjax_path = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mathjax_path = <STRING> <NEWLINE> <DEDENT> return <STRING> % { <NEWLINE> <STRING> : mathjax_path <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return the snippet of HTML code to put in HTML HEAD tag, in order to\"\"\"", "'cdn'", "\"http://cdn.mathjax.org/mathjax/1.1-latest\"", "\"/MathJax\"", "\"\"\"<script type=\"text/x-mathjax-config\">\"\"\"", "'mathjax_path'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["f00dfe9b45aff4fda7093dacf9358175", {"code_string": "def broadcast(self, * args):\n    \"\"\"Broadcast data over the network\"\"\"\n    if self.networking == \"server\":\n        try:\n            data = cPickle.dumps(args)\n            self.network_stream.sendto(data, ('<broadcast>', self.port))\n        except socket.error, msg:\n            if msg[0] != 9:\n                log.error(str(msg[0]) + ' ' + msg[1])\n                print(str(msg[0]) + ' ' + msg[1])\n", "code_toks_joined": "def broadcast ( self , * args ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . networking == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> data = cPickle . dumps ( args ) <NEWLINE> self . network_stream . sendto ( data , ( <STRING> , self . port ) ) <NEWLINE> <DEDENT> except socket . error , msg : <NEWLINE> <INDENT> if msg [ 0 ] != 9 : <NEWLINE> <INDENT> log . error ( str ( msg [ 0 ] ) + <STRING> + msg [ 1 ] ) <NEWLINE> print ( str ( msg [ 0 ] ) + <STRING> + msg [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Broadcast data over the network\"\"\"", "\"server\"", "'<broadcast>'", "' '", "' '"]}, "err_obj": {"msg": "invalid syntax"}}], ["a86b9b1d54e0f379a094f724f8dd468d", {"code_string": "class BaseDbTemplateDecorator(BaseTemplateDecorator):\n    def __init__(self, ingress):\n        super(BaseDbTemplateDecorator, self).__init__()\n        self._ingress = ingress\n    def _add_client_resources(self, resources, app_region, port, params,\n        sg_ref):\n        clients = params.get('clients', ())\n        ingress_resources = self._ingress.ingress_resources(app_region,\n            port,\n            clients,\n            sg_ref = sg_ref)\n            logger.debug('Adding %s ingress rules.', len(ingress_resources))\n            resources.update(ingress_resources)\n", "code_toks_joined": "class BaseDbTemplateDecorator ( BaseTemplateDecorator ) : <NEWLINE> <INDENT> def __init__ ( self , ingress ) : <NEWLINE> <INDENT> super ( BaseDbTemplateDecorator , self ) . __init__ ( ) <NEWLINE> self . _ingress = ingress <NEWLINE> <DEDENT> def _add_client_resources ( self , resources , app_region , port , params , <NEWLINE> <INDENT> sg_ref ) : <NEWLINE> clients = params . get ( <STRING> , ( ) ) <NEWLINE> ingress_resources = self . _ingress . ingress_resources ( app_region , <NEWLINE> <INDENT> port , <NEWLINE> clients , <NEWLINE> sg_ref = sg_ref ) <NEWLINE> logger . debug ( <STRING> , len ( ingress_resources ) ) <NEWLINE> resources . update ( ingress_resources ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'clients'", "'Adding %s ingress rules.'"]}, "err_obj": {"msg": "unexpected indent"}}], ["8abbfd790fbed69a4cd5dcd4d6d9ac68", {"code_string": "def countCrashes(file_name):\n    file_in = open(file_name, \"r\")\n    output_value = 0\n    for line in file_in:\n        if \"****IN FLIGHT EMERGENCY****\" in line:\n            output_value += 1\n            elif \"out of fuel\" in line:\n            print(\"File shows jet out of fuel.\")\n    return output_value\n", "code_toks_joined": "def countCrashes ( file_name ) : <NEWLINE> <INDENT> file_in = open ( file_name , <STRING> ) <NEWLINE> output_value = 0 <NEWLINE> for line in file_in : <NEWLINE> <INDENT> if <STRING> in line : <NEWLINE> <INDENT> output_value += 1 <NEWLINE> elif <STRING> in line : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return output_value <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"r\"", "\"****IN FLIGHT EMERGENCY****\"", "\"out of fuel\"", "\"File shows jet out of fuel.\""]}, "err_obj": {"msg": "invalid syntax"}}], ["8d0beb1300046ecfb49018685192c078", {"code_string": "import os\nimport sys\nimport pytest\nsys.path.append(os.path.join(os.path.dirname(__file__), \"django-tuttle\")\nsys.exit(pytest.main())\n", "code_toks_joined": "import os <NEWLINE> import sys <NEWLINE> import pytest <NEWLINE> sys . path . append ( os . path . join ( os . path . dirname ( __file__ ) , <STRING> ) <NEWLINE> sys . exit ( pytest . main ( ) ) <NEWLINE>", "anonymize_dict": {"<STRING>": ["\"django-tuttle\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["0d1dd21b8f9da337d7ebaa890a998e8a", {"code_string": "def install_host():\n    \"\"\"Install required components into supported hosts\"\"\"\n    for install in(_install_maya,\n        _install_houdini,\n        _install_nuke,\n        _install_hiero,\n        _install_nukestudio):\n        try:\n        install()\n        except ImportError:\n        pass\n        else:\n        break\n", "code_toks_joined": "def install_host ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for install in ( _install_maya , <NEWLINE> <INDENT> _install_houdini , <NEWLINE> _install_nuke , <NEWLINE> _install_hiero , <NEWLINE> _install_nukestudio ) : <NEWLINE> try : <NEWLINE> install ( ) <NEWLINE> except ImportError : <NEWLINE> pass <NEWLINE> else : <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Install required components into supported hosts\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["e485323c5fca4e03f165941039b6cb10", {"code_string": "def __getattr__(self, name):\n    if name in dir(self):\n        return getattr(self, name)\n    elif name.startswith('_'):\n        raise AttributeError, \"Attribute %s not found\" % name\n    else:\n        if self.__mlname__ is not None:\n            name = (self.__mlname__ + '.' + name)\n        newname = MATLABName(name)\n        setattr(self, name, newname)\n        sys.modules[newname.__name__] = newname\n        return newname\n", "code_toks_joined": "def __getattr__ ( self , name ) : <NEWLINE> <INDENT> if name in dir ( self ) : <NEWLINE> <INDENT> return getattr ( self , name ) <NEWLINE> <DEDENT> elif name . startswith ( <STRING> ) : <NEWLINE> <INDENT> raise AttributeError , <STRING> % name <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if self . __mlname__ is not None : <NEWLINE> <INDENT> name = ( self . __mlname__ + <STRING> + name ) <NEWLINE> <DEDENT> newname = MATLABName ( name ) <NEWLINE> setattr ( self , name , newname ) <NEWLINE> sys . modules [ newname . __name__ ] = newname <NEWLINE> return newname <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'_'", "\"Attribute %s not found\"", "'.'"]}, "err_obj": {"msg": "invalid syntax"}}], ["1ed9cdff1840558bdd9ed001fadf9c6b", {"code_string": "def get_api_calls():\n    calls = {}\n    for t in rdf_ontology.api_calls:\n        target = str(t.target)\n        method = str(t.method)\n        path = str(t.path)\n        category = str(t.category)\n        if method == \"GET\" and(category == \"record_items\" or\n            path == \"/ontology\" or\n            path == \"/apps/manifests/\" or\n            path == \"/manifest\"):\n            if target not in calls.keys():\n            calls[target] = path\n    return calls\n", "code_toks_joined": "def get_api_calls ( ) : <NEWLINE> <INDENT> calls = { } <NEWLINE> for t in rdf_ontology . api_calls : <NEWLINE> <INDENT> target = str ( t . target ) <NEWLINE> method = str ( t . method ) <NEWLINE> path = str ( t . path ) <NEWLINE> category = str ( t . category ) <NEWLINE> if method == <STRING> and ( category == <STRING> or <NEWLINE> <INDENT> path == <STRING> or <NEWLINE> path == <STRING> or <NEWLINE> path == <STRING> ) : <NEWLINE> if target not in calls . keys ( ) : <NEWLINE> calls [ target ] = path <NEWLINE> <DEDENT> <DEDENT> return calls <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"GET\"", "\"record_items\"", "\"/ontology\"", "\"/apps/manifests/\"", "\"/manifest\""]}, "err_obj": {"msg": "expected an indented block"}}], ["9dc1ae2ca3eb8a01d9bf7730b4def6a5", {"code_string": "def compare(self, obj):\n    \"\"\" Compare objects. \"\"\"\n    for prop in orm.object_mapper(self).iterate_properties:\n        if isinstance(prop, orm.ColumnProperty) or(isinstance(prop, orm.RelationshipProperty)\n            and prop.secondary):\n            if getattr(obj, prop.key) != getattr(self, prop.key):\n            return False\n    return True\n", "code_toks_joined": "def compare ( self , obj ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for prop in orm . object_mapper ( self ) . iterate_properties : <NEWLINE> <INDENT> if isinstance ( prop , orm . ColumnProperty ) or ( isinstance ( prop , orm . RelationshipProperty ) <NEWLINE> <INDENT> and prop . secondary ) : <NEWLINE> if getattr ( obj , prop . key ) != getattr ( self , prop . key ) : <NEWLINE> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Compare objects. \"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["990029fae57d1c6dd8d4289745bf60c6", {"code_string": "def setupUi(self, MainWindow):\n    MainWindow.setObjectName(\"MainWindow\")\n    MainWindow.resize(742, 440)\n    MainWindow.setStyleSheet(\"\")\n    MainWindow.setUnifiedTitleAndToolBarOnMac(False)\n    self.centralwidget = QtWidgets.QWidget(MainWindow)\n    self.centralwidget.setMinimumSize(QtCore.QSize(742, 409))\n    palette = QtGui.QPalette()\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(20, 20, 20))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(30, 30, 30))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(25, 25, 25))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(10, 10, 10))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(13, 13, 13))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(20, 20, 20))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(20, 20, 20))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 85, 0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(10, 10, 10))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(20, 20, 20))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(30, 30, 30))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(25, 25, 25))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(10, 10, 10))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(13, 13, 13))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(20, 20, 20))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(20, 20, 20))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 85, 0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(10, 10, 10))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(10, 10, 10))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(20, 20, 20))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(30, 30, 30))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(25, 25, 25))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(10, 10, 10))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(13, 13, 13))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(10, 10, 10))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(10, 10, 10))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(20, 20, 20))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(20, 20, 20))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(51, 153, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(20, 20, 20))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipText, brush)\n    self.centralwidget.setPalette(palette)\n    self.centralwidget.setStyleSheet(\"background-color: #141414;\")\n    self.centralwidget.setObjectName(\"centralwidget\")\n    self.gridLayout_2 = QtWidgets.QGridLayout(self.centralwidget)\n    self.gridLayout_2.setContentsMargins(0, 0, 0, 0)\n    self.gridLayout_2.setSpacing(0)\n    self.gridLayout_2.setObjectName(\"gridLayout_2\")\n    self.stackedWidget = QtWidgets.QStackedWidget(self.centralwidget)\n    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Preferred)\n    sizePolicy.setHorizontalStretch(0)\n    sizePolicy.setVerticalStretch(0)\n    sizePolicy.setHeightForWidth(self.stackedWidget.sizePolicy().hasHeightForWidth())\n    self.stackedWidget.setSizePolicy(sizePolicy)\n    self.stackedWidget.setAutoFillBackground(False)\n    self.stackedWidget.setStyleSheet(\"border-color: rgb(20, 20, 20);\")\n    self.stackedWidget.setFrameShadow(QtWidgets.QFrame.Sunken)\n    self.stackedWidget.setLineWidth(0)\n    self.stackedWidget.setObjectName(\"stackedWidget\")\n    self.Chat = QtWidgets.QWidget()\n    self.Chat.setStyleSheet(\"background-color: #141414;\\n\"\n", "code_toks_joined": "def setupUi ( self , MainWindow ) : <NEWLINE> <INDENT> MainWindow . setObjectName ( <STRING> ) <NEWLINE> MainWindow . resize ( 742 , 440 ) <NEWLINE> MainWindow . setStyleSheet ( <STRING> ) <NEWLINE> MainWindow . setUnifiedTitleAndToolBarOnMac ( False ) <NEWLINE> self . centralwidget = QtWidgets . QWidget ( MainWindow ) <NEWLINE> self . centralwidget . setMinimumSize ( QtCore . QSize ( 742 , 409 ) ) <NEWLINE> palette = QtGui . QPalette ( ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . WindowText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 20 , 20 , 20 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Button , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 30 , 30 , 30 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Light , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 25 , 25 , 25 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Midlight , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 10 , 10 , 10 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Dark , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 13 , 13 , 13 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Mid , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Text , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . BrightText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . ButtonText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 20 , 20 , 20 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Base , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 20 , 20 , 20 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Window , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 0 , 0 , 0 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Shadow , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 85 , 0 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . Highlight , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 10 , 10 , 10 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . AlternateBase , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 220 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . ToolTipBase , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Active , QtGui . QPalette . ToolTipText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . WindowText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 20 , 20 , 20 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Button , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 30 , 30 , 30 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Light , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 25 , 25 , 25 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Midlight , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 10 , 10 , 10 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Dark , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 13 , 13 , 13 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Mid , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Text , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . BrightText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . ButtonText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 20 , 20 , 20 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Base , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 20 , 20 , 20 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Window , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 0 , 0 , 0 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Shadow , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 85 , 0 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . Highlight , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 10 , 10 , 10 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . AlternateBase , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 220 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . ToolTipBase , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Inactive , QtGui . QPalette . ToolTipText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 10 , 10 , 10 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . WindowText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 20 , 20 , 20 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Button , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 30 , 30 , 30 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Light , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 25 , 25 , 25 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Midlight , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 10 , 10 , 10 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Dark , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 13 , 13 , 13 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Mid , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 10 , 10 , 10 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Text , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . BrightText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 10 , 10 , 10 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . ButtonText , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 20 , 20 , 20 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Base , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 20 , 20 , 20 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Window , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 0 , 0 , 0 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Shadow , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 51 , 153 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . Highlight , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 20 , 20 , 20 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . AlternateBase , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 220 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . ToolTipBase , brush ) <NEWLINE> brush = QtGui . QBrush ( QtGui . QColor ( 255 , 255 , 255 ) ) <NEWLINE> brush . setStyle ( QtCore . Qt . SolidPattern ) <NEWLINE> palette . setBrush ( QtGui . QPalette . Disabled , QtGui . QPalette . ToolTipText , brush ) <NEWLINE> self . centralwidget . setPalette ( palette ) <NEWLINE> self . centralwidget . setStyleSheet ( <STRING> ) <NEWLINE> self . centralwidget . setObjectName ( <STRING> ) <NEWLINE> self . gridLayout_2 = QtWidgets . QGridLayout ( self . centralwidget ) <NEWLINE> self . gridLayout_2 . setContentsMargins ( 0 , 0 , 0 , 0 ) <NEWLINE> self . gridLayout_2 . setSpacing ( 0 ) <NEWLINE> self . gridLayout_2 . setObjectName ( <STRING> ) <NEWLINE> self . stackedWidget = QtWidgets . QStackedWidget ( self . centralwidget ) <NEWLINE> sizePolicy = QtWidgets . QSizePolicy ( QtWidgets . QSizePolicy . MinimumExpanding , QtWidgets . QSizePolicy . Preferred ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( self . stackedWidget . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> self . stackedWidget . setSizePolicy ( sizePolicy ) <NEWLINE> self . stackedWidget . setAutoFillBackground ( False ) <NEWLINE> self . stackedWidget . setStyleSheet ( <STRING> ) <NEWLINE> self . stackedWidget . setFrameShadow ( QtWidgets . QFrame . Sunken ) <NEWLINE> self . stackedWidget . setLineWidth ( 0 ) <NEWLINE> self . stackedWidget . setObjectName ( <STRING> ) <NEWLINE> self . Chat = QtWidgets . QWidget ( ) <NEWLINE> self . Chat . setStyleSheet ( <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"MainWindow\"", "\"\"", "\"background-color: #141414;\"", "\"centralwidget\"", "\"gridLayout_2\"", "\"border-color: rgb(20, 20, 20);\"", "\"stackedWidget\"", "\"background-color: #141414;\\n\""]}, "window_span": [2588, 2592], "err_obj": {"msg": "unbalanced (){}[]"}}], ["00660f78acd98abcfd3f5360036f3bb2", {"code_string": "def print_status():\n    if(debugLevel): print \"rwp: print_status() called\"\n    print(\"rwp.print_status: encoders[left, right]=[%f, %f]cm\" %(enc_read(1), enc_read(0)))\n", "code_toks_joined": "def print_status ( ) : <NEWLINE> <INDENT> if ( debugLevel ) : print <STRING> <NEWLINE> print ( <STRING> % ( enc_read ( 1 ) , enc_read ( 0 ) ) ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"rwp: print_status() called\"", "\"rwp.print_status: encoders[left, right]=[%f, %f]cm\""]}, "err_obj": {"msg": "invalid syntax"}}], ["6be27d6eae6d4b90a9a1af29b31526c5", {"code_string": "from pylab import plot, show\nfrom numpy import vstack, array\nfrom numpy.random import rand\nfrom scipy.cluster.vq import kmeans, vq\nimport echonest.audio as audio\nfrom echonest.sorting import *\nfrom echonest.selection import *\nimport pyechonest.config as config\nconfig.MP3_BITRATE = 192\ninputFilename = \"mp3/softhotlong.mp3\"\nsong = audio.LocalAudioFile(inputFilename)\nsample_rate = song.sampleRate\nnum_channels = song.numChannels\nout_shape = list(song.data.shape)\nout_shape[0] = 2\nnum_clusters = 50\nouts = [None] * num_clusters\nfor n in range(0, num_clusters):\n    outs[n] = audio.AudioData(shape = out_shape, sampleRate = sample_rate, numChannels = num_channels)\ndata = array(song.analysis.segments.timbre)\ncentroids, _ = kmeans(data, num_clusters)\nidx, _ = vq(data, centroids)\nsegclusters = [[]] * num_clusters\nfor s in range(0, len(idx)):\n    segment = song.analysis.segments[s]\n    cluster_number = idx[s]\n    outs[cluster_number].append(song[segment])\ninc = 0\nrand = random(\nfor out in outs:\n    out.encode(\"clusters/cluster\" + str(inc) + \".mp3\")\n    inc += 1\n", "code_toks_joined": "from pylab import plot , show <NEWLINE> from numpy import vstack , array <NEWLINE> from numpy . random import rand <NEWLINE> from scipy . cluster . vq import kmeans , vq <NEWLINE> import echonest . audio as audio <NEWLINE> from echonest . sorting import * <NEWLINE> from echonest . selection import * <NEWLINE> import pyechonest . config as config <NEWLINE> config . MP3_BITRATE = 192 <NEWLINE> inputFilename = <STRING> <NEWLINE> song = audio . LocalAudioFile ( inputFilename ) <NEWLINE> sample_rate = song . sampleRate <NEWLINE> num_channels = song . numChannels <NEWLINE> out_shape = list ( song . data . shape ) <NEWLINE> out_shape [ 0 ] = 2 <NEWLINE> num_clusters = 50 <NEWLINE> outs = [ None ] * num_clusters <NEWLINE> for n in range ( 0 , num_clusters ) : <NEWLINE> <INDENT> outs [ n ] = audio . AudioData ( shape = out_shape , sampleRate = sample_rate , numChannels = num_channels ) <NEWLINE> <DEDENT> data = array ( song . analysis . segments . timbre ) <NEWLINE> centroids , _ = kmeans ( data , num_clusters ) <NEWLINE> idx , _ = vq ( data , centroids ) <NEWLINE> segclusters = [ [ ] ] * num_clusters <NEWLINE> for s in range ( 0 , len ( idx ) ) : <NEWLINE> <INDENT> segment = song . analysis . segments [ s ] <NEWLINE> cluster_number = idx [ s ] <NEWLINE> outs [ cluster_number ] . append ( song [ segment ] ) <NEWLINE> <DEDENT> inc = 0 <NEWLINE> rand = random ( <NEWLINE> for out in outs : <NEWLINE> <INDENT> out . encode ( <STRING> + str ( inc ) + <STRING> ) <NEWLINE> inc += 1 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"mp3/softhotlong.mp3\"", "\"clusters/cluster\"", "\".mp3\""]}, "window_span": [254, 282], "err_obj": {"msg": "unbalanced (){}[]"}}], ["33937e48403a52e6637a44a30f8e4419", {"code_string": "def ipc_server(qapp, qtbot):\n    server = ipc.IPCServer('qute-test')\n    yield server\n    if(server._socket is not None and\n        server._socket.state() != QLocalSocket.UnconnectedState):\n        with qtbot.waitSignal(server._socket.disconnected, raising = False):\n        server._socket.abort()\n    try:\n        server.shutdown()\n    except ipc.Error:\n        pass\n", "code_toks_joined": "def ipc_server ( qapp , qtbot ) : <NEWLINE> <INDENT> server = ipc . IPCServer ( <STRING> ) <NEWLINE> yield server <NEWLINE> if ( server . _socket is not None and <NEWLINE> <INDENT> server . _socket . state ( ) != QLocalSocket . UnconnectedState ) : <NEWLINE> with qtbot . waitSignal ( server . _socket . disconnected , raising = False ) : <NEWLINE> server . _socket . abort ( ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> server . shutdown ( ) <NEWLINE> <DEDENT> except ipc . Error : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'qute-test'"]}, "err_obj": {"msg": "expected an indented block"}}], ["4c96c2bb47d63315b04bb60a0437a7c0", {"code_string": "def download_attachment(self, url):\n    url = url.strip(\" <>\")\n    if self.no_download:\n        if self.verbose:\n            print(\"NOT downloading attachment from %s\" % url)\n        content = \"\"\n    else:\n        if self.verbose:\n            print(\"Downloading attachment from %s\" % url)\n        try:\n            content = urllib.urlopen(url).read()\n        except IOError, e:\n            raise DownloadError(e)\n    return content\n", "code_toks_joined": "def download_attachment ( self , url ) : <NEWLINE> <INDENT> url = url . strip ( <STRING> ) <NEWLINE> if self . no_download : <NEWLINE> <INDENT> if self . verbose : <NEWLINE> <INDENT> print ( <STRING> % url ) <NEWLINE> <DEDENT> content = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if self . verbose : <NEWLINE> <INDENT> print ( <STRING> % url ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> content = urllib . urlopen ( url ) . read ( ) <NEWLINE> <DEDENT> except IOError , e : <NEWLINE> <INDENT> raise DownloadError ( e ) <NEWLINE> <DEDENT> <DEDENT> return content <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\" <>\"", "\"NOT downloading attachment from %s\"", "\"\"", "\"Downloading attachment from %s\""]}, "err_obj": {"msg": "invalid syntax"}}], ["6a75261cbede36d537c4a7811b31818b", {"code_string": "def y1p_zeros(nt, complex = 0):\n    \"\"\"Returns nt (complex or real) zeros of Y1'(z), z1', and the value\"\"\"\n    if not isscalar(nt) or(floor(nt) != nt) or(nt <= 0):\n        raise ValueError, \"Arguments must be scalar positive integer.\"\n    kf = 2\n    kc = (complex != 1)\n    return specfun.cyzo(nt, kf, kc)\n", "code_toks_joined": "def y1p_zeros ( nt , complex = 0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not isscalar ( nt ) or ( floor ( nt ) != nt ) or ( nt <= 0 ) : <NEWLINE> <INDENT> raise ValueError , <STRING> <NEWLINE> <DEDENT> kf = 2 <NEWLINE> kc = ( complex != 1 ) <NEWLINE> return specfun . cyzo ( nt , kf , kc ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns nt (complex or real) zeros of Y1'(z), z1', and the value\"\"\"", "\"Arguments must be scalar positive integer.\""]}, "err_obj": {"msg": "invalid syntax"}}], ["8375c45f351e96373844a1a057ab186e", {"code_string": "def fstat(self, fd):\n    if fd.symbolic:\n        mode = self.state.se.BVS('st_mode', 32)\n    else:\n        fd = self.state.se.eval(fd)\n        mode = self.state.se.BVS('st_mode', 32) if not self.files[fd].name.startswith('/dev/') else self.state.se.BVV(0, 32)\n            self.state.se.BVV(0, 64),\n            self.state.se.BVV(0, 64),\n            mode,\n            self.state.se.BVV(0, 32),\n            self.state.se.BVV(0, 32),\n            self.state.se.BVV(0, 64),\n            self.state.se.BVS('st_size', 64),\n            self.state.se.BVV(0, 64),\n            self.state.se.BVV(0, 64),\n            self.state.se.BVV(0, 64),\n            self.state.se.BVV(0, 64),\n            self.state.se.BVV(0, 64),\n            self.state.se.BVV(0, 64),\n            self.state.se.BVV(0, 64),\n            self.state.se.BVV(0, 64))\n", "code_toks_joined": "def fstat ( self , fd ) : <NEWLINE> <INDENT> if fd . symbolic : <NEWLINE> <INDENT> mode = self . state . se . BVS ( <STRING> , 32 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fd = self . state . se . eval ( fd ) <NEWLINE> mode = self . state . se . BVS ( <STRING> , 32 ) if not self . files [ fd ] . name . startswith ( <STRING> ) else self . state . se . BVV ( 0 , 32 ) <NEWLINE> <INDENT> self . state . se . BVV ( 0 , 64 ) , <NEWLINE> self . state . se . BVV ( 0 , 64 ) , <NEWLINE> mode , <NEWLINE> self . state . se . BVV ( 0 , 32 ) , <NEWLINE> self . state . se . BVV ( 0 , 32 ) , <NEWLINE> self . state . se . BVV ( 0 , 64 ) , <NEWLINE> self . state . se . BVS ( <STRING> , 64 ) , <NEWLINE> self . state . se . BVV ( 0 , 64 ) , <NEWLINE> self . state . se . BVV ( 0 , 64 ) , <NEWLINE> self . state . se . BVV ( 0 , 64 ) , <NEWLINE> self . state . se . BVV ( 0 , 64 ) , <NEWLINE> self . state . se . BVV ( 0 , 64 ) , <NEWLINE> self . state . se . BVV ( 0 , 64 ) , <NEWLINE> self . state . se . BVV ( 0 , 64 ) , <NEWLINE> self . state . se . BVV ( 0 , 64 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'st_mode'", "'st_mode'", "'/dev/'", "'st_size'"]}, "window_span": [279, 293], "err_obj": {"msg": "unbalanced (){}[]"}}], ["5bd4e5a2d020551f00cf98aced06c8aa", {"code_string": "def proc_tank_scheduled(redis_msg, ** kw):\n    ext = {'test_id': redis_msg.get('id')}\n    logger = get_logger(** ext)\n    try:\n    except TankClientError as e:\n        logger.error('Tank API call failed: {}'.format(e))\n        raise\n    if tank_msg['status_code'] == 'PREPARING':\n        return\n    try:\n        lunaport_msg = lunaport_c1.test_get(redis_msg['id'])\n        case_struct = lunaport_c1.case_get(lunaport_msg.get('case_id'))\n    except LunaportClientError as e:\n        logger.error('Lunaport client call failed:{}'.format(e))\n        raise\n    if tank_msg['status_code'] == 'FINISHED' and tank_msg['exit_code'] == 1:\n        redis.hdel(r_adr['monitor_start'], kw['id'])\n        notify_test('on_start_failed', lunaport_msg, None, case = case_struct,\n            tank_msg = tank_msg)\n        return\n    diff = {\n        'status': TestStateTr.port_by_tank(tank_msg.get('status_code')),\n    }\n    t_summary = {}\n    if tank_msg.get('lunapark_id'):\n        try:\n            l_test_id = tank_msg['lunapark_id']).json().pop()\n            t_summary.update({'t_tank_id': redis_msg['t_tank_id']})\n            diff.update({\n            'lunapark': t_summary,\n            })\n            if t_summary.get('fd'):\n            diff.update({\n                'started_at': msk_iso_to_utc(t_summary['fd']).isoformat(),\n            })\n    try:\n        test_struct, test_loc = lunaport_c1.test_patch(redis_msg['id'], diff)\n    except LunaportClientError as e:\n        test_struct = None\n        logger.error('Lunaport client call failed:{}'.format(e))\n        if not 'Nothing to update' in str(e):\n            raise\n    redis.hdel(r_adr['monitor_start'], kw['id'])\n    t_struct = test_struct or t_summary\n", "code_toks_joined": "def proc_tank_scheduled ( redis_msg , ** kw ) : <NEWLINE> <INDENT> ext = { <STRING> : redis_msg . get ( <STRING> ) } <NEWLINE> logger = get_logger ( ** ext ) <NEWLINE> try : <NEWLINE> except TankClientError as e : <NEWLINE> <INDENT> logger . error ( <STRING> . format ( e ) ) <NEWLINE> raise <NEWLINE> <DEDENT> if tank_msg [ <STRING> ] == <STRING> : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> lunaport_msg = lunaport_c1 . test_get ( redis_msg [ <STRING> ] ) <NEWLINE> case_struct = lunaport_c1 . case_get ( lunaport_msg . get ( <STRING> ) ) <NEWLINE> <DEDENT> except LunaportClientError as e : <NEWLINE> <INDENT> logger . error ( <STRING> . format ( e ) ) <NEWLINE> raise <NEWLINE> <DEDENT> if tank_msg [ <STRING> ] == <STRING> and tank_msg [ <STRING> ] == 1 : <NEWLINE> <INDENT> redis . hdel ( r_adr [ <STRING> ] , kw [ <STRING> ] ) <NEWLINE> notify_test ( <STRING> , lunaport_msg , None , case = case_struct , <NEWLINE> <INDENT> tank_msg = tank_msg ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> diff = { <NEWLINE> <INDENT> <STRING> : TestStateTr . port_by_tank ( tank_msg . get ( <STRING> ) ) , <NEWLINE> <DEDENT> } <NEWLINE> t_summary = { } <NEWLINE> if tank_msg . get ( <STRING> ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> l_test_id = tank_msg [ <STRING> ] ) . json ( ) . pop ( ) <NEWLINE> t_summary . update ( { <STRING> : redis_msg [ <STRING> ] } ) <NEWLINE> diff . update ( { <NEWLINE> <STRING> : t_summary , <NEWLINE> } ) <NEWLINE> if t_summary . get ( <STRING> ) : <NEWLINE> diff . update ( { <NEWLINE> <INDENT> <STRING> : msk_iso_to_utc ( t_summary [ <STRING> ] ) . isoformat ( ) , <NEWLINE> <DEDENT> } ) <NEWLINE> <DEDENT> <DEDENT> try : <NEWLINE> <INDENT> test_struct , test_loc = lunaport_c1 . test_patch ( redis_msg [ <STRING> ] , diff ) <NEWLINE> <DEDENT> except LunaportClientError as e : <NEWLINE> <INDENT> test_struct = None <NEWLINE> logger . error ( <STRING> . format ( e ) ) <NEWLINE> if not <STRING> in str ( e ) : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> <DEDENT> redis . hdel ( r_adr [ <STRING> ] , kw [ <STRING> ] ) <NEWLINE> t_struct = test_struct or t_summary <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'test_id'", "'id'", "'Tank API call failed: {}'", "'status_code'", "'PREPARING'", "'id'", "'case_id'", "'Lunaport client call failed:{}'", "'status_code'", "'FINISHED'", "'exit_code'", "'monitor_start'", "'id'", "'on_start_failed'", "'status'", "'status_code'", "'lunapark_id'", "'lunapark_id'", "'t_tank_id'", "'t_tank_id'", "'lunapark'", "'fd'", "'started_at'", "'fd'", "'id'", "'Lunaport client call failed:{}'", "'Nothing to update'", "'monitor_start'", "'id'"]}, "window_span": [219, 236], "err_obj": {"msg": "unbalanced (){}[]"}}], ["b79a209e9c1f41163363b31f4f21a711", {"code_string": "def resizeEvent(self event):\n    super(GraphicsView, self).resizeEvent(event)\n    if self.s is not None:\n        self.s.auto_update_all_links()\n", "code_toks_joined": "def resizeEvent ( self event ) : <NEWLINE> <INDENT> super ( GraphicsView , self ) . resizeEvent ( event ) <NEWLINE> if self . s is not None : <NEWLINE> <INDENT> self . s . auto_update_all_links ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "invalid syntax"}}], ["0a5d4e72fa6abb78b46ccd8d563fe6d6", {"code_string": "def fileExists(fn):\n    \"\"\" Does a file exist?\"\"\"\n    if debug:\n        print \"fileExists(%r)\" %(fn, )\n    fn = os.path.expanduser(fn)\n    readable = os.access(fn, os.R_OK)\n    if not readable: return 0\n    mode = os.stat(fn).st_mode\n    return stat.S_ISREG(mode)\n", "code_toks_joined": "def fileExists ( fn ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if debug : <NEWLINE> <INDENT> print <STRING> % ( fn , ) <NEWLINE> <DEDENT> fn = os . path . expanduser ( fn ) <NEWLINE> readable = os . access ( fn , os . R_OK ) <NEWLINE> if not readable : return 0 <NEWLINE> mode = os . stat ( fn ) . st_mode <NEWLINE> return stat . S_ISREG ( mode ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Does a file exist?\"\"\"", "\"fileExists(%r)\""]}, "err_obj": {"msg": "invalid syntax"}}], ["c08367364199dd51718489addca2b1f2", {"code_string": "def testFailedStreamRequestStreamResponse(self):\n    for(group, method), test_messages_sequence in(\n        six.iteritems(self._digest.stream_stream_messages_sequences)):\n        for test_messages in test_messages_sequence:\n        requests = test_messages.requests()\n        with self._control.fail(), self.assertRaises(face.ExpirationError):\n            response_iterator = self._invoker.future(group, method)(\n                iter(requests), _3069_test_constant.REALLY_SHORT_TIMEOUT)\n            list(response_iterator)\n", "code_toks_joined": "def testFailedStreamRequestStreamResponse ( self ) : <NEWLINE> <INDENT> for ( group , method ) , test_messages_sequence in ( <NEWLINE> <INDENT> six . iteritems ( self . _digest . stream_stream_messages_sequences ) ) : <NEWLINE> for test_messages in test_messages_sequence : <NEWLINE> requests = test_messages . requests ( ) <NEWLINE> with self . _control . fail ( ) , self . assertRaises ( face . ExpirationError ) : <NEWLINE> <INDENT> response_iterator = self . _invoker . future ( group , method ) ( <NEWLINE> <INDENT> iter ( requests ) , _3069_test_constant . REALLY_SHORT_TIMEOUT ) <NEWLINE> <DEDENT> list ( response_iterator ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["8f5cd4b8badcd9b1d3a1e0481af20ec5", {"code_string": "def _import_bears(file_path, kinds):\n    for bear_list in iimport_objects(file_path,\n        names = '__additional_bears__',\n        types = list):\n        for bear_class in bear_list:\n        if _get_kind(bear_class) in kinds:\n        yield bear_class\n    for bear_class in iimport_objects(file_path,\n        attributes = 'kind',\n        local = True):\n        if _get_kind(bear_class) in kinds:\n        yield bear_class\n", "code_toks_joined": "def _import_bears ( file_path , kinds ) : <NEWLINE> <INDENT> for bear_list in iimport_objects ( file_path , <NEWLINE> <INDENT> names = <STRING> , <NEWLINE> types = list ) : <NEWLINE> for bear_class in bear_list : <NEWLINE> if _get_kind ( bear_class ) in kinds : <NEWLINE> yield bear_class <NEWLINE> <DEDENT> for bear_class in iimport_objects ( file_path , <NEWLINE> <INDENT> attributes = <STRING> , <NEWLINE> local = True ) : <NEWLINE> if _get_kind ( bear_class ) in kinds : <NEWLINE> yield bear_class <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'__additional_bears__'", "'kind'"]}, "err_obj": {"msg": "expected an indented block"}}], ["89d98f38d313ec9b1ec29a4d75748a5a", {"code_string": "def saveSQL(data = None, name = None):\n    if data is not None and name is not None and name.strip():\n        filename = \"syncPushSQL/%s.sql\" % name\n        try:\n            dataFile = open(filename, 'wb')\n            for row in data:\n                dataString = row.encode('ascii', 'ignore')\n                dataFile.write(dataString)\n            dataFile.close()\n        except Exception, e:\n            pass\n", "code_toks_joined": "def saveSQL ( data = None , name = None ) : <NEWLINE> <INDENT> if data is not None and name is not None and name . strip ( ) : <NEWLINE> <INDENT> filename = <STRING> % name <NEWLINE> try : <NEWLINE> <INDENT> dataFile = open ( filename , <STRING> ) <NEWLINE> for row in data : <NEWLINE> <INDENT> dataString = row . encode ( <STRING> , <STRING> ) <NEWLINE> dataFile . write ( dataString ) <NEWLINE> <DEDENT> dataFile . close ( ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"syncPushSQL/%s.sql\"", "'wb'", "'ascii'", "'ignore'"]}, "err_obj": {"msg": "invalid syntax"}}], ["58fecb88ab269e001a938eaa2ea64d68", {"code_string": "def test():\n    from subprocess import call\n    call(['nosetests', '-v',\n    ,\n        '--with-coverage', '--cover-package=app', '--cover-branches',\n        '--cover-erase', '--cover-html', '--cover-html-dir=cover'])\n", "code_toks_joined": "def test ( ) : <NEWLINE> <INDENT> from subprocess import call <NEWLINE> call ( [ <STRING> , <STRING> , <NEWLINE> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'nosetests'", "'-v'", "'--with-coverage'", "'--cover-package=app'", "'--cover-branches'", "'--cover-erase'", "'--cover-html'", "'--cover-html-dir=cover'"]}, "err_obj": {"msg": "invalid syntax"}}], ["4f456de9e1ae4670f610a862b0c9109a", {"code_string": "class SchoolMember:\n    '''any school member'''\n    def __init__(self, name, age):\n    '''initialize a school member'''\n    self.name = name\n    self.age = age\n    print(\"Initialized SchoolMember: {}\".format(self.name))\n    def tell(self):\n    '''tell details'''\n", "code_toks_joined": "class SchoolMember : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , name , age ) : <NEWLINE> <STRING> <NEWLINE> self . name = name <NEWLINE> self . age = age <NEWLINE> print ( <STRING> . format ( self . name ) ) <NEWLINE> def tell ( self ) : <NEWLINE> <STRING> <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'''any school member'''", "'''initialize a school member'''", "\"Initialized SchoolMember: {}\"", "'''tell details'''"]}, "err_obj": {"msg": "expected an indented block"}}], ["7baf5cf8872637b4efd43bb84a41e767", {"code_string": "def warn_version_mismatch():\n    equo_ver = read_client_release()\n    entropy_ver = etpConst['entropyversion']\n    if equo_ver != entropy_ver:\n        print_warning(\"\")\n        print_warning(\"%s: %s\" %(\n            bold(_(\"Entropy/Equo version mismatch\"),\n            purple(_(\"it could make your system explode!\")), ))\n        print_warning(\"(%s[equo]& %s[entropy])\" %(\n            blue(equo_ver),\n            blue(entropy_ver), ))\n        print_warning(\"\")\n", "code_toks_joined": "def warn_version_mismatch ( ) : <NEWLINE> <INDENT> equo_ver = read_client_release ( ) <NEWLINE> entropy_ver = etpConst [ <STRING> ] <NEWLINE> if equo_ver != entropy_ver : <NEWLINE> <INDENT> print_warning ( <STRING> ) <NEWLINE> print_warning ( <STRING> % ( <NEWLINE> <INDENT> bold ( _ ( <STRING> ) , <NEWLINE> purple ( _ ( <STRING> ) ) , ) ) <NEWLINE> <DEDENT> print_warning ( <STRING> % ( <NEWLINE> <INDENT> blue ( equo_ver ) , <NEWLINE> blue ( entropy_ver ) , ) ) <NEWLINE> <DEDENT> print_warning ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'entropyversion'", "\"\"", "\"%s: %s\"", "\"Entropy/Equo version mismatch\"", "\"it could make your system explode!\"", "\"(%s[equo]& %s[entropy])\"", "\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["5348549af4133344935738080f1f7f49", {"code_string": "def __init__(self, server, (sock, addr)):\n    asyncore.dispatcher_with_send.__init__(self, sock)\n    self.server = server\n    self.address = ':'.join(map(str, addr))\n    self.gpg = False\n    self.data = ''\n    self.state = 'NOAUTH'\n    self.connected = False\n", "code_toks_joined": "def __init__ ( self , server , ( sock , addr ) ) : <NEWLINE> <INDENT> asyncore . dispatcher_with_send . __init__ ( self , sock ) <NEWLINE> self . server = server <NEWLINE> self . address = <STRING> . join ( map ( str , addr ) ) <NEWLINE> self . gpg = False <NEWLINE> self . data = <STRING> <NEWLINE> self . state = <STRING> <NEWLINE> self . connected = False <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["':'", "''", "'NOAUTH'"]}, "err_obj": {"msg": "invalid syntax"}}], ["3cf484bb14a8b39a4a758d7fe1dcd981", {"code_string": "def countDays(begYear, endYear, day):\n    first = sundays = 0\n    for year in range(begYear, endYear):\n        for month in range(len(months):\n            first += getMonthLength(year, month)\n            first = first % len(daysOfWeek)\n            if year > 1900 and first == daysOfWeek[day]:\n                sundays += 1\n    return sundays\n", "code_toks_joined": "def countDays ( begYear , endYear , day ) : <NEWLINE> <INDENT> first = sundays = 0 <NEWLINE> for year in range ( begYear , endYear ) : <NEWLINE> <INDENT> for month in range ( len ( months ) : <NEWLINE> <INDENT> first += getMonthLength ( year , month ) <NEWLINE> first = first % len ( daysOfWeek ) <NEWLINE> if year > 1900 and first == daysOfWeek [ day ] : <NEWLINE> <INDENT> sundays += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return sundays <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["567d1df11fce62b8b28074d6f047852a", {"code_string": "def test_solver2(N, plot = True, version = 'scalar'):\n    s = StoreSolution()\n    s.main(N, version)\n    print('CPU time: ', s.cpu)\n    if len(s.x) < 10:\n        print s.solutions\n    if plot:\n        from CurveViz import graph\n        g = graph(program = 'Gnuplot', coor = s.x, ymax = 1, ymin = - 1)\n        for s in s.solutions:\n            g.plotcurve(s)\n", "code_toks_joined": "def test_solver2 ( N , plot = True , version = <STRING> ) : <NEWLINE> <INDENT> s = StoreSolution ( ) <NEWLINE> s . main ( N , version ) <NEWLINE> print ( <STRING> , s . cpu ) <NEWLINE> if len ( s . x ) < 10 : <NEWLINE> <INDENT> print s . solutions <NEWLINE> <DEDENT> if plot : <NEWLINE> <INDENT> from CurveViz import graph <NEWLINE> g = graph ( program = <STRING> , coor = s . x , ymax = 1 , ymin = - 1 ) <NEWLINE> for s in s . solutions : <NEWLINE> <INDENT> g . plotcurve ( s ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'scalar'", "'CPU time: '", "'Gnuplot'"]}, "err_obj": {"msg": "invalid syntax"}}], ["eec70bce869e6ae78c44d7e62aba7a2c", {"code_string": "class DateDisplayZH_TW(DateDisplay):\n    \"\"\"Traditional-Chinese language date display class.\"\"\"\n    formats = (\n        \"\u5e74\u5e74\u5e74\u5e74-\u6708\u6708-\u65e5\u65e5 (ISO)\", \"\u6578\u5b57\u683c\u5f0f\",\n        )\n    _bce_str = \"%s B.C.E.\"\n    display = DateDisplay.display_formatted\n    def _display_calendar(self, date_val, long_months, short_months = None,\n        inflect = \"\"):\n        if short_months is None:\n        short_months = long_months\n        if self.format == 0:\n        return self.display_iso(date_val)\n        else:\n        value = self.dd_dformat01(date_val)\n        if date_val[2] < 0:\n        return self._bce_str % value\n        else:\n        return value\n", "code_toks_joined": "class DateDisplayZH_TW ( DateDisplay ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> formats = ( <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> ) <NEWLINE> <DEDENT> _bce_str = <STRING> <NEWLINE> display = DateDisplay . display_formatted <NEWLINE> def _display_calendar ( self , date_val , long_months , short_months = None , <NEWLINE> <INDENT> inflect = <STRING> ) : <NEWLINE> if short_months is None : <NEWLINE> short_months = long_months <NEWLINE> if self . format == 0 : <NEWLINE> return self . display_iso ( date_val ) <NEWLINE> else : <NEWLINE> value = self . dd_dformat01 ( date_val ) <NEWLINE> if date_val [ 2 ] < 0 : <NEWLINE> return self . _bce_str % value <NEWLINE> else : <NEWLINE> return value <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Traditional-Chinese language date display class.\"\"\"", "\"\u5e74\u5e74\u5e74\u5e74-\u6708\u6708-\u65e5\u65e5 (ISO)\"", "\"\u6578\u5b57\u683c\u5f0f\"", "\"%s B.C.E.\"", "\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["e5ffe4a0e658421cab05996c289a4166", {"code_string": "def check(self, verbose = True):\n    self.share.refresh()\n    if verbose: print self.share.get_info()['symbol'] + \"\\tvol: \" + self.share.get_volume() + \"\\t\\tprice: \" + self.share.get_price() + \"\\t\\ttime: \" + self.share.get_trade_datetime()\n    return{'share': 'symbol'}\n", "code_toks_joined": "def check ( self , verbose = True ) : <NEWLINE> <INDENT> self . share . refresh ( ) <NEWLINE> if verbose : print self . share . get_info ( ) [ <STRING> ] + <STRING> + self . share . get_volume ( ) + <STRING> + self . share . get_price ( ) + <STRING> + self . share . get_trade_datetime ( ) <NEWLINE> return { <STRING> : <STRING> } <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'symbol'", "\"\\tvol: \"", "\"\\t\\tprice: \"", "\"\\t\\ttime: \"", "'share'", "'symbol'"]}, "err_obj": {"msg": "invalid syntax"}}], ["b4573b9af68283ba74d2e06d614ebb6f", {"code_string": "def _get_port_groups(self, query = None):\n    if not self.port_groups_in:\n        return[]\n    tenant_id = self._get_query_tenant_id(query)\n    self.port_groups_out = []\n    for port_group in self.port_groups_in:\n        self.port_groups_out.append(get_port_group_mock(\n            id = port_group['id'], name = port_group['name'],\n            tenant_id = tenant_id)\n    return self.port_groups_out\n", "code_toks_joined": "def _get_port_groups ( self , query = None ) : <NEWLINE> <INDENT> if not self . port_groups_in : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> tenant_id = self . _get_query_tenant_id ( query ) <NEWLINE> self . port_groups_out = [ ] <NEWLINE> for port_group in self . port_groups_in : <NEWLINE> <INDENT> self . port_groups_out . append ( get_port_group_mock ( <NEWLINE> <INDENT> id = port_group [ <STRING> ] , name = port_group [ <STRING> ] , <NEWLINE> tenant_id = tenant_id ) <NEWLINE> <DEDENT> <DEDENT> return self . port_groups_out <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'id'", "'name'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["9fb7ef0f94374eb82ebde8bb1a1dd9b3", {"code_string": "def InitUniformRegionScalarQuant(quantName, initValues):\n    global regionNameDictionary\n    Idx = 0.\n    values = []\n    for key, value in sorted(regionNameDictionary.iteritems(), key = lambda(k, v): (v, k)):\n        if initValues.has_key(key):\n            values.append(initValues[key])\n        elif key == 'empty':\n            values.append(0.)\n        else:\n            values.append(0.)\n        Idx += 1\n    setscalaruniformregion(quantName, values)\n    return\n", "code_toks_joined": "def InitUniformRegionScalarQuant ( quantName , initValues ) : <NEWLINE> <INDENT> global regionNameDictionary <NEWLINE> Idx = 0. <NEWLINE> values = [ ] <NEWLINE> for key , value in sorted ( regionNameDictionary . iteritems ( ) , key = lambda ( k , v ) : ( v , k ) ) : <NEWLINE> <INDENT> if initValues . has_key ( key ) : <NEWLINE> <INDENT> values . append ( initValues [ key ] ) <NEWLINE> <DEDENT> elif key == <STRING> : <NEWLINE> <INDENT> values . append ( 0. ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> values . append ( 0. ) <NEWLINE> <DEDENT> Idx += 1 <NEWLINE> <DEDENT> setscalaruniformregion ( quantName , values ) <NEWLINE> return <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'empty'"]}, "err_obj": {"msg": "invalid syntax"}}], ["97c45281f657b52ee4cd806133005d5a", {"code_string": "def najTarok(self):\n    return self.maxKarta(list(set([Karta(TAROK, i) for i in range(1, 23)]) - set([x for\n        x in self.padle[TAROK]])).vrednost\n", "code_toks_joined": "def najTarok ( self ) : <NEWLINE> <INDENT> return self . maxKarta ( list ( set ( [ Karta ( TAROK , i ) for i in range ( 1 , 23 ) ] ) - set ( [ x for <NEWLINE> <INDENT> x in self . padle [ TAROK ] ] ) ) . vrednost <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["87f4b0ee621c2b3af7110acd35e24f12", {"code_string": "def IPAddr(vmip):\n    for myip in net['ip_addresses']:\n        if re.match('\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}', myip) and myip != '127.0.0.1':\n    return myip\n        else:\n    return None\n", "code_toks_joined": "def IPAddr ( vmip ) : <NEWLINE> <INDENT> for myip in net [ <STRING> ] : <NEWLINE> <INDENT> if re . match ( <STRING> , myip ) and myip != <STRING> : <NEWLINE> <DEDENT> return myip <NEWLINE> <INDENT> else : <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'ip_addresses'", "'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}'", "'127.0.0.1'"]}, "err_obj": {"msg": "expected an indented block"}}], ["9745e8973d6dcb0e1574540ad128400c", {"code_string": "def test_flowgraph_page(self):\n    def callback((response, data)):\n        self.assertEqual(response.code, http.OK)\n        self.assertEqual(response.headers.getRawHeaders('Content-Type'), ['image/png'])\n    return testutil.http_get(reactor, self.url + 'flow-graph').addCallback(callback)\n", "code_toks_joined": "def test_flowgraph_page ( self ) : <NEWLINE> <INDENT> def callback ( ( response , data ) ) : <NEWLINE> <INDENT> self . assertEqual ( response . code , http . OK ) <NEWLINE> self . assertEqual ( response . headers . getRawHeaders ( <STRING> ) , [ <STRING> ] ) <NEWLINE> <DEDENT> return testutil . http_get ( reactor , self . url + <STRING> ) . addCallback ( callback ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Content-Type'", "'image/png'", "'flow-graph'"]}, "err_obj": {"msg": "invalid syntax"}}], ["d3d7e5c0744c5b05023bb1c71d25fe5d", {"code_string": "def get_course_from_git(self, gitloc, branch):\n    \"\"\"This downloads and runs the checks for importing a course in git\"\"\"\n    if not(gitloc.endswith('.git') or gitloc.startswith('http:') or\n        gitloc.startswith('https:') or gitloc.startswith('git:'))\n        return _(\"The git repo location should end with '.git', \"\n            \"and be a valid url\")\n    return self.import_mongo_course(gitloc, branch)\n", "code_toks_joined": "def get_course_from_git ( self , gitloc , branch ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not ( gitloc . endswith ( <STRING> ) or gitloc . startswith ( <STRING> ) or <NEWLINE> <INDENT> gitloc . startswith ( <STRING> ) or gitloc . startswith ( <STRING> ) ) <NEWLINE> return _ ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return self . import_mongo_course ( gitloc , branch ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"This downloads and runs the checks for importing a course in git\"\"\"", "'.git'", "'http:'", "'https:'", "'git:'", "\"The git repo location should end with '.git', \"", "\"and be a valid url\""]}, "err_obj": {"msg": "invalid syntax"}}], ["bc5d8589546c9debb1a1b7ff09ce9c65", {"code_string": "def test_input_A_dtypes():\n    A, b = create_test_A_b_rand(10, 0.5)\n    for d in[np.float16, np.float32, np.int16, np.int32, np.int64, np.complex64,\n        np.complex128, np.complex128, np.uint16, np.uint32, np.uint64]:\n        with pytest.raises(TypeError):\n        ps.solve(A.astype(d), b)\n", "code_toks_joined": "def test_input_A_dtypes ( ) : <NEWLINE> <INDENT> A , b = create_test_A_b_rand ( 10 , 0.5 ) <NEWLINE> for d in [ np . float16 , np . float32 , np . int16 , np . int32 , np . int64 , np . complex64 , <NEWLINE> <INDENT> np . complex128 , np . complex128 , np . uint16 , np . uint32 , np . uint64 ] : <NEWLINE> with pytest . raises ( TypeError ) : <NEWLINE> ps . solve ( A . astype ( d ) , b ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["6eef01de98bfe2846f7cbcb360610786", {"code_string": "def output_process(output_queue_recv):\n    X = output_queue_recv.recv()\n    while len(X) == 3:\n        coeffs, answers, small_scores = X\n        n = len(answers)\n        for i in range(n):\n            if coeffs is not None:\n                coeffs_text = [\"%g * %s\" %(c, index2word1[w]) for w, c in zip(* scipy.sparse.find(coeffs[i])[1: ])]\n                print(args.answer_tab.join(coeffs_text))\n            if small_scores is not None:\n                score_text = [(args.score_format % s) for s in small_scores[i]]\n                print(args.answer_tab.join(\n                    index2word[a] + s\n                        for a, s in zip(answers[i], score_text)\n                    )\n            else:\n                print(args.answer_tab.join(index2word[w] for w in answers[i]))\n        X = output_queue_recv.recv()\n", "code_toks_joined": "def output_process ( output_queue_recv ) : <NEWLINE> <INDENT> X = output_queue_recv . recv ( ) <NEWLINE> while len ( X ) == 3 : <NEWLINE> <INDENT> coeffs , answers , small_scores = X <NEWLINE> n = len ( answers ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if coeffs is not None : <NEWLINE> <INDENT> coeffs_text = [ <STRING> % ( c , index2word1 [ w ] ) for w , c in zip ( * scipy . sparse . find ( coeffs [ i ] ) [ 1 : ] ) ] <NEWLINE> print ( args . answer_tab . join ( coeffs_text ) ) <NEWLINE> <DEDENT> if small_scores is not None : <NEWLINE> <INDENT> score_text = [ ( args . score_format % s ) for s in small_scores [ i ] ] <NEWLINE> print ( args . answer_tab . join ( <NEWLINE> <INDENT> index2word [ a ] + s <NEWLINE> <INDENT> for a , s in zip ( answers [ i ] , score_text ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( args . answer_tab . join ( index2word [ w ] for w in answers [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> X = output_queue_recv . recv ( ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"%g * %s\""]}, "window_span": [139, 214], "err_obj": {"msg": "unbalanced (){}[]"}}], ["c9e1b18eef5151003ab235e31725eefb", {"code_string": "class StoreEmailsClass(models.Model):\n    accounts = models.ForeignKey(AddEmail)\n    def __unicode__(self):\n    return self.accounts\n", "code_toks_joined": "class StoreEmailsClass ( models . Model ) : <NEWLINE> <INDENT> accounts = models . ForeignKey ( AddEmail ) <NEWLINE> def __unicode__ ( self ) : <NEWLINE> return self . accounts <NEWLINE> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}], ["a1acb7eaa710af93e005060b47b1900a", {"code_string": "def _last_marker(f_path, l_obj):\n    \"\"\"Set Marker.\"\"\"\n    return '%s&marker=%s' %(f_path, quoter(url = l_obj)\n", "code_toks_joined": "def _last_marker ( f_path , l_obj ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return <STRING> % ( f_path , quoter ( url = l_obj ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Set Marker.\"\"\"", "'%s&marker=%s'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["3bf2eb07c5f474f288ff4fc909d7fffd", {"code_string": "def get_api_all(url, log_label = 'results'):\n    \"\"\"Get url and all subsequent API pages.\"\"\"\n    results = []\n    while url is not None:\n        req = urllib.request.Request(url,\n            headers = {'Authorization': 'Token ' + os.getenv('FUM_API_TOKEN'))})\n        with urllib.request.urlopen(req) as resp:\n            data = json.loads(resp.read().decode('utf-8'))\n        results.extend(data['results'])\n        print('got {}/{} {}'.format(len(results), data['count'], log_label),\n            flush = True)\n        url = data['next']\n    return results\n", "code_toks_joined": "def get_api_all ( url , log_label = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> results = [ ] <NEWLINE> while url is not None : <NEWLINE> <INDENT> req = urllib . request . Request ( url , <NEWLINE> <INDENT> headers = { <STRING> : <STRING> + os . getenv ( <STRING> ) ) } ) <NEWLINE> <DEDENT> with urllib . request . urlopen ( req ) as resp : <NEWLINE> <INDENT> data = json . loads ( resp . read ( ) . decode ( <STRING> ) ) <NEWLINE> <DEDENT> results . extend ( data [ <STRING> ] ) <NEWLINE> print ( <STRING> . format ( len ( results ) , data [ <STRING> ] , log_label ) , <NEWLINE> <INDENT> flush = True ) <NEWLINE> <DEDENT> url = data [ <STRING> ] <NEWLINE> <DEDENT> return results <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'results'", "\"\"\"Get url and all subsequent API pages.\"\"\"", "'Authorization'", "'Token '", "'FUM_API_TOKEN'", "'utf-8'", "'results'", "'got {}/{} {}'", "'count'", "'next'"]}, "window_span": [26, 56], "err_obj": {"msg": "unbalanced (){}[]"}}], ["1b71828dce4480a4b4d1e1725a520602", {"code_string": "def http_open(self, req):\n    response = urllib2.addinfourl(\n        StringIO(self.response_queue.popleft(),\n        'generated by MockHTTPHandler',\n        req.get_full_url(),\n    )\n    response.code = 200\n    response.msg = 'OK'\n    return response\n", "code_toks_joined": "def http_open ( self , req ) : <NEWLINE> <INDENT> response = urllib2 . addinfourl ( <NEWLINE> <INDENT> StringIO ( self . response_queue . popleft ( ) , <NEWLINE> <STRING> , <NEWLINE> req . get_full_url ( ) , <NEWLINE> <DEDENT> ) <NEWLINE> response . code = 200 <NEWLINE> response . msg = <STRING> <NEWLINE> return response <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'generated by MockHTTPHandler'", "'OK'"]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["3a92324baf3220884606fddde7cb1ae5", {"code_string": "def retrieve(self, ids):\n    \"\"\"yield wikidata entities from a list of ids. For internal use.\"\"\"\n    for batch in more_itertools.chunked(ids, 50):\n        for page in self.session.get(continuation = True,\n            action = 'wbgetentities',\n            languages = 'en',\n            ids = self.stringify_ids(batch)):\n            assert page['success'] == 1\n            for result in page['entities'].values():\n            yield result\n        time.sleep(self.DELAY)\n", "code_toks_joined": "def retrieve ( self , ids ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for batch in more_itertools . chunked ( ids , 50 ) : <NEWLINE> <INDENT> for page in self . session . get ( continuation = True , <NEWLINE> <INDENT> action = <STRING> , <NEWLINE> languages = <STRING> , <NEWLINE> ids = self . stringify_ids ( batch ) ) : <NEWLINE> assert page [ <STRING> ] == 1 <NEWLINE> for result in page [ <STRING> ] . values ( ) : <NEWLINE> yield result <NEWLINE> <DEDENT> time . sleep ( self . DELAY ) <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"yield wikidata entities from a list of ids. For internal use.\"\"\"", "'wbgetentities'", "'en'", "'success'", "'entities'"]}, "err_obj": {"msg": "expected an indented block"}}], ["b5aa3177b22e2c49fbe416ea9296d635", {"code_string": "def getRequiredAdapters(iface, withViews = False):\n    \"\"\"Get adapter registrations where the specified interface is required.\"\"\"\n    gsm = getGlobalSiteManager()\n    for meth in('registeredAdapters',\n        'registeredSubscriptionAdapters',\n        'registeredHandlers'):\n        for reg in getattr(gsm, meth)():\n        if len(reg.required) == 0:\n        continue\n        if not withViews and reg.required[- 1].isOrExtends(IRequest):\n        continue\n        for required_iface in reg.required:\n        if iface.isOrExtends(required_iface):\n            yield reg\n", "code_toks_joined": "def getRequiredAdapters ( iface , withViews = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> gsm = getGlobalSiteManager ( ) <NEWLINE> for meth in ( <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ) : <NEWLINE> for reg in getattr ( gsm , meth ) ( ) : <NEWLINE> if len ( reg . required ) == 0 : <NEWLINE> continue <NEWLINE> if not withViews and reg . required [ - 1 ] . isOrExtends ( IRequest ) : <NEWLINE> continue <NEWLINE> for required_iface in reg . required : <NEWLINE> if iface . isOrExtends ( required_iface ) : <NEWLINE> <INDENT> yield reg <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Get adapter registrations where the specified interface is required.\"\"\"", "'registeredAdapters'", "'registeredSubscriptionAdapters'", "'registeredHandlers'"]}, "err_obj": {"msg": "expected an indented block"}}], ["67ca7b7ec6baa7b07973101a86863313", {"code_string": "def OnActivate(self, event):\n    \"\"\" Activate Event for a Transcript Window \"\"\"\n    if(self.ControlObject != None) and(self.transcriptWindowNumber < len(self.ControlObject.TranscriptWindow)):\n        self.ControlObject.activeTranscript = self.transcriptWindowNumber\n    elif(self.ControlObject != None) and(self.ControlObject.activeTranscript >= len(self.ControlObject.TranscriptWindow):\n        self.ControlObject.activeTranscript = 0\n    event.Skip()\n", "code_toks_joined": "def OnActivate ( self , event ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( self . ControlObject != None ) and ( self . transcriptWindowNumber < len ( self . ControlObject . TranscriptWindow ) ) : <NEWLINE> <INDENT> self . ControlObject . activeTranscript = self . transcriptWindowNumber <NEWLINE> <DEDENT> elif ( self . ControlObject != None ) and ( self . ControlObject . activeTranscript >= len ( self . ControlObject . TranscriptWindow ) : <NEWLINE> <INDENT> self . ControlObject . activeTranscript = 0 <NEWLINE> <DEDENT> event . Skip ( ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\" Activate Event for a Transcript Window \"\"\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["73947713ee27120de921939d169862e1", {"code_string": "def show(request):\n    if off:\n        return HttpResponse(\"<h1>\u7f51\u7ad9\u6682\u505c\u4f7f\u7528, \u9879\u76ee <a href=\\\"http://tofind.space/NCspider/\\\">Github \u4e3b\u9875</a> </h1>\")\n    delta = datetime.timedelta(days = 2)\n    hot_sina_news = sina_article.objects.filter(put_time__gte = datetime.date.today() - delta).exclude(title__isnull = True).exclude(title__exact = '').order_by('-comments_number')[: 20]\n    hot_tencent_news = tencent_article.objects.filter(put_time__gte = datetime.date.today() - delta).exclude(title__isnull = True).exclude(title__exact = '').order_by('-comments_number')[: 20]\n    hot_sohu_news = sohu_article.objects.filter(put_time__gte = datetime.date.today() - delta).exclude(title__isnull = True).exclude(title__exact = '').order_by('-comments_number')[: 20]\n    return render(request, 'news_opin/hot_news.html',\n        {\n            'hot_sina_news': hot_sina_news,\n            'hot_tencent_news': hot_tencent_news,\n            'hot_sohu_news': hot_sohu_news,\n        }\n", "code_toks_joined": "def show ( request ) : <NEWLINE> <INDENT> if off : <NEWLINE> <INDENT> return HttpResponse ( <STRING> ) <NEWLINE> <DEDENT> delta = datetime . timedelta ( days = 2 ) <NEWLINE> hot_sina_news = sina_article . objects . filter ( put_time__gte = datetime . date . today ( ) - delta ) . exclude ( title__isnull = True ) . exclude ( title__exact = <STRING> ) . order_by ( <STRING> ) [ : 20 ] <NEWLINE> hot_tencent_news = tencent_article . objects . filter ( put_time__gte = datetime . date . today ( ) - delta ) . exclude ( title__isnull = True ) . exclude ( title__exact = <STRING> ) . order_by ( <STRING> ) [ : 20 ] <NEWLINE> hot_sohu_news = sohu_article . objects . filter ( put_time__gte = datetime . date . today ( ) - delta ) . exclude ( title__isnull = True ) . exclude ( title__exact = <STRING> ) . order_by ( <STRING> ) [ : 20 ] <NEWLINE> return render ( request , <STRING> , <NEWLINE> <INDENT> { <NEWLINE> <INDENT> <STRING> : hot_sina_news , <NEWLINE> <STRING> : hot_tencent_news , <NEWLINE> <STRING> : hot_sohu_news , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"<h1>\u7f51\u7ad9\u6682\u505c\u4f7f\u7528, \u9879\u76ee <a href=\\\"http://tofind.space/NCspider/\\\">Github \u4e3b\u9875</a> </h1>\"", "''", "'-comments_number'", "''", "'-comments_number'", "''", "'-comments_number'", "'news_opin/hot_news.html'", "'hot_sina_news'", "'hot_tencent_news'", "'hot_sohu_news'"]}, "window_span": [165, 195], "err_obj": {"msg": "unbalanced (){}[]"}}], ["679b977d0c8ad1a7b1213727b666813a", {"code_string": "a = int(input('Ingrese un numero'))\nb = int(input('Ingrese un numero'))\nif(a + b == 0)\n    print: (\"cero\")\nif(a + b < 0)\n    print: (\"negativo\")\nif(a + b > 0)\n    print: (\"positivo\")\n", "code_toks_joined": "a = int ( input ( <STRING> ) ) <NEWLINE> b = int ( input ( <STRING> ) ) <NEWLINE> if ( a + b == 0 ) <NEWLINE> <INDENT> print : ( <STRING> ) <NEWLINE> <DEDENT> if ( a + b < 0 ) <NEWLINE> <INDENT> print : ( <STRING> ) <NEWLINE> <DEDENT> if ( a + b > 0 ) <NEWLINE> <INDENT> print : ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Ingrese un numero'", "'Ingrese un numero'", "\"cero\"", "\"negativo\"", "\"positivo\""]}, "err_obj": {"msg": "invalid syntax"}}], ["3c4f05ed78ea599863e7e86975612e1e", {"code_string": "def launchChrome(self url, title):\n    action = 'RunPlugin(%s)' %('plugin://plugin.program.chrome.launcher/?kiosk=yes&mode=showSite&stopPlayback=yes&url=' + url)\n    common.log('chrome test:' + str(action))\n    xbmc.executebuiltin(action)\n", "code_toks_joined": "def launchChrome ( self url , title ) : <NEWLINE> <INDENT> action = <STRING> % ( <STRING> + url ) <NEWLINE> common . log ( <STRING> + str ( action ) ) <NEWLINE> xbmc . executebuiltin ( action ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'RunPlugin(%s)'", "'plugin://plugin.program.chrome.launcher/?kiosk=yes&mode=showSite&stopPlayback=yes&url='", "'chrome test:'"]}, "err_obj": {"msg": "invalid syntax"}}], ["3dff15ccee9c026ee2ad48bbd911dafa", {"code_string": "import Levenshtein\nimport random\nexecuted_set = []\ntestcase_obj = open('test2.txt')\ntestcase_list = testcase_obj.readlines()\ni = 0\ninit_num = random.randint(1, 78000)\nexecuted_set.append(init_num)\nwhile i < 20:\n    candidate_set = []\n    j = 0\n    while j < 10:\n        j = j + 1\n        candidates = random.randint(1, 70000)\n        while candidates in executed_set:\n            candidates = random.randint(1, 70000)\n        candidate_set.append(candidates)\n    Sim_set = []\n    max_dis = - 1\n    max_code = - 1\n    for code in candidate_set:\n        temp_set = []\n        for elem in executed_set:\n            temp_set.append(Levenshtein.distance(testcase_list[code], testcase_list[elem])\n", "code_toks_joined": "import Levenshtein <NEWLINE> import random <NEWLINE> executed_set = [ ] <NEWLINE> testcase_obj = open ( <STRING> ) <NEWLINE> testcase_list = testcase_obj . readlines ( ) <NEWLINE> i = 0 <NEWLINE> init_num = random . randint ( 1 , 78000 ) <NEWLINE> executed_set . append ( init_num ) <NEWLINE> while i < 20 : <NEWLINE> <INDENT> candidate_set = [ ] <NEWLINE> j = 0 <NEWLINE> while j < 10 : <NEWLINE> <INDENT> j = j + 1 <NEWLINE> candidates = random . randint ( 1 , 70000 ) <NEWLINE> while candidates in executed_set : <NEWLINE> <INDENT> candidates = random . randint ( 1 , 70000 ) <NEWLINE> <DEDENT> candidate_set . append ( candidates ) <NEWLINE> <DEDENT> Sim_set = [ ] <NEWLINE> max_dis = - 1 <NEWLINE> max_code = - 1 <NEWLINE> for code in candidate_set : <NEWLINE> <INDENT> temp_set = [ ] <NEWLINE> for elem in executed_set : <NEWLINE> <INDENT> temp_set . append ( Levenshtein . distance ( testcase_list [ code ] , testcase_list [ elem ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>", "anonymize_dict": {"<STRING>": ["'test2.txt'"]}, "window_span": [152, 171], "err_obj": {"msg": "unbalanced (){}[]"}}], ["a96cd0bdb98a82e30903068b6fca6f17", {"code_string": "def creds_dialog(creds):\n    \"\"\"Thread safe wrapper for libvirt openAuth user/pass callback\"\"\"\n    retipc = []\n    def wrapper(fn creds):\n        try:\n            ret = fn(creds)\n        except:\n            logging.exception(\"Error from creds dialog\")\n            ret = - 1\n        retipc.append(ret)\n    GLib.idle_add(wrapper, creds_dialog_main, creds)\n    while not retipc:\n        time.sleep(.1)\n    return retipc[0]\n", "code_toks_joined": "def creds_dialog ( creds ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> retipc = [ ] <NEWLINE> def wrapper ( fn creds ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ret = fn ( creds ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> logging . exception ( <STRING> ) <NEWLINE> ret = - 1 <NEWLINE> <DEDENT> retipc . append ( ret ) <NEWLINE> <DEDENT> GLib . idle_add ( wrapper , creds_dialog_main , creds ) <NEWLINE> while not retipc : <NEWLINE> <INDENT> time . sleep ( .1 ) <NEWLINE> <DEDENT> return retipc [ 0 ] <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Thread safe wrapper for libvirt openAuth user/pass callback\"\"\"", "\"Error from creds dialog\""]}, "err_obj": {"msg": "invalid syntax"}}], ["29d58a846a5741e040b2135c9b5db36b", {"code_string": "def _orphaned_files(self):\n    \"\"\"Returns a list of files which aren't referenced by any adjusted images\"\"\"\n    base_dir = getattr(\n        settings, 'DAGUERRE_ADJUSTED_IMAGE_PATH',\n        DEFAULT_ADJUSTED_IMAGE_PATH)\n    known_paths = set(\n        AdjustedImage.objects.values_list('adjusted', flat = True).distinct()\n    )\n    orphans = []\n    for dirpath, dirnames, filenames in self._walk(\n        base_dir, topdown = False):\n        for filename in filenames:\n        filepath = os.path.join(dirpath, filename)\n        if filepath not in known_paths:\n            orphans.append(filepath)\n    return orphans\n", "code_toks_joined": "def _orphaned_files ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> base_dir = getattr ( <NEWLINE> <INDENT> settings , <STRING> , <NEWLINE> DEFAULT_ADJUSTED_IMAGE_PATH ) <NEWLINE> <DEDENT> known_paths = set ( <NEWLINE> <INDENT> AdjustedImage . objects . values_list ( <STRING> , flat = True ) . distinct ( ) <NEWLINE> <DEDENT> ) <NEWLINE> orphans = [ ] <NEWLINE> for dirpath , dirnames , filenames in self . _walk ( <NEWLINE> <INDENT> base_dir , topdown = False ) : <NEWLINE> for filename in filenames : <NEWLINE> filepath = os . path . join ( dirpath , filename ) <NEWLINE> if filepath not in known_paths : <NEWLINE> <INDENT> orphans . append ( filepath ) <NEWLINE> <DEDENT> <DEDENT> return orphans <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Returns a list of files which aren't referenced by any adjusted images\"\"\"", "'DAGUERRE_ADJUSTED_IMAGE_PATH'", "'adjusted'"]}, "err_obj": {"msg": "expected an indented block"}}], ["d137f7a9b34f2d8650da9bbd5ddcc9f0", {"code_string": "def canFindBuiltinHeaders(index, args = []):\n    flags = 0\n    currentFile = (\"test.c\", '#include \"stddef.h\"')\n    try:\n        tu = index.parse(\"test.c\", args, [currentFile], flags)\n    except TranslationUnitLoadError, e:\n        return 0\n    return len(tu.diagnostics) == 0\n", "code_toks_joined": "def canFindBuiltinHeaders ( index , args = [ ] ) : <NEWLINE> <INDENT> flags = 0 <NEWLINE> currentFile = ( <STRING> , <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> tu = index . parse ( <STRING> , args , [ currentFile ] , flags ) <NEWLINE> <DEDENT> except TranslationUnitLoadError , e : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return len ( tu . diagnostics ) == 0 <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"test.c\"", "'#include \"stddef.h\"'", "\"test.c\""]}, "err_obj": {"msg": "invalid syntax"}}], ["590b342767eaad669c8bce875d5f7384", {"code_string": "def testKnownValues(self):\n    \"\"\"soundex should give known result with known input\"\"\"\n    for name, result in self.knownValues:\n    self.assertEqual(soundex.soundex(name), result)\n", "code_toks_joined": "def testKnownValues ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for name , result in self . knownValues : <NEWLINE> self . assertEqual ( soundex . soundex ( name ) , result ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"soundex should give known result with known input\"\"\""]}, "err_obj": {"msg": "expected an indented block"}}], ["23f9c5f465c8bcac856c70ca99843fcd", {"code_string": "def filter_python_develop(line):\n    if not line.strip():\n        return Logger.DEBUG\n    for prefix in['Searching for', 'Reading ', 'Best match: ', 'Processing ',\n        'Moving ', 'Adding ', 'running ', 'writing ', 'Creating ',\n        'creating ', 'Copying ']:\n        if line.startswith(prefix):\n        return Logger.DEBUG\n    return Logger.NOTIFY\n", "code_toks_joined": "def filter_python_develop ( line ) : <NEWLINE> <INDENT> if not line . strip ( ) : <NEWLINE> <INDENT> return Logger . DEBUG <NEWLINE> <DEDENT> for prefix in [ <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> ] : <NEWLINE> if line . startswith ( prefix ) : <NEWLINE> return Logger . DEBUG <NEWLINE> <DEDENT> return Logger . NOTIFY <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["'Searching for'", "'Reading '", "'Best match: '", "'Processing '", "'Moving '", "'Adding '", "'running '", "'writing '", "'Creating '", "'creating '", "'Copying '"]}, "err_obj": {"msg": "expected an indented block"}}], ["d45ef87acfd718f8535ba8b9439adaf7", {"code_string": "def set_distro(self, distro_name):\n    \"\"\"Sets the distro.This must be the name of an existing\"\"\"\n    d = self.config.distros().find(name = distro_name)\n    if d is not None:\n        self.distro = distro_name\n        self.depth = d.depth + 1\n        return True\n    raise CX(_(\"distribution not found\")\n", "code_toks_joined": "def set_distro ( self , distro_name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> d = self . config . distros ( ) . find ( name = distro_name ) <NEWLINE> if d is not None : <NEWLINE> <INDENT> self . distro = distro_name <NEWLINE> self . depth = d . depth + 1 <NEWLINE> return True <NEWLINE> <DEDENT> raise CX ( _ ( <STRING> ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Sets the distro.This must be the name of an existing\"\"\"", "\"distribution not found\""]}, "err_obj": {"msg": "unbalanced (){}[]"}}], ["fc4e834573c2e285367d092aa5a6b4ee", {"code_string": "def spdiags(data, diags, m, n, format = None)\n    \"\"\"Return a sparse matrix from diagonals.\"\"\"\n    return dia_matrix((data, diags), shape = (m, n)).asformat(format)\n", "code_toks_joined": "def spdiags ( data , diags , m , n , format = None ) <NEWLINE> <INDENT> <STRING> <NEWLINE> return dia_matrix ( ( data , diags ) , shape = ( m , n ) ) . asformat ( format ) <NEWLINE> <DEDENT>", "anonymize_dict": {"<STRING>": ["\"\"\"Return a sparse matrix from diagonals.\"\"\""]}, "err_obj": {"msg": "invalid syntax"}}], ["78876e54af584d5c9ba3f657afd028e9", {"code_string": "def match(self, entry):\n    if self.neg:\n        for f in entry.keys():\n        field = entry[f]\n        if field.match(self.__test) is not None:\n            return 0\n        return 1\n    else:\n        for f in entry.keys():\n        field = entry[f]\n        if field.match(self.__test) is not None:\n            return 1\n        return 0\n", "code_toks_joined": "def match ( self , entry ) : <NEWLINE> <INDENT> if self . neg : <NEWLINE> <INDENT> for f in entry . keys ( ) : <NEWLINE> field = entry [ f ] <NEWLINE> if field . match ( self . __test ) is not None : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for f in entry . keys ( ) : <NEWLINE> field = entry [ f ] <NEWLINE> if field . match ( self . __test ) is not None : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT> <DEDENT>", "anonymize_dict": {}, "err_obj": {"msg": "expected an indented block"}}]]