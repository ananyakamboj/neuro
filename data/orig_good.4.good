def expand_2d_path ( self , path ) : <NEWLINE> <INDENT> expanded_paths = { <NEWLINE> <INDENT> self . HH : <STRING> , <NEWLINE> self . HL : <STRING> , <NEWLINE> self . LH : <STRING> , <NEWLINE> self . LL : <STRING> <NEWLINE> <DEDENT> } <NEWLINE> return ( <STRING> . join ( [ expanded_paths [ p ] [ 0 ] for p in path ] ) , <NEWLINE> <INDENT> <STRING> . join ( [ expanded_paths [ p ] [ 1 ] for p in path ] ) ) <NEWLINE> <DEDENT> <DEDENT>
def test_norm_spherical ( self ) : <NEWLINE> <INDENT> norm_s = self . spherical . norm ( ) <NEWLINE> assert isinstance ( norm_s , u . Quantity ) <NEWLINE> assert norm_s . dtype . kind == <STRING> <NEWLINE> assert np . all ( norm_s == self . distance ) <NEWLINE> <DEDENT>
from django . conf . urls import include , url <NEWLINE> from django . views . generic import RedirectView <NEWLINE> from dashboard . views . account import SignupView <NEWLINE> urlpatterns = [ <NEWLINE> <INDENT> url ( <STRING> , SignupView . as_view ( ) , name = <STRING> ) , <NEWLINE> url ( <STRING> , RedirectView . as_view ( url = <STRING> , permanent = False ) , name = <STRING> ) , <NEWLINE> url ( <STRING> , include ( <STRING> ) ) , <NEWLINE> url ( <STRING> , include ( <STRING> , namespace = <STRING> ) ) <NEWLINE> <DEDENT> ] <NEWLINE>
def test_cf_errand_manifest_has_cf_cli_package ( self ) : <NEWLINE> <INDENT> for manifest in glob . glob ( <STRING> ) : <NEWLINE> <INDENT> if not manifest . startswith ( <STRING> ) : <NEWLINE> <INDENT> self . assertTrue ( <STRING> in read_yaml ( manifest ) . get ( <STRING> , [ ] ) , manifest ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> st = [ ] <NEWLINE> res = [ - 1 ] * n <NEWLINE> for i , a in enumerate ( arr ) : <NEWLINE> <INDENT> while st and st [ - 1 ] [ 1 ] < a : <NEWLINE> <INDENT> res [ st . pop ( ) [ 0 ] ] = i <NEWLINE> <DEDENT> st . append ( ( i , a ) ) <NEWLINE> <DEDENT> print ( * res ) <NEWLINE>
def __init__ ( self , _self = cmd ) : <NEWLINE> <INDENT> Wizard . __init__ ( self , _self ) <NEWLINE> for a in self . get_prompt ( ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
class ContactForm ( AbstractContactForm ) : <NEWLINE> <INDENT> sender = forms . CharField ( <NEWLINE> <INDENT> help_text = _ ( <STRING> ) , <NEWLINE> validators = [ EmailValidator ] <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def fetchResourceData ( dataset_id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> d = Dataset ( dataset_id ) <NEWLINE> d . info ( ) <NEWLINE> resources = d . resources ( ) <NEWLINE> resource_data = [ ] <NEWLINE> for resource in resources : <NEWLINE> <INDENT> data = { k : Resource ( resource ) . info ( ) [ k ] for k in _fields ( config , <STRING> ) } <NEWLINE> resource_data . append ( data ) <NEWLINE> <DEDENT> return resource_data <NEWLINE> <DEDENT>
def test_callpairorbetter_fold_preflop ( ) : <NEWLINE> <INDENT> table = Table ( ) <NEWLINE> num_players = 3 <NEWLINE> for i in xrange ( num_players ) : <NEWLINE> <INDENT> player = Player ( 10 , <STRING> ) <NEWLINE> player . sit ( table , i ) <NEWLINE> <DEDENT> table . initialize_hand ( ) <NEWLINE> table . players [ 0 ] . hole_cards . append ( Card ( <STRING> , 10 ) ) <NEWLINE> table . players [ 0 ] . hole_cards . append ( Card ( <STRING> , 9 ) ) <NEWLINE> assert table . players [ 0 ] . decide ( ) == Decision . FOLD <NEWLINE> <DEDENT>
def create_client ( self ) : <NEWLINE> <INDENT> c = super ( CinderV2TestCase , self ) . create_client ( ) <NEWLINE> self . assertIsInstance ( c , cinder_client_v2 . Client ) <NEWLINE> return c <NEWLINE> <DEDENT>
import settings <NEWLINE> import pika <NEWLINE> import tweepy <NEWLINE> import json <NEWLINE> import jinja2 <NEWLINE>
def test_search_top ( self ) : <NEWLINE> <INDENT> results = self . db . search ( <STRING> , top = True ) <NEWLINE> self . assertEqual ( len ( results ) , 1 ) <NEWLINE> <DEDENT>
def install ( self ) : <NEWLINE> <INDENT> lg . info ( <STRING> ) <NEWLINE> self . _hwdb = self . resolve ( pyhwdb ) <NEWLINE> self . _hwdb . incall ( <STRING> ) <NEWLINE> self . post_callback ( 1 , self . insert ) <NEWLINE> pass <NEWLINE> <DEDENT>
def dummy_loss ( gan_model , add_summaries = True ) : <NEWLINE> <INDENT> return math_ops . reduce_sum ( gan_model . discriminator_real_outputs - <NEWLINE> <INDENT> gan_model . discriminator_gen_outputs ) <NEWLINE> <DEDENT> <DEDENT>
class Local ( Common ) : <NEWLINE> <INDENT> DEBUG = values . BooleanValue ( True ) <NEWLINE> TEMPLATE_DEBUG = DEBUG <NEWLINE> INSTALLED_APPS = Common . INSTALLED_APPS <NEWLINE> EMAIL_HOST = <STRING> <NEWLINE> EMAIL_PORT = 1025 <NEWLINE> EMAIL_BACKEND = values . Value ( <STRING> ) <NEWLINE> MIDDLEWARE_CLASSES = Common . MIDDLEWARE_CLASSES + ( <STRING> , ) <NEWLINE> INSTALLED_APPS += ( <STRING> , ) <NEWLINE> DEBUG_TOOLBAR_PATCH_SETTINGS = False <NEWLINE> INTERNAL_IPS = ( <STRING> , ) <NEWLINE> DEBUG_TOOLBAR_CONFIG = { <NEWLINE> <INDENT> <STRING> : [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <DEDENT> ] , <NEWLINE> <STRING> : True , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>
from ipp_macro_series_parser . demographie . parser import ( <NEWLINE> <INDENT> create_demographie_data_frame <NEWLINE> ) <NEWLINE> <DEDENT>
class ISession ( zope . interface . Interface ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def update_video ( bcvideo ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> <DEDENT>
def flush ( self , obj ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> object_uuid = LENSE . OBJECTS . getattr ( obj , <STRING> ) <NEWLINE> if not object_uuid : <NEWLINE> <INDENT> self . log ( <STRING> , level = <STRING> , method = <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> self . model . objects . filter ( object_uuid = object_uuid ) . delete ( ) <NEWLINE> self . log ( <STRING> . format ( repr ( obj ) ) , level = <STRING> , method = <STRING> ) <NEWLINE> <DEDENT>
class DNSException ( Exception ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> pass <NEWLINE> <DEDENT>
def _wait_for_port ( self ) : <NEWLINE> <INDENT> sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) <NEWLINE> while sock . connect_ex ( ( self . listen_ip , self . port ) ) != 0 : <NEWLINE> <INDENT> sleep ( .1 ) <NEWLINE> <DEDENT> sleep ( .5 ) <NEWLINE> del sock <NEWLINE> <DEDENT>
def evolve ( context ) : <NEWLINE> <INDENT> if getattr ( context , <STRING> , None ) is None : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> context . events = SiteEvents ( ) <NEWLINE> <DEDENT> for tag_id , tag_obj in context . tags . _tagid_to_obj . items ( ) : <NEWLINE> <INDENT> tag_obj . _id = tag_id <NEWLINE> <DEDENT> for gen , index , mapping in context . events : <NEWLINE> <INDENT> if <STRING> not in mapping : <NEWLINE> <INDENT> profile_url = <STRING> . join ( mapping [ <STRING> ] . split ( <STRING> ) [ : - 1 ] ) <NEWLINE> mapping [ <STRING> ] = profile_url <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class String ( FieldType ) : <NEWLINE> <INDENT> def coerce ( self , obj , attr , value ) : <NEWLINE> <INDENT> if isinstance ( value , ( basestring , int , long , float , <NEWLINE> <INDENT> datetime . datetime ) ) : <NEWLINE> return unicode ( value ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise ValueError ( _ ( <STRING> ) , <NEWLINE> <INDENT> value . __class__ . __name__ ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def purpose ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> and_ = <STRING> <NEWLINE> @ one_of_the_brightest ( features , of , Python ) <NEWLINE> def are_decorators ( syntax ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import wx <NEWLINE> from pyResMan . Dialogs . pyResManDialog import pyResManDialog <NEWLINE>
import decimal <NEWLINE> import re <NEWLINE> import csv <NEWLINE>
def moveBatUp ( bat_x , bat_y , bat_z ) : <NEWLINE> <INDENT> if ( bat_y - 1 < bottom ) : <NEWLINE> <INDENT> bat_y = bottom + 1 <NEWLINE> <DEDENT> if ( bat_y + 1 > top ) : <NEWLINE> <INDENT> bat_y = top - 1 <NEWLINE> <DEDENT> mc . setBlocks ( bat_x , bat_y - 1 , bat_z , bat_x , bat_y + 1 , bat_z , block . WOOL . id , 2 ) <NEWLINE> mc . setBlock ( bat_x , bat_y - 2 , bat_z , block . WOOL . id , 15 ) <NEWLINE> <DEDENT>
def performOauthDance ( auth ) : <NEWLINE> <INDENT> print ( <STRING> , auth . get_authorization_url ( ) ) <NEWLINE> verifier = input ( <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> auth . get_access_token ( verifier ) <NEWLINE> print ( <STRING> . join ( [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> % auth . access_token , <NEWLINE> <STRING> % auth . access_token_secret ] ) ) <NEWLINE> <DEDENT> <DEDENT> except tweepy . TweepError : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def testSubsampleFourByFour ( self ) : <NEWLINE> <INDENT> x = array_ops . reshape ( math_ops . to_float ( math_ops . range ( 16 ) ) , [ 1 , 4 , 4 , 1 ] ) <NEWLINE> x = resnet_utils . subsample ( x , 2 ) <NEWLINE> expected = array_ops . reshape ( <NEWLINE> <INDENT> constant_op . constant ( [ 0 , 2 , 8 , 10 ] ) , [ 1 , 2 , 2 , 1 ] ) <NEWLINE> <DEDENT> with self . test_session ( ) : <NEWLINE> <INDENT> self . assertAllClose ( x . eval ( ) , expected . eval ( ) ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import os <NEWLINE> from sys import exit <NEWLINE> from subprocess import check_call <NEWLINE> try : <NEWLINE> <INDENT> import dotenv <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT>
def test_deferred_class_factory ( self ) : <NEWLINE> <INDENT> from django . db . models . query_utils import deferred_class_factory <NEWLINE> new_class = deferred_class_factory ( Item , <NEWLINE> <INDENT> ( <STRING> , ) ) <NEWLINE> <DEDENT> self . assertEqual ( new_class . __name__ , <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import datetime <NEWLINE> from helpers import unittest <NEWLINE> import luigi <NEWLINE> from luigi . parameter import DateIntervalParameter as DI <NEWLINE>
def get_filter6 ( self , dir ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> result = [ ] <NEWLINE> for i in self . ip : <NEWLINE> <INDENT> if Util . verify_ip6net ( i ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> result . append ( <STRING> ) <NEWLINE> <DEDENT> elif i != <STRING> : <NEWLINE> <INDENT> result . append ( <STRING> % ( dir , i ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return result <NEWLINE> <DEDENT>
class DetailsModel ( models . Model ) : <NEWLINE> <INDENT> details = models . CharField ( verbose_name = _ ( <STRING> ) , max_length = 64 , blank = True , null = True ) <NEWLINE> class Meta : <NEWLINE> <INDENT> abstract = True <NEWLINE> <DEDENT> <DEDENT>
def getOrganism ( ) : <NEWLINE> <INDENT> baseUrl = <STRING> <NEWLINE> req = urllib2 . Request ( baseUrl ) <NEWLINE> response = urllib2 . urlopen ( req ) <NEWLINE> organism_infos = response . read ( ) . split ( <STRING> ) <NEWLINE> for organism_info in organism_infos : <NEWLINE> <INDENT> info_list = organism_info . split ( <STRING> ) <NEWLINE> print ( info_list ) <NEWLINE> print ( <STRING> % info_list [ 1 ] ) <NEWLINE> save_organism_info_to_db ( info_list ) <NEWLINE> <DEDENT> <DEDENT>
def _collapse ( self ) : <NEWLINE> <INDENT> self . resize ( self . startwidth , self . parent ( ) . height ( ) ) <NEWLINE> self . move ( self . parent ( ) . width ( ) - self . startwidth , 0 ) <NEWLINE> self . expaned = False <NEWLINE> <DEDENT>
import factory <NEWLINE> from models import Classgroup , Message , Resource <NEWLINE> from django . contrib . auth . models import User <NEWLINE> from django . contrib . auth . hashers import make_password <NEWLINE>
def CIlevel ( redshiftGrid , PDF , fraction , numlevels = 200 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> evidence = np . trapz ( PDF , redshiftGrid ) <NEWLINE> for level in np . linspace ( 0 , PDF . max ( ) , num = numlevels ) : <NEWLINE> <INDENT> ind = np . where ( PDF <= level ) <NEWLINE> resint = np . trapz ( PDF [ ind ] , redshiftGrid [ ind ] ) <NEWLINE> if resint >= fraction * evidence : <NEWLINE> <INDENT> return level <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class Degree ( models . Model ) : <NEWLINE> <INDENT> name = models . CharField ( max_length = 255 ) <NEWLINE> def __str__ ( self ) : <NEWLINE> <INDENT> return self . name <NEWLINE> <DEDENT> <DEDENT>
class userProfile ( models . Model ) : <NEWLINE> <INDENT> user = models . OneToOneField ( settings . AUTH_USER_MODEL ) <NEWLINE> bio = models . CharField ( max_length = 200 ) <NEWLINE> <DEDENT>
def __init__ ( self , conc_level , n_req ) : <NEWLINE> <INDENT> self . conc_level = conc_level <NEWLINE> self . n_req = n_req <NEWLINE> <DEDENT>
def passes ( out , err ) : <NEWLINE> <INDENT> return all ( <NEWLINE> <INDENT> [ th . reads ( err , <STRING> ) , <NEWLINE> <INDENT> th . writes ( err , <STRING> ) , <NEWLINE> th . count_writes ( err , 1 ) , <NEWLINE> th . reads ( err , <STRING> ) , <NEWLINE> th . reads ( err , <STRING> ) , <NEWLINE> th . reads ( err , <STRING> ) , <NEWLINE> ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def __init__ ( self ) : <NEWLINE> <INDENT> super ( PowerOn , self ) . __init__ ( ) <NEWLINE> self . name = <STRING> <NEWLINE> self . summary = <STRING> <NEWLINE> self . description = <STRING> <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from __future__ import print_function <NEWLINE> from builtins import range <NEWLINE> from untwisted . network import core , Spin , xmap <NEWLINE> from untwisted . iostd import Client , lose , CONNECT , CONNECT_ERR <NEWLINE> from untwisted . task import Task , DONE <NEWLINE> from untwisted . network import die <NEWLINE>
def getCharPositionInLine ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . charPositionInLine <NEWLINE> <DEDENT>
class Upgrader ( upgrade . Upgrader ) : <NEWLINE> <INDENT> def upgrade_2_0_to_3_0 ( self , tools , address ) : <NEWLINE> <INDENT> root = tools . root ( address ) <NEWLINE> root . get_node ( 2 ) . erase ( ) <NEWLINE> root . ensure_node ( 1 , 1 , 255 , 7 ) . set_data ( piw . makelong ( 1 , 0 ) ) <NEWLINE> tools . substitute_connection ( paths . makeid_list ( address , 2 ) , paths . makeid_list ( address , 2 , 1 ) ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import os <NEWLINE> os . environ . setdefault ( <STRING> , <STRING> ) <NEWLINE> import alumni . startup as startup <NEWLINE> startup . run ( ) <NEWLINE> from django . core . wsgi import get_wsgi_application <NEWLINE> application = get_wsgi_application ( ) <NEWLINE>
<STRING> <NEWLINE> import md5 <NEWLINE> import random <NEWLINE> from twisted . cred . error import Unauthorized <NEWLINE>
from pygccxml import declarations <NEWLINE> g_value_type_cache = { } <NEWLINE> g_top_parent = None <NEWLINE>
class PhotosView ( GalleryUtils ) : <NEWLINE> <INDENT> def __init__ ( self , app ) : <NEWLINE> <INDENT> self . app = app <NEWLINE> <DEDENT> def get_first_photo_in_photos_view ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . select_many_retry ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> objectName = <STRING> ) [ 0 ] <NEWLINE> <DEDENT> <DEDENT> def number_of_photos ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> photo_delegates = self . app . select_many ( <STRING> , <NEWLINE> <INDENT> objectName = <STRING> ) <NEWLINE> <DEDENT> return len ( photo_delegates ) <NEWLINE> <DEDENT> <DEDENT>
def _send_data ( self , exit_code , data ) : <NEWLINE> <INDENT> message = { <NEWLINE> <INDENT> <STRING> : exit_code == 0 , <NEWLINE> <STRING> : str ( data ) if data else <STRING> <NEWLINE> <DEDENT> } <NEWLINE> pickled_message = pickle . dumps ( message ) <NEWLINE> self . request . sendall ( pickled_message ) <NEWLINE> <DEDENT>
from django . conf . urls import url , include <NEWLINE> from . views import * <NEWLINE> urlpatterns = [ <NEWLINE> <INDENT> url ( <STRING> , DateListView . as_view ( ) , name = <STRING> ) , <NEWLINE> url ( <STRING> , DateDetailView . as_view ( ) , name = <STRING> ) , <NEWLINE> url ( <STRING> , include ( <STRING> , namespace = <STRING> ) ) , <NEWLINE> <DEDENT> ] <NEWLINE>
class clv_document_question_answer ( osv . osv ) : <NEWLINE> <INDENT> _name = <STRING> <NEWLINE> _columns = { <NEWLINE> <INDENT> <STRING> : fields . char ( size = 256 , <NEWLINE> <INDENT> string = <STRING> , required = True , <NEWLINE> help = <STRING> ) , <NEWLINE> <DEDENT> <STRING> : fields . text ( string = <STRING> ) , <NEWLINE> <STRING> : fields . text ( string = <STRING> ) , <NEWLINE> <STRING> : fields . boolean ( <STRING> , <NEWLINE> <INDENT> help = <STRING> ) , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> _defaults = { <NEWLINE> <INDENT> <STRING> : 1 , <NEWLINE> } <NEWLINE> <DEDENT> <DEDENT>
def create ( cls , schema , name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> fn = cls . tags . get ( name ) <NEWLINE> if fn is not None : <NEWLINE> <INDENT> return fn ( schema , name ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return XBuiltin ( schema , name ) <NEWLINE> <DEDENT> <DEDENT>
from __future__ import unicode_literals <NEWLINE> import autoslug . fields <NEWLINE> from django . db import migrations , models <NEWLINE> import dartcms . utils . fields <NEWLINE>
class TestLoadState ( unittest . TestCase ) : <NEWLINE> <INDENT> def setUp ( self ) : <NEWLINE> <INDENT> self . dojo = Dojo ( ) <NEWLINE> <DEDENT> def test_data_loaded_successfully ( self ) : <NEWLINE> <INDENT> self . dojo . load_state ( <STRING> ) <NEWLINE> self . assertEqual ( path . exists ( <STRING> ) , True ) <NEWLINE> <DEDENT> <DEDENT>
from marionette_driver import expected , By , Wait <NEWLINE> from marionette_driver . errors import NoSuchElementException <NEWLINE> from firefox_ui_harness . decorators import skip_under_xvfb <NEWLINE> from firefox_ui_harness import FirefoxTestCase <NEWLINE>
import urllib <NEWLINE> from bs4 import BeautifulSoup <NEWLINE> url = <STRING> <NEWLINE> page = urllib . request . urlopen ( url ) <NEWLINE> s_p = page . read ( ) <NEWLINE> s = BeautifulSoup ( s_p , <STRING> ) <NEWLINE> a = [ ] <NEWLINE> for form in s . findAll ( <STRING> ) : <NEWLINE> <INDENT> a = form <NEWLINE> print ( a ) <NEWLINE> <DEDENT>
def interactive_console ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . vm . interactive_ssh ( ) <NEWLINE> <DEDENT>
def _create_buttons ( self ) : <NEWLINE> <INDENT> frame = Frame ( self ) <NEWLINE> self . _create_button ( frame , self . _left_button , <NEWLINE> <INDENT> self . _left_button_clicked ) <NEWLINE> <DEDENT> self . _create_button ( frame , self . _right_button , <NEWLINE> <INDENT> self . _right_button_clicked ) <NEWLINE> <DEDENT> frame . pack ( ) <NEWLINE> <DEDENT>
from django . conf . urls . defaults import * <NEWLINE> from events . views import * <NEWLINE> from events . models import Event , EventTime <NEWLINE> urlpatterns = patterns ( <STRING> , <NEWLINE> <INDENT> url ( <STRING> , event_detail , <NEWLINE> <INDENT> name = <STRING> ) , <NEWLINE> <DEDENT> url ( <STRING> , <NEWLINE> <INDENT> event_time_detail , name = <STRING> ) , <NEWLINE> <DEDENT> url ( <STRING> , <NEWLINE> <INDENT> register_for_event , <NEWLINE> name = <STRING> ) , <NEWLINE> <DEDENT> <DEDENT> ) <NEWLINE>
from __future__ import absolute_import <NEWLINE> from diggerplus . settings import DB_SETTINGS <NEWLINE> from diggerplus . db import db_manager <NEWLINE>
def forwards ( self , orm ) : <NEWLINE> <INDENT> db . add_column ( <STRING> , <STRING> , <NEWLINE> <INDENT> self . gf ( <STRING> ) ( default = <STRING> , max_length = 100 , blank = True ) , <NEWLINE> keep_default = False ) <NEWLINE> <DEDENT> <DEDENT>
from mezzanine . pages . admin import PageAdmin <NEWLINE> from django . contrib import admin <NEWLINE> from hs_modelinstance . models import ModelInstanceResource <NEWLINE> admin . site . register ( ModelInstanceResource , PageAdmin ) <NEWLINE>
from django . contrib import admin <NEWLINE> from main . models import ( Student , <NEWLINE> <INDENT> Professor , <NEWLINE> Admin , <NEWLINE> Course , <NEWLINE> Feedback , <NEWLINE> CourseStudent , <NEWLINE> CourseProfessor , <NEWLINE> RequestFeedback ) <NEWLINE> <DEDENT> admin . site . register ( Student ) <NEWLINE> admin . site . register ( Professor ) <NEWLINE> admin . site . register ( Course ) <NEWLINE> admin . site . register ( Feedback ) <NEWLINE> admin . site . register ( Admin ) <NEWLINE> admin . site . register ( CourseStudent ) <NEWLINE> admin . site . register ( CourseProfessor ) <NEWLINE> admin . site . register ( RequestFeedback ) <NEWLINE>
from muralifpb . models import UserStudent <NEWLINE> from muralifpb . models import Category <NEWLINE> from muralifpb . models import Post <NEWLINE> from muralifpb . models import NewsPortals <NEWLINE>
def migrate ( ) : <NEWLINE> <INDENT> with cd ( PROJECT_DIRNAME ) : <NEWLINE> <INDENT> run ( <STRING> ) <NEWLINE> run ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def clean ( filename ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> garbage = re . findall ( <STRING> , filename ) [ 0 ] <NEWLINE> cleanname = filename [ : - len ( garbage ) ] <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> cleanname = filename <NEWLINE> <DEDENT> return cleanname <NEWLINE> <DEDENT>
class Node ( models . Model ) : <NEWLINE> <INDENT> address = models . CharField ( unique = True , primary_key = True , max_length = 256 ) <NEWLINE> hostname = models . CharField ( blank = True , max_length = 256 ) <NEWLINE> sshkeys = models . ManyToManyField ( <STRING> ) <NEWLINE> userdata = models . ForeignKey ( <STRING> ) <NEWLINE> def __str__ ( self ) : <NEWLINE> <INDENT> return self . address <NEWLINE> <DEDENT> __unicode__ = __str__ <NEWLINE> <DEDENT>
def reset_defaults ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for name , widget in self . form . widgets . items ( ) : <NEWLINE> <INDENT> value = get_default_setting ( name ) <NEWLINE> self . form . set_widget_value ( widget , value ) <NEWLINE> <DEDENT> <DEDENT>
def _convert_savegame ( self , savegame ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for item in self . items : <NEWLINE> <INDENT> item . _convert_savegame ( savegame ) <NEWLINE> <DEDENT> self . savegame = savegame <NEWLINE> <DEDENT>
def test_array_to_byte_string_stereo_bytedepthE4 ( self ) : <NEWLINE> <INDENT> self . assertEqual ( util . array_to_byte_string ( self . stereo , 4 ) , <NEWLINE> <INDENT> self . stereo_str4 ) <NEWLINE> <DEDENT> <DEDENT>
from libs . common import requestVPNCycle <NEWLINE> from libs . utility import debugTrace , errorTrace , infoTrace <NEWLINE> debugTrace ( <STRING> ) <NEWLINE> requestVPNCycle ( False ) <NEWLINE> debugTrace ( <STRING> ) <NEWLINE>
def get_requirements ( ) : <NEWLINE> <INDENT> with open ( <STRING> ) as f : <NEWLINE> <INDENT> rv = f . read ( ) . splitlines ( ) <NEWLINE> <DEDENT> return rv <NEWLINE> <DEDENT>
from django . conf import settings <NEWLINE> from django . conf . urls . defaults import patterns , include , url <NEWLINE> from django . contrib import admin <NEWLINE> admin . autodiscover ( ) <NEWLINE> urlpatterns = patterns ( <STRING> , <NEWLINE> <INDENT> url ( <STRING> , include ( admin . site . urls ) ) , <NEWLINE> <DEDENT> ) <NEWLINE> if settings . DEBUG : <NEWLINE> <INDENT> urlpatterns += patterns ( <STRING> , <NEWLINE> <INDENT> ( <STRING> , <STRING> , { <STRING> : settings . MEDIA_ROOT } ) , <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def test_http_error ( self ) : <NEWLINE> <INDENT> url = <STRING> <NEWLINE> requests . get ( url , stream = True ) . AndRaise ( exceptions . HTTPError ( ) ) <NEWLINE> self . m . ReplayAll ( ) <NEWLINE> self . assertRaises ( urlfetch . URLFetchError , urlfetch . get , url ) <NEWLINE> self . m . VerifyAll ( ) <NEWLINE> <DEDENT>
class Submit ( object ) : <NEWLINE> <INDENT> def __init__ ( self , jsubrc , task_id , dry_run ) : <NEWLINE> <INDENT> self . __jsubrc = jsubrc <NEWLINE> self . __task_id = task_id <NEWLINE> self . __dry_run = dry_run <NEWLINE> <DEDENT> def execute ( self ) : <NEWLINE> <INDENT> click . echo ( <STRING> ) <NEWLINE> j = Jsub ( self . __jsubrc ) <NEWLINE> j . submit ( self . __task_id , dry_run = self . __dry_run ) <NEWLINE> <DEDENT> <DEDENT>
class TestStream : <NEWLINE> <INDENT> def test_repeat_each ( self ) : <NEWLINE> <INDENT> nsamples = 10 <NEWLINE> nrepeats = 5 <NEWLINE> stream = Stream ( range ( nsamples ) ) <NEWLINE> repeated_stream = repeat_each ( stream , nrepeats ) <NEWLINE> assert type ( repeated_stream ) is type ( stream ) <NEWLINE> repeated_stream = list ( repeated_stream ) <NEWLINE> assert np . allclose ( repeated_stream [ 0 : : 5 ] , repeated_stream [ 3 : : 5 ] ) <NEWLINE> <DEDENT> <DEDENT>
import argparse <NEWLINE> from alerta . app import app <NEWLINE> from alerta . app import db <NEWLINE> from alerta . version import __version__ <NEWLINE> LOG = app . logger <NEWLINE>
import smach_ros <NEWLINE> import smach <NEWLINE> from smach import state <NEWLINE> import rospy <NEWLINE> import yaml <NEWLINE> import os . path <NEWLINE> import numpy as np <NEWLINE> from std_msgs . msg import Float64 , String <NEWLINE> from dynamixel_msgs . msg import JointState <NEWLINE> from dynamixel_controllers . srv import TorqueEnable , SetSpeed <NEWLINE> from dynamixel_driver . dynamixel_io import DynamixelIO <NEWLINE> from approach_control_srv . srv import Gesture <NEWLINE>
def tearDownClass ( cls ) : <NEWLINE> <INDENT> cls . io_loop . add_callback ( cls . http_server . stop ) <NEWLINE> cls . io_loop . add_callback ( cls . https_server . stop ) <NEWLINE> cls . io_loop . add_callback ( cls . proxy_server . stop ) <NEWLINE> cls . io_loop . add_callback ( cls . io_loop . stop ) <NEWLINE> cls . server_thread . join ( ) <NEWLINE> <DEDENT>
import django <NEWLINE> import os <NEWLINE> import sys <NEWLINE> if django . VERSION < ( 1 , 8 ) : <NEWLINE> <INDENT> from django . db . backends import BaseDatabaseClient <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from django . db . backends . base . client import BaseDatabaseClient <NEWLINE> <DEDENT>
import logging <NEWLINE> import state <NEWLINE> import network <NEWLINE> import worker <NEWLINE> import project <NEWLINE> import user <NEWLINE> import tracking <NEWLINE> import cpc . network . server_response <NEWLINE> import cpc . util <NEWLINE> from cpc . server . state . user_handler import UserLevel <NEWLINE> log = logging . getLogger ( __name__ ) <NEWLINE>
import sys <NEWLINE> import matplotlib . pyplot as plt <NEWLINE> import numpy as np <NEWLINE> import csv <NEWLINE>
class CloseableNestedSetup ( logbook . NestedSetup ) : <NEWLINE> <INDENT> def close ( self ) : <NEWLINE> <INDENT> for obj in self . objects : <NEWLINE> <INDENT> if hasattr ( obj , <STRING> ) : <NEWLINE> <INDENT> obj . close ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
from __future__ import unicode_literals <NEWLINE> from django import forms <NEWLINE> from django . utils . translation import ugettext_lazy as _ <NEWLINE> from . models import Grid , GRID_CONFIG , DJANGOCMS_GRID_CHOICES <NEWLINE> NUM_COLUMNS = [ <NEWLINE> <INDENT> ( i , <STRING> % i ) for i in range ( 0 , GRID_CONFIG [ <STRING> ] ) <NEWLINE> <DEDENT> ] <NEWLINE>
def unshorten ( url , quality = None ) : <NEWLINE> <INDENT> import js2py <NEWLINE> html = requests . get ( url ) . text <NEWLINE> javascript = <STRING> . format ( <NEWLINE> <INDENT> re . search ( <STRING> , html ) . group ( 1 ) <NEWLINE> <DEDENT> ) <NEWLINE> logger . debug ( <STRING> . format ( javascript ) ) <NEWLINE> src = js2py . eval_js ( javascript ) <NEWLINE> logger . debug ( <STRING> . format ( src ) ) <NEWLINE> if quality is None : <NEWLINE> <INDENT> logger . warning ( <STRING> ) <NEWLINE> quality = get_quality ( src ) <NEWLINE> <DEDENT> return [ Source ( src , quality ) ] <NEWLINE> <DEDENT>
def testToNumberFloat ( self ) : <NEWLINE> <INDENT> obj = QLocale ( QLocale . C ) <NEWLINE> self . assertEqual ( ( ctypes . c_float ( 37.109 ) . value , True ) , <NEWLINE> <INDENT> obj . toFloat ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT>
import logging <NEWLINE> import os <NEWLINE> basedir = os . path . abspath ( os . path . dirname ( __file__ ) ) <NEWLINE>
from __future__ import absolute_import , division , print_function <NEWLINE> from . base import Base , Defaults , DBase , Datasheet , Thread <NEWLINE> from . events import Event , Actions , Action <NEWLINE> from . ecs import EntityCatalogue , Entity , Component <NEWLINE> from . settings import Settings <NEWLINE>
<STRING> <NEWLINE> import sys , os , imp <NEWLINE> from modulegraph . modulegraph import MissingModule , Package , SourceModule , CompiledModule , find_module <NEWLINE>
def test_tokenize ( self ) : <NEWLINE> <INDENT> gw = fatzebra . gateway . Gateway ( ) <NEWLINE> result = gw . tokenize ( <STRING> , VALID_CARD , VALID_EXPIRY , <STRING> ) <NEWLINE> self . assertIsNotNone ( result . token ) <NEWLINE> <DEDENT>
from mercurial . dicthelpers import diff , join <NEWLINE> import unittest <NEWLINE> import silenttestrunner <NEWLINE>
import sys , os <NEWLINE> from xml . etree import ElementTree as ET <NEWLINE> import xml <NEWLINE> <STRING> <NEWLINE> dumpfile = open ( sys . argv [ 1 ] ) <NEWLINE> test = ET . fromstringlist ( dumpfile ) <NEWLINE> for address in test . iter ( <STRING> ) : <NEWLINE> <INDENT> print ( address . tag , address . text ) <NEWLINE> <DEDENT>
class UJsonTestCase ( BackendBase ) : <NEWLINE> <INDENT> def setUp ( self ) : <NEWLINE> <INDENT> self . set_preferred_backend ( <STRING> ) <NEWLINE> <DEDENT> def test_backend ( self ) : <NEWLINE> <INDENT> expected_pickled = ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> self . assertEncodeDecode ( expected_pickled ) <NEWLINE> <DEDENT> <DEDENT>
def init_hashing ( depth , width , alg ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> hashIO . set_depth ( depth ) <NEWLINE> hashIO . set_width ( width ) <NEWLINE> hashIO . set_hashalg ( alg ) <NEWLINE> <DEDENT>
def _load_entry_point ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> import pkg_resources <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> for res in pkg_resources . iter_entry_points ( <STRING> ) : <NEWLINE> <INDENT> if res . name == self . drivername . replace ( <STRING> , <STRING> ) : <NEWLINE> <INDENT> return res . load ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT>
class Migration ( migrations . Migration ) : <NEWLINE> <INDENT> dependencies = [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE> operations = [ <NEWLINE> <INDENT> migrations . AddField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> field = models . CharField ( default = <STRING> , max_length = 255 , blank = True ) , <NEWLINE> <DEDENT> ) , <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> director . init ( resizable = True ) <NEWLINE> scene1 = cocos . scene . Scene ( ) <NEWLINE> scene2 = cocos . scene . Scene ( ) <NEWLINE> colorl = ColorLayer ( 32 , 32 , 255 , 255 ) <NEWLINE> sprite = Sprite ( <STRING> , ( 320 , 240 ) ) <NEWLINE> colorl . add ( sprite ) <NEWLINE> scene1 . add ( BackgroundLayer ( ) , z = 0 ) <NEWLINE> scene2 . add ( colorl , z = 0 ) <NEWLINE> director . run ( CornerMoveTransition ( scene1 , 2 , scene2 ) ) <NEWLINE> <DEDENT>
def ticker ( cur1 , cur2 ) : <NEWLINE> <INDENT> s = __name__ . split ( <STRING> ) [ 1 ] <NEWLINE> r = sys . _getframe ( ) . f_code . co_name <NEWLINE> symbol = cur1 . capitalize ( ) + cur2 . capitalize ( ) <NEWLINE> cr = core . request ( s , r ) . replace ( constants . SYMBOL_PATTERN , symbol ) <NEWLINE> return core . get ( core . hostname ( s ) , cr , core . header ( s ) , core . compression ( s ) , core . timeout ( s ) ) <NEWLINE> <DEDENT>
def test_time_domain_default ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> domain = Domain . TimeDomain ( ) <NEWLINE> actual = domain . draw ( 3 ) <NEWLINE> expected = [ time ( 0 , 0 ) , time ( 0 , 1 ) , time ( 0 , 2 ) ] <NEWLINE> self . assertItemsEqual ( actual , expected ) <NEWLINE> self . assertEquals ( domain . max_size , 60 * 24 ) <NEWLINE> <DEDENT>
class Item ( pg . sprite . Sprite ) : <NEWLINE> <INDENT> def __init__ ( self , game , pos , type ) : <NEWLINE> <INDENT> self . _layer = ITEMS_LAYER <NEWLINE> self . groups = game . all_sprites , game . items <NEWLINE> pg . sprite . Sprite . __init__ ( self , self . groups ) <NEWLINE> self . game = game <NEWLINE> self . image = game . item_images [ type ] <NEWLINE> self . rect = self . image . get_rect ( ) <NEWLINE> self . type = type <NEWLINE> self . rect . center = pos <NEWLINE> self . pos = pos <NEWLINE> <DEDENT> <DEDENT>
def test_get_compound_annotated_section_data_set ( self ) : <NEWLINE> <INDENT> expected = <STRING> <NEWLINE> self . asdsa . json_msg_query = MagicMock ( name = <STRING> ) <NEWLINE> self . asdsa . get_annotated_section_data_sets ( <NEWLINE> <INDENT> structures = [ 112763676 ] , <NEWLINE> intensity_values = [ <STRING> , <STRING> , <STRING> ] , <NEWLINE> density_values = [ <STRING> , <STRING> ] , <NEWLINE> pattern_values = [ <STRING> ] , <NEWLINE> age_names = [ <STRING> , <STRING> ] ) <NEWLINE> <DEDENT> self . asdsa . json_msg_query . assert_called_once_with ( expected ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from __future__ import absolute_import , print_function <NEWLINE>
class ClearCalendarForm ( i18nforms . Form ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> confirm_delete = wtforms . BooleanField ( <NEWLINE> <INDENT> _ ( <STRING> ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def run_app ( ) : <NEWLINE> <INDENT> root = Tk ( ) <NEWLINE> controller = Controller ( root ) <NEWLINE> controller . start ( ) <NEWLINE> root . mainloop ( ) <NEWLINE> <DEDENT>
def __init__ ( self , model , data , parameters = None ) : <NEWLINE> <INDENT> self . model = copy . copy ( model ) <NEWLINE> self . num_layers = model . num_layers <NEWLINE> self . data = data <NEWLINE> if parameters is None : <NEWLINE> <INDENT> parameters = OptimizerParameters ( ) <NEWLINE> <DEDENT> self . parameters = parameters <NEWLINE> self . cost = 0.0 <NEWLINE> self . n_iter = 0 <NEWLINE> self . hits = 0.0 <NEWLINE> self . step_w = None <NEWLINE> self . step_b = None <NEWLINE> <DEDENT>
def medman_genre ( med , args ) : <NEWLINE> <INDENT> if len ( args ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return False <NEWLINE> <DEDENT> if args [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> elif args [ 0 ] == <STRING> : <NEWLINE> <INDENT> return handle_name ( med , args [ 1 ] , args [ 2 : ] ) <NEWLINE> <DEDENT> elif args [ 0 ] == <STRING> : <NEWLINE> <INDENT> return handle_entry ( med , args [ 1 ] , args [ 2 ] , args [ 3 : ] ) <NEWLINE> <DEDENT> <DEDENT>
try : <NEWLINE> <INDENT> from unittest import mock <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> import mock <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> import unittest2 as unittest <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> import unittest <NEWLINE> <DEDENT>
def js_ex ( string ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> result = browser . js_ex ( string ) <NEWLINE> print ( result ) <NEWLINE> return result <NEWLINE> <DEDENT>
def delete_first ( self ) : <NEWLINE> <INDENT> wd = self . app . wd <NEWLINE> wd . find_element_by_css_selector ( <STRING> ) . click ( ) <NEWLINE> wd . find_element_by_name ( <STRING> ) . click ( ) <NEWLINE> <DEDENT>
class tester_t ( parser_test_case . parser_test_case_t ) : <NEWLINE> <INDENT> COMPILATION_MODE = parser . COMPILATION_MODE . ALL_AT_ONCE <NEWLINE> def __init__ ( self , * args ) : <NEWLINE> <INDENT> parser_test_case . parser_test_case_t . __init__ ( self , * args ) <NEWLINE> self . header = <STRING> <NEWLINE> self . declarations = None <NEWLINE> <DEDENT> def setUp ( self ) : <NEWLINE> <INDENT> if not self . declarations : <NEWLINE> <INDENT> self . declarations = parser . parse ( [ self . header ] , self . config ) <NEWLINE> <DEDENT> <DEDENT> def test ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>
def backwards ( self , orm ) : <NEWLINE> <INDENT> db . add_column ( <STRING> , <STRING> , self . gf ( <STRING> ) ( null = True , blank = True ) , keep_default = False ) <NEWLINE> db . add_column ( <STRING> , <STRING> , self . gf ( <STRING> ) ( default = 1 ) , keep_default = False ) <NEWLINE> db . add_column ( <STRING> , <STRING> , self . gf ( <STRING> ) ( default = 1 ) , keep_default = False ) <NEWLINE> db . add_column ( <STRING> , <STRING> , self . gf ( <STRING> ) ( null = True , blank = True ) , keep_default = False ) <NEWLINE> <DEDENT>
def load_url ( url , mapper = TupleMapper , options = { } ) : <NEWLINE> <INDENT> mimetype = guess_type ( url ) <NEWLINE> if mimetype not in PARSERS : <NEWLINE> <INDENT> raise ParseFailed ( <STRING> % mimetype ) <NEWLINE> <DEDENT> parser = PARSERS [ mimetype ] <NEWLINE> loader = NetLoader <NEWLINE> IO = make_io ( loader , parser , mapper ) <NEWLINE> return IO ( url = url , ** options ) <NEWLINE> <DEDENT>
def set ( self , key , value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . __data = ( { key , value } ) <NEWLINE> <DEDENT>
def build_from_web_request ( cls , params , default_chunk_size ) : <NEWLINE> <INDENT> chunk_size = params . get ( <STRING> ) <NEWLINE> filters = params . get_all ( <STRING> ) <NEWLINE> orderings = params . get_all ( <STRING> ) <NEWLINE> if not chunk_size and not filters and not orderings : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> chunk_size = int ( chunk_size or default_chunk_size ) <NEWLINE> secret = cls . _build_secret ( params ) <NEWLINE> return cls . _TableContext1 ( 1 , chunk_size , filters , orderings , { } , secret ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> SCHEMA = <STRING> <NEWLINE> DATABASE_TABLE = <STRING> <NEWLINE> VIEW_TABLE = <STRING> <NEWLINE>
def test_create_security_group_rule_with_remote_group_id ( self ) : <NEWLINE> <INDENT> sg1_body , _ = self . _create_security_group ( ) <NEWLINE> sg2_body , _ = self . _create_security_group ( ) <NEWLINE> sg_id = sg1_body [ <STRING> ] [ <STRING> ] <NEWLINE> direction = <STRING> <NEWLINE> protocol = <STRING> <NEWLINE> port_range_min = 50 <NEWLINE> port_range_max = 55 <NEWLINE> remote_id = sg2_body [ <STRING> ] [ <STRING> ] <NEWLINE> self . _create_verify_security_group_rule ( sg_id , direction , <NEWLINE> <INDENT> self . ethertype , protocol , <NEWLINE> port_range_min , <NEWLINE> port_range_max , <NEWLINE> remote_group_id = remote_id ) <NEWLINE> <DEDENT> <DEDENT>
def get_group ( self , group_name ) : <NEWLINE> <INDENT> internal = self . __group . get_group ( group_name ) <NEWLINE> if internal is None : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> return Group ( internal ) <NEWLINE> <DEDENT>
from __future__ import absolute_import <NEWLINE> from unipath import Path <NEWLINE> from . local import * <NEWLINE> DATABASES = { <NEWLINE> <INDENT> <STRING> : { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> LOCAL_ROOT = Path ( <STRING> ) <NEWLINE> WEATHER_ROOT = LOCAL_ROOT + <STRING> <NEWLINE> EMAIL_BACKEND = <STRING> <NEWLINE> NOTIFICATIONS_QUEUE_MINS = 0 <NEWLINE>
from datetime import datetime <NEWLINE> from sqlalchemy . orm import aliased <NEWLINE> from flask import Blueprint , request , url_for , redirect , render_template , session <NEWLINE> from flask . ext . wtf import Form , TextField , Required , PasswordField , HiddenField , DateField , IntegerField <NEWLINE> from pager . libs . flask_ import blueprint_templated , error , success <NEWLINE> from pager . models import db , User , Message , MessageLog <NEWLINE> from pager . tasks import absence_email , send_notify_mail <NEWLINE> admin = Blueprint ( <STRING> , __name__ ) <NEWLINE> templated = blueprint_templated ( admin . name ) <NEWLINE>
from setuptools import setup , find_packages <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> version = <STRING> , <NEWLINE> packages = find_packages ( ) , <NEWLINE> install_requires = [ <STRING> , <STRING> , <STRING> ] , <NEWLINE> tests_require = [ <STRING> ] <NEWLINE> <DEDENT> ) <NEWLINE>
class MessageQuerySet ( QuerySet ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def undelivered ( self , to = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if to is not None : <NEWLINE> <INDENT> return self . filter ( deliveries__receiver = to , <NEWLINE> <INDENT> deliveries__delivered_at__isnull = True ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return self . filter ( deliveries__delivered_at__isnull = True ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import dbus <NEWLINE> import sys <NEWLINE> import getopt <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> import ConfigParser <NEWLINE> from SimpleXMLRPCServer import SimpleXMLRPCServer , SimpleXMLRPCRequestHandler <NEWLINE> config = ConfigParser . ConfigParser ( ) <NEWLINE> config . read ( [ <STRING> ] ) <NEWLINE> xmlrpc_host = config . get ( <STRING> , <STRING> ) <NEWLINE> xmlrpc_port = eval ( config . get ( <STRING> , <STRING> ) ) <NEWLINE> root_folder = config . get ( <STRING> , <STRING> ) <NEWLINE>
class DummyParser : <NEWLINE> <INDENT> anchorlist = [ ] <NEWLINE> def feed ( self , s ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
import requests <NEWLINE> from bs4 import BeautifulSoup <NEWLINE> import getpass <NEWLINE>
<STRING> <NEWLINE> from __future__ import ( absolute_import , division , print_function ) <NEWLINE> import iris . tests as tests <NEWLINE> import numpy as np <NEWLINE> import iris . analysis . interpolate as interpolate <NEWLINE> from iris . coords import DimCoord <NEWLINE> from iris . cube import Cube <NEWLINE> from iris . tests . test_interpolation import normalise_order <NEWLINE>
<STRING> <NEWLINE> import distutils . sysconfig <NEWLINE> import sys <NEWLINE> plib = distutils . sysconfig . get_python_lib ( ) <NEWLINE> mod_path = <STRING> % plib <NEWLINE> sys . path . insert ( 0 , mod_path ) <NEWLINE> from utils import _ <NEWLINE> import commands <NEWLINE> from cexceptions import * <NEWLINE> HELP_FORMAT = commands . HELP_FORMAT <NEWLINE>
from nose . tools import assert_equal <NEWLINE> import clinvoc <NEWLINE> from clinvoc . hcpcs import HCPCS <NEWLINE>
class Fortaleza ( DstTzInfo ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> zone = <STRING> <NEWLINE> <DEDENT>
def initialize ( self , ctx ) : <NEWLINE> <INDENT> self . path = self . url <NEWLINE> super ( HttpReader , self ) . initialize ( ctx ) <NEWLINE> if ( self . url == None ) : <NEWLINE> <INDENT> raise Exception ( <STRING> % self ) <NEWLINE> <DEDENT> <DEDENT>
def get_column_names ( cursor ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return [ col [ 0 ] for col in cursor . description ] <NEWLINE> <DEDENT>
class Evaluator ( template . EvaluatorInterface ) : <NEWLINE> <INDENT> evalList = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> def __init__ ( self , iocTree , remoteCommand , wd , keepFiles , confidential , dirname ) : <NEWLINE> <INDENT> template . EvaluatorInterface . __init__ ( self , iocTree , remoteCommand , wd , keepFiles , confidential , dirname ) <NEWLINE> self . setEvaluatorParams ( evalList = Evaluator . evalList , name = <STRING> , ext = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> import argparse <NEWLINE> from vasppy . poscar import Poscar <NEWLINE> from vasppy . cell import Cell <NEWLINE>
def upgrade ( ) : <NEWLINE> <INDENT> op . create_table ( <STRING> , <NEWLINE> sa . Column ( <STRING> , sa . Integer ( ) , nullable = False ) , <NEWLINE> sa . Column ( <STRING> , sa . String ( length = 260 ) , nullable = True ) , <NEWLINE> sa . Column ( <STRING> , sa . String ( length = 80 ) , nullable = True ) , <NEWLINE> sa . Column ( <STRING> , sa . String ( length = 80 ) , nullable = True ) , <NEWLINE> sa . PrimaryKeyConstraint ( <STRING> ) <NEWLINE> ) <NEWLINE> <DEDENT>
def post_bookmark ( bmk , auth_token ) : <NEWLINE> <INDENT> params = bmk2params ( bmk , auth_token ) <NEWLINE> reply = requests . post ( add_url , params = params ) <NEWLINE> return parse_reply ( reply ) <NEWLINE> <DEDENT>
def tunnel_port_handler ( self , ev ) : <NEWLINE> <INDENT> self . logger . debug ( <STRING> , ev ) <NEWLINE> if ev . add_del : <NEWLINE> <INDENT> self . _tunnel_port_add ( ev ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . _tunnel_port_del ( ev ) <NEWLINE> <DEDENT> <DEDENT>
from django . conf import settings <NEWLINE> from django . core . mail import EmailMultiAlternatives <NEWLINE> from django . template . loader import render_to_string <NEWLINE>
<STRING> <NEWLINE> from __future__ import absolute_import <NEWLINE> from __future__ import unicode_literals <NEWLINE> from . import util <NEWLINE> from . import odict <NEWLINE> import re <NEWLINE>
import numpy as np <NEWLINE> from zvsgld import ZVSGLD <NEWLINE> from sklearn . metrics import log_loss <NEWLINE>
<STRING> <NEWLINE> __context__ = <STRING> <NEWLINE> import pyrevit . unittests as prtests <NEWLINE> prtests . perform_engine_tests ( ) <NEWLINE>
def get_pubkey_from_x ( self , xpub , for_change , n ) : <NEWLINE> <INDENT> _ , _ , _ , c , cK = deserialize_xkey ( xpub ) <NEWLINE> for i in [ for_change , n ] : <NEWLINE> <INDENT> cK , c = CKD_pub ( cK , c , i ) <NEWLINE> <DEDENT> return cK . encode ( <STRING> ) <NEWLINE> <DEDENT>
def _connect ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . _play_context . become : <NEWLINE> <INDENT> self . __become_method_supported ( ) <NEWLINE> <DEDENT> <DEDENT>
def calcRabbits ( n , k ) : <NEWLINE> <INDENT> pairs = [ 1 , 1 ] <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> f1 = pairs [ i - 1 ] <NEWLINE> f2 = pairs [ i - 2 ] * 3 <NEWLINE> pairs . append ( ( f1 + f2 ) ) <NEWLINE> <DEDENT> return pairs <NEWLINE> <DEDENT>
def classifySPoutput ( targetOutputColumns , outputColumns ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> numTargets , numDims = targetOutputColumns . shape <NEWLINE> overlap = np . zeros ( ( numTargets , ) ) <NEWLINE> for i in range ( numTargets ) : <NEWLINE> <INDENT> overlap [ i ] = percentOverlap ( outputColumns , targetOutputColumns [ i , : ] ) <NEWLINE> <DEDENT> classLabel = np . argmax ( overlap ) <NEWLINE> return classLabel <NEWLINE> <DEDENT>
def getNotes ( self ) : <NEWLINE> <INDENT> return [ <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ] <NEWLINE> <DEDENT>
def test_xml_to_json ( ) : <NEWLINE> <INDENT> res = serialize . xml_to_json ( ex . C_XML_1 ) <NEWLINE> assert res == ex . C_XML_1_AS_JSON <NEWLINE> <DEDENT>
def release_floatingip ( self , floatingip ) : <NEWLINE> <INDENT> row = self . _get_row_with_floatingip ( floatingip ) <NEWLINE> row . mark ( ) <NEWLINE> self . floatingips_table . release . click ( ) <NEWLINE> self . floatingip_form . submit . click ( ) <NEWLINE> self . wait_till_popups_disappear ( ) <NEWLINE> <DEDENT>
class AnityaException ( Exception ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> pass <NEWLINE> <DEDENT>
import asyncio <NEWLINE> import argparse <NEWLINE> from timer import timer <NEWLINE> import settings <NEWLINE>
class Migration ( migrations . Migration ) : <NEWLINE> <INDENT> dependencies = [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE> operations = [ <NEWLINE> <INDENT> migrations . AlterField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> field = models . TimeField ( default = datetime . time ( 1 , 50 , 31 , 856605 ) , verbose_name = <STRING> ) , <NEWLINE> preserve_default = False , <NEWLINE> <DEDENT> ) , <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT>
def run ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( getDatastorePath ( <STRING> ) ) <NEWLINE> return 0 <NEWLINE> <DEDENT>
def nice_times ( seconds ) : <NEWLINE> <INDENT> if seconds < 60 * 60 : <NEWLINE> <INDENT> hours = None <NEWLINE> if seconds < 60 : <NEWLINE> <INDENT> minutes = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minutes = seconds / 60 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> minutes = seconds / 60 <NEWLINE> hours = seconds / 60 / 60 <NEWLINE> <DEDENT> return hours , minutes <NEWLINE> <DEDENT>
def main ( args ) : <NEWLINE> <INDENT> server . start ( main_loop ) <NEWLINE> adapter = Application ( server , <STRING> ) <NEWLINE> plugin . plugin_main ( adapter ) <NEWLINE> try : <NEWLINE> <INDENT> server . main_loop ( ) <NEWLINE> <DEDENT> except KeyboardInterrupt : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT>
def test_csv2nlj ( tmpdir , compare_iter , dicts_csv_path , dicts_path ) : <NEWLINE> <INDENT> outfile = str ( tmpdir . mkdir ( <STRING> ) . join ( <STRING> ) ) <NEWLINE> result = CliRunner ( ) . invoke ( main , [ <NEWLINE> <INDENT> <STRING> , dicts_csv_path , outfile <NEWLINE> <DEDENT> ] ) <NEWLINE> assert result . exit_code == 0 <NEWLINE> with nlj . open ( dicts_path ) as expected : <NEWLINE> <INDENT> with nlj . open ( outfile ) as actual : <NEWLINE> <INDENT> compare_iter ( expected , actual ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def tearDown ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> DBSession . rollback ( ) <NEWLINE> <DEDENT>
class Scraper ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def scrape ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> raise NotImplementedError ( ) <NEWLINE> <DEDENT> <DEDENT>
def euclidean_distance ( data , p1 , p2 ) : <NEWLINE> <INDENT> si = { } <NEWLINE> for item in data [ person1 ] : <NEWLINE> <INDENT> if item in data [ person2 ] : <NEWLINE> <INDENT> si [ item ] = 1 <NEWLINE> <DEDENT> <DEDENT> if len ( si ) == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> sum_of_squares = 0 <NEWLINE> for item in data [ person1 ] : <NEWLINE> <INDENT> if item in data [ person2 ] : <NEWLINE> <INDENT> sum_of_squares += pow ( data [ person1 ] [ item ] - data [ person2 ] [ item ] , 2 ) <NEWLINE> <DEDENT> <DEDENT> return 1 / ( 1 + sum_of_squares ) <NEWLINE> <DEDENT>
def _get_user_input ( ) -> dict : <NEWLINE> <INDENT> return docopt ( <NEWLINE> <INDENT> doc = _read_interface ( ) , <NEWLINE> version = const . VERSION <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def ms_to_sec ( ms ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return int ( ms / 1000 ) <NEWLINE> <DEDENT>
class PipelineLogger : <NEWLINE> <INDENT> logFunctions = { <STRING> : logging . info , <NEWLINE> <INDENT> <STRING> : logging . debug , <NEWLINE> <STRING> : logging . warning , <NEWLINE> <STRING> : logging . error , <NEWLINE> <STRING> : logging . critical , <NEWLINE> <INDENT> <STRING> : logging . exception } <NEWLINE> <DEDENT> <DEDENT> @ staticmethod <NEWLINE> def log ( moduleName , level , message ) : <NEWLINE> <INDENT> level = level . lower ( ) <NEWLINE> logging . getLogger ( moduleName ) <NEWLINE> PipelineLogger . logFunctions [ level ] ( message ) <NEWLINE> <DEDENT> <DEDENT>
class SimpleExample ( BaseWidget ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> super ( SimpleExample , self ) . __init__ ( <STRING> ) <NEWLINE> self . _control = ControlFile ( <STRING> ) <NEWLINE> self . _formset = [ <STRING> , ( <STRING> , <STRING> , <STRING> ) , <STRING> ] <NEWLINE> <DEDENT> <DEDENT>
def test_make_and_send_dns_message_missing_AA_flags ( self , * mocks ) : <NEWLINE> <INDENT> self . agent . _make_dns_message = Mock ( return_value = <STRING> ) <NEWLINE> response = RoObject ( <NEWLINE> <INDENT> rcode = Mock ( return_value = dns . rcode . NOERROR ) , <NEWLINE> flags = 0 , <NEWLINE> <DEDENT> ) <NEWLINE> self . agent . _send_dns_message = Mock ( return_value = response ) <NEWLINE> out = self . agent . _make_and_send_dns_message ( <STRING> , 123 , 1 , 2 , 3 , 4 , 5 ) <NEWLINE> self . assertEqual ( ( None , 0 ) , out ) <NEWLINE> <DEDENT>
def __init__ ( self ) : <NEWLINE> <INDENT> self . __varName = <STRING> <NEWLINE> self . __current = <STRING> <NEWLINE> self . __curList = [ ] <NEWLINE> <DEDENT>
import sys , socket <NEWLINE> from collect_client import * <NEWLINE> from client_psutil_plugin import psutil_stat <NEWLINE> hostname = socket . gethostname ( ) <NEWLINE> server_address = [ <STRING> % hostname ] <NEWLINE> if True : <NEWLINE> <INDENT> c = collectd ( hostname , server_address ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = collectd ( hostname , server_address , stack = 10 ) <NEWLINE> <DEDENT> <STRING> <NEWLINE> ps = psutil_stat ( ) <NEWLINE> c . plugins . append ( ps ) <NEWLINE> c . daemon ( ) <NEWLINE>
from realacct_list import RealAcctListMixin <NEWLINE> from realtxn_list import RealTxnListForRealAcctMixin <NEWLINE>
from django . conf . urls import patterns , url <NEWLINE> from django . contrib . auth . decorators import login_required <NEWLINE> from . views import ActivityStream , ActivityStreamSettings <NEWLINE> urlpatterns = patterns ( <STRING> , <NEWLINE> <INDENT> url ( <STRING> , ActivityStream . as_view ( ) , name = <STRING> ) , <NEWLINE> url ( <STRING> , login_required ( ActivityStreamSettings . as_view ( ) ) , <NEWLINE> <INDENT> name = <STRING> ) , <NEWLINE> <DEDENT> <DEDENT> ) <NEWLINE>
from django . conf . urls import patterns , url <NEWLINE> from home import views <NEWLINE> urlpatterns = patterns ( <STRING> , <NEWLINE> <INDENT> url ( <STRING> , views . index , name = <STRING> ) , <NEWLINE> url ( <STRING> , views . gadget_details , name = <STRING> ) , <NEWLINE> url ( <STRING> , views . gadget_do , name = <STRING> ) , <NEWLINE> <DEDENT> ) <NEWLINE>
def setUp ( self ) : <NEWLINE> <INDENT> self . dataUnit = HomeoDataUnit ( ) <NEWLINE> self . unit = HomeoUnit ( ) <NEWLINE> <DEDENT>
import logging <NEWLINE> from django . core . management . base import BaseCommand <NEWLINE> from feedzilla . models import Post <NEWLINE>
def set_voice ( ) : <NEWLINE> <INDENT> global voice <NEWLINE> import pyvona <NEWLINE> voice = pyvona . create_voice ( ) <NEWLINE> <DEDENT>
def delete_group_rows ( self , session , group ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> rows = [ r for r in self . rows if r [ 2 ] == group ] <NEWLINE> ids = [ r [ 0 ] for r in rows ] <NEWLINE> session . execute ( <STRING> % <STRING> . join ( ids ) ) <NEWLINE> return list ( rows ) <NEWLINE> <DEDENT>
class Whisk : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> start_time = time . time ( ) <NEWLINE> mdbundle = FileLoader ( MARKDOWN_EXT , ROOT_DIR , MarkdownFile ) <NEWLINE> templates = set ( f . metadata [ <STRING> ] for f in mdbundle . files ) <NEWLINE> tt = Templater ( TEMPLATE_DIR ) <NEWLINE> tt . load_templates ( templates ) <NEWLINE> for mdfile in mdbundle . files : <NEWLINE> <INDENT> tt . render_and_write ( mdfile ) <NEWLINE> <DEDENT> print ( <STRING> % ( len ( mdbundle . files ) , time . time ( ) - start_time ) ) <NEWLINE> <DEDENT> <DEDENT>
def test_substitution ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> testcases = [ ( <STRING> , <STRING> ) , <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) ] <NEWLINE> <DEDENT> for a , b in testcases : <NEWLINE> <INDENT> obj = cronex . CronExpression ( a ) <NEWLINE> self . assertTrue ( b in repr ( obj ) ) <NEWLINE> <DEDENT> <DEDENT>
def deploy_ssh_pubkeys ( self , ovfenv ) : <NEWLINE> <INDENT> for pubkey in ovfenv . ssh_pubkeys : <NEWLINE> <INDENT> logger . info ( <STRING> ) <NEWLINE> self . distro . osutil . deploy_ssh_pubkey ( ovfenv . username , pubkey ) <NEWLINE> <DEDENT> <DEDENT>
import demowlcutils <NEWLINE> from demowlcutils import ppxml , WLC_login <NEWLINE> from pprint import pprint as pp <NEWLINE> from jnpr . wlc import WirelessLanController as WLC <NEWLINE> wlc = WLC ( host = <STRING> , user = <STRING> , password = <STRING> ) <NEWLINE>
from app import db , app <NEWLINE> from models import File <NEWLINE> from datetime import date , datetime , time , timedelta <NEWLINE> import os <NEWLINE> import shutil <NEWLINE>
from flask . ext . script import Manager , Server <NEWLINE> from flaskcms import creat_app <NEWLINE> server = Server ( port = 8000 ) <NEWLINE> manager = Manager ( creat_app ( <STRING> ) ) <NEWLINE> manager . add_command ( <STRING> , server ) <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> manager . run ( ) <NEWLINE> <DEDENT>
from functools import wraps <NEWLINE> from django . http import HttpResponse <NEWLINE> from django . core . urlresolvers import reverse <NEWLINE> from django . core . handlers . wsgi import WSGIRequest <NEWLINE> from fandjango . utils import get_post_authorization_redirect_url <NEWLINE> from fandjango . views import authorize_application <NEWLINE> from fandjango . settings import FACEBOOK_APPLICATION_DOMAIN <NEWLINE> from fandjango . settings import FACEBOOK_APPLICATION_NAMESPACE <NEWLINE> from fandjango . settings import FACEBOOK_APPLICATION_INITIAL_PERMISSIONS <NEWLINE> from fandjango . settings import FACEBOOK_AUTHORIZATION_REDIRECT_URL <NEWLINE>
def __init__ ( self , size ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> this = _coda_io . new_NullInputStream ( size ) <NEWLINE> try : <NEWLINE> <INDENT> self . this . append ( this ) <NEWLINE> <DEDENT> except __builtin__ . Exception : <NEWLINE> <INDENT> self . this = this <NEWLINE> <DEDENT> <DEDENT>
def testContentTypeTokenGeneratorCreatesEquivalentGlobalTokens ( self ) : <NEWLINE> <INDENT> self . assertEqual ( <NEWLINE> <INDENT> len ( self . token_generator . generate ( scope . access_all ( ) ) ) , <NEWLINE> len ( basic_token_generator . generate ( scope . access_all ( ) ) ) , <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def test_startup_file ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . run_tool ( <STRING> ) <NEWLINE> startup_file = os . path . join ( self . data_dir , <STRING> ) <NEWLINE> assert os . path . isfile ( startup_file ) <NEWLINE> file_contents = self . tool . _convert_u2b ( json . load ( open ( startup_file , <STRING> ) ) ) <NEWLINE> assert file_contents [ <STRING> ] == self . tool . args <NEWLINE> assert file_contents [ <STRING> ] == self . tool . unknown_args <NEWLINE> <DEDENT>
def test_DWI2Tensor_outputs ( ) : <NEWLINE> <INDENT> output_map = dict ( tensor = dict ( ) , <NEWLINE> ) <NEWLINE> outputs = DWI2Tensor . output_spec ( ) <NEWLINE> for key , metadata in output_map . items ( ) : <NEWLINE> <INDENT> for metakey , value in metadata . items ( ) : <NEWLINE> <INDENT> yield assert_equal , getattr ( outputs . traits ( ) [ key ] , metakey ) , value <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from . jobs import Jobs <NEWLINE> from . job import Job <NEWLINE>
def forwards ( self , orm ) : <NEWLINE> <INDENT> db . create_table ( <STRING> , ( <NEWLINE> <INDENT> ( <STRING> , self . gf ( <STRING> ) ( primary_key = True ) ) , <NEWLINE> ( <STRING> , self . gf ( <STRING> ) ( max_length = 255 ) ) , <NEWLINE> <DEDENT> ) ) <NEWLINE> db . send_create_signal ( <STRING> , [ <STRING> ] ) <NEWLINE> db . add_column ( <STRING> , <STRING> , <NEWLINE> <INDENT> self . gf ( <STRING> ) ( to = orm [ <STRING> ] , null = True , blank = True ) , <NEWLINE> keep_default = False ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> HOST = <STRING> <NEWLINE> PORT = 50001 <NEWLINE> message_list = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in message_list : <NEWLINE> <INDENT> s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) <NEWLINE> s . bind ( ( HOST , PORT ) ) <NEWLINE> s . listen ( 1 ) <NEWLINE> conn , addr = s . accept ( ) <NEWLINE> conn . send ( i ) <NEWLINE> conn . close ( ) <NEWLINE> <DEDENT> <DEDENT>
from __future__ import print_function <NEWLINE> import sys <NEWLINE> import os . path <NEWLINE> import json <NEWLINE> import argparse <NEWLINE> import numpy as np <NEWLINE> import datetime <NEWLINE> sys . path . append ( os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) ) <NEWLINE> import s2p <NEWLINE> from s2plib . config import cfg <NEWLINE> from s2plib import common <NEWLINE> from s2plib import initialization <NEWLINE>
def get ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> bit_value = DAISY20 . get ( self . identifier ) & 0x3f8 <NEWLINE> self . buffer . append ( bit_value ) <NEWLINE> bfr = tuple ( buf for buf in self . buffer if buf is not None ) <NEWLINE> mask = 0x03ff <NEWLINE> for buffer_value in bfr : <NEWLINE> <INDENT> mask = mask & buffer_value <NEWLINE> <DEDENT> if DAISY20 . convert ( mask ^ bit_value ) < 0.2 : <NEWLINE> <INDENT> value = bit_value <NEWLINE> DAISY20 . last_value_set = value <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> value = DAISY20 . last_value_set <NEWLINE> <DEDENT> return DAISY20 . convert ( value ) <NEWLINE> <DEDENT>
def inactivate ( self ) : <NEWLINE> <INDENT> assert self . is_active , ( <STRING> ) <NEWLINE> self . is_active = False <NEWLINE> <DEDENT>
class TrafficCardClass ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . balance = 0 <NEWLINE> <DEDENT> def charge ( self , amount ) : <NEWLINE> <INDENT> self . balance += amount <NEWLINE> <DEDENT> def pay ( self , amount ) : <NEWLINE> <INDENT> self . balance -= amount <NEWLINE> <DEDENT> def check ( self ) : <NEWLINE> <INDENT> return self . balance <NEWLINE> <DEDENT> <DEDENT>
def setupDB ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not os . path . isfile ( globalVars . dbPath ) : <NEWLINE> <INDENT> logging . error ( <STRING> ) <NEWLINE> dbConn , dbcursor = dbConnection . dbConnect ( ) <NEWLINE> dbcursor . execute ( <STRING> ) <NEWLINE> dbConnection . dbClose ( dbConn ) <NEWLINE> logging . info ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from reactnativebackend . settings . staging import * <NEWLINE> DATABASES = { <NEWLINE> <INDENT> <STRING> : { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE>
import boto3 <NEWLINE> cloudwatch = boto3 . client ( <STRING> ) <NEWLINE> cloudwatch . put_metric_data ( <NEWLINE> <INDENT> MetricData = [ <NEWLINE> <INDENT> { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : [ <NEWLINE> <INDENT> { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> <DEDENT> } , <NEWLINE> <DEDENT> ] , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : 1.0 <NEWLINE> <DEDENT> } , <NEWLINE> <DEDENT> ] , <NEWLINE> Namespace = <STRING> <NEWLINE> <DEDENT> ) <NEWLINE>
import arcade <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> arcade . open_window ( <STRING> , 600 , 600 ) <NEWLINE> arcade . set_background_color ( arcade . color . WHEAT ) <NEWLINE> arcade . run ( ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import sys <NEWLINE> warnings = <STRING> <NEWLINE> try : <NEWLINE> <INDENT> import unicodedata <NEWLINE> def U ( name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> u = unicodedata . lookup ( name ) <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> u = None <NEWLINE> global warnings <NEWLINE> warnings += <STRING> % name <NEWLINE> <DEDENT> return u <NEWLINE> <DEDENT> <DEDENT> except ImportError : <NEWLINE> <INDENT> warnings += <STRING> <NEWLINE> U = lambda name : None <NEWLINE> <DEDENT> from sympy . printing . conventions import split_super_sub <NEWLINE> __all__ = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ] <NEWLINE> <DEDENT> _use_unicode = False <NEWLINE>
def polygonSelection ( self ) : <NEWLINE> <INDENT> if self . tool : <NEWLINE> <INDENT> self . tool . reset ( ) <NEWLINE> <DEDENT> self . request = <STRING> <NEWLINE> self . tool = selectPolygon ( self . iface , self . themeColor , 1 ) <NEWLINE> self . tool . setAction ( self . actions [ 4 ] ) <NEWLINE> self . iface . connect ( self . tool , SIGNAL ( <STRING> ) , self . returnedBounds ) <NEWLINE> self . iface . mapCanvas ( ) . setMapTool ( self . tool ) <NEWLINE> self . sb . showMessage ( self . tr ( <STRING> ) ) <NEWLINE> <DEDENT>
def event_to_num_steps ( self , event ) : <NEWLINE> <INDENT> if self . _num_steps is not None : <NEWLINE> <INDENT> return self . _num_steps [ event ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> <DEDENT>
def test_field_table ( self ) : <NEWLINE> <INDENT> w = Writer ( ) <NEWLINE> expect ( w . write_table ) . args ( { <STRING> : <STRING> } ) . side_effect ( <NEWLINE> <INDENT> lambda * args : w . _output_buffer . extend ( <STRING> ) ) <NEWLINE> <DEDENT> w . _field_table ( { <STRING> : <STRING> } ) <NEWLINE> assert_equals ( <STRING> , w . _output_buffer ) <NEWLINE> <DEDENT>
def myAccumulate ( iterable , func = operator . add ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> it = iter ( iterable ) <NEWLINE> try : <NEWLINE> <INDENT> total = next ( it ) <NEWLINE> <DEDENT> except StopIteration : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> yield total <NEWLINE> for element in it : <NEWLINE> <INDENT> total = func ( total , element ) <NEWLINE> yield total <NEWLINE> <DEDENT> <DEDENT>
__author__ = <STRING> <NEWLINE> import paramiko <NEWLINE> import argparse <NEWLINE> import time <NEWLINE> import re <NEWLINE> <STRING> <NEWLINE> switches_this_script_works_on = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE>
class OIDTemplate ( object ) : <NEWLINE> <INDENT> __slots__ = ( <STRING> , <STRING> ) <NEWLINE> def __init__ ( self , initializer = <STRING> , oid_cls = OID ) : <NEWLINE> <INDENT> self . _initializer = initializer <NEWLINE> self . _oid_cls = oid_cls <NEWLINE> <DEDENT> def new ( self , data = <STRING> ) : <NEWLINE> <INDENT> obj = self . _oid_cls ( ) <NEWLINE> obj . open ( self . _initializer + data ) <NEWLINE> return obj <NEWLINE> <DEDENT> <DEDENT>
def handler_all ( f ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> registrations_global . append ( f ) <NEWLINE> return f <NEWLINE> <DEDENT>
def stderr ( self ) : <NEWLINE> <INDENT> if self . _stderr is None : <NEWLINE> <INDENT> self . _read_stderr ( ) <NEWLINE> <DEDENT> return self . _stderr <NEWLINE> <DEDENT>
def raw_exec ( command , arguments ) : <NEWLINE> <INDENT> return subprocess . Popen ( ( command , ) + arguments , <NEWLINE> <INDENT> stdin = subprocess . PIPE , <NEWLINE> stdout = subprocess . PIPE , <NEWLINE> stderr = subprocess . STDOUT ) <NEWLINE> <DEDENT> <DEDENT>
from django . contrib import admin <NEWLINE> from django . conf . urls import patterns <NEWLINE> from django . contrib import admin , messages <NEWLINE> from django . core . paginator import Paginator , EmptyPage , PageNotAnInteger <NEWLINE> from django . http import HttpResponseRedirect , HttpResponse <NEWLINE> from django . shortcuts import render <NEWLINE> from django . template import RequestContext , loader <NEWLINE> from website . models import * <NEWLINE> from event_counter . admin import * <NEWLINE> from website . forms import * <NEWLINE> import logging <NEWLINE> logger = logging . getLogger ( <STRING> ) <NEWLINE>
def init ( context ) : <NEWLINE> <INDENT> context . s1 = <STRING> <NEWLINE> context . s2 = <STRING> <NEWLINE> context . counter = 0 <NEWLINE> context . window = 60 <NEWLINE> context . ratio = 15 <NEWLINE> context . up_cross_up_limit = False <NEWLINE> context . down_cross_down_limit = False <NEWLINE> context . entry_score = 2 <NEWLINE> subscribe ( [ context . s1 , context . s2 ] ) <NEWLINE> <DEDENT>
def test_build_query_in_with_set ( self ) : <NEWLINE> <INDENT> self . sq . add_filter ( SQ ( content = <STRING> ) ) <NEWLINE> self . sq . add_filter ( SQ ( title__in = set ( [ <STRING> , <STRING> ] ) ) ) <NEWLINE> self . assertEqual ( self . sq . build_query ( ) , <STRING> ) <NEWLINE> <DEDENT>
def __init__ ( self , id , name , descr ) : <NEWLINE> <INDENT> JQuest . __init__ ( self , id , name , descr ) <NEWLINE> self . questItemIds = [ ROUGH_JEWEL ] <NEWLINE> <DEDENT>
def plotVideoAvg ( feat ) : <NEWLINE> <INDENT> feat = feat . sum ( axis = 0 ) / feat . shape [ 0 ] <NEWLINE> fig = plt . figure ( ) <NEWLINE> plt . bar ( list ( range ( feat . shape [ 0 ] ) ) , feat ) <NEWLINE> plt . show ( ) <NEWLINE> <DEDENT>
def test_invalid_key ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> session = self . backend ( <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> session . save ( ) <NEWLINE> <DEDENT> except AttributeError : <NEWLINE> <INDENT> self . fail ( <STRING> ) <NEWLINE> <DEDENT> self . assertNotEqual ( session . session_key , <STRING> ) <NEWLINE> self . assertEqual ( session . get ( <STRING> ) , None ) <NEWLINE> session . delete ( ) <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> session . delete ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def backwards ( self , orm ) : <NEWLINE> <INDENT> db . delete_unique ( <STRING> , [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] ) <NEWLINE> db . delete_table ( <STRING> ) <NEWLINE> db . delete_table ( <STRING> ) <NEWLINE> db . delete_table ( <STRING> ) <NEWLINE> db . delete_table ( <STRING> ) <NEWLINE> db . delete_table ( <STRING> ) <NEWLINE> db . delete_table ( <STRING> ) <NEWLINE> db . delete_table ( <STRING> ) <NEWLINE> db . delete_table ( <STRING> ) <NEWLINE> db . delete_table ( <STRING> ) <NEWLINE> <DEDENT>
def add_arguments ( self , parser ) : <NEWLINE> <INDENT> parser . add_argument ( <STRING> , metavar = <STRING> , type = str , <NEWLINE> <INDENT> help = <STRING> ) <NEWLINE> <DEDENT> parser . add_argument ( <STRING> , <NEWLINE> <INDENT> dest = <STRING> , <NEWLINE> action = <STRING> , <NEWLINE> default = None , <NEWLINE> help = <STRING> ) <NEWLINE> <DEDENT> self . add_realm_args ( parser ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from braubuddy . thermostat . base import IThermostat <NEWLINE> from braubuddy . thermostat . simpleranged import SimpleRangedThermostat <NEWLINE>
from nose . tools import * <NEWLINE> from mock import patch <NEWLINE> import mock <NEWLINE> from . import nose_helper <NEWLINE> from kiwi . exceptions import * <NEWLINE> from kiwi . storage . loop_device import LoopDevice <NEWLINE>
class Migration ( migrations . Migration ) : <NEWLINE> <INDENT> dependencies = [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE> operations = [ <NEWLINE> <INDENT> migrations . AddField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> field = models . BooleanField ( default = False , verbose_name = <STRING> ) , <NEWLINE> <DEDENT> ) , <NEWLINE> migrations . AddField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> field = models . URLField ( blank = True , max_length = 1024 , null = True , verbose_name = <STRING> ) , <NEWLINE> <DEDENT> ) , <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT>
from __future__ import print_function , division <NEWLINE> import os , re <NEWLINE> import logging <NEWLINE> import subprocess as sp <NEWLINE> from astropy . coordinates import SkyCoord <NEWLINE>
def got_key ( client ) : <NEWLINE> <INDENT> infile = open ( <STRING> , <STRING> ) <NEWLINE> data = infile . read ( ) <NEWLINE> infile . close ( ) <NEWLINE> stream = andrena . FileTransfer ( None , client ) <NEWLINE> stream . meta = <STRING> <NEWLINE> stream . buffer = data <NEWLINE> client . send ( stream ) <NEWLINE> <DEDENT>
def search_equality ( text ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> pattern = <STRING> <NEWLINE> equality = re . search ( pattern , text ) <NEWLINE> if equality : <NEWLINE> <INDENT> return equality . group ( ) [ 4 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT>
class UnaryOperator ( object ) : <NEWLINE> <INDENT> NAME = <STRING> <NEWLINE> def __init__ ( self , argument ) : <NEWLINE> <INDENT> self . argument = argument <NEWLINE> <DEDENT> def __repr__ ( self ) : <NEWLINE> <INDENT> return <STRING> % ( <NEWLINE> <INDENT> self . NAME , <NEWLINE> isinstance ( self . argument , ListRedirect ) and self . argument . reduce ( ) or self . argument ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def AppendDictionary ( d1 , d2 ) : <NEWLINE> <INDENT> for tag , value in d2 . iteritems ( ) : <NEWLINE> <INDENT> if tag in d1 : <NEWLINE> <INDENT> d1 [ tag ] = d1 [ tag ] + <STRING> + value <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d1 [ tag ] = value <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class Migration ( migrations . Migration ) : <NEWLINE> <INDENT> dependencies = [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE> operations = [ <NEWLINE> <INDENT> migrations . AlterField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> field = models . DecimalField ( decimal_places = 2 , default = 0 , max_digits = 5 ) , <NEWLINE> <DEDENT> ) , <NEWLINE> migrations . AlterField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> field = models . IntegerField ( default = 0 ) , <NEWLINE> <DEDENT> ) , <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import json <NEWLINE> from optparse import make_option <NEWLINE> from textwrap import dedent <NEWLINE> from django . core . management . base import BaseCommand , CommandError <NEWLINE> from xmodule . modulestore . django import modulestore <NEWLINE> from xmodule . modulestore . inheritance import own_metadata , compute_inherited_metadata <NEWLINE> from xblock_discussion import DiscussionXBlock <NEWLINE> from xblock . fields import Scope <NEWLINE> from opaque_keys import InvalidKeyError <NEWLINE> from opaque_keys . edx . keys import CourseKey <NEWLINE> FILTER_LIST = [ <STRING> ] <NEWLINE> INHERITED_FILTER_LIST = [ <STRING> , <STRING> ] <NEWLINE>
def _table_stub ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not self . _admin : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> return self . _table_stub_internal <NEWLINE> <DEDENT>
import os <NEWLINE> import urllib <NEWLINE> import json <NEWLINE> import sys <NEWLINE> import ast <NEWLINE> import argparse <NEWLINE> import utils <NEWLINE>
from django . template import Library , Node , Variable , loader <NEWLINE> from django . template . context import Context <NEWLINE> register = Library ( ) <NEWLINE>
class ScalarFunction ( Function ) : <NEWLINE> <INDENT> def _get_class_name ( self , name ) : <NEWLINE> <INDENT> if name is None : <NEWLINE> <INDENT> name = util . guid ( ) <NEWLINE> <DEDENT> return <STRING> . format ( name ) <NEWLINE> <DEDENT> def _type_signature ( self , inputs , output ) : <NEWLINE> <INDENT> input_type = _to_input_sig ( inputs ) <NEWLINE> output = validate_type ( output ) <NEWLINE> output_type = rules . shape_like_flatargs ( output ) <NEWLINE> return input_type , output_type <NEWLINE> <DEDENT> <DEDENT>
def format_account ( service_name , data ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if <STRING> not in data : <NEWLINE> <INDENT> raise KeyError ( <STRING> ) <NEWLINE> <DEDENT> account = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : service_name , <NEWLINE> <STRING> : data [ <STRING> ] , <NEWLINE> <STRING> : <STRING> <NEWLINE> <DEDENT> } <NEWLINE> if ( data . has_key ( service_name ) <NEWLINE> <INDENT> and data [ service_name ] . has_key ( <STRING> ) <NEWLINE> and data [ service_name ] [ <STRING> ] . has_key ( <STRING> ) ) : <NEWLINE> account [ <STRING> ] = data [ service_name ] [ <STRING> ] [ <STRING> ] <NEWLINE> <DEDENT> return account <NEWLINE> <DEDENT>
from . signals import model_activations_changed , model_activations_updated <NEWLINE> from . version import __version__ <NEWLINE> default_app_config = <STRING> <NEWLINE>
<STRING> <NEWLINE> from __future__ import absolute_import <NEWLINE> from . _error import Error <NEWLINE> from . _error import OutputFormatError <NEWLINE> from . _renderer import OUTPUT_FORMATS <NEWLINE> from . _renderer import render <NEWLINE> from . _rst import register_rst_directive <NEWLINE> VERSION = <STRING> <NEWLINE> __all__ = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <DEDENT> ] <NEWLINE>
import json <NEWLINE> import csv <NEWLINE> PATH = <STRING> <NEWLINE> OUT = <STRING> <NEWLINE>
def convert ( reset , clean ) : <NEWLINE> <INDENT> conv = EumssiConverter ( <STRING> , dw_a_map ) <NEWLINE> if reset : <NEWLINE> <INDENT> conv . reset ( ) <NEWLINE> <DEDENT> if clean : <NEWLINE> <INDENT> conv . clean ( ) <NEWLINE> <DEDENT> conv . run ( ) <NEWLINE> <DEDENT>
class _SingleArgumentFunctionWithCudnn ( _SingleArgumentFunction ) : <NEWLINE> <INDENT> def __init__ ( self , use_cudnn , func , * args , ** kwargs ) : <NEWLINE> <INDENT> super ( _SingleArgumentFunctionWithCudnn , self ) . __init__ ( <NEWLINE> <INDENT> func , * args , ** kwargs ) <NEWLINE> <DEDENT> self . use_cudnn = use_cudnn <NEWLINE> <DEDENT> def __call__ ( self , x ) : <NEWLINE> <INDENT> with configuration . using_config ( <STRING> , self . use_cudnn ) : <NEWLINE> <INDENT> return super ( _SingleArgumentFunctionWithCudnn , self ) . __call__ ( x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class Waypoint : <NEWLINE> <INDENT> def __init__ ( self , agent , x , y , z , arrival , duration ) : <NEWLINE> <INDENT> self . agent = agent <NEWLINE> self . x = x <NEWLINE> self . y = y <NEWLINE> self . z = z <NEWLINE> self . arrival = arrival <NEWLINE> self . duration = duration <NEWLINE> <DEDENT> def __lt__ ( self , other ) : <NEWLINE> <INDENT> return self . arrival < other . arrival <NEWLINE> <DEDENT> def __repr__ ( self ) : <NEWLINE> <INDENT> return <STRING> . format ( self . agent , self . arrival , self . x , self . y , self . z ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import os <NEWLINE> import time <NEWLINE> import unittest <NEWLINE> from test . fork_wait import ForkWait <NEWLINE> from test . support import run_unittest , reap_children <NEWLINE> if not hasattr ( os , <STRING> ) : <NEWLINE> <INDENT> raise unittest . SkipTest ( <STRING> ) <NEWLINE> <DEDENT> if not hasattr ( os , <STRING> ) : <NEWLINE> <INDENT> raise unittest . SkipTest ( <STRING> ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> __version__ = <STRING> <NEWLINE> import anydbm <NEWLINE> import whichdb <NEWLINE> db = anydbm . open ( <STRING> , <STRING> ) <NEWLINE> db [ <STRING> ] = <STRING> <NEWLINE> db . close ( ) <NEWLINE> print ( whichdb . whichdb ( <STRING> ) ) <NEWLINE>
<STRING> <NEWLINE> from rest_framework import serializers <NEWLINE> from rest_framework . reverse import reverse <NEWLINE> from student . models import CourseEnrollment , User <NEWLINE> from certificates . models import certificate_status_for_student , CertificateStatuses <NEWLINE>
def test_is_not_instance ( self , instance ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . assertFalse ( real . real_number . is_instance ( instance ) ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import smtplib <NEWLINE> from email . mime . multipart import MIMEMultipart <NEWLINE> from email . mime . text import MIMEText <NEWLINE>
<STRING> <NEWLINE> from __future__ import unicode_literals <NEWLINE> import logging <NEWLINE> __author__ = <STRING> <NEWLINE> __date__ = <STRING> <NEWLINE> __copyright__ = <STRING> <NEWLINE> __credits__ = [ <STRING> , ] <NEWLINE> log = logging . getLogger ( __name__ ) <NEWLINE>
import random <NEWLINE> for x in range ( 1 , 11 ) : <NEWLINE> <INDENT> throw_1 = random . randint ( 1 , 6 ) <NEWLINE> throw_2 = random . randint ( 1 , 6 ) <NEWLINE> total = throw_1 + throw_2 <NEWLINE> print ( total ) <NEWLINE> if ( total == 7 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if ( total == 11 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if throw_1 == throw_2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import unittest <NEWLINE> from puzz import * <NEWLINE> import os <NEWLINE>
def fake_marathon_response ( ) : <NEWLINE> <INDENT> current_dir = os . path . join ( os . path . dirname ( __file__ ) ) <NEWLINE> config_file = os . path . abspath ( <NEWLINE> <INDENT> os . path . join ( current_dir , <STRING> , <STRING> ) <NEWLINE> <DEDENT> ) <NEWLINE> with open ( config_file , <STRING> ) as f : <NEWLINE> <INDENT> return json . loads ( f . read ( ) ) <NEWLINE> <DEDENT> <DEDENT>
class Randomizer ( object ) : <NEWLINE> <INDENT> @ staticmethod <NEWLINE> def bool_on_percentage ( percentage = 0 ) : <NEWLINE> <INDENT> return random . randint ( 0 , 100 ) < percentage <NEWLINE> <DEDENT> <DEDENT>
def compile_jsmin ( instr , outfile ) : <NEWLINE> <INDENT> with open ( outfile , <STRING> ) as fw : <NEWLINE> <INDENT> compiler = sp . Popen ( [ JSMIN ] , stdin = sp . PIPE , stdout = sp . PIPE ) <NEWLINE> stout , sterr = compiler . communicate ( instr ) <NEWLINE> fw . write ( stout ) <NEWLINE> print ( <STRING> % fw . tell ( ) ) <NEWLINE> print ( <STRING> % ( 100 - fw . tell ( ) / len ( instr ) * 100 ) ) <NEWLINE> <DEDENT> <DEDENT>
class DBNode ( db . Model ) : <NEWLINE> <INDENT> id = db . Column ( db . Integer , primary_key = True , autoincrement = True ) <NEWLINE> hostname = db . Column ( db . String ( 128 ) ) <NEWLINE> ip = db . Column ( db . String ( 128 ) ) <NEWLINE> port = db . Column ( db . Integer , default = 0 ) <NEWLINE> def __init__ ( self , hostname , ip , port ) : <NEWLINE> <INDENT> self . hostname = hostname <NEWLINE> self . ip = ip <NEWLINE> self . port = port <NEWLINE> <DEDENT> <DEDENT>
def retranslateUi ( self , MainWindow ) : <NEWLINE> <INDENT> MainWindow . setWindowTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . defaultViewText . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . menuMen . setTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . actionClose . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . actionClose . setShortcut ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> <DEDENT>
class agilentMSOX3012A ( agilent3000A ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , * args , ** kwargs ) : <NEWLINE> <INDENT> self . __dict__ . setdefault ( <STRING> , <STRING> ) <NEWLINE> super ( agilentMSOX3012A , self ) . __init__ ( * args , ** kwargs ) <NEWLINE> self . _analog_channel_count = 2 <NEWLINE> self . _digital_channel_count = 16 <NEWLINE> self . _channel_count = self . _analog_channel_count + self . _digital_channel_count <NEWLINE> self . _bandwidth = 100e6 <NEWLINE> self . _init_channels ( ) <NEWLINE> <DEDENT> <DEDENT>
class FilterAction ( Enum ) : <NEWLINE> <INDENT> discard = 0 <NEWLINE> bounce = 1 <NEWLINE> forward = 2 <NEWLINE> preserve = 3 <NEWLINE> <DEDENT>
def start_guesstotal ( self , db_session ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> mv_obj = db_session . query ( models . MiscValue ) . filter ( models . MiscValue . mv_key == <STRING> ) . one ( ) <NEWLINE> mv_obj . mv_value = <STRING> <NEWLINE> utils . add_to_public_chat_queue ( self , <STRING> ) <NEWLINE> <DEDENT>
def uniform_displace ( stepsize , coords , indices = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( indices ) : <NEWLINE> <INDENT> for i in indices : <NEWLINE> <INDENT> coords [ i ] += stepsize * rotations . vector_random_uniform_hypersphere ( 3 ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> for x in coords : <NEWLINE> <INDENT> x += stepsize * rotations . vector_random_uniform_hypersphere ( 3 ) <NEWLINE> <DEDENT> <DEDENT>
def _combine_attributes ( * attributes ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return reduce ( lambda a , b : str ( a ) + code . DELIMITER + str ( b ) , attributes ) <NEWLINE> <DEDENT>
def test_load_model_workaround ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> , None ) is not None : <NEWLINE> <INDENT> model_filename = <STRING> <NEWLINE> weight_filename = <STRING> <NEWLINE> <DEDENT> if os . getenv ( <STRING> , None ) is not None : <NEWLINE> <INDENT> model_filename = <STRING> <NEWLINE> weight_filename = <STRING> <NEWLINE> <DEDENT> model = KerasModelFeatureProducer . load_model_workaround ( <NEWLINE> <INDENT> model_filename , weight_filename ) <NEWLINE> <DEDENT> assert model . layers [ 0 ] . name == <STRING> <NEWLINE> <DEDENT>
def get_ip ( self ) : <NEWLINE> <INDENT> try : return self . info . get ( <STRING> ) <NEWLINE> except : pass <NEWLINE> <DEDENT>
class BlinkyRequestHandler ( http . server . BaseHTTPRequestHandler ) : <NEWLINE> <INDENT> def do_HEAD ( self ) : <NEWLINE> <INDENT> self . send_response ( 200 ) <NEWLINE> self . send_header ( <STRING> , <STRING> ) <NEWLINE> self . end_headers ( ) <NEWLINE> <DEDENT> def do_GET ( self ) : <NEWLINE> <INDENT> global led_status <NEWLINE> if led_status == gpio . LOW : <NEWLINE> <INDENT> self . wfile . write ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> led_status = gpio . HIGH <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . wfile . write ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> led_status = gpio . LOW <NEWLINE> <DEDENT> gpio . output ( led_pin , led_status ) <NEWLINE> <DEDENT> <DEDENT>
class Migration ( migrations . Migration ) : <NEWLINE> <INDENT> dependencies = [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE> operations = [ <NEWLINE> <INDENT> migrations . AddField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> field = models . IntegerField ( null = True , unique = True ) , <NEWLINE> preserve_default = True , <NEWLINE> <DEDENT> ) , <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT>
def baskara ( a , b , c ) : <NEWLINE> <INDENT> d = delta ( a , b , c ) <NEWLINE> if d < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif d == 0 : <NEWLINE> <INDENT> raiz = - b / ( 2 * a ) <NEWLINE> print ( <STRING> % raiz ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raiz1 = ( - b + math . sqrt ( delta ) ) / ( 2 * a ) <NEWLINE> raiz2 = ( - b - math . sqrt ( delta ) ) / ( 2 * a ) <NEWLINE> print ( <STRING> % ( raiz1 , raiz2 ) ) <NEWLINE> <DEDENT> <DEDENT>
import json <NEWLINE> import urllib2 <NEWLINE> import re <NEWLINE> from bs4 import BeautifulSoup <NEWLINE> from order import Order <NEWLINE> from goods import Goods <NEWLINE> import sys <NEWLINE> reload ( sys ) <NEWLINE> sys . setdefaultencoding ( <STRING> ) <NEWLINE>
import six <NEWLINE> from ... errors . saklientexception import SaklientException <NEWLINE> from . . client import Client <NEWLINE> from . resource import Resource <NEWLINE> from ... util import Util <NEWLINE> import saklient <NEWLINE> str = six . text_type <NEWLINE>
from kivy . app import App <NEWLINE> from kivy . uix . widget import Widget <NEWLINE> from kivy . graphics import Color , Ellipse , Rectangle , RoundedRectangle <NEWLINE> from kivy . lang import Builder <NEWLINE> TEXTURE = <STRING> <NEWLINE> YELLOW = ( 1 , .7 , 0 ) <NEWLINE> ORANGE = ( 1 , .45 , 0 ) <NEWLINE> RED = ( 1 , 0 , 0 ) <NEWLINE> WHITE = ( 1 , 1 , 1 ) <NEWLINE>
def RVKFooDxrqYXAX ( ) : <NEWLINE> <INDENT> pspict , fig = SinglePicture ( <STRING> ) <NEWLINE> pspict . dilatation ( 1 ) <NEWLINE> tableau = <STRING> <NEWLINE> solution = <STRING> <NEWLINE> solution_substitution = <STRING> <NEWLINE> sudoku = SudokuGrid ( tableau , length = 0.7 ) <NEWLINE> pspict . DrawGraphs ( sudoku ) <NEWLINE> pspict . comment = <STRING> <NEWLINE> fig . no_figure ( ) <NEWLINE> fig . conclude ( ) <NEWLINE> fig . write_the_file ( ) <NEWLINE> <DEDENT>
def mount ( node_path ) : <NEWLINE> <INDENT> u = get_udisks1 ( ) <NEWLINE> u . mount ( node_path ) <NEWLINE> <DEDENT>
def test_parse_search ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> gc = GalaxyCLI ( args = [ <STRING> ] ) <NEWLINE> self . run_parse_common ( gc , <STRING> ) <NEWLINE> self . assertEqual ( gc . options . platforms , None ) <NEWLINE> self . assertEqual ( gc . options . galaxy_tags , None ) <NEWLINE> self . assertEqual ( gc . options . author , None ) <NEWLINE> <DEDENT>
def fwrap ( fn , value ) : <NEWLINE> <INDENT> iv = ( value , ) <NEWLINE> return lambda : fn ( iv [ 0 ] ) <NEWLINE> <DEDENT>
def _get_method ( method ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> module = method . split ( <STRING> ) <NEWLINE> _module_import = module [ 0 ] <NEWLINE> class_name = module [ - 1 ] <NEWLINE> module_import = __import__ ( _module_import , fromlist = [ class_name ] ) <NEWLINE> return getattr ( module_import , class_name ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import numpy <NEWLINE> import theano <NEWLINE> import theano . tensor as T <NEWLINE> from net . layerparams import LayerParams <NEWLINE> __author__ = <STRING> <NEWLINE> __copyright__ = <STRING> <NEWLINE> __credits__ = [ <STRING> , <STRING> ] <NEWLINE> __license__ = <STRING> <NEWLINE> __version__ = <STRING> <NEWLINE> __maintainer__ = <STRING> <NEWLINE> __email__ = <STRING> <NEWLINE> __status__ = <STRING> <NEWLINE>
def copy ( self ) : <NEWLINE> <INDENT> ret = super ( Chain , self ) . copy ( ) <NEWLINE> ret . _children = set ( ret . _children ) <NEWLINE> d = ret . __dict__ <NEWLINE> for name in ret . _children : <NEWLINE> <INDENT> copied = d [ name ] . copy ( ) <NEWLINE> copied . name = name <NEWLINE> d [ name ] = copied <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT>
def html_footer ( nome ) : <NEWLINE> <INDENT> if nome == None : <NEWLINE> <INDENT> footer = ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> footer = ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> + nome + <STRING> <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return footer <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from __future__ import print_function <NEWLINE> from __future__ import absolute_import <NEWLINE> import os <NEWLINE> import re <NEWLINE> from argparse import ArgumentParser <NEWLINE> from gnuradio import gr <NEWLINE> from . util_functions import get_modname <NEWLINE> from . scm import SCMRepoFactory <NEWLINE>
<STRING> <NEWLINE> AWS_SECRET_KEY = <STRING> <NEWLINE> AWS_ACCESS_KEY = <STRING> <NEWLINE> AWS_BUCKET = <STRING> <NEWLINE> AWS_BASE_URL = <STRING> <NEWLINE> AWS_EXPIRY_TIME = 60 * 30 <NEWLINE> AWS_FORCE_HTTP = True <NEWLINE> UPLOAD_TO_S3 = False <NEWLINE> MEDIA_URL = <STRING> <NEWLINE> <STRING> <NEWLINE> import os <NEWLINE> from boto . s3 . connection import S3Connection <NEWLINE> from boto . s3 . key import Key <NEWLINE> from django . conf import settings <NEWLINE> if settings . UPLOAD_TO_S3 : <NEWLINE> <INDENT> conn = S3Connection ( settings . AWS_ACCESS_KEY , settings . AWS_SECRET_KEY ) <NEWLINE> bucket = conn . get_bucket ( settings . AWS_BUCKET ) <NEWLINE> <DEDENT>
def toCSV ( fname , data , labels = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if len ( data ) == 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if labels is None : <NEWLINE> <INDENT> labels = data . keys ( ) <NEWLINE> <DEDENT> data = [ data [ l ] for l in labels ] <NEWLINE> writer = csv . writer ( fname , delimiter = <STRING> ) <NEWLINE> writer . writerow ( labels ) <NEWLINE> writer . writerows ( zip ( * data ) ) <NEWLINE> <DEDENT>
def title ( self ) : <NEWLINE> <INDENT> title = _ ( <STRING> . format ( self . title_month ) ) <NEWLINE> if self . location and self . location . location_type . name . upper ( ) == <STRING> : <NEWLINE> <INDENT> return <STRING> . format ( self . location . name , <NEWLINE> <INDENT> self . location . site_code , <NEWLINE> self . location . metadata . get ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> return title <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from sqlalchemy import Column , Sequence <NEWLINE> from sqlalchemy . types import Integer , Unicode , UnicodeText , DateTime , Boolean <NEWLINE> from onlinelinguisticdatabase . model . meta import Base , now <NEWLINE>
def test_hmm_validation ( ) : <NEWLINE> <INDENT> assert_raises ( ValueError , MultinomialHMM ( alpha = 0 ) . fit , X , y , lengths ) <NEWLINE> assert_raises ( ValueError , MultinomialHMM ( alpha = - 1 ) . fit , X , y , lengths ) <NEWLINE> <DEDENT>
from setuptools import setup <NEWLINE> from os . path import join , dirname <NEWLINE> execfile ( join ( dirname ( __file__ ) , <STRING> , <STRING> ) ) <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> version = VERSION , <NEWLINE> author = <STRING> , <NEWLINE> author_email = <STRING> , <NEWLINE> packages = [ <STRING> ] , <NEWLINE> url = <STRING> , <NEWLINE> license = <STRING> , <NEWLINE> description = <STRING> , <NEWLINE> long_description = open ( <STRING> ) . read ( ) , <NEWLINE> install_requires = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> ] , <NEWLINE> <DEDENT> <DEDENT> ) <NEWLINE>
import heapq as hq <NEWLINE> import math <NEWLINE> import sys <NEWLINE> inf = math . inf <NEWLINE>
def get ( entity_id ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return Entity . get ( Entity . id == entity_id ) <NEWLINE> <DEDENT> except DoesNotExist : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT>
def single_search_processor ( request ) : <NEWLINE> <INDENT> context = { } <NEWLINE> single_search_on = False <NEWLINE> try : <NEWLINE> <INDENT> if settings . SINGLE_SEARCH_ENABLED : <NEWLINE> <INDENT> single_search_on = True <NEWLINE> <DEDENT> <DEDENT> except AttributeError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> context = { <NEWLINE> <INDENT> <STRING> : single_search_on , <NEWLINE> <DEDENT> } <NEWLINE> return context <NEWLINE> <DEDENT>
class DummyPublisher ( BasePublisher ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def open ( self ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> def close ( self ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> def send ( self , msg ) : <NEWLINE> <INDENT> print ( <STRING> . format ( msg ) ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT>
def test_authorize_user_trailing_slash ( self ) : <NEWLINE> <INDENT> req = webob . Request . blank ( <STRING> ) <NEWLINE> req . headers [ <STRING> ] = <STRING> <NEWLINE> req . headers [ <STRING> ] = <STRING> <NEWLINE> req . headers [ <STRING> ] = <STRING> <NEWLINE> result = req . get_response ( fakes . wsgi_app ( use_no_auth = True ) ) <NEWLINE> self . assertEqual ( result . status , <STRING> ) <NEWLINE> self . assertEqual ( result . headers [ <STRING> ] , <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class MasterConfig ( Config ) : <NEWLINE> <INDENT> api = CommonApiConfig ( common_logger = <STRING> , <NEWLINE> <INDENT> access_logger = <STRING> , <NEWLINE> port = 8080 ) <NEWLINE> <DEDENT> backend = ConfigField ( type = str , required = True , default = <STRING> ) <NEWLINE> backend_config = ConfigField ( type = dict , required = True , default = dict ( ) ) <NEWLINE> plugins = PluginsConfig ( ) <NEWLINE> <DEDENT>
import json <NEWLINE> import logging <NEWLINE> import logging . handlers <NEWLINE> import os <NEWLINE> import shutil <NEWLINE> import sys <NEWLINE> import traceback <NEWLINE> from argparse import ArgumentParser <NEWLINE> from pyani import anib , anim , tetra , pyani_config , pyani_files , pyani_graphics <NEWLINE> from pyani . run_multiprocessing import multiprocessing_run <NEWLINE> from pyani . pyani_config import params_mpl , params_r <NEWLINE>
def getMonthEndDates ( timestamps ) : <NEWLINE> <INDENT> newTS = [ ] <NEWLINE> temp = timestamps [ 0 ] . month <NEWLINE> for x in range ( 0 , len ( timestamps ) - 1 ) : <NEWLINE> <INDENT> if ( temp != timestamps [ x ] . month ) : <NEWLINE> <INDENT> newTS . append ( timestamps [ x - 1 ] ) <NEWLINE> temp = timestamps [ x ] . month <NEWLINE> <DEDENT> <DEDENT> newTS . append ( timestamps [ len ( timestamps ) - 1 ] ) <NEWLINE> return newTS <NEWLINE> <DEDENT>
def JSONrepr ( self ) : <NEWLINE> <INDENT> for k , ( _ , required ) in self . props . items ( ) : <NEWLINE> <INDENT> if required and k not in self . properties : <NEWLINE> <INDENT> rtype = getattr ( self , <STRING> , <STRING> ) <NEWLINE> raise ValueError ( <NEWLINE> <INDENT> <STRING> % ( k , rtype ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> self . validate ( ) <NEWLINE> if self . properties : <NEWLINE> <INDENT> return self . resource <NEWLINE> <DEDENT> elif hasattr ( self , <STRING> ) : <NEWLINE> <INDENT> return { <STRING> : self . resource_type } <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return { } <NEWLINE> <DEDENT> <DEDENT>
from distutils . core import setup , Extension <NEWLINE> setup ( name = <STRING> , version = <STRING> , ext_modules = [ Extension ( <STRING> , [ <STRING> ] ) ] ) <NEWLINE>
def init ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . ajouter_filtre ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> self . ajouter_filtre ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> <DEDENT>
def n ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return np . sum ( self . h . values ( ) ) <NEWLINE> <DEDENT>
def __unicode__ ( self ) : <NEWLINE> <INDENT> return <STRING> % ( self . identifier , self . msisdn , <NEWLINE> <INDENT> self . smstext ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import yaml <NEWLINE> size = 0 <NEWLINE> MIN_SIZE_KEY = <STRING> <NEWLINE> DEFAULT_MIN_SIZE = 1 <NEWLINE> MAX_SIZE_KEY = <STRING> <NEWLINE> DEFAULT_MAX_SIZE = 1 <NEWLINE> CONTAINER_IMAGE_KEY = <STRING> <NEWLINE> DEFAULT_CONTAINER_IMAGE = <STRING> <NEWLINE> DOCKER_ENV_KEY = <STRING> <NEWLINE> DEFAULT_DOCKER_ENV = { } <NEWLINE>
def process_connect ( self ) : <NEWLINE> <INDENT> if self . http_data . has_keepalive ( ) : <NEWLINE> <INDENT> self . keep_alive = True <NEWLINE> <DEDENT> self . current_destination = self . get_destination_from_data ( ) <NEWLINE> if TestController . match_monitored_domains ( self . current_destination . host ) : <NEWLINE> <INDENT> self . redirect_destination ( ) <NEWLINE> <DEDENT> self . send_data ( socket_to = self . request , data = <STRING> ) <NEWLINE> self . forward_https_channel ( ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import os <NEWLINE> from PIL import Image , ImageEnhance <NEWLINE> from sys import argv , exit , stderr <NEWLINE>
class LoggingStatsd ( DogStatsd ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def _report ( self , metric , metric_type , value , tags , sample_rate ) : <NEWLINE> <INDENT> logger . debug ( <STRING> , metric , metric_type , value ) <NEWLINE> return super ( ) . _report ( metric , metric_type , value , tags , sample_rate ) <NEWLINE> <DEDENT> <DEDENT>
def reset ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . sensors = [ random . uniform ( - 30. , 30. ) , 0.0 , 0.0 ] <NEWLINE> if self . render : <NEWLINE> <INDENT> if self . server . clients > 0 : <NEWLINE> <INDENT> self . server . send ( [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def dotset ( obj , keys , value ) : <NEWLINE> <INDENT> attrs = keys . split ( <STRING> ) <NEWLINE> target = obj <NEWLINE> if <STRING> in keys : <NEWLINE> <INDENT> target = dotget ( obj , <STRING> . join ( attrs [ : - 1 ] ) ) <NEWLINE> <DEDENT> setattr ( target , attrs [ - 1 ] , value ) <NEWLINE> <DEDENT>
class OfferAdmin ( admin . ModelAdmin ) : <NEWLINE> <INDENT> fields = ( <STRING> , <STRING> ) <NEWLINE> if django . VERSION [ : 2 ] <= ( 1 , 5 ) : <NEWLINE> <INDENT> class Media : <NEWLINE> <INDENT> js = ( <STRING> , ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class Serializer ( django . core . serializers . json . Serializer ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def end_serialization ( self ) : <NEWLINE> <INDENT> if json . __version__ . split ( <STRING> ) >= [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> self . options . update ( { <STRING> : False } ) <NEWLINE> <DEDENT> json . dump ( <NEWLINE> <INDENT> self . objects , self . stream , cls = MAASJSONEncoder , ** self . options ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class GumballMachineProxy ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , gumball_machine ) : <NEWLINE> <INDENT> self . machine = gumball_machine <NEWLINE> <DEDENT> def __getattr__ ( self , attr ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> check_attr = getattr ( self . machine , attr ) <NEWLINE> if callable ( check_attr ) : <NEWLINE> <INDENT> def wrap_remote_call ( * args , ** kargs ) : <NEWLINE> <INDENT> return check_attr ( * args , ** kargs ) <NEWLINE> <DEDENT> return wrap_remote_call <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return check_attr <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class Arith ( ) : <NEWLINE> <INDENT> def __init__ ( self , a ) : <NEWLINE> <INDENT> self . a = a <NEWLINE> <DEDENT> def add ( self , b ) : <NEWLINE> <INDENT> return NUMBERS [ <NEWLINE> <INDENT> NUMBERS . index ( self . a ) + <NEWLINE> NUMBERS . index ( b ) <NEWLINE> ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_set_decimal_objective ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> prob = self . solver . create_problem ( ) <NEWLINE> prob . define ( <STRING> , lower = 3 , upper = 100 ) <NEWLINE> prob . set_objective ( Decimal ( <STRING> ) * prob . var ( <STRING> ) ) <NEWLINE> <DEDENT>
def warn_and_error ( a , b ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> 1 [ 2 ] <NEWLINE> <DEDENT>
def on_close ( self ) : <NEWLINE> <INDENT> new_controller_type = self . controller_type_combo . currentText ( ) <NEWLINE> new_controller_name = self . controller_name_text . text ( ) <NEWLINE> if new_controller_type == <STRING> : <NEWLINE> <INDENT> new_controller_address = self . ip_address_text . text ( ) <NEWLINE> <DEDENT> elif new_controller_type == <STRING> : <NEWLINE> <INDENT> new_controller_address = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> new_controller_address = <STRING> <NEWLINE> <DEDENT> self . new_controller_data = ( new_controller_type , new_controller_name , <NEWLINE> <INDENT> new_controller_address ) <NEWLINE> <DEDENT> <DEDENT>
def get_urls ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> from operator import itemgetter <NEWLINE> nice_urls = [ ] <NEWLINE> app = get_app ( <STRING> ) <NEWLINE> for model in get_models ( app ) : <NEWLINE> <INDENT> nice_urls . append ( { <STRING> : model ( ) . get_subclass_name ( ) } ) <NEWLINE> <DEDENT> nice_urls = sorted ( nice_urls , key = itemgetter ( <STRING> ) ) <NEWLINE> return nice_urls <NEWLINE> <DEDENT>
