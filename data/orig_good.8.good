def cb ( ) : <NEWLINE> <INDENT> from . Netconfig import Netconfig <NEWLINE> return Netconfig ( ) <NEWLINE> <DEDENT>
from __future__ import absolute_import <NEWLINE> import logging <NEWLINE> from logging . handlers import SysLogHandler <NEWLINE> from conf . appconfig import LOG_FORMAT , LOG_DATE , LOG_ROOT_LEVEL , TOTEM_ENV , LOG_IDENTIFIER <NEWLINE>
def splitByDeletions ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> splitObjects = [ ] <NEWLINE> isFirstIteration = True <NEWLINE> obj = None <NEWLINE> for tag , chunk in self . chunk_pairs : <NEWLINE> <INDENT> isNewObject = ( tag . isHeaderTag and tag . isDeleted ) <NEWLINE> if isNewObject or isFirstIteration : <NEWLINE> <INDENT> obj = YaffsObject ( self . object_id ) <NEWLINE> splitObjects . append ( obj ) <NEWLINE> isFirstIteration = False <NEWLINE> <DEDENT> obj . chunk_pairs . append ( ( tag , chunk ) ) <NEWLINE> <DEDENT> if len ( splitObjects ) > 1 or len ( splitObjects ) == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> return splitObjects <NEWLINE> <DEDENT>
from django . contrib import admin <NEWLINE> from fpr import models <NEWLINE> admin . site . register ( models . Format ) <NEWLINE> admin . site . register ( models . FormatGroup ) <NEWLINE> admin . site . register ( models . FormatVersion ) <NEWLINE> admin . site . register ( models . IDCommand ) <NEWLINE> admin . site . register ( models . IDRule ) <NEWLINE> admin . site . register ( models . IDTool ) <NEWLINE> admin . site . register ( models . FPRule ) <NEWLINE> admin . site . register ( models . FPCommand ) <NEWLINE> admin . site . register ( models . FPTool ) <NEWLINE>
class DiffsetAction ( AbstractAction ) : <NEWLINE> <INDENT> def __init__ ( self , documentNumber , fiscalYears ) : <NEWLINE> <INDENT> self . documentNumber = documentNumber <NEWLINE> self . fiscalYears = set ( fiscalYears ) <NEWLINE> <DEDENT> <DEDENT>
from layer import NeuralLayer <NEWLINE> from recurrent import RecurrentLayer , RecurrentNetwork <NEWLINE>
class AnnealingCountStopper ( BasicStopper ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , training_options , * args , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> super ( ) . __init__ ( training_options , * args , ** kwargs ) <NEWLINE> self . min_epochs = training_options [ <STRING> ] <NEWLINE> self . _annealing_left = training_options [ <STRING> ] <NEWLINE> <DEDENT> def improvement_ceased ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . _annealing_left -= 1 <NEWLINE> <DEDENT> def start_new_minibatch ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . trainer . epoch_number <= self . min_epochs : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return self . _annealing_left >= 0 <NEWLINE> <DEDENT> <DEDENT>
def timeout ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> loop . quit ( ) <NEWLINE> <DEDENT>
from __future__ import absolute_import , division , print_function <NEWLINE> import hashlib <NEWLINE> from os import remove , makedirs <NEWLINE> from os . path import exists , isdir <NEWLINE> from functools import partial <NEWLINE> from warnings import warn <NEWLINE> from types import FunctionType <NEWLINE> from . _decorator import experimental , deprecated <NEWLINE>
class Quote ( Group ) : <NEWLINE> <INDENT> def __str__ ( self ) : <NEWLINE> <INDENT> if not self . end : <NEWLINE> <INDENT> if [ x for x in self if isinstance ( x , Whitespace ) ] : <NEWLINE> <INDENT> self . start = <STRING> % self . start <NEWLINE> self . end = <STRING> <NEWLINE> <DEDENT> <DEDENT> return <STRING> % ( <NEWLINE> <INDENT> self . start , <STRING> . join ( unicode ( x ) for x in self ) , self . end ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def consume ( self , amount = 1 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> while self . quota < amount : <NEWLINE> <INDENT> delta = self . quota_manager . consume ( self . bucket , self . batch_size , <NEWLINE> <INDENT> consume_some = True ) <NEWLINE> <DEDENT> if not delta : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> self . quota += delta <NEWLINE> <DEDENT> self . quota -= amount <NEWLINE> return True <NEWLINE> <DEDENT>
def streem ( items , map = SIMPLE_MAP , reduce = None , starting_level = 0 , mandatory_levels = [ ] , mandatory_levels_all = False ) : <NEWLINE> <INDENT> return ( reduce or _REDUCE_DEFAULT ) ( NodeIterator ( <NEWLINE> <INDENT> SourceData ( items , map , reduce , starting_level , mandatory_levels , mandatory_levels_all ) ) ) <NEWLINE> <DEDENT> <DEDENT>
def resolve_windows ( self , window ) : <NEWLINE> <INDENT> if not window : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> res = [ window ] <NEWLINE> res . extend ( window . get_children ( ) ) <NEWLINE> return res <NEWLINE> <DEDENT>
import smtplib <NEWLINE> from email . MIMEMultipart import MIMEMultipart <NEWLINE> from email . MIMEBase import MIMEBase <NEWLINE> from email . MIMEText import MIMEText <NEWLINE> from email . Utils import COMMASPACE , formatdate <NEWLINE> from email import Encoders <NEWLINE> import os , datetime <NEWLINE>
def get_next_sequence_number ( name ) : <NEWLINE> <INDENT> connection = pymongo . MongoClient ( <STRING> ) <NEWLINE> db = connection . test <NEWLINE> counters = db . counters <NEWLINE> try : <NEWLINE> <INDENT> counter = counters . find_one_and_update ( filter = { <STRING> : name } , <NEWLINE> <INDENT> update = { <STRING> : { <STRING> : - 1 } } , <NEWLINE> upsert = True , <NEWLINE> return_document = pymongo . ReturnDocument . AFTER ) <NEWLINE> <DEDENT> <DEDENT> except Exception as e : <NEWLINE> <INDENT> print ( <STRING> , type ( e ) , e ) <NEWLINE> <DEDENT> counter_value = counter [ <STRING> ] <NEWLINE> return counter_value <NEWLINE> <DEDENT>
class TestCopyFromPy ( unittest . TestCase ) : <NEWLINE> <INDENT> def test_bool ( self ) : <NEWLINE> <INDENT> a = nd . empty ( <STRING> ) <NEWLINE> a [ ... ] = [ True , False , 1 , 0 , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> self . assertEqual ( nd . as_py ( a ) , [ True , False ] * 4 ) <NEWLINE> <DEDENT> <DEDENT>
def object_to_form ( self ) : <NEWLINE> <INDENT> self . extracolumns ( ) <NEWLINE> return SQLObjectWithFormGlue . object_to_form ( self ) <NEWLINE> <DEDENT>
def journal_writer ( filename , queue ) : <NEWLINE> <INDENT> with open ( filename , <STRING> ) as f : <NEWLINE> <INDENT> slave = queue . get ( ) <NEWLINE> while slave : <NEWLINE> <INDENT> print ( slave ) <NEWLINE> slave = queue . get ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def formed_page_num ( self , page_index ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return <STRING> % ( page_index * 100 ) <NEWLINE> <DEDENT>
def test_CRLF_headers_only ( self , httpbin ) : <NEWLINE> <INDENT> r = http ( <STRING> , <STRING> , httpbin . url + <STRING> ) <NEWLINE> body = self . _validate_crlf ( r ) <NEWLINE> assert not body , <STRING> % r <NEWLINE> <DEDENT>
def match ( text ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return MATCHER . match ( text ) <NEWLINE> <DEDENT>
class InterfaceMeta ( type ) : <NEWLINE> <INDENT> def __new__ ( cls , name , parents , dct ) : <NEWLINE> <INDENT> if <STRING> not in dct : <NEWLINE> <INDENT> dct [ <STRING> ] = name . lower ( ) <NEWLINE> <DEDENT> if <STRING> in dct : <NEWLINE> <INDENT> filename = dct [ <STRING> ] <NEWLINE> dct [ <STRING> ] = open ( filename , <STRING> ) <NEWLINE> <DEDENT> return super ( InterfaceMeta , cls ) . __new__ ( cls , name , parents , dct ) <NEWLINE> <DEDENT> <DEDENT>
def scanSent ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sent = r . get_sent ( limit = MAXPOSTS ) <NEWLINE> listo = [ ] <NEWLINE> for item in sent : <NEWLINE> <INDENT> iid = item . fullname <NEWLINE> cur . execute ( <STRING> , [ iid ] ) <NEWLINE> if not cur . fetchone ( ) : <NEWLINE> <INDENT> if ITEMTYPE in iid : <NEWLINE> <INDENT> print ( <STRING> + iid ) <NEWLINE> listo . append ( item ) <NEWLINE> <DEDENT> cur . execute ( <STRING> , [ iid ] ) <NEWLINE> <DEDENT> <DEDENT> sql . commit ( ) <NEWLINE> return listo <NEWLINE> <DEDENT>
<STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> from com . irdeto . sample . python . module import fibonacci <NEWLINE> <STRING> <NEWLINE> fib_result = fibonacci . fib ( 1000 ) <NEWLINE>
from __future__ import unicode_literals <NEWLINE> from django . db import migrations , models <NEWLINE> import utils <NEWLINE>
def downgrade ( migrate_engine ) : <NEWLINE> <INDENT> meta = MetaData ( ) <NEWLINE> meta . bind = migrate_engine <NEWLINE> tables = [ define_metadef_objects_table ( meta ) , <NEWLINE> <INDENT> define_metadef_properties_table ( meta ) , <NEWLINE> define_metadef_namespace_resource_types_table ( meta ) , <NEWLINE> define_metadef_resource_types_table ( meta ) , <NEWLINE> define_metadef_namespaces_table ( meta ) ] <NEWLINE> <DEDENT> drop_tables ( tables ) <NEWLINE> <DEDENT>
def __init__ ( self , game ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> Object . __init__ ( self , game ) <NEWLINE> self . image = pygame . image . load ( <STRING> ) . convert ( ) <NEWLINE> self . image2 = pygame . image . load ( <STRING> ) . convert ( ) <NEWLINE> self . imageHit = pygame . image . load ( <STRING> ) . convert ( ) <NEWLINE> self . rect = self . image . get_rect ( ) <NEWLINE> self . SetAppearing ( ) <NEWLINE> <DEDENT>
def get_ensemble_ncl ( _name , _n_models , fast = True ) : <NEWLINE> <INDENT> ensemble = get_ensembleNCL_model ( name = _name , classification = True , classes_labels = classes_labels , <NEWLINE> <INDENT> n_input = n_features , n_output = n_output , <NEWLINE> n_ensemble_models = _n_models , n_neurons_models = n_neurons , <NEWLINE> fn_activation1 = fn_activation , fn_activation2 = fn_activation , <NEWLINE> update = update_fn , name_update = name_update , <NEWLINE> lamb = 0.3 , params_update = { <STRING> : 0.03 } <NEWLINE> ) <NEWLINE> <DEDENT> ensemble . compile ( fast = fast ) <NEWLINE> return ensemble <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from __future__ import print_function , unicode_literals <NEWLINE> import json <NEWLINE> from . import BaseHandler <NEWLINE>
class AccountVoucher ( orm . Model ) : <NEWLINE> <INDENT> _inherit = <STRING> <NEWLINE> _columns = { <NEWLINE> <INDENT> <STRING> : fields . related ( <STRING> , <NEWLINE> <INDENT> <STRING> , type = <STRING> , store = True , <NEWLINE> relation = <STRING> , string = <STRING> ) <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> <DEDENT>
def request ( self , url , * args , ** kwargs ) : <NEWLINE> <INDENT> url += <STRING> + self . access_token <NEWLINE> self . location ( self . absurl ( url , base = True ) , * args , ** kwargs ) <NEWLINE> return json . loads ( self . response . content ) <NEWLINE> <DEDENT>
from __future__ import unicode_literals <NEWLINE> from sure . old import AssertionHelper <NEWLINE> that = AssertionHelper <NEWLINE> __all__ = [ <STRING> ] <NEWLINE>
def previousTI ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . _previousTI <NEWLINE> <DEDENT>
def get_feed ( self , url = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if url : <NEWLINE> <INDENT> bits = url . split ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bits = [ ] <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> obj = self . get_object ( bits ) <NEWLINE> <DEDENT> except ObjectDoesNotExist : <NEWLINE> <INDENT> raise FeedDoesNotExist <NEWLINE> <DEDENT> return super ( Feed , self ) . get_feed ( obj , self . request ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from distutils import unixccompiler <NEWLINE> from distutils import ccompiler <NEWLINE>
def interpret_warning ( line ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> line = line . rstrip ( <STRING> ) <NEWLINE> m = warning_re . match ( line ) <NEWLINE> if m and m . group ( 2 ) not in allowed_warnings : <NEWLINE> <INDENT> print ( <STRING> , m . group ( 2 ) ) <NEWLINE> <DEDENT> <DEDENT>
from mongcore . connectors import * <NEWLINE> from mongseafood . models import * <NEWLINE> from mongcore . imports import * <NEWLINE> import time <NEWLINE> import datetime <NEWLINE> from django . utils . timezone import get_current_timezone , make_aware <NEWLINE>
<STRING> <NEWLINE> from __future__ import print_function <NEWLINE> NAME = <STRING> <NEWLINE> import os <NEWLINE> import sys <NEWLINE> import socket <NEWLINE> try : <NEWLINE> <INDENT> from cStringIO import StringIO <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> from io import StringIO <NEWLINE> <DEDENT> import genpy <NEWLINE> import roslib . message <NEWLINE> import rospy <NEWLINE> import rosmsg <NEWLINE> import rosgraph <NEWLINE> import rosgraph . names <NEWLINE> import rosgraph . network <NEWLINE> from optparse import OptionParser <NEWLINE>
from django . conf . urls import patterns , include , url <NEWLINE> from django . contrib import admin <NEWLINE> from shelf . views import MainPageView <NEWLINE> from contact . views import MessageAddView <NEWLINE> urlpatterns = patterns ( <STRING> , <NEWLINE> <INDENT> url ( <STRING> , include ( admin . site . urls ) ) , <NEWLINE> url ( <STRING> , include ( <STRING> , namespace = <STRING> ) ) , <NEWLINE> url ( <STRING> , MessageAddView . as_view ( ) ) , <NEWLINE> url ( <STRING> , MainPageView . as_view ( ) , name = <STRING> ) , <NEWLINE> url ( <STRING> , include ( <STRING> ) ) , <NEWLINE> <DEDENT> ) <NEWLINE>
def OR ( x1 , x2 ) : <NEWLINE> <INDENT> x = np . array ( [ x1 , x2 ] ) <NEWLINE> w = np . array ( [ 0.5 , 0.5 ] ) <NEWLINE> b = - 0.3 <NEWLINE> tmp = np . sum ( w * x ) + b <NEWLINE> if tmp <= 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> <DEDENT>
from __future__ import print_function <NEWLINE> <STRING> <NEWLINE> import atexit <NEWLINE> import argparse <NEWLINE> from six import PY2 <NEWLINE> import sys <NEWLINE> import textwrap <NEWLINE> from pyvmomi_tools import cli <NEWLINE> from pyVim import connect <NEWLINE> from pyVmomi import vim <NEWLINE> from pyvmomi_tools . extensions . credstore import VICredStore , NoCredentialsFileFound , HostNotFoundException <NEWLINE> if PY2 : <NEWLINE> <INDENT> input = raw_input <NEWLINE> <DEDENT>
from __future__ import absolute_import , unicode_literals <NEWLINE> from . production import * <NEWLINE> DEBUG = False <NEWLINE> TEMPLATE_DEBUG = False <NEWLINE> EMAIL_BACKEND = <STRING> <NEWLINE> try : <NEWLINE> <INDENT> from . local import * <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
from subprocess import call <NEWLINE> from random import randint <NEWLINE> from time import sleep <NEWLINE> from threading import Thread <NEWLINE> threadlist = [ ] <NEWLINE> zip_codes = open ( <STRING> , <STRING> ) <NEWLINE> for line in zip_codes : <NEWLINE> <INDENT> print ( line . strip ( ) ) <NEWLINE> <DEDENT>
def test_negative_create_with_empty_layout ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> name = gen_string ( <STRING> ) <NEWLINE> with Session ( self . browser ) as session : <NEWLINE> <INDENT> make_partitiontable ( <NEWLINE> <INDENT> session , name = name , template_path = <STRING> , os_family = <STRING> ) <NEWLINE> <DEDENT> self . assertIsNotNone ( self . partitiontable . wait_until_element <NEWLINE> <INDENT> ( common_locators [ <STRING> ] ) ) <NEWLINE> <DEDENT> self . assertIsNone ( self . partitiontable . search ( name ) ) <NEWLINE> <DEDENT> <DEDENT>
def test_source_validation ( self ) : <NEWLINE> <INDENT> with pytest . raises ( ValidationError ) as execinfo : <NEWLINE> <INDENT> GoodFactory ( ) <NEWLINE> message = <STRING> <NEWLINE> assert message in execinfo . execonly ( ) <NEWLINE> <DEDENT> <DEDENT>
from __future__ import unicode_literals <NEWLINE> from . models import batch_backends <NEWLINE> from . . core . models import base_decorator <NEWLINE> batch_backend = batch_backends [ <STRING> ] <NEWLINE> mock_batch = base_decorator ( batch_backends ) <NEWLINE>
def ecologyGBM_random_noise ( ) : <NEWLINE> <INDENT> ecology_train = h2o . import_file ( path = pyunit_utils . locate ( <STRING> ) ) <NEWLINE> gbm_h2o = H2OGradientBoostingEstimator ( pred_noise_bandwidth = 0.5 ) <NEWLINE> gbm_h2o . train ( x = list ( range ( 2 , ecology_train . ncol ) ) , y = <STRING> , training_frame = ecology_train ) <NEWLINE> print ( gbm_h2o ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import sys <NEWLINE> NetworkManagerState = None <NEWLINE>
def property_attributes ( interface , method ) : <NEWLINE> <INDENT> extended_attributes = method . extended_attributes <NEWLINE> property_attributes_list = [ ] <NEWLINE> if <STRING> in extended_attributes : <NEWLINE> <INDENT> property_attributes_list . append ( <STRING> ) <NEWLINE> <DEDENT> if is_unforgeable ( interface , method ) : <NEWLINE> <INDENT> property_attributes_list . append ( <STRING> ) <NEWLINE> property_attributes_list . append ( <STRING> ) <NEWLINE> <DEDENT> return property_attributes_list <NEWLINE> <DEDENT>
<STRING> <NEWLINE> __author__ = <STRING> <NEWLINE> __license__ = <STRING> <NEWLINE> __maintainer__ = <STRING> <NEWLINE> __email__ = <STRING> <NEWLINE> import autocorrelation <NEWLINE> import avar <NEWLINE> import emus <NEWLINE> import linalg <NEWLINE> import usutils <NEWLINE>
import random <NEWLINE> print ( random . randint ( 1 , 18 ) ) <NEWLINE>
def setUp ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . __dirs_to_remove = [ ] <NEWLINE> <DEDENT>
import glob <NEWLINE> import os <NEWLINE> import pygame <NEWLINE> import time <NEWLINE> pygame . init ( ) <NEWLINE> white = ( 255 , 255 , 255 ) <NEWLINE> black = ( 0 , 0 , 0 ) <NEWLINE>
class Solution ( object ) : <NEWLINE> <INDENT> def combinationSum4 ( self , nums , target ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if target <= 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> nums . sort ( ) <NEWLINE> dp = [ 0 ] * ( target + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for t in xrange ( 1 , target + 1 ) : <NEWLINE> <INDENT> for n in nums : <NEWLINE> <INDENT> if n > t : break <NEWLINE> dp [ t ] += dp [ t - n ] <NEWLINE> <DEDENT> <DEDENT> return dp [ target ] <NEWLINE> <DEDENT> <DEDENT>
class PystanError ( Exception ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> pass <NEWLINE> <DEDENT>
def dispose ( self ) : <NEWLINE> <INDENT> self . _username = None <NEWLINE> self . _password = None <NEWLINE> self . _org_url = None <NEWLINE> self . _proxy_url = None <NEWLINE> self . _proxy_port = None <NEWLINE> self . _token_url = None <NEWLINE> self . _securityHandler = None <NEWLINE> self . _valid = None <NEWLINE> self . _message = None <NEWLINE> del self . _username <NEWLINE> del self . _password <NEWLINE> del self . _org_url <NEWLINE> del self . _proxy_url <NEWLINE> del self . _proxy_port <NEWLINE> del self . _token_url <NEWLINE> del self . _securityHandler <NEWLINE> del self . _valid <NEWLINE> del self . _message <NEWLINE> <DEDENT>
import mock <NEWLINE> from kombu import Connection , Exchange , Queue <NEWLINE> from st2common . transport import consumers <NEWLINE> from st2common . transport import utils as transport_utils <NEWLINE> from st2tests . base import DbTestCase <NEWLINE> from tests . unit . base import FakeModelDB <NEWLINE> FAKE_XCHG = Exchange ( <STRING> , type = <STRING> ) <NEWLINE> FAKE_WORK_Q = Queue ( <STRING> , FAKE_XCHG ) <NEWLINE>
import theano <NEWLINE> import theano . tensor as T <NEWLINE> import numpy as np <NEWLINE> from learn_theano . utils . download_all_datasets import get_dataset <NEWLINE> import cPickle <NEWLINE> import pickle <NEWLINE> import time <NEWLINE>
def test_room ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> rv = self . app . get ( <STRING> ) <NEWLINE> assert <STRING> in rv . data <NEWLINE> <DEDENT>
class Point ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> __slots__ = ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> def __init__ ( self , x = 0.0 , y = 0.0 , z = 0.0 , w = 1.0 ) : <NEWLINE> <INDENT> super ( Point , self ) . __init__ ( ) <NEWLINE> self . x = x <NEWLINE> self . y = y <NEWLINE> self . z = z <NEWLINE> self . w = w <NEWLINE> <DEDENT> <DEDENT>
from neutron . plugins . ml2 import driver_api as api <NEWLINE> from neutron_lib import constants as p_constants <NEWLINE> from oslo_log import log <NEWLINE> from networking_powervm . plugins . ibm . agent . powervm import constants as pconst <NEWLINE> from networking_powervm . plugins . ml2 . drivers import mech_pvm_base <NEWLINE> LOG = log . getLogger ( __name__ ) <NEWLINE>
class PrepareOut ( cr . Plugin , cr . Plugin . Type ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def UpdateContext ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> def Prepare ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> raise NotImplementedError ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import abc <NEWLINE> import cvxpy <NEWLINE> import cvxpy . interface as intf <NEWLINE> import cvxopt <NEWLINE>
<STRING> <NEWLINE> import unittest <NEWLINE> from daeso . pair import Pair <NEWLINE> from daeso_nl . graph . alpinograph import AlpinoGraph <NEWLINE> from daeso_nl . ga . feats import * <NEWLINE> from daeso_nl . ga . feats . root import ( ff_roots_share_infix , <NEWLINE> <INDENT> ff_roots_share_prefix , <NEWLINE> ff_roots_share_suffix , <NEWLINE> ff_roots_subsumption ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from googleads import adwords <NEWLINE> from googleads import errors <NEWLINE> ADGROUP_ID = <STRING> <NEWLINE> AD_ID = <STRING> <NEWLINE>
def _get_sm_name ( o ) : <NEWLINE> <INDENT> if isinstance ( o , StorageManager ) : <NEWLINE> <INDENT> return o . name <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return str ( o ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , text = None , head = False , cl = None , ident = None , style = None , attrs = None ) : <NEWLINE> <INDENT> super ( ) . __init__ ( cl = cl , ident = ident , style = style , attrs = attrs ) <NEWLINE> if text : <NEWLINE> <INDENT> self . _children . append ( text ) <NEWLINE> <DEDENT> self . head = head <NEWLINE> <DEDENT>
def test_condition_type1_variant3 ( self ) : <NEWLINE> <INDENT> response = ConditionAIMLTests . test_client . bot . ask_question ( <STRING> , <STRING> ) <NEWLINE> self . assertIsNotNone ( response ) <NEWLINE> self . assertEquals ( response , <STRING> ) <NEWLINE> <DEDENT>
import pprint <NEWLINE> from unittest import TestCase <NEWLINE> from . . nbjson import reads , writes <NEWLINE> from . nbexamples import nb0 <NEWLINE>
def last_request_status ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . __last_request_status <NEWLINE> <DEDENT>
def create_dummy_class ( klass , dependency ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> class _Dummy ( object ) : <NEWLINE> <INDENT> def __init__ ( self , * args , ** kwargs ) : <NEWLINE> <INDENT> raise ImportError ( <STRING> . format ( dependency , klass ) ) <NEWLINE> <DEDENT> <DEDENT> return _Dummy <NEWLINE> <DEDENT>
from django . test import TestCase <NEWLINE> import re <NEWLINE> example_unshrunk = <STRING> <NEWLINE> example_3q = <STRING> <NEWLINE>
<STRING> <NEWLINE> from __future__ import print_function <NEWLINE> import sys <NEWLINE> from rally . cli import cliutils <NEWLINE> from rally . common import profile <NEWLINE> from rally_ovs . cli . commands import deployment <NEWLINE> from rally_ovs . cli . commands import task <NEWLINE> profile . profile = profile . PROFILE_OVS <NEWLINE> ovs_categories = { <NEWLINE> <INDENT> <STRING> : deployment . DeploymentCommands , <NEWLINE> <STRING> : task . TaskCommands , <NEWLINE> <DEDENT> } <NEWLINE>
def _get_log_url ( self , response ) : <NEWLINE> <INDENT> url = None <NEWLINE> if not response or not isinstance ( response , dict ) or not response . has_key ( <STRING> ) : <NEWLINE> <INDENT> return url <NEWLINE> <DEDENT> return response [ <STRING> ] <NEWLINE> <DEDENT>
def oscillations ( N ) : <NEWLINE> <INDENT> x = zeros ( N + 1 ) <NEWLINE> for n in range ( N + 1 ) : <NEWLINE> <INDENT> x [ n ] = exp ( - 4 * n / float ( N ) ) * sin ( 8 * pi * n / float ( N ) ) <NEWLINE> <DEDENT> return x <NEWLINE> <DEDENT>
def open ( cls , context = None ) : <NEWLINE> <INDENT> if context is None : <NEWLINE> <INDENT> context = { } <NEWLINE> <DEDENT> return cls ( ** context ) <NEWLINE> <DEDENT>
class Values : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . matrixR = [ 1.0 , 0.0 , 0.0 ] <NEWLINE> self . matrixG = [ 0.0 , 1.0 , 0.0 ] <NEWLINE> self . matrixB = [ 0.0 , 0.0 , 1.0 ] <NEWLINE> self . matrixC = [ 0.0 , 0.0 , 0.0 ] <NEWLINE> self . brightR = 1.0 <NEWLINE> self . brightG = 1.0 <NEWLINE> self . brightB = 1.0 <NEWLINE> self . contrast = 1.0 <NEWLINE> self . saturation = 1.0 <NEWLINE> <DEDENT> <DEDENT>
def from_features ( features ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> master = { } <NEWLINE> for feature in features : <NEWLINE> <INDENT> for field_key , field_info in _iter_field_infos ( feature ) : <NEWLINE> <INDENT> new_fi = FieldInfo ( <NEWLINE> <INDENT> field_key , <NEWLINE> None , <NEWLINE> field_info <NEWLINE> <DEDENT> ) <NEWLINE> master [ field_key ] = new_fi <NEWLINE> <DEDENT> <DEDENT> return master <NEWLINE> <DEDENT>
def range2list ( str ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> r = [ ] <NEWLINE> parts = str . split ( <STRING> ) <NEWLINE> for part in parts : <NEWLINE> <INDENT> minmax = part . split ( <STRING> , 2 ) <NEWLINE> if len ( minmax ) == 1 : <NEWLINE> <INDENT> val = int ( part [ 0 ] ) <NEWLINE> r . append ( ( val , val ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r . append ( ( int ( minmax [ 0 ] ) , int ( minmax [ 1 ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> return r <NEWLINE> <DEDENT>
def formula_1d ( init , coeff , variable ) : <NEWLINE> <INDENT> value = init * numpy . exp ( coeff * variable ) <NEWLINE> return value <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from flask import Flask , render_template <NEWLINE> from useradvocacy . settings import ProdConfig <NEWLINE> from useradvocacy . assets import assets <NEWLINE> from useradvocacy . extensions import ( <NEWLINE> <INDENT> bcrypt , <NEWLINE> cache , <NEWLINE> db , <NEWLINE> login_manager , <NEWLINE> migrate , <NEWLINE> debug_toolbar , <NEWLINE> <DEDENT> ) <NEWLINE> from useradvocacy import public , user , reports , dashboards , data <NEWLINE>
<STRING> <NEWLINE> import sysconfig <NEWLINE> for name in sysconfig . get_scheme_names ( ) : <NEWLINE> <INDENT> print ( name ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from game import Directions , Actions <NEWLINE> import util <NEWLINE>
def __init__ ( self , access_key , secret_key , cloud_id = None , api_host = <STRING> , api_port = 443 ) : <NEWLINE> <INDENT> self . cloud_id = cloud_id <NEWLINE> self . access_key = access_key <NEWLINE> self . secret_key = secret_key <NEWLINE> self . api_host = api_host <NEWLINE> self . api_port = api_port <NEWLINE> self . api_version = 2 <NEWLINE> self . videos = GroupRetriever ( self , Video ) <NEWLINE> self . clouds = GroupRetriever ( self , Cloud ) <NEWLINE> self . encodings = GroupRetriever ( self , Encoding ) <NEWLINE> self . profiles = GroupRetriever ( self , Profile ) <NEWLINE> self . notifications = SingleRetriever ( self , Notifications ) <NEWLINE> <DEDENT>
class PagesForModerationPanel ( object ) : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> order = 200 <NEWLINE> def __init__ ( self , request ) : <NEWLINE> <INDENT> self . request = request <NEWLINE> user_perms = UserPagePermissionsProxy ( request . user ) <NEWLINE> self . page_revisions_for_moderation = user_perms . revisions_for_moderation ( ) . select_related ( <STRING> , <STRING> ) . order_by ( <STRING> ) <NEWLINE> <DEDENT> def render ( self ) : <NEWLINE> <INDENT> return render_to_string ( <STRING> , { <NEWLINE> <INDENT> <STRING> : self . page_revisions_for_moderation , <NEWLINE> <DEDENT> } , request = self . request ) <NEWLINE> <DEDENT> <DEDENT>
def main ( argv ) : <NEWLINE> <INDENT> data_files = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <DEDENT> ] <NEWLINE> data_dir = <STRING> <NEWLINE> for file_name in data_files : <NEWLINE> <INDENT> pprint ( file_name ) <NEWLINE> wb = openpyxl . load_workbook ( <STRING> % ( data_dir , file_name ) , read_only = True ) <NEWLINE> <DEDENT> <DEDENT>
def test ( ) : <NEWLINE> <INDENT> assert 2 == rom05 ( 0 ) <NEWLINE> assert 4 == rom05 ( 1 ) <NEWLINE> assert 6 == rom05 ( 2 ) <NEWLINE> <DEDENT>
def parse_items ( self , response ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> sel = Selector ( response ) <NEWLINE> job_item , company_item = response . meta [ <STRING> ] , response . meta [ <STRING> ] <NEWLINE> company_item [ <STRING> ] = <STRING> . join ( sel . xpath ( <STRING> ) . extract ( ) ) <NEWLINE> company_item [ <STRING> ] = sel . xpath ( <STRING> ) . extract_first ( ) <NEWLINE> job_item [ <STRING> ] = <STRING> . join ( sel . xpath ( <STRING> ) . extract ( ) ) <NEWLINE> job_item [ <STRING> ] = company_item <NEWLINE> yield job_item <NEWLINE> <DEDENT>
def compress ( result , next ) : <NEWLINE> <INDENT> count = int ( result [ - 1 ] ) if result [ - 1 ] . isdigit ( ) else 1 <NEWLINE> last = result [ - 1 ] if count == 1 else result [ - 2 ] <NEWLINE> if next == last : <NEWLINE> <INDENT> index = None if count == 1 else - 1 <NEWLINE> result = result [ : index ] + str ( count + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += next <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT>
class AttributeOptionGroupAdmin ( admin . ModelAdmin ) : <NEWLINE> <INDENT> list_display = ( <STRING> , <STRING> ) <NEWLINE> inlines = [ AttributeOptionInline , ] <NEWLINE> <DEDENT>
def populate_parser ( parent_parser ) : <NEWLINE> <INDENT> parser = parent_parser . add_parser ( <STRING> , <NEWLINE> <INDENT> description = <STRING> , <NEWLINE> formatter_class = ArgumentDefaultsHelpFormatter ) <NEWLINE> <DEDENT> parser . add_argument ( <STRING> , help = <STRING> ) <NEWLINE> parser . set_defaults ( func = run ) <NEWLINE> <DEDENT>
def random_serial_number ( size : int ) : <NEWLINE> <INDENT> serial_number = [ ] <NEWLINE> for i in range ( size ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> val = random . randint ( 0 , size ) + 1 <NEWLINE> if val not in serial_number : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> serial_number . append ( val ) <NEWLINE> <DEDENT> return serial_number <NEWLINE> <DEDENT>
def updateProgress ( self , progress , msg ) : <NEWLINE> <INDENT> self . splash . showMessage ( msg , alignment = QtCore . Qt . AlignBottom , color = self . textColor ) <NEWLINE> self . progressBar . setValue ( progress ) <NEWLINE> self . app . processEvents ( ) <NEWLINE> <DEDENT>
class ShowVersion ( CommandoApplication ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> commands = [ <STRING> ] <NEWLINE> <DEDENT>
class WPConfModifEPaymentWorldPayDataModif ( WPConfModifEPaymentWorldPayBase ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def _getTabContent ( self , params ) : <NEWLINE> <INDENT> wc = WConfModifEPaymentWorldPayDataModif ( self . _conf ) <NEWLINE> p = { <STRING> : quoteattr ( str ( localUrlHandlers . UHConfModifEPaymentWorldPayPerformDataModif . getURL ( self . _conf ) ) ) } <NEWLINE> return wc . getHTML ( p ) <NEWLINE> <DEDENT> <DEDENT>
class CircularLayout ( Layout ) : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> def draw ( self , sampler , canvas ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
def test_cust_all ( self ) : <NEWLINE> <INDENT> parser = create_db . build_arg_parser ( ) <NEWLINE> args = parser . parse_args ( <STRING> . split ( ) ) <NEWLINE> self . assertEqual ( args . func , create_db . create_multi_cust_dbs ) <NEWLINE> self . assertEqual ( args . org , None ) <NEWLINE> self . assertEqual ( args . all , True ) <NEWLINE> <DEDENT>
def setup_systems ( run_input , system_params ) : <NEWLINE> <INDENT> systems = MultiSystem ( run_input , system_params ) <NEWLINE> return systems <NEWLINE> <DEDENT>
class AuditLogEntryEvent ( object ) : <NEWLINE> <INDENT> MEMBER_INVITE = 1 <NEWLINE> MEMBER_ADD = 2 <NEWLINE> MEMBER_ACCEPT = 3 <NEWLINE> MEMBER_EDIT = 4 <NEWLINE> MEMBER_REMOVE = 5 <NEWLINE> ORG_ADD = 10 <NEWLINE> ORG_EDIT = 11 <NEWLINE> TEAM_ADD = 20 <NEWLINE> TEAM_EDIT = 21 <NEWLINE> TEAM_REMOVE = 22 <NEWLINE> PROJECT_ADD = 30 <NEWLINE> PROJECT_EDIT = 31 <NEWLINE> PROJECT_REMOVE = 32 <NEWLINE> PROJECT_SET_PUBLIC = 33 <NEWLINE> PROJECT_SET_PRIVATE = 34 <NEWLINE> TAGKEY_REMOVE = 40 <NEWLINE> PROJECTKEY_ADD = 50 <NEWLINE> PROJECTKEY_EDIT = 51 <NEWLINE> PROJECTKEY_REMOVE = 52 <NEWLINE> PROJECTKEY_ENABLE = 53 <NEWLINE> PROJECTKEY_DISABLE = 53 <NEWLINE> SSO_ENABLE = 60 <NEWLINE> SSO_DISABLE = 61 <NEWLINE> SSO_EDIT = 62 <NEWLINE> SSO_IDENTITY_LINK = 63 <NEWLINE> <DEDENT>
def members ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def raw_member_list ( update = False ) : <NEWLINE> <INDENT> if update : <NEWLINE> <INDENT> self . update_group ( ) <NEWLINE> <DEDENT> return self . raw . get ( <STRING> , list ( ) ) <NEWLINE> <DEDENT> ret = Chats ( source = self ) <NEWLINE> ret . extend ( map ( <NEWLINE> <INDENT> lambda x : Member ( x , self ) , <NEWLINE> raw_member_list ( ) or raw_member_list ( True ) <NEWLINE> <DEDENT> ) ) <NEWLINE> return ret <NEWLINE> <DEDENT>
def test_raises_error_for_abn_containing_a_letter ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> invalid_abn = <STRING> <NEWLINE> validator = AUBusinessNumberFieldValidator ( ) <NEWLINE> self . assertRaises ( ValidationError , lambda : validator ( invalid_abn ) ) <NEWLINE> <DEDENT>
from sys import argv <NEWLINE> print ( <STRING> ) <NEWLINE> file_again = raw_input ( <STRING> ) <NEWLINE> txt_again = open ( file_again ) <NEWLINE> print ( txt_again . read ( ) ) <NEWLINE> txt_again . close ( ) <NEWLINE>
class IPodPlistEvent ( event . PythonDatetimeEvent ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> DATA_TYPE = <STRING> <NEWLINE> def __init__ ( self , datetime_timestamp , device_id , device_info ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> super ( IPodPlistEvent , self ) . __init__ ( <NEWLINE> <INDENT> datetime_timestamp , eventdata . EventTimestamp . LAST_CONNECTED ) <NEWLINE> <DEDENT> self . device_id = device_id <NEWLINE> for key , value in device_info . iteritems ( ) : <NEWLINE> <INDENT> if key == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> attribute_name = key . lower ( ) . replace ( <STRING> , <STRING> ) <NEWLINE> setattr ( self , attribute_name , value ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def p5 ( n ) : <NEWLINE> <INDENT> r = dict ( ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> decompose ( i , r ) <NEWLINE> <DEDENT> res = 1 <NEWLINE> for i in r . keys ( ) : <NEWLINE> <INDENT> res *= i ** r [ i ] <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT>
def get ( self ) : <NEWLINE> <INDENT> if not self . user : <NEWLINE> <INDENT> self . redirect_login ( ) <NEWLINE> return <NEWLINE> <DEDENT> comment_id = int ( self . request . get ( <STRING> ) ) <NEWLINE> comment = Comment . by_id ( comment_id ) <NEWLINE> if not comment : <NEWLINE> <INDENT> self . error ( 404 ) <NEWLINE> return <NEWLINE> <DEDENT> if comment . author_id != self . user . key ( ) . id ( ) : <NEWLINE> <INDENT> self . redirect_login ( ) <NEWLINE> return <NEWLINE> <DEDENT> self . render_edit_comment ( comment ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import os <NEWLINE> muland_binary = os . getenv ( <STRING> , <STRING> ) <NEWLINE> muland_work = os . getenv ( <STRING> , <STRING> ) <NEWLINE> mulandweb_host = os . getenv ( <STRING> , <STRING> ) <NEWLINE> mulandweb_port = int ( os . getenv ( <STRING> , 8000 ) ) <NEWLINE> mulandweb_memfile_max = int ( os . getenv ( <STRING> , 5 * 1024 * 1024 ) ) <NEWLINE> db_url = os . getenv ( <STRING> , <STRING> ) <NEWLINE> db_prefix = os . getenv ( <STRING> , <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> from mulandlocal import * <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
def test_redirect_with_script_prefix ( self ) : <NEWLINE> <INDENT> previous_script_prefix = urlresolvers . get_script_prefix ( ) <NEWLINE> urlresolvers . set_script_prefix ( <STRING> ) <NEWLINE> r1 = self . request_factory . get ( <STRING> ) <NEWLINE> r2 = self . middleware . process_request ( r1 ) <NEWLINE> self . assertEqual ( 301 , r2 . status_code ) <NEWLINE> self . assertEqual ( <STRING> , r2 [ <STRING> ] ) <NEWLINE> r3 = self . request_factory . get ( <STRING> ) <NEWLINE> r4 = self . middleware . process_request ( r3 ) <NEWLINE> self . assertEqual ( None , r4 ) <NEWLINE> urlresolvers . set_script_prefix ( previous_script_prefix ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import threading <NEWLINE> import time <NEWLINE> j_list = [ ] <NEWLINE>
from __future__ import absolute_import , unicode_literals <NEWLINE> from django . db import models <NEWLINE> from taggit . managers import TaggableManager <NEWLINE> from wagtail . wagtailsearch import index <NEWLINE>
import os <NEWLINE> from _core import lib <NEWLINE> RESOURCE_PATH = os . path . join ( <STRING> , <STRING> ) <NEWLINE> SHADER_PATH = os . path . abspath ( os . path . join ( RESOURCE_PATH , <STRING> , <STRING> ) ) <NEWLINE> IMAGE_PATH = os . path . abspath ( os . path . join ( RESOURCE_PATH , <STRING> , <NEWLINE> <INDENT> <STRING> ) ) <NEWLINE> <DEDENT> core = lib . NewCore ( ) <NEWLINE> lib . Core_Init ( core , SHADER_PATH . encode ( <STRING> ) , IMAGE_PATH . encode ( <STRING> ) ) <NEWLINE> lib . Core_Run ( core ) <NEWLINE> lib . DeleteCore ( core ) <NEWLINE>
from datetime import datetime <NEWLINE> GAME_VIDEO_BASE_URL = <STRING> <NEWLINE> LIVE_UPDATE_BASE_URL = <STRING> <NEWLINE>
from rhum . utils . crc8 import CRC8Utils <NEWLINE> print ( CRC8Utils . check ( <STRING> , 0xb9 ) ) <NEWLINE> print ( CRC8Utils . check ( <STRING> , 0xb5 ) ) <NEWLINE>
def assertExitedStateNTimesRecently ( self , times , card , state , when ) : <NEWLINE> <INDENT> StateLog = self . _get_target_class ( ) <NEWLINE> state_logs = StateLog . objects . filter ( card = card , state = state ) . order_by ( <STRING> ) <NEWLINE> assert times == len ( state_logs ) <NEWLINE> self . assertEqualDateTimes ( state_logs [ 0 ] . exited , when ) <NEWLINE> assert state_logs [ 0 ] . entered is not None <NEWLINE> for i in xrange ( 1 , times - 1 ) : <NEWLINE> <INDENT> assert state_logs [ i ] . entered != when <NEWLINE> assert state_logs [ i ] . exited != when <NEWLINE> <DEDENT> <DEDENT>
def test_frozendict_hash ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> hash ( frozendict ( { <STRING> : <STRING> , <STRING> : 42 } ) ) <NEWLINE> hash ( frozendict ( { <NEWLINE> <INDENT> <STRING> : ( 42 , <STRING> ) , <NEWLINE> <STRING> : [ ( 0 , 0 , { <STRING> : [ 42 ] } ) ] , <NEWLINE> <DEDENT> } ) ) <NEWLINE> <DEDENT>
def assertTranslate ( self , machine , lang = <STRING> , word = <STRING> , empty = False ) : <NEWLINE> <INDENT> translation = machine . translate ( lang , word , MockUnit ( ) , None ) <NEWLINE> self . assertIsInstance ( translation , list ) <NEWLINE> if not empty : <NEWLINE> <INDENT> self . assertTrue ( len ( translation ) > 0 ) <NEWLINE> <DEDENT> <DEDENT>
def getName ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return None <NEWLINE> <DEDENT>
class UserBasedScalableNumerator ( MRJob ) : <NEWLINE> <INDENT> def steps ( self ) : <NEWLINE> <INDENT> return [ <NEWLINE> <INDENT> MRStep ( mapper = self . mapper_getUser , <NEWLINE> <INDENT> reducer = self . reducer_countMoiveForUser ) <NEWLINE> <DEDENT> <DEDENT> ] <NEWLINE> <DEDENT> def mapper_getUser ( self , _ , line ) : <NEWLINE> <INDENT> if not line . strip ( ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> user = line . strip ( ) . split ( <STRING> ) [ 0 ] <NEWLINE> yield user , 1 <NEWLINE> <DEDENT> <DEDENT> def reducer_countMoiveForUser ( self , user , count ) : <NEWLINE> <INDENT> yield <STRING> , ( user , sum ( count ) ) <NEWLINE> <DEDENT> <DEDENT>
def publish ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> ) <NEWLINE> all ( ) <NEWLINE> local ( <STRING> ) <NEWLINE> local ( <STRING> . format ( VERSION ) ) <NEWLINE> local ( <STRING> . format ( VERSION , DATE ) ) <NEWLINE> local ( <STRING> ) <NEWLINE> local ( <STRING> ) <NEWLINE> local ( <STRING> ) <NEWLINE> local ( <STRING> ) <NEWLINE> local ( <STRING> ) <NEWLINE> <DEDENT>
class PageCyclerIntlHiRu ( _PageCycler ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> page_set = page_sets . IntlHiRuPageSet <NEWLINE> @ classmethod <NEWLINE> def Name ( cls ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT>
def run ( visual , program_runner ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> try : <NEWLINE> <INDENT> stage . init ( ) <NEWLINE> if visual : <NEWLINE> <INDENT> graphics . init ( ) <NEWLINE> <DEDENT> theme . init ( ) <NEWLINE> score = gameloop . start ( program_runner ) <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> return score <NEWLINE> <DEDENT>
def account_info ( iso , bank_acc ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if iso in _account_info : <NEWLINE> <INDENT> return _account_info [ iso ] ( bank_acc ) <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
def test_add_histogram_value_wrong_variable ( self ) : <NEWLINE> <INDENT> cc = CrayonClient ( port = self . test_server_port ) <NEWLINE> foo = cc . create_experiment ( <STRING> ) <NEWLINE> data = { <STRING> : 0 , <NEWLINE> <INDENT> <STRING> : 100 , <NEWLINE> <STRING> : 3 , <NEWLINE> <STRING> : [ 10 , 50 , 30 ] , <NEWLINE> <STRING> : [ 5 , 45 , 25 ] } <NEWLINE> <DEDENT> self . assertRaises ( ValueError , foo . add_histogram_value , <NEWLINE> <INDENT> <STRING> , data ) <NEWLINE> <DEDENT> <DEDENT>
def cb_ballinimage ( self , balls : BallsInImage ) : <NEWLINE> <INDENT> if balls . candidates : <NEWLINE> <INDENT> ball = balls . candidates [ 0 ] <NEWLINE> self . bestball_in_image = ball . center . x , ball . center . y <NEWLINE> <DEDENT> <DEDENT>
def test_formula_terms_variables ( self ) : <NEWLINE> <INDENT> assert len ( self . formula_terms_variables ) == 1 <NEWLINE> assert hasattr ( self . formula_terms_variable , <STRING> ) <NEWLINE> assert self . formula_terms_variable . standard_name == <STRING> <NEWLINE> <DEDENT>
def get_responsible ( section , key ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> first = CFG_PATHS [ - 1 ] <NEWLINE> paths = reversed ( CFG_PATHS ) <NEWLINE> for path in paths : <NEWLINE> <INDENT> config = ConfigParser . ConfigParser ( ) <NEWLINE> config . read ( path ) <NEWLINE> if config . has_option ( section , key ) : <NEWLINE> <INDENT> return path <NEWLINE> <DEDENT> <DEDENT> return first <NEWLINE> <DEDENT>
def __init__ ( self , * args , ** kwargs ) : <NEWLINE> <INDENT> super ( ) . __init__ ( * args , ** kwargs ) <NEWLINE> self . user_id = self . slack_client . api_call ( <STRING> ) [ <STRING> ] <NEWLINE> self . store_file = open ( <STRING> . format ( type ( self ) . __name__ ) , <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> self . store = json . load ( self . store_file ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> self . store = { } <NEWLINE> <DEDENT> <DEDENT>
import base_partner_merge_ccorp <NEWLINE> import base_partner_merge_address_ccorp <NEWLINE>
from __future__ import absolute_import , unicode_literals <NEWLINE> from binascii import Error <NEWLINE> from django . core . management . base import NoArgsCommand <NEWLINE> from ... import backend <NEWLINE> from ... session import SessionStore <NEWLINE>
from authentication . views import MainLoginView , FirstLoginView , LogoutView <NEWLINE> from django . conf . urls import patterns , url <NEWLINE> urlpatterns = patterns ( <STRING> , <NEWLINE> <INDENT> url ( <STRING> , MainLoginView . as_view ( ) , <NEWLINE> <INDENT> name = <STRING> ) , <NEWLINE> <DEDENT> url ( <STRING> , LogoutView . as_view ( ) , <NEWLINE> <INDENT> name = <STRING> ) , <NEWLINE> <DEDENT> url ( <STRING> , FirstLoginView . as_view ( ) , <NEWLINE> <INDENT> name = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> ) <NEWLINE>
def __init__ ( self , * args ) : <NEWLINE> <INDENT> this = _SimAppObjNameDefault_DistributionSystem_RefrigerationLoop . new_SimAppObjNameDefault_DistributionSystem_RefrigerationLoop_sequence ( * args ) <NEWLINE> try : <NEWLINE> <INDENT> self . this . append ( this ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> self . this = this <NEWLINE> <DEDENT> <DEDENT>
from jiver import __version__ <NEWLINE> import os <NEWLINE> import sys <NEWLINE> try : <NEWLINE> <INDENT> from setuptools import setup <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> from distutils . core import setup <NEWLINE> <DEDENT> dependencies = [ <STRING> , <STRING> ] <NEWLINE>
def add ( self , mac , ip ) : <NEWLINE> <INDENT> assert mac not in [ x [ 0 ] for x in self . _nodesMACIPPairs ] <NEWLINE> assert ip not in [ x [ 1 ] for x in self . _nodesMACIPPairs ] <NEWLINE> self . _nodesMACIPPairs . append ( ( mac , ip ) ) <NEWLINE> self . _reload ( ) <NEWLINE> <DEDENT>
def get_selections ( module , pkg ) : <NEWLINE> <INDENT> cmd = [ module . get_bin_path ( <STRING> , True ) , pkg ] <NEWLINE> rc , out , err = module . run_command ( <STRING> . join ( cmd ) ) <NEWLINE> if rc != 0 : <NEWLINE> <INDENT> module . fail_json ( msg = err ) <NEWLINE> <DEDENT> selections = { } <NEWLINE> for line in out . splitlines ( ) : <NEWLINE> <INDENT> ( key , value ) = line . split ( <STRING> , 1 ) <NEWLINE> selections [ key . strip ( <STRING> ) . strip ( ) ] = value . strip ( ) <NEWLINE> <DEDENT> return selections <NEWLINE> <DEDENT>
from crawler import TCrawler <NEWLINE> from segments_index import TSegmentIndexWriter <NEWLINE> from utils import TCustomCounter <NEWLINE> from ling_utils import CASE_UPPER , CASE_TITLE , CASE_LOWER <NEWLINE> from ling_utils import span_tokenize_windows1251 <NEWLINE> from ling_utils import unify_word <NEWLINE> import sys <NEWLINE> import os <NEWLINE> REDUCERS_COUNT = 100 <NEWLINE> REDUCERS_FILES_BUFFER = 1000000 <NEWLINE> WEIGHT_SHIFT = 2 <NEWLINE> SEGMENT_POS_SHIFT = 6 <NEWLINE> BOOK_SHIFT = 20 <NEWLINE> SEGMENT_SIZE = ( 1 << SEGMENT_POS_SHIFT ) <NEWLINE>
from learning . bayesian_learning . agents import TheEyeAgent <NEWLINE> from opencog . atomspace import AtomSpace <NEWLINE> from opencog . cogserver import Server <NEWLINE> __author__ = <STRING> <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> server = Server ( ) <NEWLINE> server . add_mind_agent ( TheEyeAgent ( ) ) <NEWLINE> server . run ( AtomSpace ( ) ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import sys <NEWLINE> import requests <NEWLINE> import xml . dom . minidom as minidom <NEWLINE> from PySide import QtCore , QtGui <NEWLINE> from . import _spotting , _callinfo , _grid , _location , _config <NEWLINE>
import odoo . addons . decimal_precision as dp <NEWLINE> from odoo import fields , models , api , tools <NEWLINE> from odoo . exceptions import UserError <NEWLINE>
def bench_xpath_class_repeat ( self , children ) : <NEWLINE> <INDENT> for child in children : <NEWLINE> <INDENT> xpath = self . etree . XPath ( <STRING> ) <NEWLINE> xpath ( child ) <NEWLINE> <DEDENT> <DEDENT>
from django . http import HttpResponse <NEWLINE> import numpy as np <NEWLINE> import matplotlib <NEWLINE> from matplotlib . pyplot import get_cmap , colorbar , legend <NEWLINE> import matplotlib . pyplot as plt <NEWLINE> from matplotlib . backends . backend_agg import FigureCanvasAgg <NEWLINE> import wms . add_cmaps <NEWLINE> from wms . mpl_handler import DEFAULT_HATCHES <NEWLINE> from wms import logger <NEWLINE> from matplotlib import rcParams <NEWLINE> rcParams [ <STRING> ] = <STRING> <NEWLINE> rcParams [ <STRING> ] = [ <STRING> ] <NEWLINE> rcParams [ <STRING> ] = [ <STRING> ] <NEWLINE> rcParams [ <STRING> ] = <STRING> <NEWLINE> rcParams [ <STRING> ] = True <NEWLINE>
def disable_mocktime ( ) : <NEWLINE> <INDENT> global MOCKTIME <NEWLINE> MOCKTIME = 0 <NEWLINE> <DEDENT>
<STRING> <NEWLINE> __author__ = <STRING> <NEWLINE> import sys <NEWLINE> from streammorphology import ExperimentRunner <NEWLINE> from streammorphology . lyapunov import Lyapmap <NEWLINE> runner = ExperimentRunner ( ExperimentClass = Lyapmap ) <NEWLINE> runner . run ( ) <NEWLINE> sys . exit ( 0 ) <NEWLINE>
def _fetch ( self , force ) : <NEWLINE> <INDENT> if not force : <NEWLINE> <INDENT> value = self . get_local_only ( ) <NEWLINE> if not value == DoesNotExist : <NEWLINE> <INDENT> return value <NEWLINE> <DEDENT> value = self . value_from_cache_data ( cache . get ( self . key ) ) <NEWLINE> if not value == DoesNotExist : <NEWLINE> <INDENT> return value <NEWLINE> <DEDENT> <DEDENT> cache_data = self . generate_cache_data ( ) <NEWLINE> return self . value_from_cache_data ( cache_data ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from five import grok <NEWLINE> from zope . interface import Interface <NEWLINE> from zope . globalrequest import getRequest <NEWLINE> from collective . beaker . interfaces import ISession <NEWLINE> SESSION_KEY = <STRING> <NEWLINE>
class CeleryTestCase ( TestCase ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def setUp ( self ) : <NEWLINE> <INDENT> self . tracer = get_dummy_tracer ( ) <NEWLINE> self . _original_tracer = ddtrace . tracer <NEWLINE> ddtrace . tracer = self . tracer <NEWLINE> self . app = patch_app ( Celery ( <STRING> , broker = BROKER_URL , backend = BACKEND_URL ) ) <NEWLINE> <DEDENT> <DEDENT>
def resizeHalf ( srcPath ) : <NEWLINE> <INDENT> convert_command = CONVERT + <STRING> <NEWLINE> dstPath = srcPath . replace ( HIGH_ROOT , LOW_ROOT ) <NEWLINE> if not os . path . exists ( os . path . dirname ( dstPath ) ) : <NEWLINE> <INDENT> os . system ( <STRING> % os . path . dirname ( dstPath ) ) <NEWLINE> <DEDENT> cmd = convert_command . format ( srcPath , dstPath ) <NEWLINE> print ( srcPath , <STRING> , dstPath , <STRING> ) <NEWLINE> os . system ( cmd ) <NEWLINE> <DEDENT>
from setuptools import setup <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> version = <STRING> , <NEWLINE> packages = [ <STRING> ] , <NEWLINE> data_files = [ <NEWLINE> <INDENT> ( <STRING> , [ <STRING> ] ) , <NEWLINE> ( <STRING> , [ <STRING> ] ) <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT> ) <NEWLINE>
def test_timeout ( ) : <NEWLINE> <INDENT> sp = svm . SVC ( C = 1 , kernel = lambda x , y : x * y . T , probability = True , <NEWLINE> <INDENT> max_iter = 1 ) <NEWLINE> <DEDENT> with warnings . catch_warnings ( record = True ) as foo : <NEWLINE> <INDENT> sp . fit ( X_sp , Y ) <NEWLINE> nose_assert_equal ( len ( foo ) , 1 , msg = foo ) <NEWLINE> nose_assert_equal ( foo [ 0 ] . category , ConvergenceWarning , <NEWLINE> <INDENT> msg = foo [ 0 ] . category ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from __future__ import division , absolute_import , print_function <NEWLINE> __all__ = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> from . import numeric as _nx <NEWLINE> from . numeric import array , asanyarray , newaxis <NEWLINE>
import logging <NEWLINE> from hashlib import sha1 <NEWLINE> from pylons import app_globals <NEWLINE> log = logging . getLogger ( __name__ ) <NEWLINE> SEP = <STRING> <NEWLINE>
def electrum_path ( self ) : <NEWLINE> <INDENT> path = self . get ( <STRING> ) <NEWLINE> if path is None : <NEWLINE> <INDENT> path = self . user_dir ( ) <NEWLINE> <DEDENT> if self . get ( <STRING> ) : <NEWLINE> <INDENT> path = os . path . join ( path , <STRING> ) <NEWLINE> <DEDENT> if not os . path . exists ( path ) : <NEWLINE> <INDENT> if os . path . islink ( path ) : <NEWLINE> <INDENT> raise BaseException ( <STRING> + path ) <NEWLINE> <DEDENT> os . mkdir ( path ) <NEWLINE> <DEDENT> self . print_error ( <STRING> , path ) <NEWLINE> return path <NEWLINE> <DEDENT>
def __init__ ( self , mainWindow , * args , ** kwargs ) : <NEWLINE> <INDENT> super ( ) . __init__ ( * args , ** kwargs ) <NEWLINE> self . window = mainWindow <NEWLINE> <DEDENT>
class product_template ( models . Model ) : <NEWLINE> <INDENT> _inherit = <STRING> <NEWLINE> other_sale_description = fields . Char ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
class VoteUpCommentAction ( VoteUpAction ) : <NEWLINE> <INDENT> def repute_users ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def process_action ( self ) : <NEWLINE> <INDENT> self . process_vote_action ( 1 ) <NEWLINE> <DEDENT> def cancel_action ( self ) : <NEWLINE> <INDENT> super ( VoteUpAction , self ) . cancel_action ( ) <NEWLINE> <DEDENT> def describe ( self , viewer = None ) : <NEWLINE> <INDENT> return self . describe_vote ( _ ( <STRING> ) , viewer ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , parent = None ) : <NEWLINE> <INDENT> super ( ) . __init__ ( parent ) <NEWLINE> self . player = Player ( ) <NEWLINE> self . resize ( 15 , 15 ) <NEWLINE> self . _current_mode = self . player . playback_mode <NEWLINE> self . _set_mode ( ) <NEWLINE> <DEDENT>
def request ( self , path , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . http_client . fetch ( self . get_url ( path ) , self . stop , ** kwargs ) <NEWLINE> return self . wait ( ) <NEWLINE> <DEDENT>
from golem . appconfig import CommonConfig <NEWLINE> from golem . core . simpleconfig import SimpleConfig <NEWLINE> from golem . testutils import TempDirFixture <NEWLINE>
def txt_to_cfg ( pos ) : <NEWLINE> <INDENT> file = <STRING> % pos <NEWLINE> lines = open ( file ) . readlines ( ) <NEWLINE> for line in lines : <NEWLINE> <INDENT> word = line . strip ( ) <NEWLINE> word = word . replace ( <STRING> , <STRING> ) <NEWLINE> rule = <STRING> % ( pos , word ) <NEWLINE> yield rule <NEWLINE> <DEDENT> <DEDENT>
def decode_mixture ( P , entropy_cutoff ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> nr_seqs = numarray . shape ( P ) [ 0 ] <NEWLINE> result = [ None ] * nr_seqs <NEWLINE> for i in xrange ( nr_seqs ) : <NEWLINE> <INDENT> e = Entropy ( P [ i ] ) <NEWLINE> if e < entropy_cutoff : <NEWLINE> <INDENT> result [ i ] = int ( numarray . argmax ( P [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <DEDENT>
__author__ = <STRING> <NEWLINE> <STRING> <NEWLINE> __version__ = <STRING> <NEWLINE> <STRING> <NEWLINE> __revision__ = <STRING> <NEWLINE> <STRING> <NEWLINE> __date__ = <STRING> <NEWLINE> <STRING> <NEWLINE> __copyright__ = <STRING> <NEWLINE> <STRING> <NEWLINE> __license__ = <STRING> <NEWLINE> <STRING> <NEWLINE> import unittest <NEWLINE> import appier <NEWLINE>
def _write_lcd ( self ) : <NEWLINE> <INDENT> if self . ablib_available : <NEWLINE> <INDENT> self . lcd . setcurpos ( 0 , 0 ) <NEWLINE> self . lcd . putstring ( <STRING> ) <NEWLINE> timestring = time . strftime ( <STRING> ) <NEWLINE> self . lcd . setcurpos ( 0 , 1 ) <NEWLINE> self . lcd . putstring ( timestring ) <NEWLINE> <DEDENT> <DEDENT>
def load_abstracts ( ) : <NEWLINE> <INDENT> f = open ( p + <STRING> , <STRING> ) <NEWLINE> reader = csv . reader ( f ) <NEWLINE> for row in reader : <NEWLINE> <INDENT> papers [ row [ 0 ] ] = { <NEWLINE> <INDENT> <STRING> : unicode ( row [ 1 ] , <STRING> ) , <NEWLINE> <STRING> : unicode ( row [ 2 ] , <STRING> ) } <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def setController ( self , controller ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . _controller = controller <NEWLINE> pass <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import greentest <NEWLINE> from gevent import monkey <NEWLINE> monkey . patch_all ( ) <NEWLINE> import sys <NEWLINE> try : <NEWLINE> <INDENT> import urllib2 <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> from urllib import request as urllib2 <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> import BaseHTTPServer <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> from http import server as BaseHTTPServer <NEWLINE> <DEDENT> import gevent <NEWLINE>
from django . http import HttpResponse <NEWLINE> from django . template import RequestContext , loader <NEWLINE> from fedinv import settings <NEWLINE> from event . forms import EventForm <NEWLINE> from swag . models import SwagType <NEWLINE>
import os <NEWLINE> import flask_app <NEWLINE> from zair import __all__ <NEWLINE> app = flask_app . app <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> app . run ( host = <STRING> , port = int ( os . environ . get ( <STRING> , 8080 ) ) , debug = app . config [ <STRING> ] ) <NEWLINE> <DEDENT>
class FixedLastmodMixedSitemap ( Sitemap ) : <NEWLINE> <INDENT> changefreq = <STRING> <NEWLINE> priority = 0.5 <NEWLINE> location = <STRING> <NEWLINE> loop = 0 <NEWLINE> def items ( self ) : <NEWLINE> <INDENT> o1 = TestModel ( ) <NEWLINE> o1 . lastmod = datetime ( 2013 , 3 , 13 , 10 , 0 , 0 ) <NEWLINE> o2 = TestModel ( ) <NEWLINE> return [ o1 , o2 ] <NEWLINE> <DEDENT> <DEDENT>
def upgrade ( ) : <NEWLINE> <INDENT> op . alter_column ( <STRING> , <STRING> , <NEWLINE> <INDENT> existing_type = mysql . VARCHAR ( length = 20 ) , <NEWLINE> nullable = False ) <NEWLINE> <DEDENT> op . add_column ( <STRING> , sa . Column ( <STRING> , sa . Text ( ) , nullable = True ) ) <NEWLINE> <DEDENT>
class DateTimeGenerator ( TemplateArgsGenerator ) : <NEWLINE> <INDENT> def __init__ ( self , name , format ) : <NEWLINE> <INDENT> self . name = name <NEWLINE> self . format = format <NEWLINE> <DEDENT> def gen_args ( self ) : <NEWLINE> <INDENT> yield self . name , datetime . datetime . now ( ) . strftime ( self . format ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from django . conf . urls import url <NEWLINE> import lists . views as views <NEWLINE> urlpatterns = [ <NEWLINE> <INDENT> url ( <STRING> , views . new_list , name = <STRING> ) , <NEWLINE> url ( <STRING> , views . view_list , name = <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE>
def unctrl ( ch ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return b2s ( curses . unctrl ( ch ) ) <NEWLINE> <DEDENT>
class MicrocomputerAdmin ( admin . ModelAdmin ) : <NEWLINE> <INDENT> list_display = ( <STRING> , <STRING> ) <NEWLINE> ordering = ( <STRING> , ) <NEWLINE> <DEDENT>
def run ( self ) : <NEWLINE> <INDENT> for serieLocalID in self . toRefresh . copy ( ) : <NEWLINE> <INDENT> if serieLocalID in self . updateInProgress : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> task = DownloadSerieTask ( serieLocalID ) <NEWLINE> runnable = Runnable ( task ) <NEWLINE> runnable . task . serieUpdated . connect ( self . _serieUpdated ) <NEWLINE> runnable . task . serieUpdateStatus . connect ( self . serieUpdateStatus ) <NEWLINE> self . threadPool . tryStart ( runnable ) <NEWLINE> self . toRefresh . discard ( serieLocalID ) <NEWLINE> self . updateInProgress . add ( serieLocalID ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> msg = input ( ) <NEWLINE> print ( msg . swapcase ( ) ) <NEWLINE>
def remove ( self , collection_name , criteria ) : <NEWLINE> <INDENT> api = self . collection ( collection_name ) <NEWLINE> return api . remove ( criteria ) <NEWLINE> <DEDENT>
from oslo_log import log as logging <NEWLINE> from sqlalchemy import Column , ForeignKey , MetaData , Table <NEWLINE> from sqlalchemy import Boolean , DateTime , Integer , String <NEWLINE> from cinder . i18n import _ <NEWLINE> LOG = logging . getLogger ( __name__ ) <NEWLINE>
<STRING> <NEWLINE> import logging <NEWLINE> import os <NEWLINE> import re <NEWLINE> import socket <NEWLINE> import sys <NEWLINE> from webkitpy . layout_tests . servers import http_server_base <NEWLINE> _log = logging . getLogger ( __name__ ) <NEWLINE>
def register ( ) : <NEWLINE> <INDENT> bpy . utils . register_class ( BisectMirror ) <NEWLINE> bpy . utils . register_class ( AutoMirror ) <NEWLINE> bpy . utils . register_class ( AlignVertices ) <NEWLINE> <DEDENT>
from setuptools import setup <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> packages = [ <STRING> ] , <NEWLINE> include_package_data = True , <NEWLINE> install_requires = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> <NEWLINE> <DEDENT> ] , <NEWLINE> <DEDENT> ) <NEWLINE>
from zipa import api_github_com as github <NEWLINE> repos = github . orgs . django . repos <NEWLINE> for repo in repos [ { <STRING> : <STRING> , <STRING> : <STRING> } ] : <NEWLINE> <INDENT> print ( repo . name ) <NEWLINE> <DEDENT>
def m ( i , j , L , M ) : <NEWLINE> <INDENT> if M - s ( i , j , L ) >= 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cont = inf <NEWLINE> for k in range ( i , j ) : <NEWLINE> <INDENT> aux = S ( i , k , M , L ) + m ( k + 1 , j , L , M ) <NEWLINE> if aux < cont : <NEWLINE> <INDENT> cont = aux <NEWLINE> <DEDENT> <DEDENT> return cont <NEWLINE> <DEDENT> <DEDENT>
def list_ace ( archive , compression , cmd , verbosity , interactive ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> cmdlist = [ cmd ] <NEWLINE> if verbosity > 1 : <NEWLINE> <INDENT> cmdlist . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cmdlist . append ( <STRING> ) <NEWLINE> <DEDENT> cmdlist . append ( archive ) <NEWLINE> return cmdlist <NEWLINE> <DEDENT>
from __future__ import ( absolute_import , division , print_function ) <NEWLINE> from six . moves import ( filter , input , map , range , zip ) <NEWLINE> import iris . tests as tests <NEWLINE> from iris . std_names import STD_NAMES <NEWLINE>
def _killcurses ( signal , frame ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> curses . echo ( ) <NEWLINE> curses . nocbreak ( ) <NEWLINE> curses . endwin ( ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from XdY import * <NEWLINE> from series import InfiniteSequence <NEWLINE>
def supress_warnings ( ) : <NEWLINE> <INDENT> original_warn = warnings . warn <NEWLINE> warnings . warn = silent_warnings <NEWLINE> yield <NEWLINE> warnings . warn = original_warn <NEWLINE> <DEDENT>
class SetLangNavPlugin ( BaseAdminPlugin ) : <NEWLINE> <INDENT> def block_top_navmenu ( self , context , nodes ) : <NEWLINE> <INDENT> context = get_context_dict ( context ) <NEWLINE> context [ <STRING> ] = self . request . get_full_path ( ) <NEWLINE> nodes . append ( loader . render_to_string ( <STRING> , context = context ) ) <NEWLINE> <DEDENT> <DEDENT>
def calculate_perplexity ( log_probs ) : <NEWLINE> <INDENT> perp = 0 <NEWLINE> for p in log_probs : <NEWLINE> <INDENT> perp += - p <NEWLINE> <DEDENT> return np . exp ( perp / len ( log_probs ) ) <NEWLINE> <DEDENT>
class DetailsMixin ( DescriptionMixin ) : <NEWLINE> <INDENT> def __init__ ( self , * args , ** kwargs ) : <NEWLINE> <INDENT> self . required = kwargs . pop ( <STRING> , None ) <NEWLINE> super ( DetailsMixin , self ) . __init__ ( * args , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT>
def implied_subfeature ( feature , subvalue , value_string ) : <NEWLINE> <INDENT> assert isinstance ( feature , Feature ) <NEWLINE> assert isinstance ( subvalue , basestring ) <NEWLINE> assert isinstance ( value_string , basestring ) <NEWLINE> result = __find_implied_subfeature ( feature , subvalue , value_string ) <NEWLINE> if not result : <NEWLINE> <INDENT> raise InvalidValue ( <STRING> % ( subvalue , feature , value_string ) ) <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT>
from nose . tools import eq_ , raises <NEWLINE> from nanodb_driver . driver import Driver , ConnectionTimedOut , ServerRequestError <NEWLINE> from test . helper import MockServer <NEWLINE>
import codecs <NEWLINE> from ansiblereview import Result , Error <NEWLINE> from ansiblelint . utils import get_action_tasks , normalize_task , parse_yaml_linenumbers <NEWLINE>
def token ( self , token ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . header ( <STRING> , <STRING> . format ( token ) ) <NEWLINE> <DEDENT>
__version__ = <STRING> <NEWLINE> __version_info__ = ( 0 , 5 , 0 ) <NEWLINE> from django . utils . translation import ugettext_lazy as _ <NEWLINE>
def match ( self , vistrail , action ) : <NEWLINE> <INDENT> self . setCurrentVistrail ( vistrail ) <NEWLINE> query = self . queries_by_vistrail [ vistrail ] <NEWLINE> return query . match ( vistrail , action ) <NEWLINE> <DEDENT>
def _get_prop ( self , prop ) : <NEWLINE> <INDENT> if prop == <STRING> : <NEWLINE> <INDENT> return self . get_src ( ) <NEWLINE> <DEDENT> return super ( self . __class__ , self ) . _get_prop ( prop ) <NEWLINE> <DEDENT>
from sympy import diff , Eq , init_printing , pprint , symbols , simplify <NEWLINE> init_printing ( ) <NEWLINE> C , Ca , Cb , f , F , rhoS = symbols ( <STRING> ) <NEWLINE> chemenergy = rhoS * ( C - Ca ) ** 2 * ( Cb - C ) ** 2 <NEWLINE> pprint ( Eq ( F , simplify ( chemenergy ) ) ) <NEWLINE> pprint ( Eq ( f , simplify ( diff ( chemenergy , C ) ) ) ) <NEWLINE>
def __nonzero__ ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . _rrule is not None <NEWLINE> <DEDENT>
def get_path_hash ( self , unhashed_path ) : <NEWLINE> <INDENT> if self . hash_cache . get_path_hash ( unhashed_path ) is None : <NEWLINE> <INDENT> file = self . get_file ( unhashed_path ) <NEWLINE> if file is None : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> hash_str = get_hash ( file . handle ) <NEWLINE> self . hash_cache . set_path_hash ( unhashed_path , hash_str ) <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> file . handle . close ( ) <NEWLINE> <DEDENT> <DEDENT> return self . hash_cache . get_path_hash ( unhashed_path ) <NEWLINE> <DEDENT>
class Command ( BaseCommand ) : <NEWLINE> <INDENT> help = <STRING> <NEWLINE> def handle ( self , * args , ** options ) : <NEWLINE> <INDENT> email_unpaid_orders ( verbose = options [ <STRING> ] ) <NEWLINE> if options [ <STRING> ] > 0 : <NEWLINE> <INDENT> self . stdout . write ( self . style . SUCCESS ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def build_directory ( ) : <NEWLINE> <INDENT> if os . path . exists ( <STRING> ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> os . mkdir ( <STRING> ) <NEWLINE> <DEDENT> if os . path . exists ( whoosh_database ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> os . makedirs ( whoosh_database ) <NEWLINE> <DEDENT> <DEDENT>
def forwards ( self , orm ) : <NEWLINE> <INDENT> db . add_column ( <STRING> , <STRING> , <NEWLINE> <INDENT> self . gf ( <STRING> ) ( unique_with = ( ) , max_length = 50 , blank = True , populate_from = None , unique = True , null = True ) , <NEWLINE> keep_default = False ) <NEWLINE> <DEDENT> <DEDENT>
import json <NEWLINE> import httpretty <NEWLINE> from w3af_api_client import Connection <NEWLINE> from w3af_api_client . tests . base import BaseAPITest <NEWLINE> from w3af_api_client . tests . test_scan import INDEX_RESPONSE , VERSION_RESPONSE <NEWLINE> SCAN_LIST_RESPONSE = json . dumps ( { <STRING> : [ { <STRING> : 0 , <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : [ <STRING> ] , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : True } , <NEWLINE> { <STRING> : 1 , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : [ <STRING> ] , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : False } <NEWLINE> ] } ) <NEWLINE> <DEDENT>
from libopenzwave . _version import __version__ <NEWLINE> from libopenzwave . _global import * <NEWLINE> from libopenzwave . manager import PyManager <NEWLINE> from libopenzwave . options import PyOptions <NEWLINE>
class EfficientFib ( object ) : <NEWLINE> <INDENT> cache = { } <NEWLINE> def calc ( self , n ) : <NEWLINE> <INDENT> if n < 2 : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> if n in self . cache : <NEWLINE> <INDENT> return self . cache [ n ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fibn = self . calc ( n - 1 ) + self . calc ( n - 2 ) <NEWLINE> self . cache [ n ] = fibn <NEWLINE> return fibn <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_set_single_string_contents_via_init ( self ) : <NEWLINE> <INDENT> x = FileMocker ( <STRING> ) <NEWLINE> self . assertEqual ( x ( <STRING> ) . read ( ) , <STRING> ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from math import hypot <NEWLINE> from math import sqrt <NEWLINE>
def forwards ( self , orm ) : <NEWLINE> <INDENT> db . add_column ( <STRING> , <STRING> , <NEWLINE> <INDENT> self . gf ( <STRING> ) ( max_length = 10 , null = True ) , <NEWLINE> keep_default = False ) <NEWLINE> <DEDENT> <DEDENT>
import datetime <NEWLINE> import re <NEWLINE> from functools import total_ordering <NEWLINE> from math import floor <NEWLINE> from dateutil . parser import parse <NEWLINE> from bvggrabber . utils . format import timeformat <NEWLINE> from bvggrabber . utils . json import ObjectJSONEncoder <NEWLINE>
def endsInLeft ( self , str ) : <NEWLINE> <INDENT> endsInRegex = <STRING> <NEWLINE> matching = bool ( re . match ( endsInRegex , str . upper ( ) ) ) <NEWLINE> return matching <NEWLINE> <DEDENT>
import sys <NEWLINE> import platform <NEWLINE> if platform . python_version ( ) < <STRING> : <NEWLINE> <INDENT> import unittest2 as unittest <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> import unittest <NEWLINE> <DEDENT> from os . path import dirname <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> here = dirname ( __file__ ) <NEWLINE> sys . path . insert ( 0 , here + <STRING> ) <NEWLINE> <DEDENT> import ctrie <NEWLINE>
import sys <NEWLINE> import os . path <NEWLINE> from django . core . management import execute_manager <NEWLINE> from django . core . management import setup_environ , execute_from_command_line <NEWLINE> try : <NEWLINE> <INDENT> import settings <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> sys . stderr . write ( <STRING> % __file__ ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> sys . path . insert ( 0 , settings . PROJECT_ROOT . replace ( <STRING> , <STRING> ) ) <NEWLINE> setup_environ ( settings ) <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> execute_from_command_line ( ) <NEWLINE> <DEDENT>
def __init__ ( self ) : <NEWLINE> <INDENT> super ( WalktoTemplateSM , self ) . __init__ ( ) <NEWLINE> self . name = <STRING> <NEWLINE> self . add_parameter ( <STRING> , <STRING> ) <NEWLINE> self . add_parameter ( <STRING> , <STRING> ) <NEWLINE> <DEDENT>
def __dateTimeChanged ( self , qDateTime ) : <NEWLINE> <INDENT> delimited = str ( qDateTime . toString ( QtCore . Qt . ISODate ) ) <NEWLINE> undelimited = <STRING> % ( <NEWLINE> <INDENT> delimited [ 0 : 4 ] , <NEWLINE> delimited [ 5 : 7 ] , <NEWLINE> delimited [ 8 : 10 ] , <NEWLINE> delimited [ 11 : 13 ] , <NEWLINE> delimited [ 14 : 16 ] , <NEWLINE> delimited [ 17 : 19 ] , <NEWLINE> <DEDENT> ) <NEWLINE> with Gaffer . UndoContext ( self . getPlug ( ) . ancestor ( Gaffer . ScriptNode ) ) : <NEWLINE> <INDENT> self . getPlug ( ) . setValue ( undelimited ) <NEWLINE> <DEDENT> <DEDENT>
def recur_node ( node , level = 0 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * level + <STRING> + str ( node ) ) <NEWLINE> for child in node . children : <NEWLINE> <INDENT> recur_node ( child , level + 1 ) <NEWLINE> <DEDENT> <DEDENT>
def backwards ( self , orm ) : <NEWLINE> <INDENT> db . add_column ( <STRING> , <STRING> , <NEWLINE> <INDENT> self . gf ( <STRING> ) ( max_length = 100 , null = True , blank = True ) , <NEWLINE> keep_default = False ) <NEWLINE> <DEDENT> raise RuntimeError ( <STRING> ) <NEWLINE> db . alter_column ( <STRING> , <STRING> , self . gf ( <STRING> ) ( max_length = 100 ) ) <NEWLINE> <DEDENT>
class Square ( Shape ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> Shape . __init__ ( self ) <NEWLINE> self . polygon = Polygon ( ( ( 0 , 0 ) , ( 25 , 0 ) , ( 25 , 25 ) , ( 0 , 25 ) ) ) <NEWLINE> <DEDENT> <DEDENT>
def check_language_code ( code ) : <NEWLINE> <INDENT> if code is None : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> code = str_to_unicode ( code ) <NEWLINE> if code not in getUtility ( ILanguageManager ) : <NEWLINE> <INDENT> msg = <STRING> . format ( code ) <NEWLINE> raise Import21Error ( msg ) <NEWLINE> <DEDENT> return code <NEWLINE> <DEDENT>
from token_reader import USBTokenReader , NoTokensAvailableError , read_tokens_from_file <NEWLINE> from token import BadTokenFormatError , Token <NEWLINE> from token_collector import MQTTCollector , GITCollector , MailCollector , MQTTTokenForwarder <NEWLINE>
<STRING> <NEWLINE> import argparse <NEWLINE> import os <NEWLINE> import shlex <NEWLINE> import subprocess <NEWLINE> import time <NEWLINE>
class ActionsTests ( unittest . TestCase ) : <NEWLINE> <INDENT> def setUp ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def test_interpreter_do_method ( self ) : <NEWLINE> <INDENT> self . assertTrue ( hasattr ( TestAction , <STRING> ) ) <NEWLINE> <DEDENT> def test_do ( self ) : <NEWLINE> <INDENT> interpreter = mock . Mock ( ) <NEWLINE> action = TestAction ( attr_1 = 1 , attr_2 = 666 ) <NEWLINE> action . do ( interpreter ) <NEWLINE> self . assertEqual ( interpreter . do_test_action . call_args_list , [ mock . call ( action = action ) ] ) <NEWLINE> <DEDENT> <DEDENT>
import os <NEWLINE> from task import Task , Project <NEWLINE> __version__ = 1 <NEWLINE>
def startService ( self ) : <NEWLINE> <INDENT> service . Service . startService ( self ) <NEWLINE> self . calls = [ task . LoopingCall ( d . transfer ) for d in self . domains ] <NEWLINE> i = 0 <NEWLINE> from twisted . internet import reactor <NEWLINE> for c in self . calls : <NEWLINE> <INDENT> reactor . callLater ( i , c . start , 60 * 60 ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT>
def __getattr__ ( self , key ) : <NEWLINE> <INDENT> if key in self . __DEFAULTS : <NEWLINE> <INDENT> return getattr ( self . settings , <NEWLINE> <INDENT> self . prefix + key , self . __DEFAULTS [ key ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> from django . core . exceptions import ImproperlyConfigured <NEWLINE> try : <NEWLINE> <INDENT> return getattr ( self . settings , self . prefix + key ) <NEWLINE> <DEDENT> except AttributeError : <NEWLINE> <INDENT> raise ImproperlyConfigured ( <STRING> % self . prefix + key ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from functools import wraps <NEWLINE> from twisted . internet import defer <NEWLINE>
import pandas as pd <NEWLINE> import sys <NEWLINE> savename = sys . argv [ 1 ] <NEWLINE> filename_1990 = <STRING> <NEWLINE> filename_2004 = <STRING> <NEWLINE> filename_2006 = <STRING> <NEWLINE> filename_2008 = <STRING> <NEWLINE> filename_2010 = <STRING> <NEWLINE> filename_2012 = <STRING> <NEWLINE> earthquakes_1990 = pd . read_csv ( filename_1990 , sep = <STRING> ) <NEWLINE> earthquakes_2004 = pd . read_csv ( filename_2004 , sep = <STRING> ) <NEWLINE> earthquakes_2006 = pd . read_csv ( filename_2006 , sep = <STRING> ) <NEWLINE> earthquakes_2008 = pd . read_csv ( filename_2008 , sep = <STRING> ) <NEWLINE> earthquakes_2010 = pd . read_csv ( filename_2010 , sep = <STRING> ) <NEWLINE> earthquakes_2012 = pd . read_csv ( filename_2012 , sep = <STRING> ) <NEWLINE>
import six <NEWLINE> collect_ignore = [ ] <NEWLINE> if six . PY3 : <NEWLINE> <INDENT> for fn in open ( <STRING> ) : <NEWLINE> <INDENT> if fn . strip ( ) : <NEWLINE> <INDENT> collect_ignore . append ( fn . strip ( ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_mapping ( modules ) : <NEWLINE> <INDENT> return [ <NEWLINE> <INDENT> ( <STRING> , MainHandler ) , <NEWLINE> ( <STRING> , CoinbaseWatcherHandler , dict ( modules = modules ) ) , <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from desispec . io import read_frame <NEWLINE> from desispec . io import read_fibermap <NEWLINE> from desispec . io import read_fiberflat <NEWLINE> from desispec . io import write_sky <NEWLINE> from desispec . fiberflat import apply_fiberflat <NEWLINE> from desispec . sky import compute_sky <NEWLINE> from desispec . log import get_logger <NEWLINE> import argparse <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE>
<STRING> <NEWLINE> print ( __doc__ ) <NEWLINE> import cv2 <NEWLINE> from simplecv . api import Color , Image <NEWLINE> from simplecv . ui import Window <NEWLINE>
import mock <NEWLINE> from hwk import udev <NEWLINE> from hwk . tests . unit import base <NEWLINE>
from tornado . tcpserver import TCPServer <NEWLINE> from tornado . tcpclient import TCPClient <NEWLINE> from tornado . iostream import StreamClosedError <NEWLINE> from tornado . ioloop import IOLoop , PeriodicCallback <NEWLINE> from tornado import gen <NEWLINE>
def cancel ( cls , payments ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> PaymentTransaction = Pool ( ) . get ( <STRING> ) <NEWLINE> payment_transactions = [ ] <NEWLINE> for payment in payments : <NEWLINE> <INDENT> payment_transactions . extend ( payment . payment_transactions ) <NEWLINE> <DEDENT> PaymentTransaction . cancel ( payment_transactions ) <NEWLINE> <DEDENT>
from OSIM . Modeling . CircuitSystemEquations import CircuitSystemEquations <NEWLINE> from OSIM . Simulation . CircuitAnalysis . CircuitAnalyser import CircuitAnalyser <NEWLINE> from OSIM . Simulation . NetToComp import NetToComp <NEWLINE> seq = CircuitSystemEquations ( NetToComp ( <STRING> ) . getComponents ( ) ) <NEWLINE> ca = CircuitAnalyser ( seq ) <NEWLINE> ca . printDCOp ( [ <STRING> ] ) <NEWLINE>
def err_check ( r ) : <NEWLINE> <INDENT> x = r . json ( ) <NEWLINE> try : <NEWLINE> <INDENT> if x [ <STRING> ] == <STRING> : <NEWLINE> <INDENT> raise InvalidPhoneNumber ( <STRING> % r . json ( ) , r . json ( ) ) <NEWLINE> <DEDENT> <DEDENT> except KeyError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> if r . status_code == 202 or r . status_code == 200 : <NEWLINE> <INDENT> return r . text <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise SonarError ( <STRING> % r . status_code , r . status_code ) <NEWLINE> <DEDENT> <DEDENT>
def _print_name ( self , name , data = None ) : <NEWLINE> <INDENT> if data is None : <NEWLINE> <INDENT> self . _handle . write ( <STRING> % ( <STRING> * self . _colwidth , name ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . _handle . write ( <STRING> % ( <NEWLINE> <INDENT> self . _colwidth , name [ : self . _colwidth ] , <NEWLINE> data [ : self . _maxwidth - self . _colwidth - 2 ] . rstrip ( ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from setuptools import setup <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> version = <STRING> , <NEWLINE> py_modules = [ <STRING> ] , <NEWLINE> install_requires = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <DEDENT> ] , <NEWLINE> entry_points = <STRING> , <NEWLINE> <DEDENT> ) <NEWLINE>
def heapSort ( lst ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> t = len ( lst ) <NEWLINE> i = arrayHeap . mkHeap ( t , arrayHeap . less ) <NEWLINE> r = [ ] <NEWLINE> for elem in lst : <NEWLINE> <INDENT> arrayHeap . add ( i , elem ) <NEWLINE> <DEDENT> for el in range ( len ( lst ) ) : <NEWLINE> <INDENT> r . append ( arrayHeap . removeMin ( i ) ) <NEWLINE> <DEDENT> return r <NEWLINE> <DEDENT>
class ApacheModfcgidPlugin ( Plugin ) : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> homepage = <STRING> <NEWLINE> matchers = [ <NEWLINE> <INDENT> { <STRING> : ( <STRING> , <STRING> ) } , <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT>
def unpack ( archive , to_directory = None ) : <NEWLINE> <INDENT> if not to_directory : <NEWLINE> <INDENT> to_directory = os . path . dirname ( archive . name ) <NEWLINE> <DEDENT> if archive . name . endswith ( <STRING> ) : <NEWLINE> <INDENT> return extract_zip ( archive , to_directory ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> file_list = extract_tar_file ( archive , to_directory ) <NEWLINE> return [ x . name for x in file_list ] <NEWLINE> <DEDENT> <DEDENT>
def default_script ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return <STRING> <NEWLINE> <DEDENT>
import json <NEWLINE> from decimal import Decimal <NEWLINE> from datetime import datetime , date <NEWLINE>
import io <NEWLINE> import os <NEWLINE> import sys <NEWLINE> import time <NEWLINE> from IOST_Prepare import IOST_Prepare <NEWLINE> from IOST_Config import * <NEWLINE> import gtk <NEWLINE> import gtk . glade <NEWLINE> IOST_WMain_AutoMail_Debug_Enable = 1 <NEWLINE>
class MyInteractive ( cmd . Cmd ) : <NEWLINE> <INDENT> intro = <STRING> + <STRING> <NEWLINE> prompt = <STRING> <NEWLINE> file = None <NEWLINE> @ docopt_cmd <NEWLINE> def do_tcp ( self , arg ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( arg ) <NEWLINE> <DEDENT> @ docopt_cmd <NEWLINE> def do_serial ( self , arg ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( arg ) <NEWLINE> <DEDENT> def do_quit ( self , arg ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
import os <NEWLINE> from DIRAC import S_OK , S_ERROR , gConfig , gLogger <NEWLINE> from DIRAC . Core . Utilities import List <NEWLINE> from DIRAC . ConfigurationSystem . Client . Helpers import Registry <NEWLINE> from DIRAC . ConfigurationSystem . Client . Helpers import CSGlobals <NEWLINE> from DIRAC . Core . DISET . AuthManager import AuthManager <NEWLINE> from DIRAC . Core . DISET . ThreadConfig import ThreadConfig <NEWLINE> from WebAppDIRAC . Lib import Conf <NEWLINE>
def test_main ( ) : <NEWLINE> <INDENT> global boundaries , linecount <NEWLINE> boundaries = 0 <NEWLINE> linecount = 0 <NEWLINE> f = cStringIO . StringIO ( msg ) <NEWLINE> getMIMEMsg ( multifile . MultiFile ( f ) ) <NEWLINE> assert boundaries == 2 <NEWLINE> assert linecount == 9 <NEWLINE> <DEDENT>
def edgesFromBoolImg ( arr , dtype = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> out = np . zeros_like ( arr , dtype = dtype ) <NEWLINE> _calc ( arr , out ) <NEWLINE> _calc ( arr . T , out . T ) <NEWLINE> return out <NEWLINE> <DEDENT>
def run ( core , actor , target , commandString ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT>
from flask import current_app <NEWLINE> from functools import wraps <NEWLINE> from hashlib import md5 <NEWLINE> from changes . ext . redis import UnableToGetLock <NEWLINE> from changes . config import redis <NEWLINE>
def test_id_to_name_and_params_list_args ( self ) : <NEWLINE> <INDENT> task_id = <STRING> <NEWLINE> ( name , params ) = luigi . task . id_to_name_and_params ( task_id ) <NEWLINE> self . assertEquals ( name , <STRING> ) <NEWLINE> self . assertEquals ( params , dict ( date = <STRING> , foo = [ <STRING> , <STRING> ] ) ) <NEWLINE> <DEDENT>
def __init__ ( self , game ) : <NEWLINE> <INDENT> self . game = game <NEWLINE> self . dpad = { } <NEWLINE> <DEDENT>
def test_create_region_with_conflicting_ids ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ref = self . new_region_ref ( ) <NEWLINE> self . put ( <NEWLINE> <INDENT> <STRING> % uuid . uuid4 ( ) . hex , <NEWLINE> body = { <STRING> : ref } , <NEWLINE> expected_status = 400 ) <NEWLINE> <DEDENT> <DEDENT>
def __getitem__ ( self , key ) : <NEWLINE> <INDENT> if isinstance ( key , str ) or isinstance ( key , unicode ) : <NEWLINE> <INDENT> if key in self . headers : <NEWLINE> <INDENT> pos = self . headers . index ( key ) <NEWLINE> return [ row [ pos ] for row in self . _data ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise KeyError <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> _results = self . _data [ key ] <NEWLINE> if isinstance ( _results , Row ) : <NEWLINE> <INDENT> return _results . tuple <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ result . tuple for result in _results ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from __future__ import unicode_literals <NEWLINE> import os <NEWLINE> from paste . deploy import loadapp <NEWLINE> from waitress import serve <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> port = int ( os . environ . get ( <STRING> , 5000 ) ) <NEWLINE> app = loadapp ( <STRING> , relative_to = <STRING> ) <NEWLINE> serve ( app , host = <STRING> , port = port ) <NEWLINE> <DEDENT>
def test_actual_code ( ) : <NEWLINE> <INDENT> text = <STRING> <NEWLINE> expected = <STRING> <NEWLINE> assert_transform ( sqla_count , text , [ expected ] ) <NEWLINE> <DEDENT>
def set_resource_image_from_url ( self , url ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> req = urllib2 . Request ( url , headers = { <STRING> : <STRING> } ) <NEWLINE> f = urllib2 . urlopen ( req ) <NEWLINE> self . set_resource_image ( f ) <NEWLINE> f . close ( ) <NEWLINE> <DEDENT>
def bin ( num , width = 0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> num = long ( num ) <NEWLINE> s = _int2bitstring ( num ) <NEWLINE> if width : <NEWLINE> <INDENT> pad = <STRING> <NEWLINE> if num < 0 : <NEWLINE> <INDENT> pad = <STRING> <NEWLINE> <DEDENT> return ( width - len ( s ) ) * pad + s <NEWLINE> <DEDENT> return s <NEWLINE> <DEDENT>
def drawCheck ( surface , widget ) : <NEWLINE> <INDENT> if not widget . enabled : <NEWLINE> <INDENT> s2 = <STRING> <NEWLINE> <DEDENT> elif widget . focused : <NEWLINE> <INDENT> s2 = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s2 = <STRING> <NEWLINE> <DEDENT> if widget . checked : <NEWLINE> <INDENT> s3 = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s3 = <STRING> <NEWLINE> <DEDENT> style = <STRING> % ( widget . style or <STRING> , s2 , s3 ) <NEWLINE> drawBox ( surface , widget , style ) <NEWLINE> drawTextAndIcons ( surface , widget , style ) <NEWLINE> return widget . rect <NEWLINE> <DEDENT>
def dist_qualifier ( cls , dist ) : <NEWLINE> <INDENT> dist_key = dist . strip ( ) . lower ( ) <NEWLINE> if dist_key in [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> return <STRING> . format ( dist_key ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> . format ( dist_key ) <NEWLINE> <DEDENT> <DEDENT>
def dump ( self , team , order ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> , team , <STRING> , order , <STRING> , order [ <STRING> ] ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
def _get_trusted ( self , cr , uid , context = None ) : <NEWLINE> <INDENT> if context == None : <NEWLINE> <INDENT> context = { } <NEWLINE> <DEDENT> return context . get ( <STRING> , False ) <NEWLINE> <DEDENT>
from tests . unit import AWSMockServiceTestCase <NEWLINE> from boto . s3 . connection import S3Connection <NEWLINE> from boto . s3 . bucket import Bucket <NEWLINE> from boto . s3 . tagging import Tag <NEWLINE>
def assert_subclass ( item , Class ) : <NEWLINE> <INDENT> if not issubclass ( item , Class ) : <NEWLINE> <INDENT> raise TypeError ( <STRING> . format ( <NEWLINE> <INDENT> expected = Class . __name__ , <NEWLINE> got = item . __name__ <NEWLINE> <DEDENT> ) ) <NEWLINE> <DEDENT> <DEDENT>
from __future__ import unicode_literals <NEWLINE> from __future__ import print_function <NEWLINE> from __future__ import division <NEWLINE> from __future__ import absolute_import <NEWLINE> from future . builtins import next <NEWLINE> from future . builtins import str <NEWLINE> from future import standard_library <NEWLINE> standard_library . install_hooks ( ) <NEWLINE> from past . builtins import basestring <NEWLINE> import io <NEWLINE> import collections <NEWLINE> from . tools import enum , py2_iterable <NEWLINE>
class ContactInformation ( models . Model ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> timestamp = models . DateTimeField ( auto_now_add = True ) <NEWLINE> contact_name = models . CharField ( max_length = 100 , null = False , blank = False ) <NEWLINE> contact_email = models . EmailField ( max_length = 200 , null = False , blank = False ) <NEWLINE> contact_comment = models . TextField ( null = False , blank = False ) <NEWLINE> <DEDENT>
def test_lexer ( sourceFile , outFile ) : <NEWLINE> <INDENT> comp = Compiler ( sourceFile , outFile , True ) <NEWLINE> comp . lexer_driver ( ) <NEWLINE> <DEDENT>
class Migration ( migrations . Migration ) : <NEWLINE> <INDENT> dependencies = [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE> operations = [ <NEWLINE> <INDENT> migrations . AlterField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> field = models . DateTimeField ( default = datetime . datetime ( 2016 , 2 , 5 , 15 , 24 , 23 , 587829 ) , verbose_name = <STRING> , auto_now_add = True ) , <NEWLINE> preserve_default = True , <NEWLINE> <DEDENT> ) , <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT>
def callback ( parser ) : <NEWLINE> <INDENT> if not site . home ( ) : <NEWLINE> <INDENT> sys . exit ( <STRING> ) <NEWLINE> <DEDENT> if not os . path . exists ( site . out ( ) ) : <NEWLINE> <INDENT> sys . exit ( <STRING> ) <NEWLINE> <DEDENT> utils . cleardir ( site . out ( ) ) <NEWLINE> <DEDENT>
import openwns . simulator <NEWLINE> thisSimulator = openwns . simulator . OpenWNS ( ) <NEWLINE> openwns . simulator . setSimulator ( thisSimulator ) <NEWLINE>
def load ( self , config , container_builder ) : <NEWLINE> <INDENT> definition = ioc . component . Definition ( <STRING> , kwargs = { <NEWLINE> <INDENT> <STRING> : ioc . component . Reference ( <STRING> ) <NEWLINE> <DEDENT> } ) <NEWLINE> container_builder . add ( <STRING> , definition ) <NEWLINE> <DEDENT>
def test_write_one_yeast_protein ( ) : <NEWLINE> <INDENT> qid = <STRING> <NEWLINE> taxid = <STRING> <NEWLINE> entrezgene = <STRING> <NEWLINE> _test_write_one_protein ( qid , entrezgene , taxid ) <NEWLINE> <DEDENT>
def gotoURL ( self , url , cookies = None , headers = None ) : <NEWLINE> <INDENT> r = requests . get ( url , cookies = cookies , headers = headers ) <NEWLINE> while int ( r . headers [ <STRING> ] ) <= 3000 : <NEWLINE> <INDENT> print ( <STRING> % url ) <NEWLINE> r = requests . get ( url , cookies = cookies , headers = headers ) <NEWLINE> <DEDENT> return r . text <NEWLINE> <DEDENT>
def gdal_version_info ( ) : <NEWLINE> <INDENT> ver = gdal_version ( ) . decode ( ) <NEWLINE> m = version_regex . match ( ver ) <NEWLINE> if not m : <NEWLINE> <INDENT> raise GDALException ( <STRING> % ver ) <NEWLINE> <DEDENT> return { key : m . group ( key ) for key in ( <STRING> , <STRING> , <STRING> ) } <NEWLINE> <DEDENT>
from __future__ import print_function , unicode_literals <NEWLINE> import os <NEWLINE> import sys <NEWLINE> from logging import DEBUG , FileHandler , getLogger <NEWLINE> from twisted . internet . error import CannotListenError <NEWLINE> from deluge . common import run_profiled <NEWLINE> from deluge . configmanager import get_config_dir <NEWLINE> from deluge . ui . baseargparser import BaseArgParser <NEWLINE> from deluge . ui . translations_util import set_dummy_trans <NEWLINE>
def convertItems ( self , items ) : <NEWLINE> <INDENT> result = Bag ( ) <NEWLINE> for k , node in enumerate ( items ) : <NEWLINE> <INDENT> label = node . label <NEWLINE> value = node . value <NEWLINE> attr = dict ( node . attr ) <NEWLINE> if label == <STRING> : <NEWLINE> <INDENT> label = attr . get ( <STRING> ) <NEWLINE> <DEDENT> if label == <STRING> : <NEWLINE> <INDENT> label = attr . get ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> label = <STRING> % k <NEWLINE> <DEDENT> if label : <NEWLINE> <INDENT> result . setItem ( label , value , attr ) <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <DEDENT>
class Property : <NEWLINE> <INDENT> def __init__ ( self , herbie_name ) : <NEWLINE> <INDENT> self . herbie_name = herbie_name <NEWLINE> <DEDENT> <DEDENT>
def test_access_with_password_in_header ( self , caplog ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> caplog . set_level ( logging . WARNING , <NEWLINE> <INDENT> logger = <STRING> ) <NEWLINE> <DEDENT> req = requests . get ( <NEWLINE> <INDENT> _url ( const . URL_API ) , <NEWLINE> headers = { const . HTTP_HEADER_HA_AUTH : API_PASSWORD } ) <NEWLINE> <DEDENT> assert req . status_code == 200 <NEWLINE> logs = caplog . text <NEWLINE> assert API_PASSWORD not in logs <NEWLINE> <DEDENT>
def describe ( ) : <NEWLINE> <INDENT> from subprocess import check_output <NEWLINE> cwd = os . path . dirname ( __file__ ) <NEWLINE> return check_output ( <STRING> , cwd = cwd , shell = True ) . decode ( <STRING> ) . strip ( ) <NEWLINE> <DEDENT>
def test_bad_metrics_create_subcommand ( self ) : <NEWLINE> <INDENT> argstrings = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <DEDENT> ] <NEWLINE> _shell = monascaclient . shell . MonascaShell ( ) <NEWLINE> for argstr in argstrings : <NEWLINE> <INDENT> self . assertRaises ( SystemExit , _shell . main , argstr . split ( ) ) <NEWLINE> <DEDENT> <DEDENT>
def get_entrance_exam_content ( request , course ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> required_content = get_required_content ( course , request . user ) <NEWLINE> exam_module = None <NEWLINE> for content in required_content : <NEWLINE> <INDENT> usage_key = course . id . make_usage_key_from_deprecated_string ( content ) <NEWLINE> module_item = modulestore ( ) . get_item ( usage_key ) <NEWLINE> if not module_item . hide_from_toc and module_item . is_entrance_exam : <NEWLINE> <INDENT> exam_module = module_item <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> return exam_module <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import xml . etree . cElementTree as ET <NEWLINE> import urllib2 <NEWLINE> from autopkglib import Processor , ProcessorError <NEWLINE> __all__ = [ <STRING> ] <NEWLINE>
from baseparser import BaseParser <NEWLINE> import bs4 <NEWLINE> import re <NEWLINE>
class ItemFilter ( FilterSet ) : <NEWLINE> <INDENT> class Meta : <NEWLINE> <INDENT> model = Item <NEWLINE> fields = { <NEWLINE> <INDENT> <STRING> : [ <STRING> ] , <NEWLINE> <STRING> : [ <STRING> ] , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> @ property <NEWLINE> def form ( self ) : <NEWLINE> <INDENT> form = super ( ) . form <NEWLINE> helper = FormHelper ( ) <NEWLINE> helper . form_method = <STRING> <NEWLINE> helper . layout = Layout ( <NEWLINE> <INDENT> Field ( <STRING> ) , <NEWLINE> Field ( <STRING> ) , <NEWLINE> <DEDENT> ) <NEWLINE> helper . add_input ( Submit ( <STRING> , <STRING> ) ) <NEWLINE> form . helper = helper <NEWLINE> return form <NEWLINE> <DEDENT> <DEDENT>
def test ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . connect ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import tempfile <NEWLINE> import shutil <NEWLINE> base_directory = tempfile . mkdtemp ( ) <NEWLINE> image_urls = [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> ] <NEWLINE> <DEDENT> print ( compare_similarity ( image_urls , base_directory ) ) <NEWLINE> shutil . rmtree ( base_directory ) <NEWLINE> <DEDENT>
import re <NEWLINE> import ast <NEWLINE> import sys <NEWLINE> from setuptools import setup , find_packages <NEWLINE> from setuptools . command . test import test as TestCommand <NEWLINE> from codecs import open <NEWLINE> from os import path <NEWLINE>
from flask import Request <NEWLINE> from aleph . views . util import extract_next_url <NEWLINE> from aleph . tests . util import TestCase <NEWLINE>
def _show_details ( self , item_view ) : <NEWLINE> <INDENT> with api . new_store ( ) as store : <NEWLINE> <INDENT> model = store . fetch ( item_view ) <NEWLINE> run_dialog ( ReturnedSaleDialog , self , store , model ) <NEWLINE> store . retval = store . get_pending_count ( ) > 0 <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import os <NEWLINE> import re <NEWLINE> import fileinput <NEWLINE> from math import sqrt <NEWLINE> import scipy <NEWLINE> import numpy as np <NEWLINE> import scipy . stats as stats <NEWLINE> import pylab as pimport <NEWLINE> import matplotlib . pyplot as plt <NEWLINE>
def logfilter ( samplerate , signal , * args , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> feat = filter ( samplerate , signal , * args , ** kwargs ) <NEWLINE> return np . log ( feat ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import json <NEWLINE> for filepath in sys . argv [ 1 : ] : <NEWLINE> <INDENT> with open ( filepath ) as f : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> oyster = json . load ( f ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> sys . stderr . write ( <STRING> . format ( filepath ) ) <NEWLINE> raise <NEWLINE> <DEDENT> <DEDENT> with open ( filepath , <STRING> ) as f : <NEWLINE> <INDENT> json . dump ( oyster , f , ensure_ascii = False , indent = 4 , separators = ( <STRING> , <STRING> ) , sort_keys = True ) <NEWLINE> f . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def delete_tenant ( mgmt_root , name ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> p = mgmt_root . cm . cloud . tenants_s . tenant . load ( name = name ) <NEWLINE> <DEDENT> except HTTPError as err : <NEWLINE> <INDENT> if err . response . status_code != 404 : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> p . delete ( ) <NEWLINE> <DEDENT>
def clear_cart ( request ) : <NEWLINE> <INDENT> if request . method == <STRING> : <NEWLINE> <INDENT> if request . is_ajax ( ) : <NEWLINE> <INDENT> cart = Cart ( request . session ) <NEWLINE> cart . clear ( ) <NEWLINE> return JsonResponse ( { <NEWLINE> <INDENT> <STRING> : <STRING> <NEWLINE> <DEDENT> } ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import cgi <NEWLINE> import os <NEWLINE> import rrdtool <NEWLINE> import sys <NEWLINE>
from __future__ import unicode_literals <NEWLINE> from django . conf import settings <NEWLINE> from django . db import migrations , models <NEWLINE> import django . db . models . deletion <NEWLINE> import meals . models <NEWLINE>
def hanning ( cube , decimate = True ) : <NEWLINE> <INDENT> cube . allow_huge_operations = True <NEWLINE> smcube = cube [ 1 : - 1 , : , : ] * 0.5 <NEWLINE> smcube += cube [ 0 : - 2 , : , : ] * 0.25 <NEWLINE> smcube += cube [ 2 : , : , : ] * 0.25 <NEWLINE> if decimate : <NEWLINE> <INDENT> smcube = smcube [ 1 : : 2 , : , : ] <NEWLINE> <DEDENT> return smcube <NEWLINE> <DEDENT>
def RunGenerateLibrary ( ) : <NEWLINE> <INDENT> from googleapis . codegen import generate_library <NEWLINE> run_script_module . RunScriptModule ( generate_library ) <NEWLINE> <DEDENT>
class GType ( PackageElement , Type ) : <NEWLINE> <INDENT> def __init__ ( self , name , package = None , is_external = False ) : <NEWLINE> <INDENT> PackageElement . __init__ ( self , name , package , is_external ) <NEWLINE> Type . __init__ ( self ) <NEWLINE> <DEDENT> def get_name ( self ) : <NEWLINE> <INDENT> return self . name <NEWLINE> <DEDENT> <DEDENT>
import unittest <NEWLINE> import os <NEWLINE> import datetime <NEWLINE> import numpy as np <NEWLINE> from gpm_repo import gpm_wrapper <NEWLINE>
class UserProfile ( FacebookProfileModel ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> user = models . OneToOneField ( get_user_model ( ) ) <NEWLINE> <DEDENT>
from __future__ import print_function <NEWLINE> from __future__ import absolute_import <NEWLINE> from PyOpenWorm . muscle import Muscle <NEWLINE> from PyOpenWorm . neuron import Neuron <NEWLINE> from . DataTestTemplate import _DataTest <NEWLINE>
def getDescription ( self ) : <NEWLINE> <INDENT> if self . sourcetype == self . WMIFILES_MONITOR : <NEWLINE> <INDENT> return self . hostname <NEWLINE> <DEDENT> return BasicDataSource . BasicDataSource . getDescription ( self ) <NEWLINE> <DEDENT>
