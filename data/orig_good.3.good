<STRING> <NEWLINE> import logging <NEWLINE> import dialog <NEWLINE> from certbot . display import util as display_util <NEWLINE>
from logging import getLogger <NEWLINE> from os import access , R_OK <NEWLINE> from os . path import join , normpath <NEWLINE> from mimetypes import guess_type <NEWLINE> from paste . fileapp import FileApp <NEWLINE> from turbulenz_local . models . gamelist import GameList <NEWLINE> from turbulenz_local . tools import get_absolute_path <NEWLINE> LOG = getLogger ( __name__ ) <NEWLINE>
def parse_site_distribution ( site_distribution ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> numeric_site_distribution = { } <NEWLINE> numeric_site_mapping = { } <NEWLINE> for i , k in enumerate ( site_distribution . keys ( ) ) : <NEWLINE> <INDENT> numeric_site_distribution [ i ] = site_distribution [ k ] <NEWLINE> numeric_site_mapping [ i ] = k <NEWLINE> <DEDENT> return numeric_site_distribution , numeric_site_mapping <NEWLINE> <DEDENT>
def add_bookmark ( self , torrent_id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . call ( <STRING> % torrent_id ) <NEWLINE> <DEDENT>
class beta_zeros ( object ) : <NEWLINE> <INDENT> def initialize ( self , beta_count ) : <NEWLINE> <INDENT> betas = np . zeros ( beta_count ) <NEWLINE> return betas <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import os <NEWLINE> import time <NEWLINE> import re <NEWLINE> if j . core . platformtype . myplatform . isUnix ( ) : <NEWLINE> <INDENT> import fcntl <NEWLINE> <DEDENT> from JumpScale import j <NEWLINE>
<STRING> <NEWLINE> from __future__ import absolute_import <NEWLINE> from __future__ import unicode_literals <NEWLINE> from mako . template import Template <NEWLINE> from . templates import Templates <NEWLINE> from . util_functions import str_to_fancyc_comment <NEWLINE> from . util_functions import str_to_python_comment <NEWLINE> from . util_functions import strip_default_values <NEWLINE> from . util_functions import strip_arg_types <NEWLINE> from . util_functions import strip_arg_types_grc <NEWLINE> GRTYPELIST = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> <DEDENT> } <NEWLINE>
<STRING> <NEWLINE> import os <NEWLINE> from os . path import join <NEWLINE> try : <NEWLINE> <INDENT> from S3 import CallingFormat <NEWLINE> AWS_CALLING_FORMAT = CallingFormat . SUBDOMAIN <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> from configurations import Configuration , values <NEWLINE> BASE_DIR = os . path . dirname ( os . path . dirname ( __file__ ) ) <NEWLINE>
def print_verbose ( self , pkg , cfile ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> file_str = pp . path ( format_filetype ( cfile , pkg . parsed_contents ( ) [ cfile ] ) ) <NEWLINE> if self . name_only : <NEWLINE> <INDENT> name = pkg . cp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> name = str ( pkg . cpv ) <NEWLINE> <DEDENT> pp . uprint ( pp . cpv ( name ) , <STRING> + file_str + <STRING> ) <NEWLINE> <DEDENT>
def is_installed ( package ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> __import__ ( package ) <NEWLINE> return True <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT>
def pull_by_url ( cls , url ) : <NEWLINE> <INDENT> res = cls . query ( q = { <STRING> : { <STRING> : { <STRING> : url } } } ) <NEWLINE> if res . get ( <STRING> , { } ) . get ( <STRING> , 0 ) == 1 : <NEWLINE> <INDENT> return cls ( ** res [ <STRING> ] [ <STRING> ] [ 0 ] [ <STRING> ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT>
def amax ( a , axis = None , out = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> amax = a . max <NEWLINE> <DEDENT> except AttributeError : <NEWLINE> <INDENT> return _wrapit ( a , <STRING> , axis , out ) <NEWLINE> <DEDENT> return amax ( axis , out ) <NEWLINE> <DEDENT>
def new_language_value_change ( self , listbox , row ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if row is not None : <NEWLINE> <INDENT> self . new_language = { <NEWLINE> <INDENT> <STRING> : row . get_index ( ) , <STRING> : row . get_child ( ) . get_text ( ) <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> <DEDENT>
def fetch_csv ( self , date , label ) : <NEWLINE> <INDENT> datestr = date . strftime ( <STRING> ) <NEWLINE> url = <STRING> % ( self . base_url , label , datestr , label ) <NEWLINE> result = self . request ( url ) <NEWLINE> return result . text <NEWLINE> <DEDENT>
def __init__ ( self , cls , attr_dict ) : <NEWLINE> <INDENT> self . my_class = cls <NEWLINE> self . name = attr_dict [ <STRING> ] <NEWLINE> self . d_type = attr_dict [ <STRING> ] <NEWLINE> self . visibility = self . visibility_dict [ attr_dict [ <STRING> ] ] <NEWLINE> self . abstract_flag = attr_dict [ <STRING> ] <NEWLINE> self . static_flag = attr_dict [ <STRING> ] <NEWLINE> self . comment = attr_dict [ <STRING> ] <NEWLINE> self . value = None <NEWLINE> if attr_dict [ <STRING> ] != <STRING> : <NEWLINE> <INDENT> self . value = attr_dict [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT>
from supriya import osctools <NEWLINE> from supriya import servertools <NEWLINE> from supriya import synthdefs <NEWLINE> from supriya import systemtools <NEWLINE>
class Import ( models . Model ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> start = models . IntegerField ( ) <NEWLINE> end = models . IntegerField ( ) <NEWLINE> date = models . DateTimeField ( _ ( <STRING> ) , auto_now_add = True ) <NEWLINE> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> % ( _ ( <STRING> ) , self . start , self . end ) <NEWLINE> <DEDENT> def save ( self , * args , ** kwargs ) : <NEWLINE> <INDENT> self . full_clean ( ) <NEWLINE> super ( Import , self ) . save ( * args , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import os <NEWLINE> import sys <NEWLINE> import zipfile <NEWLINE> from qisys import ui <NEWLINE> import qisys . command <NEWLINE> import qisys . parsers <NEWLINE> import qipkg . parsers <NEWLINE> import qipkg . package <NEWLINE>
def test_get_sections_by_crn ( self ) : <NEWLINE> <INDENT> s1 , s2 , s3 , s4 = SectionPeriodFactory . create_batch ( 4 ) <NEWLINE> json = self . json_get ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> get = <STRING> % ( s1 . section . crn , s3 . section . crn ) , <NEWLINE> status_code = 200 ) <NEWLINE> <DEDENT> self . assertEqual ( json , { <NEWLINE> <INDENT> <STRING> : 4 , <NEWLINE> <STRING> : True , <NEWLINE> <STRING> : [ <NEWLINE> <INDENT> self . to_dict ( s1 ) , <NEWLINE> self . to_dict ( s3 ) , <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT> } ) <NEWLINE> <DEDENT>
from runners . baseRunner import BaseRunner <NEWLINE> import ha_engine . ha_infra as infra <NEWLINE> import time <NEWLINE> import subprocess <NEWLINE> LOG = infra . ha_logging ( __name__ ) <NEWLINE>
def show_branches_panel ( self , repo , on_selection , * args , ** kwargs ) : <NEWLINE> <INDENT> branches , choices = self . get_branch_choices ( repo , * args , ** kwargs ) <NEWLINE> def on_done ( idx ) : <NEWLINE> <INDENT> if idx != - 1 : <NEWLINE> <INDENT> branch = branches [ idx ] <NEWLINE> on_selection ( branch ) <NEWLINE> <DEDENT> <DEDENT> self . window . show_quick_panel ( choices , on_done , sublime . MONOSPACE_FONT ) <NEWLINE> <DEDENT>
def before_request ( ) : <NEWLINE> <INDENT> if <STRING> not in session : <NEWLINE> <INDENT> session [ <STRING> ] = datetime . datetime . now ( ) <NEWLINE> <DEDENT> session [ <STRING> ] = datetime . datetime . now ( ) <NEWLINE> <DEDENT>
def test_no_favorite_position ( self ) : <NEWLINE> <INDENT> result = self . bot . _get_pos_by_fav_location ( <STRING> ) <NEWLINE> self . assertEqual ( result , None ) <NEWLINE> <DEDENT>
def _get_ranking ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . _ranking <NEWLINE> <DEDENT>
def now ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return datetime . datetime . utcnow ( ) <NEWLINE> <DEDENT>
class UnitOfMeasure ( UnleashedResource ) : <NEWLINE> <INDENT> __endpoint__ = <STRING> <NEWLINE> Guid = fields . FieldGuid ( required = True ) <NEWLINE> Name = fields . FieldString ( length = 20 , required = True ) <NEWLINE> <DEDENT>
def __le__ ( self , other ) : <NEWLINE> <INDENT> for a , b in zip ( self , other ) : <NEWLINE> <INDENT> if a != b : <NEWLINE> <INDENT> return a < b <NEWLINE> <DEDENT> <DEDENT> return len ( self ) <= len ( other ) <NEWLINE> <DEDENT>
def init_methods ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> cls_member = lambda x : x . inner_class == self <NEWLINE> return self ( InitMethod , filter = cls_member , cut = True ) <NEWLINE> <DEDENT>
def test_video_start_time_and_end_time ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> data = { <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> self . metadata = self . metadata_for_mode ( <STRING> , additional_data = data ) <NEWLINE> self . navigate_to_video ( ) <NEWLINE> self . assertEqual ( self . video . position , <STRING> ) <NEWLINE> self . video . click_player_button ( <STRING> ) <NEWLINE> self . video . wait_for_state ( <STRING> ) <NEWLINE> self . assertIn ( self . video . position , ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT>
import threading <NEWLINE> from swiftclient import client as swift_client <NEWLINE> from swiftclient import ClientException <NEWLINE> from nose . plugins . attrib import attr <NEWLINE> from storlets . tools . utils import get_member_auth <NEWLINE> from tests . functional . java import StorletJavaFunctionalTest <NEWLINE> import unittest <NEWLINE>
class Persona ( models . Model ) : <NEWLINE> <INDENT> nickname = models . CharField ( max_length = 100 ) <NEWLINE> company = models . ForeignKey ( Company , related_name = <STRING> ) <NEWLINE> speaker = models . ForeignKey ( Speaker , related_name = <STRING> ) <NEWLINE> def __str__ ( self ) : <NEWLINE> <INDENT> return self . nickname + <STRING> + str ( self . speaker ) + <STRING> <NEWLINE> <DEDENT> <DEDENT>
def set_verifier ( self , verifier = None ) : <NEWLINE> <INDENT> if verifier is not None : <NEWLINE> <INDENT> self . verifier = verifier <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . verifier = generate_verifier ( ) <NEWLINE> <DEDENT> <DEDENT>
import os <NEWLINE> import ycm_core <NEWLINE> flags = [ <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> <NEWLINE> ] <NEWLINE> compilation_database_folder = <STRING> <NEWLINE> if compilation_database_folder : <NEWLINE> <INDENT> database = ycm_core . CompilationDatabase ( compilation_database_folder ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> database = None <NEWLINE> <DEDENT>
import markdown <NEWLINE> from django import forms <NEWLINE> from django . utils . html import escape <NEWLINE> from django . utils . safestring import mark_safe <NEWLINE> from django . utils . translation import ugettext_lazy as _ <NEWLINE> from shuup . xtheme . plugins . _base import Plugin <NEWLINE> from shuup . xtheme . plugins . forms import TranslatableField <NEWLINE>
def __vector_to_string ( self , vector ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return numpy . array_str ( vector ) <NEWLINE> <DEDENT>
def test_with_request_type_post ( self ) : <NEWLINE> <INDENT> self . setUpWithRequestTypeMethodScraper ( <STRING> ) <NEWLINE> self . rpt_mp . method = <STRING> <NEWLINE> self . rpt_mp . save ( ) <NEWLINE> self . run_event_spider ( 1 ) <NEWLINE> self . assertEqual ( len ( Event . objects . all ( ) ) , 4 ) <NEWLINE> <DEDENT>
class Cleaner ( Task ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def execute ( self ) : <NEWLINE> <INDENT> safe_rmtree ( self . get_options ( ) . pants_workdir ) <NEWLINE> <DEDENT> <DEDENT>
def P ( x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return math . exp ( - beta * x ** 2 / 2.0 ) <NEWLINE> <DEDENT>
def suite ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> test_suite = unittest . TestSuite ( ) <NEWLINE> test_suite . addTests ( <NEWLINE> <INDENT> unittest . TestLoader ( ) . loadTestsFromTestCase ( TestProduct ) <NEWLINE> <DEDENT> ) <NEWLINE> return test_suite <NEWLINE> <DEDENT>
class Number ( Literal ) : <NEWLINE> <INDENT> def set_fields ( self , number ) : <NEWLINE> <INDENT> self . value = decimal . Decimal ( number ) <NEWLINE> <DEDENT> <DEDENT>
class allPayController ( http . Controller ) : <NEWLINE> <INDENT> _return_url = <STRING> <NEWLINE> @ http . route ( <STRING> , type = <STRING> , auth = <STRING> , methods = [ <STRING> , <STRING> ] ) <NEWLINE> def allpay_return ( self , ** post ) : <NEWLINE> <INDENT> _logger . info ( <STRING> , pprint . pformat ( post ) ) <NEWLINE> if post . get ( <STRING> ) in [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> request . registry [ <STRING> ] . form_feedback ( request . cr , SUPERUSER_ID , post , <STRING> , <NEWLINE> <INDENT> context = request . context ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
class Chord : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . degree = None <NEWLINE> self . weights = [ 1.6 , .3 , 1.5 , .6 , 1.4 , .4 , .2 ] <NEWLINE> <DEDENT> <DEDENT>
def handlefiles ( self , dirname , filenames ) : <NEWLINE> <INDENT> for filename in filenames : <NEWLINE> <INDENT> pathname = os . path . join ( dirname , filename ) <NEWLINE> if os . path . isdir ( pathname ) : <NEWLINE> <INDENT> self . handledir ( pathname ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . handlefile ( pathname ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def post_init ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> pass <NEWLINE> <DEDENT>
class AdminReadonlyField ( LayoutNode ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> template_name = <STRING> <NEWLINE> def __init__ ( self , fieldset_field ) : <NEWLINE> <INDENT> self . fieldset_field = fieldset_field <NEWLINE> <DEDENT> def get_context_data ( self , context ) : <NEWLINE> <INDENT> return { <STRING> : self . fieldset_field } <NEWLINE> <DEDENT> <DEDENT>
def send ( self , data ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not self . is_connected ( ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return self . sock . sendall ( data ) <NEWLINE> <DEDENT>
def testPos ( self ) : <NEWLINE> <INDENT> fn = os . path . join ( CBCF_DATADIR , self . filename ) <NEWLINE> v = pysam . VariantFile ( fn ) <NEWLINE> pos = [ rec . pos for rec in v ] <NEWLINE> self . assertEqual ( pos , [ 1230237 , 14370 , 17330 , 1110696 , 1234567 ] ) <NEWLINE> <DEDENT>
def start ( self ) : <NEWLINE> <INDENT> if self . _current_state == self . FINAL : <NEWLINE> <INDENT> self . _navIntr . start ( ) <NEWLINE> self . _current_state = self . DEFAULT_MODE <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
def compute_amount_in ( hivemindd , txinfo ) : <NEWLINE> <INDENT> result = Decimal ( <STRING> ) <NEWLINE> for vin in txinfo [ <STRING> ] : <NEWLINE> <INDENT> in_info = hivemindd . getrawtransaction ( vin [ <STRING> ] , 1 ) <NEWLINE> vout = in_info [ <STRING> ] [ vin [ <STRING> ] ] <NEWLINE> result = result + vout [ <STRING> ] <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT>
class Home ( BaseHandler ) : <NEWLINE> <INDENT> def get ( self ) : <NEWLINE> <INDENT> params = { } <NEWLINE> return self . render_template ( <STRING> , ** params ) <NEWLINE> <DEDENT> def post ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> self . redirect_to ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import unittest <NEWLINE> import scipy as sp <NEWLINE> import framework . mynumpy as np <NEWLINE> import framework . linalg . matrixDecomp as md <NEWLINE> import framework . linalg . linearSolve as ls <NEWLINE> from framework . gfuncs import is_np_type <NEWLINE> FLOATING_PRECISION = 32 <NEWLINE>
def _get_connection ( self , connection ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not connection : <NEWLINE> <INDENT> connection = self . default_connection <NEWLINE> <DEDENT> if isinstance ( connection , str ) : <NEWLINE> <INDENT> connection = { <STRING> : connection } <NEWLINE> <DEDENT> if isinstance ( connection , dict ) : <NEWLINE> <INDENT> connection = Connection ( ** connection ) <NEWLINE> <DEDENT> return connection <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import csv <NEWLINE> csv_name = <STRING> <NEWLINE> state_ide = [ ] <NEWLINE> state_dur = [ ] <NEWLINE> file = open ( csv_name ) <NEWLINE> data = csv . DictReader ( file ) <NEWLINE> for row in data : <NEWLINE> <INDENT> state_ide . append ( int ( row [ <STRING> ] ) ) <NEWLINE> state_dur . append ( int ( row [ <STRING> ] ) ) <NEWLINE> <DEDENT> file . close ( ) <NEWLINE> print ( <STRING> , state_ide ) <NEWLINE> print ( <STRING> , state_dur ) <NEWLINE>
def multiRing ( coordinates ) : <NEWLINE> <INDENT> values = [ ] <NEWLINE> for lineString in coordinates : <NEWLINE> <INDENT> values . append ( <STRING> . format ( linearRing ( lineString ) ) ) <NEWLINE> <DEDENT> return <STRING> . join ( values ) <NEWLINE> <DEDENT>
def set_verbosity ( self , level ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . set_option ( pycurl . VERBOSE , level ) <NEWLINE> <DEDENT>
def clean_nombre ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> nombre = self . cleaned_data [ <STRING> ] <NEWLINE> if len ( nombre ) < 5 : <NEWLINE> <INDENT> raise forms . ValidationError ( <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif len ( nombre ) > 15 : <NEWLINE> <INDENT> raise forms . ValidationError ( <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return nombre <NEWLINE> <DEDENT>
from django . conf import settings <NEWLINE> from questionnaire import * <NEWLINE> from django . utils . translation import ugettext as _ <NEWLINE> import simple <NEWLINE> import choice <NEWLINE> import range <NEWLINE> import timeperiod <NEWLINE> import custom <NEWLINE>
def handleEvents ( self , event , fpsClock ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return False <NEWLINE> <DEDENT>
def get_fragment ( self , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> gen , namespaces , plan = self . get_fragment_generator ( ** kwargs ) <NEWLINE> graph = ConjunctiveGraph ( ) <NEWLINE> [ graph . bind ( prefix , u ) for ( prefix , u ) in namespaces ] <NEWLINE> [ graph . add ( ( s , p , o ) ) for ( _ , s , p , o ) in gen ] <NEWLINE> return graph <NEWLINE> <DEDENT>
class AstLeaf ( AstNode ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def bind ( self , inputs ) : <NEWLINE> <INDENT> self . op = self . op ( inputs ) <NEWLINE> operators . Operator . __init__ ( self , inputs , self . op . outputs ) <NEWLINE> <DEDENT> def process ( self , data ) : <NEWLINE> <INDENT> return self . op ( data ) <NEWLINE> <DEDENT> <DEDENT>
import factory <NEWLINE> from core . tests . factories import ExtendedFactory <NEWLINE> from organization . tests . factories import ProjectFactory <NEWLINE> from spatial . models import SpatialUnit , SpatialRelationship <NEWLINE>
def assertExpressionEqual ( self , left , right ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> stmt = sa . select ( [ left . label ( <STRING> ) ] , from_obj = self . table ) <NEWLINE> result = self . engine . execute ( stmt ) <NEWLINE> left_result = [ row [ <STRING> ] for row in result ] <NEWLINE> stmt = sa . select ( [ right . label ( <STRING> ) ] , from_obj = self . table ) <NEWLINE> result = self . engine . execute ( stmt ) <NEWLINE> right_result = [ row [ <STRING> ] for row in result ] <NEWLINE> self . assertCountEqual ( left_result , right_result ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from __future__ import division <NEWLINE> import numpy as np <NEWLINE> from scipy . constants import g <NEWLINE> from openquake . hazardlib . gsim . rietbrock_et_al_2013 import RietbrockEtAl2013MD <NEWLINE> from openquake . hazardlib . gsim . base import CoeffsTable <NEWLINE> from openquake . hazardlib . imt import PGA , SA <NEWLINE>
def get ( self , * args ) : <NEWLINE> <INDENT> url = formatUrl ( self . host , args ) <NEWLINE> logger . debug ( <STRING> , url ) <NEWLINE> response = requests . get ( url , verify = False , <NEWLINE> <INDENT> headers = self . headers , <NEWLINE> auth = ( self . user , self . passwd ) ) <NEWLINE> <DEDENT> checkResponse ( response ) <NEWLINE> return response <NEWLINE> <DEDENT>
class ExternalNode ( gpi . NodeAPI ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def initUI ( self ) : <NEWLINE> <INDENT> self . addWidget ( <STRING> , <STRING> , val = <STRING> ) <NEWLINE> self . addWidget ( <STRING> , <STRING> , val = <STRING> ) <NEWLINE> <DEDENT> def execType ( self ) : <NEWLINE> <INDENT> return gpi . GPI_THREAD <NEWLINE> <DEDENT> <DEDENT>
def check_proc_acl ( path ) : <NEWLINE> <INDENT> if str ( path ) == <STRING> : <NEWLINE> <INDENT> raise AclException ( <STRING> % path ) <NEWLINE> <DEDENT> <DEDENT>
import unittest <NEWLINE> from mobly import suite_runner <NEWLINE> from tests . lib import integration_test <NEWLINE> from tests . lib import integration2_test <NEWLINE>
class ParentAdmin ( MPTTModelAdmin , reversion . VersionAdmin ) : <NEWLINE> <INDENT> fieldsets = [ <NEWLINE> <INDENT> ( <STRING> , { <STRING> : [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] } ) , <NEWLINE> ] <NEWLINE> <DEDENT> list_display = ( <STRING> , <STRING> , <STRING> ) <NEWLINE> list_filter = [ <STRING> ] <NEWLINE> search_fields = [ <STRING> ] <NEWLINE> form = ParentForm <NEWLINE> ordering = [ <STRING> ] <NEWLINE> prepopulated_fields = { <STRING> : ( <STRING> , ) , } <NEWLINE> <DEDENT>
def getDirList ( p ) : <NEWLINE> <INDENT> p = str ( p ) <NEWLINE> if p == <STRING> : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> a = os . listdir ( p ) <NEWLINE> b = [ x for x in a if os . path . isdir ( p + x ) ] <NEWLINE> return b <NEWLINE> <DEDENT>
class DiaryProduct ( Product ) : <NEWLINE> <INDENT> isbn = models . CharField ( max_length = 255 ) <NEWLINE> number_of_pages = models . IntegerField ( ) <NEWLINE> <DEDENT>
def _get_sendfile ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> from importlib import import_module <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> from django . utils . importlib import import_module <NEWLINE> <DEDENT> from django . conf import settings <NEWLINE> from django . core . exceptions import ImproperlyConfigured <NEWLINE> backend = getattr ( settings , <STRING> , None ) <NEWLINE> if not backend : <NEWLINE> <INDENT> raise ImproperlyConfigured ( <STRING> ) <NEWLINE> <DEDENT> module = import_module ( backend ) <NEWLINE> return module . sendfile <NEWLINE> <DEDENT>
import MySQLdb <NEWLINE> import sys <NEWLINE> sys . path . append ( <STRING> ) <NEWLINE> import config <NEWLINE> db = MySQLdb . connect ( host = config . DB_HOST , <NEWLINE> <INDENT> port = config . DB_PORT , <NEWLINE> user = config . DB_USER , <NEWLINE> passwd = config . DB_PASSWD , <NEWLINE> db = config . DB_NAME , <NEWLINE> charset = <STRING> <NEWLINE> ) <NEWLINE> <DEDENT> db . autocommit ( True ) <NEWLINE>
def space_info ( array ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return array . get ( space = True ) <NEWLINE> <DEDENT>
from . . import excepttypes <NEWLINE> from . . constraints import ObjectConstraint , maybeThrow <NEWLINE> from . base import BaseOp <NEWLINE>
class O_Item ( scrapy . Item ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> url = scrapy . Field ( ) <NEWLINE> title = scrapy . Field ( ) <NEWLINE> links = scrapy . Field ( ) <NEWLINE> timestamp = scrapy . Field ( ) <NEWLINE> page_size = scrapy . Field ( ) <NEWLINE> full_html = scrapy . Field ( ) <NEWLINE> full_text = scrapy . Field ( ) <NEWLINE> secure = scrapy . Field ( ) <NEWLINE> cid = scrapy . Field ( ) <NEWLINE> domain = scrapy . Field ( ) <NEWLINE> tab = scrapy . Field ( ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import supybot <NEWLINE> import supybot . world as world <NEWLINE> __version__ = <STRING> <NEWLINE> __author__ = <STRING> <NEWLINE> __contributors__ = { } <NEWLINE> __url__ = <STRING> <NEWLINE> from . import config <NEWLINE> from . import plugin <NEWLINE> from imp import reload <NEWLINE> reload ( config ) <NEWLINE> reload ( plugin ) <NEWLINE> if world . testing : <NEWLINE> <INDENT> import test <NEWLINE> <DEDENT> Class = plugin . Class <NEWLINE> configure = config . configure <NEWLINE>
try : <NEWLINE> <INDENT> from gtts import gTTS <NEWLINE> import urllib <NEWLINE> import speech_recognition as sr <NEWLINE> from pydub import AudioSegment <NEWLINE> <DEDENT> except ImportError as e : <NEWLINE> <INDENT> print ( str ( e ) ) <NEWLINE> <DEDENT>
def build_arguments ( self , parser ) : <NEWLINE> <INDENT> parser . add_argument ( <STRING> , <STRING> , type = int , default = 18 , <NEWLINE> <INDENT> help = <STRING> ) <NEWLINE> <DEDENT> parser . add_argument ( <STRING> , type = argparse . FileType ( <STRING> ) , <NEWLINE> <INDENT> help = <STRING> ) <NEWLINE> <DEDENT> parser . add_argument ( <STRING> , type = argparse . FileType ( <STRING> ) , <NEWLINE> <INDENT> help = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def save ( self ) : <NEWLINE> <INDENT> if self . delay_save_count > 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if datetime . datetime . now ( ) - self . load_time > datetime . timedelta ( seconds = 5 ) : <NEWLINE> <INDENT> logger . warning ( <STRING> , self . name , str ( datetime . datetime . now ( ) - self . load_time ) ) <NEWLINE> <DEDENT> self . datasource . save_project ( self ) <NEWLINE> <DEDENT>
def decreet_get_chapters ( documentID , chaptertype = False ) : <NEWLINE> <INDENT> url = decreeturl + str ( documentID ) <NEWLINE> print ( url ) <NEWLINE> r = requests . get ( url ) <NEWLINE> print ( r ) <NEWLINE> data = json . loads ( r . content [ 1 : len ( r . content ) - 2 ] ) <NEWLINE> print ( data ) <NEWLINE> h = [ ] <NEWLINE> for value in data : <NEWLINE> <INDENT> chapter = Chapter ( value [ <STRING> ] , value [ <STRING> ] , value [ <STRING> ] , value [ <STRING> ] , chaptertype ) <NEWLINE> h . append ( chapter ) <NEWLINE> <DEDENT> return h <NEWLINE> <DEDENT>
def expand_model_fields ( model , field_names ) : <NEWLINE> <INDENT> model_class = type ( model ) <NEWLINE> try : <NEWLINE> <INDENT> trans_field_mapping = translator . get_options_for_model ( model_class ) . fields <NEWLINE> <DEDENT> except modeltranslation . translator . NotRegistered : <NEWLINE> <INDENT> return field_names <NEWLINE> <DEDENT> def expand_field ( field_name ) : <NEWLINE> <INDENT> translated_versions = trans_field_mapping . get ( field_name ) <NEWLINE> if translated_versions is not None : <NEWLINE> <INDENT> return ( f . name for f in translated_versions ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ field_name ] <NEWLINE> <DEDENT> <DEDENT> return [ expanded <NEWLINE> <INDENT> for unexpanded in field_names <NEWLINE> for expanded in expand_field ( unexpanded ) ] <NEWLINE> <DEDENT> <DEDENT>
from distutils . core import setup <NEWLINE> setup ( name = <STRING> , <NEWLINE> <INDENT> version = <STRING> , <NEWLINE> description = <STRING> , <NEWLINE> author = <STRING> , <NEWLINE> author_email = <STRING> , <NEWLINE> license = <STRING> , <NEWLINE> url = <STRING> , <NEWLINE> classifiers = [ <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <DEDENT> ] , <NEWLINE> platforms = [ <STRING> ] , <NEWLINE> keywords = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <NEWLINE> py_modules = [ <STRING> ] <NEWLINE> <DEDENT> ) <NEWLINE>
from __future__ import print_function <NEWLINE> from json import dumps <NEWLINE> from getpass import getuser <NEWLINE> from . base . base_drmaa import BaseDrmaaManager <NEWLINE> from . util . sudo import sudo_popen <NEWLINE> from . . managers import status <NEWLINE> from galaxy . tools . deps . commands import which <NEWLINE> from logging import getLogger <NEWLINE> log = getLogger ( __name__ ) <NEWLINE> DEFAULT_CHOWN_WORKING_DIRECTORY_SCRIPT = <STRING> <NEWLINE> DEFAULT_DRMAA_KILL_SCRIPT = <STRING> <NEWLINE> DEFAULT_DRMAA_LAUNCH_SCRIPT = <STRING> <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> parent = os . path . join ( os . path . dirname ( __file__ ) , <STRING> ) <NEWLINE> sys . path . insert ( 0 , parent ) <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> os . environ . setdefault ( <STRING> , <STRING> ) <NEWLINE> from django . core . management import execute_from_command_line <NEWLINE> execute_from_command_line ( sys . argv ) <NEWLINE> <DEDENT>
from django . conf . urls import url <NEWLINE> from orders . views import CheckoutFormView , ConfirmationView <NEWLINE> urlpatterns = [ <NEWLINE> <INDENT> url ( <STRING> , CheckoutFormView . as_view ( ) , name = <STRING> ) , <NEWLINE> url ( <STRING> , ConfirmationView . as_view ( ) , name = <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE>
def handle_testcase ( params ) : <NEWLINE> <INDENT> data = { } <NEWLINE> for param in params : <NEWLINE> <INDENT> parts = param . split ( <STRING> ) <NEWLINE> if len ( parts ) == 2 : <NEWLINE> <INDENT> key , value = parts <NEWLINE> key = key . lower ( ) <NEWLINE> data [ key ] = value <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise JobError ( <NEWLINE> <INDENT> <STRING> % param ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return data <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from sphinx . search import SearchLanguage , parse_stop_word <NEWLINE> import snowballstemmer <NEWLINE> french_stopwords = parse_stop_word ( <STRING> ) <NEWLINE> js_stemmer = <STRING> <NEWLINE>
<STRING> <NEWLINE> import unittest ; <NEWLINE> from pyclustering . cluster . tests . xmeans_templates import XmeansTestTemplates ; <NEWLINE> from pyclustering . cluster . xmeans import splitting_type ; <NEWLINE> from pyclustering . samples . definitions import SIMPLE_SAMPLES , FCPS_SAMPLES ; <NEWLINE>
class BaseService ( object ) : <NEWLINE> <INDENT> model = None <NEWLINE> model_proxy = None <NEWLINE> @ classmethod <NEWLINE> def all ( cls , klass , db_session = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> db_session = get_db_session ( db_session ) <NEWLINE> return db_session . query ( klass ) <NEWLINE> <DEDENT> @ classmethod <NEWLINE> def base_query ( cls , db_session = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> db_session = get_db_session ( db_session ) <NEWLINE> return db_session . query ( cls . model ) <NEWLINE> <DEDENT> <DEDENT>
def update_chassis ( self , chassis , values ) : <NEWLINE> <INDENT> session = get_session ( ) <NEWLINE> with session . begin ( ) : <NEWLINE> <INDENT> query = model_query ( models . Chassis , session = session ) <NEWLINE> query = add_identity_filter ( query , chassis ) <NEWLINE> count = query . update ( values ) <NEWLINE> if count != 1 : <NEWLINE> <INDENT> raise exception . ChassisNotFound ( chassis = chassis ) <NEWLINE> <DEDENT> ref = query . one ( ) <NEWLINE> <DEDENT> return ref <NEWLINE> <DEDENT>
__author__ = <STRING> <NEWLINE> import os <NEWLINE> import pymongo <NEWLINE> import datetime <NEWLINE> MONGODB_HOST = os . getenv ( <STRING> , <STRING> ) <NEWLINE> MONGODB_PORT = os . getenv ( <STRING> , 27017 ) <NEWLINE> mongodb_client = pymongo . MongoClient ( MONGODB_HOST , MONGODB_PORT ) <NEWLINE>
def label_logical_ties_in_expr_with_logical_tie_durations ( <NEWLINE> <INDENT> expr , markup_direction = Down ) : <NEWLINE> <STRING> <NEWLINE> from abjad . tools import labeltools <NEWLINE> return labeltools . label_leaves_in_expr_with_leaf_durations ( <NEWLINE> <INDENT> expr , <NEWLINE> label_durations = True , <NEWLINE> label_written_durations = True , <NEWLINE> markup_direction = markup_direction , <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT>
def execute ( commands ) : <NEWLINE> <INDENT> p = subprocess . Popen ( commands , shell = True , stdout = subprocess . PIPE ) <NEWLINE> out , err = p . communicate ( ) <NEWLINE> return out <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import flask_restplus as restplus <NEWLINE> from flask_restplus import fields <NEWLINE> from treadmill import webutils <NEWLINE> from treadmill . api import api_lookup <NEWLINE>
class lims_oligos_io ( lims_oligos_query , sbaas_template_io ) : <NEWLINE> <INDENT> def import_oligosStorage_add ( self , filename ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> data = base_importData ( ) ; <NEWLINE> data . read_csv ( filename ) ; <NEWLINE> data . format_data ( ) ; <NEWLINE> self . add_oligosStorage ( data . data ) ; <NEWLINE> data . clear_data ( ) ; <NEWLINE> <DEDENT> def import_oligosDescription_add ( self , filename ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> data = base_importData ( ) ; <NEWLINE> data . read_csv ( filename ) ; <NEWLINE> data . format_data ( ) ; <NEWLINE> self . add_oligosDescription ( data . data ) ; <NEWLINE> data . clear_data ( ) ; <NEWLINE> <DEDENT> <DEDENT>
def test_implicit_subscribed ( self ) : <NEWLINE> <INDENT> user = self . create_user ( ) <NEWLINE> group = self . create_group ( ) <NEWLINE> result = serialize ( group , user ) <NEWLINE> assert result [ <STRING> ] <NEWLINE> <DEDENT>
import os <NEWLINE> import pandas as pd <NEWLINE> fname = <STRING> <NEWLINE> path = os . getcwd ( ) <NEWLINE> files = os . listdir ( path ) <NEWLINE> files_xls = [ f for f in files if f [ : 3 ] == fname ] <NEWLINE> df = pd . DataFrame ( ) <NEWLINE> for f in files_xls : <NEWLINE> <INDENT> data = pd . read_excel ( f , <STRING> ) <NEWLINE> df = df . append ( data ) <NEWLINE> <DEDENT> df . sort_index ( inplace = True ) <NEWLINE> df = df . sort ( [ <STRING> ] ) <NEWLINE> df . to_excel ( <STRING> + fname + <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE>
def addnettunnels ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> logger . info ( <STRING> , self . network_nodes ) <NEWLINE> for n in self . network_nodes : <NEWLINE> <INDENT> self . addnettunnel ( n ) <NEWLINE> <DEDENT> <DEDENT>
def returnFromInitialAuthorization ( self ) : <NEWLINE> <INDENT> rtmom_net . getInternetConnector ( ) . connectAuthorizedClicked ( self . conn , self . tokenPath ) <NEWLINE> self . _myrtmom . updateFromNet ( netConnector ) <NEWLINE> self . _myrtmom . doSaveToFile ( self . _fileHandler ) <NEWLINE> self . rtmom_page . promote ( ) <NEWLINE> self . _finishOffInit ( ) <NEWLINE> <DEDENT>
def test_unpacking_images_returns_correct_img_type ( ) : <NEWLINE> <INDENT> test_cases = [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> ] <NEWLINE> for ole_obj_filename , img_ext in test_cases : <NEWLINE> <INDENT> ole = get_test_data_file_contents ( ole_obj_filename ) <NEWLINE> assert oleh . unpack ( ole ) . what == img_ext <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from PyDAQmx import Task <NEWLINE> import numpy as np <NEWLINE> value = 1.3 <NEWLINE> task = Task ( ) <NEWLINE> task . CreateAOVoltageChan ( <STRING> , <STRING> , - 10.0 , 10.0 , PyDAQmx . DAQmx_Val_Volts , None ) <NEWLINE> task . StartTask ( ) <NEWLINE> task . WriteAnalogScalarF64 ( 1 , 10.0 , value , None ) <NEWLINE> task . StopTask ( ) <NEWLINE>
def __init__ ( self ) : <NEWLINE> <INDENT> BaseCT2Device . __init__ ( self ) <NEWLINE> device_name = self . card_config [ <STRING> ] <NEWLINE> self . __tango_device = PyTango . gevent . DeviceProxy ( device_name ) <NEWLINE> self . __tango_device . subscribe_event ( <STRING> , <NEWLINE> <INDENT> PyTango . EventType . CHANGE_EVENT , <NEWLINE> self . __on_status ) <NEWLINE> <DEDENT> self . __tango_device . subscribe_event ( <STRING> , <NEWLINE> <INDENT> PyTango . EventType . CHANGE_EVENT , <NEWLINE> self . __on_point_nb ) <NEWLINE> <DEDENT> self . __tango_device . subscribe_event ( <STRING> , <NEWLINE> <INDENT> PyTango . EventType . CHANGE_EVENT , <NEWLINE> self . __on_error ) <NEWLINE> <DEDENT> <DEDENT>
from django . dispatch import Signal <NEWLINE> instance_created = Signal ( providing_args = [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE>
def api_delete_server_repositories ( hostname ) : <NEWLINE> <INDENT> db_session = DBSession ( ) <NEWLINE> delete_server_repository ( db_session , hostname ) <NEWLINE> return jsonify ( ** { RESPONSE_ENVELOPE : { KEY_HOSTNAME : hostname , RESPONSE_STATUS : APIStatus . SUCCESS } } ) <NEWLINE> <DEDENT>
def get_lang ( extension ) : <NEWLINE> <INDENT> if not extension : <NEWLINE> <INDENT> extension = <STRING> <NEWLINE> <DEDENT> return LEXER_MAP . get ( extension , <STRING> ) <NEWLINE> <DEDENT>
list = [ 1 , 2 , 3 , 4 , 5 ] <NEWLINE> productItems = 1 <NEWLINE> for item in list : <NEWLINE> <INDENT> productItems *= item <NEWLINE> <DEDENT> print ( <STRING> , productItems ) <NEWLINE>
class UserSerializer ( serializers . HyperlinkedModelSerializer ) : <NEWLINE> <INDENT> measurements = serializers . HyperlinkedRelatedField ( <NEWLINE> <INDENT> queryset = Measurement . objects . all ( ) , <NEWLINE> view_name = <STRING> , <NEWLINE> many = True ) <NEWLINE> <DEDENT> class Meta : <NEWLINE> <INDENT> model = User <NEWLINE> fields = ( <STRING> , <STRING> , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from __future__ import print_function , division , absolute_import <NEWLINE> from future import standard_library <NEWLINE> standard_library . install_aliases ( ) <NEWLINE> from builtins import range <NEWLINE> import numpy as np <NEWLINE> from odl . discr import ( <NEWLINE> <INDENT> uniform_grid , DiscreteLp , uniform_partition_fromgrid , <NEWLINE> uniform_discr_frompartition ) <NEWLINE> <DEDENT> from odl . set import RealNumbers <NEWLINE> from odl . util import ( <NEWLINE> <INDENT> fast_1d_tensor_mult , <NEWLINE> is_real_dtype , is_scalar_dtype , is_real_floating_dtype , <NEWLINE> is_complex_floating_dtype , complex_dtype , dtype_repr , <NEWLINE> conj_exponent , <NEWLINE> normalized_scalar_param_list , normalized_axes_tuple ) <NEWLINE> <DEDENT> __all__ = ( <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <STRING> ) <NEWLINE> <DEDENT>
import fabric <NEWLINE> fabricClient = fabric . createClient ( ) <NEWLINE> op = fabricClient . DependencyGraph . createOperator ( <STRING> ) <NEWLINE> op . setEntryPoint ( <STRING> ) <NEWLINE> op . setSourceCode ( <STRING> ) <NEWLINE> binding = fabricClient . DependencyGraph . createBinding ( ) <NEWLINE> binding . setOperator ( op ) <NEWLINE> binding . setParameterLayout ( [ <STRING> ] ) <NEWLINE> node = fabricClient . DependencyGraph . createNode ( <STRING> ) <NEWLINE> node . addMember ( <STRING> , <STRING> ) <NEWLINE> node . bindings . append ( binding ) <NEWLINE> node . setData ( <STRING> , [ 17 ] ) <NEWLINE> print ( node . getErrors ( ) ) <NEWLINE> fabricClient . close ( ) <NEWLINE>
def test_previous_after_working_day_end ( self ) : <NEWLINE> <INDENT> dt = self . utc . localize ( datetime . datetime ( 2016 , 1 , 25 , 18 , 00 , 0 ) ) <NEWLINE> self . assertEqual ( <NEWLINE> <INDENT> self . workdayrule . previous ( dt ) , <NEWLINE> ( <NEWLINE> <INDENT> self . utc . localize ( datetime . datetime ( 2016 , 1 , 25 , 9 , 0 , 0 ) ) , <NEWLINE> self . utc . localize ( datetime . datetime ( 2016 , 1 , 25 , 17 , 0 , 0 ) ) , <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
import requests <NEWLINE> from database import db <NEWLINE> from database import db_models <NEWLINE> R = db_models . Rep <NEWLINE>
def do_setup ( ) : <NEWLINE> <INDENT> kwargs = package_data . copy ( ) <NEWLINE> kwargs [ <STRING> ] = classifiers <NEWLINE> kwargs [ <STRING> ] = { <STRING> : build_data , <NEWLINE> <INDENT> <STRING> : smart_install_data } <NEWLINE> <DEDENT> if sys . version_info >= ( 3 , ) : <NEWLINE> <INDENT> kwargs [ <STRING> ] [ <STRING> ] = copy_build_py_2to3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kwargs [ <STRING> ] [ <STRING> ] = build_py <NEWLINE> <DEDENT> dist = setup ( ** kwargs ) <NEWLINE> return dist <NEWLINE> <DEDENT>
def median_absolute_deviation ( x , M = None ) : <NEWLINE> <INDENT> if M is None : <NEWLINE> <INDENT> M = np . median ( x ) <NEWLINE> <DEDENT> return np . median ( abs ( x - M ) ) <NEWLINE> <DEDENT>
SourceDirPath = <STRING> <NEWLINE> BackupDirPath = <STRING> <NEWLINE> import Tkinter , tkFileDialog , tkMessageBox <NEWLINE> import subprocess <NEWLINE> import os <NEWLINE>
from couchpotato . core . helpers . encoding import tryUrlencode <NEWLINE> from couchpotato . core . logger import CPLog <NEWLINE> from couchpotato . core . event import fireEvent <NEWLINE> from couchpotato . core . media . _base . providers . torrent . bithdtv import Base <NEWLINE> from couchpotato . core . media . movie . providers . base import MovieProvider <NEWLINE> log = CPLog ( __name__ ) <NEWLINE> autoload = <STRING> <NEWLINE>
class Migration ( migrations . Migration ) : <NEWLINE> <INDENT> dependencies = [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE> operations = [ <NEWLINE> <INDENT> migrations . AddField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> field = models . BooleanField ( default = False , editable = False , verbose_name = <STRING> ) , <NEWLINE> <DEDENT> ) , <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT>
def redirect_if_authorized ( func ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> @ wraps ( func ) <NEWLINE> def _decorator ( request , * args , ** kwargs ) : <NEWLINE> <INDENT> if request . user . is_authenticated ( ) : <NEWLINE> <INDENT> return redirect ( settings . LOGIN_REDIRECT_URL ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return func ( request , * args , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT> return _decorator <NEWLINE> <DEDENT>
class Solution ( object ) : <NEWLINE> <INDENT> def majorityElement ( self , nums ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> hash = { } <NEWLINE> output = nums [ 0 ] <NEWLINE> for i in range ( len ( nums ) ) : <NEWLINE> <INDENT> val = nums [ i ] <NEWLINE> if val in hash : <NEWLINE> <INDENT> hash [ val ] += 1 <NEWLINE> if hash [ val ] > len ( nums ) / 2 : <NEWLINE> <INDENT> output = val <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> hash [ val ] = 1 <NEWLINE> <DEDENT> <DEDENT> return output <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import cPickle <NEWLINE> import os <NEWLINE> import time <NEWLINE> import math <NEWLINE> import numpy as np <NEWLINE> import shapefile <NEWLINE> from laspy . file import File <NEWLINE> import voronoi <NEWLINE> source = <STRING> <NEWLINE> target = <STRING> <NEWLINE> archive = <STRING> <NEWLINE> pyshp = <STRING> <NEWLINE>
<STRING> <NEWLINE> from cdbifunc import * <NEWLINE> from cdbfunctions import * <NEWLINE> from datetime import date <NEWLINE>
<STRING> <NEWLINE> from __future__ import print_function <NEWLINE> from __future__ import division <NEWLINE> from __future__ import absolute_import <NEWLINE> import win32security <NEWLINE> from chevah . compat . testing import ( <NEWLINE> <INDENT> mk , <NEWLINE> TEST_ACCOUNT_GROUP , <NEWLINE> TEST_DOMAIN , <NEWLINE> TEST_PDC , <NEWLINE> TestUser , <NEWLINE> ) <NEWLINE> <DEDENT> from chevah . compat . testing . testcase import OSAccountFileSystemTestCase <NEWLINE> from chevah . compat . tests . mixin . filesystem import SymbolicLinksMixin <NEWLINE>
from anymarkup_core import AnyMarkupError , parse , parse_file , serialize , serialize_file <NEWLINE> __version__ = <STRING> <NEWLINE>
def test_anonymous ( self ) : <NEWLINE> <INDENT> m = mmap . mmap ( - 1 , PAGESIZE ) <NEWLINE> for x in xrange ( PAGESIZE ) : <NEWLINE> <INDENT> self . assertEqual ( m [ x ] , <STRING> , <STRING> ) <NEWLINE> <DEDENT> for x in xrange ( PAGESIZE ) : <NEWLINE> <INDENT> m [ x ] = ch = chr ( x & 255 ) <NEWLINE> self . assertEqual ( m [ x ] , ch ) <NEWLINE> <DEDENT> <DEDENT>
from core import httptools <NEWLINE> from core import logger <NEWLINE> from core import scrapertools <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> set_title ( evdh_title ) <NEWLINE> print_free ( ) <NEWLINE> start_evdh ( ) <NEWLINE> wait_pause ( ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from __future__ import absolute_import <NEWLINE> from __future__ import division <NEWLINE> from __future__ import print_function <NEWLINE> import sys <NEWLINE>
class APIClient ( Client ) : <NEWLINE> <INDENT> def patch ( self , path , data = <STRING> , content_type = MULTIPART_CONTENT , <NEWLINE> <INDENT> follow = False , ** extra ) : <NEWLINE> return self . generic ( <STRING> , path , data , content_type , ** extra ) <NEWLINE> <DEDENT> def options ( self , path , data = <STRING> , content_type = MULTIPART_CONTENT , <NEWLINE> <INDENT> follow = False , ** extra ) : <NEWLINE> return self . generic ( <STRING> , path , data , content_type , ** extra ) <NEWLINE> <DEDENT> <DEDENT>
def fail_test ( sock , handle , thing ) : <NEWLINE> <INDENT> print ( <STRING> + str ( thing ) + <STRING> ) <NEWLINE> sock . close ( ) <NEWLINE> stopcomm ( handle ) <NEWLINE> mycontext [ <STRING> ] = False <NEWLINE> exitall ( ) <NEWLINE> <DEDENT>
def handle_endtag ( self , tag ) : <NEWLINE> <INDENT> if tag == <STRING> or tag == <STRING> : <NEWLINE> <INDENT> self . starting = False <NEWLINE> <DEDENT> <DEDENT>
import tensorflow as tf <NEWLINE> v1 = tf . Variable ( tf . constant ( 1.0 , shape = [ 1 ] ) , name = <STRING> ) <NEWLINE> v2 = tf . Variable ( tf . constant ( 2.0 , shape = [ 1 ] ) , name = <STRING> ) <NEWLINE> result = v1 + v2 <NEWLINE> init_op = tf . global_variables_initializer ( ) <NEWLINE> saver = tf . train . Saver ( ) <NEWLINE> with tf . Session ( ) as sess : <NEWLINE> <INDENT> sess . run ( init_op ) <NEWLINE> saver . save ( sess , <STRING> ) <NEWLINE> <DEDENT>
def get_pydoc_text ( module ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> doc = pydoc . TextDoc ( ) <NEWLINE> loc = doc . getdocloc ( pydoc_mod ) or <STRING> <NEWLINE> if loc : <NEWLINE> <INDENT> loc = <STRING> + loc + <STRING> <NEWLINE> <DEDENT> output = doc . docmodule ( module ) <NEWLINE> patt = re . compile ( <STRING> ) <NEWLINE> output = patt . sub ( <STRING> , output ) <NEWLINE> return output . strip ( ) , loc <NEWLINE> <DEDENT>
def createHTML ( self , outputFile , algData ) : <NEWLINE> <INDENT> with codecs . open ( outputFile , <STRING> , encoding = <STRING> ) as f : <NEWLINE> <INDENT> f . write ( <STRING> ) <NEWLINE> f . write ( <STRING> ) <NEWLINE> f . write ( self . tr ( <STRING> ) + str ( len ( algData ) ) + <STRING> ) <NEWLINE> f . write ( self . tr ( <STRING> ) ) <NEWLINE> f . write ( <STRING> ) <NEWLINE> for s in algData : <NEWLINE> <INDENT> f . write ( <STRING> + str ( s ) + <STRING> ) <NEWLINE> <DEDENT> f . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def get_data_from_quickbooks_where ( self , where ) : <NEWLINE> <INDENT> query = <STRING> + self . build_quickbooks_select_fields ( ) + <STRING> + self . qodbc_table + <STRING> + where <NEWLINE> return self . qodbc . query ( query ) <NEWLINE> <DEDENT>
class HookSerializer ( serializers . ModelSerializer ) : <NEWLINE> <INDENT> class Meta : <NEWLINE> <INDENT> model = Hook <NEWLINE> read_only_fields = ( <STRING> , ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from __future__ import print_function <NEWLINE> import logging <NEWLINE> import sys <NEWLINE> import os <NEWLINE> import cPickle <NEWLINE> import numpy as np <NEWLINE> from scipy . sparse import dok_matrix <NEWLINE> from scipy . io import mmwrite , mmread <NEWLINE> import text_entail . dictionary as td <NEWLINE> import text_entail . io as tio <NEWLINE>
import gi <NEWLINE> gi . require_version ( <STRING> , <STRING> ) <NEWLINE> from gi . repository import Gtk <NEWLINE> from gi . repository import Gdk <NEWLINE> from gi . repository import GObject <NEWLINE> import logging <NEWLINE> from gettext import gettext as _ <NEWLINE> from Editing_View import Editing_View <NEWLINE> from Gallery_View import Gallery_View <NEWLINE> from infoslicer . processing . Article import Article <NEWLINE> logger = logging . getLogger ( <STRING> ) <NEWLINE>
import urllib <NEWLINE> username = <STRING> <NEWLINE> password = <STRING> <NEWLINE> session = <STRING> <NEWLINE>
def _get_persistent_cmd ( self , attr_name , cmd_name , * args , ** kwargs ) : <NEWLINE> <INDENT> cur_val = getattr ( self , attr_name ) <NEWLINE> if cur_val is not None : <NEWLINE> <INDENT> return cur_val <NEWLINE> <DEDENT> options = { <STRING> : PIPE , <STRING> : True } <NEWLINE> options . update ( kwargs ) <NEWLINE> cmd = self . _call_process ( cmd_name , * args , ** options ) <NEWLINE> setattr ( self , attr_name , cmd ) <NEWLINE> return cmd <NEWLINE> <DEDENT>
def get_os_full_version ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . _os_full_ver <NEWLINE> <DEDENT>
from . import ux <NEWLINE> from . import autoimport <NEWLINE> from . loggers import Loggers <NEWLINE>
from __future__ import unicode_literals , division , absolute_import <NEWLINE> import logging <NEWLINE> import re <NEWLINE> from flexget import plugin <NEWLINE> from flexget . event import event <NEWLINE> from flexget . utils . cached_input import cached <NEWLINE> from flexget . entry import Entry <NEWLINE> from flexget . utils . soup import get_soup <NEWLINE> log = logging . getLogger ( <STRING> ) <NEWLINE> USER_ID_RE = <STRING> <NEWLINE>
def __getstate__ ( self ) : <NEWLINE> <INDENT> newdict = super ( WorkflowWorker , self ) . __getstate__ ( ) <NEWLINE> del newdict [ <STRING> ] <NEWLINE> return newdict <NEWLINE> <DEDENT>
def setUp ( self ) : <NEWLINE> <INDENT> super ( AutoscalingLoadBalancerv2Test , self ) . setUp ( ) <NEWLINE> self . template_name = <STRING> <NEWLINE> self . app_server_template_name = <STRING> <NEWLINE> self . webapp_template_name = <STRING> <NEWLINE> if not self . is_network_extension_supported ( <STRING> ) : <NEWLINE> <INDENT> self . skipTest ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
__doc__ = <STRING> <NEWLINE> __version__ = <STRING> [ 11 : - 2 ] <NEWLINE> from Globals import InitializeClass <NEWLINE> from Products . ZenModel . ZenossSecurity import * <NEWLINE> from ZenPacks . community . RDBMS . DBSrvInst import DBSrvInst <NEWLINE>
c = get_config ( ) <NEWLINE> c . NotebookApp . ip = <STRING> <NEWLINE> c . NotebookApp . open_browser = False <NEWLINE> c . NotebookApp . port = 8880 <NEWLINE> import os <NEWLINE> import sys <NEWLINE> spark_home = os . environ . get ( <STRING> , None ) <NEWLINE> if not spark_home : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> os . environ [ <STRING> ] = <STRING> <NEWLINE> os . environ [ <STRING> ] = <STRING> <NEWLINE> sys . path . insert ( 0 , os . path . join ( spark_home , <STRING> ) ) <NEWLINE> sys . path . insert ( 0 , os . path . join ( spark_home , <STRING> ) ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> from utils import logging <NEWLINE>
from django . conf . urls import patterns , url <NEWLINE> from views import * <NEWLINE> urlpatterns = patterns ( <STRING> , <NEWLINE> <INDENT> url ( <STRING> , playlists , name = <STRING> ) , <NEWLINE> url ( <STRING> , videos , name = <STRING> ) , <NEWLINE> <DEDENT> ) <NEWLINE>
<STRING> <NEWLINE> __author__ = <STRING> <NEWLINE> __copyright__ = <STRING> <NEWLINE> __license__ = <STRING> <NEWLINE> import Agent as AG <NEWLINE> import SuperMarioBros as SMB <NEWLINE> import Utility as UT <NEWLINE> config = SMB . simulation_config <NEWLINE> config . update ( SMB . render_config ) <NEWLINE> layout = SMB . layout_fromdefault ( ) <NEWLINE> render = UT . TKRender ( layout , config = config ) <NEWLINE> simulation = SMB . MarioSimulation ( layout , config = config ) <NEWLINE> keypoller = SMB . KeyPoller ( ) <NEWLINE> AG . keyboard_agent ( simulation , keypoller , render , config = config ) <NEWLINE>
def custom_signup ( self , request , user ) : <NEWLINE> <INDENT> custom_form = super ( BaseSignupForm , self ) <NEWLINE> if hasattr ( custom_form , <STRING> ) and callable ( custom_form . signup ) : <NEWLINE> <INDENT> custom_form . signup ( request , user ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> warnings . warn ( <STRING> <NEWLINE> <INDENT> <STRING> , <NEWLINE> DeprecationWarning ) <NEWLINE> <DEDENT> custom_form . save ( user ) <NEWLINE> <DEDENT> <DEDENT>
def testGEQOver ( self ) : <NEWLINE> <INDENT> var1 , var2 , var3 = ( Variable ( list ( range ( 0 , 3 ) ) ) for x in range ( 0 , 3 ) ) <NEWLINE> model = NativeModel ( ) <NEWLINE> model . add_constraint ( var1 >= var2 ) <NEWLINE> model . add_constraint ( var2 >= var3 ) <NEWLINE> model . add_constraint ( var1 >= var3 ) <NEWLINE> solver = Solver ( model ) <NEWLINE> assert ( solver . solve ( ) ) <NEWLINE> <DEDENT>
def source_writer ( self , buffered = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not buffered : <NEWLINE> <INDENT> return self . source ( ) . writer ( ) <NEWLINE> <DEDENT> if self . _source_writer is None : <NEWLINE> <INDENT> self . _source_writer = BufferedWriter ( self . source ( ) ) <NEWLINE> <DEDENT> return self . _source_writer <NEWLINE> <DEDENT>
from __future__ import print_function <NEWLINE> from pybel . constants import HAS_PRODUCT , HAS_REACTANT , HAS_VARIANT , HAS_COMPONENT , TRANSCRIBED_TO , TRANSLATED_TO <NEWLINE> IS_PRODUCT_OF = <STRING> <NEWLINE> IS_REACTANT_OF = <STRING> <NEWLINE> IS_VARIANT_OF = <STRING> <NEWLINE> IS_COMPONENT_OF = <STRING> <NEWLINE> TRANSCRIBED_FROM = <STRING> <NEWLINE> TRANSLATED_FROM = <STRING> <NEWLINE> INFERRED_INVERSE = { <NEWLINE> <INDENT> HAS_PRODUCT : IS_PRODUCT_OF , <NEWLINE> HAS_REACTANT : IS_REACTANT_OF , <NEWLINE> HAS_VARIANT : IS_VARIANT_OF , <NEWLINE> HAS_COMPONENT : IS_COMPONENT_OF , <NEWLINE> TRANSCRIBED_TO : TRANSCRIBED_FROM , <NEWLINE> TRANSLATED_TO : TRANSLATED_FROM <NEWLINE> <DEDENT> } <NEWLINE> abstract_url_fmt = <STRING> <NEWLINE> title_url_fmt = <STRING> <NEWLINE> so_url_fmt = <STRING> <NEWLINE> citation_format = <STRING> <NEWLINE> evidence_format = <STRING> <NEWLINE>
def get_hash ( __arcfile , __hashtype ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> __res = getattr ( hashlib , __hashtype ) ( __arcfile . read ( ) ) . hexdigest ( ) <NEWLINE> __arcfile . close ( ) <NEWLINE> return __res <NEWLINE> <DEDENT>
from sqlalchemy import create_engine , Column , BigInteger , Boolean <NEWLINE> from sqlalchemy . ext . declarative import declarative_base <NEWLINE> from sqlalchemy . orm import sessionmaker <NEWLINE> Base = declarative_base ( ) <NEWLINE>
def setUp ( self ) : <NEWLINE> <INDENT> super ( PostgreSQLTestBase , self ) . setUp ( ) <NEWLINE> if not self . __class__ . _is_postgres : <NEWLINE> <INDENT> raise unittest . SkipTest ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from spyre import server <NEWLINE> import pandas as pd <NEWLINE> import numpy as np <NEWLINE> from bokeh import resources as r <NEWLINE> from bokeh . resources import CDN <NEWLINE> from bokeh . embed import components <NEWLINE> from bokeh . plotting import line <NEWLINE> from bokeh . sampledata import us_counties , unemployment <NEWLINE> from bokeh . plotting import * <NEWLINE> from bokeh . objects import HoverTool <NEWLINE> from collections import OrderedDict <NEWLINE>
import paramiko <NEWLINE> from getpass import getpass <NEWLINE> ip_addr = raw_input ( <STRING> ) <NEWLINE> username = raw_input ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> password = getpass ( ) <NEWLINE> remote_conn_pre = paramiko . SSHClient ( ) <NEWLINE> remote_conn_pre . load_host_keys ( <STRING> ) <NEWLINE> remote_conn_pre . connect ( ip_addr , username = username , password = password , <NEWLINE> <INDENT> look_for_keys = False , allow_agent = False ) <NEWLINE> <DEDENT> remote_conn = remote_conn_pre . invoke_shell ( ) <NEWLINE> remote_conn . settimeout ( 4.0 ) <NEWLINE>
from . import ( <NEWLINE> <INDENT> csv , <NEWLINE> fwt , <NEWLINE> json , <NEWLINE> onelinejson , <NEWLINE> xml , <NEWLINE> yaml , <NEWLINE> sqlalchemy , <NEWLINE> excel <NEWLINE> <DEDENT> ) <NEWLINE>
def __init__ ( self , expression , start_pos , end_pos , text ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . __expr = expression <NEWLINE> self . __s_pos = start_pos <NEWLINE> self . __e_pos = end_pos <NEWLINE> self . __txt = text <NEWLINE> <DEDENT>
def log ( logt , * text ) : <NEWLINE> <INDENT> print ( <STRING> % ( logt , <STRING> . join ( text ) ) ) <NEWLINE> Log ( logt ) . append ( * text ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import django <NEWLINE> if django . get_version ( ) < <STRING> : <NEWLINE> <INDENT> from django . conf . urls . defaults import patterns , url <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from django . conf . urls import patterns , url <NEWLINE> <DEDENT> from ssosp . views import sso_acs , sso_login , sso_logout <NEWLINE> urlpatterns = patterns ( <STRING> , <NEWLINE> <INDENT> url ( <STRING> , sso_acs , name = <STRING> ) , <NEWLINE> url ( <STRING> , sso_login , name = <STRING> ) , <NEWLINE> url ( <STRING> , sso_logout , name = <STRING> ) , <NEWLINE> <DEDENT> ) <NEWLINE>
def fale_conosco ( request ) : <NEWLINE> <INDENT> email_enviado = False <NEWLINE> if request . method == <STRING> : <NEWLINE> <INDENT> form = FaleConoscoForm ( request . POST ) <NEWLINE> if form . is_valid ( ) : <NEWLINE> <INDENT> human = True <NEWLINE> form . enviar ( ) <NEWLINE> email_enviado = True <NEWLINE> form = FaleConoscoForm ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> form = FaleConoscoForm ( ) <NEWLINE> <DEDENT> return render_to_response ( <STRING> , locals ( ) , context_instance = RequestContext ( request ) ) <NEWLINE> <DEDENT>
def _exit_code ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> main ( Arguments ) <NEWLINE> <DEDENT> except SystemExit as e : <NEWLINE> <INDENT> return e . code <NEWLINE> <DEDENT> <DEDENT>
def __setitem__ ( self , key , value ) : <NEWLINE> <INDENT> assert ( key not in self . thedict ) <NEWLINE> self . thedict [ key ] = value <NEWLINE> <DEDENT>
class ClientTest ( utils . TestCase ) : <NEWLINE> <INDENT> def test_get_client_class_v1 ( self ) : <NEWLINE> <INDENT> output = cinderclient . client . get_client_class ( <STRING> ) <NEWLINE> self . assertEqual ( output , cinderclient . v1 . client . Client ) <NEWLINE> <DEDENT> def test_get_client_class_v2 ( self ) : <NEWLINE> <INDENT> output = cinderclient . client . get_client_class ( <STRING> ) <NEWLINE> self . assertEqual ( output , cinderclient . v2 . client . Client ) <NEWLINE> <DEDENT> def test_get_client_class_unknown ( self ) : <NEWLINE> <INDENT> self . assertRaises ( cinderclient . exceptions . UnsupportedVersion , <NEWLINE> <INDENT> cinderclient . client . get_client_class , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def __error ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> content = <STRING> <NEWLINE> self . send_response ( 500 ) <NEWLINE> self . send_header ( <STRING> , len ( content ) ) <NEWLINE> self . send_header ( <STRING> , <STRING> ) <NEWLINE> self . end_headers ( ) <NEWLINE> self . wfile . write ( content ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
from time import sleep <NEWLINE> from gi . repository import GLib <NEWLINE> from ulauncher . util . decorator . run_async import run_async <NEWLINE> from . BaseAction import BaseAction <NEWLINE>
def toHex ( buffer ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> result = <STRING> <NEWLINE> cpt1 = 0 <NEWLINE> cpt2 = 0 <NEWLINE> for byte in buffer : <NEWLINE> <INDENT> result += hex ( ord ( byte ) ) [ 2 : ] . zfill ( 2 ) <NEWLINE> cpt1 += 1 <NEWLINE> if cpt1 >= 4 : <NEWLINE> <INDENT> result += <STRING> <NEWLINE> cpt1 = 0 <NEWLINE> cpt2 += 1 <NEWLINE> <DEDENT> if cpt2 >= 10 : <NEWLINE> <INDENT> result += <STRING> <NEWLINE> cpt2 = 0 <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from corporachar import settings <NEWLINE> from corporachar . utils . db_manager import DBConnect <NEWLINE> import json <NEWLINE> import requests <NEWLINE> from os import walk , path <NEWLINE> import textract <NEWLINE> from joblib import Parallel , delayed <NEWLINE> import click <NEWLINE> from unidecode import unidecode <NEWLINE> import itertools <NEWLINE>
from . import account_tax <NEWLINE> from . import account_payment <NEWLINE> from . import account_tax_withholding_rule <NEWLINE> from . import account_payment_group <NEWLINE> from . import res_company <NEWLINE>
def on_accept ( self , sock , mask ) : <NEWLINE> <INDENT> conn , addr = self . main_socket . accept ( ) <NEWLINE> logging . info ( <STRING> . format ( addr ) ) <NEWLINE> conn . setblocking ( False ) <NEWLINE> self . current_peers [ conn . fileno ( ) ] = conn . getpeername ( ) <NEWLINE> self . selector . register ( fileobj = conn , events = selectors . EVENT_READ , <NEWLINE> <INDENT> data = self . on_read ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from django . test . utils import override_settings <NEWLINE> import mock <NEWLINE> from webplatformcompat . models import Maturity , Specification <NEWLINE> from webplatformcompat . tasks import update_cache_for_instance <NEWLINE> from . base import TestCase <NEWLINE>
def write_pretty_json ( path , data ) : <NEWLINE> <INDENT> with open ( path , <STRING> ) as fd : <NEWLINE> <INDENT> fd . write ( json . dumps ( data , <NEWLINE> <INDENT> sort_keys = True , <NEWLINE> separators = ( <STRING> , <STRING> ) , <NEWLINE> indent = 2 ) ) <NEWLINE> <DEDENT> fd . flush ( ) <NEWLINE> os . fsync ( fd ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import logging <NEWLINE> from cpy2py . kernel import kernel_state <NEWLINE> from cpy2py . twinterpreter import group_state <NEWLINE>
class SymbolPrimitives ( Primitives ) : <NEWLINE> <INDENT> def install_primitives ( self ) : <NEWLINE> <INDENT> self . _install_instance_primitive ( Primitive ( <STRING> , self . _universe , <NEWLINE> <INDENT> _asString ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from m5 . SimObject import SimObject <NEWLINE> from m5 . defines import buildEnv <NEWLINE> from m5 . params import * <NEWLINE> from m5 . proxy import * <NEWLINE> from SimpleMemory import * <NEWLINE> class MemoryMode ( Enum ) : vals = [ <STRING> , <STRING> , <STRING> ] <NEWLINE>
from team import Team <NEWLINE> __all__ = [ <NEWLINE> <INDENT> Team <NEWLINE> <DEDENT> ] <NEWLINE>
def read_transactions_from_csv ( filename ) : <NEWLINE> <INDENT> transactions = [ ] <NEWLINE> with open ( filename , <STRING> ) as csvfile : <NEWLINE> <INDENT> reader = csv . reader ( csvfile , delimiter = <STRING> , quotechar = <STRING> ) <NEWLINE> reader . next ( ) <NEWLINE> for row in reader : <NEWLINE> <INDENT> transactions . append ( csv_row_to_transaction ( row ) ) <NEWLINE> <DEDENT> <DEDENT> return transactions <NEWLINE> <DEDENT>
def requiredMemoryMB ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return 2000 <NEWLINE> <DEDENT>
class Tx ( namedtuple ( <STRING> , <STRING> ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> @ cachedproperty <NEWLINE> def is_coinbase ( self ) : <NEWLINE> <INDENT> return self . inputs [ 0 ] . is_coinbase <NEWLINE> <DEDENT> <DEDENT>
def draw_square ( size ) : <NEWLINE> <INDENT> for side in range ( 0 , 4 ) : <NEWLINE> <INDENT> turtle . forward ( size ) <NEWLINE> turtle . right ( 90 ) <NEWLINE> <DEDENT> <DEDENT>
from elixir import setup_all , create_all , metadata , Entity , session , drop_all <NEWLINE> from sqlalchemy import create_engine <NEWLINE> from sqlalchemy . pool import StaticPool <NEWLINE> from astral . conf import settings <NEWLINE> from astral . models . node import Node <NEWLINE> from astral . models . stream import Stream <NEWLINE> from astral . models . ticket import Ticket <NEWLINE> from astral . models . event import Event <NEWLINE> metadata . bind = create_engine ( <STRING> % <NEWLINE> <INDENT> settings . DATABASE_PATH , echo = False , poolclass = StaticPool ) <NEWLINE> <DEDENT> setup_all ( ) <NEWLINE> create_all ( ) <NEWLINE>
def get_imdb_ijba ( data_dir ) : <NEWLINE> <INDENT> imdb = [ ] <NEWLINE> nfold = 10 <NEWLINE> for n in xrange ( nfold ) : <NEWLINE> <INDENT> file_name = <STRING> % ( ( n + 1 ) , ( n + 1 ) ) <NEWLINE> fid = open ( file_name , <STRING> ) <NEWLINE> image_names = [ ] <NEWLINE> for im_name in fid : <NEWLINE> <INDENT> image_names . append ( im_name . strip ( <STRING> ) ) <NEWLINE> <DEDENT> imdb . append ( image_names ) <NEWLINE> <DEDENT> return imdb <NEWLINE> <DEDENT>
def fib_x ( n ) : <NEWLINE> <INDENT> if n == 0 or n == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return fib_x ( n - 1 ) + fib_x ( n - 2 ) <NEWLINE> <DEDENT> <DEDENT>
import imp <NEWLINE> from django . core . management import execute_manager <NEWLINE> import sys <NEWLINE> import os <NEWLINE> sys . path . insert ( 0 , os . path . abspath ( <STRING> ) ) <NEWLINE> try : <NEWLINE> <INDENT> imp . find_module ( <STRING> ) <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> import sys <NEWLINE> sys . stderr . write ( <STRING> % __file__ ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> import settings <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> execute_manager ( settings ) <NEWLINE> <DEDENT>
def get_run ( firehose_dir , version = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> path = <STRING> . format ( firehose_dir ) <NEWLINE> if version is <STRING> : <NEWLINE> <INDENT> version = sorted ( os . listdir ( path ) ) [ - 1 ] <NEWLINE> <DEDENT> run = pickle . load ( open ( <STRING> . format ( path , version ) , <STRING> ) ) <NEWLINE> return run <NEWLINE> <DEDENT>
<STRING> <NEWLINE> __author__ = <STRING> <NEWLINE> __date__ = <STRING> <NEWLINE> __version__ = <STRING> <NEWLINE> __credits__ = <STRING> <NEWLINE> configPath = <STRING> <NEWLINE> sqlFilePath = None <NEWLINE> withDBCreate = 1 <NEWLINE> uId = 0 <NEWLINE> import dbengine <NEWLINE> from toolib . utility . timer import Timer <NEWLINE>
class CorpusDataSitemap ( GenericSitemap ) : <NEWLINE> <INDENT> priority = 0.9 <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> super ( CorpusDataSitemap , self ) . __init__ ( info_dict = { <STRING> : Poem . objects . all ( ) } ) <NEWLINE> <DEDENT> <DEDENT>
def test_template_for_url ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> resp = self . client . get ( <STRING> ) <NEWLINE> self . assertEqual ( resp . status_code , 200 ) <NEWLINE> <DEDENT>
import unittest <NEWLINE> import numpy as np <NEWLINE> from numpy . testing import assert_array_almost_equal <NEWLINE> from param import resolve_path <NEWLINE> from topo . base . boundingregion import BoundingBox <NEWLINE> from topo . pattern . image import FileImage <NEWLINE> from topo . transferfn import IdentityTF <NEWLINE>
def test_tableheader ( ) : <NEWLINE> <INDENT> tokens = tuple ( lexer . tokenize ( <STRING> ) ) <NEWLINE> element = TableHeaderElement ( tokens ) <NEWLINE> assert element . is_array_of_tables <NEWLINE> assert ( <STRING> , <STRING> , <STRING> ) == element . names <NEWLINE> assert element . has_name_prefix ( ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT>
def initialization ( levels ) : <NEWLINE> <INDENT> nt = 0 <NEWLINE> for i , l in enumerate ( levels ) : <NEWLINE> <INDENT> if i == len ( levels ) - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> nt += levels [ i + 1 ] * l <NEWLINE> if i != len ( levels ) - 2 : <NEWLINE> <INDENT> nt += levels [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> return np . random . normal ( 0. , 1. , nt ) <NEWLINE> <DEDENT>
class Migration ( migrations . Migration ) : <NEWLINE> <INDENT> dependencies = [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE> operations = [ <NEWLINE> <INDENT> migrations . RunPython ( load_fixture ) , <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT>
def play ( item ) : <NEWLINE> <INDENT> logger . info ( <STRING> ) <NEWLINE> itemlist = servertools . find_video_items ( data = item . url ) <NEWLINE> for videoitem in itemlist : <NEWLINE> <INDENT> videoitem . title = <STRING> + videoitem . server + <STRING> + scrapertools . get_filename_from_url ( videoitem . url ) + <STRING> <NEWLINE> videoitem . fulltitle = item . fulltitle <NEWLINE> videoitem . thumbnail = item . thumbnail <NEWLINE> videoitem . channel = item . channel <NEWLINE> <DEDENT> return itemlist <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from pathlib import Path <NEWLINE> from wand . image import Image <NEWLINE> from tempfile import NamedTemporaryFile <NEWLINE> import subprocess <NEWLINE> MINHEIGHT = 500 <NEWLINE>
class FencedCodeExtension ( markdown . Extension ) : <NEWLINE> <INDENT> def extendMarkdown ( self , md , md_globals ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> md . preprocessors . add ( <STRING> , <NEWLINE> <INDENT> FencedBlockPreprocessor ( md ) , <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from datetime import datetime <NEWLINE> from django . shortcuts import resolve_url as r <NEWLINE> from django . test import TestCase <NEWLINE> from orcamentos . proposal . models import Entry <NEWLINE> from . test_base import BaseEntryTest <NEWLINE>
import wx <NEWLINE> from multiplatform_widgets import widgets <NEWLINE> from base import basePanel <NEWLINE>
from __future__ import absolute_import <NEWLINE> import sys <NEWLINE> from salt . utils . winservice import Service , instart <NEWLINE> import salt <NEWLINE> import salt . defaults . exitcodes <NEWLINE> import win32serviceutil <NEWLINE> import win32service <NEWLINE> import winerror <NEWLINE>
import numpy as np <NEWLINE> import matplotlib . pyplot as plt <NEWLINE> marker_settings = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <DEDENT> } <NEWLINE>
class DD ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , text = None ) : <NEWLINE> <INDENT> self . tag = <STRING> <NEWLINE> self . values = { <STRING> : text } <NEWLINE> <DEDENT> def construct ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return dd . render ( self . values ) <NEWLINE> <DEDENT> <DEDENT>
class Contact ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . n = N ( ) <NEWLINE> self . fn = n . formatted_name ( ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , http_client = None , http_call_back = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> BaseController . __init__ ( self , http_client , http_call_back ) <NEWLINE> <DEDENT>
class AutomationScenesView ( SubView ) : <NEWLINE> <INDENT> def __init__ ( self , evManager ) : <NEWLINE> <INDENT> super ( ) . __init__ ( evManager ) <NEWLINE> self . name = <STRING> <NEWLINE> self . title = <STRING> <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import logging <NEWLINE> import threading <NEWLINE> import time <NEWLINE> logging . basicConfig ( level = logging . DEBUG , <NEWLINE> <INDENT> format = <STRING> , <NEWLINE> ) <NEWLINE> <DEDENT>
from sa_tools . parsers . search_result import SearchResultParser <NEWLINE> from sa_tools . base import SAObj <NEWLINE> from sa_tools . thread import Thread <NEWLINE> from sa_tools . forum import Forum <NEWLINE> from sa_tools . poster import Poster <NEWLINE> from sa_tools . post import Post <NEWLINE>
from setuptools import setup <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> version = <STRING> , <NEWLINE> packages = [ <STRING> ] , <NEWLINE> scripts = [ <STRING> ] , <NEWLINE> author = <STRING> , <NEWLINE> author_email = <STRING> , <NEWLINE> description = <STRING> , <NEWLINE> license = <STRING> , <NEWLINE> url = <STRING> <NEWLINE> <DEDENT> ) <NEWLINE>
def getedutext ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> edunodelist = getedunode ( self . tree ) <NEWLINE> texts = [ ] <NEWLINE> for node in edunodelist : <NEWLINE> <INDENT> texts . append ( node . text ) <NEWLINE> <DEDENT> return texts <NEWLINE> <DEDENT>
<STRING> <NEWLINE> revision = <STRING> <NEWLINE> down_revision = <STRING> <NEWLINE> branch_labels = None <NEWLINE> depends_on = None <NEWLINE> from alembic import op <NEWLINE> from sqlalchemy import Column , ForeignKey , Numeric <NEWLINE> from sqlalchemy_utils import UUIDType <NEWLINE>
import re <NEWLINE> import numpy as np <NEWLINE> import sympy <NEWLINE> from sympy import collect <NEWLINE>
def test_401_with_unsupported_authorization_header ( client ) : <NEWLINE> <INDENT> headers = Headers ( ) <NEWLINE> headers . set ( <STRING> , <STRING> ) <NEWLINE> response = client . get ( <STRING> , headers = headers ) <NEWLINE> assert response . status_code == 401 <NEWLINE> assert response . json . get ( <STRING> ) == <STRING> <NEWLINE> <DEDENT>
import testtools <NEWLINE> import webob . exc <NEWLINE> from nova . api . openstack . compute import hosts as os_hosts_v21 <NEWLINE> from nova . compute import power_state <NEWLINE> from nova . compute import vm_states <NEWLINE> from nova import context as context_maker <NEWLINE> from nova import db <NEWLINE> from nova import exception <NEWLINE> from nova import test <NEWLINE> from nova . tests . unit . api . openstack import fakes <NEWLINE> from nova . tests . unit import fake_hosts <NEWLINE> from nova . tests import uuidsentinel <NEWLINE>
import pypug <NEWLINE> <STRING> <NEWLINE> cid = 2244 <NEWLINE> properties = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> data = pypug . getCompoundPropertiesFromCID ( cid , properties ) <NEWLINE> print ( data ) <NEWLINE>
<STRING> <NEWLINE> from django . conf . urls import url , include <NEWLINE> from django . contrib import admin <NEWLINE> urlpatterns = [ <NEWLINE> <INDENT> url ( <STRING> , include ( admin . site . urls ) ) , <NEWLINE> url ( <STRING> , include ( <STRING> ) ) , <NEWLINE> url ( <STRING> , include ( <STRING> ) ) , <NEWLINE> url ( <STRING> , include ( <STRING> ) ) , <NEWLINE> url ( <STRING> , include ( <STRING> ) ) , <NEWLINE> <DEDENT> ] <NEWLINE>
class MockedOSCrawlerFailure : <NEWLINE> <INDENT> def crawl ( self , container_id , ** kwargs ) : <NEWLINE> <INDENT> if container_id == <STRING> : <NEWLINE> <INDENT> raise OSError ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ ( <STRING> , { <STRING> : <STRING> } , <STRING> ) ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def GetConversations ( limit , offset ) : <NEWLINE> <INDENT> all_args = { k : len ( v ) == 0 or v [ 0 ] for k , v in request . args . lists ( ) } <NEWLINE> return dg . MakeFakeDataMgr ( <STRING> ) . RecentConversations ( limit , offset , all_args ) <NEWLINE> <DEDENT>
def r34 ( tags ) : <NEWLINE> <INDENT> link = <STRING> + tags <NEWLINE> rget = requests . get ( link . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> root = xml . etree . ElementTree . fromstring ( rget . text ) <NEWLINE> try : <NEWLINE> <INDENT> return <STRING> + root [ random . randint ( 0 , len ( root ) - 1 ) ] . attrib [ <STRING> ] <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> <INDENT> return e <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from __future__ import absolute_import <NEWLINE> from __future__ import division <NEWLINE> from __future__ import print_function <NEWLINE> from __future__ import unicode_literals <NEWLINE> import io <NEWLINE> import logging <NEWLINE> import os . path <NEWLINE> import pstats <NEWLINE> import random <NEWLINE> import unittest <NEWLINE> import six <NEWLINE> from cutplace import interface <NEWLINE> from cutplace import validio <NEWLINE> from cutplace import _compat <NEWLINE> from cutplace import applications <NEWLINE> from cutplace import _tools <NEWLINE> from tests import dev_test <NEWLINE> _log = logging . getLogger ( <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> import cProfile as profile <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> import profile <NEWLINE> _log . warning ( <STRING> ) <NEWLINE> <DEDENT>
def contextMenuEvent ( self , event ) : <NEWLINE> <INDENT> pos = event . globalPos ( ) <NEWLINE> action = actionAtPos ( pos ) <NEWLINE> if action : <NEWLINE> <INDENT> G . item_context_menu . act ( action , pos ) <NEWLINE> <DEDENT> event . accept ( ) <NEWLINE> <DEDENT>
class ReconcileOrdersAndTransactionsDownstreamMixin ( MapReduceJobTaskMixin ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import_date = luigi . DateParameter ( ) <NEWLINE> <DEDENT>
class SendingEligibility ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . eligible = <STRING> <NEWLINE> self . reason_code = <STRING> <NEWLINE> self . account_number = <STRING> <NEWLINE> self . ica = <STRING> <NEWLINE> self . currency = <STRING> <NEWLINE> self . country = <STRING> <NEWLINE> self . brand = <STRING> <NEWLINE> <DEDENT> <DEDENT>
import coverage <NEWLINE> from unittest import TextTestRunner , TestLoader <NEWLINE> from os . path import split , join , abspath <NEWLINE> from os import chdir <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> project_dir = split ( split ( abspath ( __file__ ) ) [ 0 ] ) [ 0 ] <NEWLINE> chdir ( project_dir ) <NEWLINE> cov = coverage . coverage ( branch = True ) <NEWLINE> cov . start ( ) <NEWLINE> suite = TestLoader ( ) . discover ( <STRING> , pattern = <STRING> ) <NEWLINE> TextTestRunner ( verbosity = 2 ) . run ( suite ) <NEWLINE> cov . stop ( ) <NEWLINE> cov . save ( ) <NEWLINE> cov . html_report ( ) <NEWLINE> <DEDENT>
def course_description ( request , pk ) : <NEWLINE> <INDENT> course = get_object_or_404 ( models . Course , pk = pk ) <NEWLINE> return http . HttpResponse ( course . long_description_html ) <NEWLINE> <DEDENT>
def create_from_template ( self , template_id , custom_fields = None , * args , ** kwargs ) : <NEWLINE> <INDENT> auth = None <NEWLINE> if <STRING> in kwargs : <NEWLINE> <INDENT> auth = kwargs [ <STRING> ] <NEWLINE> del ( kwargs [ <STRING> ] ) <NEWLINE> <DEDENT> self . validate_signers ( ) <NEWLINE> data = self . data ( ) <NEWLINE> data [ <STRING> ] = template_id <NEWLINE> if custom_fields : <NEWLINE> <INDENT> for k , v in custom_fields . items ( ) : <NEWLINE> <INDENT> data [ <STRING> % k ] = v <NEWLINE> <DEDENT> <DEDENT> return self . signature_request . send_with_reusable_form . post ( auth = auth , data = data , ** kwargs ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> __authors__ = [ <STRING> , <NEWLINE> <INDENT> <STRING> ] <NEWLINE> <DEDENT> import account <NEWLINE>
def __init__ ( self , seqno , type = None ) : <NEWLINE> <INDENT> Base . __init__ ( self , type ) <NEWLINE> self . state [ <STRING> ] = seqno <NEWLINE> self . data = <STRING> <NEWLINE> <DEDENT>
class User ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> self . user_id = None <NEWLINE> self . first_name = None <NEWLINE> self . last_name = None <NEWLINE> self . email = None <NEWLINE> self . pin = None <NEWLINE> <DEDENT> def load_from_tuple ( self , user ) : <NEWLINE> <INDENT> self . user_id = user [ 0 ] <NEWLINE> self . first_name = user [ 1 ] <NEWLINE> self . last_name = user [ 2 ] <NEWLINE> self . email = user [ 3 ] <NEWLINE> self . pin = user [ 4 ] <NEWLINE> return self <NEWLINE> <DEDENT> <DEDENT>
def print_usage ( ) : <NEWLINE> <INDENT> print ( <STRING> + str ( sys . argv [ 0 ] ) + <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> + str ( sys . argv [ 0 ] ) + <STRING> ) <NEWLINE> print ( <STRING> + str ( sys . argv [ 0 ] ) + <STRING> ) <NEWLINE> print ( <STRING> + str ( sys . argv [ 0 ] ) + <STRING> ) <NEWLINE> <DEDENT>
import unittest <NEWLINE> from PySide2 . QtWidgets import QMenu <NEWLINE> from PySide2 . QtGui import QKeySequence , QIcon <NEWLINE> from PySide2 . QtCore import SLOT <NEWLINE> from helper import UsesQApplication <NEWLINE>
from django . conf . urls import patterns , url <NEWLINE> from . views import IndexView , DetailView <NEWLINE> urlpatterns = [ <NEWLINE> <INDENT> url ( <STRING> , IndexView . as_view ( ) , name = <STRING> ) , <NEWLINE> url ( <STRING> , DetailView . as_view ( ) , name = <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE>
from django . utils . module_loading import autodiscover_modules <NEWLINE> from . decorators import register <NEWLINE> from . sites import AdminReportSite , site <NEWLINE> from . reports import Report <NEWLINE> __version__ = <STRING> <NEWLINE> __all__ = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE>
def count ( self ) : <NEWLINE> <INDENT> if self . topContainer is None : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return 1 <NEWLINE> <DEDENT>
def get_song_json ( self , song_id ) : <NEWLINE> <INDENT> json_url = <STRING> <NEWLINE> post_data = <STRING> % ( song_id , ) <NEWLINE> headers = { <NEWLINE> <INDENT> <STRING> : <STRING> <NEWLINE> <DEDENT> } <NEWLINE> json_str = common . get_url_content ( json_url , post_data , headers ) <NEWLINE> if not json_str : <NEWLINE> <INDENT> logging . info ( <STRING> , url ) <NEWLINE> return False <NEWLINE> <DEDENT> obj = json . loads ( json_str ) <NEWLINE> return obj <NEWLINE> <DEDENT>
def test_ip_to_int_conversion ( self ) : <NEWLINE> <INDENT> for ip in ip_generator ( 50000 ) : <NEWLINE> <INDENT> num = convert_ip_to_int ( ip ) <NEWLINE> self . failIf ( num < 0 ) <NEWLINE> self . assertEqual ( ip , convert_int_to_ip ( num ) ) <NEWLINE> <DEDENT> <DEDENT>
class Permissions ( models . Model ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> class Meta : <NEWLINE> <INDENT> permissions = ( <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> <DEDENT>
def test_disconnect ( self ) : <NEWLINE> <INDENT> self . robot . disconnect ( ) <NEWLINE> res = self . robot . is_connected ( ) <NEWLINE> self . assertEquals ( bool ( res ) , False ) <NEWLINE> <DEDENT>
import keys as keys <NEWLINE> from readFromWhatPulseDb import readFromWhatPulseDb <NEWLINE> from mySqlHandler import mySqlHandler <NEWLINE> data = readFromWhatPulseDb ( ) . returnData ( ) <NEWLINE> sql = mySqlHandler ( keys ) <NEWLINE> for entry in data : <NEWLINE> <INDENT> sql . insertArrayIntoDb ( entry ) <NEWLINE> <DEDENT>
from __future__ import division <NEWLINE> from optparse import OptionParser <NEWLINE> import csv <NEWLINE> import MySQLdb <NEWLINE> import sys <NEWLINE>
def test_is_created ( self ) : <NEWLINE> <INDENT> shell = unittest . mock . MagicMock ( ) <NEWLINE> container = robot . cloud . container . Container ( shell , <STRING> ) <NEWLINE> shell . run . return_value = robot . tests . future ( ( 1 , <STRING> ) ) <NEWLINE> self . assertFalse ( ( yield container . is_created ( ) ) ) <NEWLINE> shell . reset_mock ( ) <NEWLINE> shell . run . return_value = robot . tests . future ( ( 0 , <STRING> ) ) <NEWLINE> self . assertTrue ( ( yield container . is_created ( ) ) ) <NEWLINE> <DEDENT>
def get ( self , id ) : <NEWLINE> <INDENT> self . check_admin ( ) <NEWLINE> user_dao = UserDao ( self . db_session ( ) ) <NEWLINE> user = user_dao . retrieve ( id = id ) <NEWLINE> result = [ p . to_dict ( ) for p in user . permissions ] <NEWLINE> return result , 200 <NEWLINE> <DEDENT>
class HtmlView ( AbstractView ) : <NEWLINE> <INDENT> def __init__ ( self , template_name , model ) : <NEWLINE> <INDENT> self . _template_name = template_name <NEWLINE> self . _model = model <NEWLINE> <DEDENT> def get_content_type ( self ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> def render ( self , out ) : <NEWLINE> <INDENT> basedir = os . path . dirname ( __file__ ) <NEWLINE> t_file = os . path . join ( basedir , <STRING> , <STRING> , <NEWLINE> <INDENT> self . _template_name ) <NEWLINE> <DEDENT> out . write ( template . render ( t_file , self . _model ) ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> import scipy . io . wavfile <NEWLINE> import os , re <NEWLINE>
def __init__ ( self , data = None ) : <NEWLINE> <INDENT> self . parent = None <NEWLINE> self . data = data <NEWLINE> self . forest = [ ] <NEWLINE> <DEDENT>
class Overrides ( Adapter ) : <NEWLINE> <INDENT> def __init__ ( self , data = { } , * args , ** kwargs ) : <NEWLINE> <INDENT> super ( Overrides , self ) . __init__ ( * args , ** kwargs ) <NEWLINE> self . data = data <NEWLINE> self . load ( ) <NEWLINE> <DEDENT> def load ( self , formatter = None ) : <NEWLINE> <INDENT> self . data = dict ( ( self . format ( k , formatter ) , v ) for k , v in self . data . items ( ) ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import os <NEWLINE> import sys <NEWLINE> import numpy as np <NEWLINE> import config <NEWLINE> from config import TRAIN_SIZE <NEWLINE> from utils import np_utils , pkl_utils <NEWLINE>
def test_get_index ( ) : <NEWLINE> <INDENT> example = [ 1 , 2 ] <NEWLINE> assert get_index ( example , 0 ) == 1 <NEWLINE> assert get_index ( example , 3 ) is None <NEWLINE> <DEDENT>
def symlink ( source , destination , use_bind = False ) : <NEWLINE> <INDENT> worker . register_resource ( <NEWLINE> <INDENT> SymlinkResource ( <NEWLINE> <INDENT> source , destination , use_bind <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def tab_response ( self ) : <NEWLINE> <INDENT> if self . flow . intercepted and self . flow . response : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from __future__ import absolute_import <NEWLINE> from __future__ import division <NEWLINE> from __future__ import print_function <NEWLINE> from tensorflow . contrib . seq2seq . python . ops . basic_decoder import * <NEWLINE> from tensorflow . contrib . seq2seq . python . ops . decoder import * <NEWLINE> from tensorflow . contrib . seq2seq . python . ops . dynamic_attention_wrapper import * <NEWLINE> from tensorflow . contrib . seq2seq . python . ops . helper import * <NEWLINE> from tensorflow . contrib . seq2seq . python . ops . loss import * <NEWLINE> from tensorflow . python . util . all_util import remove_undocumented <NEWLINE> _allowed_symbols = [ <STRING> ] <NEWLINE> remove_undocumented ( __name__ , _allowed_symbols ) <NEWLINE>
from setuptools import setup <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> version = <STRING> , <NEWLINE> author = <STRING> , <NEWLINE> author_email = <STRING> , <NEWLINE> license = <STRING> , <NEWLINE> url = <STRING> , <NEWLINE> packages = [ <STRING> ] , <NEWLINE> <DEDENT> ) <NEWLINE>
def __init__ ( self , ** kwargs ) : <NEWLINE> <INDENT> super ( Proposal , self ) . __init__ ( ** kwargs ) <NEWLINE> self . votes = VoteSpace ( type = SPACETYPE . PROPOSAL ) <NEWLINE> self . comments = CommentSpace ( type = SPACETYPE . PROPOSAL ) <NEWLINE> <DEDENT>
def testfindfit ( data ) : <NEWLINE> <INDENT> if verbose : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if audioop . findfit ( data [ 1 ] , data [ 1 ] ) != ( 0 , 1.0 ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return 1 <NEWLINE> <DEDENT>
from distutils . core import setup <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> version = <STRING> , <NEWLINE> description = <STRING> , <NEWLINE> author = <STRING> , <NEWLINE> author_email = <STRING> , <NEWLINE> url = <STRING> , <NEWLINE> packages = [ <STRING> ] , <NEWLINE> install_requires = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <DEDENT> ] , <NEWLINE> <DEDENT> ) <NEWLINE>
def getlocale ( category = LC_CTYPE ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return None , None <NEWLINE> <DEDENT>
def __call__ ( self , y ) : <NEWLINE> <INDENT> res = self . interpolate ( y ) <NEWLINE> return res <NEWLINE> <DEDENT>
from selene . support import by <NEWLINE> from selene . support . jquery_style_selectors import s <NEWLINE> from selenium . webdriver . common . by import By <NEWLINE> from TestUserData . TestUserData import test_email , correct_test_password <NEWLINE> from roses . rosesPages . RemindpasswordPage import RemindpasswordPage <NEWLINE> from roses . rosesPages . TopBottomMenu import TopBottomMenu <NEWLINE> from roses . rosesPages . UsercabinetPage import UsercabinetPage <NEWLINE>
def test_goalf_toolchain ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . get_toolchain ( <STRING> , version = <STRING> ) <NEWLINE> <DEDENT>
from helpers import crop_image <NEWLINE> from lbp import LocalBinaryPatternsDescriptor <NEWLINE> from hist import HistDescriptor <NEWLINE>
from unittest import TestCase <NEWLINE> import numpy as np <NEWLINE> from sklearn . svm . classes import SVC <NEWLINE> from tests . estimator . classifier . Classifier import Classifier <NEWLINE> from tests . language . Ruby import Ruby <NEWLINE>
def _parse_args ( ) : <NEWLINE> <INDENT> parser = argparse . ArgumentParser ( ) <NEWLINE> parser . add_argument ( <STRING> , choices = ( <STRING> , <STRING> , <STRING> ) , <NEWLINE> <INDENT> default = <STRING> ) <NEWLINE> <DEDENT> parser . add_argument ( <STRING> , default = DEFAULT_FOLDER ) <NEWLINE> parser . add_argument ( <STRING> , default = None ) <NEWLINE> parser . add_argument ( <STRING> , default = DEFAULT_SEED ) <NEWLINE> return parser . parse_args ( ) <NEWLINE> <DEDENT>
def get_profile_page_html ( self , uid = None , page = <STRING> , domain = <STRING> ) : <NEWLINE> <INDENT> if not uid : <NEWLINE> <INDENT> uid = str ( self . http_helper . get_uid ( ) ) <NEWLINE> <DEDENT> profile_path = self . path_profile . replace ( <STRING> , domain ) <NEWLINE> profile_path = profile_path . replace ( <STRING> , str ( uid ) ) <NEWLINE> profile_path = profile_path . replace ( <STRING> , str ( page ) ) <NEWLINE> return self . http_helper . get_html ( profile_path ) <NEWLINE> <DEDENT>
from datetime import datetime <NEWLINE> from dateutil . relativedelta import relativedelta <NEWLINE> import time <NEWLINE> import pooler <NEWLINE> from report . render import render <NEWLINE>
from gravity . tae . text import Text , TextBulk , TextFile , TokenizedText , GzipTextFile , XmlText <NEWLINE> from gravity . tae . text import fRegexpSearch , fMatch , fSearch , AnnotatedText <NEWLINE> from gravity . tae . text import fStandardSearch , fStandardMatch , fSearchAll , fTokensAligner <NEWLINE> from gravity . tae . tokenizer import WhiteSpaceTokenzier <NEWLINE> import unittest , os , re <NEWLINE> test_dir = os . path . dirname ( __file__ ) <NEWLINE> txt_file = os . path . join ( test_dir , <STRING> ) <NEWLINE> assert os . path . exists ( txt_file ) <NEWLINE>
def update_paths ( pipe_dict , ms_path = None , pipepath = None ) : <NEWLINE> <INDENT> if ms_path is not None : <NEWLINE> <INDENT> pipe_dict [ <STRING> ] = ms_path <NEWLINE> pipe_dict [ <STRING> ] = ms_path [ : - 3 ] <NEWLINE> <DEDENT> if pipepath is not None : <NEWLINE> <INDENT> pipe_dict [ <STRING> ] = pipepath <NEWLINE> <DEDENT> return pipe_dict <NEWLINE> <DEDENT>
class Command ( BaseCommand ) : <NEWLINE> <INDENT> help = <STRING> <NEWLINE> option_list = list ( BaseCommand . option_list ) + list ( ClearCommand . base_options ) + [ option for option in UpdateCommand . base_options if option . get_opt_string ( ) == <STRING> ] <NEWLINE> def handle ( self , ** options ) : <NEWLINE> <INDENT> call_command ( <STRING> , ** options ) <NEWLINE> call_command ( <STRING> , ** options ) <NEWLINE> <DEDENT> <DEDENT>
def _get_connection_list ( self , hosts , port ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return [ <STRING> . format ( ** locals ( ) ) <NEWLINE> <INDENT> for host in hosts ] <NEWLINE> <DEDENT> <DEDENT>
def get_rater_ids ( self , batch_id ) : <NEWLINE> <INDENT> values = [ ] <NEWLINE> for rating_object in self . ratings : <NEWLINE> <INDENT> if rating_object . batch_id == batch_id and rating_object . rater_id not in values : <NEWLINE> <INDENT> values . append ( rating_object . rater_id ) <NEWLINE> <DEDENT> <DEDENT> return values [ 0 : 5 ] <NEWLINE> <DEDENT>
def _im_identify_type ( fn ) : <NEWLINE> <INDENT> out = check_output ( [ <STRING> , <STRING> , <STRING> , fn ] ) . split ( <STRING> ) [ 0 ] <NEWLINE> return out . strip ( ) . lower ( ) <NEWLINE> <DEDENT>
import os <NEWLINE> from django . conf import settings <NEWLINE> from django . core . exceptions import ImproperlyConfigured <NEWLINE> from django . forms import ValidationError <NEWLINE> from . models import AjaxFileUploaded <NEWLINE> from . signals import pre_ajax_file_save <NEWLINE>
from __future__ import division <NEWLINE> import logging <NEWLINE> import os <NEWLINE> import pkg_resources <NEWLINE> import pandas <NEWLINE> from pandas import concat <NEWLINE> from openfisca_france_indirect_taxation . build_survey_data . utils import ident_men_dtype <NEWLINE> log = logging . getLogger ( __name__ ) <NEWLINE>
def fin_current ( self , t = None ) : <NEWLINE> <INDENT> if ( not t ) : <NEWLINE> <INDENT> t = time . time ( ) <NEWLINE> <DEDENT> if ( self . cur_event ) : <NEWLINE> <INDENT> self . cur_event . end = t <NEWLINE> self . cur_event = None <NEWLINE> <DEDENT> <DEDENT>
def F2level ( J , B , D , H , lamb , lambdap , lambdapp , mu , mup , mupp , muppp ) : <NEWLINE> <INDENT> x = J * ( J + 1 ) <NEWLINE> return B * x - D * x * x + H * x * x * x + 2 * lamb / 3 + 2 * lambdap * x / 3 + 2 * lambdapp * x * x / 3 - mu - mup * x - mupp * x * x + muppp <NEWLINE> <DEDENT>
def setUp ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> pre_obj = event . PreprocessObject ( ) <NEWLINE> self . _plugin = mac_document_versions . MacDocumentVersionsPlugin ( pre_obj ) <NEWLINE> <DEDENT>
def test_return_for ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> if i % 2 : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from os import path <NEWLINE> from docutils import nodes <NEWLINE> from docutils . parsers . rst import directives <NEWLINE> from sphinx import addnodes <NEWLINE> from sphinx . domains . c import CObject <NEWLINE>
def str2int ( s ) : <NEWLINE> <INDENT> def fn2 ( x , y ) : <NEWLINE> <INDENT> return x * 10 + y <NEWLINE> <DEDENT> def char2num2 ( s ) : <NEWLINE> <INDENT> return { <STRING> : 0 , <STRING> : 1 , <STRING> : 2 , <STRING> : 3 , <STRING> : 4 , <STRING> : 5 , <STRING> : 6 , <STRING> : 7 , <STRING> : 8 , <STRING> : 9 } [ s ] <NEWLINE> <DEDENT> return reduce ( fn2 , map ( char2num2 , s ) ) <NEWLINE> <DEDENT>
import hashlib <NEWLINE> secret_key = <STRING> <NEWLINE> number = 0 <NEWLINE>
from django import forms <NEWLINE> from django . forms . utils import flatatt <NEWLINE> from django . utils . html import escape <NEWLINE> from django . utils . safestring import mark_safe <NEWLINE> from django . utils . translation import ugettext as _ <NEWLINE>
<STRING> <NEWLINE> from __future__ import print_function , division <NEWLINE> from io import BytesIO <NEWLINE> try : <NEWLINE> <INDENT> from sympy import latex as default_latex <NEWLINE> from sympy import preview <NEWLINE> from sympy . core . compatibility import integer_types <NEWLINE> from sympy . utilities . misc import debug <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import time <NEWLINE> import logging <NEWLINE> import numpy as np <NEWLINE> from robo . initial_design . init_random_uniform import init_random_uniform <NEWLINE> from robo . solver . bayesian_optimization import BayesianOptimization <NEWLINE> from robo . incumbent . best_observation import BestProjectedObservation <NEWLINE> from robo . initial_design . extrapolative_initial_design import extrapolative_initial_design <NEWLINE> logger = logging . getLogger ( __name__ ) <NEWLINE>
class Migration ( migrations . Migration ) : <NEWLINE> <INDENT> dependencies = [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE> operations = [ <NEWLINE> <INDENT> migrations . RemoveField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> <DEDENT> ) , <NEWLINE> migrations . AlterField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> field = models . ForeignKey ( on_delete = django . db . models . deletion . CASCADE , related_name = <STRING> , to = <STRING> ) , <NEWLINE> <DEDENT> ) , <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT>
class Collections ( enum . Enum ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> PROJECTS_TESTMATRICES = ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> { } , <NEWLINE> [ <STRING> , <STRING> ] <NEWLINE> <DEDENT> ) <NEWLINE> TESTENVIRONMENTCATALOG = ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> { } , <NEWLINE> [ <STRING> ] <NEWLINE> <DEDENT> ) <NEWLINE> def __init__ ( self , collection_name , path , flat_paths , params ) : <NEWLINE> <INDENT> self . collection_name = collection_name <NEWLINE> self . path = path <NEWLINE> self . flat_paths = flat_paths <NEWLINE> self . params = params <NEWLINE> <DEDENT> <DEDENT>
def render_prompt ( self , prompt ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> prompt = prompt . strip ( <STRING> ) . replace ( <STRING> , <STRING> ) <NEWLINE> for colour in ansi . COLOURS_NAMED : <NEWLINE> <INDENT> if <STRING> % ( colour ) in prompt : <NEWLINE> <INDENT> prompt = prompt . replace ( <NEWLINE> <INDENT> <STRING> % ( colour ) , ansiFormatter . cmdColourNamed ( colour ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> prompt = prompt . replace ( <STRING> , ansiFormatter . cmdReset ( ) ) <NEWLINE> return prompt <NEWLINE> <DEDENT>
from abc_lexer import ABC_Lexer <NEWLINE> import time <NEWLINE> import sys <NEWLINE> lex = ABC_Lexer ( ) <NEWLINE>
from model . group import Group <NEWLINE> import random <NEWLINE> import string <NEWLINE> import os . path <NEWLINE> import jsonpickle <NEWLINE> import getopt <NEWLINE> import sys <NEWLINE> try : <NEWLINE> <INDENT> opts , args = getopt . getopt ( sys . argv [ 1 : ] , <STRING> , [ <STRING> , <STRING> ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> getopt . usage ( ) <NEWLINE> sys . exit ( 2 ) <NEWLINE> <DEDENT> n = 5 <NEWLINE> f = <STRING> <NEWLINE> for o , a in opts : <NEWLINE> <INDENT> if o == <STRING> : <NEWLINE> <INDENT> n = int ( a ) <NEWLINE> <DEDENT> elif o == <STRING> : <NEWLINE> <INDENT> f = a <NEWLINE> <DEDENT> <DEDENT>
import os <NEWLINE> import glob <NEWLINE> import xml . etree . ElementTree as elementTree <NEWLINE> import pymysql as mySQL <NEWLINE> import argparse <NEWLINE> import getpass <NEWLINE>
<STRING> <NEWLINE> import sys <NEWLINE> try : <NEWLINE> <INDENT> from plunger import toolbox <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> sys . path . append ( <STRING> ) <NEWLINE> import toolbox <NEWLINE> sys . path . pop ( ) <NEWLINE> <DEDENT> format = <STRING> <NEWLINE> ext = <STRING> <NEWLINE> needs_dir = False <NEWLINE> does_import = False <NEWLINE> does_export = True <NEWLINE> version = <STRING> <NEWLINE>
import os <NEWLINE> import re <NEWLINE> PS3AUTOTESTS_DIR = os . path . abspath ( <STRING> ) <NEWLINE> PS3AUTOTESTS_BENCHMARKS = os . path . join ( PS3AUTOTESTS_DIR , <STRING> ) <NEWLINE> PS3AUTOTESTS_COMMON = os . path . join ( PS3AUTOTESTS_DIR , <STRING> ) <NEWLINE> PS3AUTOTESTS_TESTS = os . path . join ( PS3AUTOTESTS_DIR , <STRING> ) <NEWLINE>
<STRING> <NEWLINE> from espresso . esutil import cxxinit <NEWLINE> from espresso import pmi <NEWLINE> from _espresso import analysis_Autocorrelation <NEWLINE>
def nlogn_model ( start , log_slope ) : <NEWLINE> <INDENT> def __inner_model__ ( x ) : <NEWLINE> <INDENT> return start + log_slope * x . name * math . log ( x . name or 0.0001 ) <NEWLINE> <DEDENT> return __inner_model__ <NEWLINE> <DEDENT>
def set_cache ( rev ) : <NEWLINE> <INDENT> from django . core . cache import cache <NEWLINE> cache . set ( <STRING> , rev , timeout = None ) <NEWLINE> <DEDENT>
def importDB ( ) : <NEWLINE> <INDENT> selimagedb = filedialog . askopenfile ( filetypes = ( ( <STRING> , <STRING> ) , ( <STRING> , <STRING> ) ) ) <NEWLINE> try : <NEWLINE> <INDENT> IMDatabase = pickle . load ( open ( selimagedb , <STRING> ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> invalidimagewindow ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def forwards ( self , orm ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> threads = orm [ <STRING> ] . objects . all ( ) <NEWLINE> count = threads . count ( ) <NEWLINE> message = <STRING> <NEWLINE> site_id = django_settings . SITE_ID <NEWLINE> current_site = orm [ <STRING> ] . objects . get ( id = site_id ) <NEWLINE> for thread in ProgressBar ( threads . iterator ( ) , count , message ) : <NEWLINE> <INDENT> thread . site = current_site <NEWLINE> thread . save ( ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import inspect <NEWLINE> from . . singleton import Singleton as dpSingleton <NEWLINE> from . . engine import Engine as dpEngine <NEWLINE> from . . loader import Loader as dpLoader <NEWLINE> from . . model import Model as dpModel <NEWLINE> from . . cache import dpInValueModelConfig <NEWLINE>
import wsme <NEWLINE> from wsme . rest import json <NEWLINE> from wsme import types <NEWLINE> from daisy . api . v2 . model . metadef_object import MetadefObject <NEWLINE> from daisy . api . v2 . model . metadef_property_type import PropertyType <NEWLINE> from daisy . api . v2 . model . metadef_resource_type import ResourceTypeAssociation <NEWLINE> from daisy . api . v2 . model . metadef_tag import MetadefTag <NEWLINE> from daisy . common . wsme_utils import WSMEModelTransformer <NEWLINE>
import re <NEWLINE> from django import http <NEWLINE> try : <NEWLINE> <INDENT> from urlparse import urlparse <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> from urllib . parse import urlparse <NEWLINE> <DEDENT> from corsheaders import defaults as settings <NEWLINE> from django . db . models . loading import get_model <NEWLINE> ACCESS_CONTROL_ALLOW_ORIGIN = <STRING> <NEWLINE> ACCESS_CONTROL_EXPOSE_HEADERS = <STRING> <NEWLINE> ACCESS_CONTROL_ALLOW_CREDENTIALS = <STRING> <NEWLINE> ACCESS_CONTROL_ALLOW_HEADERS = <STRING> <NEWLINE> ACCESS_CONTROL_ALLOW_METHODS = <STRING> <NEWLINE> ACCESS_CONTROL_MAX_AGE = <STRING> <NEWLINE>
from distutils . core import setup <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> version = <STRING> , <NEWLINE> author = <STRING> , <NEWLINE> author_email = <STRING> , <NEWLINE> maintainer = <STRING> , <NEWLINE> maintainer_email = <STRING> , <NEWLINE> url = <STRING> , <NEWLINE> download_url = <STRING> , <NEWLINE> description = <STRING> , <NEWLINE> long_description = <STRING> , <NEWLINE> classifiers = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> <NEWLINE> <DEDENT> ] , <NEWLINE> py_modules = [ <STRING> ] , <NEWLINE> requires = [ <STRING> ] , <NEWLINE> provides = [ <STRING> ] <NEWLINE> <DEDENT> ) <NEWLINE>
<STRING> <NEWLINE> import ldap <NEWLINE> import os . path <NEWLINE> from django . utils . encoding import force_unicode <NEWLINE> DEBUG = False <NEWLINE> if DEBUG : <NEWLINE> <INDENT> import sys <NEWLINE> ldap . set_option ( ldap . OPT_DEBUG_LEVEL , 255 ) <NEWLINE> ldapmodule_trace_level = 1 <NEWLINE> ldapmodule_trace_file = sys . stderr <NEWLINE> <DEDENT> if os . path . exists ( <STRING> ) : <NEWLINE> <INDENT> ldap . set_option ( ldap . OPT_X_TLS_CERTFILE , <STRING> ) <NEWLINE> ldap . set_option ( ldap . OPT_X_TLS_KEYFILE , <STRING> ) <NEWLINE> ldap . set_option ( ldap . OPT_X_TLS_CACERTDIR , <STRING> ) <NEWLINE> <DEDENT>
def scrub_cell ( cell ) : <NEWLINE> <INDENT> if cell [ <STRING> ] != <STRING> : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if <STRING> in cell : <NEWLINE> <INDENT> cell [ <STRING> ] = [ ] <NEWLINE> <DEDENT> for field in ( <STRING> , <STRING> ) : <NEWLINE> <INDENT> if field in cell : <NEWLINE> <INDENT> del cell [ field ] <NEWLINE> <DEDENT> <DEDENT> for field in ( <STRING> , ) : <NEWLINE> <INDENT> if field in cell : <NEWLINE> <INDENT> cell [ field ] = None <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def getMelinderFluids ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> classes = [ ] <NEWLINE> ignList = getIgnoreNames ( ) <NEWLINE> for name , obj in inspect . getmembers ( MelinderFluids ) : <NEWLINE> <INDENT> if inspect . isclass ( obj ) : <NEWLINE> <INDENT> if not name in ignList : <NEWLINE> <INDENT> classes . append ( obj ( ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return classes <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from __future__ import ( absolute_import , division , print_function ) <NEWLINE> from six . moves import ( filter , input , map , range , zip ) <NEWLINE> import iris . tests as tests <NEWLINE> import biggus <NEWLINE> import numpy as np <NEWLINE> import numpy . ma as ma <NEWLINE> from iris . analysis import VARIANCE <NEWLINE> import iris . cube <NEWLINE> from iris . coords import DimCoord <NEWLINE> from iris . tests import mock <NEWLINE>
