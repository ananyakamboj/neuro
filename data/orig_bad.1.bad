import glob <NEWLINE> for filename in glob . glob ( <STRING> ) : <NEWLINE> <INDENT> exec <STRING> % filename [ : - 3 ] <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import unittest <NEWLINE> unittest . main ( ) <NEWLINE> <DEDENT>
def get_last_day ( values , N = <STRING> , NoData = NoDataVal , Thres = 1.0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not N : N = len ( values ) <NEWLINE> last_day = 0 <NEWLINE> Nact = 0 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> if values [ i ] != NoData and values [ i ] > Thres : <NEWLINE> <INDENT> last_day = i <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return ( last_day ) <NEWLINE> <DEDENT>
def backend_object_mode ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with self . giveup_context ( <STRING> <NEWLINE> <INDENT> % ( self . func_id . func_name , ) ) : <NEWLINE> if len ( self . args ) != self . nargs : <NEWLINE> self . args = ( tuple ( self . args ) + ( types . pyobject , ) * <NEWLINE> ( self . nargs - len ( self . args ) ) ) <NEWLINE> return py_lowering_stage ( self . targetctx , <NEWLINE> <INDENT> self . library , <NEWLINE> self . func_ir , <NEWLINE> self . flags ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def __init__ ( self , jel ) : <NEWLINE> <INDENT> self . hostname = jel [ <STRING> ] <NEWLINE> self . cluster = jel [ <STRING> ] <NEWLINE> self . roles = [ str ( x ) . strip ( ) for x in jel [ <STRING> ] . split ( <STRING> ) ] <NEWLINE> if <STRING> in self . roles : <NEWLINE> <INDENT> self . role = <STRING> <NEWLINE> <DEDENT> elif <STRING> in self . roles : <NEWLINE> <INDENT> self . role = <STRING> <NEWLINE> <INDENT> else : <NEWLINE> <INDENT> self . role = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> self . id = jel [ <STRING> ] <NEWLINE> self . repolist = None <NEWLINE> <DEDENT>
def _onHideActionTriggered ( self , checked = False ) : <NEWLINE> <INDENT> plot = self . _hideActions [ id ( self . sender ( ) ) ) ] <NEWLINE> self . hidePlot ( plot ) <NEWLINE> <DEDENT>
def update_graph_from_dropdown ( dropdown multi ) : <NEWLINE> <INDENT> ch = qm . get_symbol ( dropdown , start = <STRING> ) <NEWLINE> if <STRING> in multi : <NEWLINE> <INDENT> ch . add_EMA ( ) <NEWLINE> <DEDENT> if <STRING> in multi : <NEWLINE> <INDENT> ch . add_RSI ( ) <NEWLINE> <DEDENT> if <STRING> in multi : <NEWLINE> <INDENT> ch . add_MACD ( ) <NEWLINE> <DEDENT> if <STRING> in multi : <NEWLINE> <INDENT> ch . add_BBANDS ( ) <NEWLINE> <DEDENT> return ch . to_figure ( ) <NEWLINE> <DEDENT>
def set_http_debug ( val ) : <NEWLINE> <INDENT> global _http_debug <NEWLINE> _http_debug = val <NEWLINE> if identity : <NEWLINE> <INDENT> identity . http_log_debug = val <NEWLINE> <DEDENT> for svc in ( cloudservers , cloudfiles , cloud_loadbalancers , <NEWLINE> <INDENT> cloud_blockstorage , cloud_databases , cloud_dns , cloud_networks , <NEWLINE> autoscale , images , queues ) : <NEWLINE> if svc is not None : <NEWLINE> svc . http_log_debug = val <NEWLINE> <DEDENT> <DEDENT>
def delete_playlist ( self ) : <NEWLINE> <INDENT> self . playlist . lock ( ) <NEWLINE> <INDENT> for i in range ( self . playlist . count ( ) ) : <NEWLINE> <INDENT> self . playlist . remove_index ( 0 ) <NEWLINE> <DEDENT> self . playlist . unlock ( ) <NEWLINE> self . create_random_playlist ( ) <NEWLINE> <DEDENT> <DEDENT>
def fred_timer_start ( s_timer_name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> global GB_ENABLE_TIMINGS , gd_timers <NEWLINE> if GB_ENABLE_TIMINGS : <NEWLINE> gd_timers [ s_timer_name ] = time . time ( ) <NEWLINE> <INDENT> fred_debug ( <STRING> % s_timer_name ) <NEWLINE> <DEDENT> <DEDENT>
def get_temperature ( self ) : <NEWLINE> <INDENT> temperature = self . __send_relay_command__ ( commands [ <STRING> ] , True ) <NEWLINE> if temperature : <NEWLINE> return temperature . rstrip ( ) <NEWLINE> else : <NEWLINE> return False <NEWLINE> <DEDENT>
def GetOption ( self , name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . _Options . GetValue ( name ) <NEWLINE> def Conf ( self , name , * values ) : <NEWLINE> <STRING> <NEWLINE> self . _Options . Conf ( name , values ) <NEWLINE> <DEDENT>
def check_sphinx_version ( expected_version ) : <NEWLINE> <INDENT> sphinx_version = LooseVersion ( sphinx . __version__ ) <NEWLINE> expected_version = LooseVersion ( expected_version ) <NEWLINE> if sphinx_version < expected_version : <NEWLINE> <INDENT> raise RuntimeError ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> . format ( <NEWLINE> <INDENT> expected_version , sphinx_version ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def fix_nfs ( ( node_id , instance_id , dns ) ) : <NEWLINE> <INDENT> key = get_key ( ) <NEWLINE> cmd = <STRING> <NEWLINE> if not ssh_command ( key , dns , cmd ) : <NEWLINE> <INDENT> print ( <STRING> , node_id , instance_id , dns , <STRING> ) <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
def Decode ( self , hex ) : <NEWLINE> <INDENT> plain = <STRING> <NEWLINE> cipher = hex . decode ( <STRING> ) . decode ( <STRING> ) <NEWLINE> for i in range ( len ( cipher ) ) : <NEWLINE> plain += chr ( ord ( cipher [ i ] ) ^ ( ord ( <STRING> ) ) ) <NEWLINE> return plain <NEWLINE> <DEDENT>
def fix_indices ( Is , Js , ( M , N ) ) : <NEWLINE> <INDENT> Is [ Is == M ] = 0 <NEWLINE> Is [ Is == - 1 ] = M - 1 <NEWLINE> Js [ Js == N ] = 0 <NEWLINE> Js [ Js == - 1 ] = N - 1 <NEWLINE> return ( Is , Js ) <NEWLINE> <DEDENT>
def checkBranches ( self , starteip , endeip , op ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = [ ] <NEWLINE> blist = op . getBranches ( emu = self ) <NEWLINE> if len ( blist ) > 1 : <NEWLINE> <INDENT> for bva , bflags in blist : <NEWLINE> <INDENT> if bva == None : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> bpath = self . getBranchNode ( self . curpath , bva ) <NEWLINE> ret . append ( ( bva , bpath ) <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <DEDENT>
class CLIP_UL_tracking_objects ( UIList ) : <NEWLINE> <INDENT> def draw_item ( self , context , layout , data , item , icon , <NEWLINE> <INDENT> active_data , active_propname , index ) : <NEWLINE> tobj = item <NEWLINE> if self . layout_type in { <STRING> , <STRING> } : <NEWLINE> layout . prop ( tobj , <STRING> , text = <STRING> , emboss = False , <NEWLINE> <INDENT> icon = <STRING> if tobj . is_camera <NEWLINE> else <STRING> ) <NEWLINE> elif self . layout_type == <STRING> : <NEWLINE> layout . alignment = <STRING> <NEWLINE> layout . label ( text = <STRING> , <NEWLINE> <INDENT> icon = <STRING> if tobj . is_camera <NEWLINE> else <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<DEDENT> print ( <STRING> . format ( len ( files ) ) ) ) <NEWLINE>
def _get_pass_envs ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> out = [ ] <NEWLINE> for proxyenv in [ <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> ] : <NEWLINE> if proxyenv in os . environ : <NEWLINE> out += [ <STRING> , <STRING> % ( proxyenv , os . environ [ proxyenv ] ) ] <NEWLINE> <DEDENT> return out <NEWLINE> <DEDENT>
def write_submission ( ) : <NEWLINE> <INDENT> with open ( submission , <STRING> ) as outfile : <NEWLINE> <INDENT> outfile . write ( <STRING> ) <NEWLINE> for t , date , ID , x , y in data ( test , D ) : <NEWLINE> <INDENT> p = learner . predict ( x ) <NEWLINE> outfile . write ( <STRING> % ( ID , str ( p ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def __exit__ ( self , type , value , traceback ) : <NEWLINE> <INDENT> if isinstance ( value , LevMarError ) : <NEWLINE> self . traceback = ( type , value , traceback ) <NEWLINE> if isinstance ( value , LinAlgError ) : <NEWLINE> self . traceback = ( type , value , traceback ) <NEWLINE> return isinstance ( value , LevMarError ) or isinstance ( value , LinAlgError ) <NEWLINE> <DEDENT>
def testGetFailures02 ( self ) : <NEWLINE> <INDENT> output = ( <STRING> , 4 , 1124013539.0 , <NEWLINE> <INDENT> [ <STRING> <NEWLINE> <INDENT> % m for m in 53 , 54 , 57 , 58 ] ) <NEWLINE> <DEDENT> <DEDENT> self . filter . addLogPath ( GetFailures . FILENAME_02 ) <NEWLINE> self . filter . addFailRegex ( <STRING> ) <NEWLINE> self . filter . getFailures ( GetFailures . FILENAME_02 ) <NEWLINE> _assert_correct_last_attempt ( self , self . filter , output ) <NEWLINE> <DEDENT>
def GET_PROGRAMS ( self ) : <NEWLINE> <INDENT> if self . debug_mode : print <STRING> <NEWLINE> webcontent = self . get_webcontent ( CAT_URL ) <NEWLINE> catalogue = json . loads ( webcontent ) <NEWLINE> for categorie in catalogue : <NEWLINE> <INDENT> if categorie [ <STRING> ] . encode ( <STRING> ) == self . name : <NEWLINE> <INDENT> programs = categorie [ <STRING> ] <NEWLINE> for program in programs : <NEWLINE> <INDENT> title = program [ <STRING> ] . encode ( <STRING> ) <NEWLINE> self . add_item ( title , self . name , 2 ) <NEWLINE> if self . debug_mode : <NEWLINE> <INDENT> print <STRING> % title <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
( <STRING> <NEWLINE> <DEDENT>
def _get_cache_size ( self ) : <NEWLINE> <INDENT> for size in self . _size_dict . keys ( ) : <NEWLINE> <INDENT> for row in self . _cc . execute ( <NEWLINE> <INDENT> <STRING> , ( size , ) ) : <NEWLINE> if row [ 0 ] not in self . _path_files : <NEWLINE> file_list = self . _size_dict . get ( size , [ ] ) <NEWLINE> self . _size_dict [ size ] = [ row [ 0 ] ] + file_list <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class { { modelname } } ( CommonColumns ) : <NEWLINE> <INDENT> __tablename__ = <STRING> <NEWLINE> guid = Column ( String ( 36 ) , primary_key = True ) <NEWLINE> <DEDENT>
def segments ( self , precision = 0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = [ ] <NEWLINE> for moveTo , group in itertools . groupby ( self . items , <NEWLINE> <INDENT> lambda x : isinstance ( x , MoveTo ) ) : <NEWLINE> if not moveTo : <NEWLINE> seg = [ x . segments ( precision ) for x in group ] <NEWLINE> ret . append ( list ( itertools . chain . from_iterable ( seg ) ) ) <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT>
def check_if_ready_for_barracuda ( ) : <NEWLINE> <INDENT> mariadb_variables = frappe . _dict ( frappe . db . sql ( <STRING> ) ) <NEWLINE> for key , value in { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> } . items ( ) : <NEWLINE> if mariadb_variables . get ( key ) != value : <NEWLINE> print ( <STRING> * 80 ) <NEWLINE> print ( <STRING> ) <NEWLINE> print <NEWLINE> print ( expected_config_for_barracuda ) <NEWLINE> print ( <STRING> * 80 ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , * args , ** kwargs ) : <NEWLINE> <INDENT> dict . __init__ ( self ) <NEWLINE> self . _as_list = { } <NEWLINE> self . _last_key = None <NEWLINE> if ( len ( args ) == 1 and len ( kwargs ) == 0 and <NEWLINE> <INDENT> isinstance ( args [ 0 ] , HTTPHeaders ) ) : <NEWLINE> for k , v in args [ 0 ] . get_all ( ) : <NEWLINE> self . add ( k , v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . update ( * args , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT>
def indentfault ( ) : <NEWLINE> <INDENT> asd ( <NEWLINE> indentback <NEWLINE> <DEDENT>
( <STRING> <NEWLINE> <DEDENT>
def startBeat ( self , connection , request_handler ) : <NEWLINE> <INDENT> beater = PeriodicCallback ( None , self . heart_interval , IOLoop . instance ( ) ) <NEWLINE> def _beat ( ) : <NEWLINE> <INDENT> if connection . connected is False : <NEWLINE> beater . stop ( ) <NEWLINE> else : <NEWLINE> request_handler . write ( chr ( messaging . StreamingMessage . NULL_BYTE ) ) <NEWLINE> request_handler . flush ( ) <NEWLINE> beater . callback = _beat <NEWLINE> beater . start ( ) <NEWLINE> <DEDENT> <DEDENT>
def test_connect_put_node_timeout ( self ) : <NEWLINE> <INDENT> controller = proxy_server . ObjectController ( self . app , <STRING> , <STRING> , <STRING> ) <NEWLINE> self . app . conn_timeout = 0.1 <NEWLINE> with set_http_connect ( 200 , slow_connect = True ) : <NEWLINE> <INDENT> nodes = [ dict ( ip = <STRING> , port = <STRING> , device = <STRING> ) ] <NEWLINE> res = controller . _connect_put_node ( nodes , <STRING> , <STRING> , { } , ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> self . assertTrue ( res is None ) <NEWLINE> <DEDENT>
def dice ( self , ( tag , start , stop , subtags ) , buffer ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> lex_log ( <STRING> ) <NEWLINE> lex_log ( <STRING> + str ( tag ) ) <NEWLINE> lex_log ( <STRING> + str ( start ) ) <NEWLINE> lex_log ( <STRING> + str ( stop ) ) <NEWLINE> lex_log ( <STRING> + str ( subtags ) ) <NEWLINE> lex_log ( <STRING> + str ( buffer ) ) <NEWLINE> lex_log ( <STRING> ) <NEWLINE> return self . rollit ( ( tag , start , stop , subtags ) , buffer ) <NEWLINE> <DEDENT>
def test_create_route_no_subnet_raises ( self ) : <NEWLINE> <INDENT> subnet = dict ( id = 2 , ip_policy = [ ] , cidr = <STRING> ) <NEWLINE> create_route = dict ( id = 1 , cidr = <STRING> , gateway = <STRING> ) <NEWLINE> with self . _stubs ( create_route = create_route , find_routes = [ ] , <NEWLINE> <INDENT> subnet = subnet ) : <NEWLINE> with self . assertRaises ( <NEWLINE> exceptions . BadRequest ) : <NEWLINE> self . plugin . create_route ( self . context , <NEWLINE> <INDENT> dict ( route = create_route ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def goBack ( self ) : <NEWLINE> <INDENT> if self . isAdvancedBladeActive ( ) : <NEWLINE> <INDENT> self . setFocus ( self . advancedButton ) <NEWLINE> else : <NEWLINE> self . close ( ) <NEWLINE> <DEDENT> <DEDENT>
def toggleScreen ( value ) : <NEWLINE> <INDENT> file = open ( SCREEN , <STRING> ) <NEWLINE> current_status = int ( file . read ( 1 ) ) <NEWLINE> <INDENT> if current_status != value : <NEWLINE> os . system ( <STRING> + str ( value ) + <STRING> + SCREEN ) <NEWLINE> <DEDENT> <DEDENT>
class desktopui_BrowserTest ( chrome_test . ChromeTestBase ) : <NEWLINE> <INDENT> version = 1 <NEWLINE> binary_to_run = <STRING> <NEWLINE> blacklist = [ ] <NEWLINE> def run_once ( self , group = 0 , total_groups = 4 ) : <NEWLINE> <INDENT> tests_to_run = self . filter_bad_tests ( <NEWLINE> <INDENT> self . generate_test_list ( self . binary_to_run , group , total_groups ) ) <NEWLINE> <DEDENT> tests_to_run . extend ( map ( lambda ( x ) : <STRING> + x , self . blacklist ) ) <NEWLINE> self . run_chrome_test ( self . binary_to_run , <NEWLINE> <INDENT> <STRING> % <STRING> . join ( tests_to_run ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def html ( file_name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> def html_decorator ( func ) : <NEWLINE> <INDENT> def func_wrapper ( * args , ** kwargs ) : <NEWLINE> <INDENT> self = args [ 0 ] <NEWLINE> with open ( file_name , <STRING> ) as f : <NEWLINE> <INDENT> text = f . read ( ) <NEWLINE> self . response . write ( text ) <NEWLINE> <DEDENT> func ( * args , ** kwargs ) <NEWLINE> <DEDENT> return func_wrapper <NEWLINE> <DEDENT> return html_decorator <NEWLINE> <DEDENT> <DEDENT>
def main_list ( params ) : <NEWLINE> <INDENT> plugintools . log ( <STRING> + repr ( params ) ) <NEWLINE> <INDENT> icon2 = <STRING> <NEWLINE> plugintools . add_item ( title = <STRING> , url = base + <STRING> , thumbnail = icon2 , folder = True ) <NEWLINE> <DEDENT> xbmcplugin . setContent ( int ( sys . argv [ 1 ] ) , <STRING> ) <NEWLINE> xbmc . executebuiltin ( <STRING> ) <NEWLINE> <DEDENT>
class SMTPHandler ( logging . handlers . SMTPHandler ) : <NEWLINE> <INDENT> def __init__ ( self , mailhost , fromaddr , toaddrs , subject , <NEWLINE> <INDENT> credentials = None , secure = None ) : <NEWLINE> if secure is True : <NEWLINE> secure = tuple ( ) <NEWLINE> super ( SMTPHandler , self ) . __init__ ( mailhost , fromaddr , toaddrs , <NEWLINE> <INDENT> subject , credentials , secure ) <NEWLINE> self . subject = subject <NEWLINE> <DEDENT> <DEDENT> def getSubject ( self , record ) : <NEWLINE> <INDENT> now = datetime . datetime . now ( ) <NEWLINE> return now . strftime ( self . subject ) <NEWLINE> <DEDENT> <DEDENT>
def mapSimpleSequenceProperty ( self , prop ) : <NEWLINE> <INDENT> javaprop , javatype = self . _createComplexJavaProp ( prop ) <NEWLINE> values = [ ] <NEWLINE> if prop . hasValue ( ) : <NEWLINE> <INDENT> for value in prop . value ( ) : <NEWLINE> <INDENT> values . append ( java . literal ( value , <NEWLINE> <INDENT> javatype , <NEWLINE> complex = prop . isComplex ( ) ) ) <NEWLINE> javaprop [ <STRING> ] = values <NEWLINE> <DEDENT> <DEDENT> <DEDENT> javaprop [ <STRING> ] = prop . isOptional ( ) <NEWLINE> return javaprop <NEWLINE> <DEDENT>
class FIFOQueueWithTimeoutTest ( tf . test . TestCase ) : <NEWLINE> <INDENT> def testDequeueWithTimeout ( self ) : <NEWLINE> <INDENT> with self . test_session ( <NEWLINE> <INDENT> config = tf . ConfigProto ( operation_timeout_in_ms = 20 ) ) as sess : <NEWLINE> q = tf . FIFOQueue ( 10 , tf . float32 ) <NEWLINE> dequeued_t = q . dequeue ( ) <NEWLINE> with self . assertRaisesRegexp ( tf . errors . DeadlineExceededError , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> <DEDENT> sess . run ( dequeued_t ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def getCPULoad ( ) : <NEWLINE> <INDENT> CPU_LOAD_LOC = <STRING> <NEWLINE> <INDENT> loadFile = open ( CPU_LOAD_LOC ) <NEWLINE> cpuLoad = loadFile . read ( ) <NEWLINE> cpuLoad = cpuLoad . split ( ) [ 0 ] <NEWLINE> cpuLoad = long ( float ( cpuLoad ) ) <NEWLINE> print ( <STRING> % cpuLoad ) <NEWLINE> return cpuLoad <NEWLINE> <DEDENT> <DEDENT>
def mostrar_friends ( ) : <NEWLINE> <INDENT> user = main . me ( ) <NEWLINE> friends = main . friends_ids ( user . id ) <NEWLINE> for f in friends <NEWLINE> <INDENT> name = main . get_user ( f ) <NEWLINE> print ( name ) <NEWLINE> <DEDENT> <DEDENT>
def _ConditionallyUploadToCloudStorage ( self , img_name , page , tab , screenshot ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not self . options . refimg_cloud_storage_bucket : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> cloud_name = self . _FormatReferenceImageName ( img_name , page , tab ) <NEWLINE> if not cloud_storage . Exists ( self . options . refimg_cloud_storage_bucket , <NEWLINE> <INDENT> cloud_name ) : <NEWLINE> self . _UploadBitmapToCloudStorage ( self . options . refimg_cloud_storage_bucket , <NEWLINE> <INDENT> cloud_name , <NEWLINE> screenshot ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>
def set_computer_name ( name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if name : <NEWLINE> <INDENT> name = name . decode ( <STRING> ) <NEWLINE> <DEDENT> if windll . kernel32 . SetComputerNameExW ( win32con . ComputerNamePhysicalDnsHostname , <NEWLINE> <INDENT> name ) : <NEWLINE> ret = { <STRING> : { <STRING> : get_computer_name ( ) } } <NEWLINE> pending = get_pending_computer_name ( ) <NEWLINE> if pending not in ( None , False ) : <NEWLINE> ret [ <STRING> ] [ <STRING> ] = pending <NEWLINE> return ret <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
class MetricsPlot ( object ) : <NEWLINE> <INDENT> def __init__ ( self , query_dict , plot_type , inverted_series , normalize_to , <NEWLINE> <INDENT> drilldown_callback ) : <NEWLINE> <STRING> <NEWLINE> self . query_dict = query_dict <NEWLINE> if plot_type == <STRING> : <NEWLINE> self . is_line = True <NEWLINE> elif plot_type == <STRING> : <NEWLINE> self . is_line = False <NEWLINE> else : <NEWLINE> raise ValidationError ( { <STRING> : <STRING> } ) <NEWLINE> self . plot_type = plot_type <NEWLINE> self . inverted_series = inverted_series <NEWLINE> self . normalize_to = normalize_to <NEWLINE> if self . normalize_to is None : <NEWLINE> self . normalize_to = <STRING> <NEWLINE> self . drilldown_callback = drilldown_callback <NEWLINE> <DEDENT> <DEDENT>
try : <NEWLINE> <INDENT> from icu import Normalizer2 , UNormalizationMode2 <NEWLINE> <DEDENT> except ImportError , e : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> from unittest import main <NEWLINE> from BaseTokenStreamTestCase import BaseTokenStreamTestCase <NEWLINE>
def sliver_status ( self , slice_urn , authority , options ) : <NEWLINE> <INDENT> result = self . shell . SliverStatus ( slice_urn ) <NEWLINE> return result <NEWLINE> <INDENT> def get_expiration_date ( slice_hrn , creds ) : <NEWLINE> <INDENT> for cred in creds : <NEWLINE> <INDENT> credential = Credential ( string = cred ) <NEWLINE> <INDENT> if credential . get_gid_caller ( ) . get_hrn ( ) == slice_hrn : <NEWLINE> <INDENT> return credential . get_expiration ( ) <NEWLINE> return None <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def collidewithladders ( self , player ) : <NEWLINE> <INDENT> for i in self . ladders : <NEWLINE> <INDENT> if i != None and i . collidewithladder ( self , player ) : <NEWLINE> return 2 <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT>
class LogoutRequest ( Request ) : <NEWLINE> <INDENT> def __init__ ( self , sec_context , receiver_addrs , log = None , timeslack = 0 , <NEWLINE> <INDENT> debug = 0 ) : <NEWLINE> Request . __init__ ( self , sec_context , receiver_addrs , log , timeslack , <NEWLINE> <INDENT> debug ) <NEWLINE> self . signature_check = self . sec . correctly_signed_logout_request <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def __init__ ( self , ticket_id , subject_id , , actor_id ) : <NEWLINE> <INDENT> assert ticket_id <NEWLINE> assert subject_id <NEWLINE> assert actor_id <NEWLINE> self . ticket_id = ticket_id <NEWLINE> self . subject_id = subject_id <NEWLINE> self . actor_id = actor_id <NEWLINE> <DEDENT>
class ReaderObserver ( Observer ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def update ( self , observable , ( addedreaders , removedreaders ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>
def print_paths ( self ) : <NEWLINE> <INDENT> for path in self . paths : <NEWLINE> <INDENT> for pt in path : <NEWLINE> <INDENT> print ( str ( pt [ 0 ] ) + <STRING> + str ( pt [ 1 ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def optionGet ( conffile , section , variable ) : <NEWLINE> <INDENT> if ( DEBUG == true ) : print <STRING> <NEWLINE> print ( cp . get ( str ( section ) , str ( variable ) ) ) <NEWLINE> return cp . get ( str ( section ) , str ( variable ) ) <NEWLINE> if ( DEBUG == true ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
def buildCSSFile ( filename , output_filename ) : <NEWLINE> <INDENT> if verbose : <NEWLINE> print ( <STRING> + filename + <STRING> + output_filename ) <NEWLINE> with open ( filename , <STRING> ) as myfile : <NEWLINE> <INDENT> css = myfile . read ( ) <NEWLINE> minified_css = cssmin ( css ) <NEWLINE> with open ( output_filename , <STRING> ) as text_file : <NEWLINE> text_file . write ( minified_css ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT>
def get_property ( property ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> return self . __properties_dict [ property ] <NEWLINE> <DEDENT> <DEDENT>
def collidewithladdersdown ( self , player ) : <NEWLINE> <INDENT> for i in self . ladders : <NEWLINE> <INDENT> if i != None and i . collidewithladderdown ( self , player ) : <NEWLINE> return 2 <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT>
def copy_vm_console_logs ( self , vm_name , dest_host ) : <NEWLINE> <INDENT> local_log_paths = self . _pathutils . get_vm_console_log_paths ( <NEWLINE> <INDENT> vm_name ) <NEWLINE> <DEDENT> remote_log_paths = self . _pathutils . get_vm_console_log_paths ( <NEWLINE> <INDENT> vm_name , remote_server = dest_host ) <NEWLINE> <DEDENT> for local_log_path , remote_log_path in zip ( local_log_paths , <NEWLINE> <INDENT> remote_log_paths ) : <NEWLINE> if self . _pathutils . exists ( local_log_path ) : <NEWLINE> self . _pathutils . copy ( local_log_path , <NEWLINE> remote_log_path ) <NEWLINE> <DEDENT> <DEDENT>
def get_events_conf ( config , key , default = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for getter in [ <NEWLINE> <INDENT> config . cfg [ <STRING> ] [ <STRING> ] , <NEWLINE> GLOBAL_CFG . get ( [ <STRING> , <STRING> ] ) ] : <NEWLINE> try : <NEWLINE> value = getter [ key ] <NEWLINE> except KeyError : <NEWLINE> pass <NEWLINE> else : <NEWLINE> if value is not None : <NEWLINE> <INDENT> return value <NEWLINE> <DEDENT> <DEDENT> return default <NEWLINE> <DEDENT>
def build_features ( a_templates , b_templates ) : <NEWLINE> <INDENT> a_features = [ ] <NEWLINE> b_features = [ ] <NEWLINE> for template in a_templates : <NEWLINE> <INDENT> for i in xrange ( template . cardinality ( ) ) : <NEWLINE> <INDENT> a_features . append ( template ( i ) ) ) <NEWLINE> <DEDENT> <DEDENT> for template in b_templates : <NEWLINE> <INDENT> for i in xrange ( template . cardinality ( ) ) : <NEWLINE> <INDENT> b_features . append ( template ( i ) ) <NEWLINE> <DEDENT> <DEDENT> return ( a_features , b_features ) <NEWLINE> <DEDENT>
def test_nonascii_bytes_literals ( self ) : <NEWLINE> <INDENT> expected = <STRING> <NEWLINE> with check_py3k_warnings ( ( expected , SyntaxWarning ) ) : <NEWLINE> <INDENT> exec <STRING> <NEWLINE> <DEDENT> <DEDENT>
def _test_revamp ( ) : <NEWLINE> <INDENT> ImportManager ( ) . install ( ) <NEWLINE> sys . path . insert ( 0 , BuiltinImporter ( ) ) ) <NEWLINE> <DEDENT>
( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
def TranslatePagespeed ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> pagespeed = self . app_engine_web_xml . pagespeed <NEWLINE> if not pagespeed : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> statements = [ <STRING> ] <NEWLINE> for title , urls in [ ( <STRING> , pagespeed . domains_to_rewrite ) , <NEWLINE> <INDENT> ( <STRING> , pagespeed . url_blacklist ) , <NEWLINE> ( <STRING> , pagespeed . enabled_rewriters ) , <NEWLINE> ( <STRING> , pagespeed . disabled_rewriters ) ] : <NEWLINE> if urls : <NEWLINE> statements . append ( <STRING> % title ) <NEWLINE> statements += [ <STRING> % url for url in urls ] <NEWLINE> <DEDENT> return statements <NEWLINE> <DEDENT>
def collectOutput ( c1 , c2 , output ) : <NEWLINE> <INDENT> for i in range ( len ( output [ <STRING> ] ) ) : <NEWLINE> <INDENT> iOutput = output [ <STRING> ] [ i ] <NEWLINE> iSubstance = output [ <STRING> ] [ i ] <NEWLINE> iLabel = output [ <STRING> ] [ i ] <NEWLINE> if ( iSubstance == 1 ) : <NEWLINE> <INDENT> output [ <STRING> ] [ iLabel ] . append ( c1 [ iOutput ] ) <NEWLINE> else : <NEWLINE> output [ <STRING> ] [ iLabel ] . append ( c2 [ iOutput ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def subst ( self , s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> new_head = subst ( s , self . head ) <NEWLINE> new_goals = list ( subst_conjunction ( s , self . goals ) ) <NEWLINE> new_rule = Rule ( new_head , new_goals , name = self . name , tv = self . tv , <NEWLINE> <INDENT> formula = self . formula , match = self . match ) <NEWLINE> <DEDENT> return new_rule <NEWLINE> <DEDENT> <DEDENT>
def _download_file ( uri , filename ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> with open ( filename , <STRING> ) as handle : <NEWLINE> <INDENT> request = requests . get ( uri , stream = True ) <NEWLINE> for block in request . iter_content ( 1024 ) : <NEWLINE> <INDENT> if not block : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> handle . write ( block ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except IOError , e : <NEWLINE> <INDENT> print ( e ) <NEWLINE> <DEDENT> <DEDENT>
class Ui_gpsDialog ( object ) : <NEWLINE> <INDENT> def setupUi ( self , gpsDialog ) : <NEWLINE> <INDENT> gpsDialog . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> gpsDialog . resize ( 595 , 300 ) <NEWLINE> gpsDialog . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
def _recursive_delete ( self , reg , start_path , end_path ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> while ( len ( start_path ) < len ( end_path ) ) : <NEWLINE> <INDENT> _winreg . DeleteKey ( reg , end_path ) <NEWLINE> end_path = end_path [ 0 : end_path . rfind ( <STRING> ) ] <NEWLINE> <DEDENT> <DEDENT> except Exception , e : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
def get_measurement_no ( self , number ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not 0 <= number < 8 : <NEWLINE> <INDENT> raise ValueError ( <STRING> + str ( number ) <NEWLINE> <DEDENT> base_address , format = self . I2C_ADDRESS [ <STRING> ] <NEWLINE> return self . _i2c_query ( base_address + number , format ) [ 0 ] <NEWLINE> <DEDENT>
def run_lstm ( self , init_state , input_vecs ) : <NEWLINE> <INDENT> s = init_state <NEWLINE> out_vectors = [ ] <NEWLINE> for vector in input_vecs : <NEWLINE> x_t = lookup ( self . input_lookup , int ( vector ) ) <NEWLINE> <INDENT> s = s . add_input ( x_t ) <NEWLINE> out_vector = s . output ( ) <NEWLINE> out_vectors . append ( out_vector ) <NEWLINE> <DEDENT> return out_vectors <NEWLINE> <DEDENT>
class TransmitThread ( threading . Thread ) : <NEWLINE> <INDENT> def get_message ( self ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> def run ( self ) : <NEWLINE> <INDENT> morsecodelib . sound . config . config . WORDS_PER_MINUTE = 20 <NEWLINE> laser = laserControl . LaserController ( ) <NEWLINE> with laser : <NEWLINE> <INDENT> morse = laserControl . MorseRenderLaser ( laser ) <NEWLINE> morse . text_to_sound ( self . get_message ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class IdentifyGate ( Task ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> min_bbar_width = 0.3 <NEWLINE> def on_first_run ( self , vision ) : <NEWLINE> <INDENT> self . seen_cons_check = ConsistencyCheck ( 4 , 5 ) <NEWLINE> <DEDENT> def on_run ( self , vision ) : <NEWLINE> <INDENT> self . seen_cons_check . add ( vision . bottom is not None and <NEWLINE> if self . seen_cons_check . check ( ) : <NEWLINE> <INDENT> self . finish ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_hspl ( self , target = None , editor = None , token = None ) : <NEWLINE> <INDENT> url = self . base_URL + <STRING> <NEWLINE> params = { } <NEWLINE> <INDENT> if token is not None : <NEWLINE> <INDENT> params [ <STRING> ] = token <NEWLINE> <DEDENT> <DEDENT> if target is not None : <NEWLINE> <INDENT> params [ <STRING> ] = target <NEWLINE> <DEDENT> if editor is not None : <NEWLINE> <INDENT> params [ <STRING> ] = editor <NEWLINE> <DEDENT> return get ( url , params = params ) <NEWLINE> <DEDENT>
class HandleMessage ( Thread ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> def __init__ ( self , report_object , received , addr ) : <NEWLINE> <INDENT> Thread . __init__ ( self ) <NEWLINE> self . received = received <NEWLINE> self . src_address = addr [ 0 ] <NEWLINE> self . response_port = 23456 <NEWLINE> self . bw_for_new_flows = 0.1 <NEWLINE> self . report_object = report_object <NEWLINE> <DEDENT> def run ( self ) : <NEWLINE> <INDENT> self . report_object . message_from_controller ( self . received ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_classifyKind ( self ) : <NEWLINE> <INDENT> aPath = <STRING> <NEWLINE> <INDENT> fc = TemplateFileCreator ( aPath ) <NEWLINE> expectedKind = <STRING> <NEWLINE> result = fc . classifyKind ( ) <NEWLINE> self . assertEqual ( expectedKind , result ) <NEWLINE> <DEDENT> <DEDENT>
class Nivel ( models . Model ) : <NEWLINE> <INDENT> nombre = models . CharField ( , max_length = 50 ) <NEWLINE> margen = models . PositiveSmallIntegerField ( ) <NEWLINE> <INDENT> class Meta : <NEWLINE> <INDENT> verbose_name = _ ( <STRING> ) <NEWLINE> verbose_name_plural = _ ( <STRING> ) <NEWLINE> <DEDENT> def __unicode__ ( self ) : <NEWLINE> <INDENT> return self . nombre <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class CANDaemon ( threading . Thread ) : <NEWLINE> <INDENT> log = None <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> threading . Thread . __init__ ( self ) <NEWLINE> self . setDaemon ( True ) <NEWLINE> self . log = logging . getLogger ( <STRING> ) <NEWLINE> <DEDENT> def run ( self ) : <NEWLINE> self . log . debug ( <STRING> ) <NEWLINE> <INDENT> can_process ( ) <NEWLINE> self . log . debug ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class Command ( BaseCommand ) : <NEWLINE> <INDENT> args = <STRING> <NEWLINE> help = <STRING> <NEWLINE> def handle ( self , * args , ** options ) : <NEWLINE> <INDENT> for directory in args : <NEWLINE> self . stdout . write ( <STRING> % directory ) <NEWLINE> scan_dir_for_new_songs ( directory , verbose = True ) <NEWLINE> <DEDENT> <DEDENT>
def get_file_size ( file_obj ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( hasattr ( file_obj , <STRING> ) and hasattr ( file_obj , <STRING> ) and <NEWLINE> <INDENT> ( six . PY2 or six . PY3 and file_obj . seekable ( ) ) ) : <NEWLINE> try : <NEWLINE> curr = file_obj . tell ( ) <NEWLINE> file_obj . seek ( 0 , os . SEEK_END ) <NEWLINE> size = file_obj . tell ( ) <NEWLINE> file_obj . seek ( curr ) <NEWLINE> return size <NEWLINE> except IOError as e : <NEWLINE> if e . errno == errno . ESPIPE : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def set_wizard_text ( self , text ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . getControl ( self . wizTextbox ) . setText ( text ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> self . oe . dbg_log ( <STRING> , <NEWLINE> <INDENT> <STRING> + repr ( e ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class Logging : <NEWLINE> <INDENT> <STRING> <NEWLINE> def error ( self , msg ) : <NEWLINE> <INDENT> print <STRING> , msg <NEWLINE> <DEDENT> def warn ( self , msg ) : <NEWLINE> <INDENT> print <STRING> , msg <NEWLINE> <DEDENT> def info ( self , msg ) : print msg <NEWLINE> def debug ( self , msg ) : self . vlog ( 1 , msg ) <NEWLINE> def vlog ( self , level , msg ) : <NEWLINE> <INDENT> if FLAGS . v >= level : print msg <NEWLINE> <DEDENT> <DEDENT>
def start ( self , tb ) : <NEWLINE> <INDENT> if tb is None : <NEWLINE> <INDENT> fn , args = self . set_trace , ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fn , args = self . post_mortem , ( tb , ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> t = self . translator <NEWLINE> exec <STRING> <NEWLINE> locals ( ) . update ( self . exposed ) <NEWLINE> fn ( * args ) <NEWLINE> pass <NEWLINE> <DEDENT> except bdb . BdbQuit : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
def check_program ( p ) : <NEWLINE> <INDENT> for d in os . getenv ( <STRING> ) . split ( <STRING> ) : <NEWLINE> if os . path . exists ( os . path . join ( d , p ) ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
class SqliteDict ( proxydict . JsonProxyDict ) : <NEWLINE> <INDENT> def __init__ ( self , path = <STRING> , table = <STRING> , <NEWLINE> <INDENT> isolation_level = <STRING> , * args , ** kwargs ) : <NEWLINE> target = SqliteStringDict ( path , table = table , <NEWLINE> <INDENT> isolation_level = isolation_level ) <NEWLINE> super ( proxydict . JsonProxyDict , self ) . __init__ ( target ) <NEWLINE> self . update ( dict ( * args , ** kwargs ) ) <NEWLINE> <DEDENT> <DEDENT> def copy ( self ) : <NEWLINE> <INDENT> t = self . target <NEWLINE> return SqliteDict ( t . path , t . table , t . isolation_level ) <NEWLINE> <DEDENT> <DEDENT>
class TunClientFactory ( WebSocketClientFactory ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( * args , ** kwargs ) : <NEWLINE> <INDENT> if <STRING> in kwargs and kwargs [ <STRING> ] : <NEWLINE> <INDENT> self . device = kwargs [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise TypeError ( <STRING> ) <NEWLINE> <DEDENT> self . crypto = kwargs [ <STRING> ] if <STRING> in kwargs and kwargs [ <STRING> ] else None <NEWLINE> WebSocketClientFactory . __init__ ( self , * args , ** kwargs ) <NEWLINE> self . log = logging . getLogger ( type ( self ) ) <NEWLINE> self . log . debug ( <STRING> . format ( type ( self ) ) <NEWLINE> <DEDENT> <DEDENT>
def forwards ( self , orm ) : <NEWLINE> <INDENT> db . create_table ( <STRING> , ( <NEWLINE> <INDENT> ( <STRING> , self . gf ( <STRING> ) ( primary_key = True ) ) , <NEWLINE> ( <STRING> , self . gf ( <STRING> ) ( unique = True , max_length = 255 ) ) , <NEWLINE> <DEDENT> ) <NEWLINE> db . send_create_signal ( <STRING> , [ <STRING> ] ) <NEWLINE> <DEDENT>
def get_jaccard_index_map ( g ) : <NEWLINE> <INDENT> edge_to_jaccard = { } <NEWLINE> for u , v in g . edges_iter ( ) : <NEWLINE> u_neighbors = set ( g . neighbors ( u ) ) <NEWLINE> v_neighbors = set ( g . neighbors ( v ) ) <NEWLINE> edge_to_jaccard [ ( u , v ) ] = float ( len ( u_neighbors & v_neighbors ) ) / len ( u_neighbors | v_neighbors ) <NEWLINE> return edge_to_jaccard <NEWLINE> <DEDENT>
def gammp ( a , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( x < 0.0 or a <= 0.0 ) : <NEWLINE> <INDENT> raise ValueError , ( a , x ) <NEWLINE> <DEDENT> if ( x < a + 1.0 ) : <NEWLINE> <INDENT> return gser ( a , x ) [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1. - gcf ( a , x ) [ 0 ] <NEWLINE> <DEDENT> <DEDENT>
class ProcessExecutionError ( IOError ) : <NEWLINE> <INDENT> def __init__ ( self , stdout = None , stderr = None , exit_code = None , cmd = None , <NEWLINE> <INDENT> description = None ) : <NEWLINE> self . exit_code = exit_code <NEWLINE> self . stderr = stderr <NEWLINE> self . stdout = stdout <NEWLINE> self . cmd = cmd <NEWLINE> self . description = description <NEWLINE> if description is None : <NEWLINE> description = _ ( <STRING> ) <NEWLINE> if exit_code is None : <NEWLINE> exit_code = <STRING> <NEWLINE> message = _ ( <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> ) % locals ( ) <NEWLINE> IOError . __init__ ( self , message ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def getDuration ( self ) : <NEWLINE> <INDENT> if self . entry . media is not None and self . entry . media . duration is not None <NEWLINE> <INDENT> return self . entry . media . duration . seconds <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT>
( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def _build_config ( self ) : <NEWLINE> <INDENT> with patch . object ( self . cert_obj , <STRING> , <NEWLINE> <INDENT> return_value = { } ) as mock_build_instance : <NEWLINE> result = self . cert_obj . build_config ( ) <NEWLINE> self . assertTrue ( mock_build_instance . called ) <NEWLINE> self . assertEqual ( result [ <STRING> ] [ <STRING> ] [ 0 ] [ <STRING> ] , <NEWLINE> <INDENT> <STRING> ) <NEWLINE> self . assertEqual ( result [ <STRING> ] [ <STRING> ] [ 0 ] [ <STRING> ] , <NEWLINE> <STRING> ) <NEWLINE> return result <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class ExtraTreeRegressor ( DecisionTreeRegressor ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , criterion = <STRING> , <NEWLINE> <INDENT> max_depth = None , <NEWLINE> min_samples_split = 1 , <NEWLINE> min_samples_leaf = 1 , <NEWLINE> min_density = 0.1 , <NEWLINE> max_features = <STRING> , <NEWLINE> compute_importances = False , <NEWLINE> random_state = None ) : <NEWLINE> super ( ExtraTreeRegressor , self ) . __init__ ( criterion , <NEWLINE> <INDENT> max_depth , <NEWLINE> min_samples_split , <NEWLINE> min_samples_leaf , <NEWLINE> min_density , <NEWLINE> max_features , <NEWLINE> compute_importances , <NEWLINE> random_state ) <NEWLINE> self . find_split_ = _tree . TREE_SPLIT_RANDOM <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def recommendDruidMaxMemoryLimitConfigurations ( self , configurations , clusterData , services , hosts ) : <NEWLINE> <INDENT> putEnvPropertyAttribute = self . putPropertyAttribute ( configurations , <STRING> ) <NEWLINE> for component in [ <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ] : <NEWLINE> component_hosts = self . getHostsWithComponent ( <STRING> , component , services , hosts ) <NEWLINE> if component_hosts is not None and len ( component_hosts ) > 0 : <NEWLINE> totalAvailableMem = self . getMinMemory ( component_hosts ) / 1024 <NEWLINE> nodeType = self . DRUID_COMPONENT_NODE_TYPE_MAP [ component ] <NEWLINE> putEnvPropertyAttribute ( format ( <STRING> ) , <STRING> , <NEWLINE> <INDENT> max ( totalAvailableMem , 1024 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def median ( m , axis = 0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if numpy . ma . isMA ( m ) : <NEWLINE> <INDENT> raise TypeError , <STRING> % type ( m ) . __name__ <NEWLINE> <DEDENT> m = numpy . asarray ( m , numpy . float ) <NEWLINE> m = numpy . transpose ( m , [ axis ] + range ( axis ) + range ( axis + 1 , numpy . rank ( m ) ) ) <NEWLINE> return numpy . median ( m ) <NEWLINE> <DEDENT>
def test_port_rule_masking ( self ) : <NEWLINE> <INDENT> if ( inspect . isclass ( self . expected ) <NEWLINE> <INDENT> and issubclass ( self . expected , Exception ) ) : <NEWLINE> with testtools . ExpectedException ( self . expected ) : <NEWLINE> utils . port_rule_masking ( self . port_min , self . port_max ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rules = utils . port_rule_masking ( self . port_min , self . port_max ) <NEWLINE> self . assertItemsEqual ( self . expected , rules ) <NEWLINE> <DEDENT> <DEDENT>
def endElement ( self , name ) : <NEWLINE> <INDENT> if name == <STRING> : <NEWLINE> <INDENT> self . in_context = False <NEWLINE> self . sentences . append ( ( self . lexelt , <NEWLINE> <INDENT> self . head_count , <NEWLINE> self . cur_sentence , <NEWLINE> self . instance_id ) <NEWLINE> <DEDENT> <DEDENT> if name == <STRING> : <NEWLINE> <INDENT> self . cur_sentence += <STRING> <NEWLINE> <DEDENT> <DEDENT>
def home ( ) <NEWLINE> <INDENT> <STRING> <NEWLINE> return render_template ( <STRING> ) <NEWLINE> <DEDENT>
def send_req ( host , port , req ) : <NEWLINE> <INDENT> sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) <NEWLINE> print ( <STRING> % ( host , port ) ) <NEWLINE> sock . connect ( ( host , port ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> sock . send ( req ) <NEWLINE> print ( <STRING> ) <NEWLINE> rbuf = sock . recv ( 1024 ) <NEWLINE> resp = <STRING> <NEWLINE> while len ( rbuf ) : <NEWLINE> resp = resp + rbuf <NEWLINE> rbuf = sock . recv ( 1024 ) <NEWLINE> print ( <STRING> ) <NEWLINE> sock . close ( ) <NEWLINE> return resp <NEWLINE> <DEDENT>
from oslo_log import log as logging <NEWLINE> from cinder . backup import driver <NEWLINE> from cinder . tests . unit . backup import fake_service <NEWLINE> LOG = logging . getLogger ( __name__ ) <NEWLINE> class FakeBackupServiceWithVerify ( driver . BackupDriverWithVerify , <NEWLINE> <INDENT> fake_service . FakeBackupService ) : <NEWLINE> def verify ( self , backup ) : <NEWLINE> pass <NEWLINE> <DEDENT>
def from_crawler ( cls , crawler ) : <NEWLINE> <INDENT> return cls ( <NEWLINE> <INDENT> mongo_uri = MONGO_URI , <NEWLINE> mongo_db = <STRING> <NEWLINE> image_dir = os . path . join ( PROJECT_DIR , <STRING> ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def get_namespace ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if len ( self . __namespaces ) != 1 : <NEWLINE> <INDENT> raise ValueError , <STRING> <NEWLINE> <DEDENT> return self . __namespaces [ 0 ] <NEWLINE> <DEDENT>
def get_pixmap ( self , cat , value ) : <NEWLINE> <INDENT> pix = None <NEWLINE> if cat == <STRING> : <NEWLINE> <INDENT> pix = STATE_PIX . get ( value , None ) <NEWLINE> <DEDENT> elif cat == <STRING> : <NEWLINE> <INDENT> pix = TRACKER_PIX . get ( value , None ) <NEWLINE> <DEDENT> if pix : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return GdkPixbuf . Pixbuf . new_from_file ( deluge . common . get_pixmap ( <STRING> % pix ) ) <NEWLINE> <DEDENT> except GError , e : <NEWLINE> <INDENT> log . warning ( e ) <NEWLINE> <DEDENT> <DEDENT> return self . get_transparent_pix ( 16 , 16 ) <NEWLINE> <DEDENT>
class ResourceManagementClientConfiguration ( AzureConfiguration ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( <NEWLINE> <INDENT> self , credentials , subscription_id , base_url = None ) : <NEWLINE> if credentials is None : <NEWLINE> raise ValueError ( <STRING> ) <NEWLINE> if subscription_id is None : <NEWLINE> raise ValueError ( <STRING> ) <NEWLINE> if not base_url : <NEWLINE> base_url = <STRING> <NEWLINE> super ( ResourceManagementClientConfiguration , self ) . __init__ ( base_url ) <NEWLINE> self . add_user_agent ( <STRING> . format ( VERSION ) ) <NEWLINE> self . add_user_agent ( <STRING> ) <NEWLINE> self . credentials = credentials <NEWLINE> self . subscription_id = subscription_id <NEWLINE> <DEDENT> <DEDENT>
class TaskWorkArea ( object ) : <NEWLINE> <INDENT> def __init__ ( self , taskTab : [ ] Task ) : <NEWLINE> <INDENT> self . taskTab = taskTab <NEWLINE> let self . taskList : Task = None <NEWLINE> let self . holdCount : int = 0 <NEWLINE> let self . qpktCount : int = 0 <NEWLINE> <DEDENT> <DEDENT>
def initGui ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> icon_path = <STRING> <NEWLINE> self . add_action ( <NEWLINE> <INDENT> icon_path , <NEWLINE> text = self . tr ( <STRING> ) , <NEWLINE> callback = self . run , <NEWLINE> parent = self . iface . mainWindow ( ) <NEWLINE> <DEDENT> self . dlg . toolButton . clicked . connect ( self . selectFile ) <NEWLINE> self . dlg . testButton . clicked . connect ( self . testConnection ) <NEWLINE> <DEDENT>
def draw ( self , dc , gc , ( x , y ) ) : <NEWLINE> <INDENT> x = x + self . get_width ( ) <NEWLINE> self . children . reverse ( ) <NEWLINE> for child in self . children : <NEWLINE> <INDENT> x = x - child . get_width ( ) <NEWLINE> child . draw ( dc , gc , ( x , y ) ) <NEWLINE> <DEDENT> self . children . reverse ( ) <NEWLINE> <DEDENT>
def process_response ( self , request , response ) : <NEWLINE> <INDENT> if ( self . sts_seconds and request . is_secure ( ) and <NEWLINE> <INDENT> <STRING> not in response ) : <NEWLINE> sts_header = <STRING> % self . sts_seconds <NEWLINE> if self . sts_include_subdomains : <NEWLINE> sts_header = sts_header + <STRING> <NEWLINE> response [ <STRING> ] = sts_header <NEWLINE> <DEDENT> if self . content_type_nosniff and <STRING> not in response : <NEWLINE> <INDENT> response [ <STRING> ] = <STRING> <NEWLINE> <DEDENT> if self . xss_filter and <STRING> not in response : <NEWLINE> <INDENT> response [ <STRING> ] = <STRING> <NEWLINE> <DEDENT> return response <NEWLINE> <DEDENT>
class Faction : <NEWLINE> <INDENT> def __init__ ( self , name , ascendancy , manufacturing , research , culture , speed , m_node , r_node , c_node , defense , attack ) : <NEWLINE> <INDENT> self . name = name <NEWLINE> self . ascendancy = ascendancy <NEWLINE> self . manufacturing = manufacturing <NEWLINE> self . research = research <NEWLINE> self . culture = culture <NEWLINE> self . speed = speed <NEWLINE> self . m_node = m_node <NEWLINE> self . r_node = r_node <NEWLINE> self . c_node = c_node <NEWLINE> self . defense = defense <NEWLINE> self . attack = attack <NEWLINE> <DEDENT> def show_stats ( self ) : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
class HTTPForbidden ( HTTPClientError ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> code = 403 <NEWLINE> title = <STRING> <NEWLINE> explanation = ( <STRING> ) <NEWLINE> def __init__ ( self , detail = None , headers = None , comment = None , <NEWLINE> <INDENT> body_template = None , result = None , ** kw ) : <NEWLINE> HTTPClientError . __init__ ( self , detail = detail , headers = headers , <NEWLINE> <INDENT> comment = comment , body_template = body_template , <NEWLINE> ** kw ) <NEWLINE> self . result = result <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def __init__ ( self , handler = None ) : <NEWLINE> <INDENT> self . fkiss_started = 0 <NEWLINE> self . event = None <NEWLINE> <INDENT> self . actions = [ ] <NEWLINE> <DEDENT> self . setindex = - 1 <NEWLINE> <INDENT> self . handler = handler <NEWLINE> <DEDENT> <DEDENT>
def testBootTimeNonExistantFile ( self ) : <NEWLINE> <INDENT> with MonkeyPatchScope ( [ ( sampling , <STRING> , <NEWLINE> <INDENT> <STRING> ) ] ) : <NEWLINE> with self . assertRaises ( IOError ) : <NEWLINE> sampling . getBootTime ( ) <NEWLINE> <DEDENT> <DEDENT>
def close ( self ) : <NEWLINE> <INDENT> if DEBUG : print self . _address , <STRING> <NEWLINE> if not self . _closed : <NEWLINE> <INDENT> self . connection_lost ( self . _socket ) <NEWLINE> self . _socket . close ( ) <NEWLINE> <DEDENT> <DEDENT>
def is_arbiter_master_selected ( self ) : <NEWLINE> <INDENT> if self . dbg : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> return self . arbiter_selected is not None <NEWLINE> <DEDENT>
def _prepare_to_process ( self , options , args , tool ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . state = self . _prepare_state ( options , args , tool ) <NEWLINE> <DEDENT> except ScriptError , e : <NEWLINE> <INDENT> _log . error ( e . message_with_output ( ) ) <NEWLINE> self . _exit ( e . exit_code or 2 ) <NEWLINE> <DEDENT> self . _prepare_sequence . run_and_handle_errors ( tool , options , self . state ) <NEWLINE> <DEDENT>
class DatasetValidationShuffleSplit ( DatasetCV ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , dataset , n_iter = 10 , test_size = 0.1 , valid_size = None , <NEWLINE> <INDENT> train_size = None , random_state = None , ** kwargs ) : <NEWLINE> n = dataset . get_num_examples ( ) <NEWLINE> cv = ValidationShuffleSplit ( n , n_iter , test_size , valid_size , <NEWLINE> <INDENT> train_size , random_state ) <NEWLINE> super ( DatasetValidationShuffleSplit , self ) . __init__ ( dataset , cv , <NEWLINE> <INDENT> ** kwargs ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def setUp ( self ) : <NEWLINE> <INDENT> super ( AntlrJavaGenTest , self ) . setUp ( ) <NEWLINE> for ver in self . VERSIONS : <NEWLINE> <INDENT> self . create_file ( <NEWLINE> <INDENT> relpath = <STRING> . format ( version = ver , ** self . PARTS ) , <NEWLINE> contents = dedent ( <STRING> . format ( ** self . PARTS ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_user_config_path ( * args ) : <NEWLINE> <INDENT> if sys . platform == <STRING> : <NEWLINE> <INDENT> return win32_get_app_data_path ( * args ) <NEWLINE> <DEDENT> config_home = os . environ . get ( <NEWLINE> <INDENT> <STRING> , os . path . join ( os . path . expanduser ( <STRING> ) , <STRING> ) ) ) <NEWLINE> <DEDENT> return os . path . join ( config_home , * args ) <NEWLINE> <DEDENT>
def EndMapping ( self , top_value , mapping ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> mapping . value . CheckInitialized ( ) <NEWLINE> <DEDENT> except validation . ValidationError : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> error_str = str ( e ) <NEWLINE> <DEDENT> except Exception : <NEWLINE> <INDENT> error_str = <STRING> <NEWLINE> <DEDENT> raise validation . ValidationError ( <STRING> % error_str , e ) <NEWLINE> <DEDENT> <DEDENT>
class HandlerA ( object ) <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> def __call__ ( self , packet ) : <NEWLINE> <INDENT> print ( <STRING> . format ( packet ) ) <NEWLINE> <DEDENT> <DEDENT>
def __ds_activity_record_changed ( self , event ) <NEWLINE> <INDENT> self . _revalidate_activities ( ) <NEWLINE> self . _revalidate_links ( ) <NEWLINE> <DEDENT>
def __getMovieTitle ( sHtmlContent ) : <NEWLINE> <INDENT> sPattern = <STRING> <NEWLINE> oParser = cParser ( ) <NEWLINE> aResult = oParser . parse ( sHtmlContent , sPattern ) <NEWLINE> if ( aResult [ 0 ] == True ) : <NEWLINE> return cUtil ( ) . removeHtmlTags ( str ( aResult [ 1 ] [ 0 ] ) ) <NEWLINE> return False <NEWLINE> <DEDENT>
def get_nvml ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if platform . system ( ) == <STRING> : <NEWLINE> <INDENT> return get_library ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for name in ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ) : <NEWLINE> nvml = get_library ( name ) <NEWLINE> if nvml is not None : <NEWLINE> return nvml <NEWLINE> <DEDENT> <DEDENT> return None <NEWLINE> <DEDENT>
def defineCharacteristics ( self ) : <NEWLINE> <INDENT> self . name = <STRING> <NEWLINE> self . group = <STRING> <NEWLINE> self . addParameter ( ParameterRaster ( SplitRGBBands . INPUT , <STRING> , <NEWLINE> <INDENT> False ) ) <NEWLINE> <DEDENT> self . addOutput ( OutputRaster ( SplitRGBBands . R , <STRING> ) ) <NEWLINE> self . addOutput ( OutputRaster ( SplitRGBBands . G , <STRING> ) ) <NEWLINE> self . addOutput ( OutputRaster ( SplitRGBBands . B , <STRING> ) <NEWLINE> <DEDENT>
def upgrade ( ) : <NEWLINE> <INDENT> op . add_column ( <STRING> , sa . Column ( <STRING> , sa . Boolean ( ) , nullable = True ) <NEWLINE> op . create_index ( <STRING> , <STRING> , [ <STRING> , <STRING> ] , unique = True ) <NEWLINE> op . drop_constraint ( <STRING> , <STRING> , type_ = <STRING> ) <NEWLINE> <DEDENT>
class AutoRestResourceFlatteningTestServiceConfiguration ( AzureConfiguration ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( <NEWLINE> <INDENT> self , credentials , base_url = None ) : <NEWLINE> if credentials is None : <NEWLINE> raise ValueError ( <STRING> ) <NEWLINE> if not base_url : <NEWLINE> base_url = <STRING> <NEWLINE> super ( AutoRestResourceFlatteningTestServiceConfiguration , self ) . __init__ ( base_url ) <NEWLINE> self . add_user_agent ( <STRING> . format ( VERSION ) ) <NEWLINE> self . add_user_agent ( <STRING> ) <NEWLINE> self . credentials = credentials <NEWLINE> <DEDENT> <DEDENT>
def get_outputs ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> o = [ ] <NEWLINE> for type , x , v in self . outputs : <NEWLINE> <INDENT> if type == <STRING> : <NEWLINE> <INDENT> addr = x <NEWLINE> <DEDENT> elif type == <STRING> : <NEWLINE> <INDENT> addr = public_key_to_bc_address ( x . decode ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> addr = <STRING> + x . encode ( <STRING> ) <NEWLINE> <DEDENT> o . append ( ( addr , v ) ) <NEWLINE> <DEDENT> return o <NEWLINE> <DEDENT>
def affected ( self , source , sites ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> source_sites = list ( self ( [ source ] , sites ) <NEWLINE> if source_sites : <NEWLINE> <INDENT> return source_sites [ 0 ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT>
def xml ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if <STRING> not in self . mimetype : <NEWLINE> <INDENT> raise AttributeError ( <NEWLINE> <INDENT> <STRING> <NEWLINE> % self . mimetype ) <NEWLINE> <DEDENT> <DEDENT> for module in [ <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ] : <NEWLINE> etree = import_string ( module , silent = True ) <NEWLINE> if etree is not None : <NEWLINE> return etree . XML ( self . body ) <NEWLINE> <DEDENT> raise RuntimeError ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def load ( np , typ , cfg ) : <NEWLINE> <INDENT> if typ == <STRING> : <NEWLINE> sink = NP_RDS ( np ) <NEWLINE> elif typ == <STRING> : <NEWLINE> sink = NP_Icecast ( np ) <NEWLINE> elif typ == <STRING> : <NEWLINE> sink = NP_Shoutcast ( np ) <NEWLINE> elif typ == <STRING> : <NEWLINE> sink = NP_FTP ( np ) <NEWLINE> elif typ == <STRING> : <NEWLINE> sink = NP_UDP ( np ) <NEWLINE> elif typ == <STRING> : <NEWLINE> sink = NP_CSV ( np ) <NEWLINE> else : <NEWLINE> raise Exception , <STRING> % ( typ , ) <NEWLINE> sink . config ( cfg ) <NEWLINE> return sink <NEWLINE> <DEDENT>
def _configure ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> Component . _configure ( self ) <NEWLINE> self . label ( self . inventory . label ) <NEWLINE> <DEDENT> except ValueError , err : <NEWLINE> <INDENT> aliases = <STRING> . join ( self . aliases ) <NEWLINE> raise ValueError ( <STRING> <NEWLINE> <INDENT> <STRING> % ( aliases , err . message ) ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <DEDENT>
def create_workset_request ( message ) : <NEWLINE> <INDENT> workseturi = handlers [ <STRING> ] ( message , <STRING> ) <NEWLINE> if workseturi : <NEWLINE> print ( <STRING> , workseturi ) <NEWLINE> emit ( <STRING> , workseturi ) <NEWLINE> else : <NEWLINE> emit ( <STRING> ) <NEWLINE> <DEDENT>
def _make_app ( ) <NEWLINE> <INDENT> <STRING> <NEWLINE> return <NEWLINE> <DEDENT>
def draw_button ( self , txt , icon , key ) : <NEWLINE> <INDENT> button = gtk . Button ( ) <NEWLINE> <INDENT> button . connect ( <STRING> , self . callback , key ) <NEWLINE> <DEDENT> h_pixbuf = gtk . gdk . pixbuf_new_from_file ( ICON + <STRING> ) <NEWLINE> p_pixbuf = gtk . gdk . pixbuf_new_from_file ( ICON + <STRING> ) <NEWLINE> button . set_size_request ( h_pixbuf . get_width ( ) , h_pixbuf . get_height ( ) ) <NEWLINE> button . connect ( <STRING> , self . expose_tab , txt , icon , h_pixbuf , p_pixbuf , key , self . get_id ) <NEWLINE> return button <NEWLINE> <DEDENT>
def test_017_disconnect_output_not_connected ( self ) : <NEWLINE> <INDENT> hblock = gr . hier_block2 ( <STRING> , <NEWLINE> <INDENT> gr . io_signature ( 1 , 1 , gr . sizeof_int ) , <NEWLINE> gr . io_signature ( 1 , 1 , gr . sizeof_int ) ) <NEWLINE> <DEDENT> nop1 = blocks . nop ( gr . sizeof_int ) <NEWLINE> <INDENT> nop2 = blocks . nop ( gr . sizeof_int ) <NEWLINE> <DEDENT> hblock . connect ( nop1 , hblock ) <NEWLINE> <INDENT> self . assertRaises ( ValueError , <NEWLINE> <INDENT> lambda : hblock . disconnect ( nop2 , hblock ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_database_url_additional_args ( self ) : <NEWLINE> <INDENT> def mock_database_url_caster ( self , url , engine = None ) : <NEWLINE> <INDENT> return { <STRING> : url , <STRING> : engine } <NEWLINE> <DEDENT> with patch ( <STRING> , <NEWLINE> <INDENT> mock_database_url_caster ) : <NEWLINE> value = DatabaseURLValue ( <NEWLINE> engine = <STRING> ) <NEWLINE> with env ( DATABASE_URL = <STRING> ) : <NEWLINE> self . assertEqual ( value . setup ( <STRING> ) , { <NEWLINE> <INDENT> <STRING> : { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> <DEDENT> } <NEWLINE> } ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def fixup ( dir ) : <NEWLINE> <INDENT> for root , dirs , files in os . walk ( dir ) : <NEWLINE> for f in files : <NEWLINE> <INDENT> if f . endswith ( <STRING> ) : <NEWLINE> <DEDENT> path = <STRING> % ( root , f ) <NEWLINE> fix_hdr ( path ) <NEWLINE> <DEDENT>
def test_set_device_status_mismatch ( self ) : <NEWLINE> <INDENT> with mock . patch ( <STRING> <NEWLINE> <INDENT> <STRING> , <NEWLINE> return_value = self . ASSIGNED_MAC ) , mock . patch ( <STRING> <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> with mock . patch ( <STRING> <NEWLINE> <INDENT> <STRING> ) as log_mock : <NEWLINE> self . eswitch_mgr . set_device_state ( self . WRONG_MAC , <NEWLINE> <INDENT> self . PCI_SLOT , True ) <NEWLINE> log_mock . assert_called_with ( <STRING> <NEWLINE> <STRING> , <NEWLINE> { <STRING> : self . PCI_SLOT , <NEWLINE> <STRING> : self . WRONG_MAC } ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
class Term ( BaseAccounting ) : <NEWLINE> <INDENT> def to_dict ( self ) : <NEWLINE> <INDENT> if self . obj == None : <NEWLINE> return { } <NEWLINE> return { <NEWLINE> <INDENT> <STRING> : self . obj . GetName ( ) . decode ( GC_ENC ) , <NEWLINE> <STRING> : self . obj . GetDescription ( ) . decode ( GC_ENC ) , <NEWLINE> <STRING> : self . obj . GetDueDays ( ) , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> <DEDENT>
def sendtoBh_sock ( self , data ) : <NEWLINE> <INDENT> client_socket = socket . socket ( socket . AF_UNIX , socket . SOCK_STREAM ) <NEWLINE> client_socket . connect ( <STRING> ) <NEWLINE> client_socket . send ( data ) <NEWLINE> <INDENT> client_socket . close ( ) <NEWLINE> <DEDENT> <DEDENT>
def _listing_iter ( self , account_name , lcontainer , lprefix , req ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> for page in self . _listing_pages_iter ( account_name , lcontainer , <NEWLINE> <INDENT> lprefix , req . environ ) : <NEWLINE> for item in page : <NEWLINE> yield item <NEWLINE> <DEDENT> <DEDENT> except ListingIterNotFound : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> except HTTPPreconditionFailed : <NEWLINE> <INDENT> raise HTTPPreconditionFailed ( request = req ) <NEWLINE> <DEDENT> except ListingIterError : <NEWLINE> <INDENT> raise HTTPServerError ( request = req ) <NEWLINE> <DEDENT> <DEDENT>
def draw_bearing ( ( x , y ) , my_dict ) : <NEWLINE> <INDENT> drawCircle ( my_dict [ <STRING> ] / 2 , ( x , - y ) , my_dict [ <STRING> ] ) <NEWLINE> drawCircle ( my_dict [ <STRING> ] / 2 , ( x - my_dict [ <STRING> ] , - y ) , my_dict [ <STRING> ] ) <NEWLINE> drawCircle ( my_dict [ <STRING> ] / 2 , ( x + my_dict [ <STRING> ] , - y ) , my_dict [ <STRING> ] ) <NEWLINE> <DEDENT>
import re <NEWLINE> from utils import * <NEWLINE> Phase = enum ( WRAPPER_WAIT = 1 , SCRIPT_WAIT = 2 , TEMPLATES_WAIT = 3 , RUN_WAIT = 4 , DONE = 5 , GIVENUP = 6 ) <NEWLINE> template = <STRING> <NEWLINE> dirname = <STRING> <NEWLINE> env_ht = { } <NEWLINE> cloud = <STRING> <NEWLINE> is_done = lambda ( instance , public , status , port ) : ( status == <STRING> and not public . startswith ( <STRING> ) ) <NEWLINE> num_attempts = 10 <NEWLINE>
def _string_common ( cls , column , field_args , ** extra ) : <NEWLINE> <INDENT> if column . type . length : <NEWLINE> <INDENT> field_args [ <STRING> ] . append ( validators . Length ( max = column . type . length ) <NEWLINE> <DEDENT> <DEDENT>
class InvalidSeverityError ( ImportException ) : <NEWLINE> <INDENT> def __init__ ( self , * rest ) : <NEWLINE> ImportException . __init__ ( self , rest ) <NEWLINE> <DEDENT>
def testDepthwiseConv2DInputGrad ( self ) : <NEWLINE> <INDENT> for index , ( input_size , filter_size , output_size , stride , <NEWLINE> <INDENT> padding ) in enumerate ( CheckGradConfigsToTest ( ) ) : <NEWLINE> print ( <STRING> , index , <STRING> ) <NEWLINE> for use_gpu in [ True , False ] : <NEWLINE> self . _ConstructAndTestGradient ( input_size , <NEWLINE> <INDENT> filter_size , <NEWLINE> output_size , <NEWLINE> stride , <NEWLINE> padding , <NEWLINE> tf . float32 , <NEWLINE> test_input = True , <NEWLINE> use_gpu = use_gpu ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def coerce ( self , argument ) : <NEWLINE> <INDENT> for handles , handle in [ ( self . _is_string , self . _handle_string ) , <NEWLINE> <INDENT> ( self . _is_number , self . _pass_through ) , <NEWLINE> ( is_dict_like , self . _coerce_dict ) , <NEWLINE> ( is_list_like , self . _coerce_list ) , <NEWLINE> ( lambda arg : True , self . _to_string ) ] : <NEWLINE> if handles ( argument ) : <NEWLINE> return handle ( argument ) <NEWLINE> <DEDENT> <DEDENT>
def init_screen ( self ) : <NEWLINE> <INDENT> pygame . draw . rect ( self . screen , ( 154 , 255 , 154 ) , ( 0 , 0 , 640 , 480 ) , 0 ) <NEWLINE> myfont = pygame . font . SysFont ( <STRING> , 30 ) <NEWLINE> welcome = myfont . render ( <STRING> , 1 , ( 47 , 79 , 79 ) ) <NEWLINE> self . screen . blit ( welcome , ( 30 , 210 ) ) ) <NEWLINE> pygame . display . update ( ) <NEWLINE> <DEDENT>
def maxrss ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for name in ( <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> ) : <NEWLINE> mm = _VmB ( name ) <NEWLINE> if mm > 0 : <NEWLINE> return mm <NEWLINE> <DEDENT> mm = resource . getrusage ( resource . RUSAGE_SELF ) [ 2 ] <NEWLINE> if mm > 0 : <NEWLINE> <INDENT> if mm < ( 1024 ) ** 2 : <NEWLINE> <INDENT> mm = mm * 1024 <NEWLINE> <DEDENT> return mm <NEWLINE> <DEDENT> return 0.0 <NEWLINE> <DEDENT>
class DiscontigScannerGroup ( ScannerGroup ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def scan ( self , offset = 0 , maxlen = None ) : <NEWLINE> <INDENT> maxlen = maxlen or self . session . profile . get_constant ( <STRING> ) <NEWLINE> for ( start , _ , length ) in self . address_space . get_address_ranges ( <NEWLINE> <INDENT> offset , offset + maxlen ) : <NEWLINE> for match in super ( DiscontigScannerGroup , self ) . scan ( <NEWLINE> <INDENT> start , maxlen = length ) : <NEWLINE> <DEDENT> yield match <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>
def testGetPowerData_packageCollisionDifferent ( self ) : <NEWLINE> <INDENT> self . battery . _cache [ <STRING> ] = { <STRING> : <STRING> } <NEWLINE> with self . assertCall ( <NEWLINE> <INDENT> self . call . device . RunShellCommand ( <NEWLINE> <INDENT> [ <STRING> , <STRING> , <STRING> ] , <NEWLINE> check_return = True , large_output = True ) , <NEWLINE> <DEDENT> _DUMPSYS_OUTPUT ) : <NEWLINE> with self . assertRaises ( device_errors . CommandFailedError ) : <NEWLINE> self . battery . GetPowerData ( ) <NEWLINE> <DEDENT> <DEDENT>
def test_field_validation_error ( testapp ) : <NEWLINE> <INDENT> def always_fail ( value ) : <NEWLINE> <INDENT> raise ValidationError ( <STRING> ) <NEWLINE> <DEDENT> args = { <STRING> : fields . Field ( validate = always_fail ) } <NEWLINE> with testapp . test_request_context ( <STRING> , data = json . dumps ( { <STRING> : <STRING> } ) , <NEWLINE> <INDENT> content_type = <STRING> , method = <STRING> ) : <NEWLINE> with pytest . raises ( HTTPException ) as excinfo : <NEWLINE> parser . parse ( args , locations = ( <STRING> , ) ) <NEWLINE> <DEDENT> exc = excinfo . value <NEWLINE> assert exc . code == 422 <NEWLINE> <DEDENT>
def train ( self , labeled_data ) : <NEWLINE> <INDENT> self . feature_distribution = CounterMap ( ) <NEWLINE> labels = set ( ) <NEWLINE> for label , datum in labeled_data : <NEWLINE> <INDENT> labels . add ( label ) <NEWLINE> for feature in ngrams ( datum , 3 ) <NEWLINE> <INDENT> self . feature_distribution [ feature ] [ label ] += 1 <NEWLINE> <DEDENT> <DEDENT> for feature in self . feature_distribution . iterkeys ( ) : <NEWLINE> <INDENT> self . feature_distribution [ feature ] . default = 0.01 <NEWLINE> <DEDENT> self . feature_distribution . normalize ( ) <NEWLINE> self . feature_distribution . log ( ) <NEWLINE> <DEDENT>
def rename ( self , inner_path_before , inner_path_after ) : <NEWLINE> <INDENT> for retry in range ( 3 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> os . rename ( self . getPath ( inner_path_before ) , self . getPath ( inner_path_after ) ) <NEWLINE> err = None <NEWLINE> break <NEWLINE> <DEDENT> except Exception , err : <NEWLINE> <INDENT> self . log . error ( <STRING> % ( inner_path_before , err , retry ) ) <NEWLINE> time . sleep ( 0.1 + retry ) <NEWLINE> <DEDENT> <DEDENT> if err : <NEWLINE> <INDENT> raise err <NEWLINE> <DEDENT> <DEDENT>
class ReaderPosition ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , end = None , key = None , byte_offset = None , record_index = None , <NEWLINE> <INDENT> shuffle_position = None , concat_position = None ) : <NEWLINE> <STRING> <NEWLINE> self . end = end <NEWLINE> self . key = key <NEWLINE> self . byte_offset = byte_offset <NEWLINE> self . record_index = record_index <NEWLINE> self . shuffle_position = shuffle_position <NEWLINE> if concat_position is not None : <NEWLINE> assert isinstance ( concat_position , ConcatPosition ) <NEWLINE> self . concat_position = concat_position <NEWLINE> <DEDENT> <DEDENT>
def run_ofctl ( self , cmd , args ) : <NEWLINE> <INDENT> full_args = [ <STRING> , cmd , self . br_name ] + args <NEWLINE> try : <NEWLINE> <INDENT> return utils . execute ( full_args , root_helper = self . root_helper ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> LOG . error ( _ ( <STRING> ) , <NEWLINE> <INDENT> { <STRING> : full_args , <STRING> : e } ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def json_to_array ( string , dtype ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> return np . fromiter ( json . loads ( string ) , dtype ) <NEWLINE> <DEDENT> <DEDENT>
class LttreeSettings ( BasicUISettings ) : <NEWLINE> <INDENT> def __init__ ( self , <NEWLINE> <INDENT> user_bindings_x = None , <NEWLINE> user_bindings = None , <NEWLINE> order_method = <STRING> ) : <NEWLINE> BasicUISettings . __init__ ( self , <NEWLINE> <INDENT> user_bindings_x , <NEWLINE> user_bindings , <NEWLINE> order_method ) <NEWLINE> self . column_names = [ ] <NEWLINE> self . ii_coords = [ ] <NEWLINE> self . ii_vects = [ ] <NEWLINE> self . i_atomid = None <NEWLINE> self . i_atomtype = None <NEWLINE> self . i_molid = None <NEWLINE> self . infile = None <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def macros ( lines ) : <NEWLINE> <INDENT> for line in string . split ( lines , <STRING> ) : <NEWLINE> <INDENT> if not re . match ( <STRING> , line ) : <NEWLINE> <INDENT> return_type , name , arg_types = extract_macro ( line ) <NEWLINE> if return_type : <NEWLINE> <DEDENT> <DEDENT> emit_redef ( return_type , name , arg_types ) <NEWLINE> <DEDENT>
def print_device_event ( device ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> global current_devices <NEWLINE> global observer <NEWLINE> global ser_port <NEWLINE> print ( list ( device . items ( ) ) ) <NEWLINE> if device . action == <STRING> : <NEWLINE> print ( <STRING> ) <NEWLINE> elif device . action == <STRING> : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> + str ( device . action ) ) <NEWLINE> if device . subsystem == <STRING> : <NEWLINE> print ( <STRING> + device [ <STRING> ] ) <NEWLINE> ser_port = device [ <STRING> ] <NEWLINE> observer . stop ( ) <NEWLINE> <DEDENT>
def process_request ( self , client , addr ) : <NEWLINE> <INDENT> client . setblocking ( 1 ) <NEWLINE> client . setsockopt ( socket . IPPROTO_TCP , socket . TCP_NODELAY , 1 ) <NEWLINE> flags = fcntl . fcntl ( client , fcntl . F_GETFD ) | fcntl . FD_CLOEXEC <NEWLINE> fcntl . fcntl ( client , fcntl . F_SETFD , flags ) <NEWLINE> self . server . socket = client <NEWLINE> try : <NEWLINE> <INDENT> self . server . process_request ( client , addr ) <NEWLINE> <DEDENT> except IOError , e : <NEWLINE> <INDENT> if e . errno != errno . EPIPE : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> <DEDENT> self . request_count += 1 <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> parser = ParseGLC ( 10 , 6 ) <NEWLINE> for d in parser . scraped_data : <NEWLINE> <INDENT> print ( <STRING> % ( d [ <STRING> ] , d [ <STRING> ] , d [ <STRING> ] ) <NEWLINE> <DEDENT> parser = ParseGLC ( 11 , 4 ) <NEWLINE> for d in parser . scraped_data : <NEWLINE> <INDENT> print ( <STRING> % ( d [ <STRING> ] , d [ <STRING> ] , d [ <STRING> ] ) ) <NEWLINE> <DEDENT> <DEDENT>
class Main : <NEWLINE> <INDENT> def __init__ ( self , dir , database = <STRING> ) : <NEWLINE> <INDENT> self . start_dir = os . getcwd ( ) <NEWLINE> self . dir = dir <NEWLINE> self . database = database <NEWLINE> <DEDENT> def main ( ) <NEWLINE> <INDENT> os . chdir ( self . dir ) <NEWLINE> self . database = database . init ( self . database ) <NEWLINE> template . init ( self . database ) <NEWLINE> <DEDENT> <DEDENT>
class MustCoupError ( Exception ) : <NEWLINE> <INDENT> def __init__ ( self , conn ) : <NEWLINE> self . conn = conn <NEWLINE> conn . sendall ( <STRING> ) <NEWLINE> <DEDENT>
def _refresh_view_trigger ( self change ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . refresh_view ( ) <NEWLINE> <DEDENT>
def ExportDynamicResults ( self , options = { } , progress = None ) : <NEWLINE> <INDENT> progupdate = None <NEWLINE> if progress is not None : progupdate = progress . Update <NEWLINE> oldoptions = self . _updateOptions ( options ) <NEWLINE> try : <NEWLINE> CallInternalPlugin ( EOFTPLUGIN_DYNAMICRESULTSEXPORT , self , progupdate ) <NEWLINE> CallUserPlugins ( EOFTPLUGIN_DYNAMICRESULTSEXPORT , progress , self , progupdate ) <NEWLINE> finally : <NEWLINE> <INDENT> if oldoptions is not None : <NEWLINE> <INDENT> self . options = oldoptions <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def apiRequest ( call ) : <NEWLINE> <INDENT> if Prefs [ <STRING> ] == True : Log ( <STRING> + call ) <NEWLINE> <INDENT> headers = { <STRING> : <STRING> + Prefs [ <STRING> ] } <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> req = urllib2 . Request ( call , None , headers ) <NEWLINE> response = urllib2 . urlopen ( req ) <NEWLINE> result = response . read ( ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> if Prefs [ <STRING> ] == True : Log ( <STRING> + str ( e ) ) <NEWLINE> return False <NEWLINE> <INDENT> return result <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def _build_mails_response ( self , ( mails , total ) ) : <NEWLINE> <INDENT> return { <NEWLINE> <INDENT> <STRING> : { <NEWLINE> <INDENT> <STRING> : total , <NEWLINE> <DEDENT> } , <NEWLINE> <STRING> : [ mail . as_dict ( ) for mail in mails ] <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>
def histogram ( self , mask = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . load ( ) <NEWLINE> if mask : <NEWLINE> mask . load ( ) <NEWLINE> return self . im . histogram ( mask . im ) <NEWLINE> return self . im . histogram ( ) <NEWLINE> <DEDENT>
def _new_packet_cb ( self , pk ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if pk . channel == READ_CHANNEL or pk . channel == WRITE_CHANNEL : <NEWLINE> <INDENT> var_id = pk . data [ 0 ] <NEWLINE> if ( pk . channel != TOC_CHANNEL and self . _req_param == var_id and <NEWLINE> <INDENT> pk is not None ) : <NEWLINE> self . updated_callback ( pk ) <NEWLINE> self . _req_param = - 1 <NEWLINE> try : <NEWLINE> self . wait_lock . release ( ) <NEWLINE> except : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def packetReceived ( self , command , payload2 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if command != <STRING> and not self . connected2 : <NEWLINE> <INDENT> raise PeerMisbehavingError ( <STRING> ) <NEWLINE> <DEDENT> p2protocol . Protocol . packetReceived ( self , command , payload2 ) <NEWLINE> <DEDENT> except PeerMisbehavingError , e : <NEWLINE> <INDENT> print ( <STRING> % self . addr , e . message ) <NEWLINE> self . badPeerHappened ( ) <NEWLINE> <DEDENT> <DEDENT>
def _resolveReferences ( self , flatdb ) : <NEWLINE> <INDENT> for element in flatdb . keys ( ) : <NEWLINE> <INDENT> for attribute in flatdb [ element ] . keys ( ) : <NEWLINE> val = flatdb [ element ] [ attribute ] <NEWLINE> if isinstance ( val , basestring ) : <NEWLINE> <INDENT> if flatdb . has_key ( val ) : <NEWLINE> <DEDENT> flatdb [ element ] [ attribute ] = flatdb [ val ] <NEWLINE> <DEDENT> return flatdb <NEWLINE> <DEDENT>
def _do_find ( self ) : <NEWLINE> <INDENT> self . _cached_attributes = dict ( ) <NEWLINE> for fn in [ self . _probe_jetdirect , <NEWLINE> <INDENT> self . _probe_ipp , <NEWLINE> self . _probe_snmp , <NEWLINE> self . _probe_lpd , <NEWLINE> self . _probe_hplip , <NEWLINE> self . _probe_smb ] : <NEWLINE> if self . quit : <NEWLINE> return <NEWLINE> try : <NEWLINE> fn ( ) <NEWLINE> except Exception : <NEWLINE> nonfatalException ( ) <NEWLINE> <DEDENT> if not self . quit : <NEWLINE> <INDENT> self . callback_fn ( None ) <NEWLINE> <DEDENT> <DEDENT>
def on_connect ( client , userdata , flags , rc ) : <NEWLINE> <INDENT> print ( <STRING> + str ( rc ) ) <NEWLINE> <INDENT> client . subscribe ( <STRING> ) <NEWLINE> <DEDENT> client . subscribe ( <STRING> ) <NEWLINE> client . subscribe ( <STRING> ) <NEWLINE> <DEDENT>
def _get_down_payment ( self , data , context = None ) : <NEWLINE> <INDENT> cr = self . cr <NEWLINE> res = 0.0 <NEWLINE> target_data = { <STRING> : data . billing_type , <NEWLINE> <INDENT> <STRING> : data . billing_extra_amount , <NEWLINE> <STRING> : data . billing_months , <NEWLINE> <STRING> : data . amount_total } <NEWLINE> <DEDENT> temp_bank = [ <NEWLINE> <INDENT> ( [ <STRING> , <STRING> ] , <STRING> ) , <NEWLINE> ( [ <STRING> ] , <STRING> ) , <NEWLINE> ] <NEWLINE> <DEDENT> for target_types , str_result in temp_bank : <NEWLINE> <INDENT> if target_data [ <STRING> ] in target_types : <NEWLINE> <INDENT> exec str_result <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <DEDENT>
class Simple_tenant_usage ( extensions . ExtensionDescriptor ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> name = <STRING> <NEWLINE> alias = <STRING> <NEWLINE> namespace = ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> updated = <STRING> <NEWLINE> def get_resources ( self ) : <NEWLINE> <INDENT> resources = [ ] <NEWLINE> res = extensions . ResourceExtension ( <STRING> , <NEWLINE> <INDENT> SimpleTenantUsageController ( ) <NEWLINE> <DEDENT> resources . append ( res ) <NEWLINE> return resources <NEWLINE> <DEDENT> <DEDENT>
def _capture_device_settings ( self , clip , track , args ) : <NEWLINE> <INDENT> dev_range = self . _get_device_range ( args , track ) <NEWLINE> if dev_range : <NEWLINE> <INDENT> for dev_index in range ( dev_range [ 0 ] , dev_range [ 1 ] ) : <NEWLINE> if dev_index < ( len ( track . devices ) ) : <NEWLINE> <INDENT> current_device = track . devices [ dev_index ] <NEWLINE> for p in current_device . parameters : <NEWLINE> <DEDENT> self . _insert_envelope ( clip , p ) <NEWLINE> <INDENT> if current_device . can_have_chains : <NEWLINE> <DEDENT> self . _capture_nested_devices ( clip , current_device ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , line ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . values = line . split ( <STRING> ) <NEWLINE> self . chromosome = self . values [ 0 ] <NEWLINE> if self . isHitSNP ( self . values [ 1 ] ) <NEWLINE> <INDENT> self . hit_snp = True <NEWLINE> self . hit_allele = strip ( self . values [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . hit_snp = False <NEWLINE> self . hit_allele = None <NEWLINE> <DEDENT> self . position = int ( self . values [ 3 ] ) <NEWLINE> <DEDENT>
def formatException ( self , ( E , e , tb ) ) : <NEWLINE> <INDENT> if conf . supybot . log . stdout . colorized ( ) : <NEWLINE> <INDENT> return <STRING> . join ( [ ansi . RED , <NEWLINE> <INDENT> Formatter . formatException ( self , ( E , e , tb ) ) , <NEWLINE> ansi . RESET ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return Formatter . formatException ( self , ( E , e , tb ) ) <NEWLINE> <DEDENT> <DEDENT>
def test_scan_with_existent_ns_and_set ( self ) : <NEWLINE> <INDENT> ns = <STRING> <NEWLINE> st = <STRING> <NEWLINE> records = [ ] <NEWLINE> scan_obj = None <NEWLINE> def callback ( ( key , meta , bins ) ) : <NEWLINE> <INDENT> records . append ( bins ) <NEWLINE> <DEDENT> scan_obj = self . client . scan ( ns , st ) <NEWLINE> scan_obj . foreach ( callback ) <NEWLINE> assert len ( records ) != 0 <NEWLINE> <DEDENT>
def whoosh_index ( app , model ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not hasattr ( app , <STRING> ) : <NEWLINE> <INDENT> app . whoosh_indexes = { } <NEWLINE> <DEDENT> return app . whoosh_indexes . get ( model . __name__ , <NEWLINE> <INDENT> _create_index ( app , model ) <NEWLINE> <DEDENT> <DEDENT>
def test_getParameterNames_python_function_doesnt_have_parameters ( self ) : <NEWLINE> <INDENT> functionName = <STRING> <NEWLINE> fileDir = path . join ( os . sep , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> expected = [ ] <NEWLINE> <INDENT> obj = self . _getInstance ( ) <NEWLINE> parameterNames = obj . _getParameterNames ( functionName , fileDir ) <NEWLINE> self . assertEqual ( expected , parameterNames ) <NEWLINE> <DEDENT> <DEDENT>
def get_connection ( self ) : <NEWLINE> <INDENT> self . _config_boto_timeout ( self . connection_timeout , self . num_retries ) <NEWLINE> if not all ( ( self . connection_data [ <STRING> ] , <NEWLINE> <INDENT> self . connection_data [ <STRING> ] ) ) : <NEWLINE> if all ( self . ks_cred . itervalues ( ) ) : <NEWLINE> ec2_cred = self . _keystone_aws_get ( ) <NEWLINE> self . connection_data [ <STRING> ] = ec2_cred . access <NEWLINE> self . connection_data [ <STRING> ] = ec2_cred . secret <NEWLINE> else : <NEWLINE> raise exceptions . InvalidConfiguration ( <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return self . connect_method ( ** self . connection_data ) <NEWLINE> <DEDENT>
def follows ( curs ) : <NEWLINE> <INDENT> l = set ( [ ] ) <NEWLINE> for c in curs . execute ( <STRING> ) : <NEWLINE> <INDENT> l . add ( c ) <NEWLINE> if len ( l ) < 10 or len ( l ) % 10000 == 0 : print <STRING> . format ( len ( l ) ) <NEWLINE> <DEDENT> return l <NEWLINE> <DEDENT>
import sys <NEWLINE> if len ( sys . argv ) < 2 or len ( sys . argv [ 1 ] ) < 2 : print <STRING> <NEWLINE> my_moves , opp_moves = sys . argv [ 1 ] , sys . argv [ 2 ] <NEWLINE> moves = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> history = zip ( [ moves . index ( i ) for i in my_moves ] , <NEWLINE> <INDENT> [ moves . index ( i ) for i in opp_moves ] ) <NEWLINE> <DEDENT>
def analyzeAPIFiles ( top ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> cur = top . children <NEWLINE> while cur != None : <NEWLINE> <INDENT> if cur . type == <STRING> : <NEWLINE> cur = cur . next <NEWLINE> continue <NEWLINE> if cur . name == <STRING> : <NEWLINE> count = count + analyzeAPIFile ( cur ) <NEWLINE> else : <NEWLINE> print ( <STRING> % ( cur . name ) ) <NEWLINE> cur = cur . next <NEWLINE> <DEDENT> return count <NEWLINE> <DEDENT>
def has_excessive_failures ( self ) : <NEWLINE> <INDENT> if ( self . failures . first_failure_time is not None and <NEWLINE> <INDENT> self . disable_hard_timeout ) : <NEWLINE> if ( time . time ( ) >= self . failures . first_failure_time + <NEWLINE> <INDENT> self . disable_hard_timeout ) : <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT> if self . failures . num_failures ( ) >= self . disable_failures : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
def make_client ( port , host ) : <NEWLINE> <INDENT> uri = <STRING> <NEWLINE> framed = False <NEWLINE> http = False <NEWLINE> if http : <NEWLINE> <INDENT> transport = THttpClient . THttpClient ( host , port , uri ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> socket = TSocket . TSocket ( host , port ) <NEWLINE> if framed : <NEWLINE> transport = TTransport . TFramedTransport ( socket ) <NEWLINE> else : <NEWLINE> transport = TTransport . TBufferedTransport ( socket ) <NEWLINE> <DEDENT> protocol = TBinaryProtocol . TBinaryProtocol ( transport ) <NEWLINE> client = LarkService . Client ( protocol ) <NEWLINE> transport . open ( ) <NEWLINE> return client <NEWLINE> <DEDENT>
def nice_output ( digits , volts ) : <NEWLINE> <INDENT> sys . stdout . write ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> <DEDENT>
def __add__ ( self , ( ox , oy , oz ) ) : <NEWLINE> <INDENT> sx , sy , sz = self <NEWLINE> return self . __class__ ( sx + ox , sy + oy , sz + oz ) <NEWLINE> <DEDENT>
def _call ( self , method , params ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> return self . conns [ self . curr_conn ] . _call ( method , params ) <NEWLINE> except : <NEWLINE> self . next_connection ( ) <NEWLINE> <DEDENT> <DEDENT>
def install ( self , seedKey , seedEntry ) : <NEWLINE> <INDENT> sanitizedKey = seedKey . hash <NEWLINE> logging . debug ( <STRING> <NEWLINE> <INDENT> dict ( key = seedKey , sanitized = sanitizedKey ) ) <NEWLINE> <DEDENT> self . _storeCode ( sanitizedKey , seedEntry [ <STRING> ] ) <NEWLINE> self . _storeManifest ( sanitizedKey , { <STRING> : seedEntry [ <STRING> ] , <STRING> : seedKey . __repr__ ( ) } ) <NEWLINE> <DEDENT>
def get ( self , request , pk ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> odlc = find_odlc ( request , int ( pk ) <NEWLINE> <DEDENT> except Odlc . DoesNotExist : <NEWLINE> <INDENT> return HttpResponseNotFound ( <STRING> % pk ) <NEWLINE> <DEDENT> except ValueError as e : <NEWLINE> <INDENT> return HttpResponseForbidden ( str ( e ) ) <NEWLINE> <DEDENT> if not odlc . thumbnail . name : <NEWLINE> <INDENT> return HttpResponseNotFound ( <STRING> % pk ) <NEWLINE> <DEDENT> return sendfile ( request , odlc . thumbnail . path ) <NEWLINE> <DEDENT>
def refreshSecondWidgets ( self ) : <NEWLINE> <INDENT> self . wprocessus . LoadInfoProcess ( ) <NEWLINE> <INDENT> self . wmodules . LoadInfoModules ( ) <NEWLINE> <DEDENT> <DEDENT>
def test_end ( passed ) : <NEWLINE> <INDENT> if passed : <NEWLINE> sys . stdout . write ( <STRING> ) <NEWLINE> else : <NEWLINE> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT>
def delImage ( self , label ) : <NEWLINE> <INDENT> for config in self . images : <NEWLINE> if string . lower ( config . getEntry ( <STRING> ) ) == string . lower ( label ) : <NEWLINE> <INDENT> self . images . remove ( config ) <NEWLINE> return <NEWLINE> raise IndexError , <STRING> % ( label , ) <NEWLINE> <DEDENT> <DEDENT>
def put ( self , metric_id ) : <NEWLINE> <INDENT> obj = { <STRING> : metric_id , <STRING> : datetime . utcnow ( ) } <NEWLINE> for arg in [ <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> <STRING> ] : <NEWLINE> value = request . form . get ( arg , None ) <NEWLINE> if value : <NEWLINE> obj [ arg ] = value <NEWLINE> <DEDENT> self . mongo . db . metric . save ( obj ) <NEWLINE> return obj , 201 <NEWLINE> <DEDENT>
def _parse_headers ( file ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> def parse ( ( headers , last ) , line ) : <NEWLINE> <INDENT> if <STRING> in line : last , value = map ( string . strip , line . split ( <STRING> , 1 ) ) <NEWLINE> else : value = line . strip ( ) <NEWLINE> headers [ last ] += value <NEWLINE> return headers , last <NEWLINE> <DEDENT> return reduce ( parse , file . read ( ) . split ( <STRING> ) , ( defaultdict ( str ) , <STRING> ) ) [ 0 ] <NEWLINE> <DEDENT> <DEDENT>
def force ( self , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> p = self . p <NEWLINE> Lc = self . lc <NEWLINE> T = self . t <NEWLINE> k = 0.138 <NEWLINE> Ec = ( k * T ) / ( 4.0 * p ) <NEWLINE> return Ec * ( ( ( 1. - ( x / Lc ) ) ** - 2 ) - 1 + ( 4 * x / Lc ) <NEWLINE> <DEDENT>
def isConnected ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return bool ( self . connection and self . connection . isConnected ( ) <NEWLINE> <DEDENT>
def _run_info_handler ( self , args , screen_info = None ) : <NEWLINE> <INDENT> output = debugger_cli_common . RichTextLines ( [ ] ) <NEWLINE> if self . _run_call_count == 1 : <NEWLINE> <INDENT> output . extend ( cli_shared . get_tfdbg_logo ( ) ) <NEWLINE> <DEDENT> output . extend ( self . _run_info ) <NEWLINE> if ( not self . _is_run_start and <NEWLINE> <INDENT> debugger_cli_common . MAIN_MENU_KEY in output . annotations ) : <NEWLINE> menu = output . annotations [ debugger_cli_common . MAIN_MENU_KEY ] <NEWLINE> if <STRING> not in menu . captions ( ) : <NEWLINE> menu . insert ( <NEWLINE> <INDENT> 0 , debugger_cli_common . MenuItem ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> return output <NEWLINE> <DEDENT>
( data [ <STRING> ] <NEWLINE> plt . figure ( ) <NEWLINE> plt . bar ( open_credit_freq . keys ( ) , open_credit_freq . values ( ) , width = 1 ) <NEWLINE> plt . show ( ) <NEWLINE> chi_redux = { } <NEWLINE> for k in open_credit_freq : <NEWLINE> <INDENT> if open_credit_freq [ k ] >= 5 : <NEWLINE> <INDENT> chi_redux [ k ] = open_credit_freq [ k ] <NEWLINE> <DEDENT> <DEDENT> chi , p = stats . chisquare ( chi_redux . values ( ) ) <NEWLINE> print ( chi ) <NEWLINE> print ( p ) <NEWLINE>
def rename_unicode_files ( path ) : <NEWLINE> <INDENT> files = [ ] <NEWLINE> for name in os . listdir ( path ) : <NEWLINE> <INDENT> if os . path . isfile ( os . path . join ( path , name ) ) : <NEWLINE> <INDENT> files . append ( name ) <NEWLINE> for f in files : <NEWLINE> <DEDENT> <DEDENT> try : <NEWLINE> <INDENT> os . rename ( path + f , path + urllib . unquote_plus ( f ) . decode ( <STRING> ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> xbmc . log ( <STRING> + f ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> sys . argv = bjam . variable ( <STRING> ) <NEWLINE> if <STRING> in sys . argv : <NEWLINE> <INDENT> import cProfile <NEWLINE> r = cProfile . runctx ( <STRING> , globals ( ) , locals ( ) , <STRING> ) <NEWLINE> import pstats <NEWLINE> stats = pstats . Stats ( <STRING> ) <NEWLINE> stats . strip_dirs ( ) <NEWLINE> stats . sort_stats ( <STRING> , <STRING> ) <NEWLINE> stats . print_callers ( 20 ) <NEWLINE> return r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return main_real ( ) <NEWLINE> <DEDENT> except ExceptionWithUserContext , e : <NEWLINE> <INDENT> e . report ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_snippets ( self ) : <NEWLINE> <INDENT> for input , output , kind in ( ( exec_tests , exec_results , <STRING> ) , <NEWLINE> <INDENT> ( single_tests , single_results , <STRING> ) , <NEWLINE> ( eval_tests , eval_results , <STRING> ) ) : <NEWLINE> for i , o in zip ( input , output ) : <NEWLINE> ast_tree = compile ( i , <STRING> , kind , ast . PyCF_ONLY_AST ) <NEWLINE> self . assertEqual ( to_tuple ( ast_tree ) , o ) <NEWLINE> self . _assertTrueorder ( ast_tree , ( 0 , 0 ) ) <NEWLINE> <DEDENT> <DEDENT>
class SubformField ( Field ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , formclass = None , label = None , can_delete = True , can_order = False , <NEWLINE> <INDENT> * args , ** kwargs ) : <NEWLINE> if formclass is not None : <NEWLINE> self . formclass = formclass <NEWLINE> if label is not None : <NEWLINE> self . form_label = label <NEWLINE> self . can_delete = can_delete <NEWLINE> self . can_order = can_order <NEWLINE> super ( SubformField , self ) . __init__ ( * args , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT>
def testShouldNotDeleteCookiesWithASimilarName ( cookie , driver , webserver ) <NEWLINE> <INDENT> cookie2 = cookie . copy ( ) <NEWLINE> cookie2 [ <STRING> ] = <STRING> . format ( cookie [ <STRING> ] ) <NEWLINE> driver . add_cookie ( cookie ) <NEWLINE> driver . add_cookie ( cookie2 ) <NEWLINE> driver . delete_cookie ( cookie [ <STRING> ] ) <NEWLINE> cookies = driver . get_cookies ( ) <NEWLINE> assert cookie [ <STRING> ] != cookies [ 0 ] [ <STRING> ] <NEWLINE> assert cookie2 [ <STRING> ] == cookies [ 0 ] [ <STRING> ] <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import sys <NEWLINE> import os <NEWLINE> import re <NEWLINE> from os import makedirs , path <NEWLINE> from types import StringTypes <NEWLINE> from whoosh . index import create_in <NEWLINE> from whoosh . fields import * <NEWLINE> from whoosh import index <NEWLINE> from whoosh . index import open_dir <NEWLINE> from harvestman . apps . spider import HarvestMan <NEWLINE> from harvestman . lib . common . common import objects <NEWLINE> from sgmllib import SGMLParser <NEWLINE> spanreg = re . compile ( <STRING> ) <NEWLINE> def info ( S ) : print <STRING> , S <NEWLINE> def extrainfo ( S , T ) : <NEWLINE> <INDENT> print <STRING> , S , <STRING> , T <NEWLINE> <DEDENT>
def _rescale_data ( X , y , sample_weight ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> n_samples = X . shape [ 0 ] <NEWLINE> sample_weight = sample_weight * np . ones ( n_samples ) <NEWLINE> sample_weight = np . sqrt ( sample_weight ) <NEWLINE> sw_matrix = sparse . dia_matrix ( ( sample_weight , 0 ) <NEWLINE> <INDENT> shape = ( n_samples , n_samples ) ) <NEWLINE> <DEDENT> X = safe_sparse_dot ( sw_matrix , X ) <NEWLINE> y = safe_sparse_dot ( sw_matrix , y ) <NEWLINE> return X , y <NEWLINE> <DEDENT>
def __init__ ( self , default_path , user_path ) : <NEWLINE> <INDENT> self . _default_settings = ConfigObj ( default_path , unrepr = True ) <NEWLINE> self . _user_path = user_path <NEWLINE> try : <NEWLINE> <INDENT> self . _old_settings = ConfigObj ( user_path , unrepr = True ) <NEWLINE> <DEDENT> except UnreprError , err : <NEWLINE> <INDENT> raise ConfigurationError ( <STRING> % <NEWLINE> <INDENT> ( user_path , err ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class Functor : <NEWLINE> <INDENT> def __init__ ( self , fo , fa , src = None , tgt = None ) : <NEWLINE> self . fo = adapt_function ( fo ) <NEWLINE> self . fa = adapt_function ( fa ) <NEWLINE> self . src = src <NEWLINE> self . tgt = tgt <NEWLINE> <DEDENT>
def get_chain_selector ( self , device ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> result = None <NEWLINE> if device . class_name . endswith ( <STRING> ) : <NEWLINE> <INDENT> for parameter in device . parameters : <NEWLINE> if str ( parameter . original_name ) == <STRING> : <NEWLINE> <INDENT> result = parameter <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <DEDENT>
def BuildDirStructure ( featRootDir , dirs ) : <NEWLINE> <INDENT> curDir = os . getcwd ( ) <NEWLINE> os . chdir ( featRootDir ) <NEWLINE> for d in dirs : <NEWLINE> <INDENT> if not os . path . exists ( d ) : <NEWLINE> os . makedirs ( d ) <NEWLINE> os . chdir ( d ) <NEWLINE> <DEDENT> os . chdir ( curDir ) <NEWLINE> <DEDENT>
def getEnvelopeFromCenterXYLengthWidth ( x , y , length , width ) : <NEWLINE> <INDENT> halfWidth = width / 2.0 <NEWLINE> halfLength = length / 2.0 <NEWLINE> bounding = [ ] <NEWLINE> bounding . append ( getStringFromXY ( x - halfWidth , y + halfLength ) ) <NEWLINE> bounding . append ( getStringFromXY ( x - halfWidth , y - halfLength ) ) <NEWLINE> bounding . append ( getStringFromXY ( x + halfWidth , y - halfLength ) ) <NEWLINE> bounding . append ( getStringFromXY ( x + halfWidth , y + halfLength ) <NEWLINE> return bounding <NEWLINE> <DEDENT>
def lookup_compression ( method ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> cmd , ext = COMPRESSION_METHODS [ method ] <NEWLINE> argv = shlex . split ( cmd ) <NEWLINE> try : <NEWLINE> <INDENT> return [ which . which ( argv [ 0 ] ) ] + argv [ 1 : ] , ext <NEWLINE> <DEDENT> except which . WhichError , e : <NEWLINE> <INDENT> raise OSError ( <STRING> % <NEWLINE> <INDENT> method ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except KeyError : <NEWLINE> <INDENT> raise OSError ( <STRING> % method ) <NEWLINE> <DEDENT> <DEDENT>
def execute ( version , command , arguments , data = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with subprocess . Popen ( ( command , ) + arguments , <NEWLINE> <INDENT> stdin = subprocess . PIPE , <NEWLINE> stdout = subprocess . PIPE , <NEWLINE> stderr = subprocess . STDOUT ) as p : <NEWLINE> if data is None : <NEWLINE> out = p . communicate ( ) [ 0 ] <NEWLINE> else : <NEWLINE> out = p . communicate ( data . encode ( ) ) [ 0 ] <NEWLINE> return ( out , p . returncode ) <NEWLINE> <DEDENT> <DEDENT>
def get_case_parameters ( case_name , ** kwargs ) : <NEWLINE> <INDENT> global remote_data , data_dir , data_host , remote_server_auto , paraview_cmd <NEWLINE> _remote_dir = data_dir <NEWLINE> if <STRING> in kwargs : <NEWLINE> <INDENT> _remote_dir = kwargs [ <STRING> ] <NEWLINE> <DEDENT> _remote_host = data_host <NEWLINE> if <STRING> in kwargs : <NEWLINE> <INDENT> _remote_host = kwargs [ <STRING> ] <NEWLINE> <DEDENT> env . use_ssh_config = True <NEWLINE> env . host_string = _remote_host <NEWLINE> case_file_str = cat_case_file ( _remote_dir , case_name ) <NEWLINE> exec case_file_str <NEWLINE> return parameters <NEWLINE> <DEDENT>
def test_enrollments_for_course_id ( self ) : <NEWLINE> <INDENT> with self . settings ( <NEWLINE> <INDENT> RESTCLIENTS_CANVAS_DAO_CLASS = <STRING> ) : <NEWLINE> canvas = Enrollments ( ) <NEWLINE> enrollments = canvas . get_enrollments_for_course_by_sis_id ( <STRING> ) <NEWLINE> self . assertEquals ( len ( enrollments ) , 3 , <STRING> ) <NEWLINE> students = canvas . get_enrollments_for_course_by_sis_id ( <STRING> , <NEWLINE> <INDENT> { <STRING> : <STRING> } ) <NEWLINE> self . assertEquals ( len ( students ) , 2 , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def getObjectHistory ( self , request ) : <NEWLINE> <INDENT> if isinstance ( request , getObjectHistoryRequest ) is False : <NEWLINE> <INDENT> raise TypeError , <STRING> % ( request . __class__ ) <NEWLINE> <DEDENT> kw = { } <NEWLINE> self . binding . Send ( None , None , request , soapaction = <STRING> , encodingStyle = <STRING> , ** kw ) <NEWLINE> typecode = Struct ( pname = None , ofwhat = getObjectHistoryResponse . typecode . ofwhat , pyclass = getObjectHistoryResponse . typecode . pyclass ) <NEWLINE> response = self . binding . Receive ( typecode ) <NEWLINE> return response <NEWLINE> <DEDENT>
def new_figure_manager ( num , * args , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if _debug : <NEWLINE> <INDENT> print <STRING> % ( self . __class__ . __name__ , _fn_name ( ) ) <NEWLINE> <DEDENT> FigureClass = kwargs . pop ( <STRING> , Figure ) <NEWLINE> thisFig = FigureClass ( * args , ** kwargs ) <NEWLINE> canvas = FigureCanvasCairo ( thisFig ) <NEWLINE> manager = FigureManagerBase ( canvas , num ) <NEWLINE> return manager <NEWLINE> <DEDENT>
class EngineStrategyMetaBase ( ABCMeta ) : <NEWLINE> <INDENT> def __init__ ( cls , name , bases_classes , attributes ) : <NEWLINE> <INDENT> if hasattr ( cls , <STRING> ) : <NEWLINE> <INDENT> schema = cls . configuration_schema <NEWLINE> Draft4Validator . check_schema ( schema ) <NEWLINE> cls . __config_validator__ = build_validator ( schema , get_module_path ( cls ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_int_type_range ( type_id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if type_id . inst . op_name not in [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> raise ParseError ( <STRING> ) <NEWLINE> <DEDENT> bitwidth = type_id . inst . operands [ 0 ] <NEWLINE> assert bitwidth in [ 16 , 32 , 64 ] <NEWLINE> min_val = - ( 1 << ( bitwidth - 1 ) <NEWLINE> max_val = ( 1 << bitwidth ) - 1 <NEWLINE> if type_id . inst . op_name == <STRING> : <NEWLINE> <INDENT> min_val = 0 <NEWLINE> <DEDENT> return min_val , max_val <NEWLINE> <DEDENT>
class Command ( BaseCommand ) : <NEWLINE> <INDENT> help = <STRING> <NEWLINE> def handle ( self , * args , ** options ) : <NEWLINE> <INDENT> for plugin in get_preindex_plugins ( ) : <NEWLINE> <INDENT> print ( <STRING> . format ( plugin . app_label ) ) ) <NEWLINE> plugin . copy_designs ( temp = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class EtniaareasAdmin ( admin . ModelAdmin ) : <NEWLINE> <INDENT> def formfield_for_foreignkey ( self , db_field , request , ** kwargs ) : <NEWLINE> <INDENT> if db_field . name == <STRING> : <NEWLINE> <INDENT> kwargs [ <STRING> ] = User . objects . filter ( id = request . user . id ) <NEWLINE> <DEDENT> return super ( EtniaareasAdmin , self ) . formfield_for_foreignkey ( db_field , request , ** kwargs ) <NEWLINE> <DEDENT> class Media : <NEWLINE> js = ( <STRING> , <STRING> ) <NEWLINE> <DEDENT>
class ForumsPostsLikes ( db . Model ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> id = db . Column ( db . Integer , primary_key = True ) <NEWLINE> post_id = db . Column ( db . Integer , db . ForeignKey ( <STRING> ) <NEWLINE> user_id = db . Column ( db . Integer , db . ForeignKey ( <STRING> ) ) <NEWLINE> def __init__ ( self , post_id , user_id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . post_id = post_id <NEWLINE> self . user_id = user_id <NEWLINE> <DEDENT> <DEDENT>
def menu ( ) : <NEWLINE> <INDENT> __limpiar ( ) <NEWLINE> print ( <STRING> 0 33 [ 1 ) <NEWLINE> while True : <NEWLINE> <INDENT> d = raw_input ( <STRING> ) <NEWLINE> if d == <STRING> : <NEWLINE> <INDENT> subprocess . call ( [ <STRING> , <STRING> ] ) <NEWLINE> <DEDENT> if d == <STRING> : <NEWLINE> <INDENT> subprocess . call ( [ <STRING> , <STRING> ] ) <NEWLINE> <DEDENT> if d == <STRING> : <NEWLINE> <INDENT> subprocess . call ( [ <STRING> , <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test3_right ( self ) : <NEWLINE> <INDENT> self . t . set_align_mode ( <STRING> ) <NEWLINE> expected = [ B ( t ) for t in <STRING> , <STRING> ] <NEWLINE> got = self . t . render ( ( 18 , ) ) . _text <NEWLINE> assert got == expected , <STRING> % ( got , expected ) <NEWLINE> <DEDENT>
def _collect_slave_state ( self ) : <NEWLINE> <INDENT> result = self . _get ( <STRING> ) <NEWLINE> if not result : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for framework in result [ <STRING> ] : <NEWLINE> <INDENT> self . known_frameworks [ framework [ <STRING> ] ] = framework [ <STRING> ] <NEWLINE> <DEDENT> for key in [ <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> ] : <NEWLINE> value = result . get ( key ) <NEWLINE> if value is not None : <NEWLINE> self . publish ( key , value , precision = self . _precision ( value ) ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self ) : <NEWLINE> <INDENT> self . _attrs = { } <NEWLINE> <INDENT> self . _parser = expat . ParserCreate ( ) <NEWLINE> self . _parser . StartElementHandler = self . start <NEWLINE> self . _parser . EndElementHandler = self . end <NEWLINE> self . _parser . StartCdataSectionHandler = self . startCdata <NEWLINE> self . _parser . EndCdataSectionHandler = self . endCdata <NEWLINE> self . _parser . CharacterDataHandler = self . data <NEWLINE> <DEDENT> <DEDENT>
class Solution ( object ) : <NEWLINE> <INDENT> def printlist ( self , head ) : <NEWLINE> while head : <NEWLINE> <INDENT> print ( head . val ) <NEWLINE> head = head . next <NEWLINE> <DEDENT> def isHappy ( self , head ) : <NEWLINE> if not head : <NEWLINE> <INDENT> return head <NEWLINE> start = head <NEWLINE> nextnode = head . next <NEWLINE> start . next = None <NEWLINE> while nextnode : <NEWLINE> tmp = nextnode . next <NEWLINE> nextnode . next = start <NEWLINE> start = nextnode <NEWLINE> nextnode = tmp <NEWLINE> return start <NEWLINE> <DEDENT> <DEDENT>
def test_search_services_loading ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> error_messages = [ ] <NEWLINE> services_classes = [ str ( service . __class__ ) for service in get_search_services ( ) ] <NEWLINE> for expected_service_class in ( <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ) : <NEWLINE> if not expected_service_class in services_classes : <NEWLINE> error_messages . append ( <STRING> % expected_service_class ) <NEWLINE> <DEDENT> if error_messages : <NEWLINE> <INDENT> self . fail ( merge_error_messages ( error_messages ) + <STRING> % repr ( services_classes ) ) <NEWLINE> <DEDENT> <DEDENT>
class NpmRequirement ( PackageRequirement ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , package , version = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> PackageRequirement . __init__ ( self , <STRING> , package , version ) <NEWLINE> <DEDENT> def is_installed ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for cmd in ( [ <STRING> , <STRING> , self . package ] , <NEWLINE> <INDENT> [ <STRING> , <STRING> , <STRING> , self . package ] ) : <NEWLINE> if platform . system ( ) == <STRING> : <NEWLINE> cmd = [ <STRING> , <STRING> ] + cmd <NEWLINE> if not call_without_output ( cmd ) : <NEWLINE> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> <DEDENT>
class GetTopSharedEvents ( DailySharesBase ) : <NEWLINE> <INDENT> def __init__ ( self , <NEWLINE> <INDENT> date = None , <NEWLINE> count = 20 , <NEWLINE> returnInfo = ReturnInfo ( ) ) : <NEWLINE> QueryParamsBase . __init__ ( self ) <NEWLINE> self . _setVal ( <STRING> , <STRING> ) <NEWLINE> self . _setVal ( <STRING> , count ) <NEWLINE> self . _update ( returnInfo . getParams ( ) ) <NEWLINE> if date == None : <NEWLINE> date = datetime . date . today ( ) <NEWLINE> self . _setDateVal ( <STRING> , date ) <NEWLINE> <DEDENT> <DEDENT>
def tg_command_whoami ( bot , chat_id , args ) : <NEWLINE> <INDENT> user_id = args [ <STRING> ] <NEWLINE> chat_type = args [ <STRING> ] <NEWLINE> if <STRING> == chat_type : <NEWLINE> <INDENT> yield from bot . sendMessage ( chat_id , <STRING> . format ( user_id = user_id ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> yield from bot . sendMessage ( chat_id , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class DatasourceManager ( models . Manager ) : <NEWLINE> <INDENT> def cached ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> sources = cache . get ( SOURCES_CACHE_KEY ) <NEWLINE> if not sources : <NEWLINE> <INDENT> sources = list ( self . all ( ) <NEWLINE> cache . set ( SOURCES_CACHE_KEY , sources ) <NEWLINE> <DEDENT> return sources <NEWLINE> <DEDENT> <DEDENT>
def get_job ( self , jobid ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> job = self . client . getJob ( self . thread_local . request_context , jobid ) <NEWLINE> <DEDENT> except JobNotFoundException , e : <NEWLINE> <INDENT> raise StructuredException ( code = <STRING> , message = <STRING> % jobid . asString , data = jobid ) <NEWLINE> <DEDENT> self . _fixup_job ( job ) <NEWLINE> return job <NEWLINE> <DEDENT>
class ConnectionKey ( Connection ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , key , secure = True , host = None , port = None , url = None , <NEWLINE> <INDENT> timeout = None , proxy_url = None , backoff = None , retry_delay = None ) : <NEWLINE> <STRING> <NEWLINE> super ( ConnectionKey , self ) . __init__ ( secure = secure , host = host , <NEWLINE> <INDENT> port = port , url = url , <NEWLINE> timeout = timeout , <NEWLINE> proxy_url = proxy_url , <NEWLINE> backoff = backoff , <NEWLINE> retry_delay = retry_delay ) <NEWLINE> self . key = key <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from material . frontend import Module <NEWLINE> <INDENT> class Sample ( Module ) : <NEWLINE> <INDENT> icon = <STRING> <NEWLINE> <DEDENT> <DEDENT>
( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT> <DEDENT>
class Audit ( Model ) : <NEWLINE> <INDENT> def __init__ ( self , enabled , keep_files = 7 , rotate = <STRING> , <NEWLINE> <INDENT> events = None , restrictions = None ) : <NEWLINE> <STRING> <NEWLINE> self . _config = { <NEWLINE> <STRING> : enabled , <NEWLINE> <STRING> : keep_files , <NEWLINE> <STRING> : rotate <NEWLINE> } <NEWLINE> if events is not None : <NEWLINE> self . _config [ <STRING> ] = events <NEWLINE> if restrictions is not None : <NEWLINE> self . _config [ <STRING> ] = restrictions <NEWLINE> <DEDENT> <DEDENT>
def getAllEventForAllUser ( self ) : <NEWLINE> <INDENT> allUser = User . getAllUser ( ) <NEWLINE> allEvent = [ ] <NEWLINE> if allUser : <NEWLINE> <INDENT> for user in allUser : <NEWLINE> <INDENT> allEvent . append ( user ) <NEWLINE> <DEDENT> return allUser <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT>
class CAboutDlg ( CDialog ) : <NEWLINE> <INDENT> CAboutDlg ( ) <NEWLINE> enum IDD = IDD_ABOUTBOX <NEWLINE> DoDataExchange = virtual void ( CDataExchange * pDX ) <NEWLINE> DECLARE_MESSAGE_MAP ( ) <NEWLINE> <DEDENT>
def test_index_default_limit ( self ) : <NEWLINE> <INDENT> self . config ( limit_param_default = 1 , api_limit_max = 3 ) <NEWLINE> path = <STRING> <NEWLINE> request = unit_test_utils . get_fake_request ( path ) <NEWLINE> output = self . controller . index ( request ) <NEWLINE> actual = set ( [ task . task_id for task in output [ <STRING> ] ] ) <NEWLINE> self . assertEqual ( 1 , len ( actual ) <NEWLINE> <DEDENT>
def get ( self , url , data = None , headers = { } , type = None ) : <NEWLINE> <INDENT> req = None <NEWLINE> try : <NEWLINE> <INDENT> if self . AcceptTypes [ type ] : <NEWLINE> <INDENT> headers [ <STRING> ] = self . AcceptTypes [ type ] <NEWLINE> req = RequestWithMethod ( url , <STRING> , headers = headers ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> req = RequestWithMethod ( url , <STRING> , , headers = headers ) <NEWLINE> <DEDENT> return ( self . _query ( req ) ) <NEWLINE> <DEDENT>
def build_extra ( d ) : <NEWLINE> <INDENT> data_fields = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> if not isinstance ( d [ <STRING> ] , list ) : <NEWLINE> <INDENT> for k , v in d . items ( ) : <NEWLINE> <INDENT> d [ k ] = [ v ] <NEWLINE> <DEDENT> <DEDENT> col = dict ( filter ( lambda ( k , v ) : k in data_fields , d . items ( ) ) ) <NEWLINE> return col <NEWLINE> <DEDENT>
def default ( func , exception , deflt ) : <NEWLINE> <INDENT> try : <NEWLINE> return func ( ) <NEWLINE> except exception : <NEWLINE> return deflt <NEWLINE> <DEDENT>
( <STRING> . format ( ver , ( time . ctime ( endTime ) ) ) <NEWLINE>
def SummarizeUrl ( url , i = 5 ) : <NEWLINE> <INDENT> summaries = [ ] <NEWLINE> try : <NEWLINE> <INDENT> article = grab_link ( url ) <NEWLINE> <DEDENT> except IOError : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return None <NEWLINE> <DEDENT> if not ( article and article . cleaned_text and article . title ) : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> summaries = Summarize ( unicode ( article . title ) <NEWLINE> <INDENT> unicode ( article . cleaned_text ) , i ) <NEWLINE> <DEDENT> return summaries <NEWLINE> <DEDENT>
def final_action_state ( path ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if len ( path ) > 1 <NEWLINE> <INDENT> return path [ - 2 ] [ 0 ] , path [ - 1 ] <NEWLINE> <DEDENT> return None , path [ - 1 ] <NEWLINE> <DEDENT>
def get_history ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> history_file_name = self . _get_history_file_name ( ) <NEWLINE> if os . path . isfile ( history_file_name ) : <NEWLINE> <INDENT> with io . open ( history_file_name , <STRING> , <NEWLINE> <INDENT> encoding = <STRING> , errors = <STRING> ) as history : <NEWLINE> for line in history : <NEWLINE> prepared = self . _script_from_history ( line ) . strip ( ) <NEWLINE> if prepared : <NEWLINE> yield prepared <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
pvalue <NEWLINE> ) <NEWLINE>
def _check_simple_error ( ret , func , args ) : <NEWLINE> <INDENT> if ret == ReturnCode . ERROR : <NEWLINE> raise RuntimeError <NEWLINE> return ret <NEWLINE> <DEDENT>
def do_script ( self , attrs ) : <NEWLINE> <INDENT> baiceurl = self . baiceurl <NEWLINE> <INDENT> for name , value in attrs : <NEWLINE> <INDENT> if name == <STRING> and value not in self . urls : <NEWLINE> <INDENT> if value . startswith ( <STRING> ) : <NEWLINE> self . urls . append ( baiceurl + value ) <NEWLINE> else : <NEWLINE> if re . search ( <STRING> , value ) : <NEWLINE> <DEDENT> <DEDENT> self . urls . append ( value ) <NEWLINE> <INDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_copes_with_empty_path_component ( self ) : <NEWLINE> <INDENT> file_name = <STRING> <NEWLINE> response = self . client . get ( <STRING> % ( self . prefix , file_name ) ) <NEWLINE> response_content = <STRING> . join ( response ) <NEWLINE> with open ( path . join ( media_dir , file_name ) , <STRING> ) as fp <NEWLINE> <INDENT> self . assertEqual ( fp . read ( ) , response_content ) <NEWLINE> <DEDENT> <DEDENT>
def adjust_loop_end ( self , clip , track , xclip , ident , args ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> args = args . strip ( ) <NEWLINE> if args . startswith ( ( <STRING> , <STRING> ) ) : <NEWLINE> <INDENT> factor = self . _parent . get_adjustment_factor ( args , True ) <NEWLINE> clip . loop_end = max ( ( clip . loop_start - factor ) , ( clip . loop_end + factor ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> clip . loop_end = float ( args ) <NEWLINE> except : pass <NEWLINE> <DEDENT> <DEDENT>
def __get_file_docstrings ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> file_lines = self . __get_file_lines ( ) <NEWLINE> file_docstrings = file_lines . map ( <NEWLINE> <INDENT> lambda ( ( repo_name , file_path ) , file_lines ) : get_docstring ( ( ( repo_name , file_path ) , file_lines ) ) <NEWLINE> <DEDENT> ) <NEWLINE> return file_docstrings <NEWLINE> <DEDENT>
def __iter__ ( self ) <NEWLINE> <INDENT> self . ind = - 1 <NEWLINE> self . a = len ( self . data ) <NEWLINE> self . b = len ( self . data [ 0 ] . keys ( ) ) <NEWLINE> self . c = len ( self . data [ 0 ] [ self . data [ 0 ] . keys ( ) [ 0 ] ] ) <NEWLINE> return ( self ) <NEWLINE> <DEDENT>
def _get_next_friendly_id ( conn , event_id ) : <NEWLINE> <INDENT> cur = conn . execute ( <STRING> , ( event_id , ) <NEWLINE> return cur . fetchone ( ) [ 0 ] <NEWLINE> <DEDENT>
def save ( self ) : <NEWLINE> <INDENT> if not self . filename : <NEWLINE> <INDENT> self . filename = QtGui . QFileDialog . getSaveFileName ( self , <STRING> ) <NEWLINE> <DEDENT> if self . filename : <NEWLINE> <INDENT> if not str ( self . filename ) . endswith ( <STRING> ) : <NEWLINE> <INDENT> self . filename += <STRING> <NEWLINE> <DEDENT> with open ( self . filename , <STRING> ) as file : <NEWLINE> <INDENT> file . write ( self . text . toHtml ( ) <NEWLINE> <DEDENT> self . changesSaved = True <NEWLINE> <DEDENT> <DEDENT>
def _assert_comments_service_called_without_group_id ( self , mock_request ) : <NEWLINE> <INDENT> self . assertTrue ( mock_request . called ) <NEWLINE> self . assertNotIn ( <STRING> , self . _data_or_params_cs_request ( mock_request ) <NEWLINE> <DEDENT>
def obj_delete ( self , request = None , ** kwargs ) : <NEWLINE> <INDENT> internalDataStore = self . get_internal_datastore ( request ) <NEWLINE> key = self . get_key ( request ) <NEWLINE> if internalDataStore is not None and key is not None : <NEWLINE> <INDENT> internalDataStore . saveAnswer ( { <STRING> : key , <STRING> : [ ] if self . _meta . isList else { } ) <NEWLINE> <DEDENT> <DEDENT>
class WaitingListDelete ( threading . Thread ) : <NEWLINE> <INDENT> def __init__ ( self , waitingid ) : <NEWLINE> <INDENT> self . waitingid = waitingid <NEWLINE> threading . Thread . __init__ ( self ) <NEWLINE> <DEDENT> def run ( self ) : <NEWLINE> data = urllib . urlencode ( { <STRING> : self . waitingid } ) <NEWLINE> request = urllib2 . Request ( <STRING> , data , headers = { <STRING> : <STRING> } ) <NEWLINE> http_file = urllib2 . urlopen ( request , timeout = 30 ) . read ( ) <NEWLINE> response = json . loads ( http_file ) <NEWLINE> print ( response ) <NEWLINE> <DEDENT>
class hr_employee ( orm . Model ) : <NEWLINE> <INDENT> _name = <STRING> <NEWLINE> _inherit = <STRING> <NEWLINE> infraction_ids = fields . One2many ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> readonly = True <NEWLINE> ) <NEWLINE> infraction_action_ids = fields . One2many ( <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> readonly = True <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT>
def insert_row ( self , query , params ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . cursor . execute ( query , params ) <NEWLINE> <DEDENT> self . connection . commit ( ) <NEWLINE> except : <NEWLINE> <INDENT> self . connection . rollback ( ) <NEWLINE> <DEDENT> <DEDENT>
def allocate_primaryIPS ( self , domains ) : <NEWLINE> <INDENT> log . info ( <STRING> ) <NEWLINE> for net , domain in self . network_for_domains ( self . unallocated_ip_base , <NEWLINE> <INDENT> domains , <NEWLINE> max_prefixlen = self <NEWLINE> . max_alloc_prefixlen ) : <NEWLINE> hosts = net . hosts ( ) <NEWLINE> for intf in domain : <NEWLINE> ip = str ( next ( hosts ) ) <NEWLINE> intf . setIP ( ip , prefixLen = net . prefixlen ) <NEWLINE> <DEDENT> <DEDENT>
def get_atoms ( pdb_file ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> parser = PDBParser ( ) <NEWLINE> structure = parser . get_structure ( pdb_file [ : - 4 ] , pdb_file ) <NEWLINE> atms = structure . get_atoms ( ) <NEWLINE> atoms = [ ] <NEWLINE> for a in atms : <NEWLINE> atoms . append ( a . get_name ( ) ) <NEWLINE> if len ( atoms ) == 0 : <NEWLINE> print ( <STRING> ) <NEWLINE> raise NoProtError ( <STRING> ) <NEWLINE> return atoms <NEWLINE> <DEDENT>
def directViewUi ( self ) : <NEWLINE> <INDENT> exec <STRING> <NEWLINE> exec <STRING> <NEWLINE> self . directView = directView ( self ) <NEWLINE> self . setCentralWidget ( self . directView ) <NEWLINE> self . VLCPlayer = VLCPlayer ( ) <NEWLINE> self . directView . horizontalLayout . insertWidget ( 0 , self . VLCPlayer ) <NEWLINE> self . directView . verticalLayout1 . setAlignment ( QtCore . Qt . AlignTop ) <NEWLINE> self . directView . verticalLayout2 . setAlignment ( QtCore . Qt . AlignTop ) <NEWLINE> <DEDENT>
def printErrors ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> , self . subsystemName ) <NEWLINE> print ( <STRING> , self . baseDir ) <NEWLINE> for err in self . errors : <NEWLINE> <INDENT> if self . duplicatedErrors . count ( err . getNumber ( ) ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> print ( <STRING> , err . getNumber ( ) ) <NEWLINE> print ( <STRING> , err . getName ( ) ) <NEWLINE> print ( <STRING> , err . getFile ( ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for err in self . errors : <NEWLINE> <INDENT> err . printError ( ) <NEWLINE> <DEDENT> <DEDENT>
def cutype ( type ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> from compiler . parsetypes import T , type_from_text <NEWLINE> if isinstance ( type , str ) : <NEWLINE> <INDENT> type = type_from_text ( type ) <NEWLINE> <DEDENT> elif not isinstance ( type , T . Type ) : <NEWLINE> <INDENT> raise TypeError , <STRING> % type <NEWLINE> <DEDENT> def setter ( fn ) : <NEWLINE> <INDENT> fn . cu_type = type <NEWLINE> return fn <NEWLINE> <DEDENT> return setter <NEWLINE> <DEDENT>
def load_additional_args ( self , config ) : <NEWLINE> <INDENT> GPIO . setmode ( GPIO . BCM ) <NEWLINE> GPIO . setwarnings ( False ) <NEWLINE> outpins = self . config_get ( config , <STRING> , <STRING> ) <NEWLINE> inpins = self . config_get ( config , <STRING> , <STRING> ) <NEWLINE> for pins , mode in ( ( outpins , GPIO . OUT ) , <NEWLINE> <INDENT> ( inpins , GPIO . IN ) ) : <NEWLINE> for pin in pins : <NEWLINE> GPIO . setup ( pin , mode ) <NEWLINE> <DEDENT> <DEDENT>
from . fields import FIELD_NO_INPUT <NEWLINE> def run_all ( rule_list , <NEWLINE> <INDENT> defined_variables , <NEWLINE> defined_actions , <NEWLINE> stop_on_first_trigger = False ) : <NEWLINE> rule_was_triggered = False <NEWLINE> for rule in rule_list : <NEWLINE> result = run ( rule , defined_variables , defined_actions ) <NEWLINE> if result : <NEWLINE> rule_was_triggered = True <NEWLINE> if stop_on_first_trigger : <NEWLINE> <INDENT> return True <NEWLINE> return rule_was_triggered <NEWLINE> <DEDENT> <DEDENT>
def OnPaint ( self , evt ) : <NEWLINE> <INDENT> dc = self . __getClientDC ( ) <NEWLINE> <INDENT> self . doPaint ( dc ) <NEWLINE> <DEDENT> evt . Skip ( ) <NEWLINE> <DEDENT>
def _apply_battery_charge_thresholds ( self ) : <NEWLINE> <INDENT> start_threshold , stop_threshold = [ spin_box . value ( ) for spin_box in <NEWLINE> <INDENT> self . _form . start_threshold_spin_box , <NEWLINE> self . _form . stop_threshold_spin_box <NEWLINE> ] <NEWLINE> <DEDENT> self . _set_battery_charge_threshold ( start_threshold , stop_threshold ) <NEWLINE> <DEDENT>
def testAsserCalls_succeeds_withAction ( self ) : <NEWLINE> <INDENT> with self . assertCall ( <NEWLINE> <INDENT> self . call . adb . Shell ( <STRING> ) , self . ShellError ( ) ) : <NEWLINE> with self . assertRaises ( ValueError ) : <NEWLINE> self . adb . Shell ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def InputDialog ( ) : <NEWLINE> <INDENT> d = MyDialog ( root ) <NEWLINE> <INDENT> root . wait_window ( d . top ) <NEWLINE> <DEDENT> strinfo = d . name + str ( d . age ) <NEWLINE> <INDENT> tkMessageBox . showinfo ( <STRING> , strinfo ) <NEWLINE> <DEDENT> <DEDENT>
def main ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> while 1 : <NEWLINE> <INDENT> self . process ( ) <NEWLINE> <DEDENT> <DEDENT> except KeyboardInterrupt : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> l = sorted ( self . hash . iteritems ( ) , key = lambda ( k , v ) : ( v , k ) ) <NEWLINE> for hash , value in l : <NEWLINE> <INDENT> print ( <STRING> % ( hash , value ) ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class Question ( models . Model ) : <NEWLINE> <INDENT> question_text = models . CharField ( max_length = 200 ) <NEWLINE> pub_date = models . DateTimeField ( <STRING> ) <NEWLINE> def __str__ ( self ) : <NEWLINE> return self . question_text <NEWLINE> def was_published_recently ( self ) : <NEWLINE> <INDENT> now = timezone . now ( ) <NEWLINE> return now - datetime . timedelta ( days = 1 ) <= self . pub_date <= now <NEWLINE> <DEDENT> <DEDENT>
def read_file_into_string ( filename ) : <NEWLINE> <INDENT> path = os . path . abspath ( os . path . dirname ( __file__ ) ) ) <NEWLINE> filepath = os . path . join ( path , filename ) <NEWLINE> try : <NEWLINE> <INDENT> return open ( filepath ) . read ( ) <NEWLINE> <DEDENT> except IOError : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT>
def decompose ( C ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return cholesky ( C ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> return modified_cholesky ( C ) <NEWLINE> <DEDENT> <DEDENT>
def gradient ( self , l ) : <NEWLINE> <INDENT> return numpy . array ( [ <NEWLINE> <INDENT> numpy . ones ( len ( l ) , float ) <NEWLINE> <DEDENT> ] + sum ( <NEWLINE> <INDENT> ( list ( gaussian . gradient ( l ) ) ) for gaussian in self . gaussians ) <NEWLINE> <DEDENT> , [ ] ) ) <NEWLINE> <DEDENT>
def test_chunkcoding ( self ) : <NEWLINE> <INDENT> for native , utf8 in zip ( * [ StringIO ( f ) . readlines ( ) <NEWLINE> <INDENT> for f in self . tstring ] ) : <NEWLINE> u = self . decode ( native ) [ 0 ] <NEWLINE> self . assertEqual ( u , utf8 . decode ( <STRING> ) ) <NEWLINE> if self . roundtriptest : <NEWLINE> self . assertEqual ( native , self . encode ( u ) [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT>
def do_generate_modified_query_string ( parser , token ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> tag_name , key , value = token . split_contents ( ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> return GetStringNode ( ) <NEWLINE> <DEDENT> if not ( key [ 0 ] == key [ - 1 ] and key [ 0 ] in ( <STRING> , <STRING> ) ) : <NEWLINE> <INDENT> raise template . TemplateSyntaxError , <STRING> % tag_name <NEWLINE> <DEDENT> return GetStringNode ( key [ 1 : - 1 ] , value ) <NEWLINE> <DEDENT>
def row_to_dict ( x ) : <NEWLINE> <INDENT> return { <NEWLINE> <INDENT> <STRING> : x [ 0 ] , <NEWLINE> <STRING> : x [ 1 ] , <NEWLINE> <STRING> : x [ 2 ] , <NEWLINE> <STRING> : x [ 3 ] <NEWLINE> <STRING> : x [ 4 ] , <NEWLINE> <STRING> : x [ 5 ] , <NEWLINE> <STRING> : x [ 6 ] , <NEWLINE> <STRING> : x [ 7 ] <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>
def _setelement ( self , s ) : <NEWLINE> <INDENT> s = string . lower ( s ) <NEWLINE> try : <NEWLINE> <INDENT> self . element = PeriodicTable [ s ] <NEWLINE> <DEDENT> except KeyError , x : <NEWLINE> <INDENT> print ( <STRING> , x ) <NEWLINE> <DEDENT> <DEDENT>
def log ( iterator ) : <NEWLINE> <INDENT> for val in iterator : <NEWLINE> <INDENT> time . sleep ( 60 ) <NEWLINE> <INDENT> print ( val ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def input ( self , entry , key ) : <NEWLINE> <INDENT> if entry . aux . match ( key ) : <NEWLINE> <INDENT> self . value = key <NEWLINE> self . close ( ) <NEWLINE> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( _ ( <STRING> ) <NEWLINE> <INDENT> <STRING> ) % key <NEWLINE> <DEDENT> return NormalTUISpoke . input ( self , entry , key ) <NEWLINE> <DEDENT> <DEDENT>
def test_dim_check_fail ( arr ) : <NEWLINE> <INDENT> from pybind11_tests . array import ( index_at , index_at_t , offset_at , offset_at_t , data , data_t , <NEWLINE> <INDENT> mutate_data , mutate_data_t ) <NEWLINE> <DEDENT> for func in ( index_at , index_at_t , offset_at , offset_at_t , data , data_t , <NEWLINE> <INDENT> mutate_data , mutate_data_t ) : <NEWLINE> with pytest . raises ( IndexError ) as excinfo : <NEWLINE> func ( arr , 1 , 2 , 3 ) <NEWLINE> assert str ( excinfo . value ) == <STRING> <NEWLINE> <DEDENT> <DEDENT>
def diffuse ( Z ) : <NEWLINE> <INDENT> Z = Z . reshape ( n * n , 2 ) <NEWLINE> <INDENT> img = np . zeros ( ( 256 , 256 ) ) <NEWLINE> for i in xrange ( n * n ) : <NEWLINE> x , y = Z [ i ] * ( 256 , 256 ) <NEWLINE> img [ x , y ] += 1 <NEWLINE> <DEDENT> return ndi . gaussian_filter ( img , ( 12 , 12 ) , mode = <STRING> ) <NEWLINE> <DEDENT>
def front_x ( words ) : <NEWLINE> <INDENT> xwords = [ ] <NEWLINE> for str in words : <NEWLINE> if str [ 0 ] == <STRING> : xwords . append ( str ) <NEWLINE> for str in xwords : <NEWLINE> words . remove ( str ) <NEWLINE> result = sorted ( xwords ) + sorted ( words ) <NEWLINE> return result <NEWLINE> <DEDENT>
def setup ( self ) : <NEWLINE> <INDENT> if self . account : <NEWLINE> <INDENT> self . sid = self . account . getAccountData ( self . user ) . get ( <STRING> None ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . sid = None <NEWLINE> <DEDENT> if self . sid : <NEWLINE> <INDENT> self . premium = True <NEWLINE> <DEDENT> self . resumeDownload = self . multiDL = self . premium <NEWLINE> self . chunkLimit = 1 <NEWLINE> <DEDENT>
def clean ( ) : <NEWLINE> <INDENT> shutil . rmtree ( <STRING> , ignore_errors = True ) <NEWLINE> shutil . rmtree ( <STRING> , ignore_errors = True ) <NEWLINE> for pattern in [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ] : <NEWLINE> for filename in glob . glob ( pattern ) : <NEWLINE> if os . path . exists ( filename ) : <NEWLINE> os . remove ( filename ) <NEWLINE> <DEDENT> <DEDENT>
def clean ( self ) : <NEWLINE> <INDENT> print ( <STRING> . format ( self . pidfile ) <NEWLINE> try : <NEWLINE> <INDENT> os . remove ( self . pidfile ) <NEWLINE> <DEDENT> except Exception : <NEWLINE> <INDENT> print ( <STRING> . format ( self . pidfile ) ) <NEWLINE> <DEDENT> <DEDENT>
def test_wrong_models_raise_exceptions ( self , kind , other ) : <NEWLINE> <INDENT> with pytest . raises ( ValueError ) : <NEWLINE> <INDENT> self . t . sidereal_time ( kind , <STRING> , <STRING> ) <NEWLINE> <DEDENT> for model in ( set ( SIDEREAL_TIME_MODELS [ other ] . keys ( ) ) - <NEWLINE> <INDENT> set ( SIDEREAL_TIME_MODELS [ kind ] . keys ( ) ) ) : <NEWLINE> with pytest . raises ( ValueError ) : <NEWLINE> self . t . sidereal_time ( kind , <STRING> , model ) <NEWLINE> with pytest . raises ( ValueError ) : <NEWLINE> self . t . sidereal_time ( kind , None , model ) <NEWLINE> <DEDENT> <DEDENT>
def on_touch_down ( self , touch ) : <NEWLINE> <INDENT> ret = super ( Console , self ) . on_touch_down ( touch ) <NEWLINE> if ( ( <STRING> not in touch . profile or touch . button == <STRING> ) and <NEWLINE> <INDENT> not ret and self . inspect_enabled ) : <NEWLINE> self . highlight_at ( * touch . pos ) <NEWLINE> if touch . is_double_tap : <NEWLINE> self . inspect_enabled = False <NEWLINE> ret = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = self . collide_point ( * touch . pos ) <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT>
class JyEntityResolverWrapper ( javasax . EntityResolver ) : <NEWLINE> <INDENT> def __init__ ( self , entityResolver ) : <NEWLINE> self . _resolver = entityResolver <NEWLINE> def resolveEntity ( self , pubId , sysId ) : <NEWLINE> return JyInputSourceWrapper ( self . _resolver . resolveEntity ( pubId , sysId ) ) <NEWLINE> <DEDENT>
def test_call_method ( self , mock_invoke_ob ) : <NEWLINE> <INDENT> with mock . patch . object ( self . vm_session , <NEWLINE> <INDENT> <STRING> , <NEWLINE> return_value = True ) : <NEWLINE> self . vm_session . _call_method ( <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , [ <STRING> ] ) <NEWLINE> self . assertTrue ( mock_invoke_ob . called ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def __setattr__ ( self , attr , value ) : <NEWLINE> <INDENT> if self . __dict__ . has_key ( attr ) : self . __dict__ [ attr ] = value ; return <NEWLINE> try : <NEWLINE> <INDENT> args , defArgs = self . _prop_map_put_ [ attr ] <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> raise AttributeError , <STRING> % ( repr ( self ) , attr ) <NEWLINE> <DEDENT> self . _oleobj_ . Invoke ( * ( args + ( value , ) + defArgs ) ) <NEWLINE> <DEDENT>
class sha1 : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> description = <STRING> <NEWLINE> category = [ <STRING> ] <NEWLINE> priority = 99 <NEWLINE> def encode ( self , string ) : <NEWLINE> s = hashlib . sha1 ( ) <NEWLINE> s . update ( string ) <NEWLINE> res = s . hexdigest ( ) <NEWLINE> return res <NEWLINE> <DEDENT>
def vxlan_mcast_supported ( self ) : <NEWLINE> <INDENT> if not cfg . CONF . VXLAN . vxlan_group : <NEWLINE> <INDENT> LOG . warning ( _LW ( <STRING> <NEWLINE> <INDENT> <STRING> ) ) <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> if not ip_lib . iproute_arg_supported ( <NEWLINE> <INDENT> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <NEWLINE> <STRING> ) : <NEWLINE> LOG . warning ( _LW ( <STRING> <NEWLINE> <INDENT> <STRING> ) , <NEWLINE> { <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> } ) <NEWLINE> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT>
def deleteProfile ( self , strId ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not strId : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> conn = odbc . odbc ( CONNECTION_STRING ) <NEWLINE> cmd = conn . cursor ( ) <NEWLINE> ok = cmd . execute ( <STRING> <NEWLINE> <INDENT> + strId + <STRING> ) ) : <NEWLINE> <DEDENT> conn . close ( ) <NEWLINE> return ok and 1 or 0 <NEWLINE> <DEDENT>
def pluralize ( count , multiple = <STRING> , single = <STRING> ) <NEWLINE> <INDENT> if count == 1 : <NEWLINE> <INDENT> return single <NEWLINE> <DEDENT> return multiple <NEWLINE> <DEDENT>
def emcLubeOff ( self ) : <NEWLINE> <INDENT> if debug ( ) : print <STRING> <NEWLINE> self . hal [ <STRING> ] = 0 <NEWLINE> self . io . lube . on = 0 <NEWLINE> self . io . status = emctask . RCS_STATUS . RCS_DONE <NEWLINE> return 0 <NEWLINE> <DEDENT>
class SwaggerPetstoreConfiguration ( Configuration ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( <NEWLINE> <INDENT> self , base_url = None , filepath = None ) : <NEWLINE> if not base_url : <NEWLINE> base_url = <STRING> <NEWLINE> super ( SwaggerPetstoreConfiguration , self ) . __init__ ( base_url , filepath ) <NEWLINE> self . add_user_agent ( <STRING> . format ( VERSION ) ) <NEWLINE> <DEDENT> <DEDENT>
def get_users_not_anybody ( ) : <NEWLINE> <INDENT> anybody_user_ids = [ user . uid for user in anybody . users ] <NEWLINE> query = dbsession . query ( User ) . filter ( User . uid . notin_ ( anybody_user_ids ) <NEWLINE> return query . all ( ) <NEWLINE> <DEDENT>
def move_cb ( word , word_eol , userdata ) : <NEWLINE> <INDENT> global moved <NEWLINE> if moved : <NEWLINE> <INDENT> return <NEWLINE> for chan in hexchat . get_list ( <STRING> ) : <NEWLINE> if chan . type == 1 and chan . id == hexchat . get_prefs ( <STRING> ) : <NEWLINE> <INDENT> network_context = chan . context <NEWLINE> moved = True <NEWLINE> network_context . emit_print ( <STRING> , word [ 0 ] , word [ 1 ] ) <NEWLINE> moved = False <NEWLINE> return hexchat . EAT_ALL <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def toggle ( self ) : <NEWLINE> <INDENT> if self . __pin . read ( ) == self . __up : <NEWLINE> <INDENT> self . __pin . write ( self . __down ) <NEWLINE> else : <NEWLINE> self . __pin . write ( self . __up ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> api_url , auth , counter = varsetup ( ) <NEWLINE> r = requests . get ( api_url , auth = auth ) <NEWLINE> my_dict = xmltodict . parse ( r . text ) <NEWLINE> my_list = my_dict [ <STRING> ] [ <STRING> ] <NEWLINE> for l in my_list : <NEWLINE> print ( my_list [ counter ] [ <STRING> ] ) <NEWLINE> counter = counter + 1 <NEWLINE> <DEDENT>
def _fbank ( * args , ** kwargs ) -> np . ndarray <NEWLINE> <INDENT> feat , _ = fbank ( * args , ** kwargs ) <NEWLINE> return feat <NEWLINE> <DEDENT>
def group_by_user ( changes ) : <NEWLINE> <INDENT> changes_bydate = { } <NEWLINE> for date in changes . keys ( ) : <NEWLINE> changes_byuser = { } <NEWLINE> for logmsg , name , filename in changes [ date ] : <NEWLINE> <INDENT> byuser = changes_byuser . get ( name , [ ] ) <NEWLINE> byuser . append ( ( filename , logmsg ) ) <NEWLINE> changes_byuser [ name ] = byuser <NEWLINE> changes_bydate [ date ] = changes_byuser <NEWLINE> <DEDENT> return changes_bydate <NEWLINE> <DEDENT>
def prepareSend ( self , type , size = None , response = 200 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . send_response ( response ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> print ( <STRING> % e ) <NEWLINE> return <NEWLINE> <DEDENT> self . send_header ( <STRING> , self . server_version ) <NEWLINE> self . send_header ( <STRING> , type ) <NEWLINE> if size : <NEWLINE> <INDENT> self . send_header ( <STRING> , size ) <NEWLINE> <DEDENT> self . end_headers ( ) <NEWLINE> <DEDENT>
def ordering ( first , second ) : <NEWLINE> <INDENT> ( ( name1 , obj , logo ) , priority1 ) = first <NEWLINE> ( ( name2 , obj , logo ) , priority2 ) = second <NEWLINE> if priority1 < priority2 : <NEWLINE> return - 1 <NEWLINE> elif priority1 > priority2 : <NEWLINE> return 1 <NEWLINE> if name1 < name2 : <NEWLINE> return - 1 <NEWLINE> elif name1 > name2 : <NEWLINE> return 1 <NEWLINE> return 0 <NEWLINE> <DEDENT>
def _check_path_symbol ( cls , module , symname , addr ) : <NEWLINE> <INDENT> sym = bcc_symbol ( ) <NEWLINE> psym = ct . pointer ( sym ) <NEWLINE> if lib . bcc_resolve_symname ( module . encode ( <STRING> ) , <NEWLINE> <INDENT> symname . encode ( <STRING> ) , addr or 0x0 , psym ) < 0 : <NEWLINE> if not sym . module : <NEWLINE> raise Exception ( <STRING> % module ) <NEWLINE> raise Exception ( <STRING> % symname ) <NEWLINE> <DEDENT> return sym . module . decode ( ) , sym . offset <NEWLINE> <DEDENT>
def testPropertyPublicMethodOverlap ( self ) : <NEWLINE> <INDENT> self . _bean . setProperty1 ( <STRING> ) <NEWLINE> self . assertEqual ( <STRING> , self . _bean . getProperty1 ( ) <NEWLINE> <DEDENT>
def find_GCD ( a , b ) : <NEWLINE> <INDENT> while a != b : <NEWLINE> <INDENT> if a > b : <NEWLINE> a -= b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b -= a <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT>
def section_names ( self , ordkey = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> section_names = [ ] <NEWLINE> for idx , timer in enumerate ( self . timers ( ) : <NEWLINE> <INDENT> if idx == 0 : <NEWLINE> <INDENT> section_names = [ s . name for s in timer . order_sections ( ordkey ) ] <NEWLINE> <DEDENT> <DEDENT> return section_names <NEWLINE> <DEDENT>
def test_list_configs_nojobs ( self ) : <NEWLINE> <INDENT> mock_context = FakeAuroraCommandContext ( ) <NEWLINE> with patch ( <STRING> , <NEWLINE> <INDENT> return_value = mock_context ) : <NEWLINE> with temporary_file ( ) as fp : <NEWLINE> fp . write ( self . get_config_with_no_jobs ( ) ) <NEWLINE> fp . flush ( ) <NEWLINE> cmd = AuroraCommandLine ( ) <NEWLINE> cmd . execute ( [ <STRING> , <STRING> , fp . name ] ) <NEWLINE> assert mock_context . out == [ <STRING> ] <NEWLINE> assert mock_context . err == [ ] <NEWLINE> <DEDENT> <DEDENT>
def _on_begin_drag ( self evt ) : <NEWLINE> <INDENT> tree_item_id = evt . GetItem ( ) <NEWLINE> fs_node = self . _get_fs_node_by_tree_item_id ( tree_item_id ) <NEWLINE> self . node_tool . begin_drag ( [ fs_node ] , self ) <NEWLINE> <DEDENT>
def format_num ( self , val , width = 8 ) : <NEWLINE> <INDENT> val = <STRING> % val <NEWLINE> <INDENT> val = val . zfill ( width ) <NEWLINE> <DEDENT> return val <NEWLINE> <DEDENT>
def run_one_push ( self ) : <NEWLINE> <INDENT> s = self . quotify ( self . val ) <NEWLINE> buf = cStringIO . StringIO ( ) <NEWLINE> c = pycurl . Curl ( ) <NEWLINE> url = self . getURL ( s ) <NEWLINE> c . setopt ( c . URL , url ) <NEWLINE> c . setopt ( pycurl . USERAGENT , <STRING> ) <NEWLINE> c . setopt ( pycurl . WRITEFUNCTION , buf . write ) <NEWLINE> try : <NEWLINE> <INDENT> res = c . perform ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> if not self . expect_fail ( ) : <NEWLINE> print ( <STRING> , url ) <NEWLINE> <DEDENT> <DEDENT>
def article_delete ( request ) : <NEWLINE> <INDENT> if C . checkLoginAdmin ( request . session . get ( <STRING> , False ) ) == False : <NEWLINE> <INDENT> return HttpResponseRedirect ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> idList = request . REQUEST . getlist ( <STRING> ) <NEWLINE> if len ( idList ) > 0 : <NEWLINE> <INDENT> Article . objects . filter ( article_id__in = idList ) . delete ( ) <NEWLINE> Relation . objects . filter ( aid__in = idList ) . delete ( ) <NEWLINE> return HttpResponse ( <STRING> ) <NEWLINE> <DEDENT> return HttpResponse ( <STRING> ) <NEWLINE> <DEDENT>
def commit_id ( self , commit ) : <NEWLINE> <INDENT> if not commit : <NEWLINE> <INDENT> commit = <STRING> <NEWLINE> <INDENT> cmt_id = None <NEWLINE> try : <NEWLINE> <DEDENT> cmt_id = check_output ( <STRING> . format ( commit ) , shell = True ) <NEWLINE> if cmt_id : <NEWLINE> cmt_id = cmt_id . strip ( ) <NEWLINE> commit_type = self . git_object_type ( commit ) <NEWLINE> if <STRING> != commit_type : <NEWLINE> sys . exit ( <STRING> . format ( commit , commit_type ) ) <NEWLINE> <INDENT> except ( CalledProcessError , OSError ) as e : <NEWLINE> <DEDENT> sys . exit ( <STRING> . format ( commit ) ) <NEWLINE> <DEDENT> return cmt_id <NEWLINE> <DEDENT>
def create_video_url ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> self . video_url = self . cleaned_data [ <STRING> ] . add_url ( <NEWLINE> <INDENT> self . cleaned_data [ <STRING> ] , <NEWLINE> self . user ) <NEWLINE> <DEDENT> <DEDENT> except Video . UrlAlreadyAdded , e : <NEWLINE> <INDENT> raise forms . ValidationError ( self . already_added_message ( e . video ) ) <NEWLINE> <DEDENT> <DEDENT>
def test_invalid_mixing_encrypt_decrypt ( self ) : <NEWLINE> <INDENT> for method1_name , method2_name in ( ( <STRING> , <STRING> ) , <NEWLINE> <INDENT> ( <STRING> , <STRING> ) ) : <NEWLINE> for assoc_data_present in ( True , False ) : <NEWLINE> cipher = AES . new ( self . key_128 , AES . MODE_CCM , <NEWLINE> nonce = self . nonce_96 , <NEWLINE> msg_len = 32 ) <NEWLINE> if assoc_data_present : <NEWLINE> cipher . update ( self . data_128 ) <NEWLINE> getattr ( cipher , method1_name ) ( self . data_128 ) <NEWLINE> self . assertRaises ( TypeError , getattr ( cipher , method2_name ) , <NEWLINE> self . data_128 ) <NEWLINE> <DEDENT> <DEDENT>
def test_get_vhd_format_zero_length_file ( self ) : <NEWLINE> <INDENT> with mock . patch ( <STRING> , <NEWLINE> <INDENT> mock . mock_open ( read_data = <STRING> ) , <NEWLINE> create = True ) as mock_open : <NEWLINE> f = mock_open . return_value <NEWLINE> f . tell . return_value = 0 <NEWLINE> self . assertRaises ( vmutils . HyperVException , <NEWLINE> <INDENT> self . _vhdutils . get_vhd_format , <NEWLINE> self . _FAKE_VHD_PATH ) <NEWLINE> f . seek . assert_called_once_with ( 0 , 2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def retranslateUi ( self , CiteDialog ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> CiteDialog . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . label . setText ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . edit_unified . setHtml ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def test_file_display ( self ) : <NEWLINE> <INDENT> for handler in ( self . dialog . idle_credits , <NEWLINE> <INDENT> self . dialog . idle_readme , <NEWLINE> self . dialog . idle_news ) : <NEWLINE> self . error . message = <STRING> <NEWLINE> self . view . called = False <NEWLINE> with self . subTest ( handler = handler ) : <NEWLINE> handler ( ) <NEWLINE> self . assertEqual ( self . error . message , <STRING> ) <NEWLINE> self . assertEqual ( self . view . called , True ) <NEWLINE> <DEDENT> <DEDENT>
def _set_cookies ( self , payload , response ) : <NEWLINE> <INDENT> cookies = [ ] <NEWLINE> for cookie in [ x . split ( <STRING> , 1 ) [ 0 ] <NEWLINE> <INDENT> for x in response . headers . getlist ( <STRING> ) ] : <NEWLINE> if cookie not in self . cookies_seen : <NEWLINE> self . cookies_seen . add ( cookie ) <NEWLINE> cookies . append ( cookie ) <NEWLINE> <DEDENT> if cookies : <NEWLINE> <INDENT> payload [ <STRING> ] = cookies <NEWLINE> <DEDENT> <DEDENT>
def extract_column ( t , names ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> lst = [ ] <NEWLINE> for i in names : <NEWLINE> <INDENT> lst . append ( np . array ( t [ i ] ) <NEWLINE> <DEDENT> return lst <NEWLINE> <DEDENT>
def get_dhcp_leases ( context , network_ref ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> hosts = [ ] <NEWLINE> for fixed_ref in db . network_get_associated_fixed_ips ( context , <NEWLINE> <INDENT> network_ref [ <STRING> ] ) : <NEWLINE> host = fixed_ref [ <STRING> ] [ <STRING> ] <NEWLINE> if network_ref [ <STRING> ] and FLAGS . host != host : <NEWLINE> continue <NEWLINE> hosts . append ( _host_lease ( fixed_ref ) ) <NEWLINE> <DEDENT> return <STRING> . join ( hosts ) <NEWLINE> <DEDENT>
def dyld_find ( name , executable_path = None , env = None , loader_path = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> name = _ensure_utf8 ( name ) <NEWLINE> executable_path = _ensure_utf8 ( executable_path ) <NEWLINE> for path in dyld_image_suffix_search ( chain ( <NEWLINE> <INDENT> dyld_override_search ( name , env ) , <NEWLINE> dyld_executable_path_search ( name , executable_path ) , <NEWLINE> dyld_loader_search ( name , loader_path ) , <NEWLINE> dyld_default_search ( name , env ) , <NEWLINE> ) , env ) : <NEWLINE> if os . path . isfile ( path ) : <NEWLINE> return path <NEWLINE> <DEDENT> raise ValueError ( <STRING> % ( name , ) ) <NEWLINE> <DEDENT>
def update_item ( self , key , view ) : <NEWLINE> <INDENT> self . lock . acquire ( ) <NEWLINE> try : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> i = self . keys . index ( key ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> raise ListBufferError , <STRING> <NEWLINE> <DEDENT> view = self . clean_item ( view ) <NEWLINE> self . items [ i ] = view <NEWLINE> self . activity ( 1 ) <NEWLINE> self . display ( i ) <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> self . lock . release ( ) <NEWLINE> <DEDENT> <DEDENT>
def _ensure_list ( self , value , field ) : <NEWLINE> <INDENT> if ( not isinstance ( value , collections . Sequence ) <NEWLINE> <INDENT> or isinstance ( value , six . string_types ) ) : <NEWLINE> warn ( ( <STRING> <NEWLINE> <INDENT> + <STRING> <NEWLINE> + <STRING> ) . format ( id = self . _data [ <STRING> ] , field = field , <NEWLINE> type = self . _data [ <STRING> ] ) , SpecificationWarning ) <NEWLINE> value = [ value ] <NEWLINE> <DEDENT> <DEDENT> return value <NEWLINE> <DEDENT>
def data2ni_form ( data , form ) : <NEWLINE> <INDENT> if ( type ( data ) is np . ndarray and <NEWLINE> <INDENT> ( numpy_data_isint ( data ) or numpy_data_isfloat ( data ) ) ) : <NEWLINE> byteorder = data . dtype . byteorder <NEWLINE> if not form in [ <STRING> , <STRING> ] : <NEWLINE> raise ValueError ( <STRING> % form ) <NEWLINE> if byteorder == <STRING> : <NEWLINE> byteorder = <STRING> if sys . byteorder == <STRING> else <STRING> <NEWLINE> if byteorder in <STRING> : <NEWLINE> return <STRING> % ( form , <STRING> if byteorder == <STRING> else <STRING> ) <NEWLINE> else : <NEWLINE> raise ValueError ( <STRING> % byteorder ) <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>
<STRING> <NEWLINE> <STRING> <NEWLINE> namespace Json <NEWLINE> <INDENT> namespace Rpc <NEWLINE> <INDENT> <STRING> <NEWLINE> class UdpClient : public Client <NEWLINE> <INDENT> public : <NEWLINE> <INDENT> <STRING> <NEWLINE> UdpClient ( std . string & address , port ) <NEWLINE> <STRING> <NEWLINE> virtual ~ UdpClient ( ) <NEWLINE> <STRING> <NEWLINE> virtual ssize_t Recv ( std . string & data ) <NEWLINE> <STRING> <NEWLINE> ssize_t Send ( std . string & data ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> } <STRING> <NEWLINE> <DEDENT> } <STRING> <NEWLINE>
from pygame import * <NEWLINE> init ( ) <NEWLINE> display . init ( ) <NEWLINE> j = joystick . Joystick ( 0 ) <NEWLINE> j . init ( ) <NEWLINE> if j . get_init ( ) == 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> while 1 : <NEWLINE> <INDENT> for e in event . get ( ) : <NEWLINE> <INDENT> if e . type != QUIT : <NEWLINE> <INDENT> print ( <STRING> % ( event . event_name ( e . type ) , e . dict ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_treat_devices_removed_returns_true_for_missing_device ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( self . agent . plugin_rpc , <STRING> <NEWLINE> <INDENT> side_effect = Exception ( ) ) : <NEWLINE> self . assertTrue ( self . agent . treat_devices_removed ( [ { } ] ) ) <NEWLINE> <DEDENT> <DEDENT>
class CountWords ( beam . PTransform ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def expand ( self , pcoll ) : <NEWLINE> <INDENT> return ( pcoll <NEWLINE> <INDENT> | <STRING> >> beam . Map ( lambda x : ( x , 1 ) ) <NEWLINE> | <STRING> >> beam . GroupByKey ( ) <NEWLINE> | <STRING> >> beam . Map ( lambda ( word , ones ) : ( word , sum ( ones ) ) ) <NEWLINE> | <STRING> >> beam . Map ( lambda ( word , c ) : <STRING> % ( word , c ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def __init__ ( self , listenIP , listenPort ) : <NEWLINE> <INDENT> setUp ( ) <NEWLINE> UDP_IP = listenIP <NEWLINE> UDP_PORT = listenPort <NEWLINE> INsock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) <NEWLINE> INsock . bind ( ( UDP_IP , UDP_PORT ) ) ) <NEWLINE> OUTsock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
def testFailedUnaryRequestStreamResponse ( self ) : <NEWLINE> <INDENT> for ( group , method ) , test_messages_sequence in ( <NEWLINE> <INDENT> six . iteritems ( self . _digest . unary_stream_messages_sequences ) ) : <NEWLINE> for test_messages in test_messages_sequence : <NEWLINE> request = test_messages . request ( ) <NEWLINE> with self . _control . fail ( ) , self . assertRaises ( face . ExpirationError ) : <NEWLINE> <INDENT> response_iterator = self . _invoker . future ( group , method ) ( <NEWLINE> <INDENT> request , _3069_test_constant . REALLY_SHORT_TIMEOUT ) <NEWLINE> <DEDENT> list ( response_iterator ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class RemoveSlashMiddleware ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def process_response ( self , request , response ) : <NEWLINE> <INDENT> if ( response . status_code == 404 and <NEWLINE> <INDENT> request . path_info . endswith ( <STRING> ) and <NEWLINE> not is_valid_path ( request . path_info ) and <NEWLINE> is_valid_path ( request . path_info [ : - 1 ] ) ) : <NEWLINE> newurl = request . path [ : - 1 ] <NEWLINE> if request . GET : <NEWLINE> with safe_query_string ( request ) : <NEWLINE> <INDENT> newurl += <STRING> + request . META [ <STRING> ] <NEWLINE> return HttpResponsePermanentRedirect ( newurl ) <NEWLINE> <DEDENT> <DEDENT> return response <NEWLINE> <DEDENT> <DEDENT>
def extract_credentials ( self , request ) : <NEWLINE> <INDENT> if request . META . get ( <STRING> , <STRING> ) . lower ( ) . startswith ( <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> ( auth_type , secret_key ) = ( <NEWLINE> request . META [ <STRING> ] . split ( ) ) <NEWLINE> if auth_type . lower ( ) != <STRING> : <NEWLINE> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> secret_key = request . GET . get ( <STRING> ) or request . POST . get ( <STRING> ) <NEWLINE> <DEDENT> return secret_key <NEWLINE> <DEDENT>
( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
<INDENT> in childNames ) <NEWLINE>
class Reference ( ReferenceBase ) : <NEWLINE> <INDENT> def __init__ ( self , target_id , type = <STRING> , link = True , style = None , <NEWLINE> <INDENT> quiet = False , ** kwargs ) : <NEWLINE> super ( ) . __init__ ( type = type , link = link , style = style , quiet = quiet , <NEWLINE> <INDENT> ** kwargs ) <NEWLINE> self . _target_id = target_id <NEWLINE> <DEDENT> <DEDENT> def target_id ( self , document ) : <NEWLINE> <INDENT> return self . _target_id <NEWLINE> <DEDENT> <DEDENT>
def GetShowIds ( self ) : <NEWLINE> <INDENT> show_ids = [ ] <NEWLINE> try : <NEWLINE> <INDENT> response = GetUrlData ( url = settings . __url__ + <STRING> ) <NEWLINE> if not response : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> result = json . loads ( response ) <NEWLINE> for each in result [ <STRING> ] : <NEWLINE> <INDENT> show_ids . append ( each ) <NEWLINE> <DEDENT> <DEDENT> except Exception , e : <NEWLINE> <INDENT> common . errorWindow ( sys . _getframe ( ) . f_code . co_name , self . CONNECT_ERROR + str ( e ) ) <NEWLINE> <DEDENT> return show_ids <NEWLINE> <DEDENT>
def load_plugins ( plugins ) : <NEWLINE> <INDENT> print ( <STRING> % <STRING> . join ( plugins ) ) <NEWLINE> for plugin in plugins : <NEWLINE> <INDENT> start = datetime . datetime . now ( ) <NEWLINE> try : <NEWLINE> <INDENT> __import__ ( plugin , globals ( ) , locals ( ) , [ <STRING> ] ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> print ( <STRING> % plugin ) <NEWLINE> print ( e ) <NEWLINE> <DEDENT> print ( <STRING> % ( plugin , datetime . datetime . now ( ) - start ) ) <NEWLINE> <DEDENT> pass <NEWLINE> <DEDENT>
def __init__ ( self , wqlf , wqlb , ssd , parent = None ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> QtGui . QWidget . __init__ ( self , parent ) <NEWLINE> <DEDENT> self . smartSpaceData = ssd <NEWLINE> self . wqlResultUI = Ui_WQLResultDialog ( ) <NEWLINE> self . wqlResultUI . setupUi ( self ) <NEWLINE> self . wqlframe = wqlf <NEWLINE> self . wqlbody = wqlb <NEWLINE> self . performQuery ( ) <NEWLINE> <DEDENT>
def parse ( self , * args , ** kwargs ) <NEWLINE> <INDENT> <STRING> <NEWLINE> abstract <NEWLINE> <DEDENT>
( <STRING> <NEWLINE> <DEDENT>
def configure_event ( self , widget , event ) : <NEWLINE> <INDENT> if _debug : <NEWLINE> <INDENT> print <STRING> % fn_name ( ) <NEWLINE> <DEDENT> if widget . get_property ( <STRING> ) is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> w , h = event . width , event . height <NEWLINE> if w < 3 or h < 3 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> dpi = self . figure . dpi <NEWLINE> self . figure . set_size_inches ( w / dpi , h / dpi ) <NEWLINE> self . _need_redraw = True <NEWLINE> return False <NEWLINE> <DEDENT>
def _create_catalog_rows ( self , catalog , prune = False ) : <NEWLINE> <INDENT> rows = [ ] <NEWLINE> for message in catalog : <NEWLINE> <INDENT> if not message . id : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if prune and not message . locations : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> rows . append ( self . _create_catalog_row ( <NEWLINE> <INDENT> message . id , message . string , message . auto_comments , message . locations ) <NEWLINE> <DEDENT> <DEDENT> return rows <NEWLINE> <DEDENT>
def sentence_semantic_vector ( s , joint_word_set ) : <NEWLINE> <INDENT> s_words = re . sub ( <STRING> , <STRING> , s1 ) . split ( ) <NEWLINE> sv = [ 0 ] * len ( joint_word_set ) <NEWLINE> for i in range ( 0 , len ( joint_word_set ) ) <NEWLINE> <INDENT> sv [ i ] = 1 if joint_word_set [ i ] in s_words else word_semantic_similarity ( joint_word_set [ i ] , s ) [ 1 ] <NEWLINE> <DEDENT> return sv <NEWLINE> <DEDENT>
def euclid_vectors ( self , a = [ ] , b = [ ] ) : <NEWLINE> <INDENT> if a . __len__ ( ) != b . __len__ ( ) : <NEWLINE> <INDENT> if self . verbose : <NEWLINE> <INDENT> print <STRING> , a . __len__ ( ) , <STRING> , b . __len__ ( ) <NEWLINE> <DEDENT> raise Exception <NEWLINE> <DEDENT> euclid_sqrd = 0 <NEWLINE> for i in range ( 0 , a . __len__ ( ) ) : <NEWLINE> <INDENT> euclid_sqrd += math . pow ( ( a [ i ] - b [ i ] ) , 2 ) <NEWLINE> <DEDENT> return math . sqrt ( euclid_sqrd ) <NEWLINE> <DEDENT>
def __init__ ( self , parent = None , pos = None , size = None , font = None ) : <NEWLINE> <INDENT> if parent is not None : <NEWLINE> if pos is not None : <NEWLINE> pos , size = parent . parse ( pos , size , font ) <NEWLINE> self . x , self . y = pos <NEWLINE> self . w , self . h = size <NEWLINE> else : <NEWLINE> self . x = None <NEWLINE> self . y = None <NEWLINE> self . w = None <NEWLINE> self . h = None <NEWLINE> <DEDENT>
def stop ( self , key ) : <NEWLINE> <INDENT> if ( Config . DEBUG > 3 ) : print <STRING> + str ( key ) <NEWLINE> for n in self . notesDict [ key ] : <NEWLINE> <INDENT> self . csnd . loopDelete ( n ) <NEWLINE> <DEDENT> del self . notesDict [ key ] <NEWLINE> if ( Config . DEBUG > 3 ) : <NEWLINE> <INDENT> print self . notesDict <NEWLINE> <DEDENT> <DEDENT>
def print_page ( request , id , pin ) : <NEWLINE> <INDENT> check_inputs ( id , pin ) <NEWLINE> con = Connection . objects . get ( id = id ) <NEWLINE> translation . activate ( brain . get_user_lang ( con . telegram_id ) ) ) <NEWLINE> message_link = HPQR_HOST + <STRING> + id + <STRING> + pin <NEWLINE> return render ( request , <STRING> , { <STRING> : message_link , <STRING> : HPQR_YANDEX_METRIKA } ) <NEWLINE> <DEDENT>
def test_rank ( score , expected_rank ) : <NEWLINE> <INDENT> if ( hasattr ( expected_rank , <STRING> ) and <NEWLINE> <INDENT> isinstance ( expected_rank ( ) , Exception ) ) : <NEWLINE> with pytest . raises ( expected_rank ) : <NEWLINE> cc_rank ( score ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> assert cc_rank ( score ) == expected_rank <NEWLINE> <DEDENT> <DEDENT>
def setUp ( self ) : <NEWLINE> <INDENT> self . archive_path = binary_manager . FetchPath ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> py_utils . GetHostArchName ( ) , <NEWLINE> , <NEWLINE> py_utils . GetHostOsName ( ) ) <NEWLINE> <DEDENT> <DEDENT>
def changes ( self , other ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> changes = { } <NEWLINE> try : <NEWLINE> <INDENT> other_code = other . code_sequence <NEWLINE> <DEDENT> except AttributeError : <NEWLINE> <INDENT> other_code = other <NEWLINE> <DEDENT> for codon , old , new in zip ( self . _codons , self . code_sequence , <NEWLINE> <INDENT> other_code ) : <NEWLINE> if old != new : <NEWLINE> changes [ codon ] = old + new <NEWLINE> <DEDENT> return changes <NEWLINE> <DEDENT>
class Solution ( object ) : <NEWLINE> <INDENT> def intersect ( self , nums1 , nums2 ) : <NEWLINE> <STRING> <NEWLINE> dict = collections . defaultdict ( int ) <NEWLINE> for i in nums1 : <NEWLINE> <INDENT> dict [ i ] += 1 <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> for i in nums2 : <NEWLINE> <INDENT> if dict [ i ] > 0 : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> dict [ i ] -= 1 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT>
import pickle <NEWLINE> import numpy as np <NEWLINE> weight_history ( append only ) <NEWLINE> ( read only ) <NEWLINE> [ Xy1 , Xy2 , . . ] <NEWLINE> run multi processes <NEWLINE>
def format_dictlist ( dictlist , features ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def dict_to_entry ( dct ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> relevant_items = [ ( k , v ) for ( k , v ) in dct . items ( ) if k in features ] <NEWLINE> ordered = sorted ( relevant_items , key = lambda ( k , v ) : header . index ( k ) ) <NEWLINE> vals = [ v for ( _ , v ) in ordered ] <NEWLINE> return vals <NEWLINE> <DEDENT> header = features <NEWLINE> datarows = map ( dict_to_entry , dictlist ) <NEWLINE> return header , datarows <NEWLINE> <DEDENT>
def GetClines ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> cccamcafardClines = [ ] <NEWLINE> cccamcafardClines . append ( self . __GetCccamcafardCline ( 1 ) ) <NEWLINE> cccamcafardClines . append ( self . __GetCccamcafardCline ( 2 ) ) <NEWLINE> cccamcafardClines = filter ( None , cccamcafardClines ) <NEWLINE> if len ( cccamcafardClines ) == 0 : print <STRING> <NEWLINE> return cccamcafardClines <NEWLINE> <DEDENT>
def test_46_disableHost_user_stop_startVM ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> self . vm_user . stop ( self . user_apiclient ) <NEWLINE> <DEDENT> listResp = VirtualMachine . list ( self . user_apiclient , id = self . vm_user . id ) <NEWLINE> self . assertEqual ( listResp [ 0 ] . state , <NEWLINE> <INDENT> VirtualMachine . STOPPED , <NEWLINE> <STRING> ) <NEWLINE> self . vm_user . start ( self . user_apiclient ) <NEWLINE> <DEDENT> listResp = VirtualMachine . list ( self . user_apiclient , id = self . vm_user . id ) <NEWLINE> self . assertEqual ( listResp [ 0 ] . state , <NEWLINE> <INDENT> VirtualMachine . RUNNING , <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
def usage ( doc = bddown_help . usage , message = None ) : <NEWLINE> <INDENT> if hasattr ( doc , <STRING> ) : <NEWLINE> <INDENT> doc = doc ( ) <NEWLINE> <DEDENT> if message : <NEWLINE> <INDENT> print ( message ) <NEWLINE> <DEDENT> print ( doc . strip ( ) <NEWLINE> <DEDENT>
def check_version ( easybuild_version , last_version_git_tag ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> % ( easybuild_package , easybuild_version ) ) <NEWLINE> print ( <STRING> % last_version_git_tag ) <NEWLINE> if not easybuild_version == last_version_git_tag : <NEWLINE> <INDENT> warning ( <STRING> % ( easybuild_package , <NEWLINE> <INDENT> easybuild_version , <NEWLINE> , <NEWLINE> last_version_git_tag ) ) <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT>
def trace_exit ( pid , flags , tricklist , exitstatus , termsig ) : <NEWLINE> <INDENT> signalname = None <NEWLINE> if termsig : <NEWLINE> signalname = signalmap . lookup_name ( termsig ) <NEWLINE> for trick , callmask , signalmask in tricklist : <NEWLINE> <INDENT> if trick . is_enabled ( pid ) : trick . exit ( pid , exitstatus , signalname ) <NEWLINE> <DEDENT> <DEDENT>
def process_details ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> results = { <NEWLINE> <INDENT> <STRING> : sys . argv , <NEWLINE> <STRING> : os . getcwd ( ) , <NEWLINE> <DEDENT> } <NEWLINE> for key , method in { <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <STRING> : <STRING> } . items ( ) : <NEWLINE> try : <NEWLINE> results [ key ] = getattr ( os , method ) ( ) <NEWLINE> except AttributeError : <NEWLINE> results [ key ] = None <NEWLINE> <DEDENT> return results <NEWLINE> <DEDENT>
def search ( self , params ) : <NEWLINE> <INDENT> if not params : <NEWLINE> raise Exception ( <STRING> ) <NEWLINE> encoded_params = urllib . urlencode ( params ) <NEWLINE> self . request_url = <STRING> % ( self . search_url , encoded_params ) <NEWLINE> self . init_request ( ) <NEWLINE> return self . send_request ( ) <NEWLINE> <DEDENT>
def selu ( x , name = <STRING> ) : <NEWLINE> <INDENT> alpha = 1.6732632423543772848170429916717 <NEWLINE> scale = 1.0507009873554804934193349852946 <NEWLINE> return scale * tf . where ( x >= 0.0 , x , alpha * tf . nn . elu ( x ) <NEWLINE> <DEDENT>
def _from_block_OB ( block , basedir , extra_info , level ) : <NEWLINE> <INDENT> for block_mod in bf_utils . iter_ListBase ( <NEWLINE> <INDENT> block . get_pointer ( ( <STRING> , <STRING> ) ) , <NEWLINE> next_item = ( <STRING> , <STRING> ) ) : <NEWLINE> item_md_type = block_mod [ <STRING> , <STRING> ] <NEWLINE> if item_md_type == C_defs . eModifierType_MeshCache : <NEWLINE> yield FPElem_block_path ( basedir , level , ( block_mod , <STRING> ) ) , extra_info <NEWLINE> <DEDENT> <DEDENT>
class Cone ( GeometricalObject3D ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , center , axis , angle ) : <NEWLINE> self . center = center <NEWLINE> self . axis = axis . normal ( ) <NEWLINE> self . angle = angle <NEWLINE> def volume ( self ) : <NEWLINE> return None <NEWLINE> <DEDENT>
def retrieve_all_links_coords_degree ( self ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> try : <NEWLINE> <INDENT> self . _cursor . execute ( <STRING> ) <NEWLINE> result = self . _cursor . fetchall ( ) <NEWLINE> <DEDENT> except MySQLdb . Error , e : <NEWLINE> <INDENT> logging . error ( <STRING> % ( e . args [ 1 ] , e . args [ 0 ] ) ) <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT>
def artifact_dir ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> dir = os . path . join ( self . project_dir , _get_value ( self . config , <STRING> , <STRING> ) <NEWLINE> if not os . path . exists ( dir ) : <NEWLINE> <INDENT> _log . debug ( <STRING> ) <NEWLINE> os . makedirs ( dir ) <NEWLINE> <DEDENT> return dir <NEWLINE> <DEDENT>
def printMat ( mat ) : <NEWLINE> <INDENT> n = len ( mat ) <NEWLINE> for row in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> , <NEWLINE> for col in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> , mat [ row ] [ col ] , ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class TOTPSlot ( OTPSlot ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , name , key , base32_encoded , salt , digits , totp_algorithm , <NEWLINE> <INDENT> time_step_size , start_time , now_time ) : <NEWLINE> super ( ) . __init__ ( name , key , base32_encoded , salt , digits ) <NEWLINE> if not isinstance ( totp_algorithm , TOTPAlgorithm ) : <NEWLINE> raise Exception ( <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> % ( totp_algorithm , traceback . format_exc ( ) ) ) <NEWLINE> self . totp_algorithm = totp_algorithm <NEWLINE> self . time_step_size = time_step_size <NEWLINE> self . start_time = start_time <NEWLINE> self . now_time = now_time <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def __getActiveBlocks ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> blockinfo = self . getBlockInformation ( ) <NEWLINE> output = [ ] <NEWLINE> for param , object_type in zip ( [ <STRING> , <STRING> , <STRING> ] , <NEWLINE> <INDENT> [ self . BLOCK , self . SIDESET , self . NODESET ] ) : <NEWLINE> if self . isOptionValid ( param ) : <NEWLINE> blocks = self . getOption ( param ) <NEWLINE> for data in blockinfo [ object_type ] . itervalues ( ) : <NEWLINE> if data . name in blocks : <NEWLINE> output . append ( data ) <NEWLINE> <DEDENT> return output <NEWLINE> <DEDENT>
def test_downvoted__other_user ( self ) : <NEWLINE> <INDENT> self . reddit . read_only = False <NEWLINE> with self . recorder . use_cassette ( <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> redditor = self . reddit . redditor ( <STRING> ) <NEWLINE> with pytest . raises ( Forbidden ) : <NEWLINE> list ( redditor . downvoted ( ) ) <NEWLINE> <DEDENT> <DEDENT>
def handle_exception ( self , exc ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if isinstance ( exc , ( exceptions . NotAuthenticated , <NEWLINE> <INDENT> exceptions . AuthenticationFailed ) ) : <NEWLINE> auth_header = self . get_authenticate_header ( self . request ) <NEWLINE> if auth_header : <NEWLINE> exc . auth_header = auth_header <NEWLINE> else : <NEWLINE> exc . status_code = status . HTTP_403_FORBIDDEN <NEWLINE> <DEDENT> response = self . settings . EXCEPTION_HANDLER ( exc ) <NEWLINE> if response is None : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> response . exception = True <NEWLINE> return response <NEWLINE> <DEDENT>
( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
myString = <STRING> <NEWLINE> if myString == <STRING> <NEWLINE> <INDENT> print ( myString ) <NEWLINE> <DEDENT>
def replace_action ( target , source , env ) : <NEWLINE> <INDENT> open ( str ( target [ 0 ] ) , <STRING> ) . write ( PercentDelimitedTemplate ( open ( str ( source [ 0 ] ) , <STRING> ) . read ( ) ) . substitute ( env ) ) <NEWLINE> <INDENT> env . Depends ( target , env . Value ( env . Dictionary ( ) ) ) <NEWLINE> <DEDENT> <DEDENT>
def lookup_login_info ( self , credentials , options ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with MethodContext ( self , MA_LOG_PREFIX , <NEWLINE> <INDENT> <STRING> , <NEWLINE> { } , credentials , options , read_only = True ) as mc : <NEWLINE> if not mc . _error : <NEWLINE> mc . _result = self . _delegate . lookup_login_info ( mc . _client_cert , <NEWLINE> <INDENT> credentials , <NEWLINE> options , <NEWLINE> mc . _session ) <NEWLINE> <DEDENT> <DEDENT> return mc . _result <NEWLINE> <DEDENT>
def htmlBalloon ( county , party ) : <NEWLINE> <INDENT> return <STRING> % ( <NEWLINE> county [ <STRING> ] , <NEWLINE> partyName ( party ) , <NEWLINE> htmlBalloonTally ( county , party ) <NEWLINE> <DEDENT>
def combinationWithoutRepetition ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> stuff = self . combinationParser ( ) <NEWLINE> if stuff [ <STRING> ] > stuff [ <STRING> ] <NEWLINE> <INDENT> return <STRING> % QOMBICON16 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stuff [ <STRING> ] = factorial ( stuff [ <STRING> ] ) / factorial ( stuff [ <STRING> ] ) / factorial ( stuff [ <STRING> ] - stuff [ <STRING> ] ) <NEWLINE> return <STRING> % stuff <NEWLINE> <DEDENT> <DEDENT>
def confirm ( self , confirmed ) : <NEWLINE> <INDENT> if not confirmed : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . nameEntry [ 1 ] . setValue ( iInputDevices . getDeviceAttribute ( self . inputDevice , <STRING> ) ) <NEWLINE> cmd = <STRING> + self . inputDevice + <STRING> <NEWLINE> exec cmd <NEWLINE> self . keySave ( ) <NEWLINE> <DEDENT> <DEDENT>
def _exec ( self , irc , msg , args , s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> exec s <NEWLINE> irc . replySuccess ( ) <NEWLINE> <DEDENT>
def test_search ( self ) : <NEWLINE> <INDENT> self . driver . get ( <STRING> ) <NEWLINE> search_input = self . driver . find_element_by_css_selector <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> search_input . send_keys ( <STRING> ) <NEWLINE> search_submit = self . driver . find_element_by_css_selector ( <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> search_submit . click ( ) <NEWLINE> self . assertTrue ( self . driver . find_element_by_css_selector ( <NEWLINE> <INDENT> <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT>
def __compute_camera_matrix_and_distortion_coefficients ( self , distorted_image_path ) : <NEWLINE> <INDENT> if self . __is_stage_complete ( self . STAGE_COMPUTED_OBJ_AND_IMG_POINTS ) and not self . __is_stage_complete ( <NEWLINE> <INDENT> self . STAGE_CALCULATED_CAMERA_MTX_AND_DIST_COEFFICIENTS ) : <NEWLINE> fname = distorted_image_path <NEWLINE> img = mpimg . imread ( fname ) <NEWLINE> ret , mtx , dist , rvecs , tvecs = cv2 . calibrateCamera ( self . __objpoints , self . __imgpoints , img . shape [ 0 : 2 ] [ : : - 1 ] , <NEWLINE> <INDENT> None , None ) <NEWLINE> self . __camera_matrix = mtx <NEWLINE> self . __distortion_coefficients = dist <NEWLINE> self . __apply_stage ( self . STAGE_CALCULATED_CAMERA_MTX_AND_DIST_COEFFICIENTS ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def create_configurable_widget ( client , config_key ) : <NEWLINE> <INDENT> frame = gtk . Frame ( config_key ) <NEWLINE> label = gtk . Label ( <STRING> ) <NEWLINE> frame . add ( label ) <NEWLINE> s = client . get_string ( config_key ) <NEWLINE> if s : <NEWLINE> label . set_text ( s ) <NEWLINE> notify_id = client . notify_add ( config_key , <NEWLINE> <INDENT> configurable_widget_config_notify , <NEWLINE> label ) <NEWLINE> <DEDENT> label . set_data ( <STRING> , notify_id ) <NEWLINE> label . set_data ( <STRING> , client ) <NEWLINE> label . connect ( <STRING> , configurable_widget_destroy_callback ) <NEWLINE> return frame <NEWLINE> <DEDENT>
def sample_getPosts ( self ) : <NEWLINE> <INDENT> prefix , suffix = getAPI ( URL , <STRING> ) <NEWLINE> url = prefix + suffix <NEWLINE> req1 = requests . get ( url ) <NEWLINE> <INDENT> body = json . loads ( req1 . text ) <NEWLINE> return body <NEWLINE> <DEDENT> <DEDENT>
def retranslateUi ( self , NoDevicesDialog_base ) : <NEWLINE> <INDENT> NoDevicesDialog_base . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . textLabel7 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def paint_aggr_hosts ( row , link_to_view ) : <NEWLINE> <INDENT> h = [ ] <NEWLINE> for site , host in row [ <STRING> ] : <NEWLINE> <INDENT> url = html . makeuri ( [ ( <STRING> , link_to_view ) , ( <STRING> , site ) , ( <STRING> , host ) ] ) <NEWLINE> h . append ( <STRING> % ( url host ) ) <NEWLINE> <DEDENT> return <STRING> , <STRING> . join ( h ) <NEWLINE> <DEDENT>
class SecurityNegotiationFailure ( StreamNegotiationFailure ) : <NEWLINE> <INDENT> def __init__ ( self , xmpp_error , <NEWLINE> <INDENT> kind = <STRING> , <NEWLINE> text = None ) : <NEWLINE> msg = <STRING> . format ( kind , xmpp_error ) <NEWLINE> if text : <NEWLINE> msg += <STRING> . format ( text ) <NEWLINE> super ( ) . __init__ ( msg ) <NEWLINE> self . xmpp_error = xmpp_error <NEWLINE> self . text = text <NEWLINE> <DEDENT> <DEDENT>
def update ( self , context ) : <NEWLINE> <INDENT> global last_update <NEWLINE> if ( context . window is not None and <NEWLINE> <INDENT> context . window . screen is not None and <NEWLINE> context . window . screen . areas is not None ) : <NEWLINE> areas = context . window . screen . areas <NEWLINE> for area in areas : <NEWLINE> if area . type == <STRING> : <NEWLINE> <INDENT> area . tag_redraw ( ) <NEWLINE> if time ( ) - last_update > 0.1 : <NEWLINE> <DEDENT> bpy . ops . wm . redraw_timer ( type = <STRING> , iterations = 1 ) <NEWLINE> last_update = time ( ) <NEWLINE> <DEDENT> <DEDENT>
def _lock_svn ( self ) : <NEWLINE> <INDENT> repo = get_output ( <STRING> ) [ 0 ] <NEWLINE> dir = os . path . join ( repo , <STRING> ) <NEWLINE> fd , tmplock = tempfile . mkstemp ( <STRING> , dir = dir ) <NEWLINE> try : <NEWLINE> <INDENT> os . close ( fd ) <NEWLINE> lockfile = os . path . join ( dir , <STRING> ) <NEWLINE> try : <NEWLINE> os . link ( tmplock , lockfile ) <NEWLINE> except OSError : <NEWLINE> raise YapError ( <STRING> ) <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> os . unlink ( tmplock ) <NEWLINE> <DEDENT> <DEDENT>
from smiles_parsers import Smiles , BuildMol <NEWLINE> from perception import RingDetection , BasicAromaticity , sssr <NEWLINE> def smilin ( smiles , transforms = [ sssr . sssr , <NEWLINE> <INDENT> BasicAromaticity . aromatize ] , <NEWLINE> enable_vfgraph = 0 ) : <NEWLINE> <STRING> <NEWLINE> builder = BuildMol . BuildMol ( enable_vfgraph ) <NEWLINE> Smiles . tokenize ( smiles , builder ) <NEWLINE> mol = builder . mol <NEWLINE> for transform in transforms : <NEWLINE> mol = transform ( mol ) <NEWLINE> for atom in mol . atoms : <NEWLINE> if not atom . has_explicit_hcount : <NEWLINE> atom . imp_hcount = atom . hcount - atom . explicit_hcount <NEWLINE> return mol <NEWLINE> <DEDENT>
def GenerateItems ( self , offset = 0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> index = 0 <NEWLINE> for x in super ( PackedVersionedCollection , self ) . GenerateItems ( ) : <NEWLINE> <INDENT> if index >= offset : <NEWLINE> <INDENT> yield x <NEWLINE> <DEDENT> index += 1 <NEWLINE> <DEDENT> for x in self . GenerateUncompactedItems ( <NEWLINE> <INDENT> max_reversed_results = self . MAX_REVERSED_RESULTS ) : <NEWLINE> if index >= offset : <NEWLINE> yield x <NEWLINE> index += 1 <NEWLINE> <DEDENT> <DEDENT>
def total_score ( filename ) : <NEWLINE> <INDENT> with open ( filename , mode = <STRING> ) as f : <NEWLINE> <INDENT> names = [ n [ 1 : - 1 ] for n in f . readline ( ) . split ( <STRING> ) ] <NEWLINE> names . sort ( ) <NEWLINE> return sum ( ( 1 + i ) * ( sum ( ord ( letter ) - ord ( <STRING> ) + 1 for letter in name ) ) for i , name in enumerate ( names ) <NEWLINE> <DEDENT> <DEDENT>
def _monitor ( self ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> for dp in self . datapaths . values ( ) : <NEWLINE> self . _request_stats ( dp ) <NEWLINE> hub . sleep ( 10 ) <NEWLINE> hub . sleep ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
def kd_sort ( elems , prop_func = ( lambda x : x ) , dir = <STRING> ) : <NEWLINE> <INDENT> elems . sort ( key = prop_func ) <NEWLINE> if dir == <STRING> or dir == <STRING> : <NEWLINE> elems . reverse ( ) <NEWLINE> <DEDENT>
def findvideosbyserver ( data , serverid ) : <NEWLINE> <INDENT> logger . info ( <STRING> ) <NEWLINE> encontrados = set ( ) <NEWLINE> devuelve = [ ] <NEWLINE> try : <NEWLINE> <INDENT> exec <STRING> + serverid <NEWLINE> exec <STRING> + serverid + <STRING> <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> logger . info ( <STRING> + serverid + <STRING> ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> logger . info ( <STRING> + serverid + <STRING> ) <NEWLINE> import traceback <NEWLINE> logger . info ( traceback . format_exc ( ) ) <NEWLINE> <DEDENT> return devuelve <NEWLINE> <DEDENT>
def sanitize_token ( self , token ) : <NEWLINE> <INDENT> token_type = token [ <STRING> ] <NEWLINE> if token_type in list ( tokenTypes . keys ( ) ) : <NEWLINE> <INDENT> token_type = tokenTypes [ token_type ] <NEWLINE> <DEDENT> if token_type in ( tokenTypes [ <STRING> ] , tokenTypes [ <STRING> ] , <NEWLINE> <INDENT> tokenTypes [ <STRING> ] ) : <NEWLINE> if token [ <STRING> ] in self . allowed_elements : <NEWLINE> return self . allowed_token ( token , token_type ) <NEWLINE> else : <NEWLINE> return self . disallowed_token ( token , token_type ) <NEWLINE> <DEDENT> elif token_type == tokenTypes [ <STRING> ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return token <NEWLINE> <DEDENT> <DEDENT>
def rastrigin_skew ( individual ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> N = len ( individual ) <NEWLINE> return 10 * N + sum ( ( 10 * x if x > 0 else x ) ** 2 <NEWLINE> <DEDENT>
class _SecureHTTPServer ( BaseHTTPServer . HTTPServer ) : <NEWLINE> <INDENT> def __init__ ( self , private_key_pem_filepath , cert_pem_filepath , <NEWLINE> <INDENT> binding = None , handler_cls = _SecureHTTPRequestHandler ) : <NEWLINE> if binding is None : <NEWLINE> binding = ( <STRING> , 1443 ) <NEWLINE> SocketServer . BaseServer . __init__ ( self , binding , handler_cls ) <NEWLINE> s = socket . socket ( self . address_family , self . socket_type ) <NEWLINE> self . socket = ssl . SSLSocket ( <NEWLINE> <INDENT> s , <NEWLINE> keyfile = private_key_pem_filepath , <NEWLINE> certfile = cert_pem_filepath ) <NEWLINE> self . server_bind ( ) <NEWLINE> self . server_activate ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def pack_bitmap_128 ( value ) : <NEWLINE> <INDENT> x = 0 l <NEWLINE> for y in value : <NEWLINE> <INDENT> x |= 1 << y <NEWLINE> <DEDENT> return struct . pack ( <STRING> , ( x >> 64 ) & MASK64 , x & MASK64 ) <NEWLINE> <DEDENT>
class AutoRestSwaggerBATFormDataServiceConfiguration ( Configuration ) : <NEWLINE> <INDENT> def __init__ ( <NEWLINE> <INDENT> self , base_url = None , filepath = None ) : <NEWLINE> if not base_url : <NEWLINE> base_url = <STRING> <NEWLINE> super ( AutoRestSwaggerBATFormDataServiceConfiguration , self ) . __init__ ( base_url , filepath ) <NEWLINE> self . user_agent = <STRING> <NEWLINE> <DEDENT> <DEDENT>
def make_each_machine_c ( machine_name , archs , functions , fcountlist , taglist , alignment ) : <NEWLINE> <INDENT> tempstring = <STRING> <NEWLINE> for arch in archs : <NEWLINE> <INDENT> tempstring += <STRING> + arch . swapcase ( ) + <STRING> <NEWLINE> <DEDENT> tempstring += <STRING> <NEWLINE> for func in functions : <NEWLINE> <INDENT> tempstring += <STRING> + func + <STRING> <NEWLINE> <DEDENT> tempstring += <STRING> <NEWLINE> tempstring += <STRING> % ( <NEWLINE> _make_each_machine_struct ( machine_name , archs + [ <STRING> ] , functions , fcountlist , taglist , alignment ) , <NEWLINE> _make_each_machine_struct ( machine_name , archs , functions , fcountlist , taglist , alignment ) <NEWLINE> <DEDENT>
class KategoriForm ( ModelForm ) : <NEWLINE> <INDENT> class Meta : <NEWLINE> model = Kategori <NEWLINE> <DEDENT>
def plugin_builder_function ( plugin_name , plugin_code ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = { } <NEWLINE> for funct_name in ( <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ) : <NEWLINE> funct = getattr ( plugin_code , funct_name , None ) <NEWLINE> if funct is not None : <NEWLINE> ret [ funct_name ] = funct <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT>
def get_footer ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> blocks , remainder = divmod ( self . offset , tarfile . RECORDSIZE ) <NEWLINE> self . offset = 0 l <NEWLINE> return <STRING> * ( tarfile . RECORDSIZE - remainder ) <NEWLINE> <DEDENT>
def handle ( self ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> data = self . request . recv ( 1024 ) <NEWLINE> if not data : <NEWLINE> break <NEWLINE> try : <NEWLINE> info = simplejson . loads ( data ) <NEWLINE> if info [ <STRING> ] == <STRING> : <NEWLINE> <INDENT> self . dowith_cmd_info ( info ) <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>
def _mysql_drop_constraint ( element , compiler , ** kw ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> constraint = element . element <NEWLINE> if isinstance ( constraint , ( schema . ForeignKeyConstraint , <NEWLINE> <INDENT> schema . PrimaryKeyConstraint <NEWLINE> schema . UniqueConstraint ) <NEWLINE> ) : <NEWLINE> return compiler . visit_drop_constraint ( element , ** kw ) <NEWLINE> <DEDENT> elif isinstance ( constraint , schema . CheckConstraint ) : <NEWLINE> <INDENT> raise NotImplementedError ( <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> raise NotImplementedError ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def recent ( request ) : <NEWLINE> <INDENT> return render ( request , <STRING> , { <NEWLINE> <INDENT> <STRING> : Signal . objects . filter ( status__in = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) . order_by ( <NEWLINE> <INDENT> <STRING> ) [ : 10 ] <NEWLINE> <DEDENT> <DEDENT> } ) <NEWLINE> <DEDENT>
def removed_same_coordinate ( verts ) : <NEWLINE> <INDENT> d = OrderedDict ( zip ( ( tuple ( v . co ) for v in verts ) , range ( len ( verts ) ) ) <NEWLINE> return [ verts [ i ] for i in d . values ( ) ] <NEWLINE> <DEDENT>
def visit_callmod ( self , node , ( l , args , r ) ) : <NEWLINE> <INDENT> if args : <NEWLINE> <INDENT> return lambda expr : Call ( expr , args [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return lambda expr : Call ( expr , [ ] ) <NEWLINE> <DEDENT> <DEDENT>
def __info__ ( self ) : <NEWLINE> <INDENT> info = [ ] <NEWLINE> info . append ( ( <STRING> , self . _bias ) ) <NEWLINE> info . append ( ( <STRING> , self . _centre ) <NEWLINE> info . append ( ( <STRING> , self . _widths ) ) <NEWLINE> return info <NEWLINE> <DEDENT>
def getFromRecentChanges ( ) : <NEWLINE> <INDENT> gen = pagegenerators . RecentchangesPageGenerator ( site = self . site ) <NEWLINE> ecart_minimal_requis = 30 <NEWLINE> for Page in pagegenerators . PreloadingGenerator ( gen , 100 ) : <NEWLINE> <INDENT> if debugLevel > 0 : <NEWLINE> <INDENT> print str ( lastEditTime ( Page ) ) + <STRING> + str ( ecart_minimal_requis ) <NEWLINE> <DEDENT> if lastEditTime ( Page ) > ecart_minimal_requis : <NEWLINE> <INDENT> c . creation ( Page . title ( ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def __undistort_chessboard_images ( self ) : <NEWLINE> <INDENT> if self . __is_stage_complete ( self . STAGE_COMPUTED_OBJ_AND_IMG_POINTS ) and not self . __is_stage_complete ( <NEWLINE> <INDENT> self . STAGE_UNDISTORED_CALIBRATION_IMAGES ) : <NEWLINE> for fname in self . __calibration_images : <NEWLINE> img = mpimg . imread ( fname ) <NEWLINE> undistorted = self . undistort ( img ) <NEWLINE> undist_file = <STRING> . format ( os . path . basename ( fname ) ) <NEWLINE> cv2 . imwrite ( undist_file , undistorted ) <NEWLINE> self . __apply_stage ( self . STAGE_UNDISTORED_CALIBRATION_IMAGES ) <NEWLINE> <DEDENT> <DEDENT>
def out ( t ) : <NEWLINE> <INDENT> integrator . fwdSeed ( <STRING> ) . set ( [ 1 , 0 ] ) <NEWLINE> <INDENT> integrator . evaluate ( 1 , 0 ) <NEWLINE> <DEDENT> A = integrator . fwdSens ( ) . toArray ( ) <NEWLINE> integrator . fwdSeed ( <STRING> ) . set ( [ 0 , 1 ] ) <NEWLINE> integrator . evaluate ( 1 , 0 ) <NEWLINE> B = integrator . fwdSens ( ) . toArray ( ) <NEWLINE> return array ( [ A , B ] ) . squeeze ( ) . T <NEWLINE> <DEDENT>
def _check_query ( self , query ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not ( self . word_re . match ( query ) or <NEWLINE> <INDENT> self . multiple_word_re . match ( query ) : <NEWLINE> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT>
def disneychannelGetStreamingUrl ( url ) : <NEWLINE> <INDENT> if debug == True : Log ( <STRING> ) <NEWLINE> try : <NEWLINE> content = getURL ( url ) <NEWLINE> match = re . compile ( <STRING> , re . DOTALL ) . findall ( content ) <NEWLINE> content = getURL ( match [ 0 ] ) <NEWLINE> match2 = re . compile ( <STRING> , re . DOTALL ) . findall ( content ) <NEWLINE> finalURL = <STRING> + match2 [ 0 ] <NEWLINE> return Redirect ( finalURL ) <NEWLINE> except Exception as e : <NEWLINE> <INDENT> if debug == True : Log ( <STRING> + str ( e ) ) <NEWLINE> <DEDENT> <DEDENT>
def get_metadata ( cls , video_id ) : <NEWLINE> <INDENT> url = <STRING> . format ( video_id ) <NEWLINE> try : <NEWLINE> <INDENT> response = requests . get ( url , params = { <NEWLINE> <INDENT> <STRING> : <STRING> <NEWLINE> <DEDENT> } ) <NEWLINE> return response . json ( ) <NEWLINE> <DEDENT> except RequestException , e : <NEWLINE> <INDENT> logger . warn ( <STRING> , e ) <NEWLINE> return { } <NEWLINE> <DEDENT> <DEDENT>
def _closedrepr ( oldmethod ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def newmethod ( self ) : <NEWLINE> <INDENT> if not self . _v_isopen : <NEWLINE> <INDENT> cmod = self . __class__ . __module__ <NEWLINE> cname = self . __class__ . __name__ <NEWLINE> addr = hex ( id ( self ) <NEWLINE> return <STRING> % ( cmod , cname , addr ) <NEWLINE> <DEDENT> return oldmethod ( self ) <NEWLINE> <DEDENT> newmethod . __name__ = oldmethod . __name__ <NEWLINE> newmethod . __doc__ = oldmethod . __doc__ <NEWLINE> return newmethod <NEWLINE> <DEDENT>
class Iload ( Instruction , PushInstruction ) : <NEWLINE> <INDENT> def __init__ ( self , line , variable ) : <NEWLINE> Instruction . __init__ ( self , line ) <NEWLINE> self . sourceLocal = variable <NEWLINE> PushInstruction . __init__ ( self ) <NEWLINE> <DEDENT>
class UT ( BaseChannel ) : <NEWLINE> <INDENT> playable = True <NEWLINE> short_name = <STRING> <NEWLINE> long_name = <STRING> <NEWLINE> default_action = <STRING> <NEWLINE> def action_play_stream ( self ) : <NEWLINE> self . plugin . set_stream_url ( <STRING> ) <NEWLINE> <DEDENT>
def overlaps ( ( u1 , v1 ) , ( u2 , v2 ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> assert u1 <= v1 <NEWLINE> assert u2 <= v2 <NEWLINE> return u1 <= v2 and v1 >= v2 <NEWLINE> <DEDENT>
def test_extended_arg ( self ) : <NEWLINE> <INDENT> longexpr = <STRING> + <STRING> * 2500 <NEWLINE> code = <STRING> % ( ( longexpr , ) * 10 ) <NEWLINE> exec code <NEWLINE> self . assertEqual ( f ( 5 ) , 0 ) <NEWLINE> <DEDENT>
class clear_impl : <NEWLINE> <INDENT> def __repr__ ( self ) : <NEWLINE> global _last_exc , _last_level , frame <NEWLINE> <INDENT> _last_exc = None <NEWLINE> frame = None <NEWLINE> <DEDENT> <DEDENT>
def check_requirements ( ) : <NEWLINE> <INDENT> for tool in [ <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ] : <NEWLINE> try : <NEWLINE> config_utils . get_program ( tool , { } ) <NEWLINE> print ( <STRING> % tool ) <NEWLINE> except Exception , e : <NEWLINE> print ( <STRING> % tool ) <NEWLINE> raise ( e ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
class NullDecoder ( AbstractSimpleDecoder ) : <NEWLINE> <INDENT> protoComponent = univ . Null ( <STRING> ) <NEWLINE> def valueDecoder ( self , fullSubstrate , substrate , asn1Spec , tagSet , <NEWLINE> <INDENT> length , state , decodeFun , substrateFun ) : <NEWLINE> head , tail = substrate [ : length ] , substrate [ length : ] <NEWLINE> r = self . _createComponent ( asn1Spec , tagSet ) <NEWLINE> if head : <NEWLINE> raise error . PyAsn1Error ( <STRING> % length ) <NEWLINE> return r , tail <NEWLINE> <DEDENT> <DEDENT>
def tryXorBreak ( ciphertext , distribution = English1Grams ) : <NEWLINE> <INDENT> return min ( [ <NEWLINE> { <STRING> : repKeyXor ( ciphertext , char ) , <STRING> : char } <NEWLINE> for char in allCharacters ] , <NEWLINE> key = lambda result : distribution . surprise ( str ( result [ <STRING> ] ) . lower ( ) ) <NEWLINE> <DEDENT>
def test_port_unbound ( self ) : <NEWLINE> <INDENT> map = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : [ ] , <NEWLINE> <STRING> : 1 } <NEWLINE> <DEDENT> net_uuid = <STRING> <NEWLINE> network_vswitch_map = ( net_uuid , map ) <NEWLINE> with mock . patch . object ( self . agent , <NEWLINE> <INDENT> <STRING> , <NEWLINE> return_value = network_vswitch_map ) : <NEWLINE> with mock . patch . object ( <NEWLINE> self . agent . _utils , <NEWLINE> <STRING> ) : <NEWLINE> self . agent . _port_unbound ( net_uuid ) <NEWLINE> <DEDENT> <DEDENT>
def test4_center ( self ) : <NEWLINE> <INDENT> self . t . set_align_mode ( <STRING> ) <NEWLINE> expected = [ B ( t ) for t in <STRING> , <STRING> ] <NEWLINE> got = self . t . render ( ( 18 , ) ) . _text <NEWLINE> assert got == expected , <STRING> % ( got , expected ) <NEWLINE> <DEDENT>
def _get_tables ( self ) : <NEWLINE> <INDENT> for names , table in [ ( self . _setting_table_names , self . setting_table ) , <NEWLINE> <INDENT> ( self . _variable_table_names , self . variable_table ) , <NEWLINE> ( self . _testcase_table_names , self . testcase_table ) , <NEWLINE> ( self . _keyword_table_names , self . keyword_table ) ] : <NEWLINE> for name in names : <NEWLINE> yield name , table <NEWLINE> <DEDENT> <DEDENT>
def worker ( virt ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> global exiting <NEWLINE> print ( <STRING> ) <NEWLINE> while not exiting : <NEWLINE> <INDENT> str = raw_input ( ) <NEWLINE> try : <NEWLINE> <INDENT> exec str <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> exc_type , exc_value , exc_traceback = sys . exc_info ( ) <NEWLINE> print ( <STRING> + <STRING> . join ( <NEWLINE> <INDENT> traceback . format_exception ( exc_type , <NEWLINE> <INDENT> exc_value , <NEWLINE> exc_traceback ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def reviewed_by ( cls , user ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> these_cases , other_cases = [ ] , [ ] <NEWLINE> for case in cls . query_under_review ( ) . run ( ) : <NEWLINE> <INDENT> if case . reviewer == user : <NEWLINE> these_cases . append ( case ) <NEWLINE> else : <NEWLINE> other_cases . append ( case ) <NEWLINE> <DEDENT> return these_cases , other_cases <NEWLINE> <DEDENT>
def handle_endtag ( self , tag ) : <NEWLINE> <INDENT> if not self . open_tags : <NEWLINE> <INDENT> self . error ( <STRING> % ( <NEWLINE> <INDENT> tag , self . format_position ( ) ) ) <NEWLINE> <DEDENT> <DEDENT> element = self . open_tags . pop ( ) <NEWLINE> while element . name != tag : <NEWLINE> <INDENT> if not self . open_tags : <NEWLINE> <INDENT> self . error ( <STRING> % ( <NEWLINE> <INDENT> tag , self . format_position ( ) ) <NEWLINE> <DEDENT> <DEDENT> element = self . open_tags . pop ( ) <NEWLINE> <DEDENT> <DEDENT>
def test_3_join_in_forked_from_thread ( self ) : <NEWLINE> <INDENT> import os <NEWLINE> if not hasattr ( os , <STRING> ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if sys . platform in ( <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> print ( <STRING> <NEWLINE> <INDENT> <STRING> ) , sys . platform <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> script = <STRING> <NEWLINE> self . _run_and_join ( script ) <NEWLINE> <DEDENT>
def disable_igmp ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> hpSwitchIgmpState = ( 1 , 3 , 6 , 1 , 4 , 1 , 11 , 2 , 14 , 11 , 5 , 1 , 7 , 1 , 15 , 1 , 1 , 2 ) <NEWLINE> <DEDENT> self . switch . snmp_set ( ( hpSwitchIgmpState + ( self . vid , ) , rfc1902 . Integer ( 2 ) ) ) <NEWLINE> <DEDENT>
def test_padding ( self ) : <NEWLINE> <INDENT> self . _test_format ( <STRING> , - 42 , grouping = 0 , out = <STRING> . rjust ( 20 ) ) <NEWLINE> self . _test_format ( <STRING> , - 4200 , grouping = 0 , out = <STRING> . rjust ( 10 ) ) <NEWLINE> self . _test_format ( <STRING> , 4200 , grouping = 0 , out = <STRING> . ljust ( 10 ) <NEWLINE> <DEDENT>
def retranslateUi ( self , ApplyCalleeDialog ) : <NEWLINE> <INDENT> ApplyCalleeDialog . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def test_add ( self ) : <NEWLINE> <INDENT> for i in range ( size * 2 ) : <NEWLINE> <INDENT> trans = generate_transition ( ) <NEWLINE> self . buffer . add ( * trans , , <NEWLINE> <DEDENT> self . assertTrue ( True ) <NEWLINE> <DEDENT>
def train ( PATH , batch , epochs ) : <NEWLINE> <INDENT> img = load_img ( PATH ) <NEWLINE> for epoch in range ( epochs ) : <NEWLINE> <INDENT> if ( epoch == 0 ) : <NEWLINE> <INDENT> if os . path . exist ( <STRING> ) ans os . path . exist ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> generator . load_weights ( <STRING> ) <NEWLINE> discriminator . load_weights ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def readline ( self size = - 1 ) : <NEWLINE> <INDENT> self . _empty_stderr ( ) <NEWLINE> return self . process . stdout . readline ( size ) <NEWLINE> <DEDENT>
def _after_request_callback ( self , exc , permid ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not exc : <NEWLINE> <INDENT> if DEBUG : print <STRING> , show_permid_short ( permid ) <NEWLINE> msg = <STRING> . join ( [ <STRING> , show_permid ( permid ) ] ) <NEWLINE> self . __log ( msg ) <NEWLINE> <DEDENT> <DEDENT>
def test_connection ( self ) : <NEWLINE> <INDENT> engine = self . _connect ( ) <NEWLINE> list ( engine . connection . list_tables ( ) ) ) <NEWLINE> <DEDENT>
def get_branch ( self ) : <NEWLINE> <INDENT> if not self . ov_list : <NEWLINE> <INDENT> self . _get_ov_list ( ) <NEWLINE> <DEDENT> branches = [ ] <NEWLINE> for ov in self . ov_list : <NEWLINE> <INDENT> branches [ ov [ <STRING> ] ] = ov [ <STRING> ] <NEWLINE> if self . type == <STRING> : <NEWLINE> return ( XEbuildGit . get_branch ( self ) , branches ) <NEWLINE> else : <NEWLINE> return ( XEbuildHG . get_branch ( self ) , branches ) <NEWLINE> <DEDENT> <DEDENT>
def OnSDLNotify ( self , VARname , SDLname , playerID , tag ) : <NEWLINE> <INDENT> ageSDL = PtGetAgeSDL ( ) <NEWLINE> print ( <STRING> , VARname , <STRING> , ageSDL [ VARname ] [ 0 ] ) <NEWLINE> if VARname == <STRING> : <NEWLINE> <INDENT> ButtonsPushed = ageSDL [ <STRING> ] [ 0 ] <NEWLINE> if ButtonsPushed == 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> ButtonsPushed = str ( ButtonsPushed ) <NEWLINE> lastbuttonpushed = ButtonsPushed [ - 1 : ] <NEWLINE> print ( <STRING> , ButtonsPushed ) <NEWLINE> code = <STRING> + str ( lastbuttonpushed ) + <STRING> <NEWLINE> exec code <NEWLINE> code = <STRING> + str ( lastbuttonpushed ) + <STRING> <NEWLINE> exec code <NEWLINE> <DEDENT> <DEDENT>
def test_datetime ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> msg_id = self . db . get_history ( ) [ - 1 ] <NEWLINE> rec = self . db . get_record ( msg_id ) <NEWLINE> self . assertTrue ( isinstance ( rec [ <STRING> ] , datetime ) <NEWLINE> self . db . update_record ( msg_id , dict ( completed = datetime . now ( ) ) ) <NEWLINE> rec = self . db . get_record ( msg_id ) <NEWLINE> self . assertTrue ( isinstance ( rec [ <STRING> ] , datetime ) ) <NEWLINE> <DEDENT>
def getFromAllRedirects ( self ) : <NEWLINE> <INDENT> for Page in self . site . allpages ( start = <STRING> , namespace = 0 , includeredirects = <STRING> ) : <NEWLINE> <INDENT> if debugLevel > 0 : print Page . title ( ) <NEWLINE> c . creation ( Page . title ( ) ) <NEWLINE> <DEDENT> <DEDENT>
def updateFunction ( newValues , runningCount ) : <NEWLINE> <INDENT> if runningCount is None : <NEWLINE> runningCount = 0 <NEWLINE> return sum ( newValues , runningCount ) <NEWLINE> <DEDENT>
def _op_generic_StoU_saturation ( self , value , min_value , max_value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return claripy . If ( <NEWLINE> <INDENT> claripy . SGT ( value , max_value ) <NEWLINE> max_value , <NEWLINE> claripy . If ( claripy . SLT ( value , min_value ) , min_value , value ) ) <NEWLINE> <DEDENT> <DEDENT>
def retranslateUi ( self , fmtomo_parameters ) : <NEWLINE> <INDENT> fmtomo_parameters . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_19 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_17 . setToolTip ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label_17 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
class UpdateLoc ( webapp2 . RequestHandler ) : <NEWLINE> <INDENT> def post ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . userKey = ndb . Key ( urlsafe = self . request . get ( <STRING> ) ) <NEWLINE> self . user = self . userKey . get ( ) <NEWLINE> if ( self . user is None ) : <NEWLINE> <INDENT> self . response . write ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . response . write ( self . user . firstName ) <NEWLINE> <DEDENT> <DEDENT> except Exception , e : <NEWLINE> <INDENT> self . response . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def unionRect ( ( xMin1 , yMin1 , xMax1 , yMax1 ) , ( xMin2 , yMin2 , xMax2 , yMax2 ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> xMin , yMin , xMax , yMax = ( min ( xMin1 , xMin2 ) , min ( yMin1 , yMin2 ) , <NEWLINE> <INDENT> max ( xMax1 , xMax2 ) , max ( yMax1 , yMax2 ) ) <NEWLINE> <DEDENT> return ( xMin , yMin , xMax , yMax ) <NEWLINE> <DEDENT>
def _resetQ ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> loop0 = 0 <NEWLINE> loop1 = 0 <NEWLINE> loop2 = 0 <NEWLINE> for loop0 in range ( 200 ) : <NEWLINE> <INDENT> for loop1 in range ( 200 ) : <NEWLINE> for loop2 in range ( self . actions ) : <NEWLINE> <INDENT> self . QL [ loop0 , loop1 , loop2 ] = random . random ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def database_exists ( database_name , ** options ) : <NEWLINE> <INDENT> db = options . get ( <STRING> , DEFAULT_DB_ALIAS ) <NEWLINE> try : <NEWLINE> <INDENT> connection = connections [ db ] <NEWLINE> with connection . cursor ( ) as cursor : <NEWLINE> <INDENT> cursor . execute ( <STRING> . format ( database_name ) ) <NEWLINE> return_value = bool ( cursor . fetchone ( ) <NEWLINE> <DEDENT> connections . close_all ( ) <NEWLINE> return return_value <NEWLINE> <DEDENT> except OperationalError : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT>
def run ( ) : <NEWLINE> <INDENT> plugintools . log ( <STRING> ) <NEWLINE> params = plugintools . get_params ( ) <NEWLINE> if params . get ( <STRING> ) is None : <NEWLINE> <INDENT> main_list ( params ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> action = params . get ( <STRING> ) <NEWLINE> exec action + <STRING> <NEWLINE> <DEDENT> plugintools . close_item_list ( ) <NEWLINE> <DEDENT>
def TerminatorThread ( long maxExecutionTime , list threads , Workload workload ) : <NEWLINE> <INDENT> this . maxExecutionTime = maxExecutionTime <NEWLINE> this . threads = threads <NEWLINE> this . workload = workload <NEWLINE> waitTimeOutInMS = 2000 ; <NEWLINE> print ( <STRING> + maxExecutionTime + <STRING> ) <NEWLINE> <DEDENT>
class TestObject ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . v = self . add ( ) <NEWLINE> <DEDENT> def add ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def _objectIdsToUsers ( self , ( users , ids ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ids : <NEWLINE> <INDENT> log . err ( <STRING> % ( ids , ) ) <NEWLINE> <DEDENT> return { <NEWLINE> <INDENT> <STRING> : { <NEWLINE> <INDENT> <STRING> : True , <NEWLINE> <STRING> : users } } <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def load_tensor_from_event ( event ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( event . summary . value [ 0 ] . tensor . tensor_content or <NEWLINE> <INDENT> event . summary . value [ 0 ] . tensor . string_val ) : <NEWLINE> tensor_proto = event . summary . value [ 0 ] . tensor <NEWLINE> if tensor_proto . dtype == types_pb2 . DT_RESOURCE : <NEWLINE> return None <NEWLINE> else : <NEWLINE> try : <NEWLINE> <INDENT> tensor_value = tensor_util . MakeNdarray ( tensor_proto ) <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> tensor_value = None <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tensor_value = None <NEWLINE> <DEDENT> return tensor_value <NEWLINE> <DEDENT>
def reduction ( before , after , cutoff = 0.35 ) : <NEWLINE> <INDENT> if isinstance ( after , str ) : <NEWLINE> try : <NEWLINE> if float ( after ) == 0.0 : <NEWLINE> <INDENT> return False <NEWLINE> except : <NEWLINE> <DEDENT> return False <NEWLINE> if float ( after ) == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> temp = ( before - after ) / before <NEWLINE> return ( temp > cutoff ) <NEWLINE> <DEDENT>
def search ( self , query , page = 1 , pageSize = 30 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> url = self . _urlHelper ( self . SEARCH_ENDPOINT , q = query , page = page , count = pageSize ) <NEWLINE> contents = self . _getUrlContents ( url ) <NEWLINE> data = json . loads ( contents ) <NEWLINE> if ( self . debugMode ) : print contents <NEWLINE> return data <NEWLINE> <DEDENT> except Exception as inst : <NEWLINE> <INDENT> if ( self . debugMode ) : print inst <NEWLINE> return None <NEWLINE> <DEDENT> <DEDENT>
def getAndSaveTweet ( count , page ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> for single_page in tweepy . Cursor ( twitter_map_config . twitter_api . search , <NEWLINE> <INDENT> q = <STRING> , <NEWLINE> count = count , <NEWLINE> result_type = <STRING> , <NEWLINE> include_entities = True , <NEWLINE> lang = <STRING> ) . pages ( page ) : <NEWLINE> for tweet in single_page : <NEWLINE> res = putTweetToDataStore ( tweet ) <NEWLINE> if res == - 1 : <NEWLINE> raise ValueError ( res ) <NEWLINE> <DEDENT> <DEDENT> except Exception , e : <NEWLINE> <INDENT> print ( e ) <NEWLINE> print ( <STRING> ) <NEWLINE> return - 1 <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <DEDENT>
def __is_bad_pick ( t_planet , pl_list ) : <NEWLINE> <INDENT> if ( t_planet . x + t_planet . rad >= DISP_W - 1 ) or ( t_planet . x - t_planet . rad <= 0 ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if ( t_planet . y + self . rad >= DISP_H - 1 ) or ( t_planet . y - self . rad <= BORDER_UP ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> for oth_planet in pl_list : <NEWLINE> <INDENT> if t_planet . overlaps ( self . __overlaps ( t_planet ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>
def __setitem__ ( self , ( i , j ) , value ) : <NEWLINE> <INDENT> if self . arr [ i ] == None : <NEWLINE> <INDENT> self . arr [ i ] = [ 0 ] * self . NO_COLS <NEWLINE> <DEDENT> self . arr [ i ] [ j ] = value <NEWLINE> <DEDENT>
def print_matrix ( matr ) : <NEWLINE> <INDENT> for row in matr : <NEWLINE> <INDENT> print ( <STRING> , <NEWLINE> for ent in row : <NEWLINE> <INDENT> print ( <STRING> % ent , ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class ValueConstant ( _ValueConstant ) : <NEWLINE> <INDENT> def __cmp__ ( self , other ) : <NEWLINE> <INDENT> return cmp ( self . value , ( other . value if isinstance ( other , ValueConstant ) else other ) <NEWLINE> <DEDENT> <DEDENT>
def update_bandwidth_xml ( iface , vnicXML , specParams = None ) : <NEWLINE> <INDENT> if ( specParams and <NEWLINE> <INDENT> ( <STRING> in specParams or <STRING> in specParams ) ) : <NEWLINE> oldBandwidth = vmxml . find_first ( vnicXML , <STRING> , None ) <NEWLINE> newBandwidth = iface . get_bandwidth_xml ( specParams , oldBandwidth ) <NEWLINE> if oldBandwidth is not None : <NEWLINE> vmxml . remove_child ( vnicXML , oldBandwidth ) <NEWLINE> vmxml . append_child ( vnicXML , newBandwidth ) <NEWLINE> <DEDENT> <DEDENT>
[ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> <NEWLINE> <DEDENT> return generate_smb_proto_payload ( netbios , smb_header , tran_request ) <NEWLINE> <DEDENT>
def test_rank_one_tensor_raises_if_rank_too_large_dynamic_rank ( self ) : <NEWLINE> <INDENT> with self . test_session ( ) : <NEWLINE> <INDENT> tensor = array_ops . placeholder ( dtypes . float32 , name = <STRING> ) <NEWLINE> desired_rank = 0 <NEWLINE> with ops . control_dependencies ( <NEWLINE> <INDENT> [ check_ops . assert_rank ( tensor , desired_rank ) ] ) : <NEWLINE> with self . assertRaisesOpError ( <STRING> ) : <NEWLINE> array_ops . identity ( tensor ) . eval ( feed_dict = { tensor : [ 1 , 2 ] } ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_perpendicular_back_direction ( self , direction ) : <NEWLINE> <INDENT> if not ( direction == <STRING> or direction == <STRING> ) : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> if direction == <STRING> : <NEWLINE> return <STRING> <NEWLINE> else : <NEWLINE> return <STRING> <NEWLINE> <DEDENT> <DEDENT>
class ProcessGroup ( models . Model ) : <NEWLINE> <INDENT> name = models . CharField ( <NEWLINE> <INDENT> verbose_name = _ ( <STRING> ) , <NEWLINE> max_length = 100 , <NEWLINE> blank = false , <NEWLINE> unique = True , <NEWLINE> null = True ) <NEWLINE> description = models . TextField ( <NEWLINE> verbose_name = _ ( <STRING> ) , <NEWLINE> blank = True , help_text = _ ( <STRING> ) ) <NEWLINE> <DEDENT> objects = ProcessGroupManager ( ) <NEWLINE> class Meta : <NEWLINE> <INDENT> verbose_name = _ ( <STRING> ) <NEWLINE> verbose_name_plural = _ ( <STRING> ) <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return self . name <NEWLINE> <DEDENT> <DEDENT>
( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>
def main ( request , response ) : <NEWLINE> <INDENT> headers = [ ( <STRING> , <STRING> ) ] <NEWLINE> test = request . GET . first ( <STRING> ) <NEWLINE> assert ( re . match ( <STRING> , test ) ; <NEWLINE> if test . find ( <STRING> ) >= 0 : <NEWLINE> <INDENT> status = 200 <NEWLINE> content = <STRING> % test <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> status = 404 <NEWLINE> content = <STRING> % test <NEWLINE> <DEDENT> return status , headers , content <NEWLINE> <DEDENT>
def apm_enc_data ( keyfile , data ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> key = M2Crypto . RSA . load_pub_key ( keyfile ) <NEWLINE> <INDENT> cdata = key . public_encrypt ( data , M2Crypto . RSA . pkcs1_padding ) <NEWLINE> <DEDENT> return base64 . encodestring ( cdata ) <NEWLINE> except : <NEWLINE> return <STRING> <NEWLINE> <DEDENT> <DEDENT>
def get_ordered_fields ( resource_id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> data = { <STRING> : resource_id , <STRING> : 0 } <NEWLINE> try : <NEWLINE> <INDENT> result = p . toolkit . get_action ( <STRING> ) ( { } , data ) <NEWLINE> <DEDENT> except NotFound : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ f [ <STRING> ] for f in result [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT>
def logfilename ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> return <STRING> + yesterday ( ) + <STRING> % ( ConfigSectionMap ( <STRING> ) [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT>
def _get_homedirs ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> result = [ ] <NEWLINE> for artifact_hit in self . session . plugins . artifact_collector ( <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> for hit_result in artifact_hit . get ( <STRING> , [ ] ) : <NEWLINE> profile_path = hit_result . get ( <STRING> ) <NEWLINE> if profile_path : <NEWLINE> <INDENT> result . append ( profile_path ) <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <DEDENT>
def test_clone_unknown_subprocess_error ( mocker , clone_dir ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> mocker . patch ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> autospec = True <NEWLINE> side_effect = [ subprocess . CalledProcessError ( <NEWLINE> <INDENT> - 1 , <STRING> , output = <STRING> <NEWLINE> <DEDENT> ) ] <NEWLINE> <DEDENT> ) <NEWLINE> with pytest . raises ( subprocess . CalledProcessError ) : <NEWLINE> <INDENT> vcs . clone ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> clone_to_dir = clone_dir , <NEWLINE> no_input = True <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> <DEDENT>
def help_fix ( self ) : <NEWLINE> <INDENT> print ( _ ( <STRING> ) <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> print <NEWLINE> print ( _ ( <STRING> ) ) <NEWLINE> print ( _ ( <STRING> ) <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> print <NEWLINE> print ( _ ( <STRING> ) ) <NEWLINE> <DEDENT>
def log_user_out ( ) : <NEWLINE> <INDENT> f = open ( <STRING> , <STRING> ) <NEWLINE> uid = f . read ( ) <NEWLINE> mydata = [ ( <STRING> , uid ) ] <NEWLINE> mydata = urllib . urlencode ( mydata ) <NEWLINE> path = <STRING> <NEWLINE> <INDENT> req = urllib2 . Request ( path , mydata ) <NEWLINE> req . add_header ( <STRING> , <STRING> ) <NEWLINE> response = urllib2 . urlopen ( req ) . read ( ) <NEWLINE> <DEDENT> <DEDENT>
def AjaxRelationleft ( request ) : <NEWLINE> <INDENT> global rlist <NEWLINE> rlist = { } <NEWLINE> idenid = request . GET [ <STRING> ] <NEWLINE> rts = Relationtype . objects . filter ( id = idenid ) <NEWLINE> for each in rts : <NEWLINE> <INDENT> subj = str ( each . left_subjecttype . title ) <NEWLINE> appltype = each . left_applicable_nodetypes <NEWLINE> fnname = <STRING> + appltype + <STRING> + subj + <STRING> <NEWLINE> exec fnname <NEWLINE> <DEDENT> returndict = rlist <NEWLINE> jsonobject = json . dumps ( returndict ) <NEWLINE> return HttpResponse ( jsonobject , <STRING> ) <NEWLINE> <DEDENT>
def open_settings ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> exec <STRING> + PLATFORM_NAME + <STRING> <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> exec <STRING> + PLATFORM_NAME + <STRING> <NEWLINE> <DEDENT> return platformconfig . open_settings ( ) <NEWLINE> <DEDENT>
def produced_quantity ( product_name , file_id ) : <NEWLINE> <INDENT> for ( id , ) in db_session . query ( Product . id ) . filter_by ( <NEWLINE> <INDENT> product_name = product_name ) : <NEWLINE> for ( produced_quantity , ) in db_session . query ( <NEWLINE> <INDENT> ProductInFile . produced_quantity ) . filter_by ( <NEWLINE> product_id = id , input_file_id = file_id ) : <NEWLINE> <DEDENT> return produced_quantity <NEWLINE> <DEDENT> <DEDENT>
def dfs ( node , val ) : <NEWLINE> <INDENT> if node != none : <NEWLINE> <INDENT> if node . data == val <NEWLINE> <INDENT> return node . data <NEWLINE> <DEDENT> dfs ( node . left ) <NEWLINE> dfs ( node . right ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT>
class Pemasukan ( models . Model ) : <NEWLINE> <INDENT> user = models . ForeignKey ( User ) <NEWLINE> nama = models . CharField ( max_length = 255 ) <NEWLINE> kategori = models . ForeignKey ( <STRING> ) <NEWLINE> tgl_buat = models . DateTimeField ( auto_now_add = True ) <NEWLINE> jumlah = models . PositiveIntegerField ( ) <NEWLINE> keterangan = models . TextField ( blank = True , null = True ) <NEWLINE> class Meta : <NEWLINE> verbose_name_plural = <STRING> <NEWLINE> verbose_name = <STRING> <NEWLINE> def __unicode__ ( self ) : <NEWLINE> return self . nama <NEWLINE> <DEDENT>
class Ui_MainProcess_dock ( object ) : <NEWLINE> <INDENT> def setupUi ( self , MainProcess_dock ) : <NEWLINE> <INDENT> MainProcess_dock . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> MainProcess_dock . resize ( 374 , 516 ) <NEWLINE> MainProcess_dock . setMinimumSize ( QtCore . QSize ( 374 , 500 ) ) <NEWLINE> MainProcess_dock . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
def orig_instruction_to_function_map ( mapfile ) : <NEWLINE> <INDENT> m = { } <NEWLINE> for line in open ( mapfile , <STRING> ) : <NEWLINE> ( addr_16 , fun ) = line . split ( <STRING> ) <NEWLINE> m [ int ( addr_16 , base = 16 ) ] = fun <NEWLINE> return m <NEWLINE> <DEDENT>
def test_simple_c_code ( ) : <NEWLINE> <INDENT> x , y , z = symbols ( <STRING> ) <NEWLINE> expr = ( x + y ) * z <NEWLINE> routine = Routine ( <STRING> , [ InputArgument ( symbol ) for symbol in x , y , z ] , [ Result ( expr ) ] ) <NEWLINE> code_gen = CCodeGen ( ) <NEWLINE> source = get_string ( code_gen . dump_c , [ routine ] ) <NEWLINE> expected = ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> assert source == expected <NEWLINE> <DEDENT>
def score_numeric ( omega_a , omega_b ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> delta = min ( abs ( omega_a - omega_b ) , 2 * pi - abs ( omega_a - omega_b ) <NEWLINE> score = pi / 4 - delta ; <NEWLINE> return score <NEWLINE> <DEDENT>
def setup_env ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> resource . setrlimit ( resource . RLIMIT_NOFILE , <NEWLINE> <INDENT> ( MAX_DESCRIPTORS , MAX_DESCRIPTORS ) ) <NEWLINE> <DEDENT> resource . setrlimit ( resource . RLIMIT_DATA , <NEWLINE> <INDENT> ( MAX_MEMORY , MAX_MEMORY ) ) <NEWLINE> <DEDENT> <DEDENT> except ValueError : <NEWLINE> <INDENT> print ( _ ( <STRING> ) <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> os . environ . setdefault ( <STRING> , <STRING> ) <NEWLINE> <DEDENT>
def test_query_query__facet_group_off2 ( self ) : <NEWLINE> <INDENT> qm = SolrQueryManager ( FakeSolrDoc ) <NEWLINE> qm = qm . filter ( id__eq = 999 ) . group_by ( <STRING> , group_limit = 2 ) params = qm . query <NEWLINE> assert <STRING> not in params <NEWLINE> <DEDENT>
def validate_password ( password , user = None , password_validators = None ) <NEWLINE> <INDENT> <STRING> <NEWLINE> errors = [ ] <NEWLINE> if password_validators is None : <NEWLINE> <INDENT> password_validators = get_default_password_validators ( ) <NEWLINE> <DEDENT> for validator in password_validators : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> validator . validate ( password , user ) <NEWLINE> <DEDENT> except ValidationError as error : <NEWLINE> <INDENT> errors . append ( error ) <NEWLINE> <DEDENT> <DEDENT> if errors : <NEWLINE> <INDENT> raise ValidationError ( errors ) <NEWLINE> <DEDENT> <DEDENT>
( <STRING> % ( count , i + 1 ) , <NEWLINE> print ( <STRING> * 9 % tuple ( decode_rotation ( total % ( 3 ** 9 ) ) ) , ) <NEWLINE> print ( <STRING> % tuple ( decode_trans ( total // ( 3 ** 9 ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def __set__ ( self , instance , value ) : <NEWLINE> <INDENT> if instance is None : <NEWLINE> <INDENT> raise AttributeError , <STRING> <NEWLINE> <DEDENT> manager = self . __get__ ( instance ) <NEWLINE> if self . related . field . null : <NEWLINE> <INDENT> manager . clear ( ) <NEWLINE> <DEDENT> manager . add ( * value ) <NEWLINE> <DEDENT>
from rest_framework import mixins <NEWLINE> from rest_framework . exceptions import APIException <NEWLINE> from rest_framework . viewsets import GenericViewSet <NEWLINE> from hptrivia_app . models import Question <NEWLINE> from serializers import QuestionSerializer <NEWLINE> class QuestionViewSet ( mixins . RetrieveModelMixin , <NEWLINE> <INDENT> mixins . UpdateModelMixin , <NEWLINE> mixins . ListModelMixin , <NEWLINE> GenericViewSet ) : <NEWLINE> model = Question <NEWLINE> lookup_field = <STRING> <NEWLINE> serializer_class = QuestionSerializer <NEWLINE> def get_queryset ( self ) : <NEWLINE> return Question . objects . all ( ) <NEWLINE> <DEDENT>
def update ( i , one ) : <NEWLINE> <INDENT> for n , ( lo , hi , new ) in enumerate ( zip ( i . lo , i . hi , <NEWLINE> <INDENT> i . value ( one ) ) ) : <NEWLINE> if new > hi : <NEWLINE> i . hi [ n ] = new <NEWLINE> if new < lo : <NEWLINE> i . lo [ n ] = new <NEWLINE> <DEDENT> <DEDENT>
def get_name ( self , width = <STRING> , context = <STRING> ) : <NEWLINE> <INDENT> names = i18n . get_day_names ( <NEWLINE> <INDENT> width , <NEWLINE> context , <NEWLINE> , <NEWLINE> i18n . get_locale ( ) <NEWLINE> <DEDENT> ) <NEWLINE> return names [ self . index ] <NEWLINE> <DEDENT>
def getColNames ( self , tablename ) : <NEWLINE> <INDENT> if ( tablename == <STRING> ) : <NEWLINE> if self . next_tbl_schema == <STRING> : <NEWLINE> <INDENT> colNames = [ <STRING> , <STRING> ] <NEWLINE> else : <NEWLINE> colNames = self . next_tbl_schema . split ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> colNames = [ ] <NEWLINE> <DEDENT> return colNames <NEWLINE> <DEDENT>
def b1282int ( st ) : <NEWLINE> <INDENT> oneHundredAndTwentyEight = 128 l <NEWLINE> i = 0 <NEWLINE> place = 0 <NEWLINE> for char in st : <NEWLINE> <INDENT> num = ord ( char ) <NEWLINE> i = i + ( num * ( oneHundredAndTwentyEight ** place ) ) <NEWLINE> place = place + 1 <NEWLINE> <DEDENT> if i <= 2147483647 : <NEWLINE> <INDENT> return int ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT>
def test_processor_xml_parsing ( self ) : <NEWLINE> <INDENT> oob_processor = CameraOutOfBandProcessor ( ) <NEWLINE> self . assertIsNotNone ( oob_processor ) <NEWLINE> self . assertFalse ( oob_processor . parse_oob_xml ( None ) ) <NEWLINE> oob = unittest . mock . Mock ( ) <NEWLINE> oob . text = None <NEWLINE> self . assertFalse ( oob_processor . parse_oob_xml ( oob ) <NEWLINE> oob = unittest . mock . Mock ( ) <NEWLINE> oob . text = <STRING> <NEWLINE> self . assertTrue ( oob_processor . parse_oob_xml ( oob ) ) <NEWLINE> <DEDENT>
def __init__ ( self plugin ) : <NEWLINE> <INDENT> super ( NECPluginV2RPCCallbacks , self ) . __init__ ( ) <NEWLINE> self . plugin = plugin <NEWLINE> <DEDENT>
( binascii . unhexlify ( flag ) <NEWLINE> <DEDENT>
def TestExit ( self ) : <NEWLINE> <INDENT> self . write ( <STRING> ) ; <NEWLINE> <INDENT> self . BackspaceNL ( 2 ) <NEWLINE> <DEDENT> self . read ( length = 8 , expect = <STRING> ) <NEWLINE> <DEDENT>
def test_callback ( self ) : <NEWLINE> <INDENT> with patch ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> ) as draugiem_complete_login : <NEWLINE> self . mock_socialaccount_state ( ) <NEWLINE> response_json = self . get_draugiem_login_response ( ) <NEWLINE> token = SocialToken ( app = self . app , token = response_json [ <STRING> ] ) <NEWLINE> login = self . get_socialaccount ( response_json , token ) <NEWLINE> draugiem_complete_login . return_value = login <NEWLINE> response = self . client . get ( <NEWLINE> reverse ( views . callback ) , <NEWLINE> { <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> } ) <NEWLINE> self . assertRedirects ( response , <STRING> , <NEWLINE> <INDENT> fetch_redirect_response = False ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
npixels = width * height <NEWLINE> <INDENT> if len ( message_bits ) > npixels * 3 : <NEWLINE> <INDENT> raise Exception ( <STRING> % ( len ( message_bits ) , npixels * 3 ) ) <NEWLINE> <DEDENT> <DEDENT>
def get_egg_info_files ( sp_dir ) : <NEWLINE> <INDENT> for fn in os . listdir ( sp_dir ) : <NEWLINE> <INDENT> if not fn . endswith ( ( <STRING> , <STRING> , <STRING> ) ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> path = join ( sp_dir , fn ) <NEWLINE> if isfile ( path ) : <NEWLINE> <INDENT> yield path <NEWLINE> <DEDENT> elif isdir ( path ) : <NEWLINE> <INDENT> for path2 in [ join ( path , <STRING> ) , <NEWLINE> <INDENT> join ( path , <STRING> , <STRING> ) , <NEWLINE> join ( path , <STRING> ) ] : <NEWLINE> if isfile ( path2 ) : <NEWLINE> yield path2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def parallel_coutputs ( model , data , parallel = multiprocessing . cpu_count ( ) , verbose = 1 ) : <NEWLINE> <INDENT> results = [ None ] * len ( data ) <NEWLINE> for i , j , outs in common . parallel_map ( coutputs_chunk , datachunks ( data , model = model ) , parallel = parallel ) : <NEWLINE> <INDENT> if verbose : print <STRING> , i , j , <STRING> % parallel <NEWLINE> for k in range ( j - i ) : results [ i + k ] = outs [ k ] <NEWLINE> <DEDENT> return results <NEWLINE> <DEDENT>
def draw_rectangle ( self , ( point1 , point2 ) , width = 1 , color = <STRING> ) : <NEWLINE> <INDENT> ( x1 , y1 ) = self . pixel_from_point ( point1 ) <NEWLINE> ( x2 , y2 ) = self . pixel_from_point ( point2 ) <NEWLINE> self . canvas . create_rectangle ( x1 , y1 , x2 , y2 , fill = color , width = 2 ) <NEWLINE> <DEDENT>
def ftpFetchFile ( self ) : <NEWLINE> <INDENT> offset = 0 <NEWLINE> if self . file is None : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . file , offset = self . openFile ( ) <NEWLINE> <DEDENT> except IOError , ie : <NEWLINE> <INDENT> self . connectionFailed ( ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> offset = self . resume and offset or 0 <NEWLINE> d = self . ftpclient . retrieveFile ( self . path , self , offset = offset ) <NEWLINE> d . addCallback ( self . ftpFinish ) . addErrback ( self . connectionFailed ) <NEWLINE> <DEDENT>
def suite ( ) : <NEWLINE> <INDENT> suite = unittest . TestSuite ( ) <NEWLINE> suite . addTest ( TestProjectToDiscreteGenotype ( <STRING> ) ) <NEWLINE> suite . addTest ( TestProjectToDiscreteGenotype ( <STRING> ) <NEWLINE> suite . addTest ( TestCountHomozigotes ( <STRING> ) ) <NEWLINE> suite . addTest ( TestGenerateData ( <STRING> ) ) <NEWLINE> return suite <NEWLINE> <DEDENT>
def troveBuilt ( self , ( jobId , troveTuple ) , binaryTroveList ) : <NEWLINE> <INDENT> self . _hadEvent = True <NEWLINE> t = self . job . getTrove ( * troveTuple ) <NEWLINE> self . server . stopTroveLogger ( t ) <NEWLINE> t . troveBuilt ( binaryTroveList ) <NEWLINE> t . own ( ) <NEWLINE> <DEDENT>
def _cbLogin ( self , ( iface , avatar , logout ) ) : <NEWLINE> <INDENT> assert iface is iwords . IUser , <STRING> % ( iface , ) <NEWLINE> del self . irc_PRIVMSG <NEWLINE> self . avatar = avatar <NEWLINE> self . logout = logout <NEWLINE> self . realm = avatar . realm <NEWLINE> self . hostname = self . realm . name <NEWLINE> info = { <NEWLINE> <INDENT> <STRING> : self . hostname , <NEWLINE> <STRING> : copyright . version , <NEWLINE> <STRING> : ctime ( ) , <NEWLINE> } <NEWLINE> <DEDENT> for code , text in self . _welcomeMessages : <NEWLINE> <INDENT> self . sendMessage ( code , text % info ) <NEWLINE> <DEDENT> <DEDENT>
class TestHeadsUp ( unittest . TestCase ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def versus_test ( self , player_1 , player_2 , expected_actions1 , <NEWLINE> <INDENT> expected_actions2 , random_seed = None ) : <NEWLINE> <STRING> <NEWLINE> if random_seed : <NEWLINE> random . seed ( random_seed ) <NEWLINE> for outcome_1 , outcome_2 in zip ( expected_actions1 , expected_actions2 ) : <NEWLINE> player_1 . play ( player_2 ) <NEWLINE> self . assertEqual ( player_1 . history [ - 1 ] , outcome_1 ) <NEWLINE> self . assertEqual ( player_2 . history [ - 1 ] , outcome_2 ) <NEWLINE> <DEDENT> <DEDENT>
def test_get_coord_connected ( self ) : <NEWLINE> <INDENT> geocode . connect ( ) <NEWLINE> coords = geocode . code ( <STRING> ) <NEWLINE> self . assertTrue ( isinstance ( coords , dict ) <NEWLINE> self . assertTrue ( <STRING> in coords ) <NEWLINE> self . assertTrue ( <STRING> in coords ) <NEWLINE> <DEDENT>
def mnemonic_to_seed ( self , mnemonic , passphrase ) : <NEWLINE> <INDENT> import pbkdf2 , hashlib , hmac <NEWLINE> PBKDF2_ROUNDS = 2048 <NEWLINE> mnemonic = unicodedata . normalize ( <STRING> , <STRING> . join ( mnemonic . split ( ) ) <NEWLINE> passphrase = unicodedata . normalize ( <STRING> , passphrase ) <NEWLINE> return pbkdf2 . PBKDF2 ( mnemonic , <STRING> + passphrase , iterations = PBKDF2_ROUNDS , macmodule = hmac , digestmodule = hashlib . sha512 ) . read ( 64 ) <NEWLINE> <DEDENT>
class StudentAdmin ( admin . ModelAdmin ) : <NEWLINE> <INDENT> search_fields = ( <STRING> , ) <NEWLINE> list_display = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> actions = [ runningadd , matchadd , clubadd , othersadd ] <NEWLINE> def get_actions ( self , request ) : <NEWLINE> <INDENT> actions = super ( StudentAdmin , self ) . get_actions ( request ) <NEWLINE> <INDENT> if request . user . username != <STRING> : <NEWLINE> <INDENT> if <STRING> in actions : <NEWLINE> <INDENT> del actions [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT> return actions <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def __getitem__ ( self , key ) : <NEWLINE> <INDENT> with self . lock : <NEWLINE> <INDENT> x = self . items [ key ] <NEWLINE> if time . time ( ) x [ 0 ] > self . maxAge and self . maxAge : <NEWLINE> <INDENT> raise KeyError ( <STRING> ) <NEWLINE> <DEDENT> return x [ 1 ] <NEWLINE> <DEDENT> <DEDENT>
import logging <NEWLINE> import sys <NEWLINE> import thinrpc <NEWLINE> import thinrpc . client as client <NEWLINE> thinrpc . logger . setLevel ( logging . DEBUG ) <NEWLINE> port = int ( sys . argv [ 1 ] ) <NEWLINE> rn = client . RpcRemote ( ( <STRING> , port ) <NEWLINE> print ( rn . hello ( ) ) <NEWLINE>
def parse_command_line ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ok = Dist . Dist . parse_command_line ( self ) <NEWLINE> if ok : <NEWLINE> <INDENT> if DEBUG : print <STRING> <NEWLINE> if self . package and self . package not in self . package_options : <NEWLINE> <INDENT> raise DistutilsArgError ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> % self . package ) <NEWLINE> <DEDENT> <DEDENT> defaults = self . package_defaults . setdefault ( <STRING> , { } ) <NEWLINE> for command , options in self . command_options . items ( ) : <NEWLINE> <INDENT> command_options = defaults . setdefault ( command , { } ) <NEWLINE> command_options . update ( options ) <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <DEDENT>
def test_extract ( self ) : <NEWLINE> <INDENT> fivedaysago = datetime . datetime . now ( ) - datetime . timedelta ( days = 5 ) <NEWLINE> for field , exp in ( <STRING> , fivedaysago . year ) , ( <STRING> , <NEWLINE> <INDENT> fivedaysago . month ) , ( <STRING> , fivedaysago . day ) : <NEWLINE> r = testing . db . execute ( select ( [ extract ( field , func . now ( ) <NEWLINE> <INDENT> + datetime . timedelta ( days = - 5 ) ) ] ) ) . scalar ( ) <NEWLINE> eq_ ( r , exp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_default_exception_message_if_empty_error_message_from_api ( ) : <NEWLINE> <INDENT> httpretty . register_uri ( httpretty . GET , <STRING> , status = 500 , body = None ) <NEWLINE> client = GavagaiClient ( <STRING> host = <STRING> ) <NEWLINE> with pytest . raises ( GavagaiHttpException ) as excinfo : <NEWLINE> <INDENT> client . request ( <STRING> , method = <STRING> ) <NEWLINE> <DEDENT> assert excinfo . value . status_code == 500 <NEWLINE> assert <STRING> in excinfo . value . message <NEWLINE> <DEDENT>
class UnknownDevice ( DeviceInfo ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , backend_domain , ident , description = None , <NEWLINE> <INDENT> frontend_domain = None ) : <NEWLINE> if description is None : <NEWLINE> description = <STRING> <NEWLINE> super ( UnknownDevice , self ) . __init__ ( backend_domain , ident , description , <NEWLINE> frontend_domain ) <NEWLINE> <DEDENT> <DEDENT>
def Save2Shelf ( config , shelfname = <STRING> ) : <NEWLINE> <INDENT> db = shelve . open ( shelfname ) <NEWLINE> runname = FindEntry ( config ) <NEWLINE> if runname is None : <NEWLINE> <INDENT> runname = str ( int ( time . time ( ) ) ) ) <NEWLINE> <DEDENT> print ( runname ) <NEWLINE> db [ runname ] = config <NEWLINE> db . close ( ) <NEWLINE> return runname <NEWLINE> <DEDENT>
class Ui_MainWindow ( object ) : <NEWLINE> <INDENT> def setupUi ( self , MainWindow ) : <NEWLINE> <INDENT> MainWindow . setObjectName ( <STRING> ) <NEWLINE> MainWindow . resize ( 1162 , 679 ) <NEWLINE> font = QtGui . QFont ( ) <NEWLINE> font . setFamily ( <STRING> ) <NEWLINE> MainWindow . setFont ( font ) <NEWLINE> self . centralwidget = QtWidgets . QWidget ( MainWindow ) <NEWLINE> self . centralwidget . setObjectName ( <STRING> ) <NEWLINE> self . label = QtWidgets . QLabel ( self . centralwidget ) <NEWLINE> self . label . setGeometry ( QtCore . QRect ( 90 , 0 , 91 , 41 ) ) <NEWLINE> self . label . setStyleSheet ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
def _getaction ( action ) : <NEWLINE> <INDENT> if not action : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if action == <STRING> : return <STRING> <NEWLINE> for a in ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> if a . startswith ( action ) : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> <DEDENT> raise _OptionError ( <STRING> % ( action , ) <NEWLINE> <DEDENT>
def retrieve_network_row_by_ifname ( cfg , ifname , filter ) : <NEWLINE> <INDENT> data = cfg . dbsess . query ( Network ) . filter ( Network . interface == ifname ) <NEWLINE> for k in filter . keys ( ) : <NEWLINE> <INDENT> exec <STRING> % ( k , k ) <NEWLINE> <DEDENT> if data . count ( ) > 0 : <NEWLINE> <INDENT> return data . one ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT>
def getUserTagsTest ( ) : <NEWLINE> <INDENT> push = IGeTui ( HOST , APPKEY , MASTERSECRET ) <NEWLINE> dictz = push . getUserTags ( APPID , CID ) <NEWLINE> for key in dictz : <NEWLINE> print ( key + <STRING> + dictz [ key ] . decode ( <STRING> ) ) <NEWLINE> <DEDENT>
from cpython cimport array as c_array <NEWLINE> from array import array <NEWLINE> cdef c_array . array a = array ( <STRING> , [ 1 , 2 , 3 ] ) <NEWLINE> cdef int [ : ] ca = a <NEWLINE> cdef int overhead ( object a ) : <NEWLINE> <INDENT> cdef int [ : ] ca = a <NEWLINE> return ca [ 0 ] <NEWLINE> <DEDENT> cdef int no_overhead ( int [ : ] ca ) : <NEWLINE> <INDENT> return ca [ 0 ] <NEWLINE> <DEDENT> print ( overhead ( a ) ) <NEWLINE> print ( no_overhead ( ca ) ) <NEWLINE>
def get_host_ipv4 ( ) : <NEWLINE> <INDENT> all_ifaces = ni . interfaces ( ) <NEWLINE> host_iface = None <NEWLINE> for iface in all_ifaces : <NEWLINE> <INDENT> if <STRING> in iface : <NEWLINE> <INDENT> host_iface = iface <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if host_iface == None : <NEWLINE> <INDENT> print ( logging . critical ( <STRING> ) <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> sys . exit ( 1 ) <NEWLINE> <DEDENT> host_ipv4 = ni . ifaddresses ( host_iface ) [ ni . AF_INET ] [ 0 ] [ <STRING> ] <NEWLINE> return host_ipv4 <NEWLINE> <DEDENT>
class DragStartEvent extends DragEvent : <NEWLINE> <INDENT> def __init__ ( self , context ) : <NEWLINE> <INDENT> super ( context ) <NEWLINE> assert context . vetoException is None <NEWLINE> assert context . dropController is None <NEWLINE> assert context . finalDropController is None <NEWLINE> <DEDENT> <STRING> <NEWLINE> def toString ( self ) : <NEWLINE> <INDENT> return <STRING> + getSourceShortTypeName ( ) + <STRING> <NEWLINE> <DEDENT> <DEDENT>
class Command ( BaseCommand ) : <NEWLINE> <INDENT> help = <STRING> <NEWLINE> def handle ( self , * args , ** options ) : <NEWLINE> <INDENT> for addon in Addon . objects . filter ( type = amo . ADDON_PERSONA , <NEWLINE> <INDENT> _current_version__isnull = True ) : <NEWLINE> if addon . _latest_version : <NEWLINE> addon . update ( _current_version = addon . _latest_version , <NEWLINE> _signal = False ) <NEWLINE> else : <NEWLINE> version = Version . objects . create ( addon = addon , version = <STRING> ) <NEWLINE> addon . update ( _current_version = version , _signal = False ) <NEWLINE> log . info ( <STRING> % addon . id ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def setUp ( self ) : <NEWLINE> <INDENT> self . client . login ( username = <STRING> password = <STRING> ) <NEWLINE> e = Episode . objects . create ( name = <STRING> ) <NEWLINE> self . episode_pk = e . pk <NEWLINE> m = Media ( content_object = e , url = <STRING> ) <NEWLINE> m . save ( ) <NEWLINE> self . mp3_media_pk = m . pk <NEWLINE> m = Media ( content_object = e , url = <STRING> ) <NEWLINE> m . save ( ) <NEWLINE> self . png_media_pk = m . pk <NEWLINE> <DEDENT>
def plug_removed ( self , w , ( win , socket ) ) : <NEWLINE> <INDENT> win . hide ( ) <NEWLINE> return True <NEWLINE> <DEDENT>
def fitting ( fn , data , parms = None , steps = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> f = functions [ fn ] <NEWLINE> np = f [ <STRING> ] <NEWLINE> if parms == None : <NEWLINE> <INDENT> parms = [ ] <NEWLINE> for i in range ( np ) : <NEWLINE> <DEDENT> s = data [ i ] <NEWLINE> <INDENT> parms . append ( s [ 1 ] ) <NEWLINE> RETS = leastSquaresFit ( f [ <STRING> ] , parms , data , max_iterations = steps ) <NEWLINE> return RETS <NEWLINE> <DEDENT> except : <NEWLINE> print ( <STRING> ) <NEWLINE> return None <NEWLINE> <DEDENT>
def terminate ( self , graceperiod = 1 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . __process . stdin : <NEWLINE> <INDENT> self . closeinput ( ) <NEWLINE> try : <NEWLINE> return with_timeout ( graceperiod , self . wait ) <NEWLINE> except Timeout : <NEWLINE> pass <NEWLINE> <DEDENT> self . kill ( signal . SIGTERM ) <NEWLINE> try : <NEWLINE> <INDENT> return with_timeout ( graceperiod , self . wait ) <NEWLINE> <DEDENT> except Timeout : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> self . kill ( signal . SIGKILL ) <NEWLINE> return self . wait ( ) <NEWLINE> <DEDENT>
def _ensure_driver_supports_request ( drv , router_body ) : <NEWLINE> <INDENT> r = router_body <NEWLINE> for key , attr in ( ( <STRING> , <STRING> ) , <NEWLINE> <INDENT> ( <STRING> , <STRING> ) ) : <NEWLINE> flag = r . get ( key ) <NEWLINE> if flag not in [ True , False ] : <NEWLINE> continue <NEWLINE> if not getattr ( drv , attr ) . is_compatible ( flag ) : <NEWLINE> raise lib_exc . InvalidInput ( error_message = ( <NEWLINE> _ ( <STRING> ) <NEWLINE> % dict ( name = drv . name , key = key , flag = flag ) ) ) <NEWLINE> <DEDENT> <DEDENT>
def lookup ( the_dict , key ) : <NEWLINE> <INDENT> the_dict = json . loads ( the_dict ) <NEWLINE> if the_dict . get ( key , <STRING> ) [ 1 ] == <STRING> : <NEWLINE> <INDENT> url = reverse ( <STRING> , kwargs = { <STRING> : os . path . basename ( the_dict . get ( key , <STRING> ) [ 0 ] ) } ) <NEWLINE> <INDENT> return <STRING> % url <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return linebreaksbr ( mark_safe ( the_dict . get ( key , <STRING> ) [ 0 ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
def get_data_path ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> exec <STRING> + PLATFORM_NAME + <STRING> <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> exec <STRING> + PLATFORM_NAME + <STRING> <NEWLINE> <DEDENT> return platformconfig . get_data_path ( ) <NEWLINE> <DEDENT>
def debug_heroes ( GAME ) : <NEWLINE> <INDENT> HEROES = GAME [ <STRING> ] [ <STRING> ] <NEWLINE> for i in range ( len ( HEROES ) ) : <NEWLINE> <INDENT> hero = HEROES [ i ] <NEWLINE> if hero [ <STRING> ] == 0 : <NEWLINE> <INDENT> print ( <STRING> % i ) <NEWLINE> <INDENT> for k in hero . keys ( ) : <NEWLINE> <INDENT> print ( <STRING> % ( k , hero [ k ] ) ) <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
class Loader ( collections . namedtuple ( <STRING> , _loader_attrs ) ) : <NEWLINE> <INDENT> def __new__ ( cls , field_generator , field_generator_kwargs , converter , <NEWLINE> <INDENT> legacy_custom_rules = None ) : <NEWLINE> <STRING> <NEWLINE> if legacy_custom_rules is not None : <NEWLINE> warnings . warn ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> return tuple . __new__ ( cls , ( field_generator , field_generator_kwargs , <NEWLINE> <INDENT> converter , legacy_custom_rules ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def opendir ( self , widget , event , index ) : <NEWLINE> <INDENT> if Globals . MenuButtonSub [ index ] == 0 : <NEWLINE> <INDENT> self . Launcher . Launch ( Globals . MenuButtonCommands [ index ] ) <NEWLINE> else : <NEWLINE> <INDENT> self . PGL . CallSpecialMenu ( int ( Globals . MenuButtonCommands [ index ] ) ) <NEWLINE> <DEDENT> <DEDENT> self . GnomeMenu_unmap ( event ) <NEWLINE> <DEDENT>
def __init__ ( self , settings , model , agentName , layer , uniqInMap = True ) : <NEWLINE> <INDENT> super ( Bee , self ) . __init__ ( settings , model , agentName , layer , uniqInMap ) <NEWLINE> self . state = _STATE_FLY <NEWLINE> <INDENT> self . hero = self . layer . getInstance ( <STRING> ) <NEWLINE> self . girl = self . layer . getInstance ( <STRING> ) <NEWLINE> self . beekeeper = self . layer . getInstance ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class ScriptModifiedHandler ( PatternMatchingEventHandler ) : <NEWLINE> <INDENT> patterns = [ <STRING> ] <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> super ( ScriptModifiedHandler , self ) . __init__ ( ) <NEWLINE> <DEDENT> def process ( self , event ) : <NEWLINE> <INDENT> print ( event . src_path , event . event_type ) <NEWLINE> <DEDENT> def on_modified ( self , event ) : <NEWLINE> <INDENT> self . process ( event ) <NEWLINE> <DEDENT> def on_moved ( self , event ) : <NEWLINE> pass <NEWLINE> def on_deleted ( self , event ) : <NEWLINE> pass <NEWLINE> def on_created ( self , event ) : <NEWLINE> pass <NEWLINE> <DEDENT>
def check_mutated ( step , expected_changed , ratio ) : <NEWLINE> <INDENT> num = len ( world . inds_before_mutation ) <NEWLINE> expected = int ( expected_changed ) <NEWLINE> ratio = float ( ratio ) <NEWLINE> num_changed = 0 <NEWLINE> for i in xrange ( num ) : <NEWLINE> is_equals = ( world . inds_before_mutation [ i ] == world . inds_after_mutation [ i ] ) . all ( ) <NEWLINE> if not is_equals : <NEWLINE> <INDENT> num_changed += 1 <NEWLINE> <DEDENT> assert abs ( num_changed - expected ) <= ratio , <STRING> % ( expected , num_changed ) <NEWLINE> <DEDENT>
def getLabel ( l , labelMap ) : <NEWLINE> <INDENT> labelC = l <NEWLINE> while labelC in labelMap : <NEWLINE> <INDENT> if labelMap [ labelC ] == labelC <NEWLINE> <INDENT> return labelC <NEWLINE> <DEDENT> labelC = labelMap [ labelC ] <NEWLINE> <DEDENT> return labelC <NEWLINE> <DEDENT>
def readS8 ( self , reg ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> result = self . bus . read_byte_data ( self . address , reg ) <NEWLINE> if result > 127 : result -= 256 <NEWLINE> if self . debug : <NEWLINE> <INDENT> print ( <STRING> % <NEWLINE> <INDENT> ( self . address , result & 0xFF , reg ) ) <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <DEDENT> except IOError , err : <NEWLINE> <INDENT> return self . errMsg ( ) <NEWLINE> <DEDENT> <DEDENT>
def _contains_dirs ( self , dir ) : <NEWLINE> <INDENT> for f in os . listdir ( dir ) : <NEWLINE> <INDENT> if os . path . isdir ( os . path . join ( dir , f ) ) <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>
def judge ( self , ( dist , hash ) , ( n , ) ) : <NEWLINE> <INDENT> if dist > n : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif dist == n : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT>
def MemWrite ( self , addr , data ) : <NEWLINE> <INDENT> set address ( addr ) <NEWLINE> data . setgpio ( val ) <NEWLINE> wr = 0 <NEWLINE> mreq = 0 <NEWLINE> wr = 1 <NEWLINE> mreq = 1 <NEWLINE> iodir0 = 0xff <NEWLINE> return <NEWLINE> <DEDENT>
def _registerFontStyleSheet ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> families = qt4 . QFontDatabase ( ) . families ( ) <NEWLINE> deffont = None <NEWLINE> for f in ( <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> if f in families : <NEWLINE> deffont = f <NEWLINE> break <NEWLINE> <DEDENT> if deffont is None : <NEWLINE> <INDENT> print ( <STRING> , file = sys . stderr ) <NEWLINE> deffont = families [ 0 ] <NEWLINE> <DEDENT> collections . Text . defaultfamily = deffont <NEWLINE> collections . Text . families = families <NEWLINE> StylesheetText . defaultfamily = deffont <NEWLINE> StylesheetText . families = families <NEWLINE> <DEDENT>
def __init__ ( self , serv ev , conf = { } , admins = [ ] ) : <NEWLINE> <INDENT> self . session = None <NEWLINE> self . serv = serv <NEWLINE> self . ev = ev <NEWLINE> self . conf = conf <NEWLINE> self . admins = admins <NEWLINE> <DEDENT>
import pyplot as plt <NEWLINE> import numpy as np <NEWLINE> <INDENT> def build_step ( self ) : <NEWLINE> <DEDENT> <STRING> <NEWLINE> p = self . cfg [ <STRING> ] <NEWLINE> self . par = <STRING> <NEWLINE> if p : <NEWLINE> self . par = <STRING> % p <NEWLINE> cmd = <STRING> % self . par <NEWLINE> run_cmd ( cmd , log_all = True , simple = True , log_output = True ) <NEWLINE> for test in [ <STRING> , <STRING> ] : <NEWLINE> cmd = <STRING> % ( self . par , test ) <NEWLINE> run_cmd ( cmd , log_all = True , simple = True , log_output = True ) <NEWLINE>
def test_create_folder_dupe ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> path = posixpath . join ( self . test_dir , <STRING> ) <NEWLINE> metadata = self . client . file_create_folder ( path ) <NEWLINE> self . assertRaises ( <NEWLINE> <INDENT> ErrorResponse <NEWLINE> lambda : self . client . file_create_folder ( path ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def cambiarEstado ( self , mac , estado ) : <NEWLINE> <INDENT> if estado == 1 : <NEWLINE> <INDENT> self . latchAux . actualizar_dispositivo ( mac , 1 ) <NEWLINE> commands . getstatusoutput ( <STRING> + <STRING> + <STRING> + mac + <STRING> + <STRING> ) <NEWLINE> else : <NEWLINE> self . latchAux . actualizar_dispositivo ( mac , 0 ) <NEWLINE> <DEDENT> <DEDENT>
def test_traffic__not_public ( self ) : <NEWLINE> <INDENT> subreddit = self . reddit . subreddit ( <STRING> ) <NEWLINE> with self . recorder . use_cassette ( <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> with pytest . raises ( NotFound ) : <NEWLINE> subreddit . traffic ( ) <NEWLINE> <DEDENT> <DEDENT>
def RunChecks ( self , responses ) : <NEWLINE> <INDENT> if not responses . success : <NEWLINE> <INDENT> raise RuntimeError ( <STRING> ) <NEWLINE> <DEDENT> for finding in checks . CheckHost ( self . state . host_data , <NEWLINE> <INDENT> os_type = self . state . knowledge_base . os ) : <NEWLINE> self . state . checks_run . append ( finding . check_id ) <NEWLINE> if finding . anomaly : <NEWLINE> self . state . checks_with_findings . append ( finding . check_id ) <NEWLINE> self . SendReply ( finding ) <NEWLINE> <DEDENT> <DEDENT>
def answer ( intervals ) : <NEWLINE> <INDENT> num_splits = len ( intervals ) <NEWLINE> t = 0 <NEWLINE> while t < num_splits <NEWLINE> <INDENT> t += 1 <NEWLINE> time_length = reduce_splits ( intervals ) <NEWLINE> if time_length > 0 : <NEWLINE> <INDENT> return time_length <NEWLINE> <DEDENT> if num_splits != len ( intervals ) <NEWLINE> <INDENT> num_splits = len ( intervals ) <NEWLINE> t = 0 <NEWLINE> <DEDENT> <DEDENT> time_length = 0 <NEWLINE> for x in intervals : <NEWLINE> <INDENT> time_length += x [ 1 ] - x [ 0 ] <NEWLINE> <DEDENT> return time_length <NEWLINE> <DEDENT>
def courses ( year ) : <NEWLINE> <INDENT> response = session . post ( pages [ <STRING> ] , params = { <NEWLINE> <INDENT> <STRING> : year , <NEWLINE> <STRING> : <STRING> <NEWLINE> <DEDENT> } ) <NEWLINE> document = BeautifulSoup ( response . text ) <NEWLINE> for option in ( document . find ( <STRING> , { <STRING> : <STRING> } ) <NEWLINE> <INDENT> . find_all ( <STRING> ) ) : <NEWLINE> if option [ <STRING> ] : <NEWLINE> yield option [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT>
def shutdown ( self ) : <NEWLINE> <INDENT> self . motor_off ( ) <NEWLINE> <INDENT> if is_debug : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> subprocess . call ( powerdown ) <NEWLINE> <DEDENT> <DEDENT>
( subaxs [ 1 ] , rain , levels = np . logspace ( 2 , 3.6 , 100 ) , cticks = [ 100 , 500 , 1000 , 1500 , 2000 , 3000 , 4000 ] , cmap = get_cmap ( MAPCOLOR ) , norm = SymLogNorm ( linthresh = 0.3 , linscale = 0.03 ) , <NEWLINE> plt . savefig ( SAVEPATH ) <NEWLINE> <DEDENT>
def update ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( self . __ptr and self . __len ) : <NEWLINE> self . __del__ ( ) <NEWLINE> self . __ptr = c_void_p ( ) <NEWLINE> self . __len = libCSM . csm_services_fetch ( byref ( self . __ptr ) , self . __config . ptr ) <NEWLINE> <DEDENT>
def r_aixssha1 ( mydata ) : <NEWLINE> <INDENT> results = re . search ( <STRING> , mydata , re . M | re . I ) <NEWLINE> if results : <NEWLINE> <INDENT> if args . quietmode : print results . group ( ) <NEWLINE> else : outputhandler . write ( str ( results . group ( ) . rstrip ( <STRING> ) ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def TestConnections ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if len ( Globals . connections ) == 1 : print <STRING> <NEWLINE> else : <NEWLINE> <INDENT> for i in range ( 1 , len ( Globals . connections ) ) : test_connection ( i ) <NEWLINE> <DEDENT> <DEDENT>
print ( <STRING> ) , <STRING> . join ( map ( str , line ) ) ) <NEWLINE>
( <STRING> <NEWLINE> <DEDENT>
def test_delete_router_interface_fail_contract_create ( self ) : <NEWLINE> <INDENT> mgr = self . plugin . manager <NEWLINE> with mock . patch ( <STRING> <NEWLINE> <INDENT> <STRING> , <NEWLINE> side_effect = KeyError ( ) ) : <NEWLINE> self . plugin . remove_router_interface ( self . context , ROUTER , <NEWLINE> <INDENT> self . interface_info ) <NEWLINE> mgr . set_contract_for_epg . assert_called_once ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import alsaaudio , time , audioop <NEWLINE> inp = alsaaudio . PCM ( alsaaudio . PCM_CAPTURE , alsaaudio . PCM_NONBLOCK ) <NEWLINE> inp . setchannels ( 1 ) <NEWLINE> inp . setrate ( 8000 ) <NEWLINE> inp . setformat ( alsaaudio . PCM_FORMAT_S16_LE ) <NEWLINE> inp . setperiodsize ( 160 ) <NEWLINE> while True : <NEWLINE> <INDENT> l , data = inp . read ( ) <NEWLINE> if l : <NEWLINE> <INDENT> au = audioop . max ( data , 2 ) <NEWLINE> if au >= 32676 : <NEWLINE> print ( au ) <NEWLINE> <DEDENT> time . sleep ( .001 ) <NEWLINE> <DEDENT>
def fsoAttributesByKey ( self , stype , node ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> val = node . fsoAttributes ( ) [ stype ] <NEWLINE> if isinstance ( val . value ( ) , vtime ) : <NEWLINE> return val . value ( ) . get_time ( ) <NEWLINE> return val <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> return Variant ( ) <NEWLINE> <DEDENT> <DEDENT>
def make_zip ( name , base_dir , skip = [ ] ) : <NEWLINE> <INDENT> skip . append ( name ) <NEWLINE> with zipfile . ZipFile ( os . path . join ( base_dir , name ) , <NEWLINE> <INDENT> <STRING> , zipfile . ZIP_DEFLATED , allowZip64 = True ) as zf : <NEWLINE> for f in [ f for f in os . listdir ( base_dir ) if f not in skip ] : <NEWLINE> zf . write ( os . path . join ( base_dir , f ) ) <NEWLINE> <DEDENT> <DEDENT>
def test_reset_source ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with ( repack <NEWLINE> <INDENT> . integer ( ) <NEWLINE> . iterator ( <NEWLINE> <INDENT> iter ( [ <STRING> , <STRING> , <STRING> ] ) ) ) as iterator : <NEWLINE> iterator . send ( iter ( [ <STRING> , <STRING> , <STRING> ] ) ) <NEWLINE> r = [ ] <NEWLINE> for v in iterator : <NEWLINE> <DEDENT> r . append ( v ) <NEWLINE> <DEDENT> self . assertSequenceEqual ( [ 11 , 22 , 33 ] , r ) <NEWLINE> <DEDENT>
def testBootTimeEmpty ( self ) : <NEWLINE> <INDENT> with MonkeyPatchScope ( [ ( hoststats , <STRING> , <NEWLINE> <INDENT> <STRING> ) ] ) : <NEWLINE> with self . assertRaises ( ValueError ) : <NEWLINE> hoststats . get_boot_time ( ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> config_file = os . path . join ( sys . path [ 0 ] , <STRING> ) <NEWLINE> config . read ( config_file ) <NEWLINE> factory = protocol . ServerFactory ( ) <NEWLINE> factory . protocol = OdinSysInfoProtocol <NEWLINE> factory . clients = [ ] <NEWLINE> port = int ( config . get ( <STRING> , <STRING> ) <NEWLINE> reactor . listenTCP ( port , factory ) <NEWLINE> logger . debug ( <STRING> % ( port ) ) <NEWLINE> reactor . run ( ) <NEWLINE> <DEDENT>
def putVarInt64 ( self , value ) : <NEWLINE> <INDENT> if value >= 0x8000000000000000 or value < - 0x8000000000000000 : <NEWLINE> <INDENT> raise ProtocolBuffer . ProtocolBufferEncodeError , <STRING> <NEWLINE> <DEDENT> self . _PutVarInt ( value ) <NEWLINE> <DEDENT>
def serialize_data ( self ) : <NEWLINE> <INDENT> ret = dict ( token = self . token , <NEWLINE> <INDENT> sandbox = self . sandbox ) <NEWLINE> <DEDENT> for attr in [ <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> ] : <NEWLINE> val = getattr ( self , attr ) <NEWLINE> if val is not None : <NEWLINE> ret [ attr ] = val <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT>
def test_ascii ( mesh ) : <NEWLINE> <INDENT> helpers . write_read ( <STRING> , <STRING> mesh , 1.0e-11 ) <NEWLINE> return <NEWLINE> <DEDENT>
class Clock ( object ) : <NEWLINE> <INDENT> def __init__ ( self , time ) : <NEWLINE> self . time = time <NEWLINE> def print_time ( self ) : <NEWLINE> print ( self . time ) <NEWLINE> <DEDENT>
def drawpaths ( self , f , paths ) : <NEWLINE> <INDENT> for path in paths : <NEWLINE> <INDENT> if not path [ <STRING> ] : <NEWLINE> <INDENT> self . drawPolyline ( f , path [ <STRING> ] , strokeColor = path [ <STRING> ] ) <NEWLINE> else : <NEWLINE> self . drawPolygon ( f , path [ <STRING> ] , strokeColor = path [ <STRING> ] , fillColor = path [ <STRING> ] , fillOpacity = path [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_metodos ( object , showValor = False ) : <NEWLINE> <INDENT> metodos = [ metodo for metodo in dir ( object ) if hasattr ( getattr ( object , metodo ) , <STRING> ) ] <NEWLINE> for metodo in metodos : <NEWLINE> <INDENT> if showValor : <NEWLINE> <INDENT> print <STRING> % ( metodo , str ( object [ metodo ] ) ) <NEWLINE> <DEDENT> else : print metodo <NEWLINE> <DEDENT> <DEDENT>
def gdal_config_options ( self , cmd = <STRING> ) : <NEWLINE> <INDENT> extra_args = [ ] <NEWLINE> if <STRING> not in cmd : <NEWLINE> <INDENT> value = gdal . GetCacheMax ( ) <NEWLINE> extra_args . extend ( ( <STRING> , <STRING> , str ( value ) ) ) <NEWLINE> <DEDENT> for key in ( <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> ) : <NEWLINE> if key not in cmd : <NEWLINE> value = gdal . GetConfigOption ( key , None ) <NEWLINE> if value : <NEWLINE> extra_args . extend ( ( <STRING> , key , <STRING> % value ) ) <NEWLINE> <DEDENT> return extra_args <NEWLINE> <DEDENT>
def finance_logs ( ) : <NEWLINE> <INDENT> info = current_user . finance_information <NEWLINE> if not info or not info . has_to_pay : <NEWLINE> <INDENT> abort ( 404 ) <NEWLINE> <DEDENT> return render_template ( <STRING> <NEWLINE> <INDENT> last_update = info . last_update , <NEWLINE> balance = info . balance . raw_value , <NEWLINE> logs = info . history ) <NEWLINE> <DEDENT> <DEDENT>
def maybe_inject_trace_event ( self ) : <NEWLINE> <INDENT> if ( self . simulation . dataplane_trace and <NEWLINE> <INDENT> ( self . logical_time % self . traffic_inject_interval ) == 0 ) : <NEWLINE> ( dp_event , host ) = self . simulation . dataplane_trace . peek ( ) <NEWLINE> if dp_event is not None : <NEWLINE> self . _log_input_event ( TrafficInjection ( dp_event = dp_event , <NEWLINE> <INDENT> host_id = host . hid ) ) <NEWLINE> <DEDENT> self . simulation . dataplane_trace . inject_trace_event ( ) <NEWLINE> <DEDENT> <DEDENT>
def get_bridge_for_iface ( root_helper , iface ) : <NEWLINE> <INDENT> args = [ <STRING> , <STRING> , <STRING> , iface ] <NEWLINE> try : <NEWLINE> <INDENT> return utils . execute ( args , root_helper = root_helper ) . strip ( ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> LOG . error ( _ ( <STRING> ) , iface , e ) <NEWLINE> return None <NEWLINE> <DEDENT> <DEDENT>
def test_builtin ( self ) : <NEWLINE> <INDENT> for name in ( <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> self . assertIsNotNone ( pydoc . locate ( name ) ) <NEWLINE> try : <NEWLINE> pydoc . render_doc ( name ) <NEWLINE> except ImportError : <NEWLINE> self . fail ( <STRING> . format ( o ) ) <NEWLINE> <DEDENT> for name in ( <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> <STRING> ) : <NEWLINE> self . assertIsNone ( pydoc . locate ( name ) ) <NEWLINE> self . assertRaises ( ImportError , pydoc . render_doc , name ) <NEWLINE> <DEDENT> <DEDENT>
class global_config : <NEWLINE> <INDENT> projects = [ <NEWLINE> <INDENT> [ <STRING> , <STRING> ] , <NEWLINE> [ <STRING> , <STRING> ] , <NEWLINE> [ <STRING> , <STRING> ] <NEWLINE> ] <NEWLINE> <DEDENT> repositoryURI = <STRING> <NEWLINE> server = syntax error <NEWLINE> debug = 0 <NEWLINE> <DEDENT>
def _log_multivariate_normal_density_tied ( X , means covars ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> cv = np . tile ( covars , ( means . shape [ 0 ] , 1 , 1 ) ) <NEWLINE> return _log_multivariate_normal_density_full ( X , means , cv ) <NEWLINE> <DEDENT>
def deploy_cli ( argv , config = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if config is not None : <NEWLINE> <INDENT> deploy_dir = instantiate ( config ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> deploy_dir = directory <NEWLINE> <DEDENT> if len ( argv ) > 1 : <NEWLINE> <INDENT> root_roles = argv [ 1 : ] <NEWLINE> deploy_dir . deploy_db ( root_roles ) <NEWLINE> deploy_dir . schema_upgrade ( ) <NEWLINE> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stderr . write ( <STRING> % dict ( <NEWLINE> <DEDENT> cmd = argv [ 0 ] <NEWLINE> <DEDENT>
def compile ( advanced = <STRING> , pretty = <STRING> , standalone = <STRING> ) : <NEWLINE> <INDENT> files = srcfiles_embedded <NEWLINE> if standalone == <STRING> : <NEWLINE> files = files + srcfiles_standalone <NEWLINE> command = <STRING> <NEWLINE> command = command + <STRING> <NEWLINE> for theFile in files : <NEWLINE> <INDENT> command = command + <STRING> + theFile + <STRING> <NEWLINE> <DEDENT> if advanced == <STRING> : <NEWLINE> <INDENT> command = ( command + <NEWLINE> <INDENT> <STRING> ) <NEWLINE> if pretty == <STRING> : <NEWLINE> <DEDENT> command = command + <STRING> <NEWLINE> <DEDENT> command = command + <STRING> <NEWLINE> local ( command ) <NEWLINE> <DEDENT>
def visitedWebsite ( pkt ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if pkt . haslayer ( Raw ) : <NEWLINE> <INDENT> payloadWeb = pkt . getlayer ( Raw ) . load <NEWLINE> <INDENT> if payloadWeb . startswith ( <STRING> ) and <STRING> in payloadWeb : <NEWLINE> <INDENT> print ( <STRING> + arg_parser ( ) . victimIP + <STRING> + payloadWeb . split ( <STRING> ) [ 1 ] . split ( <STRING> , 1 ) [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def test_setup_fails_if_no_connect_broker ( hass ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> test_broker_cfg = { mqtt . DOMAIN : { mqtt . CONF_BROKER : <STRING> } } <NEWLINE> with mock . patch ( <STRING> , <NEWLINE> <INDENT> side_effect = socket . error ( ) ) : <NEWLINE> result = yield from async_setup_component ( hass , mqtt . DOMAIN , <NEWLINE> <INDENT> test_broker_cfg ) <NEWLINE> assert not result <NEWLINE> <DEDENT> <DEDENT> with mock . patch ( <STRING> ) as mock_client : <NEWLINE> <INDENT> mock_client ( ) . connect = lambda * args : 1 <NEWLINE> result = yield from async_setup_component ( hass , mqtt . DOMAIN , <NEWLINE> <INDENT> test_broker_cfg ) <NEWLINE> <DEDENT> assert not result <NEWLINE> <DEDENT> <DEDENT>
def mouse_on_img_rect ( img , ( cx , cy ) ) : <NEWLINE> <INDENT> w2 = img . get_width ( ) / 2 <NEWLINE> h2 = img . get_height ( ) / 2 <NEWLINE> x1 = cx - w2 <NEWLINE> y1 = cy - h2 <NEWLINE> x2 = cx + w2 <NEWLINE> y2 = cy + h2 <NEWLINE> return mouse_in ( x1 , y1 , x2 , y2 ) <NEWLINE> <DEDENT>
def getAnswerList ( self , key ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> return self . db [ <STRING> ] . find ( { <STRING> : key } ) if key is not None else self . db [ <STRING> ] . find ( ) <NEWLINE> <DEDENT> <DEDENT>
