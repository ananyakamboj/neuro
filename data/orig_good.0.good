def get_UB ( config ) : <NEWLINE> <INDENT> sample , geometry , detector , engines = new_hkl_diffractometer ( config ) <NEWLINE> return hkl_matrix_to_numpy ( sample . UB_get ( ) ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import datetime <NEWLINE> import math <NEWLINE> import pytz <NEWLINE> import random <NEWLINE> import re <NEWLINE>
class IWikiPageManipulator ( Interface ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def prepare_wiki_page ( req , page , fields ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> def validate_wiki_page ( req , page ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> <DEDENT>
def test_local ( ) : <NEWLINE> <INDENT> src = urllib . urlopen ( url ) <NEWLINE> with open ( local , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( src . read ( ) ) <NEWLINE> <DEDENT> with open ( local , <STRING> ) as source : <NEWLINE> <INDENT> forum_topics ( source ) <NEWLINE> <DEDENT> <DEDENT>
class install ( _install ) : <NEWLINE> <INDENT> def run ( self ) : <NEWLINE> <INDENT> super ( ) . run ( ) <NEWLINE> self . execute ( <NEWLINE> <INDENT> make_shortcut , <NEWLINE> ( self . install_scripts , ) , <NEWLINE> msg = <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> actions = log_collection . find ( <NEWLINE> <INDENT> { } , <NEWLINE> { <STRING> : True } <NEWLINE> <DEDENT> ) . distinct ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> for action in actions : <NEWLINE> <INDENT> analyze_log_action ( action ) <NEWLINE> <DEDENT> <DEDENT>
class InteractionStyle ( Enum ) : <NEWLINE> <INDENT> SYNCHRONOUS = auto ( ) <NEWLINE> ASYNCHRONOUS = auto ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> input_length = 100 <NEWLINE> hidden_cnt = 50 <NEWLINE> nn = NeuralNetwork ( RNN ( input_length , hidden_cnt ) ) <NEWLINE> data = get_test_data ( input_length ) <NEWLINE> print ( <STRING> ) <NEWLINE> nn . train ( data ) <NEWLINE> print ( <STRING> ) <NEWLINE> nn . test ( data ) <NEWLINE> print ( <STRING> ) <NEWLINE> nn . run_with_cross_validation ( data , 2 ) <NEWLINE> print ( <STRING> ) <NEWLINE> features = nn . feature_selection ( data ) <NEWLINE> print ( <STRING> . format ( features ) ) <NEWLINE> <DEDENT>
class Maker ( FileSystemEventHandler ) : <NEWLINE> <INDENT> def on_modified ( self , _ ) : <NEWLINE> <INDENT> Maker . lock = True <NEWLINE> print ( <STRING> ) <NEWLINE> p = subprocess . Popen ( <STRING> ) <NEWLINE> p . wait ( ) <NEWLINE> <DEDENT> <DEDENT>
def test_t17 ( ) : <NEWLINE> <INDENT> lines = run_test ( <STRING> ) . split ( <STRING> ) <NEWLINE> assert ( lines [ 1 ] == <STRING> ) <NEWLINE> <DEDENT>
def log_exception ( ) : <NEWLINE> <INDENT> if not enabled : <NEWLINE> <INDENT> logger . warning ( <STRING> ) <NEWLINE> return None <NEWLINE> <DEDENT> return sentry . captureException ( extra = { <NEWLINE> <INDENT> <STRING> : get_session_data ( ) , <NEWLINE> <DEDENT> } ) <NEWLINE> <DEDENT>
import base64 <NEWLINE> from binascii import hexlify <NEWLINE> from enum import Enum <NEWLINE>
from __future__ import unicode_literals <NEWLINE> import re <NEWLINE> import base64 <NEWLINE> from . common import InfoExtractor <NEWLINE> from . . utils import ( <NEWLINE> <INDENT> ExtractorError , <NEWLINE> compat_urllib_request , <NEWLINE> compat_urllib_parse , <NEWLINE> int_or_none , <NEWLINE> <DEDENT> ) <NEWLINE>
class FingerprintTest ( unittest . TestCase ) : <NEWLINE> <INDENT> def test_name ( self ) : <NEWLINE> <INDENT> fp2 = chemkit . Fingerprint . create ( <STRING> ) <NEWLINE> self . assertEqual ( fp2 . name ( ) , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def to_xml ( self ) : <NEWLINE> <INDENT> tmpl = <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <NEWLINE> xml_item = Template ( tmpl ) . safe_substitute ( title = self . title , <NEWLINE> <INDENT> description = self . description , <NEWLINE> pic_url = self . pic_url , <NEWLINE> url = self . url ) <NEWLINE> <DEDENT> return xml_item <NEWLINE> <DEDENT>
def test_instance_has_valid_construction ( self ) : <NEWLINE> <INDENT> instance = self . _makeOne ( ) <NEWLINE> self . assertEqual ( instance . title , <STRING> ) <NEWLINE> self . assertEqual ( instance . text , <STRING> ) <NEWLINE> self . assertEqual ( instance . creator , <STRING> ) <NEWLINE> self . assertEqual ( instance . modified_by , <STRING> ) <NEWLINE> self . assertEqual ( instance . caption , <STRING> ) <NEWLINE> self . failUnless ( <STRING> in instance ) <NEWLINE> from zope . interface . verify import verifyObject <NEWLINE> from karl . models . interfaces import IAttachmentsFolder <NEWLINE> verifyObject ( IAttachmentsFolder , instance [ <STRING> ] ) <NEWLINE> <DEDENT>
def _get_section_bars ( self ) : <NEWLINE> <INDENT> self . sec_bars = self . uicore . core . cmd_str ( <STRING> ) <NEWLINE> if self . sec_bars : <NEWLINE> <INDENT> self . _parse_ascii_bars ( ) <NEWLINE> <DEDENT> <DEDENT>
def test_12_failmissingcluster ( self ) : <NEWLINE> <INDENT> command = [ <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> ] <NEWLINE> <DEDENT> out = self . notfoundtest ( command ) <NEWLINE> self . matchoutput ( out , <NEWLINE> <INDENT> <STRING> , <NEWLINE> command ) <NEWLINE> <DEDENT> <DEDENT>
def enum ( typename , field_names ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if isinstance ( field_names , str ) : <NEWLINE> <INDENT> field_names = field_names . replace ( <STRING> , <STRING> ) . split ( ) <NEWLINE> <DEDENT> d = dict ( ( reversed ( nv ) for nv in enumerate ( field_names ) ) , __slots__ = ( ) ) <NEWLINE> return type ( typename , ( object , ) , d ) ( ) <NEWLINE> <DEDENT>
def teardown ( self ) : <NEWLINE> <INDENT> if os . path . exists ( self . dbfile ) : <NEWLINE> <INDENT> os . unlink ( self . dbfile ) <NEWLINE> <DEDENT> if os . path . exists ( self . inifile ) : <NEWLINE> <INDENT> os . unlink ( self . inifile ) <NEWLINE> <DEDENT> <DEDENT>
def extract_length ( length_string ) : <NEWLINE> <INDENT> l3 = string . split ( length_string , <STRING> ) <NEWLINE> n1 = string . atoi ( l3 [ 0 ] ) <NEWLINE> n2 = string . atoi ( l3 [ 1 ] ) <NEWLINE> length = n2 - n1 <NEWLINE> return ( length ) <NEWLINE> <DEDENT>
class UserManager ( BaseUserManager ) : <NEWLINE> <INDENT> STAFF = ( <STRING> , <STRING> , <STRING> ) <NEWLINE> def create_superuser ( self , role , email , password ) : <NEWLINE> <INDENT> user = self . create_user ( email , password = password , role = role ) <NEWLINE> user . is_admin = True <NEWLINE> user . save ( using = self . _db ) <NEWLINE> return user <NEWLINE> <DEDENT> <DEDENT>
import blinker <NEWLINE> _signals = blinker . Namespace ( ) <NEWLINE> repository_created = _signals . signal ( <STRING> ) <NEWLINE> repository_updated = _signals . signal ( <STRING> ) <NEWLINE> repository_deleted = _signals . signal ( <STRING> ) <NEWLINE> tag_created = _signals . signal ( <STRING> ) <NEWLINE> tag_deleted = _signals . signal ( <STRING> ) <NEWLINE>
def test_id ( self ) : <NEWLINE> <INDENT> assert self . task . id == test_id <NEWLINE> assert self . task [ <STRING> ] == test_id <NEWLINE> <DEDENT>
def refreshCanvas ( self ) : <NEWLINE> <INDENT> if not self . dirty : return <NEWLINE> self . screen . clear ( ) <NEWLINE> self . dirty = False <NEWLINE> <DEDENT>
<STRING> <NEWLINE> if __doc__ : <NEWLINE> <INDENT> __doc__ = __doc__ . encode ( <STRING> ) . decode ( <STRING> ) <NEWLINE> <DEDENT> __author__ = <STRING> . encode ( <STRING> ) . decode ( <STRING> ) <NEWLINE> __docformat__ = <STRING> <NEWLINE> import types as _types <NEWLINE> from gensaschema import _util <NEWLINE>
<STRING> <NEWLINE> import sys <NEWLINE> import cv2 <NEWLINE> imggray = cv2 . imread ( <STRING> ) ; <NEWLINE> cv2 . imshow ( <STRING> , imggray ) <NEWLINE> imgbw = cv2 . im2bw ( imggray , 0.5 ) <NEWLINE> cv2 . subplot ( 222 ) <NEWLINE> cv2 . imshow ( imgbw ) <NEWLINE> imgbw = cv2 . im2bw ( imggray , 0.25 ) <NEWLINE> cv2 . subplot ( 223 ) <NEWLINE> cv2 . imshow ( imgbw ) <NEWLINE> level = cv2 . graythresh ( imggray ) <NEWLINE> imgbw = cv2 . im2bw ( imggray , level ) <NEWLINE> cv2 . subplot ( 224 ) <NEWLINE> cv2 . imshow ( imgbw ) <NEWLINE>
import forwarding_protocol <NEWLINE> import forwarding_buffer <NEWLINE> import forwarding_buffer_composite <NEWLINE> import functools <NEWLINE> import collections <NEWLINE> import copy <NEWLINE> import random <NEWLINE>
def get_details ( cand ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> headline = [ cand . get ( <STRING> , <STRING> ) , <NEWLINE> <INDENT> cand . get ( <STRING> , <STRING> ) , <NEWLINE> cand . get ( <STRING> , <STRING> ) , ] <NEWLINE> <DEDENT> headline = [ el for el in headline if el != <STRING> ] <NEWLINE> return <STRING> % ( <NEWLINE> <INDENT> <STRING> . join ( headline ) , <NEWLINE> cand . get ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT>
def _end_planet_source ( self ) : <NEWLINE> <INDENT> self . _end_source ( ) <NEWLINE> context = self . _getContext ( ) <NEWLINE> if not context . has_key ( <STRING> ) : context [ <STRING> ] = [ ] <NEWLINE> context . sources . append ( context . source ) <NEWLINE> del context [ <STRING> ] <NEWLINE> <DEDENT>
def upgrade ( ) : <NEWLINE> <INDENT> op . add_column ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> sa . Column ( <STRING> , sa . String ( length = 40 ) , nullable = True ) ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import os <NEWLINE> import sys <NEWLINE> PATH = os . path . abspath ( os . path . dirname ( __file__ ) ) <NEWLINE> sys . path . insert ( 0 , PATH ) <NEWLINE> activate_this = os . path . join ( PATH , <STRING> ) <NEWLINE> if os . path . exists ( activate_this ) : <NEWLINE> <INDENT> execfile ( activate_this , dict ( __file__ = activate_this ) ) <NEWLINE> <DEDENT> from app import app as application <NEWLINE>
def test_ndimiterator_yields_same_numpy_array ( ) : <NEWLINE> <INDENT> from numpy import all , ndarray <NEWLINE> from pylada . decorations . _cutilities import NDimIterator <NEWLINE> from itertools import product <NEWLINE> previous = None <NEWLINE> for expected in NDimIterator ( 2 , 2 , 3 ) : <NEWLINE> <INDENT> if previous is None : <NEWLINE> <INDENT> previous = expected <NEWLINE> <DEDENT> assert isinstance ( expected , ndarray ) <NEWLINE> assert expected . dtype == <STRING> <NEWLINE> assert previous is expected <NEWLINE> <DEDENT> <DEDENT>
from opentrons_sdk . drivers import motor <NEWLINE> __all__ = [ motor ] <NEWLINE>
def generate_idl ( self ) : <NEWLINE> <INDENT> return { <NEWLINE> <INDENT> <STRING> : self . _features , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>
def test_summarize_alad_results ( ) : <NEWLINE> <INDENT> datasets = get_test_datasets ( ) <NEWLINE> for dataset in datasets : <NEWLINE> <INDENT> args = get_command_args ( debug = False , debug_args = None ) <NEWLINE> configure_logger ( args ) <NEWLINE> opts = Opts ( args ) <NEWLINE> logger . debug ( opts . str_opts ( ) ) <NEWLINE> set_seed ( args . randseed ) <NEWLINE> summarize_alad_to_csv ( opts = opts ) <NEWLINE> print ( <STRING> % ( opts . detector_type_str ( ) , opts . dataset , ) ) <NEWLINE> <DEDENT> <DEDENT>
def test_join_user_with_bogus_id ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . _service . join ( <STRING> , uuid . UUID ( int = 99 ) ) <NEWLINE> <DEDENT> except MissingUserError as exc : <NEWLINE> <INDENT> self . assertEqual ( exc . user_id , uuid . UUID ( int = 99 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise AssertionError ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class ConstantSpectrumGenerator ( SpectrumGenerator ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , value = 1.0 , resolution = None , length = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> SpectrumGenerator . __init__ ( self , resolution = resolution , length = length ) <NEWLINE> self . __value = value <NEWLINE> <DEDENT> @ sumpf . Input ( float , <STRING> ) <NEWLINE> def SetValue ( self , value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . __value = value <NEWLINE> <DEDENT> def _GetSample ( self , f ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . __value <NEWLINE> <DEDENT> def _GetLabel ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return <STRING> <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from collections import OrderedDict <NEWLINE> from flask . ext . login import current_user <NEWLINE> from invenio_accounts . models import User <NEWLINE> from sqlalchemy import and_ , or_ <NEWLINE> from hepdata . modules . permissions . models import SubmissionParticipant <NEWLINE> from hepdata . modules . records . utils . common import get_record_by_id , decode_string <NEWLINE> from hepdata . modules . submission . api import get_latest_hepsubmission <NEWLINE> from hepdata . modules . records . utils . users import has_role <NEWLINE> from hepdata . modules . submission . models import HEPSubmission , DataReview <NEWLINE> from hepdata . utils . users import get_user_from_id <NEWLINE>
from django . http import HttpResponse <NEWLINE> from django . core . urlresolvers import reverse <NEWLINE> from django . shortcuts import render_to_response <NEWLINE> import pymongo <NEWLINE> conn = pymongo . Connection ( ) <NEWLINE> db = conn . debug_test <NEWLINE>
def dump_counts ( counts ) : <NEWLINE> <INDENT> for k , v in enumerate ( counts ) : <NEWLINE> <INDENT> kmer = indexToKmer ( k , K ) <NEWLINE> sv = <STRING> . join ( [ <STRING> % ( x , y ) for x , y in v . iteritems ( ) ] ) <NEWLINE> print ( <STRING> % ( kmer , sv ) ) <NEWLINE> <DEDENT> <DEDENT>
import logging <NEWLINE> from dart . context . database import db <NEWLINE> from dart . model . orm import TriggerDao <NEWLINE> from dart . model . trigger import Trigger <NEWLINE> from dart . service . patcher import patch_difference <NEWLINE> from dart . tool . tool_runner import Tool <NEWLINE> _logger = logging . getLogger ( __name__ ) <NEWLINE>
import urllib , urllib2 , re , xbmcplugin , xbmcgui , sys , xbmcaddon , socket <NEWLINE> socket . setdefaulttimeout ( 30 ) <NEWLINE> pluginhandle = int ( sys . argv [ 1 ] ) <NEWLINE> addon = xbmcaddon . Addon ( id = <STRING> ) <NEWLINE> translation = addon . getLocalizedString <NEWLINE> forceViewMode = addon . getSetting ( <STRING> ) <NEWLINE> if forceViewMode == <STRING> : <NEWLINE> <INDENT> forceViewMode = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> forceViewMode = False <NEWLINE> <DEDENT> viewMode = str ( addon . getSetting ( <STRING> ) ) <NEWLINE>
from datetime import datetime <NEWLINE> from corpusbuilder import CorpusBuilder <NEWLINE> import config <NEWLINE>
from pyglet . gl import * <NEWLINE> from pyglet import window , image <NEWLINE> import shader <NEWLINE> __all__ = [ <STRING> ] <NEWLINE> test_v = <STRING> <NEWLINE> test_f = <STRING> <NEWLINE>
def capillary_volume ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . capillary . capillary_volume ( ) <NEWLINE> <DEDENT>
def forwards ( self , orm ) : <NEWLINE> <INDENT> db . add_column ( <STRING> , <STRING> , <NEWLINE> <INDENT> self . gf ( <STRING> ) ( blank = True , related_name = <STRING> , null = True , on_delete = models . SET_NULL , to = orm [ <STRING> ] ) , <NEWLINE> keep_default = False ) <NEWLINE> <DEDENT> <DEDENT>
from django . shortcuts import render , render_to_response <NEWLINE> from django . views . generic import ListView <NEWLINE> from django . core . context_processors import request <NEWLINE> from django . http . response import HttpResponse <NEWLINE> from django . template import RequestContext <NEWLINE>
def _repo ( self , config ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not isinstance ( config [ <STRING> ] , list ) : <NEWLINE> <INDENT> raise SystemError ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from __future__ import unicode_literals <NEWLINE> from django . http import Http404 <NEWLINE> from rest_framework import status <NEWLINE> from rest_framework . response import Response <NEWLINE> from rest_framework . request import clone_request <NEWLINE>
def analyze_dell_status ( arr , server , community , config ) : <NEWLINE> <INDENT> st = arr [ 0 ] [ 1 ] <NEWLINE> if st != 3 : <NEWLINE> <INDENT> return oids . dell_status_standard [ st ] , True <NEWLINE> <DEDENT> return oids . dell_status_standard [ st ] , False <NEWLINE> <DEDENT>
def convertBlockquote ( line ) : <NEWLINE> <INDENT> line = re . sub ( <STRING> , <STRING> , line ) <NEWLINE> return line <NEWLINE> <DEDENT>
def test_delete_vm ( self ) : <NEWLINE> <INDENT> tenant = fakes . tenants [ <STRING> ] <NEWLINE> app = self . get_app ( ) <NEWLINE> for s in fakes . servers [ tenant [ <STRING> ] ] : <NEWLINE> <INDENT> req = self . _build_req ( <STRING> % s [ <STRING> ] , <NEWLINE> <INDENT> tenant [ <STRING> ] , method = <STRING> ) <NEWLINE> <DEDENT> resp = req . get_response ( app ) <NEWLINE> self . assertContentType ( resp ) <NEWLINE> self . assertEqual ( 204 , resp . status_code ) <NEWLINE> <DEDENT> <DEDENT>
from unittest import TestCase <NEWLINE> from unittest . mock import patch , call <NEWLINE> import rancon <NEWLINE> from rancon . backends import consul <NEWLINE> from . test_data import TEST_SERVICES <NEWLINE>
import marzipan_io <NEWLINE> import config <NEWLINE> import cc <NEWLINE> import pycurl <NEWLINE> ms = open ( <STRING> , <STRING> ) . read ( ) . rstrip ( ) . lstrip ( <STRING> ) <NEWLINE> card = cc . parse_magstripe ( ms ) <NEWLINE> ( xid , status ) = marzipan_io . send_tnbci_request ( 0.01 , card ) <NEWLINE> print ( xid ) <NEWLINE> print ( status ) <NEWLINE>
def test_create_nova_probe_external ( self ) : <NEWLINE> <INDENT> self . _test_create_probe_external ( <NEWLINE> <INDENT> debug_agent . DEVICE_OWNER_COMPUTE_PROBE ) <NEWLINE> <DEDENT> <DEDENT>
class Team ( models . Model ) : <NEWLINE> <INDENT> name = models . CharField ( <STRING> , default = <STRING> , max_length = 32 ) <NEWLINE> def __str__ ( self ) : <NEWLINE> <INDENT> return self . name <NEWLINE> <DEDENT> <DEDENT>
class build_py ( _build_py ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def run ( self ) : <NEWLINE> <INDENT> sts = Popen ( <STRING> , shell = True , cwd = this_dir ) . wait ( ) <NEWLINE> if sts != 0 : <NEWLINE> <INDENT> raise OSError ( sts , <STRING> ) <NEWLINE> <DEDENT> _build_py . run ( self ) <NEWLINE> <DEDENT> <DEDENT>
import os <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import copy <NEWLINE> if sys . platform == <STRING> : <NEWLINE> <INDENT> from cyglibra_core import * <NEWLINE> <DEDENT> elif sys . platform == <STRING> or sys . platform == <STRING> : <NEWLINE> <INDENT> from liblibra_core import * <NEWLINE> <DEDENT> from libra_py import * <NEWLINE> from create_input_gms import * <NEWLINE> from create_input_qe import * <NEWLINE> from x_to_libra_gms import * <NEWLINE> from x_to_libra_qe import * <NEWLINE> from hamiltonian_vib import * <NEWLINE> import print_results <NEWLINE> import include_mm <NEWLINE>
from brewmachine import * <NEWLINE> import json <NEWLINE> state_list = [ Maischen , Beta , Alpha , Leutern , Kochen , Kochen ] <NEWLINE> state_list . reverse ( ) <NEWLINE> io = open ( <STRING> ) . read ( ) <NEWLINE> rezept = json . loads ( io ) <NEWLINE> foo = BrewMachine ( state_list , rezept ) <NEWLINE> for _ in range ( 0 , len ( state_list ) - 1 ) : <NEWLINE> <INDENT> foo . next ( ) <NEWLINE> print ( foo . run ( ) ) <NEWLINE> <DEDENT>
import discord <NEWLINE> from bot import i18n <NEWLINE> from bot . commands . command import Command <NEWLINE> import random <NEWLINE>
from setuptools import setup , find_packages <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> version = <STRING> , <NEWLINE> description = <STRING> , <NEWLINE> long_description = <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> , <NEWLINE> url = <STRING> , <NEWLINE> classifiers = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> <NEWLINE> <DEDENT> ] , <NEWLINE> packages = find_packages ( <STRING> ) , <NEWLINE> package_dir = { <STRING> : <STRING> } <NEWLINE> <DEDENT> ) <NEWLINE>
def make_text ( s ) : <NEWLINE> <INDENT> if s . startswith ( <STRING> ) : <NEWLINE> <INDENT> s = s [ 1 : ] <NEWLINE> <DEDENT> return textwrap . dedent ( s ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> optlist , infiles = getopt . gnu_getopt ( sys . argv [ 1 : ] , <STRING> ) <NEWLINE> if not infiles : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> InFileName = infiles [ 0 ] <NEWLINE> err = open ( InFileName , <STRING> ) . read ( ) <NEWLINE> err = re . sub ( <STRING> , <STRING> , err ) <NEWLINE> out_err = handle_err ( err ) <NEWLINE> print ( out_err ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> s = drmaa . Session ( ) <NEWLINE> s . initialize ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> s . exit ( ) <NEWLINE> <DEDENT>
def decimal_dec ( hdu_str ) : <NEWLINE> <INDENT> val_list = [ float ( n ) for n in hdu_str . split ( <STRING> ) ] <NEWLINE> if str ( val_list [ 0 ] ) [ 0 ] == <STRING> : <NEWLINE> <INDENT> sng = - 1 <NEWLINE> val_list [ 0 ] = sng * val_list [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sng = 1 <NEWLINE> <DEDENT> val_deci = sng * ( val_list [ 0 ] + ( ( val_list [ 1 ] + ( val_list [ 2 ] / 60.0 ) ) / 60.0 ) ) <NEWLINE> return val_deci <NEWLINE> <DEDENT>
def match_pattern ( dna , pattern ) : <NEWLINE> <INDENT> dna = dna . upper ( ) <NEWLINE> pattern = pattern . upper ( ) <NEWLINE> locations = [ ] <NEWLINE> for index in range ( len ( dna ) - len ( pattern ) + 1 ) : <NEWLINE> <INDENT> s = dna [ index : index + len ( pattern ) ] <NEWLINE> if s == pattern : <NEWLINE> <INDENT> locations . append ( str ( index ) ) <NEWLINE> <DEDENT> <DEDENT> return locations <NEWLINE> <DEDENT>
import json <NEWLINE> from . import basetests <NEWLINE> from spark_app import app <NEWLINE>
class event ( plugin ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . observers = [ ] <NEWLINE> <DEDENT> def register_observer ( self , func ) : <NEWLINE> <INDENT> self . observers . append ( func ) <NEWLINE> <DEDENT> def print_observers ( self ) : <NEWLINE> <INDENT> for observer in self . observers : <NEWLINE> <INDENT> print ( observer ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def activate_user ( self , activation_key ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if SHA1_RE . search ( activation_key ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> profile = self . get ( activation_key = activation_key ) <NEWLINE> <DEDENT> except self . model . DoesNotExist : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if not profile . activation_key_expired ( ) : <NEWLINE> <INDENT> user = profile . user <NEWLINE> user . is_active = True <NEWLINE> user . save ( ) <NEWLINE> profile . activation_key = self . model . ACTIVATED <NEWLINE> profile . save ( ) <NEWLINE> return user <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>
class SxxExxKennung ( object ) : <NEWLINE> <INDENT> PATTERN = re . compile ( <STRING> ) <NEWLINE> @ classmethod <NEWLINE> def parse ( cls , title ) : <NEWLINE> <INDENT> target = cls . PATTERN . findall ( _normalize ( title ) ) <NEWLINE> if target : <NEWLINE> <INDENT> return <STRING> % ( int ( target [ 0 ] [ 0 ] ) , int ( target [ 0 ] [ 1 ] ) ) <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT> <DEDENT>
def convertKeyframePlan ( self , keyframeMsg ) : <NEWLINE> <INDENT> msg = lcmdrc . robot_plan_t ( ) <NEWLINE> msg . utime = keyframeMsg . utime <NEWLINE> msg . robot_name = keyframeMsg . robot_name <NEWLINE> msg . num_states = keyframeMsg . num_states <NEWLINE> msg . plan = keyframeMsg . plan <NEWLINE> msg . plan_info = keyframeMsg . plan_info <NEWLINE> msg . num_bytes = keyframeMsg . num_bytes <NEWLINE> msg . matlab_data = keyframeMsg . matlab_data <NEWLINE> msg . num_grasp_transitions = keyframeMsg . num_grasp_transitions <NEWLINE> msg . left_arm_control_type = msg . NONE <NEWLINE> msg . right_arm_control_type = msg . NONE <NEWLINE> msg . left_leg_control_type = msg . NONE <NEWLINE> msg . right_leg_control_type = msg . NONE <NEWLINE> return msg <NEWLINE> <DEDENT>
def get_matching_options ( self , obs , a ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> mask = np . array ( [ ( o . can_init ( obs ) and o . pi ( obs ) == a ) for o in self . options ] ) <NEWLINE> return np . arange ( self . n_options ) [ mask ] <NEWLINE> <DEDENT>
class EnhancedThreadedCommentFlag ( models . Model , Auditable ) : <NEWLINE> <INDENT> comment = models . ForeignKey ( EnhancedThreadedComment ) <NEWLINE> user = models . ForeignKey ( settings . AUTH_USER_MODEL ) <NEWLINE> flagged_at = models . DateTimeField ( auto_now_add = True ) <NEWLINE> hidden = models . BooleanField ( default = False ) <NEWLINE> class Meta : <NEWLINE> <INDENT> app_label = <STRING> <NEWLINE> <DEDENT> <DEDENT>
from django . conf . urls import url <NEWLINE> from subprocuraduria . views import CreateSubprocuraduriaView , CreateDireccionView , SubprocuraduriaListView , DireccionListView , EditSubprocuraduriaView <NEWLINE> urlpatterns = [ <NEWLINE> <INDENT> url ( <STRING> , CreateSubprocuraduriaView . as_view ( ) , name = <STRING> ) , <NEWLINE> url ( <STRING> , EditSubprocuraduriaView . as_view ( ) , name = <STRING> ) , <NEWLINE> url ( <STRING> , SubprocuraduriaListView . as_view ( ) , name = <STRING> ) , <NEWLINE> url ( <STRING> , CreateDireccionView . as_view ( ) , name = <STRING> ) , <NEWLINE> url ( <STRING> , DireccionListView . as_view ( ) , name = <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE>
def test_prepare_rollout ( self ) : <NEWLINE> <INDENT> expected_logs = <STRING> <NEWLINE> self . assert_execute_outputs ( PrepareRollout ( ) , [ 852 , <STRING> ] , options = self . _default_options ( ) , expected_logs = expected_logs ) <NEWLINE> <DEDENT>
def render ( filename , UserContext = { } , path = CConf [ <STRING> ] [ <STRING> ] ) : <NEWLINE> <INDENT> context . update ( UserContext ) <NEWLINE> from os . path import join , dirname <NEWLINE> if filename . startswith ( <STRING> ) : <NEWLINE> <INDENT> filename = filename . replace ( <STRING> , <STRING> , 1 ) <NEWLINE> path = join ( dirname ( __file__ ) , <STRING> , <STRING> ) <NEWLINE> <DEDENT> from jinja2 import Environment , FileSystemLoader <NEWLINE> env = Environment ( loader = FileSystemLoader ( path ) ) <NEWLINE> return env . get_template ( filename ) . render ( context ) <NEWLINE> <DEDENT>
def _setup_helpers ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . _helpers = { } <NEWLINE> for helper_str in self . configuration . lvm_share_helpers : <NEWLINE> <INDENT> share_proto , _ , import_str = helper_str . partition ( <STRING> ) <NEWLINE> helper = importutils . import_class ( import_str ) <NEWLINE> self . _helpers [ share_proto . upper ( ) ] = helper ( <NEWLINE> <INDENT> self . _execute , self . _ssh_exec_as_root , self . configuration ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import pkg_resources <NEWLINE> from disq . client import DisqueAlpha <NEWLINE> from redis . exceptions import ( <NEWLINE> <INDENT> ConnectionError , <NEWLINE> RedisError , <NEWLINE> ResponseError , <NEWLINE> TimeoutError , <NEWLINE> <DEDENT> ) <NEWLINE> Disque = DisqueAlpha <NEWLINE> __all__ = [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> ] <NEWLINE> <DEDENT> __version__ = pkg_resources . get_distribution ( <STRING> ) . version <NEWLINE>
class OAuthRequestToken ( models . Model ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> session_key = models . CharField ( max_length = 250 ) <NEWLINE> ft_token = models . CharField ( max_length = 250 ) <NEWLINE> ft_token_secret = models . CharField ( max_length = 250 ) <NEWLINE> created = models . DateTimeField ( auto_now_add = True ) <NEWLINE> def is_complete ( self ) : <NEWLINE> <INDENT> if self . ft_token and self . md_token : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def add_arguments ( self ) : <NEWLINE> <INDENT> self . argparser . add_argument ( <STRING> , <STRING> , dest = <STRING> , action = <STRING> , <NEWLINE> <INDENT> help = <STRING> ) <NEWLINE> <DEDENT> self . argparser . add_argument ( <STRING> , <STRING> , dest = <STRING> , <NEWLINE> <INDENT> help = <STRING> ) <NEWLINE> <DEDENT> self . argparser . add_argument ( <STRING> , <STRING> , dest = <STRING> , <NEWLINE> <INDENT> help = <STRING> ) <NEWLINE> <DEDENT> self . argparser . add_argument ( <STRING> , <STRING> , dest = <STRING> , action = <STRING> , <NEWLINE> <INDENT> help = <STRING> ) <NEWLINE> <DEDENT> ColumnSelectorMixin . add_arguments ( self ) <NEWLINE> <DEDENT>
def third_party_tracking_ids ( request ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return { <NEWLINE> <INDENT> <STRING> : settings . GOOGLE_ANALYTICS_TRACKING_ID , <NEWLINE> <STRING> : settings . ADDTHIS_PUBLISHER_ID , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from django . conf . urls import include , url <NEWLINE> from django . contrib import admin <NEWLINE> import settings <NEWLINE> from django . conf . urls . static import static <NEWLINE> urlpatterns = [ <NEWLINE> <INDENT> url ( <STRING> , include ( admin . site . urls ) ) , <NEWLINE> url ( <STRING> , <STRING> , { <NEWLINE> <INDENT> <STRING> : settings . MEDIA_ROOT , <NEWLINE> } ) , <NEWLINE> <DEDENT> url ( <STRING> , include ( <STRING> ) ) <NEWLINE> <DEDENT> ] + static ( settings . MEDIA_URL , document_root = settings . MEDIA_ROOT ) <NEWLINE>
def test_sync_image_failed ( self ) : <NEWLINE> <INDENT> def f ( ) : <NEWLINE> <INDENT> mv = VNXMirrorView . get ( t_cli ( ) , <STRING> ) <NEWLINE> mv . sync_image ( ) <NEWLINE> <DEDENT> assert_that ( f , raises ( VNXMirrorSyncImageError , <STRING> ) ) <NEWLINE> <DEDENT>
def OnSliderScroll ( self , event ) : <NEWLINE> <INDENT> obj = event . GetEventObject ( ) <NEWLINE> val = obj . GetValue ( ) <NEWLINE> self . val = float ( val ) / 100 <NEWLINE> Publisher ( ) . sendMessage ( ( <STRING> ) , ( self . val , self . id ) ) <NEWLINE> <DEDENT>
import urllib2 <NEWLINE> import os <NEWLINE> import datetime <NEWLINE> from targetexplorer . flaskapp import models , db <NEWLINE> import pandas as pd <NEWLINE>
def test_execute ( self , mock_exec_file , mock_get_files_in_dir ) : <NEWLINE> <INDENT> mock_service = mock . MagicMock ( ) <NEWLINE> fake_path = os . path . join ( <STRING> , <STRING> ) <NEWLINE> mock_get_files_in_dir . return_value = [ fake_path ] <NEWLINE> response = self . _localscripts . execute ( mock_service , shared_data = None ) <NEWLINE> mock_get_files_in_dir . assert_called_once_with ( <NEWLINE> <INDENT> mock . sentinel . mock_local_scripts_path ) <NEWLINE> <DEDENT> mock_exec_file . assert_called_once_with ( fake_path ) <NEWLINE> self . assertEqual ( ( base . PLUGIN_EXECUTION_DONE , False ) , response ) <NEWLINE> <DEDENT>
def test_None_count ( self ) : <NEWLINE> <INDENT> nacolcount = self . _test_dc . nacolcount ( ) <NEWLINE> self . assertEqual ( nacolcount . loc [ <STRING> , <STRING> ] , 0.1 ) <NEWLINE> self . assertEqual ( nacolcount . loc [ <STRING> , <STRING> ] , 100 ) <NEWLINE> self . assertEqual ( nacolcount . loc [ <STRING> , <STRING> ] , 0.2 ) <NEWLINE> self . assertEqual ( nacolcount . loc [ <STRING> , <STRING> ] , 200 ) <NEWLINE> <DEDENT>
import random <NEWLINE> a = random . randint ( 1 , 2 ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> w = <STRING> <NEWLINE> <DEDENT> elif a == 2 : <NEWLINE> <INDENT> w = <STRING> <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> otvet = input ( <STRING> ) <NEWLINE> while ( otvet != w ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> otvet = input ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> , w , <STRING> ) <NEWLINE> input ( <STRING> ) <NEWLINE>
import re <NEWLINE> from django . middleware . locale import LocaleMiddleware <NEWLINE> from django . utils import translation <NEWLINE> from django . conf import settings <NEWLINE> from utilities . models import UserLanguageProfile <NEWLINE> from django . core . exceptions import ObjectDoesNotExist <NEWLINE>
from django . shortcuts import render , render_to_response <NEWLINE> from django . http import HttpResponse <NEWLINE> from . models import FAQ <NEWLINE>
class md_model3 ( Model ) : <NEWLINE> <INDENT> _name = <STRING> <NEWLINE> _description = <STRING> <NEWLINE> _columns = OrderedDict ( [ <NEWLINE> ( <STRING> , fields . many2one ( obj = <STRING> , label = <STRING> , manual = <STRING> ) ) , <NEWLINE> ( <STRING> , fields . varchar ( label = <STRING> ) ) , <NEWLINE> ( <STRING> , fields . text ( label = <STRING> ) ) <NEWLINE> ] ) <NEWLINE> <DEDENT>
class ChargeFilterSettings ( base . BaseSettings ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> super ( ChargeFilterSettings , self ) . __init__ ( ) <NEWLINE> self . registerSetting ( <STRING> , default = - 100.0 ) <NEWLINE> self . registerSetting ( <STRING> , default = 100.0 ) <NEWLINE> <DEDENT> <DEDENT>
def delete_alarms ( self , alarms ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> params = { } <NEWLINE> self . build_list_params ( params , alarms , <STRING> ) <NEWLINE> return self . get_status ( <STRING> , params ) <NEWLINE> <DEDENT>
def parse_args ( local_argv = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if local_argv is None : <NEWLINE> <INDENT> local_argv = sys . argv <NEWLINE> <DEDENT> c_filename = local_argv [ 1 ] <NEWLINE> moduleName = local_argv [ 2 ] <NEWLINE> localDirectory = local_argv [ 3 ] <NEWLINE> try : <NEWLINE> <INDENT> c_filename <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> moduleName <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> localDirectory <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> return ( c_filename , moduleName , localDirectory ) <NEWLINE> <DEDENT>
def test_list_tags ( self ) : <NEWLINE> <INDENT> response = self . client . get ( <STRING> ) <NEWLINE> self . assertTrue ( <STRING> in response . context ) <NEWLINE> self . assertTrue ( len ( response . context [ <STRING> ] ) > 0 ) <NEWLINE> <DEDENT>
from . home import HomeHandler <NEWLINE> from . quiz import QuizHandler <NEWLINE> from . modify import ModifyHandler <NEWLINE> __all__ = [ <STRING> , <STRING> , <STRING> ] <NEWLINE>
def _create_roles_dirs ( self ) : <NEWLINE> <INDENT> if self . mode == <STRING> : <NEWLINE> <INDENT> role_struct = self . full_role_structure <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> role_struct = self . default_role_structure <NEWLINE> <DEDENT> for k in self . roles : <NEWLINE> <INDENT> path = os . path . join ( self . path , self . name , <STRING> , k ) <NEWLINE> self . _dirs_create ( path , * role_struct ) <NEWLINE> <DEDENT> <DEDENT>
def prompt_password ( prompt , confirm = True ) : <NEWLINE> <INDENT> import getpass <NEWLINE> if sys . stdin . isatty ( ) : <NEWLINE> <INDENT> password = getpass . getpass ( prompt ) <NEWLINE> if password and confirm : <NEWLINE> <INDENT> password2 = getpass . getpass ( <STRING> ) <NEWLINE> if password != password2 : <NEWLINE> <INDENT> sys . exit ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> password = raw_input ( prompt ) <NEWLINE> <DEDENT> if not password : <NEWLINE> <INDENT> password = None <NEWLINE> <DEDENT> return password <NEWLINE> <DEDENT>
def is_thread_waiting_for_me ( self , checked_thread ) : <NEWLINE> <INDENT> my_thread = threading . currentThread ( ) <NEWLINE> threading . main_thread ( ) <NEWLINE> <DEDENT>
import gevent <NEWLINE> from gevent import socket <NEWLINE> from gevent import monkey <NEWLINE> monkey . patch_socket ( ) <NEWLINE> from dnslib import A , AAAA , CNAME , MX , RR , TXT <NEWLINE> from dnslib import DNSHeader , DNSRecord , QTYPE <NEWLINE> AF_INET = 2 <NEWLINE> SOCK_DGRAM = 2 <NEWLINE> s = socket . socket ( AF_INET , SOCK_DGRAM ) <NEWLINE> s . bind ( ( <STRING> , 53 ) ) <NEWLINE> IP = <STRING> <NEWLINE> IPV6 = ( 0 , ) * 16 <NEWLINE> MSG = <STRING> <NEWLINE>
class LogTest ( ExtendedTestCase ) : <NEWLINE> <INDENT> def test_enums ( self ) : <NEWLINE> <INDENT> self . assertEnumIsFullyDefined ( MessageLevelEnum , <STRING> , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from __future__ import print_function <NEWLINE> import os <NEWLINE> import sys <NEWLINE> import re <NEWLINE> import tempfile <NEWLINE> import shutil <NEWLINE> import subprocess <NEWLINE>
class Migration ( migrations . Migration ) : <NEWLINE> <INDENT> dependencies = [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE> operations = [ <NEWLINE> <INDENT> migrations . AlterField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> field = models . BigIntegerField ( default = None , null = True ) , <NEWLINE> <DEDENT> ) , <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT>
from oslo_log import log <NEWLINE> from oslo_utils import timeutils <NEWLINE> from manila import exception <NEWLINE> from manila . share import api <NEWLINE> from manila . share import hook <NEWLINE> from manila . share . hooks import zaqarclientwrapper <NEWLINE> CONF = zaqarclientwrapper . CONF <NEWLINE> LOG = log . getLogger ( __name__ ) <NEWLINE> ZAQARCLIENT = zaqarclientwrapper . ZAQARCLIENT <NEWLINE>
from formalchemy . tests import * <NEWLINE> from formalchemy . fields import PasswordFieldRenderer <NEWLINE> try : <NEWLINE> <INDENT> import json <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> import simplejson as json <NEWLINE> <DEDENT>
def register ( ) : <NEWLINE> <INDENT> bpy . utils . register_class ( AppleseedMatLayerProps ) <NEWLINE> bpy . utils . register_class ( AppleseedMatProps ) <NEWLINE> bpy . types . Material . appleseed = bpy . props . PointerProperty ( type = AppleseedMatProps ) <NEWLINE> <DEDENT>
botellas = 99 <NEWLINE> while ( botellas > 0 ) : <NEWLINE> <INDENT> print ( botellas , <STRING> , botellas , <STRING> ) <NEWLINE> botellas = botellas - 1 <NEWLINE> print ( <STRING> , botellas , <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
from toontown . classicchars import DistributedGoofySpeedwayAI <NEWLINE> from toontown . dna . DNAParser import DNAGroup , DNAVisGroup <NEWLINE> from toontown . hood import HoodAI <NEWLINE> from toontown . hood import ZoneUtil <NEWLINE> from toontown . racing import RaceGlobals <NEWLINE> from toontown . racing . DistributedRacePadAI import DistributedRacePadAI <NEWLINE> from toontown . racing . DistributedStartingBlockAI import DistributedStartingBlockAI <NEWLINE> from toontown . racing . DistributedViewPadAI import DistributedViewPadAI <NEWLINE> from toontown . racing . DistributedStartingBlockAI import DistributedViewingBlockAI <NEWLINE> from toontown . toonbase import ToontownGlobals <NEWLINE>
from vt_manager . controller . MacAllocator import MACallocator <NEWLINE> from vt_manager . controller . SlotAllocator import SlotAllocator <NEWLINE> from vt_manager . models . Slot import Slot <NEWLINE> from vt_manager . models . Mac import Mac <NEWLINE> sa = SlotAllocator ( ) <NEWLINE> ma = MACallocator ( ) <NEWLINE> s = sa . acquire ( <STRING> , <STRING> , <STRING> ) <NEWLINE> m = ma . acquire ( <STRING> , <STRING> , <STRING> ) <NEWLINE> print ( m ) <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> import getopt <NEWLINE> import subprocess <NEWLINE> import tempfile <NEWLINE> import re <NEWLINE> import shutil <NEWLINE>
def create_playlist ( self , name , tracks ) : <NEWLINE> <INDENT> me = self . _client . get_me ( ) <NEWLINE> playlist = self . _client . create_playlist ( me [ <STRING> ] , name ) <NEWLINE> for c in self . _create_chunks ( tracks , 50 ) : <NEWLINE> <INDENT> self . _client . add_playlist_tracks ( me [ <STRING> ] , playlist [ <STRING> ] , c ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> __author__ = <STRING> <NEWLINE> __version__ = <STRING> <NEWLINE> from operator import neg , truediv <NEWLINE> import numpy as np <NEWLINE> import pandas as pd <NEWLINE> from numpy . random import binomial <NEWLINE> from pyugend . Models import Base_model <NEWLINE>
<STRING> <NEWLINE> import sys <NEWLINE> from PyQt4 import QtCore , QtGui , QtWebKit <NEWLINE>
import commands <NEWLINE> from datetime import datetime <NEWLINE> import functools <NEWLINE> from time import mktime , sleep , time <NEWLINE> import pytz <NEWLINE>
def entropy ( img ) : <NEWLINE> <INDENT> histogram = img . histogram ( ) <NEWLINE> histogram_length = sum ( histogram ) <NEWLINE> samples_probability = [ float ( h ) / histogram_length for h in histogram ] <NEWLINE> return - sum ( [ p * math . log ( p , 2 ) for p in samples_probability if p != 0 ] ) <NEWLINE> <DEDENT>
def load_yaml_config ( filepath ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with open ( filepath ) as f : <NEWLINE> <INDENT> return yaml . load ( f ) <NEWLINE> <DEDENT> <DEDENT>
class Solution : <NEWLINE> <INDENT> def removeElement ( self , A , elem ) : <NEWLINE> <INDENT> p1 = 0 <NEWLINE> p2 = 0 <NEWLINE> while p2 < len ( A ) : <NEWLINE> <INDENT> if A [ p2 ] != elem : <NEWLINE> <INDENT> A [ p1 ] = A [ p2 ] <NEWLINE> p1 += 1 <NEWLINE> <DEDENT> p2 += 1 <NEWLINE> <DEDENT> return p1 <NEWLINE> <DEDENT> <DEDENT>
from oslo_config import cfg <NEWLINE> from keystoneclient . auth . identity . v3 import base <NEWLINE> __all__ = [ <STRING> , <STRING> ] <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ctypes . windll . shell32 . SetCurrentProcessExplicitAppUserModelID ( <STRING> ) <NEWLINE> app = QtGui . QApplication ( sys . argv ) <NEWLINE> app . setWindowIcon ( QtGui . QIcon ( <STRING> ) ) <NEWLINE> me = MainEngine ( ) <NEWLINE> mw = MainWindow ( me . ee , me ) <NEWLINE> mw . showMaximized ( ) <NEWLINE> sys . exit ( app . exec_ ( ) ) <NEWLINE> <DEDENT>
import os <NEWLINE> import logging <NEWLINE> from logging . handlers import RotatingFileHandler <NEWLINE> from constants import HOME , LOG_DIR , LOG_FILE , MAX_LOG_SIZE <NEWLINE>
import os <NEWLINE> import dynamixel <NEWLINE> import time <NEWLINE> import random <NEWLINE> import sys <NEWLINE> import subprocess <NEWLINE> import optparse <NEWLINE> import yaml <NEWLINE> import numpy as np <NEWLINE> import hubo_ach as ha <NEWLINE> import ach <NEWLINE>
def test_file_passing_blob_from_gzip ( ) : <NEWLINE> <INDENT> import gzip <NEWLINE> src = get_fn ( <STRING> ) <NEWLINE> blob = gzip . open ( src ) . read ( ) <NEWLINE> fm = FileManager ( blob ) <NEWLINE> assert not fm . is_filename <NEWLINE> with pytest . raises ( ValueError ) : <NEWLINE> <INDENT> fm . ext <NEWLINE> <DEDENT> <DEDENT>
def rho ( n , f = f1 ) : <NEWLINE> <INDENT> x = 2 <NEWLINE> y = 2 <NEWLINE> d = 1 <NEWLINE> while d == 1 : <NEWLINE> <INDENT> x = f ( x , n ) <NEWLINE> y = f ( f ( y , n ) , n ) <NEWLINE> d = gcd ( abs ( x - y ) , n ) <NEWLINE> <DEDENT> if d == n : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return d <NEWLINE> <DEDENT>
def _populate_with_data ( self ) : <NEWLINE> <INDENT> self . _populate_freedesktop_attributes ( ) <NEWLINE> number_of_files = self . _wrapper . number_of_files <NEWLINE> self . _statusbar . pop ( 1 ) <NEWLINE> if 1 < number_of_files : <NEWLINE> <INDENT> self . _statusbar . push ( 1 , <STRING> . format ( number_of_files ) ) <NEWLINE> <DEDENT> elif 1 == number_of_files : <NEWLINE> <INDENT> file_name = self . _wrapper . file_names [ 0 ] <NEWLINE> self . _statusbar . push ( 1 , <STRING> . format ( file_name ) ) <NEWLINE> <DEDENT> <DEDENT>
def cb ( ) : <NEWLINE> <INDENT> from . GeventWSFactory import GeventWSFactory <NEWLINE> return GeventWSFactory ( ) <NEWLINE> <DEDENT>
def lca ( node_0 , node_1 ) : <NEWLINE> <INDENT> iter_0 , iter_1 = node_0 , node_1 <NEWLINE> nodes_on_path_to_root = set ( ) <NEWLINE> while iter_0 or iter_1 : <NEWLINE> <INDENT> if iter_0 : <NEWLINE> <INDENT> if iter_0 in nodes_on_path_to_root : <NEWLINE> <INDENT> return iter_0 <NEWLINE> <DEDENT> nodes_on_path_to_root . add ( iter_0 ) <NEWLINE> iter_0 = iter_0 . parent <NEWLINE> <DEDENT> if iter_1 : <NEWLINE> <INDENT> if iter_1 in nodes_on_path_to_root : <NEWLINE> <INDENT> return iter_1 <NEWLINE> <DEDENT> nodes_on_path_to_root . add ( iter_1 ) <NEWLINE> iter_1 = iter_1 . parent <NEWLINE> <DEDENT> <DEDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT>
def flatten_gender ( row ) : <NEWLINE> <INDENT> g = <STRING> <NEWLINE> if not pd . isnull ( row [ <STRING> ] ) : <NEWLINE> <INDENT> g = <STRING> <NEWLINE> <DEDENT> elif not pd . isnull ( row [ <STRING> ] ) : <NEWLINE> <INDENT> g = <STRING> <NEWLINE> <DEDENT> elif not pd . isnull ( row [ <STRING> ] ) : <NEWLINE> <INDENT> g = <STRING> <NEWLINE> <DEDENT> elif not pd . isnull ( row [ <STRING> ] ) : <NEWLINE> <INDENT> g = <STRING> <NEWLINE> <DEDENT> elif not pd . isnull ( row [ <STRING> ] ) : <NEWLINE> <INDENT> g = <STRING> <NEWLINE> <DEDENT> return g <NEWLINE> <DEDENT>
def add_lift ( self , axis = <STRING> , type_ = <STRING> ) : <NEWLINE> <INDENT> Element . add_lift ( self , axis , type_ ) <NEWLINE> self . _has_lift = True <NEWLINE> <DEDENT>
import os <NEWLINE> import subprocess <NEWLINE> import sys <NEWLINE> prog , path = sys . argv <NEWLINE> dirname , basename = os . path . split ( path ) <NEWLINE> try : <NEWLINE> <INDENT> subprocess . call ( [ sys . executable , basename ] , cwd = dirname ) <NEWLINE> <DEDENT> except KeyboardInterrupt : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> print ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> input ( ) <NEWLINE>
def _run_server ( ) : <NEWLINE> <INDENT> host = cfg . CONF . api . host <NEWLINE> port = cfg . CONF . api . port <NEWLINE> LOG . info ( <STRING> , os . getpid ( ) , host , port ) <NEWLINE> max_pool_size = eventlet . wsgi . DEFAULT_MAX_SIMULTANEOUS_REQUESTS <NEWLINE> worker_pool = eventlet . GreenPool ( max_pool_size ) <NEWLINE> sock = eventlet . listen ( ( host , port ) ) <NEWLINE> wsgi . server ( sock , app . setup_app ( ) , custom_pool = worker_pool , log = LOG , log_output = False ) <NEWLINE> return 0 <NEWLINE> <DEDENT>
from __future__ import absolute_import , unicode_literals <NEWLINE> import unittest <NEWLINE> import json <NEWLINE> from base64 import b64encode <NEWLINE> from flask import current_app , url_for <NEWLINE> from app import create_app , db <NEWLINE> from app . models import Role , User , RawCourse , Course <NEWLINE> student_id = <STRING> <NEWLINE> other_student_id = <STRING> <NEWLINE> old_student_id = <STRING> <NEWLINE>
from unittest import TestCase <NEWLINE> from cartodb_services . refactor . storage . null_config import NullConfigStorage <NEWLINE> from cartodb_services . refactor . core . interfaces import ConfigBackendInterface <NEWLINE>
<STRING> <NEWLINE> from wand . image import Image <NEWLINE> pix = 0 <NEWLINE> with Image ( filename = <STRING> ) as a : <NEWLINE> <INDENT> for i in range ( 6 ) : <NEWLINE> <INDENT> with a . clone ( ) as img : <NEWLINE> <INDENT> print ( pix ) <NEWLINE> img . crop ( top = pix , height = 1024 ) <NEWLINE> img . save ( filename = <STRING> + str ( i ) + <STRING> ) <NEWLINE> <DEDENT> pix += 1024 <NEWLINE> <DEDENT> <DEDENT>
def isOnTextBorder ( self , sender ) : <NEWLINE> <INDENT> twX = self . richText . getAbsoluteLeft ( ) <NEWLINE> twY = self . richText . getAbsoluteTop ( ) <NEWLINE> x = event . getClientX ( ) - twX <NEWLINE> y = event . getClientY ( ) - twY <NEWLINE> width = self . richText . getOffsetWidth ( ) <NEWLINE> height = self . richText . getOffsetHeight ( ) <NEWLINE> return ( ( sender == self . richText ) and <NEWLINE> <INDENT> ( ( x <= 0 ) or ( x >= width ) or <NEWLINE> ( y <= 0 ) or ( y >= height ) ) ) <NEWLINE> <DEDENT> <DEDENT>
def test_basic_queue ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> q = self . ps . queue ( <STRING> ) <NEWLINE> self . assertEqual ( q . __class__ , Queue ) <NEWLINE> q . put ( <STRING> ) <NEWLINE> q . put ( <STRING> ) <NEWLINE> q . put ( <STRING> ) <NEWLINE> q . put ( <STRING> ) <NEWLINE> r = [ ] <NEWLINE> for x in range ( 0 , 4 ) : <NEWLINE> <INDENT> r . append ( q . get ( timeout = 2 ) ) <NEWLINE> <DEDENT> self . assertEqual ( r , [ <STRING> , <STRING> , <STRING> , <STRING> ] , <STRING> ) <NEWLINE> <DEDENT>
def __init__ ( self , info_hash ) : <NEWLINE> <INDENT> self . info = redis . hgetall ( info_hash ) <NEWLINE> self . info_hash = info_hash <NEWLINE> <DEDENT>
import re <NEWLINE> import platform <NEWLINE> from decimal import Decimal <NEWLINE> from urllib import quote <NEWLINE> from PyQt4 . QtGui import * <NEWLINE> from PyQt4 . QtCore import * <NEWLINE> import PyQt4 . QtCore as QtCore <NEWLINE> import PyQt4 . QtGui as QtGui <NEWLINE> from electrum_boli_gui . qt . qrcodewidget import QRCodeWidget <NEWLINE> from electrum_boli . i18n import _ <NEWLINE> if platform . system ( ) == <STRING> : <NEWLINE> <INDENT> MONOSPACE_FONT = <STRING> <NEWLINE> <DEDENT> elif platform . system ( ) == <STRING> : <NEWLINE> <INDENT> MONOSPACE_FONT = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> MONOSPACE_FONT = <STRING> <NEWLINE> <DEDENT> column_index = 4 <NEWLINE>
<STRING> <NEWLINE> import os <NEWLINE> import configparser <NEWLINE> import logging <NEWLINE> from collections import defaultdict <NEWLINE> import homeassistant <NEWLINE> import homeassistant . loader as loader <NEWLINE> import homeassistant . components as core_components <NEWLINE>
def extract_images ( article_content ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> extractor = ImageExtractor ( ) <NEWLINE> extractor . feed ( article_content ) <NEWLINE> return extractor . images <NEWLINE> <DEDENT>
def read ( self , qid ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> indexfilepath = glob . glob ( os . path . join ( self . indexdir , <STRING> % qid ) ) <NEWLINE> if len ( indexfilepath ) == 0 : <NEWLINE> <INDENT> raise Exception ( <STRING> , qid ) <NEWLINE> <DEDENT> if len ( indexfilepath ) > 1 : <NEWLINE> <INDENT> raise Exception ( <STRING> , str ( indexfilepath ) ) <NEWLINE> <DEDENT> indexfilepath = indexfilepath [ 0 ] <NEWLINE> indices = self . _read_index ( qid , indexfilepath ) <NEWLINE> return indices <NEWLINE> <DEDENT>
def redirect ( self , f = None , args = [ ] , vars = { } , flash = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if flash : <NEWLINE> <INDENT> self . session . flash = flash <NEWLINE> <DEDENT> redirect ( self . action ( f , args , vars ) ) <NEWLINE> <DEDENT>
class FeedbackUploadForm ( forms . Form ) : <NEWLINE> <INDENT> file_upload = forms . FileField ( <NEWLINE> <INDENT> widget = forms . FileInput ( <NEWLINE> <INDENT> attrs = { <NEWLINE> <INDENT> <STRING> : <STRING> <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from __future__ import absolute_import , print_function <NEWLINE> from flask import Blueprint , abort , jsonify , request , session , url_for <NEWLINE> from flask_oauthlib . client import OAuth , prepare_request <NEWLINE> from mock import MagicMock <NEWLINE> from six . moves . urllib . parse import urlparse <NEWLINE> from werkzeug . urls import url_decode , url_parse , url_unparse <NEWLINE>
from soap . semantics . functions . arithmetic import arith_eval , error_eval <NEWLINE> from soap . semantics . functions . boolean import bool_eval <NEWLINE> from soap . semantics . functions . fixpoint import ( <NEWLINE> <INDENT> fixpoint_eval , unroll_fix_expr , fix_expr_eval <NEWLINE> <DEDENT> ) <NEWLINE> from soap . semantics . functions . label import label , luts , resource_eval <NEWLINE> from soap . semantics . functions . meta import expand_expr , expand_meta_state <NEWLINE>
class Plugin ( PluginBase ) : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> doc = <STRING> <NEWLINE> methods_subclass = { } <NEWLINE> def handle_input ( self , term_system , term_globals , exec_locals , text ) : <NEWLINE> <INDENT> fname , method , args = self . get_method_args ( text ) <NEWLINE> ret = list ( term_system . plugins ) <NEWLINE> return ret <NEWLINE> <DEDENT> <DEDENT>
class MentalUsException ( Exception ) : <NEWLINE> <INDENT> code = 0 <NEWLINE> def to_json ( self ) : <NEWLINE> <INDENT> return dict ( code = self . code , msg = self . msg ) <NEWLINE> <DEDENT> <DEDENT>
class OpenID ( object ) : <NEWLINE> <INDENT> GOOGLE = 1 <NEWLINE> FACEBOOK = 2 <NEWLINE> TWITTER = 3 <NEWLINE> FRIENDFEED = 4 <NEWLINE> NAME = { GOOGLE : <STRING> , FACEBOOK : <STRING> , <NEWLINE> <INDENT> TWITTER : <STRING> , FRIENDFEED : <STRING> } <NEWLINE> <DEDENT> <DEDENT>
import optparse <NEWLINE> from django . core . management . base import BaseCommand <NEWLINE> from cumulus . authentication import Auth <NEWLINE>
class MissingPackage ( ConnectorException ) : <NEWLINE> <INDENT> def __init__ ( self , driver , supported_packages ) : <NEWLINE> <INDENT> if not isinstance ( supported_packages , list ) : <NEWLINE> <INDENT> supported_packages = [ supported_packages ] <NEWLINE> <DEDENT> message = <STRING> % driver <NEWLINE> if len ( supported_packages ) == 1 : <NEWLINE> <INDENT> message += <STRING> % supported_packages [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> message += <STRING> % ( <STRING> . join ( supported_packages ) ) <NEWLINE> <DEDENT> super ( MissingPackage , self ) . __init__ ( message ) <NEWLINE> <DEDENT> <DEDENT>
def generate_search_index ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> page_dicts = { <NEWLINE> <INDENT> <STRING> : self . _entries , <NEWLINE> <DEDENT> } <NEWLINE> return json . dumps ( page_dicts , sort_keys = True , indent = 4 ) <NEWLINE> <DEDENT>
class Lungs ( object ) : <NEWLINE> <INDENT> def __init__ ( self , msml_filename , p ) : <NEWLINE> <INDENT> self . app = App ( exporter = <STRING> , output_dir = <STRING> + str ( p ) , executor = <STRING> ) <NEWLINE> self . mf = self . app . _load_msml_file ( msml_filename ) <NEWLINE> self . _surface_pressure = p <NEWLINE> <DEDENT> def __call__ ( self ) : <NEWLINE> <INDENT> self . app . memory_init_file = { <NEWLINE> <INDENT> <STRING> : self . _surface_pressure <NEWLINE> <DEDENT> } <NEWLINE> mem = self . app . execute_msml ( self . mf , ) <NEWLINE> return mem . _internal [ <STRING> ] [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT>
def test_instance_type_extra_specs_update ( self ) : <NEWLINE> <INDENT> self . specs [ <STRING> ] = <STRING> <NEWLINE> db . flavor_extra_specs_update_or_create ( <NEWLINE> <INDENT> self . context , <NEWLINE> self . flavorid , <NEWLINE> dict ( cpu_model = <STRING> ) ) <NEWLINE> <DEDENT> actual_specs = db . flavor_extra_specs_get ( <NEWLINE> <INDENT> self . context , <NEWLINE> self . flavorid ) <NEWLINE> <DEDENT> self . assertEqual ( self . specs , actual_specs ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from __future__ import division <NEWLINE> import grid . grid as grid <NEWLINE> import sys <NEWLINE> import argparse <NEWLINE> import os <NEWLINE>
def makeHeader ( resultList , path , timestep , name , units ) : <NEWLINE> <INDENT> resultList . Add ( <STRING> , GH_Path ( path ) ) <NEWLINE> resultList . Add ( location , GH_Path ( path ) ) <NEWLINE> resultList . Add ( name , GH_Path ( path ) ) <NEWLINE> resultList . Add ( units , GH_Path ( path ) ) <NEWLINE> resultList . Add ( timestep , GH_Path ( path ) ) <NEWLINE> resultList . Add ( start , GH_Path ( path ) ) <NEWLINE> resultList . Add ( end , GH_Path ( path ) ) <NEWLINE> <DEDENT>
def buildCircle ( name ) : <NEWLINE> <INDENT> cmds . circle ( name = name , c = ( 0 , 0 , 0 ) , nr = ( 0 , 1 , 0 ) , sw = 360 , r = 1 , d = 3 , ut = 0 , tol = 0.0001 , s = 8 , ch = False ) <NEWLINE> getShape = cmds . listRelatives ( name , shapes = True ) <NEWLINE> cmds . rename ( getShape [ 0 ] , <STRING> . format ( name ) ) <NEWLINE> return name <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> f = open ( <STRING> , <STRING> ) ; <NEWLINE> for i in range ( 2048 ) : <NEWLINE> <INDENT> s = <STRING> + str ( i ) + <STRING> <NEWLINE> f . write ( s ) <NEWLINE> <DEDENT> f . close ( ) <NEWLINE> <DEDENT>
import datetime <NEWLINE> import logging <NEWLINE> import random <NEWLINE> from mixer . backend . flask import Mixer <NEWLINE> import mixer . fakers as mxfake <NEWLINE> import mixer . generators as mxgen <NEWLINE> import pytz <NEWLINE> from six . moves import range <NEWLINE> from trafficdb . models import * <NEWLINE> log = logging . getLogger ( __name__ ) <NEWLINE> DEFAULT_START = datetime . datetime ( 2013 , 4 , 29 , tzinfo = pytz . utc ) <NEWLINE>
class GridSearch ( GridSearchCV ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def decision_function ( self , X ) : <NEWLINE> <INDENT> return super ( GridSearch , self ) . decision_function ( X ) <NEWLINE> <DEDENT> def predict ( self , X ) : <NEWLINE> <INDENT> return super ( GridSearch , self ) . predict ( X ) <NEWLINE> <DEDENT> <DEDENT>
from . import timers <NEWLINE> from . time_zone import TimeZone <NEWLINE> __all__ = [ <STRING> , <NEWLINE> <INDENT> <STRING> ] <NEWLINE> <DEDENT>
a , b = 2 , 2 <NEWLINE> print ( <STRING> % a ) <NEWLINE> print ( <STRING> % b ) <NEWLINE> c = b <NEWLINE> print ( <STRING> * 8 ) <NEWLINE> i = 8 <NEWLINE> while c > 0 : <NEWLINE> <INDENT> print ( <STRING> % ( i , ( c % 10 ) * a ) ) <NEWLINE> c = c / 10 <NEWLINE> i -= 1 <NEWLINE> <DEDENT> if i == 7 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> * 8 ) <NEWLINE> print ( <STRING> % ( a * b ) ) <NEWLINE> print ( <STRING> * 20 ) <NEWLINE> <DEDENT>
import os <NEWLINE> import pytest <NEWLINE> from contextlib import contextmanager <NEWLINE> from twitter . common . contextutil import temporary_dir <NEWLINE> from twitter . common . dirutil import Fileset as RealFileset , touch <NEWLINE>
def checkTraficLightBH ( self ) : <NEWLINE> <INDENT> self . activityTimer . callback . remove ( self . checkTraficLightBH ) <NEWLINE> self . activityTimer . start ( 100 , False ) <NEWLINE> self . startActualUpdate ( True ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> __updated__ = <STRING> <NEWLINE> import xml . etree . ElementTree as ET <NEWLINE> from twisted . trial import unittest <NEWLINE> from Modules . Families . UPB . UPB_device import API as upbDeviceAPI <NEWLINE> from test . xml_data import XML_LONG , TESTING_PYHOUSE <NEWLINE> from test . testing_mixin import SetupPyHouseObj <NEWLINE>
import W <NEWLINE> from Carbon import Windows <NEWLINE> w = W . ModalDialog ( ( 100 , 100 ) ) <NEWLINE> w . ed = W . EditText ( ( 10 , 10 , 80 , 50 ) ) <NEWLINE> w . ok = W . Button ( ( 10 , 70 , 80 , 16 ) , <STRING> , w . close ) <NEWLINE> w . setdefaultbutton ( w . ok ) <NEWLINE> w . open ( ) <NEWLINE>
def test_write_to_completion_cache ( self ) : <NEWLINE> <INDENT> manager = base . Manager ( ) <NEWLINE> manager . write_to_completion_cache ( <STRING> , <STRING> ) <NEWLINE> manager . _mock_cache = mock . Mock ( ) <NEWLINE> manager . _mock_cache . write = mock . Mock ( return_value = None ) <NEWLINE> manager . write_to_completion_cache ( <STRING> , <STRING> ) <NEWLINE> self . assertEqual ( 1 , manager . _mock_cache . write . call_count ) <NEWLINE> <DEDENT>
from django . conf import settings <NEWLINE> from django . contrib import messages <NEWLINE> from django . contrib . auth . models import User <NEWLINE> from django . core . urlresolvers import reverse <NEWLINE> from django . db . models . signals import post_save , pre_save , post_delete , pre_delete <NEWLINE> from django . dispatch import receiver <NEWLINE> from django . http import HttpResponse , HttpResponseRedirect , Http404 <NEWLINE> from django . shortcuts import render , get_object_or_404 , redirect <NEWLINE> from django . utils . translation import ugettext as _ <NEWLINE>
def print_anagrams ( sorted_words , all_words ) : <NEWLINE> <INDENT> match_count = 0 <NEWLINE> valid_set = set ( all_words ) <NEWLINE> matches = defaultdict ( list ) <NEWLINE> for word in sorted_words : <NEWLINE> <INDENT> if word in valid_set : <NEWLINE> <INDENT> sorted_letters = <STRING> . join ( sorted ( word ) ) <NEWLINE> matching_words = matches [ sorted_letters ] <NEWLINE> matching_words . append ( word ) <NEWLINE> if len ( matching_words ) > 1 : <NEWLINE> <INDENT> print ( <STRING> . join ( matching_words ) ) <NEWLINE> print <NEWLINE> match_count += 1 <NEWLINE> if match_count > 100 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import cv2 <NEWLINE> import sys <NEWLINE> import cvutil as u <NEWLINE> cap = u . source_video ( sys . argv ) <NEWLINE> count = 0 <NEWLINE> while ( count < 10 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> _ , frame = cap . read ( ) <NEWLINE> cv2 . imshow ( <STRING> , frame ) <NEWLINE> cv2 . imwrite ( <STRING> . format ( count ) , frame ) <NEWLINE> <DEDENT> cv2 . destroyAllWindows ( ) <NEWLINE>
def add_pilot_from_values ( self , pilot_name , aircraft , livery ) : <NEWLINE> <INDENT> pilot = Roster . Pilot ( pilot_name , aircraft , livery ) <NEWLINE> self . add_pilot_object ( pilot ) <NEWLINE> <DEDENT>
def decrypt ( test_key ) : <NEWLINE> <INDENT> cnt = Counter ( test_key ) <NEWLINE> return <STRING> . join ( str ( cnt [ a ] ) for a in ascii_lowercase ) <NEWLINE> <DEDENT>
class DynamicExtended ( OneOf ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , key , value , additional_field , fuzzable = True , name = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if name is None : <NEWLINE> <INDENT> name = key <NEWLINE> <DEDENT> fields = [ <NEWLINE> <INDENT> Dynamic ( key = key , default_value = value , length = len ( value ) , fuzzable = True , name = _join_name ( name , <STRING> ) ) , <NEWLINE> additional_field <NEWLINE> <DEDENT> ] <NEWLINE> super ( DynamicExtended , self ) . __init__ ( fields = fields , fuzzable = fuzzable , name = name ) <NEWLINE> <DEDENT> <DEDENT>
def test_safedata ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def encode_decode ( data ) : <NEWLINE> <INDENT> message = Message ( constants . DEBUG , data ) <NEWLINE> encoded = storage . _encode ( message ) <NEWLINE> decoded = storage . _decode ( encoded ) <NEWLINE> return decoded . message <NEWLINE> <DEDENT> storage = self . get_storage ( ) <NEWLINE> self . assertIsInstance ( <NEWLINE> <INDENT> encode_decode ( mark_safe ( <STRING> ) ) , SafeData ) <NEWLINE> <DEDENT> self . assertNotIsInstance ( <NEWLINE> <INDENT> encode_decode ( <STRING> ) , SafeData ) <NEWLINE> <DEDENT> <DEDENT>
def is_demo ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . is_demo_collection_id ( self . id ) <NEWLINE> <DEDENT>
import pytest <NEWLINE> from tests . globals import local_filepath , remote_filepath <NEWLINE> from xsdtocls . tools import cli <NEWLINE>
def test_countdown_after_start_returns_countdown_to_end ( self , event ) : <NEWLINE> <INDENT> event . end = arrow . utcnow ( ) . replace ( minutes = + 5 , seconds = + 1 ) <NEWLINE> countdown = event . countdown ( ) <NEWLINE> expected = <STRING> . format ( event . summary ) <NEWLINE> assert countdown == expected <NEWLINE> <DEDENT>
def delete_tag ( self , context , resource , resource_id , tag ) : <NEWLINE> <INDENT> res = self . _get_resource ( context , resource , resource_id ) <NEWLINE> with context . session . begin ( subtransactions = True ) : <NEWLINE> <INDENT> query = context . session . query ( tag_model . Tag ) <NEWLINE> query = query . filter_by ( tag = tag , <NEWLINE> <INDENT> standard_attr_id = res . standard_attr_id ) <NEWLINE> <DEDENT> if not query . delete ( ) : <NEWLINE> <INDENT> raise tag_ext . TagNotFound ( tag = tag ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_url ( s ) : <NEWLINE> <INDENT> m = _re_match_url . search ( s ) <NEWLINE> if not m : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> return m . group ( 1 ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from hashdd import hashdd <NEWLINE>
def filter_dict_by_keys ( dict_ , field_names ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return { key : value for ( key , value ) in dict_ . items ( ) <NEWLINE> <INDENT> if key in field_names } <NEWLINE> <DEDENT> <DEDENT>
def valid_low_rate ( self , device ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for testrate in [ 25000 ] : <NEWLINE> <INDENT> if self . valid_test ( device , testrate ) : <NEWLINE> <INDENT> return testrate <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , device ) <NEWLINE> return None <NEWLINE> <DEDENT>
def _get_url ( self , resource ) : <NEWLINE> <INDENT> if is_collection ( resource ) : <NEWLINE> <INDENT> resource = map ( str , resource ) <NEWLINE> resource = <STRING> . join ( resource ) <NEWLINE> <DEDENT> return resource <NEWLINE> <DEDENT>
def get_match ( self , pattern , source , default = <STRING> ) : <NEWLINE> <INDENT> res = re . findall ( pattern , source ) <NEWLINE> if len ( res ) > 0 : <NEWLINE> <INDENT> return res [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return default <NEWLINE> <DEDENT> <DEDENT>
def dumps ( * args , ** kwargs ) : <NEWLINE> <INDENT> kwargs [ <STRING> ] = Processor ( ) <NEWLINE> return json . dumps ( * args , ** kwargs ) <NEWLINE> <DEDENT>
def tearDown ( self ) : <NEWLINE> <INDENT> tablet . Tablet . check_vttablet_count ( ) <NEWLINE> for t in [ master_tablet , replica_tablet ] : <NEWLINE> <INDENT> t . reset_replication ( ) <NEWLINE> t . set_semi_sync_enabled ( master = False ) <NEWLINE> t . clean_dbs ( ) <NEWLINE> <DEDENT> <DEDENT>
from django . conf . urls import * <NEWLINE> from localwiki . utils . views import GetCSRFCookieView <NEWLINE> urlpatterns = patterns ( <STRING> , <NEWLINE> <INDENT> url ( <STRING> , <STRING> ) , <NEWLINE> url ( <STRING> , <STRING> ) , <NEWLINE> url ( <STRING> , <STRING> ) , <NEWLINE> url ( <STRING> , <STRING> ) , <NEWLINE> url ( <STRING> , GetCSRFCookieView . as_view ( ) , name = <STRING> ) , <NEWLINE> <DEDENT> ) <NEWLINE>
def get_similar ( asin ) : <NEWLINE> <INDENT> baseurl = <STRING> <NEWLINE> service = <STRING> <NEWLINE> amazonid = <STRING> <NEWLINE> access = <STRING> + amazonid <NEWLINE> operation = <STRING> + asin <NEWLINE> r = urllib . urlopen ( baseurl + service + access + operation ) <NEWLINE> return r <NEWLINE> <DEDENT>
from arduino import * <NEWLINE> myservo = Servo ( ) <NEWLINE> pos = 0 <NEWLINE> pin = 11 <NEWLINE> myservo . attach ( pin ) <NEWLINE>
from aux . system . base import BaseSystem <NEWLINE> from aux . authentication import BaseCredentials <NEWLINE> from aux . api import ssh <NEWLINE>
def __init__ ( self , method , start_response , context ) : <NEWLINE> <INDENT> self . method = method <NEWLINE> self . start_response = start_response <NEWLINE> self . context = context <NEWLINE> self . _write_buffer = [ ] <NEWLINE> self . _finished = False <NEWLINE> self . _expected_content_remaining = None <NEWLINE> self . _error = None <NEWLINE> <DEDENT>
from openerp . tools . translate import _ <NEWLINE> from openerp . osv import fields , osv <NEWLINE> import openerp . addons . decimal_precision as dp <NEWLINE>
def __str__ ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return <STRING> . format ( self . pathField , self . fieldList ) <NEWLINE> <DEDENT>
class MainConfigDirectory ( ConfigDirectory ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> __pathname__ = CONFIG_DIR_PATHNAME <NEWLINE> <DEDENT>
def true_pos_handler ( msg ) : <NEWLINE> <INDENT> true_pos [ 0 ] = msg . pose . position . x <NEWLINE> true_pos [ 1 ] = msg . pose . position . y <NEWLINE> true_pos [ 2 ] = msg . pose . position . z <NEWLINE> <DEDENT>
from django . contrib . auth . mixins import LoginRequiredMixin <NEWLINE> from django . core . exceptions import PermissionDenied <NEWLINE> from django . shortcuts import get_object_or_404 , redirect <NEWLINE> from django . urls import reverse <NEWLINE> from django . views . generic . base import TemplateView <NEWLINE> from projects . models import Project <NEWLINE>
from unittest import TestCase <NEWLINE> try : <NEWLINE> <INDENT> from unittest import mock <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> import mock <NEWLINE> <DEDENT> from bettercache . middleware import BetterCacheMiddleware <NEWLINE>
import shutil <NEWLINE> import sys <NEWLINE> import os <NEWLINE> import re <NEWLINE> from optparse import OptionParser <NEWLINE>
class TestLogin ( unittest . TestCase ) : <NEWLINE> <INDENT> def testmadison ( self ) : <NEWLINE> <INDENT> f = open ( <STRING> , <STRING> ) <NEWLINE> html = f . read ( ) <NEWLINE> page = koha . LoginPage ( None , html ) <NEWLINE> action , data = page . createPost ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
__all__ = [ <STRING> ] <NEWLINE> import struct <NEWLINE> import logging <NEWLINE> import core <NEWLINE> log = logging . getLogger ( <STRING> ) <NEWLINE>
from setuptools import setup <NEWLINE> setup ( name = <STRING> , <NEWLINE> <INDENT> version = <STRING> , <NEWLINE> description = <STRING> , <NEWLINE> url = <STRING> , <NEWLINE> author = <STRING> , <NEWLINE> author_email = <STRING> , <NEWLINE> license = <STRING> , <NEWLINE> packages = [ <STRING> ] , <NEWLINE> zip_safe = False , <NEWLINE> install_requires = [ <STRING> , <STRING> , <STRING> , <STRING> ] ) <NEWLINE> <DEDENT>
def test_run_extra_args ( self ) : <NEWLINE> <INDENT> self . add_new ( <STRING> , example . ex_linuxdoc ) <NEWLINE> fullpath = opj ( self . tempdir , <STRING> , <STRING> ) <NEWLINE> argv = self . argv <NEWLINE> argv . extend ( [ <STRING> , <STRING> , <STRING> , fullpath , <STRING> ] ) <NEWLINE> val = tldp . driver . run ( argv ) <NEWLINE> self . assertTrue ( <STRING> in val ) <NEWLINE> <DEDENT>
def memset ( ptr , value , byte_count ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = _LIB . eve_click_memset ( ptr , value , byte_count ) <NEWLINE> if ret < 0 : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class MockIngester ( object ) : <NEWLINE> <INDENT> def __init__ ( self , stream ) : <NEWLINE> <INDENT> self . data = stream . read ( ) <NEWLINE> <DEDENT> def next ( self ) : <NEWLINE> <INDENT> if len ( self . data ) == 0 : <NEWLINE> <INDENT> raise StopIteration ( ) <NEWLINE> <DEDENT> return self . data . pop ( ) <NEWLINE> <DEDENT> <DEDENT>
from indivo . lib import iso8601 <NEWLINE> from indivo . models import MedicationFill <NEWLINE> XML = <STRING> <NEWLINE> DOM = <STRING> <NEWLINE>
<STRING> <NEWLINE> import os <NEWLINE> import sys <NEWLINE> import importlib <NEWLINE> from argparse import ArgumentParser <NEWLINE>
def __init__ ( self , zookeepers = None ) : <NEWLINE> <INDENT> if zookeepers is None : <NEWLINE> <INDENT> zookeepers = self . _extract_zookeepers ( ) <NEWLINE> <DEDENT> self . zookeepers = zookeepers <NEWLINE> self . _connection = _connection ( zookeepers ) <NEWLINE> self . _connection . open ( ) <NEWLINE> <DEDENT>
def check_credentials ( request , username , password ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> gotten_usernames = request . dbsession . query ( User ) . all ( ) <NEWLINE> is_authenticated = False <NEWLINE> if gotten_usernames : <NEWLINE> <INDENT> if any ( d . username == username for d in gotten_usernames ) : <NEWLINE> <INDENT> db_pw = request . dbsession . query ( User ) . filter ( User . username == username ) . first ( ) <NEWLINE> try : <NEWLINE> <INDENT> is_authenticated = pwd_context . verify ( password , db_pw . password ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return is_authenticated <NEWLINE> <DEDENT>
def test_client_returning_same_for_relative_and_absolute_queries ( ) : <NEWLINE> <INDENT> given_rest_client ( ) <NEWLINE> shop_relative = client . get ( <STRING> ) <NEWLINE> shop_absolute = client . get ( API_URL ) <NEWLINE> assert unicode ( shop_relative ) == unicode ( shop_absolute ) <NEWLINE> <DEDENT>
def __truediv__ ( self , other ) : <NEWLINE> <INDENT> assert isinstance ( other , ( numbers . Number , SymbolNUMBER ) ) <NEWLINE> if isinstance ( other , SymbolNUMBER ) : <NEWLINE> <INDENT> return SymbolNUMBER ( self . value / other . value , self . lineno ) <NEWLINE> <DEDENT> return SymbolNUMBER ( self . value / other , self . lineno ) <NEWLINE> <DEDENT>
import pickle , random , itertools , copy <NEWLINE> filenames = pickle . load ( open ( <STRING> ) ) <NEWLINE> subjects = sorted ( filenames . keys ( ) ) <NEWLINE>
def from_args ( cls , args , arg_prefix ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> initializer_spec = args . process_init <NEWLINE> if initializer_spec is None : <NEWLINE> <INDENT> initializer = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> module_name , initializer_name = initializer_spec . rsplit ( <STRING> , 1 ) <NEWLINE> init_module = get_module_by_name ( module_name ) <NEWLINE> initializer = getattr ( init_module , initializer_name ) <NEWLINE> <DEDENT> return cls ( process_count = args . processes , initializer = initializer , <NEWLINE> <INDENT> maxtasksperchild = args . process_max_tasks ) <NEWLINE> <DEDENT> <DEDENT>
import TCP <NEWLINE> import Motor <NEWLINE> import Steering <NEWLINE> import Status <NEWLINE> import time <NEWLINE> import Cameras <NEWLINE> import Lights <NEWLINE> import Modes <NEWLINE> import os <NEWLINE> try : <NEWLINE> <INDENT> trip_meter = Motor . TripMeter ( ) <NEWLINE> motors = Motor . Motor ( trip_meter ) <NEWLINE> follow_line = Steering . FollowLine ( motors , start_speed = 20 ) <NEWLINE> while True : <NEWLINE> <INDENT> time . sleep ( 10 ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> motors . turn_off ( ) <NEWLINE> follow_line . stop ( ) <NEWLINE> <DEDENT>
import string <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> from random import * <NEWLINE> characters = string . ascii_letters + string . punctuation + string . digits <NEWLINE> password = <STRING> . join ( choice ( characters ) for x in range ( randint ( 8 , 16 ) ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( password ) <NEWLINE> print ( <STRING> ) <NEWLINE>
def numeric ( self , values ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return np . reshape ( values [ 0 ] , ( self . rows , self . cols ) , <STRING> ) <NEWLINE> <DEDENT>
def db_purge ( self , purge_time , purge_id ) : <NEWLINE> <INDENT> total_rows_deleted = 0 <NEWLINE> if ( purge_time != None ) : <NEWLINE> <INDENT> total_rows_deleted = self . purge_old_data ( purge_id , purge_time ) <NEWLINE> if ( total_rows_deleted != - 1 ) : <NEWLINE> <INDENT> self . _update_analytics_start_time ( int ( purge_time ) ) <NEWLINE> <DEDENT> <DEDENT> return total_rows_deleted <NEWLINE> <DEDENT>
def destination ( self , dest ) : <NEWLINE> <INDENT> self . cmd [ <STRING> ] = dest <NEWLINE> return ( self ) <NEWLINE> <DEDENT>
def move_data ( apps , schema_editor ) : <NEWLINE> <INDENT> CSWRecord = apps . get_model ( <STRING> , <STRING> ) <NEWLINE> TopicCategory = apps . get_model ( <STRING> , <STRING> ) <NEWLINE> for record in CSWRecord . objects . all ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> record . topic_category = TopicCategory . objects . filter ( identifier__iexact = record . category , is_choice = True ) [ 0 ] <NEWLINE> record . save ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_instance_id ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . _get_cache_data ( <STRING> ) <NEWLINE> <DEDENT>
import os <NEWLINE> import sys <NEWLINE> if os . name == <STRING> : <NEWLINE> <INDENT> if <STRING> not in sys . executable . lower ( ) : <NEWLINE> <INDENT> VIRTUALENV = os . path . dirname ( sys . executable ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> VIRTUALENV = os . path . dirname ( os . path . dirname ( sys . executable ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> VIRTUALENV = os . path . dirname ( os . path . dirname ( sys . executable ) ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from docutils import nodes , utils <NEWLINE> from docutils . parsers . rst import roles <NEWLINE>
def VerifyFields ( self , Mail ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> To_Email = Mail [ <STRING> ] <NEWLINE> if len ( To_Email ) != 0 : <NEWLINE> <INDENT> status = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> Message = Mail [ <STRING> ] <NEWLINE> Message = Message . strip ( ) <NEWLINE> if len ( Message ) != 0 : <NEWLINE> <INDENT> status = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return status <NEWLINE> <DEDENT>
def export_set ( dataset , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> stream = StringIO ( ) <NEWLINE> kwargs . setdefault ( <STRING> , DEFAULT_DELIMITER ) <NEWLINE> if not is_py3 : <NEWLINE> <INDENT> kwargs . setdefault ( <STRING> , DEFAULT_ENCODING ) <NEWLINE> <DEDENT> _csv = csv . writer ( stream , ** kwargs ) <NEWLINE> for row in dataset . _package ( dicts = False ) : <NEWLINE> <INDENT> _csv . writerow ( row ) <NEWLINE> <DEDENT> return stream . getvalue ( ) <NEWLINE> <DEDENT>
from pyramid . compat import ( <NEWLINE> <INDENT> text_type , <NEWLINE> binary_type <NEWLINE> ) <NEWLINE> <DEDENT> from sqlalchemy . ext . hybrid import ( <NEWLINE> <INDENT> hybrid_property , <NEWLINE> Comparator , <NEWLINE> ) <NEWLINE> <DEDENT>
from django . contrib import admin <NEWLINE> from core . models import Hackaton <NEWLINE> admin . site . register ( Hackaton ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> time1 = Time ( ) <NEWLINE> print ( <STRING> , time1 . print_military ( ) ) <NEWLINE> print ( <STRING> , time1 . print_standard ( ) ) <NEWLINE> time1 . set_time ( 13 , 27 , 6 ) <NEWLINE> print ( time1 . print_military ( ) ) <NEWLINE> print ( time1 . print_standard ( ) ) <NEWLINE> time1 . set_hour ( 4 ) <NEWLINE> time1 . set_minute ( 3 ) <NEWLINE> time1 . set_second ( 34 ) <NEWLINE> print ( time1 . print_military ( ) ) <NEWLINE> print ( time1 . print_standard ( ) ) <NEWLINE> <DEDENT>
def __enter__ ( self ) : <NEWLINE> <INDENT> with FileLock ( self . lock_path ) : <NEWLINE> <INDENT> self . read ( ) <NEWLINE> return self <NEWLINE> <DEDENT> <DEDENT>
class ClientNotifier ( Session ) : <NEWLINE> <INDENT> all_clients = [ ] <NEWLINE> def __init__ ( self , * args , ** kwargs ) : <NEWLINE> <INDENT> Session . __init__ ( self , * args , ** kwargs ) <NEWLINE> <DEDENT> def on_open ( self ) : <NEWLINE> <INDENT> self . all_clients . append ( self ) <NEWLINE> print ( self . all_clients ) <NEWLINE> pass <NEWLINE> <DEDENT> def on_message ( self , message ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def on_close ( self ) : <NEWLINE> <INDENT> self . all_clients . remove ( self ) <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>
def tweet ( self , text ) : <NEWLINE> <INDENT> text = self . clean_text ( text ) <NEWLINE> api = self . get_api ( ) <NEWLINE> api . update_status ( status = text ) <NEWLINE> <DEDENT>
class Disk ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def get_disk_usage ( self , hostname , partition = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> cmd_str = <STRING> % ( hostname , partition ) <NEWLINE> results = { <STRING> : 0 , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> run_shell_command ( cmd_str , results = results ) <NEWLINE> return results1 [ <STRING> ] , results1 [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT>
def max_sum_in_lst ( lst ) : <NEWLINE> <INDENT> cur_sum , max_sum = 0 , 0 <NEWLINE> for i in lst : <NEWLINE> <INDENT> cur_sum = i if i > cur_sum + i else cur_sum + i <NEWLINE> max_sum = cur_sum if cur_sum > max_sum else max_sum <NEWLINE> <DEDENT> return max_sum <NEWLINE> <DEDENT>
import datetime <NEWLINE> import hashlib <NEWLINE> import random <NEWLINE> import re <NEWLINE> from django . conf import settings <NEWLINE> from django . contrib . auth . models import User <NEWLINE> from django . db import models <NEWLINE> from django . db import transaction <NEWLINE> from django . template . loader import render_to_string <NEWLINE> from django . utils . translation import ugettext_lazy as _ <NEWLINE> User = settings . AUTH_USER_MODEL <NEWLINE> try : <NEWLINE> <INDENT> from django . utils . timezone import now as datetime_now <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> datetime_now = datetime . datetime . now <NEWLINE> <DEDENT> SHA1_RE = re . compile ( <STRING> ) <NEWLINE>
def lookup ( table , ip ) : <NEWLINE> <INDENT> i = bisect . bisect_right ( table , ( ip , None , None ) ) <NEWLINE> ( low , hi , isp ) = table [ i - 1 ] <NEWLINE> if low <= ip <= hi : <NEWLINE> <INDENT> return isp <NEWLINE> <DEDENT> <DEDENT>
def testHighLowEvent ( self ) : <NEWLINE> <INDENT> with self . assertRaises ( ValueError ) : <NEWLINE> <INDENT> GPIO . add_event_detect ( LOOP_IN , GPIO . LOW ) <NEWLINE> <DEDENT> with self . assertRaises ( ValueError ) : <NEWLINE> <INDENT> GPIO . add_event_detect ( LOOP_IN , GPIO . HIGH ) <NEWLINE> <DEDENT> <DEDENT>
def pop ( self , key , alt = None , callback = None ) : <NEWLINE> <INDENT> return self . __jobRunner . run ( <NEWLINE> <INDENT> self . __pop , self . __rlock , callback , key , alt <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def test_mail_notification_url_no_partner ( self ) : <NEWLINE> <INDENT> mail = self . env [ <STRING> ] . create ( { <STRING> : <STRING> } ) <NEWLINE> url = mail . _get_partner_access_link ( ) <NEWLINE> self . assertEqual ( url , None ) <NEWLINE> <DEDENT>
def serialization_path ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> envelope_filename = urllib . parse . quote ( self . content_id , safe = <STRING> ) + <STRING> <NEWLINE> return path . join ( self . deconst_config . envelope_dir , envelope_filename ) <NEWLINE> <DEDENT>
from dolfin import * <NEWLINE> import sys <NEWLINE> N = 256 <NEWLINE> sigma = 0.9 <NEWLINE> epsilon = 1.25 <NEWLINE> T = 1 <NEWLINE> c = 0.5 <NEWLINE> h = 1.0 / N <NEWLINE> dt = h * 0.0001 <NEWLINE> iteration = 0 <NEWLINE> info ( <STRING> . format ( N , sigma , epsilon , h , dt ) ) <NEWLINE> mesh = UnitIntervalMesh ( N ) <NEWLINE> V = FunctionSpace ( mesh , <STRING> , 2 ) <NEWLINE> u0 = Expression ( <STRING> ) <NEWLINE>
<STRING> <NEWLINE> from abm_template . src . basemodel import BaseModel <NEWLINE> from src . agent import Agent <NEWLINE>
def test_process_translations ( self ) : <NEWLINE> <INDENT> fr_article1 = get_article ( lang = <STRING> , slug = <STRING> , title = <STRING> , <NEWLINE> <INDENT> content = <STRING> ) <NEWLINE> <DEDENT> en_article1 = get_article ( lang = <STRING> , slug = <STRING> , title = <STRING> , <NEWLINE> <INDENT> content = <STRING> ) <NEWLINE> <DEDENT> articles = [ fr_article1 , en_article1 ] <NEWLINE> index , trans = utils . process_translations ( articles ) <NEWLINE> self . assertIn ( en_article1 , index ) <NEWLINE> self . assertIn ( fr_article1 , trans ) <NEWLINE> self . assertNotIn ( en_article1 , trans ) <NEWLINE> self . assertNotIn ( fr_article1 , index ) <NEWLINE> <DEDENT>
class Bar ( Foo1 ) : <NEWLINE> <INDENT> def test ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class Color ( _Color ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __new__ ( cls , r , g , b , a = 0 ) : <NEWLINE> <INDENT> for value in r , g , b , a : <NEWLINE> <INDENT> if value not in range ( 256 ) : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return _Color . __new__ ( cls , r , g , b , a ) <NEWLINE> <DEDENT> <DEDENT>
def bar_handler ( args ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> . format ( args [ <STRING> ] ) ) <NEWLINE> <DEDENT>
def end_synchro ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> map ( self . invalid , filter ( lambda x : x . state == AddressStates . UNKNOWN , <NEWLINE> <INDENT> self . addresses . values ( ) ) ) <NEWLINE> <DEDENT> <DEDENT>
def allTests ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> tests = make_tests ( <STRING> , True , [ <STRING> ] ) <NEWLINE> for test in tests : <NEWLINE> <INDENT> if test . getName ( ) in optionals : <NEWLINE> <INDENT> test . opt ( ) <NEWLINE> <DEDENT> <DEDENT> return tests <NEWLINE> <DEDENT>
<STRING> <NEWLINE> __docformat__ = <STRING> <NEWLINE> import os . path <NEWLINE> from qtpy import QtGui <NEWLINE> from qtpy . uic import loadUiType <NEWLINE> from qtpy import QtWidgets <NEWLINE> from vitables . vtsite import PLUGINSDIR <NEWLINE> translate = QtWidgets . QApplication . translate <NEWLINE> Ui_AboutPage = loadUiType ( os . path . join ( PLUGINSDIR , <STRING> ) ) [ 0 ] <NEWLINE>
def ensureDirExists ( path ) : <NEWLINE> <INDENT> if not os . path . exists ( path ) and not os . path . isdir ( path ) : <NEWLINE> <INDENT> os . mkdir ( path ) <NEWLINE> <DEDENT> elif not os . path . isdir ( path ) : <NEWLINE> <INDENT> raise IOError ( <STRING> % path ) <NEWLINE> <DEDENT> <DEDENT>
def calc_weights ( pscore , D ) : <NEWLINE> <INDENT> N = pscore . shape [ 0 ] <NEWLINE> weights = np . empty ( N ) <NEWLINE> weights [ D == 0 ] = 1 / ( 1 - pscore [ D == 0 ] ) <NEWLINE> weights [ D == 1 ] = 1 / pscore [ D == 1 ] <NEWLINE> return weights <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from setuptools import setup , find_packages <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> version = <STRING> , <NEWLINE> packages = find_packages ( ) , <NEWLINE> author = <STRING> , <NEWLINE> author_email = <STRING> , <NEWLINE> url = <STRING> <NEWLINE> <DEDENT> ) <NEWLINE>
def register ( ) : <NEWLINE> <INDENT> Pool . register ( <NEWLINE> <INDENT> account . AccountTemplate , <NEWLINE> account . BEVATCustomer , <NEWLINE> account . BEVATCustomerContext , <NEWLINE> module = <STRING> , type_ = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def __isub__ ( self , v2 ) : <NEWLINE> <INDENT> if hasattr ( v2 , <STRING> ) : <NEWLINE> <INDENT> self . x -= v2 . x <NEWLINE> self . y -= v2 . y <NEWLINE> self . z -= v2 . z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . x -= v2 <NEWLINE> self . y -= v2 <NEWLINE> self . z -= v2 <NEWLINE> <DEDENT> return self <NEWLINE> <DEDENT>
def user_json ( user ) : <NEWLINE> <INDENT> return { <NEWLINE> <INDENT> <STRING> : user . pk , <NEWLINE> <STRING> : reverse ( <STRING> , args = ( user . pk , ) ) , <NEWLINE> <STRING> : user . get_full_name ( ) , <NEWLINE> <STRING> : get_template ( <STRING> ) . render ( Context ( { <STRING> : user } ) ) , <NEWLINE> <STRING> : get_template ( <STRING> ) . render ( Context ( { <STRING> : user } ) ) , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>
def helper_test_http_method_and_keys ( client , method , url , data , users , after_each_request = None ) : <NEWLINE> <INDENT> responses = _helper_test_http_method_responses ( client , method , url , data , users , after_each_request ) <NEWLINE> return list ( map ( lambda r : ( r . status_code , set ( r . data . keys ( ) if isinstance ( r . data , dict ) and 200 <= r . status_code < 300 else [ ] ) ) , responses ) ) <NEWLINE> <DEDENT>
def setUp ( self ) : <NEWLINE> <INDENT> super ( TestConfigViews , self ) . setUp ( ) <NEWLINE> self . mock_about = mock . patch . object ( <NEWLINE> <INDENT> GoogleDriveClient , <NEWLINE> <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> self . mock_about . return_value = { <STRING> : <STRING> } <NEWLINE> self . mock_about . start ( ) <NEWLINE> self . mock_fetch = mock . patch . object ( <NEWLINE> <INDENT> self . node_settings . __class__ , <NEWLINE> <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> self . mock_fetch . return_value = self . external_account . oauth_key <NEWLINE> self . mock_fetch . start ( ) <NEWLINE> <DEDENT>
def boundary ( A , x , y ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> Nx = A . shape [ 1 ] <NEWLINE> Ny = A . shape [ 0 ] <NEWLINE> Lx = x [ Nx - 1 ] <NEWLINE> Ly = x [ Nx - 1 ] <NEWLINE> A [ : , 0 ] = 100 * numpy . sin ( math . pi * x / Lx ) <NEWLINE> A [ : , Nx - 1 ] = - 100 * numpy . sin ( math . pi * x / Lx ) <NEWLINE> A [ 0 , : ] = 0.0 <NEWLINE> A [ Ny - 1 , : ] = 0.0 <NEWLINE> <DEDENT>
def _live_lint ( self , cmd , code ) : <NEWLINE> <INDENT> print ( <STRING> . format ( self . filename ) ) <NEWLINE> files = [ f for f in os . listdir ( os . path . dirname ( self . filename ) ) if f . endswith ( <STRING> ) ] <NEWLINE> return self . tmpdir ( cmd , files , code ) <NEWLINE> <DEDENT>
import youtube_edits as youtube_edits_module <NEWLINE> edits = youtube_edits_module . edits <NEWLINE> mapping = get_video_excerpts_map ( edits ) <NEWLINE> print ( mapping ) <NEWLINE> url = get_youtube_url_from ( <STRING> ) <NEWLINE> for key , value in mapping . items ( ) : <NEWLINE> <INDENT> display ( HTML ( get_embed_string_from ( value , url ) ) ) <NEWLINE> <DEDENT>
class GdbThread ( Thread ) : <NEWLINE> <INDENT> def __init__ ( self , inferior , gdb_thread ) : <NEWLINE> <INDENT> super ( GdbThread , self ) . __init__ ( inferior ) <NEWLINE> self . _gdb_thread = gdb_thread <NEWLINE> <DEDENT> def name ( self ) : <NEWLINE> <INDENT> return self . _gdb_thread . name <NEWLINE> <DEDENT> def id ( self ) : <NEWLINE> <INDENT> return self . _gdb_thread . num <NEWLINE> <DEDENT> def is_valid ( self ) : <NEWLINE> <INDENT> return self . _gdb_thread . is_valid ( ) <NEWLINE> <DEDENT> <DEDENT>
def predict ( self , sequence , batch_size = 32 , verbose = 0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . labeling_ . predict ( <NEWLINE> <INDENT> sequence , batch_size = batch_size , verbose = verbose ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , * args , ** kwds ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if args or kwds : <NEWLINE> <INDENT> super ( AddTwoIntsResponse , self ) . __init__ ( * args , ** kwds ) <NEWLINE> if self . sum is None : <NEWLINE> <INDENT> self . sum = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> self . sum = 0 <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , nn , validation_split = 0.25 , batch_size = 128 , nb_epoch = 10 , show_accuracy = True ) : <NEWLINE> <INDENT> self . show_accuracy = show_accuracy <NEWLINE> self . nb_epoch = nb_epoch <NEWLINE> self . batch_size = batch_size <NEWLINE> self . validation_split = validation_split <NEWLINE> self . nn = nn <NEWLINE> self . model = nn . get_model ( ) <NEWLINE> <DEDENT>
class OggifyOSXAppDelegate ( NSObject ) : <NEWLINE> <INDENT> def applicationDidFinishLaunching_ ( self , sender ) : <NEWLINE> <INDENT> NSLog ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from __future__ import absolute_import <NEWLINE> from . kafka import KafkaProducer <NEWLINE> from . simple import SimpleProducer <NEWLINE> from . keyed import KeyedProducer <NEWLINE> __all__ = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <STRING> <NEWLINE> <DEDENT> ] <NEWLINE>
def BuildNotifyMessage ( m_ptr , src , dst_ptr ) : <NEWLINE> <INDENT> m_ptr [ <STRING> ] = NOTIFY_MESSAGE <NEWLINE> m_ptr [ <STRING> ] = get_monotonic ( ) <NEWLINE> if src == HARDWARE : <NEWLINE> <INDENT> m_ptr [ <STRING> ] = dst_ptr [ <STRING> ] <NEWLINE> dst_ptr [ <STRING> ] = 0 <NEWLINE> <DEDENT> elif src == SYSTEM : <NEWLINE> <INDENT> m_ptr [ <STRING> ] = dst_ptr [ <STRING> ] <NEWLINE> dst_ptr [ <STRING> ] = 0 <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import json <NEWLINE> import urllib2 <NEWLINE> import pandas as pn <NEWLINE>
from . constructors import ( <NEWLINE> <INDENT> is_rule , <NEWLINE> Production , <NEWLINE> Rule , <NEWLINE> OrRule , <NEWLINE> ExtendedRule , <NEWLINE> OptionalRule , <NEWLINE> RepeatableRule , <NEWLINE> RepeatableOptionalRule , <NEWLINE> NamedRule , <NEWLINE> InterpretationRule , <NEWLINE> ForwardRule , <NEWLINE> EmptyRule <NEWLINE> <DEDENT> ) <NEWLINE>
def accueil ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> identifiant = self . identifiant <NEWLINE> noms_types = tuple ( <NEWLINE> <INDENT> type ( self ) . importeur . navigation . types_elements . keys ( ) ) <NEWLINE> <DEDENT> noms_types = sorted ( noms_types ) <NEWLINE> return <STRING> . format ( identifiant ) + <STRING> <STRING> <STRING> <STRING> <STRING> + <STRING> . join ( <NEWLINE> <INDENT> noms_types ) + <STRING> <NEWLINE> <DEDENT> <DEDENT>
from distutils . core import setup <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> packages = [ <STRING> ] , <NEWLINE> version = <STRING> , <NEWLINE> description = <STRING> , <NEWLINE> author = <STRING> , <NEWLINE> author_email = <STRING> , <NEWLINE> url = <STRING> , <NEWLINE> download_url = <STRING> , <NEWLINE> keywords = [ <STRING> , <STRING> , <STRING> ] , <NEWLINE> classifiers = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> <NEWLINE> <DEDENT> ] , <NEWLINE> install_requires = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <DEDENT> ] , <NEWLINE> <DEDENT> ) <NEWLINE>
def get ( self , t , token_or_tag ) : <NEWLINE> <INDENT> if t == 0 : <NEWLINE> <INDENT> return get_token ( token_or_tag ) <NEWLINE> <DEDENT> elif t == 1 : <NEWLINE> <INDENT> return get_tag ( token_or_tag ) <NEWLINE> <DEDENT> <DEDENT>
class Board ( Model , Base ) : <NEWLINE> <INDENT> host = Column ( String ) <NEWLINE> alias = Column ( String , index = True ) <NEWLINE> __table_args__ = ( UniqueConstraint ( <STRING> , <STRING> ) , ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from __future__ import absolute_import <NEWLINE> from __future__ import division <NEWLINE> from __future__ import print_function <NEWLINE> import os <NEWLINE> import sys <NEWLINE> from os . path import join as join <NEWLINE> from shutil import copyfile <NEWLINE> import ebf <NEWLINE> import numpy as np <NEWLINE> import ConfigParser <NEWLINE> import skysurvey <NEWLINE> from . new_config import SYS_CFG_FNAME <NEWLINE> __all__ = [ <STRING> ] <NEWLINE>
import matplotlib <NEWLINE> import pandas <NEWLINE> import re <NEWLINE> from matplotlib2tikz import save as tikz_save <NEWLINE> import numpy <NEWLINE> from matplotlib import pyplot <NEWLINE> matplotlib . style . use ( <STRING> ) <NEWLINE> pyplot . interactive ( False ) <NEWLINE>
def __init__ ( self , config , url ) : <NEWLINE> <INDENT> BaseSiteAdapter . __init__ ( self , config , url ) <NEWLINE> query_data = urlparse . parse_qs ( self . parsedUrl . query ) <NEWLINE> story_id = query_data [ <STRING> ] [ 0 ] <NEWLINE> self . story . setMetadata ( <STRING> , story_id ) <NEWLINE> self . _setURL ( self . _VIEW_STORY_URL_TEMPLATE % story_id ) <NEWLINE> self . story . setMetadata ( <STRING> , self . _SITE_DOMAIN ) <NEWLINE> self . story . setMetadata ( <STRING> , self . _SITE_LANGUAGE ) <NEWLINE> <DEDENT>
class ProcurementOrder ( models . Model ) : <NEWLINE> <INDENT> _inherit = <STRING> <NEWLINE> lot_id = fields . Many2one ( <STRING> , <STRING> ) <NEWLINE> @ api . model <NEWLINE> def _get_stock_move_values ( self ) : <NEWLINE> <INDENT> res = super ( <NEWLINE> <INDENT> ProcurementOrder , self ) . _get_stock_move_values ( ) <NEWLINE> <DEDENT> res [ <STRING> ] = self . lot_id . id <NEWLINE> return res <NEWLINE> <DEDENT> <DEDENT>
import xml . etree . ElementTree as ET <NEWLINE> from src . element . Card import Card <NEWLINE> from src . element . ResourceType import ResourceType <NEWLINE> from src . element . Tile import Tile <NEWLINE> from src . game . GameState import GameState <NEWLINE> from src . mvc . EventType import EventType <NEWLINE>
def upgrade ( ) : <NEWLINE> <INDENT> upgrade_table ( <STRING> ) <NEWLINE> upgrade_table ( <STRING> ) <NEWLINE> <DEDENT>
def test_revision_unit_updater_update ( store0 ) : <NEWLINE> <INDENT> updater_class = revision_updater . get ( Unit ) <NEWLINE> updater = updater_class ( object_list = store0 . units ) <NEWLINE> _test_revision_updater ( updater ) <NEWLINE> <DEDENT>
def clean ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> cleaned_data = super ( ) . clean ( ) <NEWLINE> new_email = cleaned_data . get ( <STRING> ) <NEWLINE> re_new_email = cleaned_data . get ( <STRING> ) <NEWLINE> if new_email and new_email != re_new_email : <NEWLINE> <INDENT> raise forms . ValidationError ( ugettext ( <STRING> ) ) <NEWLINE> <DEDENT> return cleaned_data <NEWLINE> <DEDENT>
class Trigger ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . key = <STRING> <NEWLINE> self . handler = 0 <NEWLINE> self . priority = 1 <NEWLINE> self . active = False <NEWLINE> self . type = 0 <NEWLINE> self . classtxt = <STRING> <NEWLINE> <DEDENT> <DEDENT>
def process ( self ) : <NEWLINE> <INDENT> if hasattr ( self , <STRING> ) and self . _process is not None : <NEWLINE> <INDENT> return self . _process <NEWLINE> <DEDENT> <DEDENT>
def modified ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return self . pod . file_modified ( self . pod_path ) <NEWLINE> <DEDENT> except OSError : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT>
from __future__ import absolute_import , print_function , unicode_literals , division <NEWLINE> import itertools <NEWLINE> from jormungandr . realtime_schedule . realtime_proxy import RealtimeProxy <NEWLINE> from jormungandr . schedule import RealTimePassage <NEWLINE> import xml . etree . ElementTree as et <NEWLINE> from jormungandr . interfaces . parsers import date_time_format <NEWLINE> import pytz <NEWLINE> from flask import logging <NEWLINE> import pybreaker <NEWLINE> import requests as requests <NEWLINE> from jormungandr import cache , app <NEWLINE> from datetime import datetime , time <NEWLINE> from jormungandr . utils import timestamp_to_datetime <NEWLINE> from navitiacommon . ratelimit import RateLimiter , FakeRateLimiter <NEWLINE> from navitiacommon import type_pb2 <NEWLINE> import redis <NEWLINE>
import json <NEWLINE> import os <NEWLINE> import os . path <NEWLINE> import shutil <NEWLINE> import tornado . web <NEWLINE> from base import BaseHandler <NEWLINE> from logic import media <NEWLINE> from logic import url_factory <NEWLINE>
def _auth ( self ) : <NEWLINE> <INDENT> cmd = ( <STRING> <NEWLINE> <INDENT> % ( self . host , self . port , self . username , self . password ) ) <NEWLINE> <DEDENT> subprocess . check_output ( cmd , shell = True ) <NEWLINE> cmd = <STRING> <NEWLINE> stdout = subprocess . check_output ( cmd , shell = True ) <NEWLINE> return stdout . strip ( ) <NEWLINE> <DEDENT>
def from_ranges ( cls , ranges_list , pattern_creator = None , pattern = None , is_param = False ) : <NEWLINE> <INDENT> spans = SpanList ( <NEWLINE> <INDENT> [ <NEWLINE> <INDENT> Span ( <NEWLINE> <INDENT> start , <NEWLINE> end , <NEWLINE> pattern_creator = pattern_creator , <NEWLINE> pattern = pattern , <NEWLINE> is_param = is_param <NEWLINE> <DEDENT> ) for start , end in ranges_list <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT> ) <NEWLINE> return spans <NEWLINE> <DEDENT>
def test_wildcard ( ) : <NEWLINE> <INDENT> eq_ ( str ( Q ( <STRING> , wildcard = True ) ) , <STRING> ) <NEWLINE> eq_ ( str ( Q ( <STRING> , <STRING> ) ) , <STRING> ) <NEWLINE> eq_ ( str ( Q ( <STRING> , <STRING> , wildcard = True ) ) , <STRING> ) <NEWLINE> <DEDENT>
class Gui ( base . Gui ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def reset_browser ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> home = os . environ [ <STRING> ] <NEWLINE> self . delete_if_exists ( os . path . join ( home , <STRING> , <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT>
def psnr ( img1 , img2 ) : <NEWLINE> <INDENT> mse = numpy . mean ( ( img1 - img2 ) ** 2 ) <NEWLINE> if mse == 0 : <NEWLINE> <INDENT> return 100 <NEWLINE> <DEDENT> PIXEL_MAX = 255.0 <NEWLINE> return 20 * math . log10 ( PIXEL_MAX / math . sqrt ( mse ) ) <NEWLINE> <DEDENT>
def send_mail ( email_from , email_to , subject , text_content , html_content ) : <NEWLINE> <INDENT> mail = EmailMultiAlternatives ( <NEWLINE> <INDENT> subject = subject , <NEWLINE> body = text_content , <NEWLINE> from_email = email_from , <NEWLINE> to = [ email_to ] <NEWLINE> <DEDENT> ) <NEWLINE> mail . attach_alternative ( html_content , <STRING> ) <NEWLINE> mail . send ( ) <NEWLINE> <DEDENT>
def p_range ( stop , start = 0 , step = 1 ) : <NEWLINE> <INDENT> if start != 0 or step < 0 or stop < 0 : <NEWLINE> <INDENT> stop , start = start , stop <NEWLINE> <DEDENT> p_list = [ ] <NEWLINE> if step > 0 : <NEWLINE> <INDENT> while start < stop : <NEWLINE> <INDENT> p_list . append ( start ) <NEWLINE> start += step <NEWLINE> <DEDENT> <DEDENT> if step < 0 : <NEWLINE> <INDENT> while start > stop : <NEWLINE> <INDENT> p_list . append ( start ) <NEWLINE> start += step <NEWLINE> <DEDENT> <DEDENT> return p_list <NEWLINE> <DEDENT>
import re <NEWLINE> from livestreamer . plugin import Plugin <NEWLINE> from livestreamer . stream import HLSStream <NEWLINE> PLAYLIST_URL = <STRING> <NEWLINE> _url_re = re . compile ( <STRING> ) <NEWLINE>
<STRING> <NEWLINE> import random <NEWLINE> from materials . amaterial import AMaterial <NEWLINE>
<STRING> <NEWLINE> import logging <NEWLINE> from . base_controller import BaseController <NEWLINE> from . . api_helper import APIHelper <NEWLINE> from . . configuration import Configuration <NEWLINE> from . . http . auth . basic_auth import BasicAuth <NEWLINE>
import subprocess <NEWLINE> import sys <NEWLINE> if len ( sys . argv ) != 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> result = subprocess . check_output ( [ sys . argv [ 1 ] , sys . argv [ 2 ] ] ) . strip ( ) <NEWLINE> print ( <STRING> + result + <STRING> ) <NEWLINE>
def ask ( request ) : <NEWLINE> <INDENT> if request . method == <STRING> : <NEWLINE> <INDENT> form = QuestionForm ( request . POST ) <NEWLINE> try : <NEWLINE> <INDENT> question = form . save ( commit = False ) <NEWLINE> question . user = request . user <NEWLINE> question . save ( ) <NEWLINE> return redirect ( question ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> return render ( request , <STRING> , { <STRING> : True } ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> c = { } <NEWLINE> return render ( request , <STRING> , c ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from __future__ import absolute_import , division , print_function , with_statement <NEWLINE> import functools <NEWLINE> import time <NEWLINE> import weakref <NEWLINE> from tornado . concurrent import TracebackFuture <NEWLINE> from tornado . escape import utf8 , native_str <NEWLINE> from tornado import httputil , stack_context <NEWLINE> from tornado . ioloop import IOLoop <NEWLINE> from tornado . util import Configurable <NEWLINE>
class Solution : <NEWLINE> <INDENT> def isValidSerialization ( self , preorder ) : <NEWLINE> <INDENT> preorder = preorder . split ( <STRING> ) <NEWLINE> return self . is_valid_serialization ( preorder ) <NEWLINE> <DEDENT> def is_valid_serialization ( self , preorder ) : <NEWLINE> <INDENT> edge_count = 1 <NEWLINE> for node in preorder : <NEWLINE> <INDENT> if edge_count == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> edge_count -= 1 <NEWLINE> if node != <STRING> : <NEWLINE> <INDENT> edge_count += 2 <NEWLINE> <DEDENT> <DEDENT> if edge_count != 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT> <DEDENT>
def get_paper_name_by_issn ( issue_df , issn ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> paper = issue_df . loc [ issue_df [ <STRING> ] == issn ] [ <STRING> ] . iloc [ 0 ] <NEWLINE> return paper <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> log . error ( <STRING> % issn ) <NEWLINE> return False <NEWLINE> <DEDENT> <DEDENT>
import data . APIs as apis <NEWLINE> apis . deathrate . run ( ) <NEWLINE> import data . settings as settings <NEWLINE> import data . generate as generate <NEWLINE> import data . block as block <NEWLINE> import data . control as control <NEWLINE> import data . imageUtils as imageUtils <NEWLINE> import data . utils as utisls <NEWLINE> import data . entities as entitites <NEWLINE> generate . maze . loadMap ( ) <NEWLINE>
<STRING> <NEWLINE> import requests <NEWLINE> from pymongo import MongoClient <NEWLINE> collection = MongoClient ( host = <STRING> ) . bastogne . movie <NEWLINE> movie = collection . find ( ) <NEWLINE> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> for mv in movie : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> r = requests . get ( mv [ <STRING> ] ) <NEWLINE> if r . status_code != 200 : <NEWLINE> <INDENT> f . write ( ( mv [ <STRING> ] + <STRING> ) . encode ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mv [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT> except Exception as e : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def createLD ( language ) : <NEWLINE> <INDENT> languageDict = { <STRING> : <STRING> } <NEWLINE> langNum = languageDict [ language ] <NEWLINE> LD = [ ] <NEWLINE> with open ( <STRING> , <STRING> ) as infoFile : <NEWLINE> <INDENT> for line in infoFile : <NEWLINE> <INDENT> [ grammStr , inflStr , sentenceStr ] = line . split ( <STRING> ) <NEWLINE> sentenceStr = sentenceStr . rstrip ( ) <NEWLINE> s = Sentence ( [ grammStr , inflStr , sentenceStr ] ) <NEWLINE> if grammStr == langNum : <NEWLINE> <INDENT> LD . append ( s ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return LD <NEWLINE> <DEDENT>
def import_object ( name , current_module = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if <STRING> not in name : <NEWLINE> <INDENT> return __import__ ( name ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if name . startswith ( <STRING> ) : <NEWLINE> <INDENT> name = current_module . rsplit ( <STRING> , 1 ) [ 0 ] + name <NEWLINE> <DEDENT> ( modpath , objname ) = name . rsplit ( <STRING> , 1 ) <NEWLINE> module = __import__ ( modpath , fromlist = [ objname ] ) <NEWLINE> return getattr ( module , objname ) <NEWLINE> <DEDENT> <DEDENT>
