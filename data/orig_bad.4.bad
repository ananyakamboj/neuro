def getaddrlist ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> result = [ ] <NEWLINE> while self . pos < len ( self . field ) : <NEWLINE> <INDENT> ad = self . getaddress ( ) <NEWLINE> if ad : <NEWLINE> <INDENT> result += ad <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . append ( ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <DEDENT>
def _update_kernel_boundaries ( self , ( row , column ) ) : <NEWLINE> <INDENT> self . _min_row = min ( self . _min_row , row ) <NEWLINE> self . _max_row = max ( self . _max_row , row ) <NEWLINE> self . _min_column = min ( self . _min_column , column ) <NEWLINE> self . _max_column = max ( self . _max_column , column ) <NEWLINE> <DEDENT>
def adapt ( text ) : <NEWLINE> <INDENT> a = psycopg2 . extensions . adapt ( force_text ( text ) <NEWLINE> a . prepare ( connection . connection ) <NEWLINE> return a <NEWLINE> <DEDENT>
def _get_mpi_data ( self , context , project_id ) : <NEWLINE> <INDENT> result = { } <NEWLINE> for instance in self . compute_api . get_all ( context , <NEWLINE> <INDENT> project_id = project_id ) : <NEWLINE> if instance [ <STRING> ] : <NEWLINE> line = <STRING> % ( instance [ <STRING> ] [ <STRING> ] , <NEWLINE> instance [ <STRING> ] ) <NEWLINE> key = str ( instance [ <STRING> ] ) <NEWLINE> if key in result : <NEWLINE> result [ key ] . append ( line ) <NEWLINE> else : <NEWLINE> result [ key ] = [ line ] <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT>
def run ( self ) : <NEWLINE> <INDENT> self . ips = [ ] <NEWLINE> self . ipstoleases = { } <NEWLINE> self . leasestoips = { } <NEWLINE> self . ipstoslices = { } <NEWLINE> self . slicestoips = { } <NEWLINE> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . ganglia = gmon . ganglia . Ganglia ( self . host , self . port ) <NEWLINE> self . ganglia . refresh ( ) <NEWLINE> self . updateips ( ) <NEWLINE> self . updateleases ( ) <NEWLINE> self . updateslices ( ) <NEWLINE> <DEDENT> except : <NEWLINE> self . reset ( ) <NEWLINE> time . sleep ( self . pollint ) <NEWLINE> <DEDENT> <DEDENT>
def subtractByKey ( self , other , numPartitions = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> filter_func = lambda ( key , vals ) : len ( vals [ 0 ] ) > 0 and len ( vals [ 1 ] ) == 0 <NEWLINE> map_func = lambda ( key , vals ) : [ ( key , val ) for val in vals [ 0 ] ] <NEWLINE> return self . cogroup ( other , numPartitions ) . filter ( filter_func ) . flatMap ( map_func ) <NEWLINE> <DEDENT>
def setUp ( self ) : <NEWLINE> <INDENT> Config . parse_directory ( os . path . abspath ( <STRING> ) ) <NEWLINE> Config . load_user ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( 50 * <STRING> ) <NEWLINE> for i in Config . domains ( ) : <NEWLINE> print ( i , Config . keys_in_domain ( i ) ) <NEWLINE> print ( <STRING> , 50 * <STRING> ) <NEWLINE> self . db = Base . DataBase ( <STRING> ) <NEWLINE> self . output = cStringIO . StringIO ( ) <NEWLINE> <DEDENT>
def getOpenTM2Version ( ) : <NEWLINE> <INDENT> fin = open ( <STRING> , <STRING> ) <NEWLINE> for line in fin : <NEWLINE> <INDENT> if line . find ( <STRING> ) != - 1 : <NEWLINE> <INDENT> items = line . strip ( <STRING> ) . split ( <STRING> ) <NEWLINE> totalItems = len ( items ) <NEWLINE> if totalItems < 3 : <NEWLINE> continue <NEWLINE> version = items [ totalItems - 1 ] . strip ( <STRING> ) <NEWLINE> print ( version ) <NEWLINE> fout = open ( <STRING> , <STRING> ) <NEWLINE> fout . writelines ( version ) <NEWLINE> fout . close ( ) <NEWLINE> <DEDENT> <DEDENT> fin . close ( ) <NEWLINE> <DEDENT>
def _terminal_login ( self ) : <NEWLINE> <INDENT> if <STRING> in self . all_attributes : <NEWLINE> <INDENT> self . fd . write ( <STRING> ) <NEWLINE> if <STRING> in self . attributes : <NEWLINE> self . fd . write ( <STRING> % self . domainname ) <NEWLINE> else : <NEWLINE> self . fd . write ( <STRING> % self . domainname ) <NEWLINE> <DEDENT> <DEDENT>
def event ( self , event ) : <NEWLINE> <INDENT> if ( event . type == pygame . KEYDOWN ) : <NEWLINE> <INDENT> if ( event . key == pygame . K_RIGHT ) : <NEWLINE> self . nextTrack ( ) <NEWLINE> <DEDENT> <DEDENT>
def test_simple ( self , ( before , after ) ) : <NEWLINE> <INDENT> self . assertEqual ( unicode ( _ ( before ) ) , after ) <NEWLINE> self . assertEqual ( unicode ( escape ( before ) ) , after ) <NEWLINE> <DEDENT>
def parse_internal_feature_id ( self , feature_id , user_feature_id = None ) : <NEWLINE> <INDENT> if user_feature_id is None or user_feature_id is <STRING> : <NEWLINE> <INDENT> logging . debug ( <STRING> . format ( feature_id ) ) <NEWLINE> self . feature_defs = UserFeatureDef . from_feature_id ( feature_id ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> logging . debug ( <STRING> . format ( user_feature_id ) <NEWLINE> self . feature_defs = UserFeatureDef . from_user_feature_id ( user_feature_id ) <NEWLINE> <DEDENT> for index , feature_def in enumerate ( self . feature_defs ) : <NEWLINE> <INDENT> feature_def . bq_row_id = index <NEWLINE> <DEDENT> <DEDENT>
def uuid_nodes ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> unwanted_nodes = config . DEFAULT_NODES + config . UNWANTED_NODES <NEWLINE> for node in mc . ls ( long = True , <NEWLINE> <INDENT> type = config . TRACKABLE_NODE_TYPES ) : <NEWLINE> if node in unwanted_nodes : <NEWLINE> continue <NEWLINE> yield node <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> import logging <NEWLINE> from pele . optimize import mylbfgs <NEWLINE> from pele . utils . rotations import vec_random_ndim <NEWLINE> __all__ = [ <STRING> ] <NEWLINE> logger = logging . getLogger ( <STRING> ) <NEWLINE> def determine_pushoff ( <NEWLINE> <INDENT> pot , coords , vec , stepmin = .01 , ** unused_kwargs ) : <NEWLINE> <STRING> <NEWLINE> if unused_kwargs : <NEWLINE> print ( <STRING> , unused_kwargs . keys ( ) , <STRING> ) <NEWLINE> return coords + stepmin * vec / np . linalg . norm ( vec ) <NEWLINE> <DEDENT>
def dictColCopy ( fromDict , toDict , keyList ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for key in keyList : <NEWLINE> if key not in fromDict : <NEWLINE> <INDENT> raise Exception ( <STRING> + key + <STRING> + str ( fromDict ) ) <NEWLINE> toDict [ key ] = fromDict [ key ] <NEWLINE> <DEDENT> <DEDENT>
def data_entropy ( labeled_data ) : <NEWLINE> <INDENT> labels = [ label for _ , label in labeled_data ] <NEWLINE> probabilities = class_probabilities ( labels ) <NEWLINE> return entropy ( probabilities ) ] <NEWLINE> <DEDENT>
class GFF3OutStream ( GenomeStream ) : <NEWLINE> <INDENT> def __init__ ( self , genome_stream ) : <NEWLINE> <INDENT> self . gs = gtlib . gt_gff3_out_stream_new ( genome_stream , None ) <NEWLINE> self . _as_parameter_ = self . gs <NEWLINE> <DEDENT> def from_param ( cls , obj ) : <NEWLINE> <INDENT> if not isinstance ( obj , GFF3OutStream ) : <NEWLINE> <INDENT> raise TypeError , <STRING> <NEWLINE> <DEDENT> return obj . _as_parameter_ <NEWLINE> <DEDENT> from_param = classmethod ( from_param ) <NEWLINE> <DEDENT>
def get_trailing_number ( s ) : <NEWLINE> <INDENT> m = re . search ( <STRING> , s ) <NEWLINE> return int ( m . group ( ) if m else None <NEWLINE> <DEDENT>
def add_impulse ( self , delta_xdot , delta_ydot ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> self . xdot += delta_xdot / 5.0 <NEWLINE> self . ydot += delta_ydot / 5.0 <NEWLINE> self . _clip ( self . xdot ) <NEWLINE> self . _clip ( self . ydot ) <NEWLINE> <DEDENT> <DEDENT>
def GetClines ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> jokerClines = [ ] <NEWLINE> jokerClines . append ( self . __GetJokerCline ( 1 ) ) <NEWLINE> jokerClines . append ( self . __GetJokerCline ( 2 ) ) <NEWLINE> jokerClines . append ( self . __GetJokerCline ( 3 ) ) <NEWLINE> jokerClines . append ( self . __GetJokerCline ( 4 ) ) <NEWLINE> jokerClines . append ( self . __GetJokerCline ( 5 ) ) <NEWLINE> jokerClines . append ( self . __GetJokerCline ( 6 ) ) <NEWLINE> jokerClines = filter ( None , jokerClines ) <NEWLINE> if len ( jokerClines ) == 0 : print <STRING> <NEWLINE> return jokerClines <NEWLINE> <DEDENT>
( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
( <NEWLINE> <INDENT> solve each function <NEWLINE> calculate error <NEWLINE> <INDENT> ( x2 - x1 ) / ( y2 - y1 ) = % error <NEWLINE> <DEDENT> check for divergence <NEWLINE> <DEDENT> <DEDENT>
def getResult ( endpoint , parameters = None ) : <NEWLINE> <INDENT> if parameters : <NEWLINE> <INDENT> parameter_string = urllib . urlencode ( parameters ) <NEWLINE> path = <STRING> . join ( [ endpoint + <STRING> , parameter_string ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> path = endpoint <NEWLINE> <DEDENT> endpoint_result = session . get ( urljoin ( baseurl , path ) ) <NEWLINE> httpErrors ( endpoint_result . status_code , path , endpoint_result . json ( ) ) <NEWLINE> if debug : <NEWLINE> <INDENT> print <STRING> + json . dumps ( endpoint_result . json ( ) , indent = 2 ) + <STRING> <NEWLINE> <DEDENT> return endpoint_result . json ( ) <NEWLINE> <DEDENT>
def test_init_defaults ( self ) : <NEWLINE> <INDENT> self . assertEqual ( self . pageable , self . pyager . pageable ) <NEWLINE> self . assertEqual ( self . url , self . pyager . url ) <NEWLINE> self . assertEqual ( 1 , self . pyager . page ) <NEWLINE> self . assertEqual ( 10 self . pyager . page_size ) <NEWLINE> self . assertEqual ( 3 , self . pyager . window ) <NEWLINE> <DEDENT>
def retranslateUi ( self , Dialog ) : <NEWLINE> <INDENT> Dialog . setWindowTitle ( _ ( <STRING> ) ) <NEWLINE> self . msg . setText ( _ ( <STRING> <NEWLINE> <DEDENT>
def test_default_is_empty ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> assert len ( self . _get_collection ( ) == 0 <NEWLINE> <DEDENT>
def poll_for_decision_tasks ( swf , domain , task_list , identity ) : <NEWLINE> <INDENT> paginator = swf . get_paginator ( <STRING> ) <NEWLINE> result = None <NEWLINE> for page in paginator . paginate ( domain = domain , taskList = { <STRING> : task_list } , <NEWLINE> <INDENT> identity = identity ) : <NEWLINE> if result is None : <NEWLINE> result = page <NEWLINE> else : <NEWLINE> result [ <STRING> ] . extend ( page [ <STRING> ] ) <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT>
def addToPlaylist ( user , name , songs ) : <NEWLINE> <INDENT> scope = <STRING> <NEWLINE> usageToken = util . prompt_for_user_token ( username = user [ <STRING> ] , <NEWLINE> <INDENT> client_id = user [ <STRING> ] , <NEWLINE> client_secret = user [ <STRING> ] , <NEWLINE> redirect_uri = user [ <STRING> ] , <NEWLINE> scope = scope ) <NEWLINE> <DEDENT> if usageToken : <NEWLINE> sp = spotipy . Spotify ( auth = usageToken ) <NEWLINE> playlist_id = getPlaylist ( user , name ) <NEWLINE> sp . user_playlist_add_tracks ( user [ <STRING> ] , playlist_id , songs ) <NEWLINE> <DEDENT>
def saveCredentials ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> credentials = { <NEWLINE> <INDENT> <STRING> : self . username , <NEWLINE> <STRING> : self . password , <NEWLINE> <STRING> : self . auth_basic , <NEWLINE> <STRING> : self . access_token , <NEWLINE> <STRING> : self . token_expiry <NEWLINE> <DEDENT> } <NEWLINE> with open ( self . credentials_file , <STRING> ) as credentials_file : <NEWLINE> <INDENT> json . dump ( credentials , credentials_file , indent = 4 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def _scrollXNow ( self , first , last ) : <NEWLINE> <INDENT> self . _horizScrollbar . set ( first , last ) <NEWLINE> self . _horizScrollbarNeeded = ( ( first , last ) != ( <STRING> , <STRING> ) ) <NEWLINE> if self [ <STRING> ] == <STRING> : <NEWLINE> if self . _horizScrollbarNeeded != self . _horizScrollbarOn : <NEWLINE> self . _toggleHorizScrollbar ( ) <NEWLINE> <DEDENT>
class ErrorHandler ( pybindgen . settings . ErrorHandler ) : <NEWLINE> <INDENT> def handle_error ( self , wrapper , exception , traceback_ ) : <NEWLINE> <INDENT> warnings . warn ( <STRING> % ( exception , wrapper ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT>
def getSubPanelBody ( self ) : <NEWLINE> <INDENT> refBugListText = <STRING> <NEWLINE> isUrgent = False <NEWLINE> for b in self . bugs : <NEWLINE> <INDENT> refBugListText += <STRING> % ( b . number , b . subject ) <NEWLINE> isUrgent = b . isUrgent <NEWLINE> template = HPACTION_BODY <NEWLINE> if isUrgent : <NEWLINE> template = HPACTION_URGENT_BODY <NEWLINE> <DEDENT> body = template % ( refBugListText , <STRING> . join ( self . refBugNumbers ) ) <NEWLINE> return SUBPANEL_BODY % ( self . refBugNumbers [ 0 ] , body ) <NEWLINE> <DEDENT>
def do_timed_action ( self , duration = False ) : <NEWLINE> <INDENT> if duration : <NEWLINE> ms_duration = int ( round ( duration * 1000 / self . timestep ) * self . timestep ) <NEWLINE> else : ms_duration = self . timestep <NEWLINE> if self . getMode ( ) == 0 : <NEWLINE> self . step ( ms_duration ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> self . step ( ms_duration ) <NEWLINE> self . stop_moving ( ) <NEWLINE> self . step ( self . timestep ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> args = sys . argv [ 1 : ] <NEWLINE> if not args : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> if args [ 0 ] == <STRING> : <NEWLINE> <INDENT> global summary <NEWLINE> summary = True <NEWLINE> del args [ 0 ] <NEWLINE> <DEDENT> for one_file in args : <NEWLINE> extract_names ( one_file ) <NEWLINE> <DEDENT>
def pos_servo ( servo , pos ) : <NEWLINE> <INDENT> if ( debugLevel ) : print <STRING> % ( servo , pos ) <NEWLINE> if ( servo == PANSERVO ) : <NEWLINE> <INDENT> cpos = myPyLib . clamp ( pos , PanPosLimitR , PanPosLimitL ) <NEWLINE> <DEDENT> elif ( servo == TILTSERVO ) : <NEWLINE> <INDENT> cpos = myPyLib . clamp ( pos , TiltPosLimitUp , TiltPosLimitDn ) <NEWLINE> <DEDENT> if ( debugLevel ) : print <STRING> % ( servo , cpos ) <NEWLINE> myPDALib . servoWrite ( servo , cpos ) <NEWLINE> return cpos <NEWLINE> <DEDENT>
def _undo_pusher_selection ( self , selection_moves ) : <NEWLINE> <INDENT> path = [ am . direction . opposite for am in selection_moves ] <NEWLINE> old_position = self . _state . pusher_position ( self . _selected_pusher ) <NEWLINE> new_position = self . _state . board . path_destination ( old_position , path ) <NEWLINE> self . select_pusher ( self . _state . pusher_id_on ( new_position ) <NEWLINE> <DEDENT>
def _get_rpls_from_purchase_requests ( self , cr , uid , ids , context = None ) : <NEWLINE> <INDENT> rpl_ids = [ ] <NEWLINE> for request in self . pool [ <STRING> ] . browse ( <NEWLINE> <INDENT> cr , uid , ids , context = context ) : <NEWLINE> for request_line in request . line_ids : <NEWLINE> for rpl in request_line . analytic_resource_plan_lines : <NEWLINE> <INDENT> rpl_ids . append ( rpl . id ) <NEWLINE> <DEDENT> <DEDENT> return list ( set ( rpl_ids ) ) <NEWLINE> <DEDENT>
def unprefix ( localpath , prefix ) : <NEWLINE> <INDENT> if re . search ( <STRING> + prefix , localpath ) : <NEWLINE> if re . search ( <STRING> , prefix ) : <NEWLINE> <INDENT> prefix = prefix [ : - 1 ] ; <NEWLINE> return localpath [ len ( prefix ) : ] ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 1 ) ; <NEWLINE> <DEDENT> <DEDENT>
def test_scan_with_select_clause ( self ) : <NEWLINE> <INDENT> ns = <STRING> <NEWLINE> st = <STRING> <NEWLINE> records = [ ] <NEWLINE> scan_obj = None <NEWLINE> def callback ( ( key , meta , bins ) ) : <NEWLINE> <INDENT> records . append ( bins ) <NEWLINE> <DEDENT> scan_obj = self . client . scan ( ns , st ) <NEWLINE> scan_obj . select ( <STRING> ) <NEWLINE> scan_obj . foreach ( callback ) <NEWLINE> assert len ( records ) != 0 <NEWLINE> <DEDENT>
def get_icon ( name ) : <NEWLINE> <INDENT> path = os . path . dirname ( os . path . realpath ( __file__ ) <NEWLINE> path = os . path . join ( path , <STRING> % name ) <NEWLINE> icon = QtGui . QIcon ( path ) <NEWLINE> return icon <NEWLINE> <DEDENT>
from { { cookiecutter . project_slug } } . app import app <NEWLINE> flask_app = app . app <NEWLINE> flask_app . testing = True <NEWLINE> client = flask_app . test_client ( ) <NEWLINE>
( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>
from paravistest import datadir , Import_Med_Field <NEWLINE> import pvserver as paravis <NEWLINE> med_file = datadir + <STRING> <NEWLINE> field_names = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> prs_list = [ range ( 1 , 10 ) , range ( 1 , 10 ) , range ( 10 ) , range ( 10 ) , range ( 10 ) ] ) <NEWLINE> Import_Med_Field ( paravis . myParavis , med_file , field_names , 1 , prs_list ) <NEWLINE>
( indent_header + <STRING> <STRING> % ( self . contained_current_max_size , <NEWLINE> <INDENT> self . contained_current_max_size ) ; <NEWLINE> <DEDENT> <DEDENT> print ( indent_header + ( <STRING> % ( self . contained_max_size , self . contained_name ) ) . ljust ( 80 , <STRING> ) ) <NEWLINE> print ( indent_header ) <NEWLINE> <DEDENT> if brackets : <NEWLINE> <INDENT> print ( indent_header + ( <STRING> % ( self . offset + self . size ) ) . ljust ( header_size ) + indent_body + <STRING> % ( self . type_name , self . name ) ) <NEWLINE> <DEDENT> <DEDENT>
def get_sync ( self , byte_offset = 0 ) : <NEWLINE> <INDENT> block = <STRING> <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> block = os . read ( self . file_fp , self . block_size ) <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> <INDENT> frame = inspect . currentframe ( ) <NEWLINE> info = inspect . getframeinfo ( frame ) <NEWLINE> print ( <STRING> % ( type ( e ) . __name__ , info . lineno ) ) <NEWLINE> sys . exit ( 0 ) ; <NEWLINE> <DEDENT> return block <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self ) : <NEWLINE> <INDENT> super ( BlobServiceAdapter , self ) . __init__ ( <NEWLINE> <INDENT> BlobService ( account_name = self . util . get_config ( <STRING> ) , <NEWLINE> <INDENT> account_key = self . util . get_config ( <STRING> ) , <NEWLINE> host_base = self . util . get_config ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_tileset_from_gid ( self , gid ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> tiled_gid = self . tiledgidmap [ gid ] <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> raise ValueError <NEWLINE> <DEDENT> for tileset in sorted ( self . tilesets , key = attrgetter ( <STRING> ) , <NEWLINE> <INDENT> reverse = True ) : <NEWLINE> if tiled_gid >= tileset . firstgid : <NEWLINE> return tileset <NEWLINE> <DEDENT> raise ValueError <NEWLINE> <DEDENT>
def _assign_moving_average ( self , variable , value , one_minus_decay ) : <NEWLINE> <INDENT> with ops . name_scope ( None , <STRING> , <NEWLINE> <INDENT> [ variable , value , one_minus_decay ] ) as scope : <NEWLINE> with ops . colocate_with ( variable ) : <NEWLINE> update_delta = ( variable . read_value ( ) - value ) * one_minus_decay <NEWLINE> if isinstance ( variable , resource_variable_ops . ResourceVariable ) : <NEWLINE> return gen_resource_variable_ops . assign_sub_variable_op ( <NEWLINE> variable . handle , update_delta , name = scope ) <NEWLINE> else : <NEWLINE> return state_ops . assign_sub ( variable , update_delta , name = scope ) <NEWLINE> <DEDENT> <DEDENT>
def parse ( self , message ) : <NEWLINE> <INDENT> message = message . strip ( <STRING> ) <NEWLINE> buf = <STRING> <NEWLINE> timestamp , message = self . parseTimestamp ( message ) <NEWLINE> if timestamp is None : <NEWLINE> <INDENT> buf += termcolor . colored ( <STRING> % ( message ) , <STRING> ) + <STRING> <NEWLINE> return buf <NEWLINE> <DEDENT> for key in self . message_regex . keys ( ) : <NEWLINE> <INDENT> match = self . message_regex [ key ] . match ( message ) <NEWLINE> if match : <NEWLINE> <INDENT> result = match . groupdict ( ) <NEWLINE> exec <STRING> % key <NEWLINE> return buf <NEWLINE> <DEDENT> <DEDENT> return buf <NEWLINE> <DEDENT>
def generateByteArray ( size ) : <NEWLINE> <INDENT> ba = mmh3 . hash_bytes ( <STRING> , incrementSeed ( ) ) <NEWLINE> for i in xrange ( size / 8 ) : <NEWLINE> ba = ba + mmh3 . hash_bytes ( <STRING> , incrementSeed ( ) ) <NEWLINE> return bytearray ( ba [ 0 : size ] ) <NEWLINE> <DEDENT>
def question ( q ) : <NEWLINE> <INDENT> global answer <NEWLINE> answer = 0 <NEWLINE> print ( <STRING> % q ) <NEWLINE> try : <NEWLINE> time . sleep ( 3600 ) <NEWLINE> except IOError : <NEWLINE> pass <NEWLINE> if answer == 0 : <NEWLINE> assert 0 , <STRING> <NEWLINE> print ( <STRING> , answer ) <NEWLINE> return answer <NEWLINE> <DEDENT>
def combine_languages ( self ) : <NEWLINE> <INDENT> lang_list = [ lang for lang in self . language_1 , self . language_2 , self . language_3 if lang ] <NEWLINE> languages = <STRING> . join ( lang_list ) <NEWLINE> return languages <NEWLINE> <DEDENT>
class LoggerDaemon ( threading . Thread ) : <NEWLINE> <INDENT> log = None <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> threading . Thread . __init__ ( self ) <NEWLINE> self . setDaemon ( True ) <NEWLINE> self . log = logging . getLogger ( <STRING> ) <NEWLINE> <DEDENT> def run ( self ) : <NEWLINE> self . log . debug ( <STRING> ) <NEWLINE> canlogging_process ( 64 , 0.1 ) <NEWLINE> self . log . debug ( <STRING> ) <NEWLINE> <DEDENT>
def test_failed_to_initialize_resolver ( self ) : <NEWLINE> <INDENT> err_msg = <STRING> <NEWLINE> def mock_create_import_resolver ( _ ) : <NEWLINE> <INDENT> raise ResolverInstantiationError ( err_msg ) <NEWLINE> <DEDENT> with mock . patch ( <STRING> , <NEWLINE> <INDENT> new = mock_create_import_resolver ) : <NEWLINE> try : <NEWLINE> self . _update_provider_context ( ) <NEWLINE> self . fail ( <STRING> ) <NEWLINE> except CloudifyClientError , ex : <NEWLINE> self . assertIn ( err_msg , str ( ex ) ) <NEWLINE> <DEDENT> <DEDENT>
def register_errorhandlers ( app ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def render_error ( error ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> error_code = getattr ( error , <STRING> , 500 ) <NEWLINE> return render_template ( <STRING> . format ( error_code ) ) ) , error_code <NEWLINE> <DEDENT> for errcode in [ 401 , 404 , 500 ] : <NEWLINE> <INDENT> app . errorhandler ( errcode ) ( render_error ) <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>
import sys <NEWLINE> from osgpypp import osg <NEWLINE> from osgpypp import osgWidget <NEWLINE> MASK_2D = 0xF0000000 <NEWLINE> LABEL1 = <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <DEDENT> LABEL2 = <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> <DEDENT>
class GridForm ( GridFormHelp ) : <NEWLINE> <INDENT> def __init__ ( self , screen , title , * args ) : <NEWLINE> myargs = ( self , screen , title , None ) + args <NEWLINE> apply ( GridFormHelp . __init__ , myargs ) <NEWLINE> <DEDENT>
def __ledit_update_value ( self , field_name , new_value , type_fn , validator ) : <NEWLINE> <INDENT> if self . __validated ( validator , self . bindings [ field_name ] [ 0 ] , <NEWLINE> <INDENT> new_value ) : <NEWLINE> try : <NEWLINE> setattr ( self . __model , field_name , type_fn ( new_value ) ) <NEWLINE> except ValueError : <NEWLINE> if new_value != <STRING> : <NEWLINE> raise <NEWLINE> else : <NEWLINE> dispatcher . send ( <STRING> , self . __model , field_name , self ) <NEWLINE> <DEDENT> <DEDENT>
def _got_session ( session ) : <NEWLINE> <INDENT> print ( <STRING> % session ) <NEWLINE> container_name = <STRING> <NEWLINE> def _ok ( ( response , v ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> % response ) <NEWLINE> print ( <STRING> % container_name ) <NEWLINE> reactor . stop ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> session . disable_container_logging ( container = container_name ) . addCallback ( _ok ) . addErrback ( _error ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> miles = float ( input ( <STRING> ) <NEWLINE> gallons = float ( input ( <STRING> ) ) <NEWLINE> break <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> mpg = miles / gallons <NEWLINE> print ( <STRING> , mpg , <STRING> ) <NEWLINE>
def _handle_text ( self , msg ) : <NEWLINE> <INDENT> payload = msg . get_payload ( ) <NEWLINE> if payload is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> cset = msg . get_charset ( ) <NEWLINE> if cset is not None : <NEWLINE> <INDENT> payload = cset . body_encode ( payload ) <NEWLINE> <DEDENT> if not isinstance ( payload , basestring ) : <NEWLINE> <INDENT> if type ( payload ) == type ( [ ] ) and msg . is_multipart ( ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise TypeError , <STRING> % type ( payload ) <NEWLINE> <DEDENT> <DEDENT> self . _fp . write ( payload ) <NEWLINE> <DEDENT>
def __init__ ( self , host , port , path , sleepTime ) <NEWLINE> <INDENT> self . host = host <NEWLINE> self . port = port <NEWLINE> self . path = path <NEWLINE> self . sleepTime = sleepTime <NEWLINE> self . stopped = False <NEWLINE> threading . Thread . __init__ ( self ) <NEWLINE> <DEDENT>
def runSqlQueryPostgresql ( connectSring , sqlCommand ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> os . environ [ <STRING> ] = password <NEWLINE> session = Popen ( connectSring + sqlCommand , stdin = PIPE , stdout = PIPE , stderr = PIPE ) <NEWLINE> <DEDENT> except CalledProcessError , e : <NEWLINE> <INDENT> logging . info ( <STRING> % e ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> return session . communicate ( ) <NEWLINE> <DEDENT>
def send_message ( module , client_id , client_secret , topic , msg ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> access_token = get_access_token ( module , client_id , client_secret ) <NEWLINE> url = <STRING> % topic <NEWLINE> headers = { <NEWLINE> <INDENT> <STRING> : <STRING> % access_token , <NEWLINE> <DEDENT> } <NEWLINE> do_request ( module , url , { <STRING> : msg } , headers ) <NEWLINE> return True , { <STRING> : access_token } <NEWLINE> <DEDENT> except ConnectionError , e : <NEWLINE> <INDENT> return False , e <NEWLINE> <DEDENT> <DEDENT>
def list ( self , root_dir , include_inherited = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> files = [ ] <NEWLINE> for dirname , unused_dirnames , filenames in os . walk ( <NEWLINE> <INDENT> self . _logical_to_physical ( root_dir ) ) : <NEWLINE> for filename in filenames : <NEWLINE> files . append ( <NEWLINE> <INDENT> self . _physical_to_logical ( os . path . join ( dirname , filename ) ) ) <NEWLINE> <DEDENT> <DEDENT> return sorted ( files ) <NEWLINE> <DEDENT>
def hide ( self ) : <NEWLINE> <INDENT> self . screen = None <NEWLINE> with self . disableMask ( xcffib . xproto . EventMask . EnterWindow | <NEWLINE> <INDENT> xcffib . xproto . EventMask . FocusChange | <NEWLINE> xcffib . xproto . EventMask . LeaveWindow ) : <NEWLINE> for i in self . windows : <NEWLINE> i . hide ( ) <NEWLINE> self . layout . hide ( ) <NEWLINE> <DEDENT> <DEDENT>
def get_arg_spec ( ) : <NEWLINE> <INDENT> if __arg_spec is not None : return __arg_spec <NEWLINE> strats = [ <STRING> ] <NEWLINE> states = [ <STRING> , <STRING> ] <NEWLINE> __ arg_spec = ec2_argument_spec ( ) <NEWLINE> arg_spec . update ( { <NEWLINE> <INDENT> <STRING> : { <STRING> : True , <STRING> : <STRING> } , <NEWLINE> <STRING> : { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : strats } , <NEWLINE> <STRING> : { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : states } , <NEWLINE> <DEDENT> } ) <NEWLINE> return __arg_spec <NEWLINE> <DEDENT>
def stop_pen ( ) : <NEWLINE> <INDENT> subprocess . call ( <STRING> , shell = True ) <NEWLINE> all_pid_file = open ( <STRING> , <STRING> ) <NEWLINE> <INDENT> all_pid_file_content = all_pid_file . read ( ) <NEWLINE> all_pid_file . close ( ) <NEWLINE> <DEDENT> kill_command = <STRING> + all_pid_file_content <NEWLINE> print ( kill_command ) <NEWLINE> subprocess . call ( kill_command , shell = True ) <NEWLINE> <DEDENT>
class MapFailureCase ( PBSMapCase ) : <NEWLINE> <INDENT> WorkerClass = CompleteFailureIdentityWorker <NEWLINE> max_range = 10 <NEWLINE> def test_pbs_map ( self ) : <NEWLINE> xs = range ( self . max_range ) <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . assertRaises ( ppm . PBSMapError , self . run_pbs_map , self . WorkerClass , xs , queue_timeout = 5 , num_clients = 10 ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> self . assertTrue ( isinstance ( e , TestException ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_datatype ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . D . has_key ( <STRING> ) : <NEWLINE> <INDENT> return self . D [ <STRING> ] <NEWLINE> <INDENT> else : <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT> <DEDENT>
def find_merged_avatars ( main_root ) : <NEWLINE> <INDENT> print ( cformat ( <STRING> ) ) <NEWLINE> avatar_id_map = { } <NEWLINE> for avatar in verbose_iterator ( main_root [ <STRING> ] . itervalues ( ) , len ( main_root [ <STRING> ] ) , attrgetter ( <STRING> ) , <NEWLINE> <INDENT> lambda av : <STRING> . format ( safe_upper ( av . surName ) , av . name ) ) : <NEWLINE> for merged_avatar in getattr ( avatar , <STRING> , [ ] ) : <NEWLINE> avatar_id_map [ merged_avatar . getId ( ) ] = avatar . getId ( ) <NEWLINE> <DEDENT> return avatar_id_map <NEWLINE> <DEDENT>
def buildLESSFile ( filename , output_filename ) : <NEWLINE> <INDENT> if verbose : <NEWLINE> print ( <STRING> + filename + <STRING> + output_filename ) <NEWLINE> return call ( [ <STRING> , filename , <STRING> , <STRING> , output_filename , <STRING> + output_filename ] ) <NEWLINE> <DEDENT>
def test_discovery ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> scanner = get_component ( <STRING> ) . SCANNER <NEWLINE> with patch . dict ( device_tracker . DISCOVERY_PLATFORMS , { <STRING> : <STRING> } ) : <NEWLINE> <INDENT> with patch . object ( scanner , <STRING> , <NEWLINE> <INDENT> autospec = True ) as mock_scan : <NEWLINE> with assert_setup_component ( 1 , device_tracker . DOMAIN ) : <NEWLINE> assert setup_component ( <NEWLINE> self . hass , device_tracker . DOMAIN , TEST_PLATFORM ) <NEWLINE> fire_service_discovered ( self . hass , <STRING> , { } ) <NEWLINE> self . assertTrue ( mock_scan . called ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def __init__ ( self , argc , argv ) : <NEWLINE> <INDENT> if argc != 2 or int ( argv [ 1 ] ) <= 0 : <NEWLINE> <INDENT> self . print_usage ( argv ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> self . max_generation = int ( argv [ 1 ] ) <NEWLINE> self . is_running = False <NEWLINE> self . size = ( 1024 , 768 ) <NEWLINE> self . model = None <NEWLINE> def print_usage ( self , argv ) : <NEWLINE> <STRING> <NEWLINE> print ( <STRING> % argv [ 0 ] ) <NEWLINE> <DEDENT>
def _ended_courses ( self ) : <NEWLINE> <INDENT> for course_id in [ course <NEWLINE> <INDENT> for sub in settings . COURSE_LISTINGS <NEWLINE> <INDENT> for course in settings . COURSE_LISTINGS [ sub ] ] : <NEWLINE> course_loc = CourseDescriptor . id_to_location ( course_id ) <NEWLINE> course = modulestore ( ) . get_instance ( course_id , course_loc ) <NEWLINE> if course . has_ended ( ) : <NEWLINE> <DEDENT> yield course_id <NEWLINE> <DEDENT> <DEDENT>
if d == len ( key ) ( ) ) : <NEWLINE>
class OUI_data ( DVBobject ) : <NEWLINE> <INDENT> def pack ( self ) : <NEWLINE> fmt = <STRING> % len ( self . selector_bytes ) <NEWLINE> return pack ( fmt , <NEWLINE> <INDENT> self . OUI >> 8 , <NEWLINE> self . OUI & 0xFF , <NEWLINE> len ( self . selector_bytes ) , <NEWLINE> self . selector_bytes , <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT>
def test_header_start_exception ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for readerclass in [ ascii . NoHeader , ascii . SExtractor , ascii . Ipac , <NEWLINE> <INDENT> ascii . BaseReader , ascii . FixedWidthNoHeader , ascii . Cds , ascii . Daophot ] : <NEWLINE> with pytest . raises ( ValueError ) : <NEWLINE> reader = ascii . core . _get_reader ( readerclass , header_start = 5 ) <NEWLINE> <DEDENT> <DEDENT>
def key_checker ( expected_keys ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def check ( d ) : <NEWLINE> <INDENT> for k in expected_keys : <NEWLINE> <INDENT> if k not in d : <NEWLINE> <INDENT> raise InvalidTabsException ( <STRING> <NEWLINE> <INDENT> . format ( k , d ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return check <NEWLINE> <DEDENT>
def run ( db ) : <NEWLINE> <INDENT> migrator = PostgresqlMigrator ( db ) <NEWLINE> migrate ( <NEWLINE> <INDENT> migrator . add_column ( <STRING> , <STRING> , IntegerField ( ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def get_currency_precision ( currency = None ) : <NEWLINE> <INDENT> if not currency : <NEWLINE> <INDENT> currency = frappe . db . get_value ( <STRING> <NEWLINE> <INDENT> frappe . db . get_default ( <STRING> ) , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> currency_format = frappe . db . get_value ( <STRING> , currency , <STRING> ) <NEWLINE> from frappe . utils import get_number_format_info <NEWLINE> return get_number_format_info ( currency_format ) [ 2 ] <NEWLINE> <DEDENT>
class PictureNonVisual ( Serialisable ) : <NEWLINE> <INDENT> tagname = <STRING> <NEWLINE> cNvPr = Typed ( expected_type = NonVisualDrawingProps , ) <NEWLINE> cNvPicPr = Typed ( expected_type = NonVisualPictureProperties , ) <NEWLINE> __elements__ = ( <STRING> , <STRING> ) <NEWLINE> def __init__ ( self , <NEWLINE> <INDENT> cNvPr = None , <NEWLINE> cNvPicPr = None , <NEWLINE> ) : <NEWLINE> if cNvPr is None : <NEWLINE> cNvPr = NonVisualDrawingProps ( id = 0 , name = <STRING> , descr = <STRING> ) <NEWLINE> self . cNvPr = cNvPr <NEWLINE> if cNvPicPr is None : <NEWLINE> cNvPicPr = NonVisualPictureProperties ( ) <NEWLINE> self . cNvPicPr = cNvPicPr <NEWLINE> <DEDENT> <DEDENT>
def max ( dictionary ) : <NEWLINE> <INDENT> max = None <NEWLINE> highest = None <NEWLINE> for key in dictionary : <NEWLINE> <INDENT> if max < dictionary [ key ] : <NEWLINE> max = dictionary [ key ] <NEWLINE> highest = key <NEWLINE> <DEDENT> return highest <NEWLINE> <DEDENT>
def test_allocate_VF_fail ( self ) : <NEWLINE> <INDENT> self . _create_fake_instance ( ) <NEWLINE> with mock . patch . object ( objects . PciDevice , <STRING> , <NEWLINE> <INDENT> side_effect = self . _fake_pci_device_get_by_addr ) : <NEWLINE> self . _create_pci_devices ( ) <NEWLINE> devobj = self . sriov_vf_devices [ 0 ] <NEWLINE> parent = self . _fake_pci_device_get_by_addr ( None , None , <NEWLINE> <INDENT> devobj . parent_addr ) <NEWLINE> parent . status = fields . PciDeviceStatus . CLAIMED <NEWLINE> self . assertRaises ( exception . PciDevicePFInvalidStatus , <NEWLINE> devobj . allocate , self . inst ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def check_and_react ( self , record_to_check ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for cond , f in product ( self . conditionandreaction_set . all ( ) , <NEWLINE> <INDENT> record_to_check . field_set . all ( ) ) : <NEWLINE> reaction = cond . check_condition ( f ) <NEWLINE> if reaction : <NEWLINE> cond . react ( record_to_check ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT>
( m , 1 , <STRING> . join ( str ( v ) ) <NEWLINE> m = m + 1 <NEWLINE> <DEDENT> result_file = <STRING> % file_base <NEWLINE> file . save ( result_file ) <NEWLINE> <DEDENT>
isave , dsave ) <NEWLINE>
def add ( self , protocol , port , instances = [ ] , policies = [ ] , cert = None , comment = None , connection_idle_timeout = None ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . add_protocol_port ( protocol , port , policies , cert , comment , connection_idle_timeout = connection_idle_timeout ) <NEWLINE> for instance in instances : <NEWLINE> <INDENT> self . add_backend ( port , instance , policies ) <NEWLINE> <DEDENT> <DEDENT> except Exception , err : <NEWLINE> <INDENT> servo . log . error ( <STRING> % err ) <NEWLINE> <DEDENT> return self <NEWLINE> <DEDENT>
def search ( folder_to_search = os . getcwd ( ) , wildcard = <STRING> ) : <NEWLINE> <INDENT> matches = [ ] <NEWLINE> for root , dirnames , filenames in os . walk ( folder_to_search ) : <NEWLINE> <INDENT> for filename in fnmatch . filter ( filenames , wildcard ) : <NEWLINE> matches . append ( os . path . join ( root , filename ) ) <NEWLINE> <DEDENT> return matches <NEWLINE> <DEDENT>
( <STRING> , action = <STRING> , <NEWLINE> <INDENT> default = False , <NEWLINE> help = <STRING> <NEWLINE> <DEDENT> <DEDENT>
def test_reverse ( self ) : <NEWLINE> <INDENT> m = self . populate_MessageOfTypes ( ) <NEWLINE> m2 = dict_to_protobuf ( MessageOfTypes , protobuf_to_dict ( m ) <NEWLINE> assert m == m2 <NEWLINE> m2 . dubl = 0 <NEWLINE> assert m2 != m <NEWLINE> <DEDENT>
def resolve_name ( rule , tokens , id , args ) : <NEWLINE> <INDENT> if id in [ x [ 0 ] for x in tokens ] : <NEWLINE> if args : <NEWLINE> <INDENT> print ( <STRING> % ( id , args ) ) <NEWLINE> <INDENT> return parsetree . Terminal ( rule , id ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return parsetree . NonTerminal ( rule , id , args ) <NEWLINE> <DEDENT> <DEDENT>
categories = [ <STRING> , <NEWLINE> <INDENT> <STRING> ] <NEWLINE> <DEDENT> microcode = <STRING> <NEWLINE> for category in categories : <NEWLINE> <INDENT> exec <STRING> % category <NEWLINE> microcode += cat . microcode <NEWLINE> <DEDENT>
def _build_lang_data ( ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> for lang , ( ignore , newname ) in _build_po_list ( ) . items ( ) : <NEWLINE> <INDENT> targetpath = os . path . join ( <STRING> , <STRING> , lang , <STRING> ) <NEWLINE> ret . append ( ( targetpath , [ newname ] ) ) ) <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT>
def __setattr__ ( self , attr , value ) : <NEWLINE> <INDENT> if attr in [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> ] : <NEWLINE> if self . __initialized__ : <NEWLINE> raise AttributeError ( <STRING> % ( self . __class__ . __name__ , attr ) ) <NEWLINE> else : <NEWLINE> self . __dict__ [ attr ] = value <NEWLINE> <DEDENT> elif attr in [ <STRING> ] : <NEWLINE> <INDENT> self . __dict__ [ attr ] = value <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . config_attrib_set ( attr , value ) <NEWLINE> <DEDENT> return value <NEWLINE> <DEDENT>
class ExternalData : <NEWLINE> <INDENT> stored_in_cache = 0 <NEWLINE> filename = <STRING> <NEWLINE> def __init__ ( self , filename = <STRING> , do_cache = 1 ) : <NEWLINE> if filename and do_cache : <NEWLINE> <INDENT> self . stored_in_cache = 1 <NEWLINE> instance_cache [ filename ] = self <NEWLINE> <INDENT> if filename : <NEWLINE> <INDENT> self . filename = filename <NEWLINE> <DEDENT> <DEDENT> <DEDENT> def __del__ ( self ) : <NEWLINE> if self . stored_in_cache and instance_cache . has_key ( self . filename ) : <NEWLINE> <INDENT> del instance_cache [ self . filename ] <NEWLINE> <DEDENT> def Filename ( self ) : <NEWLINE> return self . filename <NEWLINE> <DEDENT>
class simpserial : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> self . gladefile = os . path . join ( glade_dir , <STRING> ) <NEWLINE> self . wTree = gtk . glade . XML ( self . gladefile , <STRING> ) <NEWLINE> <INDENT> dic = { <STRING> : self . quit , <NEWLINE> <INDENT> <STRING> : self . quit , <NEWLINE> <STRING> : self . on_import_activate , <NEWLINE> <STRING> : self . on_export_activate , <NEWLINE> <STRING> : self . on_cut_activate , <NEWLINE> <STRING> : self . on_copy_activate , <NEWLINE> <STRING> : self . on_paste_activate , <NEWLINE> } <NEWLINE> <DEDENT> self . wTree . signal_autoconnect ( dic ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class URLPatternReverse ( TestCase ) : <NEWLINE> <INDENT> urls = <STRING> <NEWLINE> def test_urlpattern_reverse ( self ) : <NEWLINE> <INDENT> for name , expected , args , kwargs in test_data : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> got = reverse ( name , args = args , kwargs = kwargs ) <NEWLINE> <DEDENT> except NoReverseMatch , e : <NEWLINE> <INDENT> self . assertEqual ( expected , NoReverseMatch ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . assertEquals ( got , expected ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> def test_reverse_none ( self ) : <NEWLINE> <INDENT> self . assertRaises ( NoReverseMatch , reverse , None ) <NEWLINE> <DEDENT> <DEDENT>
def sync_user_email_addresses ( user ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> email = user_email ( user ) <NEWLINE> if email and not bloodon . accounts . models . EmailAddress . objects . filter ( user = user , <NEWLINE> <INDENT> email__iexact = email ) . exists ( ) : <NEWLINE> if app_settings . UNIQUE_EMAIL and bloodon . accounts . models . EmailAddress . objects . filter ( email__iexact = email ) . exists ( ) : <NEWLINE> return <NEWLINE> bloodon . accounts . models . EmailAddress . objects . create ( user = user , <NEWLINE> email = email , <NEWLINE> primary = False , <NEWLINE> verified = False ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> children = [ ] Child ( ) <NEWLINE> p = Parent ( 1000 , children ) <NEWLINE> print ( <STRING> , p ) <NEWLINE> c1 = p . create_child ( 1 , p ) <NEWLINE> c2 = p . create_child ( 2 , p ) <NEWLINE> c3 = p . create_child ( 3 , p ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( c1 ) <NEWLINE> print ( c2 ) <NEWLINE> print ( c3 ) <NEWLINE> <DEDENT>
class MockPlatform ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , setup_platform = None , dependencies = None , <NEWLINE> <INDENT> platform_schema = None ) : <NEWLINE> <STRING> <NEWLINE> self . DEPENDENCIES = dependencies or [ ] <NEWLINE> self . _setup_platform = setup_platform <NEWLINE> if platform_schema is not None : <NEWLINE> self . PLATFORM_SCHEMA = platform_schema <NEWLINE> <DEDENT> def setup_platform ( self , hass , config , add_devices , discovery_info = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . _setup_platform is not None : <NEWLINE> <INDENT> self . _setup_platform ( hass , config , add_devices , discovery_info ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def _check ( self , sock_info ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> error = False <NEWLINE> age = _time ( ) - sock_info . last_checkout <NEWLINE> if ( self . _check_interval_seconds is not None <NEWLINE> <INDENT> and ( <NEWLINE> <INDENT> 0 == self . _check_interval_seconds <NEWLINE> or age > self . _check_interval_seconds ) ) : <NEWLINE> if socket_closed ( sock_info . sock ) : <NEWLINE> <DEDENT> sock_info . close ( ) <NEWLINE> error = True <NEWLINE> <DEDENT> if not error : <NEWLINE> <INDENT> return sock_info <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . connect ( ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import os <NEWLINE> from stat import S_IRUSR , S_IWUSR , S_IRGRP , S_IROTH <NEWLINE> from distutils . core import setup <NEWLINE> from distutils . command . install import install as _install <NEWLINE> from distutils . command . install_data import install_data as _install_data <NEWLINE> try : <NEWLINE> <INDENT> from Cython . Build import cythonize <NEWLINE> extensions = cythonize ( <STRING> ) <NEWLINE> from Cython . Distutils import build_ext <NEWLINE> <DEDENT> except ImportError , e : <NEWLINE> <INDENT> print ( <STRING> % e ) <NEWLINE> extensions = None <NEWLINE> build_ext = None <NEWLINE> <DEDENT> from printrun . printcore import __version__ as printcore_version <NEWLINE> INSTALLED_FILES = <STRING> <NEWLINE>
def __init__ ( self , * args , ** kwargs ) : <NEWLINE> <INDENT> self . num = Walker . number <NEWLINE> Walker . number += 1 <NEWLINE> self . initialPosition ( ) <NEWLINE> self . initialVelocity ( ) <NEWLINE> self . a = 1000000 git <NEWLINE> self . markerSize = 4 <NEWLINE> <DEDENT>
def __init__ ( self , lines , generate = custom_generator ) <NEWLINE> <INDENT> self . lines = lines <NEWLINE> self . _generate = generate <NEWLINE> <DEDENT>
def collect ( ( sql , hostname , username , password , db_name ) ) : <NEWLINE> <INDENT> print ( <STRING> % db_name ) <NEWLINE> current_process_name = current_process ( ) . name <NEWLINE> if current_process_name not in CONNECTIONS : <NEWLINE> <INDENT> print ( <STRING> % current_process_name ) <NEWLINE> CONNECTIONS [ current_process_name ] = get_connection ( <NEWLINE> <INDENT> hostname , username , password ) <NEWLINE> <DEDENT> <DEDENT> conn = CONNECTIONS [ current_process_name ] <NEWLINE> query ( conn , <STRING> % db_name ) <NEWLINE> collected = query ( conn , sql . format ( db_name = db_name ) ) <NEWLINE> print ( <STRING> % ( len ( collected ) , db_name ) ) <NEWLINE> return db_name , collected <NEWLINE> <DEDENT>
def _execute ( self , all_targets ) : <NEWLINE> <INDENT> test_targets = self . _get_test_targets ( ) <NEWLINE> if test_targets : <NEWLINE> <INDENT> self . context . release_lock ( ) <NEWLINE> with self . context . new_workunit ( name = <STRING> , <NEWLINE> <INDENT> labels = [ WorkUnitLabel . TOOL , WorkUnitLabel . TEST ] ) as workunit : <NEWLINE> cols = os . environ . get ( <STRING> , 80 ) <NEWLINE> with environment_as ( COLUMNS = str ( int ( cols ) - 30 ) ) : <NEWLINE> self . run_tests ( test_targets , workunit ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_value_for_attribute ( attribute ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> path = <STRING> % attribute <NEWLINE> try : <NEWLINE> <INDENT> http_response = _issue_http_request ( <NEWLINE> <INDENT> path , HTTP_GET , REQUIRED_METADATA_HEADER ) <NEWLINE> <DEDENT> read_response = http_response . read ( ) <NEWLINE> return read_response <NEWLINE> <DEDENT> except ( TypeError , ValueError , <NEWLINE> <INDENT> errors . MetadataServerHttpError ) as e : <NEWLINE> LOGGER . error ( <STRING> <NEWLINE> <INDENT> <STRING> , attribute , e ) <NEWLINE> return None <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def input_from_file ( filename , mode = <STRING> ) : <NEWLINE> <INDENT> with contextlib . closing ( open ( filename , mode ) ) as port : <NEWLINE> with CURRENT_INPUT_PORT . let ( port ) : <NEWLINE> <INDENT> yield <NEWLINE> <DEDENT> <DEDENT>
def _predictions_mean ( predictions , weights = None , name = None ) : <NEWLINE> <INDENT> with ops . name_scope ( <NEWLINE> <INDENT> name , <STRING> , ( predictions , weights ) ) as scope : <NEWLINE> predictions = math_ops . to_float ( predictions , name = <STRING> ) <NEWLINE> if weights is not None : <NEWLINE> weights = weights_broadcast_ops . broadcast_weights ( weights , predictions ) <NEWLINE> return metrics_lib . mean ( predictions , weights = weights , name = scope ) <NEWLINE> <DEDENT> <DEDENT>
def rm ( dest ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> _os . unlink ( native ( dest ) ) <NEWLINE> <DEDENT> except OSError , e : <NEWLINE> <INDENT> if _errno . ENOENT != e . errno : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def sparse_softmax_cross_entropy ( logits , labels , weights = 1.0 , scope = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with ops . name_scope ( scope , <STRING> , <NEWLINE> <INDENT> [ logits , labels , weights ] ) as scope : <NEWLINE> labels = array_ops . reshape ( labels , shape = [ array_ops . shape ( labels ) [ 0 ] ] ) <NEWLINE> weights = array_ops . squeeze ( weights ) <NEWLINE> losses = nn . sparse_softmax_cross_entropy_with_logits ( logits , labels , <NEWLINE> <INDENT> name = <STRING> ) <NEWLINE> return compute_weighted_loss ( losses , weights , scope = scope ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_integer ( self ) : <NEWLINE> <INDENT> ctx = typing . Context ( ) <NEWLINE> for aty , bty in itertools . product ( types . integer_domain , <NEWLINE> <INDENT> types . integer_domain ) : <NEWLINE> key = ( str ( aty ) , str ( bty ) ) <NEWLINE> try : <NEWLINE> expected = self . int_unify [ key ] <NEWLINE> except KeyError : <NEWLINE> expected = self . int_unify [ key [ : : - 1 ] ] <NEWLINE> self . assert_unify ( aty , bty , getattr ( types , expected ) ) <NEWLINE> <DEDENT> <DEDENT>
def key_even_by_priority ( self ) : <NEWLINE> <INDENT> hasHost = 0 <NEWLINE> if self . JobStatus . hostsOnJob ( ) > 0 : hasHost = 1 <NEWLINE> sortKey = <STRING> % ( hasHost , self . Job . priority ( ) , self . JobStatus . hostsOnJob ( ) , self . JobStatus . errorCount ( ) , self . Job . submittedts ( ) . toTime_t ( ) ) <NEWLINE> if VERBOSE_DEBUG : <NEWLINE> <INDENT> print <STRING> % ( self . Job . name ( ) , sortKey ) <NEWLINE> <DEDENT> return sortKey <NEWLINE> <DEDENT>
def retranslateUi ( self , TabnannyDialog ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> TabnannyDialog . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> TabnannyDialog . setWhatsThis ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def select_vendor ( ) : <NEWLINE> <INDENT> vendors = get_vendors ( ) [ <STRING> ] [ <STRING> ] <NEWLINE> if not vendors : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <STRING> <NEWLINE> <DEDENT> vendorList = [ ] <NEWLINE> vendorIdList = [ ] <NEWLINE> for i in range ( 0 , len ( vendors ) ) : <NEWLINE> <INDENT> vendorList . append ( vendors [ i ] [ <STRING> ] ) <NEWLINE> vendorIdList . append ( vendors [ i ] [ <STRING> ] ) <NEWLINE> <DEDENT> selection = get_selection ( <STRING> , vendorList ) <NEWLINE> if selection != None : <NEWLINE> return vendorIdList [ selection ] <NEWLINE> <DEDENT>
def _noncvx_id_to_idx ( dims , var_offsets , var_sizes ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> bool_idx = [ ] <NEWLINE> int_idx = [ ] <NEWLINE> for indices , constr_type in zip ( [ bool_idx , int_idx ] , <NEWLINE> <INDENT> [ s . BOOL_IDS , s . INT_IDS ] ) : <NEWLINE> for var_id in dims [ constr_type ] : <NEWLINE> offset = var_offsets [ var_id ] <NEWLINE> size = var_sizes [ var_id ] <NEWLINE> for i in range ( size [ 0 ] * size [ 1 ] ) : <NEWLINE> indices . append ( offset + i ) <NEWLINE> del dims [ constr_type ] <NEWLINE> <DEDENT> return bool_idx , int_idx <NEWLINE> <DEDENT>
def test_ToEPCTagUri ( self ) : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> epc = self . _sgln96 . encode ( self . _companyPrefix , None , self . _locationReference , self . _filter , self . _extension ) <NEWLINE> print ( epc . toEPCTagUri ( ) ) <NEWLINE> print ( <STRING> <NEWLINE> print ( <STRING> <NEWLINE> <DEDENT>
( <STRING> <NEWLINE> <DEDENT>
def post_install ( self , branch ) : <NEWLINE> <INDENT> if os . path . isfile ( postscript ) : <NEWLINE> <INDENT> if os . access ( postscript , os . X_OK ) : <NEWLINE> <INDENT> logger . debug ( <STRING> % postscript ) <NEWLINE> run_command ( <STRING> % ( postscript , branch . replace ( <STRING> , <STRING> ) . lower ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> logger . debug ( <STRING> % <NEWLINE> <INDENT> postscript ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def printColLabels ( board ) : <NEWLINE> <INDENT> ( rows , cols ) = ( 7 , 7 ) <NEWLINE> print ( <STRING> , ) <NEWLINE> for col in xrange ( cols ) : <NEWLINE> <INDENT> print chr ( ord ( <STRING> ) + col ) , <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT>
class ExprGraph : <NEWLINE> <INDENT> var graph : Code <NEWLINE> var term : Term <NEWLINE> <DEDENT>
def setUp ( self ) : <NEWLINE> <INDENT> UTConversionDataArrayNumPy . setUp ( self ) <NEWLINE> size = self . footprint // np . nbytes [ self . dtype ] <NEWLINE> digits , shape = shapeopt ( 1000 , size , ndims = 3 , ecc = 0.3 ) <NEWLINE> if self . verbose >= 1 : <NEWLINE> <INDENT> print <STRING> % ( digits , shape ) <NEWLINE> <DEDENT> self . shape = shape + ( 1 , ) <NEWLINE> self . assertAlmostEqual ( np . prod ( self . shape ) * np . nbytes [ self . dtype ] , self . footprint , - 4 ) <NEWLINE> <DEDENT>
lossMatrix [ i ] [ j ] = getLossFunc ( m_lines [ i ] ) , m_lines [ j ] ) <NEWLINE>
<INDENT> difference = datetime . datetime . now ( ) - birthday <NEWLINE> for vaccine in vaccineTimes : <NEWLINE> <INDENT> if difference >= vaccineTimes [ vaccine ] and db [ from_number ] [ vaccine ] == 0 : <NEWLINE> <INDENT> response . sms ( <STRING> + vaccine . upper ( ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def returnSearch ( ) : <NEWLINE> <INDENT> assert request . method == <STRING> <NEWLINE> searchTerm = request . form [ <STRING> ] <NEWLINE> ll = findCenterMinLargest ( listOfOrigin ) [ 0 ] <NEWLINE> businessJson = yelpSearch ( ll , searchTerm ) <NEWLINE> <INDENT> teles = timeSearch ( ll ) <NEWLINE> <DEDENT> return render_template ( <STRING> , dest = businessJson , teles3 = teles , listOfOrigin = listOfOrigin , latC = ll [ 0 ] , lngC = ll [ 1 ] ) <NEWLINE> <DEDENT>
def collect ( self ) : <NEWLINE> <INDENT> methods = self . methods ( ) <NEWLINE> for socket in sorted ( self . session . plugins . collect ( <STRING> ) , <NEWLINE> <INDENT> key = lambda socket : socket . last_pid ) : <NEWLINE> row = [ socket ] <NEWLINE> for method in methods : <NEWLINE> row . append ( method in socket . obj_producers ) <NEWLINE> yield row <NEWLINE> <DEDENT> <DEDENT>
def entropyGain ( data , clposition = LAST ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> assert type ( clposition ) is IntType <NEWLINE> data = _checkData ( data ) <NEWLINE> egains = [ ] <NEWLINE> for a in range ( len ( data [ 0 ] ) : <NEWLINE> <INDENT> egains . append ( egain ( data , a , clposition ) ) <NEWLINE> <DEDENT> egains . pop ( clposition ) <NEWLINE> return egains <NEWLINE> <DEDENT>
stdout = <STRING> ) <NEWLINE>
def read ( self , size = 1 , timeout = None ) : <NEWLINE> <INDENT> timeout_errmsg = <STRING> % ( self . _host , self . _port ) <NEWLINE> with gevent . Timeout ( timeout or self . _timeout , <NEWLINE> <INDENT> SocketTimeout ( timeout_errmsg ) ) : <NEWLINE> while len ( self . _data ) < size : <NEWLINE> self . _event . wait ( ) <NEWLINE> self . _event . clear ( ) <NEWLINE> <DEDENT> msg = self . _data [ : size ] <NEWLINE> self . _data = self . _data [ size : ] <NEWLINE> return msg <NEWLINE> <DEDENT>
def reservecommit ( client , nsi_header , connection_id ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> yield client . reserveCommit ( nsi_header , connection_id ) <NEWLINE> log . msg ( <STRING> % nsi_header . provider_nsa ) <NEWLINE> <DEDENT> except error . NSIError , e : <NEWLINE> <INDENT> _logError ( e ) <NEWLINE> <DEDENT> <DEDENT>
def flip_images ( images ) : <NEWLINE> <INDENT> new = [ ] <NEWLINE> for i in images : <NEWLINE> <INDENT> new . append ( pygame . transform . flip ( i , 1 , 0 ) <NEWLINE> <DEDENT> return new <NEWLINE> <DEDENT>
def get_service_function_chains_data ( ) : <NEWLINE> <INDENT> return { <NEWLINE> <STRING> : { <NEWLINE> <INDENT> <STRING> : [ <NEWLINE> <INDENT> { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : [ <NEWLINE> <INDENT> { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> <DEDENT> } , <NEWLINE> { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>
def verify_add ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> email = request . params . get ( <STRING> , None ) <NEWLINE> if not email : <NEWLINE> <INDENT> return error_msg ( <STRING> ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> v = ses . verifyEmailAddress ( email ) <NEWLINE> <DEDENT> except AmazonError , e : <NEWLINE> <INDENT> return error_msg ( e . __unicode__ ( ) ) <NEWLINE> <DEDENT> resp = { <STRING> : <STRING> , <STRING> : v . requestId , } <NEWLINE> return json_encode ( resp ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = sys . argv [ 1 ] <NEWLINE> n = int ( n ) <NEWLINE> second time lucky <NEWLINE> result = n / 2 * ( n + 1 ) <NEWLINE> print ( <STRING> , result ) <NEWLINE> result = 0 <NEWLINE> for i in xrange ( n + 1 ) : <NEWLINE> <INDENT> result = i + result <NEWLINE> <DEDENT> print ( <STRING> , result ) <NEWLINE> result = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> result = i + result <NEWLINE> <DEDENT> print ( <STRING> , result ) <NEWLINE>
def run_query ( query = <STRING> ) : <NEWLINE> <INDENT> datos = [ DB_HOST , DB_USER , DB_PASS , DB_NAME ] <NEWLINE> conn = MySQLdb . connect ( * datos ) <NEWLINE> cursor = conn . cursor ( ) <NEWLINE> cursor . execute ( query ) <NEWLINE> if query . upper ( ) . startswith ( <STRING> ) : <NEWLINE> data = cursor . fetchall ( ) <NEWLINE> else : <NEWLINE> conn . commit ( ) <NEWLINE> data = None <NEWLINE> cursor . close ( ) <NEWLINE> conn . close ( ) <NEWLINE> return data <NEWLINE> <DEDENT>
def f ( self , y , t ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> A , w , b , c , m = [ p [ k ] for k in <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> f = self . _fy [ self . p [ <STRING> ] ] <NEWLINE> return [ y [ 1 ] , ( A * cos ( w * t ) - b * y [ 1 ] - c * f ( y [ 0 ] ) ) / m ] <NEWLINE> <DEDENT>
def load_metrics ( filename ) <NEWLINE> <INDENT> metric_list = [ ] <NEWLINE> f = open ( filename , <STRING> ) <NEWLINE> for l in f : <NEWLINE> <INDENT> items = l . split ( ) <NEWLINE> print ( items ) <NEWLINE> metric_list . append ( items ) <NEWLINE> <DEDENT> f . close ( ) <NEWLINE> return metric_list <NEWLINE> <DEDENT>
class PostgresqlImpl ( DefaultImpl ) : <NEWLINE> <INDENT> __dialect__ = <STRING> <NEWLINE> transactional_ddl = True <NEWLINE> def compare_server_default ( self , inspector_column , <NEWLINE> <INDENT> metadata_column , <NEWLINE> rendered_metadata_default ) : <NEWLINE> if metadata_column . primary_key and metadata_column is metadata_column . table . _autoincrement_column : <NEWLINE> return False <NEWLINE> conn_col_default = inspector_column [ <STRING> ] <NEWLINE> if metadata_column . type . _type_affinity is not sqltypes . String : <NEWLINE> rendered_metadata_default = re . sub ( <STRING> , <STRING> , rendered_metadata_default ) <NEWLINE> return not self . connection . scalar ( <NEWLINE> <STRING> % ( <NEWLINE> conn_col_default , <NEWLINE> rendered_metadata_default <NEWLINE> ) <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT>
def test_positive_create_with_password ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for password in generate_strings_list ( <NEWLINE> <INDENT> exclude_types = [ <STRING> ] , max_length = 50 ) : <NEWLINE> with self . subTest ( password ) : <NEWLINE> user = entities . User ( password = password ) . create ( ) <NEWLINE> self . assertIsNotNone ( user ) <NEWLINE> <DEDENT> <DEDENT>
<INDENT> print ( <STRING> ) , <STRING> . join ( mod_lines ) ) <NEWLINE>
def _getDbfile ( self , session_id ) : <NEWLINE> <INDENT> session_dir = self . _getSessionDir ( session_id ) ; <NEWLINE> db_file = None <NEWLINE> try : <NEWLINE> for fname in os . listdir ( session_dir ) : <NEWLINE> <INDENT> if fname . endswith ( DBFILE_SFX ) : <NEWLINE> <INDENT> return os . path . join ( session_dir , fname ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> raise cherrypy . HTTPError ( 400 , <STRING> % session_id ) <NEWLINE> <DEDENT> raise cherrypy . HTTPError ( 500 , <STRING> % session_id ) <NEWLINE> <DEDENT>
def chunk_IHDR ( self , offset , bytes ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . count == 0 : <NEWLINE> <INDENT> raise SyntaxError , <STRING> <NEWLINE> <DEDENT> s = self . fp . read ( bytes ) <NEWLINE> size , mode , rawmode = self . __getmodesize ( s ) <NEWLINE> self . action = ( <STRING> , ) <NEWLINE> self . im = Image . core . new ( mode , size ) <NEWLINE> self . decoder = Image . core . zip_decoder ( rawmode ) <NEWLINE> self . decoder . setimage ( self . im , ( 0 , 0 ) + size ) <NEWLINE> self . data = <STRING> <NEWLINE> return s <NEWLINE> <DEDENT>
def call_command ( self , command , args ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> with hou . undos . disabler ( ) : <NEWLINE> <INDENT> call = getattr ( self , command ) <NEWLINE> call ( args ) <NEWLINE> <DEDENT> <DEDENT> except Exception , e : <NEWLINE> <INDENT> error = ( command , args , e ) <NEWLINE> self . log . error ( <STRING> % error ) <NEWLINE> raise e <NEWLINE> <DEDENT> <DEDENT>
def _detach_all_attachments ( self , ctxt , volume ) : <NEWLINE> <INDENT> attachments = volume [ <STRING> ] or [ ] <NEWLINE> for attachment in attachments : <NEWLINE> <INDENT> if ( attachment [ <STRING> ] == self . host and <NEWLINE> <INDENT> attachment [ <STRING> ] is None ) : <NEWLINE> try : <NEWLINE> rpcapi = self . volume_rpcapi <NEWLINE> rpcapi . detach_volume ( ctxt , volume , attachment [ <STRING> ] ) <NEWLINE> except Exception : <NEWLINE> LOG . exception ( _LE ( <STRING> <NEWLINE> <INDENT> <STRING> ) , <NEWLINE> { <STRING> : attachment [ <STRING> ] } , <NEWLINE> resource = volume ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def check_preconditions ( cls ) : <NEWLINE> <INDENT> super ( TestNetworkBasicOps , cls ) . check_preconditions ( ) <NEWLINE> if not ( CONF . network . tenant_networks_reachable <NEWLINE> <INDENT> or CONF . network . public_network_id ) : <NEWLINE> msg = ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> raise cls . skipException ( msg ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def pathsplit ( p , rest = [ ] ) : <NEWLINE> <INDENT> ( h t ) = os . path . split ( p ) <NEWLINE> if len ( h ) < 1 : return [ t ] + rest <NEWLINE> if len ( t ) < 1 : return [ h ] + rest <NEWLINE> return pathsplit ( h , [ t ] + rest ) <NEWLINE> <DEDENT>
class TimeStamp ( DateTime ) : <NEWLINE> <INDENT> def __init__ ( self , name = None , values = None , data_type = <STRING> , * args , <NEWLINE> <INDENT> ** kwargs ) : <NEWLINE> def default ( ) : <NEWLINE> return datetime . now ( ) <NEWLINE> kwargs [ <STRING> ] = default <NEWLINE> super ( ) . __init__ ( name = name , values = values , data_type = data_type , <NEWLINE> <INDENT> max_values = 1 , overwrite_last_value = False , * args , <NEWLINE> ** kwargs ) <NEWLINE> <DEDENT> <DEDENT> def can_set ( self , value ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT>
def poly ( order ) : <NEWLINE> <INDENT> def f ( ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> fstr = <STRING> <NEWLINE> statement = <STRING> <NEWLINE> for i in range ( order , 1 , - 1 ) : <NEWLINE> <INDENT> fstr += <STRING> + str ( i ) <NEWLINE> statement += <STRING> + str ( i ) + <STRING> + str ( i ) + <STRING> <NEWLINE> <DEDENT> fstr += statement + <STRING> <NEWLINE> exec fstr <NEWLINE> return f <NEWLINE> <DEDENT>
def test_add_ovs_flow_with_dest_mac ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( self . ovs_firewall . sg_br , <STRING> , <NEWLINE> <INDENT> return_value = self . mock_br ) , mock . patch . object ( self . mock_br , <STRING> ) as mock_add_flow : <NEWLINE> dest_mac = <STRING> <NEWLINE> self . ovs_firewall . _add_ovs_flow ( self . mock_br , 0 , 1 , <STRING> , <NEWLINE> <INDENT> dl_dest = dest_mac ) <NEWLINE> mock_add_flow . assert_called_with ( table = 1 , priority = 0 , <NEWLINE> <INDENT> dl_dst = dest_mac , <NEWLINE> actions = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
class Configuration ( ConfigurationMixIn ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , config_file = None , options = None , name = None , <NEWLINE> <INDENT> usage = None , doc = None , version = None ) : <NEWLINE> if options is not None : <NEWLINE> self . options = options <NEWLINE> if name is not None : <NEWLINE> self . name = name <NEWLINE> if doc is not None : <NEWLINE> self . __doc__ = doc <NEWLINE> super ( Configuration , self ) . __init__ ( config_file = config_file , usage = usage , version = version ) <NEWLINE> <DEDENT> <DEDENT>
def got_zone_id ( response ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> ) <NEWLINE> zone_id = response . data . get ( domain_name , <STRING> ) <NEWLINE> print ( <STRING> . format ( domain_name , zone_id ) ) ) <NEWLINE> print ( <STRING> , zone_id ) <NEWLINE> def updated_snapshot ( response ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( response . data ) <NEWLINE> reactor . stop ( ) <NEWLINE> <DEDENT> cloudflare . zone_grab ( zone_id = zone_id ) . addCallback ( updated_snapshot ) . addErrback ( got_error ) <NEWLINE> <DEDENT>
( <STRING> <NEWLINE> <DEDENT>
def test_from_crawler_init_call ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( self . spider_class , <STRING> , <NEWLINE> <INDENT> return_value = None ) as mock_init : <NEWLINE> self . spider_class . from_crawler ( get_crawler ( ) , <STRING> , <NEWLINE> <INDENT> foo = <STRING> ) <NEWLINE> mock_init . assert_called_once_with ( <STRING> , foo = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_doesnt_challenges_on_401_with_WWW_Authenticate ( self ) : <NEWLINE> <INDENT> decider = self . _getFUT ( ) <NEWLINE> self . failIf ( decider ( { } , <STRING> , [ ( <STRING> , <STRING> ) ] ) <NEWLINE> <DEDENT>
def init_servo ( ) : <NEWLINE> <INDENT> pigpio . set_PWM_frequency ( PIN , 50 ) <NEWLINE> pigpio . set_PWM_range ( PIN , 20000 ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> move_servo ( CENTER ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import random <NEWLINE> import weakref <NEWLINE> import gevent <NEWLINE> from gevent . queue import Queue <NEWLINE> from gevent . event import Event <NEWLINE> from socketio import packet <NEWLINE> def default_error_handler ( socket , error_name , error_message , endpoint , <NEWLINE> <INDENT> msg_id , quiet ) : <NEWLINE> <STRING> <NEWLINE> pkt = dict ( type = <STRING> , name = <STRING> , <NEWLINE> args = [ error_name , error_message ] , <NEWLINE> endpoint = endpoint ) <NEWLINE> if msg_id : <NEWLINE> pkt [ <STRING> ] = msg_id <NEWLINE> if not quiet : <NEWLINE> socket . send_packet ( pkt ) <NEWLINE> print ( <STRING> % ( <NEWLINE> error_name , error_message , endpoint , msg_id ) ) <NEWLINE> <DEDENT>
def putAnnouncement ( self , request ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return StringMessage ( data = self . _cacheAnnouncement ( ) ) ) <NEWLINE> <DEDENT>
def test_normalize_summary ( self ) : <NEWLINE> <INDENT> self . assertEqual ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> docformatter . normalize_summary ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<INDENT> help = <STRING> ) <NEWLINE>
def checkExistence ( self , name ) : <NEWLINE> <INDENT> found = 0 <NEWLINE> for x in g_attribs : <NEWLINE> <INDENT> if x == name : <NEWLINE> found = 1 <NEWLINE> break <NEWLINE> <DEDENT> if not found : <NEWLINE> <INDENT> raise UnknownPropertyException ( <STRING> + name + <STRING> , self ) <NEWLINE> <DEDENT> <DEDENT>
def add_new_to_container_url ( regrouped ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> container = regrouped [ <STRING> ] <NEWLINE> containertypename = type ( container ) . __name__ . lower ( ) <NEWLINE> try : <NEWLINE> <INDENT> subtypename = subtypenames [ containertypename ] <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> raise ValueError ( <STRING> % containertypename ) <NEWLINE> <DEDENT> return reverse ( <STRING> % subtypename ) + <STRING> % ( containertypename container . id ) <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> raise ImproperlyConfigured ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , id ) : <NEWLINE> self . id = id <NEWLINE> self . neighbours = [ ] <NEWLINE> def addNeighbour ( self , nb ) : <NEWLINE> self . neighbours . append ( nb ) <NEWLINE> <DEDENT>
def on_window_state_change ( self , widget , event , * args ) <NEWLINE> <INDENT> if event . new_window_state & gtk . gdk . WINDOW_STATE_FULLSCREEN : <NEWLINE> <INDENT> self . window_in_fullscreen = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . window_in_fullscreen = False <NEWLINE> <DEDENT> self . draw_base ( ) <NEWLINE> <DEDENT>
import logging <NEWLINE> import tornado . httpserver <NEWLINE> import tornado . ioloop <NEWLINE> import tornado . web <NEWLINE> import sys <NEWLINE> import os <NEWLINE> from tornado . options import options <NEWLINE> current_directory = os . path . dirname ( os . path . realpath ( __file__ ) ) <NEWLINE> for target_path in [ current_directory , <NEWLINE> <INDENT> os . path . join ( current_directory , <STRING> ) ] : <NEWLINE> if os . path . exists ( target_path ) : <NEWLINE> if target_path not in sys . path : <NEWLINE> sys . path . insert ( 0 , target_path ) <NEWLINE> <DEDENT> from app import CozyDataIndexer <NEWLINE> app = CozyDataIndexer ( ) <NEWLINE>
def delname ( self , name ) : <NEWLINE> <INDENT> syminf = self . scope . tbl . get ( name ) <NEWLINE> if syminf and syminf . flags & GLOBAL : return self . delCode ( <STRING> , name ) <NEWLINE> if not self . fast_locals : return self . delCode ( <STRING> , name ) <NEWLINE> if syminf . flags & CELL : raise NameError , <STRING> % name <NEWLINE> return self . delCode ( <STRING> , syminf . locals_index ) <NEWLINE> <DEDENT>
class Collector ( DefaultProcess ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> queue = None , <NEWLINE> shutdown = None , <NEWLINE> config = None ) : <NEWLINE> DefaultProcess . __init__ ( self , <NEWLINE> <INDENT> name = name , <NEWLINE> shutdown = shutdown , <NEWLINE> config = config ) <NEWLINE> self . queue = queue <NEWLINE> self . interval = 30 <NEWLINE> <DEDENT> <DEDENT> def shutdown ( self ) : <NEWLINE> <INDENT> self . log . info ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> def run ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> raise NotImplementedError <NEWLINE> <DEDENT> <DEDENT>
def taskDetail ( request , task_id ) : <NEWLINE> <INDENT> task = get_object_or_404 ( Task , pk = task_id ) <NEWLINE> <INDENT> if task . publication_date >= datetime . now ( ) and not request . user . is_trainer : <NEWLINE> raise Http404 <NEWLINE> <DEDENT> my_solutions = Task . objects . get ( pk = task_id ) . solution_set . filter ( author = request . user ) <NEWLINE> <INDENT> return render_to_response ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> { <NEWLINE> <INDENT> <STRING> : task , <NEWLINE> <STRING> : my_solutions , <NEWLINE> <DEDENT> } , <NEWLINE> context_instance = RequestContext ( request ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class WsgiApplication ( _SpyneWsgiApplication ) : <NEWLINE> <INDENT> def __init__ ( self , app , chunked = True , max_content_length = 2 * 1024 * 1024 , <NEWLINE> <INDENT> block_length = 8 * 1024 ) : <NEWLINE> super ( WsgiApplication , self ) . __init__ ( app , chunked , max_content_length , <NEWLINE> <INDENT> block_length ) <NEWLINE> self . doc = _AllYourInterfaceDocuments ( app . interface ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from __future__ import absolute_import <NEWLINE> import subprocess <NEWLINE> import os <NEWLINE> from dmp_packs . actions . models import StreamingActionExecution , MESSAGE_TYPES <NEWLINE> def streaming_action_runner_callback ( execution_id , pack , action , <NEWLINE> <INDENT> cleaned_parameters ) : <NEWLINE> streaming_action = StreamingActionExecution . objects . get ( <NEWLINE> id_execution = execution_id , <NEWLINE> pack_slug = pack . slug , <NEWLINE> action_slug = action . slug ) <NEWLINE> if action . runner_type == <STRING> : <NEWLINE> local_shell_script_runner ( action , cleaned_parameters , streaming_action ) <NEWLINE> <DEDENT>
def changedEntry ( self ) : <NEWLINE> <INDENT> for x in self . onChangedEntry : <NEWLINE> <INDENT> x ( ) <NEWLINE> <INDENT> def keyCancel ( self ) : <NEWLINE> <INDENT> for x in self [ <STRING> ] . list : <NEWLINE> <INDENT> x [ 1 ] . cancel ( ) <NEWLINE> <DEDENT> self . close ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<STRING> <NEWLINE> __version__ = <STRING> <NEWLINE> import string <NEWLINE> for name in ( s <NEWLINE> <INDENT> for s in dir ( string ) <NEWLINE> if not s . startswith ( <STRING> ) ) : <NEWLINE> value = getattr ( string , name ) <NEWLINE> if isinstance ( value , basestring ) : <NEWLINE> print ( <STRING> % ( name , value ) ) <NEWLINE> <DEDENT>
def resolve ( self , url , title , iconimage , meta ) : <NEWLINE> <INDENT> r = client . request ( url ) <NEWLINE> r = BeautifulSoup ( r ) <NEWLINE> r = r . findAll ( <STRING> ) <NEWLINE> for src in r : <NEWLINE> url = src [ <STRING> ] . encode ( <STRING> ) <NEWLINE> try : host = re . findall ( <STRING> , urlparse . urlparse ( url . strip ( ) . lower ( ) ) . netloc ) [ 0 ] <NEWLINE> except : host = <STRING> <NEWLINE> control . addLink ( host , url , <STRING> , iconimage , control . fanart , meta ) <NEWLINE> <DEDENT>
def get_patient ( patient_id ) : <NEWLINE> <INDENT> try <NEWLINE> <INDENT> if not patient_id : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> patient = Patient . objects . get ( pk = patient_id ) <NEWLINE> return patient <NEWLINE> <DEDENT> except Patient . DoesNotExist : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT>
def _lift_substructure_match ( self , subm ) : <NEWLINE> <INDENT> if not self . _is_liftable_substructure_match ( subm ) : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> if all ( map ( lambda r : r == SubstructureMatch . WHOLE_CONCEPT ) , <NEWLINE> <INDENT> subm . constituent_ranges ) : <NEWLINE> ancestors = map ( lambda c : concept . ancestors ( c ) , <NEWLINE> <INDENT> subm . concepts ) <NEWLINE> longest_common_ancestors = longest_common_prefix ( ancestors ) <NEWLINE> ancestral_parent = longest_common_ancestors [ - 1 ] <NEWLINE> ancestral_constituents = [ ] <NEWLINE> for ancs in ancestors : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def check_content_type ( fuzzresult , which ) : <NEWLINE> <INDENT> ctype = None <NEWLINE> if <STRING> in fuzzresult . history . headers . response : <NEWLINE> ctype = fuzzresult . history . headers . response [ <STRING> ] <NEWLINE> if which == <STRING> : <NEWLINE> return not ctype or ( ctype and any ( map ( lambda x : ctype . find ( x ) >= 0 , [ <STRING> ] ) ) ) <NEWLINE> else : <NEWLINE> raise FuzzExceptBadAPI ( <STRING> ) <NEWLINE> <DEDENT>
def onExecute ( self , ec_id ) : <NEWLINE> <INDENT> duration = time . clock ( ) - self . _activatedClock <NEWLINE> if self . _statusIn . isNew ( ) : <NEWLINE> self . _d_status = self . _statusIn . read ( ) <NEWLINE> self . _received = True <NEWLINE> self . _d_command . acceleratorPressMeter = math . sin ( duration / self . _interval * 2 * math . pi ) <NEWLINE> print ( self . _d_command ) <NEWLINE> self . _commandOut . write ( ) <NEWLINE> return RTC . RTC_OK <NEWLINE> <DEDENT>
def send_loop ( empty_queue_sleep = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> empty_queue_sleep = empty_queue_sleep or settings . EMPTY_QUEUE_SLEEP <NEWLINE> while True : <NEWLINE> <INDENT> while not models . QueuedMessage . objects . all ( ) <NEWLINE> <INDENT> logger . debug ( <STRING> <NEWLINE> <INDENT> <STRING> % empty_queue_sleep ) <NEWLINE> <DEDENT> time . sleep ( empty_queue_sleep ) <NEWLINE> <DEDENT> send_all ( ) <NEWLINE> <DEDENT> <DEDENT>
import os <NEWLINE> def update_privoxy_list ( blocked_urls , <NEWLINE> <INDENT> version , title , last_modified , <NEWLINE> homepage , license , issue_tracker ) : <NEWLINE> script_dir = os . path . dirname ( __file__ ) <NEWLINE> list_path = os . path . join ( script_dir , <STRING> ) <NEWLINE> with open ( list_path , <STRING> ) as privoxy_list : <NEWLINE> print ( <STRING> , file = privoxy_list ) <NEWLINE> for url in blocked_urls : <NEWLINE> print ( <STRING> , file = privoxy_list ) <NEWLINE> <DEDENT>
[ [ [ cog <NEWLINE> import sys <NEWLINE> sys . path . append ( <STRING> ) <NEWLINE> import cog <NEWLINE>
( datetime . datetime . fromtimestamp ( login_time , pytz . timezone ( <STRING> ) ) . strftime ( <NEWLINE> <INDENT> <STRING> ) , <NEWLINE> <DEDENT> if login_tty in tty : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <NEWLINE> <DEDENT> <DEDENT>
def plotStarDist ( text , xlabel , ylabel , data ) : <NEWLINE> <INDENT> x = [ data [ key ] for key in data ] <NEWLINE> n , bins , patches = P . hist ( x , 10 , normed = 0 , histtype = <STRING> ) <NEWLINE> <INDENT> P . xlabel ( xlabel ) <NEWLINE> P . ylabel ( ylabel ) <NEWLINE> P . setp ( patches , <STRING> , <STRING> , <STRING> , 0.75 ) <NEWLINE> P . title ( text ) <NEWLINE> P . show ( ) <NEWLINE> <DEDENT> <DEDENT>
def _get_next_open_batch ( self ) -> Batch : <NEWLINE> <INDENT> <STRING> <NEWLINE> for batch in Batch . objects . filter ( <NEWLINE> <INDENT> task_type = self . type_name , <NEWLINE> closed__ne = True ) . order_by ( <STRING> ) : <NEWLINE> if batch . tasks_count == batch . tasks_processed : <NEWLINE> continue <NEWLINE> return batch <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>
def hasplugin ( self , name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return bool ( self . get_plugin ( name ) <NEWLINE> <DEDENT>
class UnknownTashkeel : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def lookup ( self , word ) <NEWLINE> <INDENT> <STRING> <NEWLINE> return unkown_const . Table . get ( word , word ) <NEWLINE> <DEDENT> <DEDENT>
import salome <NEWLINE> salome . salome_init ( ) <NEWLINE> import GEOM <NEWLINE> from salome . geom import geomBuilder <NEWLINE> geompy = geomBuilder . New ( salome . myStudy ) <NEWLINE> box = geompy . MakeBoxDXDYDZ ( 100 , 30 , 100 ) <NEWLINE> IsValid = geompy . CheckSelfIntersections ( box ) <NEWLINE> if IsValid == 0 : <NEWLINE> <INDENT> raise RuntimeError , <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
class TestEC2ClientContext ( TestCase ) : <NEWLINE> <INDENT> def test_aws_ec2_client_ontext_proper_initialized ( self ) : <NEWLINE> <INDENT> aws_session_manager = Mock ( ) <NEWLINE> expected_client = Mock ( ) <NEWLINE> aws_session_manager . get_ec2_client = Mock ( return_value = expected_client ) <NEWLINE> cloudshell_session = Mock ( ) <NEWLINE> aws_ec2_resource_model = Mock ( ) <NEWLINE> with EC2ClientContext ( aws_session_manager = aws_session_manager , <NEWLINE> <INDENT> cloudshell_session = cloudshell_session , <NEWLINE> aws_ec2_resource_model = aws_ec2_resource_model ) as ec2_client : <NEWLINE> aws_session_manager . get_ec2_client . assert_called_with ( cloudshell_session = cloudshell_session , <NEWLINE> <INDENT> aws_ec2_data_model = aws_ec2_resource_model ) <NEWLINE> self . assertEquals ( ec2_client , expected_client ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import logging <NEWLINE> BLACK = <STRING> <NEWLINE> RED = <STRING> <NEWLINE> GREEN = <STRING> <NEWLINE> ORANGE = <STRING> <NEWLINE> BLUE = <STRING> <NEWLINE> PURPLE = <STRING> <NEWLINE> CYAN = <STRING> <NEWLINE> LIGHTGREY = <STRING> <NEWLINE> DARKGRAY = <STRING> <NEWLINE> LIGHTRED = <STRING> <NEWLINE> LIGHTGREEN = <STRING> <NEWLINE> YELLOW = <STRING> <NEWLINE> LIGHTBLUE = <STRING> <NEWLINE> PINK = <STRING> <NEWLINE> LIGHTCYAN = <STRING> <NEWLINE> RED_BKGND = <STRING> <NEWLINE> ENDC = <STRING> <NEWLINE> BOLD = <STRING> a <NEWLINE> UNDERLINE = <STRING> <NEWLINE> LOG_FILE_FORMAT = <STRING> <NEWLINE> LOG_FILE_DATEFMT = <STRING> <NEWLINE> LOG_FILE_LEVEL = logging . DEBUG <NEWLINE> LOG_FILE_NAME = <STRING> <NEWLINE> LOG_CONSOLE_FORMAT = DARKGRAY + <STRING> + ENDC + <STRING> <NEWLINE> LOG_CONSOLE_DATEFMT = <STRING> <NEWLINE> LOG_CONSOLE_LEVEL = logging . DEBUG <NEWLINE>
( <STRING> <NEWLINE> <DEDENT>
def p_courier ( p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if len ( p ) == 3 : <NEWLINE> p [ 0 ] = p [ 1 ] + p [ 2 ] <NEWLINE> else : <NEWLINE> p [ 0 ] = p [ 1 ] <NEWLINE> parser_verbose ( p ) <NEWLINE> <DEDENT>
def test_invalid_mixing_encrypt_decrypt ( self ) : <NEWLINE> <INDENT> for method1_name , method2_name in ( ( <STRING> , <STRING> ) , <NEWLINE> <INDENT> ( <STRING> , <STRING> ) ) : <NEWLINE> for assoc_data_present in ( True , False ) : <NEWLINE> cipher = AES . new ( self . key_128 , AES . MODE_EAX , <NEWLINE> nonce = self . nonce_96 ) <NEWLINE> if assoc_data_present : <NEWLINE> cipher . update ( self . data_128 ) <NEWLINE> getattr ( cipher , method1_name ) ( self . data_128 ) <NEWLINE> self . assertRaises ( TypeError , getattr ( cipher , method2_name ) , <NEWLINE> self . data_128 ) <NEWLINE> <DEDENT> <DEDENT>
import os <NEWLINE> import sys <NEWLINE> import site <NEWLINE> from peewee import * <NEWLINE> import datetime <NEWLINE> reload ( sys ) sys . setdefaultencoding ( <STRING> ) <NEWLINE> database = SqliteDatabase ( <STRING> , ** { } ) <NEWLINE>
def create ( self , vals ) : <NEWLINE> <INDENT> if ( <NEWLINE> <INDENT> <STRING> not in vals and <NEWLINE> vals . get ( <STRING> ) and <NEWLINE> vals . get ( <STRING> ) ) : <NEWLINE> partner = self . env [ <STRING> ] . browse ( vals [ <STRING> ] ) <NEWLINE> if vals [ <STRING> ] in ( <STRING> , <STRING> ) : <NEWLINE> vals [ <STRING> ] = partner . customer_invoice_transmit_method_id . id or False <NEWLINE> else : <NEWLINE> vals [ <STRING> ] = partner . supplier_invoice_transmit_method_id . id or False <NEWLINE> <DEDENT> return super ( AccountInvoice , self ) . create ( vals ) <NEWLINE> <DEDENT>
( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
def writeList ( self , reg , list ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> if self . debug : <NEWLINE> <INDENT> print ( <STRING> % reg ) <NEWLINE> print ( list ) <NEWLINE> <DEDENT> self . bus . write_i2c_block_data ( self . address , reg , list ) <NEWLINE> <DEDENT> except IOError , err : <NEWLINE> <INDENT> return self . errMsg ( ) <NEWLINE> <DEDENT> <DEDENT>
def enqueue ( self , vals , name = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with ops . op_scope ( self . _scope_vals ( vals ) , name , <NEWLINE> <INDENT> <STRING> % self . _name ) as scope : <NEWLINE> vals = self . _check_enqueue_dtypes ( vals ) <NEWLINE> for val , shape in zip ( vals , self . _shapes ) : <NEWLINE> val . get_shape ( ) . assert_is_compatible_with ( shape ) <NEWLINE> return gen_data_flow_ops . _queue_enqueue ( self . _queue_ref , vals , name = scope ) <NEWLINE> <DEDENT> <DEDENT>
def test_getParameterNames_php_function_doesnt_have_parameters ( self ) : <NEWLINE> <INDENT> functionName = <STRING> <NEWLINE> fileDir = path . join ( os . sep , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> expected = [ ] <NEWLINE> <INDENT> obj = self . _getInstance ( ) <NEWLINE> parameterNames = obj . _getParameterNames ( functionName , fileDir ) <NEWLINE> self . assertEqual ( expected , parameterNames ) <NEWLINE> <DEDENT> <DEDENT>
from django . http import QueryDict <NEWLINE> from django_facebook import settings as facebook_settings <NEWLINE> def generate_oauth_url ( scope = facebook_settings . FACEBOOK_DEFAULT_SCOPE , <NEWLINE> <INDENT> next = None , extra_data = None ) : <NEWLINE> query_dict = QueryDict ( <STRING> , True ) <NEWLINE> canvas_page = ( next if next is not None else <NEWLINE> facebook_settings . FACEBOOK_CANVAS_PAGE ) <NEWLINE> query_dict . update ( dict ( client_id = facebook_settings . FACEBOOK_APP_ID , <NEWLINE> <INDENT> redirect_uri = canvas_page , scope = scope ) ) <NEWLINE> if extra_data : <NEWLINE> query_dict . update ( extra_data ) <NEWLINE> auth_url = <STRING> % ( <NEWLINE> query_dict . urlencode ( ) , ) <NEWLINE> return auth_url <NEWLINE> <DEDENT> <DEDENT>
def test_model_insert ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> from { { appname } } . models . sql . pow_test_model import PowTestModel <NEWLINE> m = PowTestModel ( ) <NEWLINE> m . name = <STRING> <NEWLINE> assert isinstance ( m , PowTestModel ) <NEWLINE> <DEDENT>
class FirstCase ( TestCase ) : <NEWLINE> <INDENT> def test_1 ( self ) : <NEWLINE> Spec = self . heapy . Spec <NEWLINE> TestEnv = Spec . mkTestEnv ( _Specification_ ) <NEWLINE> TestEnv . test ( self . guppy . heapy . AbstractAlgebra ) <NEWLINE> <DEDENT>
def test_reenable_replication_fail_on_cinder_exception ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . driver . do_setup ( None ) <NEWLINE> replicated_volume = copy . deepcopy ( REPLICATED_VOLUME ) <NEWLINE> replicated_volume [ <STRING> ] = <STRING> <NEWLINE> self . assertRaises ( <NEWLINE> <INDENT> exception . CinderException , <NEWLINE> self . driver . reenable_replication <NEWLINE> CONTEXT , <NEWLINE> replicated_volume <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def ListCompare ( l1 , l2 ) : <NEWLINE> <INDENT> if len ( l1 ) is not len ( l2 ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for i in range ( len ( l1 ) ) <NEWLINE> <INDENT> if l1 [ i ] is not l2 [ i ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT>
class ZipNumpyUnpickler ( NumpyUnpickler ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , filename , file_handle ) : <NEWLINE> <INDENT> NumpyUnpickler . __init__ ( self , filename , <NEWLINE> <INDENT> file_handle <NEWLINE> mmap_mode = None ) <NEWLINE> <DEDENT> <DEDENT> def _open_pickle ( self , file_handle ) : <NEWLINE> <INDENT> return BytesIO ( read_zfile ( file_handle ) ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self ) : <NEWLINE> <INDENT> super ( RecordingDatePlugin , self ) . __init__ ( ) <NEWLINE> for recording_field in ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ) : <NEWLINE> field = mediafile . MediaField ( <NEWLINE> <INDENT> mediafile . MP3DescStorageStyle ( recording_field ) , <NEWLINE> mediafile . MP4StorageStyle ( <STRING> . format ( <NEWLINE> <INDENT> recording_field ) ) , <NEWLINE> <DEDENT> mediafile . StorageStyle ( recording_field ) ) <NEWLINE> self . add_media_field ( recording_field , field ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_var7 ( self ) : <NEWLINE> <INDENT> self . top . oneout . ratio2 = 20 <NEWLINE> try : <NEWLINE> <INDENT> self . top . connect ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> except Exception , err : <NEWLINE> <INDENT> msg = <STRING> + <STRING> <STRING> <NEWLINE> self . assertEqual ( str ( err ) , msg ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . fail ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<INDENT> output . write ( { feature [ <STRING> ] [ <STRING> ] : } , <STRING> : mapping ( shape ) } ) <NEWLINE>
def split_unidirectional_migration ( params , ( n1 , n2 ) , pts ) : <NEWLINE> <INDENT> nuW , nuC , T , m12 = params <NEWLINE> xx = Numerics . default_grid ( pts ) <NEWLINE> phi = PhiManip . phi_1D ( xx ) <NEWLINE> phi = PhiManip . phi_1D_to_2D ( xx , phi ) <NEWLINE> phi = Integration . two_pops ( phi , xx , T , nuW , nuC , m12 = m12 ) <NEWLINE> model_sfs = Spectrum . from_phi ( phi , ( n1 , n2 ) , ( xx , xx ) ) <NEWLINE> return model_sfs <NEWLINE> <DEDENT>
def generate_strongly_correlated ( profits , delta ) : <NEWLINE> <INDENT> weights = [ ] <NEWLINE> max_profit = max ( profits ) <NEWLINE> for i in range ( len ( profits ) ) : <NEWLINE> weights . append ( profits [ i ] + max_profit / delta ) <NEWLINE> return weights <NEWLINE> <DEDENT>
def install_default_probe ( self , session ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for bundle in ( <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> try : <NEWLINE> self . _context . install_bundle ( bundle ) . start ( ) <NEWLINE> except pelix . constants . BundleException as ex : <NEWLINE> session . write_line ( <STRING> , bundle , ex ) <NEWLINE> <DEDENT> with use_ipopo ( self . _context ) as ipopo : <NEWLINE> <INDENT> ipopo . instantiate ( <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> { <STRING> : <STRING> } ) <NEWLINE> <DEDENT> ipopo . instantiate ( <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> { <STRING> : <STRING> } ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def render_user_profile__menu ( self , h , comp , * args ) : <NEWLINE> <INDENT> return h . ul ( <NEWLINE> <INDENT> h . li ( <NEWLINE> <INDENT> h . a ( <NEWLINE> <INDENT> entry . label <NEWLINE> class_ = ( <NEWLINE> <INDENT> <STRING> . format ( id_ ) <NEWLINE> if id_ == self . selected <NEWLINE> else id_ <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> ) . action ( self . _on_menu_entry , id_ ) <NEWLINE> <DEDENT> ) <NEWLINE> for id_ , entry in self . menu . iteritems ( ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
class ComponentData : <NEWLINE> <INDENT> def __init__ ( self , componentID , elementID ) : <NEWLINE> self . CadType = <STRING> <NEWLINE> self . CadName = <STRING> <NEWLINE> self . FEAElementType = <STRING> <NEWLINE> self . MaterialID = <STRING> <NEWLINE> self . ComponentID = componentID <NEWLINE> self . ElementID = elementID <NEWLINE> self . FEAResults = dict ( ) <NEWLINE> self . Parts = [ ] <NEWLINE> <DEDENT>
( _ ( <STRING> <NEWLINE> <DEDENT>
class Treenode ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> def __repr__ ( self ) : <NEWLINE> <INDENT> return <STRING> % ( self . id ) <NEWLINE> <DEDENT> <DEDENT>
def digitSum ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> arr [ i ] = n % 10 <NEWLINE> n = n // 10 <NEWLINE> <DEDENT> sum = 0 <NEWLINE> for i in range ( 10 ) <NEWLINE> <INDENT> sum += arr [ i ] <NEWLINE> <DEDENT> return sum <NEWLINE> <DEDENT>
def test_get_assigned_devices_info_multiple_slots ( self , * args ) : <NEWLINE> <INDENT> emb_switch = esm . EmbSwitch ( self . PHYS_NET , self . DEV_NAME , ( ) ) <NEWLINE> with mock . patch ( <STRING> <NEWLINE> <INDENT> <STRING> , <NEWLINE> return_value = self . VF_TO_MAC_MAPPING ) , mock . patch ( <STRING> <NEWLINE> <INDENT> <STRING> , <NEWLINE> return_value = True ) : <NEWLINE> devices_info = emb_switch . get_assigned_devices_info ( ) <NEWLINE> for device_info in devices_info : <NEWLINE> mac = device_info [ 0 ] <NEWLINE> pci_slot = device_info [ 1 ] <NEWLINE> self . assertEqual ( <NEWLINE> self . EXPECTED_MAC_TO_PCI [ mac ] , pci_slot ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def forwards ( self , orm ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for channel in orm . Channel . objects . all ( ) : <NEWLINE> <INDENT> for field in ( <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> value = getattr ( channel , <STRING> % field ) <NEWLINE> if value : <NEWLINE> profile = orm [ <STRING> ] . objects . get ( <NEWLINE> pk = value ) <NEWLINE> setattr ( channel , field , profile . user ) <NEWLINE> else : <NEWLINE> setattr ( channel , field , None ) <NEWLINE> <DEDENT> channel . save ( ) <NEWLINE> <DEDENT> <DEDENT>
def launchHyperlinkButton ( exe = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if exe is None : <NEWLINE> <INDENT> exe = <STRING> % uiaqa_path <NEWLINE> if not exists ( exe ) : <NEWLINE> <INDENT> raise IOError , <STRING> % exe <NEWLINE> <DEDENT> <DEDENT> args = [ firefox_path , exe ] <NEWLINE> ( app , subproc ) = cache . launchApplication ( args = args , name = <STRING> , wait = config . LONG_DELAY ) <NEWLINE> hyperlinkbutton = HyperlinkButton ( app , subproc ) <NEWLINE> cache . addApplication ( hyperlinkbutton ) <NEWLINE> hyperlinkbutton . hyperlinkButtonFrame . app = hyperlinkbutton <NEWLINE> return hyperlinkbutton <NEWLINE> <DEDENT>
class ForExpr ( object ) : <NEWLINE> <INDENT> varInExprs = [ ] <NEWLINE> def __init__ ( self , tokens ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> while ( i < len ( tokens ) : <NEWLINE> <INDENT> self . varInExprs . append ( VarInExpr ( tokens [ i ] , tokens [ i + 2 ] ) ) <NEWLINE> i += 4 <NEWLINE> <DEDENT> <DEDENT> def __repr__ ( self ) : <NEWLINE> <INDENT> return <STRING> + str ( self . varInExprs ) <NEWLINE> <DEDENT> <DEDENT>
def combine_deltas ( self , ( share_count1 , share_hashes1 ) , ( share_count2 , share_hashes2 ) ) : <NEWLINE> <INDENT> if share_hashes1 & share_hashes2 : <NEWLINE> <INDENT> raise AssertionError ( ) <NEWLINE> <DEDENT> return share_count1 + share_count2 , share_hashes1 | share_hashes2 <NEWLINE> <DEDENT>
def retrieve_list ( self ) : <NEWLINE> <INDENT> if Blocked . select ( ) . count ( ) > 0 : <NEWLINE> <INDENT> l = Blocked . select ( ) <NEWLINE> else : <NEWLINE> l = None <NEWLINE> <DEDENT> return l <NEWLINE> <DEDENT>
def test_module_retrieve ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( troveclient . v1 . modules . Module , <STRING> , <NEWLINE> <INDENT> mock . Mock ( return_value = <STRING> ) ) : <NEWLINE> with mock . patch . object ( builtins , <STRING> ) : <NEWLINE> self . run_command ( <STRING> ) <NEWLINE> self . assert_called ( <NEWLINE> <STRING> , <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def read ( self , nbytes = 0 ) : <NEWLINE> <INDENT> if not self . buf : <NEWLINE> <INDENT> if self . __next ( ) is None : <NEWLINE> return <STRING> <NEWLINE> <DEDENT> if nbytes : <NEWLINE> <INDENT> e = self . buf [ : nbytes ] <NEWLINE> self . buf = self . buf [ nbytes : ] <NEWLINE> return e <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e = self . buf <NEWLINE> self . buf = <STRING> <NEWLINE> return e <NEWLINE> <DEDENT> <DEDENT>
def get_ids ( client , what ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> page = 0 <NEWLINE> cursor = - 1 <NEWLINE> idlist = [ ] <NEWLINE> while True : <NEWLINE> page += 1 <NEWLINE> print ( <STRING> % ( what , page ) ) <NEWLINE> result = twlib . twitter_retry ( client , <STRING> , <NEWLINE> path = <STRING> % what , <NEWLINE> params = { <STRING> : str ( cursor ) } ) <NEWLINE> jsn = twlib . parse_json ( result ) <NEWLINE> cursor = jsn [ <STRING> ] <NEWLINE> idlist += jsn [ <STRING> ] <NEWLINE> if cursor == 0 : <NEWLINE> <INDENT> break <NEWLINE> time . sleep ( 1 ) <NEWLINE> <DEDENT> return idlist <NEWLINE> <DEDENT>
class ClientDispatcher ( asyncore . dispatcher_with_send ) : <NEWLINE> <INDENT> def __init__ ( self , ( sock , addr ) ) : <NEWLINE> <INDENT> asyncore . dispatcher_with_send . __init__ ( self , sock ) <NEWLINE> self . addr = addr <NEWLINE> <DEDENT> def handle_read ( self ) : <NEWLINE> <INDENT> data = self . recv ( 1024 ) <NEWLINE> <DEDENT> <DEDENT>
def feed ( self , data ) : <NEWLINE> <INDENT> self . _result = <STRING> <NEWLINE> self . _openelems = [ ] <NEWLINE> data = <STRING> + data + <STRING> <NEWLINE> data = data . replace ( <STRING> , <STRING> ) <NEWLINE> data = iqeq_re . sub ( to_html_minus , data ) <NEWLINE> <INDENT> self . _parser . Parse ( data , 0 ) <NEWLINE> <DEDENT> <DEDENT>
def db_create ( data_path ) : <NEWLINE> <INDENT> import sqlite3 as sql <NEWLINE> conn = sql . connect ( data_path ) <NEWLINE> obj = conn . cursor ( ) <NEWLINE> try : <NEWLINE> <INDENT> obj . executescript ( <STRING> ) <NEWLINE> <DEDENT> except sqlite . DatabaseError , err : <NEWLINE> <INDENT> print ( <STRING> , err ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> conn . commit ( ) <NEWLINE> conn . close ( ) <NEWLINE> <DEDENT>
def generate_security_groups_for_given_count ( user , count ) : <NEWLINE> <INDENT> print <NEWLINE> print ( <STRING> ) <NEWLINE> print <NEWLINE> print ( <STRING> + str ( count ) ) <NEWLINE> print <NEWLINE> group = <STRING> <NEWLINE> for i in xrange ( count ) : <NEWLINE> security_group_name = <STRING> + str ( i ) + <STRING> + str ( int ( time . time ( ) ) ) <NEWLINE> group = user . add_group ( group_name = security_group_name ) <NEWLINE> user . authorize_group ( group ) <NEWLINE> return group <NEWLINE> <DEDENT>
def read ( self , size ) : <NEWLINE> <INDENT> res = <STRING> <NEWLINE> while size > 0 : <NEWLINE> <INDENT> data = self . socket . recv ( size ) <NEWLINE> <INDENT> l = len ( data ) <NEWLINE> <DEDENT> if l == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return res <NEWLINE> <DEDENT> size = size - l <NEWLINE> <INDENT> res = res + data <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <DEDENT>
def read_list ( self , object_list , bundle ) : <NEWLINE> <INDENT> q = Q ( status = <STRING> ) <NEWLINE> if ( hasattr ( bundle . request , <STRING> ) and <NEWLINE> <INDENT> bundle . request . user . is_authenticated ( ) ) : <NEWLINE> if bundle . request . user . is_superuser : <NEWLINE> return object_list <NEWLINE> else : <NEWLINE> q_args = { <NEWLINE> <INDENT> self . owner_field : bundle . request . user <NEWLINE> <DEDENT> } <NEWLINE> q = q | Q ( ** q_args ) <NEWLINE> <DEDENT> return object_list . filter ( q ) <NEWLINE> <DEDENT>
def fastFree ( params , cwd ) : <NEWLINE> <INDENT> param = params [ <STRING> ] <NEWLINE> <INDENT> p15 = open ( param , <STRING> ) <NEWLINE> m1 = <STRING> <NEWLINE> m2 = grep ( m1 , p15 ) <NEWLINE> m3 = m2 . split ( ) <NEWLINE> num_mod = int ( m3 [ 2 ] ) <NEWLINE> <DEDENT> mod = 1 <NEWLINE> while mod <= num_mod : <NEWLINE> <INDENT> mod = mod - 1 <NEWLINE> iteration = fastFree_run ( params , cwd , mod ) <NEWLINE> wait ( params , iteration ) <NEWLINE> mod = mod + 2 <NEWLINE> <DEDENT> <DEDENT>
def get_floating_ip ( self , context , id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return dict ( floating_ip_obj . FloatingIP . get_by_id ( <NEWLINE> <INDENT> context , id ) . iteritems ( ) <NEWLINE> <DEDENT> <DEDENT>
def retranslateUi ( self , ItemProperties ) : <NEWLINE> <INDENT> ItemProperties . setWindowTitle ( QtWidgets . QApplication . translate ( <STRING> , <STRING> , None , QtWidgets . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . label . setText ( QtWidgets . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def readHumidity ( ) : <NEWLINE> <INDENT> global DHT11_PIN , humidity <NEWLINE> try : <NEWLINE> <INDENT> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> dht11var = dht11driver . DHT11 ( pin = DHT11_PIN ) <NEWLINE> result = dht11var . read ( ) <NEWLINE> if result . is_valid ( ) : <NEWLINE> humidity = int ( result . humidity ) <NEWLINE> break <NEWLINE> count += 1 <NEWLINE> if count > 10 : <NEWLINE> break <NEWLINE> time . sleep ( 1 ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
def enumerateVRFY ( self , accounts , processes ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not self . vrfy_available : <NEWLINE> return [ ] <NEWLINE> accounts_input = multiprocessing . Manager ( ) . list ( ) <NEWLINE> accounts_input . extend ( accounts ) <NEWLINE> accounts_output = multiprocessing . Manager ( ) . list ( ) <NEWLINE> m_pool = multiprocessing . Pool ( processes ) <NEWLINE> for p in range ( processes ) : <NEWLINE> m_pool . apply_async ( enumerateVRFYWorker , ( self . host , self . port , self . domain , accounts_input , accounts_output ) ) <NEWLINE> m_pool . close ( ) <NEWLINE> m_pool . join ( ) <NEWLINE> return accounts_output <NEWLINE> <DEDENT>
def _match_profile_for_kernel_base ( self , kernel_base , test_as ) : <NEWLINE> <INDENT> threshold = self . session . GetParameter ( <STRING> ) <NEWLINE> for profile , match in self . nt_index . LookupIndex ( <NEWLINE> <INDENT> kernel_base , address_space = test_as ) : <NEWLINE> if match < threshold : <NEWLINE> break <NEWLINE> profile_obj = self . session . LoadProfile ( profile ) <NEWLINE> if profile_obj : <NEWLINE> return profile_obj <NEWLINE> <DEDENT> <DEDENT>
def fake_quals ( fa ) : <NEWLINE> <INDENT> faq = fa . rsplit ( <STRING> , 1 ) [ 0 ] + <STRING> <NEWLINE> if op . exists ( faq ) : <NEWLINE> <INDENT> logging . debug ( <STRING> . format ( faq ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sh ( <STRING> . format ( fa , faq ) <NEWLINE> <DEDENT> return fa , faq <NEWLINE> <DEDENT>
class ORCIDSerializer ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def serialize ( self , pid , record , links_factory = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return json . dumps ( convert_to_orcid ( record . dumps ( ) ) ) <NEWLINE> <DEDENT> def serialize_search ( self , pid_fetcher , search_result , links = None , <NEWLINE> <INDENT> item_links_factory = None ) : <NEWLINE> <STRING> <NEWLINE> records = [ ] <NEWLINE> for hit in search_result [ <STRING> ] [ <STRING> ] : <NEWLINE> records . append ( json . dumps ( ( convert_to_orcid ( hit [ <STRING> ] ) ) ) ) <NEWLINE> return <STRING> . join ( records ) <NEWLINE> <DEDENT> <DEDENT>
def get_angle_from_coordinates ( ( x1 , y1 ) , ( x2 , y2 ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if y1 == y2 : <NEWLINE> <INDENT> if x2 > x1 : return 0 <NEWLINE> else : return 180 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if y2 > y1 : return 270 <NEWLINE> else : return 90 <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , display ) : <NEWLINE> <INDENT> self . _display = display <NEWLINE> if self . _display . verbosity >= 4 : <NEWLINE> <INDENT> name = getattr ( self , <STRING> , <STRING> ) <NEWLINE> ctype = getattr ( self , <STRING> , <STRING> ) <NEWLINE> version = getattr ( self , <STRING> , <STRING> ) <NEWLINE> self . _display . vvvv ( <STRING> % ( name , ctype , version ) <NEWLINE> <DEDENT> <DEDENT>
import utils <NEWLINE> SEVERITY_FINE = 1 <NEWLINE> SEVERITY_WARNING = 2 <NEWLINE> SEVERITY_ERROR = 3 <NEWLINE> STR_SEVERITY = { <NEWLINE> <INDENT> SEVERITY_FINE : <STRING> <NEWLINE> SEVERITY_WARNING : <STRING> <NEWLINE> SEVERITY_ERROR : <STRING> <NEWLINE> <DEDENT> } <NEWLINE> LOG_TEMPLATE = <STRING> <NEWLINE>
( <STRING> <NEWLINE> <DEDENT>
def color_water ( imask ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> count = 2 <NEWLINE> Mp , Lp = imask . shape <NEWLINE> for j in range ( 1 , Mp - 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , Lp - 1 ) : <NEWLINE> if ( imask [ j , i ] == 1 ) : <NEWLINE> <DEDENT> flood_fill_water ( imask , i , j , count ) <NEWLINE> <INDENT> warning ( <STRING> , i , j ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> warning ( <STRING> , count - 2 , <STRING> ) <NEWLINE> return count - 2 <NEWLINE> <DEDENT>
def test_get_local_port_mac_raises_exception_for_missing_mac ( self ) : <NEWLINE> <INDENT> with mock . patch ( <STRING> , <NEWLINE> <INDENT> return_value = mock . Mock ( address = None ) ) : <NEWLINE> with testtools . ExpectedException ( Exception ) : <NEWLINE> self . br . get_local_port_mac ( ) <NEWLINE> <DEDENT> <DEDENT>
def __eq__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == type ( self ) <NEWLINE> <INDENT> return ( abs ( self . t0 == other . t0 ) < 1e-15 ) and ( abs ( self . t1 == other . t1 ) < 1e-15 ) and ( self . n_step == other . n_step ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise ValueError <NEWLINE> <DEDENT> <DEDENT>
class InsertionSort ( SortAlgorithm ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def sort ( self , data ) : <NEWLINE> <INDENT> for i in range ( 1 , len ( data ) : <NEWLINE> <INDENT> k = i <NEWLINE> while k > 0 and data [ k ] < data [ k - 1 ] : <NEWLINE> <INDENT> self . swap ( data , k , k - 1 ) <NEWLINE> k -= 1 <NEWLINE> <DEDENT> <DEDENT> return data <NEWLINE> <DEDENT> <DEDENT>
def step ( context ) : <NEWLINE> <INDENT> from numpy import all , abs , identity <NEWLINE> for survivor , qmatrix , value in zip ( context . survivors , context . qmatrices , <NEWLINE> <INDENT> context . survivor_values ) : <NEWLINE> try : <NEWLINE> assert all ( abs ( value - identity ( value . shape [ 0 ] ) ) < context . tolerance ) <NEWLINE> except : <NEWLINE> print ( survivor ) <NEWLINE> print ( qmatrix ) <NEWLINE> raise <NEWLINE> <DEDENT> <DEDENT>
def get_good_peers ( self , max_count ) : <NEWLINE> <INDENT> t = time . time ( ) <NEWLINE> return [ x [ 0 ] for x in sorted ( self . addr_store . iteritems ( ) , key = lambda ( k , ( services , first_seen , last_seen ) ) : <NEWLINE> <INDENT> - math . log ( max ( 3600 , last_seen - first_seen ) ) / math . log ( max ( 3600 , t - last_seen ) ) * random . expovariate ( 1 ) <NEWLINE> <DEDENT> ) ] [ : max_count ] <NEWLINE> <DEDENT>
def raise_if_not_int_vector2 ( v ) : <NEWLINE> <INDENT> if not isinstance ( v , numpy . ndarray ) : <NEWLINE> <INDENT> raise ValueError ( <STRING> . format ( <NEWLINE> <INDENT> v , repr ( v ) , type ( v ) ) ) <NEWLINE> <DEDENT> <DEDENT> if not numpy . issubdtype ( v . dtype . type , numpy . integer ) : <NEWLINE> <INDENT> raise ValueError ( <STRING> . format ( v , v . dtype ) <NEWLINE> <DEDENT> <DEDENT>
def rename_combining ( seq ) : <NEWLINE> <INDENT> filtered_sequence = [ ] <NEWLINE> for ks in seq : <NEWLINE> <INDENT> if findall ( <STRING> , ks ) : <NEWLINE> <INDENT> ks = sub ( <STRING> , <STRING> , ks ) <NEWLINE> <INDENT> if ks == <STRING> : <NEWLINE> <INDENT> ks = <STRING> <NEWLINE> <DEDENT> if ks == <STRING> : <NEWLINE> <INDENT> ks = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> filtered_sequence . append ( ks ) <NEWLINE> <DEDENT> return filtered_sequence <NEWLINE> <DEDENT>
def containsDigitAndSlashOperator ( form ) : <NEWLINE> <INDENT> if re . match ( <STRING> , form ) : <NEWLINE> <INDENT> return [ int ( True ) ] <NEWLINE> else : <NEWLINE> return [ int ( False ) ] <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , name , , cfg , paths ) : <NEWLINE> <INDENT> distros . Distro . __init__ ( self , name , cfg , paths ) <NEWLINE> self . _runner = helpers . Runners ( paths ) <NEWLINE> self . osfamily = <STRING> <NEWLINE> <DEDENT>
def _check_imt ( self , imt ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not issubclass ( type ( imt ) , imt_module . _IMT ) : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> if not type ( imt ) in self . DEFINED_FOR_INTENSITY_MEASURE_TYPES : <NEWLINE> <INDENT> raise ValueError ( <STRING> % <NEWLINE> <INDENT> ( type ( imt ) . __name__ , type ( self ) . __name__ ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def sendScript ( self , string ) : <NEWLINE> <INDENT> warnings . warn ( <NEWLINE> <INDENT> <STRING> <NEWLINE> DeprecationWarning , <NEWLINE> 2 ) <NEWLINE> <DEDENT> self . send ( string ) <NEWLINE> <DEDENT>
def testOverrideFlavor ( self ) : <NEWLINE> <INDENT> def override ( flavor1 , flavor2 ) : <NEWLINE> <INDENT> return overrideFlavor ( parseFlavor ( flavor1 ) , <NEWLINE> <INDENT> parseFlavor ( flavor2 ) . freeze ( ) <NEWLINE> <DEDENT> <DEDENT> assert ( override ( <STRING> , <STRING> ) == <STRING> ) <NEWLINE> foo = override ( <STRING> , <STRING> ) <NEWLINE> assert ( override ( <STRING> , <STRING> ) == <STRING> ) <NEWLINE> <DEDENT>
def retranslateUi ( self , DlgAbout ) : <NEWLINE> <INDENT> DlgAbout . setWindowTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . btnClose . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . txtAbout . setHtml ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def _shareLease ( self , dstImgPath ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . log . debug ( <STRING> , self . volUUID <NEWLINE> <INDENT> dstImgPath ) <NEWLINE> <DEDENT> dstLeasePath = self . _getLeaseVolumePath ( <NEWLINE> <INDENT> os . path . join ( dstImgPath , self . volUUID ) ) <NEWLINE> <DEDENT> self . oop . utils . forceLink ( self . _getLeaseVolumePath ( ) , dstLeasePath ) <NEWLINE> <DEDENT>
class Player ( Thread ) : <NEWLINE> <INDENT> def __init__ ( self , startX , startY , player ) : <NEWLINE> self . fd = open ( config . STASH_PATH + player + <STRING> , <STRING> ) <NEWLINE> self . playerStash = mmap . mmap ( self . fd . fileno ( ) , 0 ) <NEWLINE> self . player = getattr ( imp . load_source ( player , config . PLAYER_PATH + player + <STRING> ) , <STRING> ) ( startX , startY , self . playerStash ) <NEWLINE> self . fd . close ( ) <NEWLINE> <DEDENT>
def resolve_name ( tokens , id , args ) : <NEWLINE> <INDENT> if id in map ( lambda x : x [ 0 ] , tokens ) : <NEWLINE> if args : <NEWLINE> <INDENT> print ( <STRING> % ( id , args ) ) <NEWLINE> <INDENT> return Terminal ( id ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return NonTerminal ( id , args ) <NEWLINE> <DEDENT> <DEDENT>
class DebugSWFilter ( BaseSWFilter ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> __logger = logging . getLogger ( __name__ ) <NEWLINE> def aggregate_windows ( self , <NEWLINE> <INDENT> window_seq , <NEWLINE> if_index = None , <NEWLINE> true_factor = 1 , <NEWLINE> true_summand = 0 , <NEWLINE> false_factor = 1 , <NEWLINE> false_summand = 0 , <NEWLINE> ** kwargs ) : <NEWLINE> <STRING> <NEWLINE> for window in window_seq : <NEWLINE> for win_index , win_item in enumerate ( window ) : <NEWLINE> if if_index == win_index : <NEWLINE> yield true_factor * win_item + true_summand <NEWLINE> else : <NEWLINE> yield false_factor * win_item + false_summand <NEWLINE> <DEDENT> <DEDENT>
( 0 <NEWLINE> <DEDENT>
def add_known_arguments ( self , parser ) : <NEWLINE> <INDENT> parser . add_argument ( <NEWLINE> <INDENT> <STRING> , metavar = <STRING> , <NEWLINE> help = _ ( <STRING> ) ) <NEWLINE> <DEDENT> parser . add_argument ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> help = _ ( <STRING> ) ) , <NEWLINE> <DEDENT> parser . add_argument ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> help = _ ( <STRING> ) ) , <NEWLINE> <DEDENT> parser . add_argument ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> help = _ ( <STRING> ) ) , <NEWLINE> <DEDENT> parser . add_argument ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> default = False , <NEWLINE> help = _ ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
def showColorWellUI ( ) : <NEWLINE> <INDENT> global dialog <NEWLINE> if dialog is not None : <NEWLINE> dialog . enter ( ) <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> dialog = ColorWellDialog ( ) <NEWLINE> <DEDENT>
def reset ( self ) : <NEWLINE> <INDENT> self . token = None <NEWLINE> self . unary_operators = <STRING> <NEWLINE> self . binary_operators = frozenset ( [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> self . tokenizer = Tokenizer ( ) <NEWLINE> self . token_generator = None <NEWLINE> self . tree = Treebuilder ( DataNode ( None ) <NEWLINE> self . expr_builder = None <NEWLINE> self . expr_builders = [ ] <NEWLINE> <DEDENT>
def new_figure_manager ( num , * args , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if _debug : <NEWLINE> <INDENT> print <STRING> % fn_name ( ) <NEWLINE> <DEDENT> FigureClass = kwargs . pop ( <STRING> , Figure ) <NEWLINE> thisFig = FigureClass ( * args , ** kwargs ) <NEWLINE> canvas = FigureCanvasGTKCairo ( thisFig ) <NEWLINE> return FigureManagerGTK ( canvas , num ) <NEWLINE> <DEDENT>
def mpc_cos_pi ( ( a , b ) , prec , rnd = round_fast ) : <NEWLINE> <INDENT> b = mpf_mul ( b , mpf_pi ( prec + 5 ) , prec + 5 ) <NEWLINE> if a == fzero : <NEWLINE> <INDENT> return mpf_cosh ( b , prec , rnd ) , fzero <NEWLINE> <DEDENT> wp = prec + 6 <NEWLINE> c , s = mpf_cos_sin_pi ( a , wp ) <NEWLINE> ch , sh = cosh_sinh ( b , wp ) <NEWLINE> re = mpf_mul ( c , ch , prec , rnd ) <NEWLINE> im = mpf_mul ( s , sh , prec , rnd ) <NEWLINE> return re , mpf_neg ( im ) <NEWLINE> <DEDENT>
def _get_consumer ( self , session , consumer_id ) : <NEWLINE> <INDENT> consumer_ref = session . query ( Consumer ) . get ( consumer_id ) <NEWLINE> if consumer_ref is None : <NEWLINE> <INDENT> raise exception . NotFound ( _ ( <STRING> % consumer_id ) <NEWLINE> <DEDENT> return consumer_ref <NEWLINE> <DEDENT>
def with_right_justify ( ) : <NEWLINE> <INDENT> with progressbar . ProgressBar ( max_value = range_count , term_width = 20 , <NEWLINE> <INDENT> left_justify = False ) as progress : <NEWLINE> assert progress . term_width is not None <NEWLINE> for i in range ( range_count ) : <NEWLINE> del_from_list ( ) <NEWLINE> progress . update ( i ) <NEWLINE> <DEDENT> <DEDENT>
def get_ssaname ( self , varname , line ) : <NEWLINE> <INDENT> if vim . current . buffer . name == None : <NEWLINE> <INDENT> raise AnnExc ( <STRING> ) <NEWLINE> <DEDENT> if vim . current . buffer . name != self . filename or os . stat ( self . filename ) . st_mtime > self . timestamp : <NEWLINE> filename = self . filename <NEWLINE> self . parse ( filename ) <NEWLINE> ssaname = varname <NEWLINE> try : <NEWLINE> <INDENT> ssaname = self . annot [ ( str ( varname ) , int ( line ) ) ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> return ssaname <NEWLINE> <DEDENT>
def Warn ( self , msg ) : <NEWLINE> <INDENT> if GetOption ( <STRING> ) : print <STRING> % msg <NEWLINE> self . warns . append ( msg ) <NEWLINE> <DEDENT>
def handle_data ( self , command = None , payload = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> method_name = <STRING> % command <NEWLINE> if command and hasattr ( self , method_name ) and callable ( getattr ( self , method_name ) : <NEWLINE> <INDENT> return getattr ( self , method_name ) ( payload ) <NEWLINE> <DEDENT> <DEDENT>
def write ( self , text , * args ) : <NEWLINE> <INDENT> newArgs = [ ] <NEWLINE> for arg in args : <NEWLINE> <INDENT> try : <NEWLINE> arg = arg . sourceString ( ) <NEWLINE> except ( TypeError ) : <NEWLINE> arg = arg <NEWLINE> newArgs . append ( arg ) <NEWLINE> <DEDENT> if self . startLine : <NEWLINE> <INDENT> self . text . append ( self . indent * self . indentation ) <NEWLINE> self . startLine = 0 <NEWLINE> <DEDENT> if len ( args ) > 0 : <NEWLINE> <INDENT> text = text % tuple ( newArgs ) <NEWLINE> <DEDENT> self . text . append ( text ) <NEWLINE> <DEDENT>
def getTiposEvaluacion ( ) : <NEWLINE> <INDENT> tipos = [ ] <NEWLINE> for tipo in rs1 . find ( <NEWLINE> <INDENT> <STRING> , { <STRING> : <STRING> } <NEWLINE> <INDENT> ) . find_all ( <STRING> ) : <NEWLINE> if tipo [ <STRING> ] . isdigit ( ) : <NEWLINE> tipos . append ( [ tipo [ <STRING> ] , tipo [ <STRING> ] ] ) <NEWLINE> <DEDENT> <DEDENT> return tipos <NEWLINE> <DEDENT>
class XmlEventDebug : <NEWLINE> <INDENT> def start ( self , tag , attrib ) : print <STRING> % tag , <NEWLINE> def end ( self , tag ) : <NEWLINE> <INDENT> print <STRING> % tag , <NEWLINE> <DEDENT> def data ( self , data ) : <NEWLINE> <INDENT> print ( data . encode ( <STRING> , <STRING> ) , ) <NEWLINE> <DEDENT> def close ( self ) : pass <NEWLINE> <DEDENT>
def test_sinkstate_callable ( self ) : <NEWLINE> <INDENT> def spam ( state = [ 0 ] ) : <NEWLINE> <INDENT> i = state [ 0 ] <NEWLINE> state [ 0 ] = i + 1 <NEWLINE> if i == 10 : <NEWLINE> <INDENT> raise AssertionError , <STRING> <NEWLINE> <DEDENT> return i <NEWLINE> <DEDENT> b = iter ( spam , 5 ) <NEWLINE> self . assertEqual ( list ( b ) , range ( 5 ) ) <NEWLINE> self . assertEqual ( list ( b ) , [ ] ) <NEWLINE> <DEDENT>
def myi2cWriteBlock ( bus , addr , addr2 , data ) : <NEWLINE> <INDENT> try : <NEWLINE> bus . write_i2c_block_data ( addr , addr2 , data ) <NEWLINE> return 1 <NEWLINE> except : <NEWLINE> <INDENT> print ( <STRING> , hex ( addr ) , <STRING> , hex ( addr2 ) , <STRING> , hex ( data [ 0 ] ) ) <NEWLINE> return 0 <NEWLINE> <DEDENT> <DEDENT>
def initialize_options ( self ) : <NEWLINE> <INDENT> self . podir = <STRING> <NEWLINE> self . msgmerge = <STRING> <NEWLINE> self . options = Options ( ) <NEWLINE> <INDENT> self . escape = 0 <NEWLINE> self . width = 78 <NEWLINE> <DEDENT> self . extract_all = 0 <NEWLINE> self . default_domain = None <NEWLINE> self . keyword = None <NEWLINE> self . no_default_keywords = 0 <NEWLINE> self . no_location = 0 <NEWLINE> self . style = None <NEWLINE> self . output = None <NEWLINE> self . output_dir = None <NEWLINE> <INDENT> self . docstrings = 0 <NEWLINE> <DEDENT> self . exclude_file = None <NEWLINE> <INDENT> self . all_linguas = [ ] <NEWLINE> <DEDENT> <DEDENT>
def merge ( taxonomy_1 , taxonomy_2 , alignment_graph , rename = ( <STRING> , <STRING> ) : <NEWLINE> <INDENT> union_graph = nx . union ( taxonomy_1 , taxonomy_2 , rename = rename ) <NEWLINE> merge_graph = nx . compose ( union_graph , alignment_graph ) <NEWLINE> return merge_graph <NEWLINE> <DEDENT>
class Flag1 ( smach . State ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> smach . State . __init__ ( self , outcomes = [ <STRING> , <STRING> ] ) <NEWLINE> <DEDENT> def execute ( self , userdata ) : <NEWLINE> global receivedflag1 <NEWLINE> receivedflag1 = 0 <NEWLINE> rospy . sleep ( 0.001 ) <NEWLINE> rospy . Subscriber ( <STRING> , Int8 , callback1 ) <NEWLINE> if receivedflag1 == 1 : <NEWLINE> global start <NEWLINE> start = time . time ( ) <NEWLINE> receivedflag1 = 0 <NEWLINE> return <STRING> <NEWLINE> <INDENT> else : <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <DEDENT>
def all_active ( user ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> db_session . query ( UserFeeds ) . filter_by ( userid = user . id ) . update ( <NEWLINE> <INDENT> { <NEWLINE> <INDENT> <STRING> : True <NEWLINE> <DEDENT> } ) <NEWLINE> <DEDENT> db_session . commit ( ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> logger . exception ( <STRING> ) <NEWLINE> db_session . rollback ( ) <NEWLINE> <DEDENT> <DEDENT>
def _render_status_text ( self , name , status ) : <NEWLINE> <INDENT> if not name : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> <DEDENT> return <STRING> % ( utf8 ( name ) , utf8 ( status ) <NEWLINE> <DEDENT>
def displayBufferOnScreen ( screen , font , buff ) : <NEWLINE> <INDENT> if ( buff == <STRING> ) : <NEWLINE> color = const . COLOR_BLACK <NEWLINE> else : <NEWLINE> color = const . COLOR_WHITE <NEWLINE> pygame . draw . rect ( screen , color , pygame . rect . Rect ( 0 , 0 , 800 , 100 ) ) <NEWLINE> screen . blit ( font . render ( buff , 0 , ( 0 , 0 , 0 ) ) , ( 10 , 10 ) ) <NEWLINE> <DEDENT>
def runningAsOSXApp ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> global _appbundle <NEWLINE> if _appbundle is None <NEWLINE> <INDENT> _appbundle = ( sys . platform == <STRING> and <STRING> in sys . executable ) <NEWLINE> <DEDENT> return _appbundle <NEWLINE> <DEDENT>
def anagrams_for ( word ) : <NEWLINE> <INDENT> word_array = array ( <STRING> , word ) <NEWLINE> [ print new_word . tobytes ( ) <NEWLINE> <INDENT> for new_word in <NEWLINE> <INDENT> list ( itertools . permutations ( word_array , word_array . length ) ) <NEWLINE> if new_word in <NEWLINE> <INDENT> words . words ( ) ) ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def __import ( importCommand , importCommand2 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> exec importCommand <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> exec importCommand2 <NEWLINE> <DEDENT> <DEDENT>
def log ( level , s ) : <NEWLINE> <INDENT> if level > DEBUG : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> print ( s . encode ( <STRING> ) ) <NEWLINE> <INDENT> print ( time . strftime ( <STRING> ) + <STRING> % ( <NEWLINE> os . getpid ( ) , <NEWLINE> s ) ) . encode ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from django . conf . urls import url , include <NEWLINE> from django . contrib import admin <NEWLINE> urlpatterns = [ <NEWLINE> <INDENT> url ( <STRING> , admin . site . urls ) , <NEWLINE> url ( <STRING> , include ( <STRING> ) ) ) , <NEWLINE> url ( <STRING> , include ( <STRING> ) ) , <NEWLINE> <DEDENT> ] <NEWLINE>
def PatternPwd ( pattern ) : <NEWLINE> <INDENT> newpasswd = <STRING> <NEWLINE> for i in range ( len ( pattern ) ) : <NEWLINE> if pattern [ i ] == <STRING> : <NEWLINE> <INDENT> chars = string . ascii_lowercase <NEWLINE> <INDENT> newpasswd = newpasswd + choice ( chars ) <NEWLINE> if pattern [ i ] == <STRING> : <NEWLINE> <DEDENT> chars = string . ascii_uppercase <NEWLINE> <INDENT> newpasswd = newpasswd + choice ( chars ) <NEWLINE> if pattern [ i ] == <STRING> : <NEWLINE> <DEDENT> chars = string . digits <NEWLINE> <INDENT> newpasswd = newpasswd + choice ( chars ) <NEWLINE> <DEDENT> <DEDENT> return newpasswd <NEWLINE> <DEDENT>
def commit ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> with open ( self . fname , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( str ( self . _second ) ) <NEWLINE> <DEDENT> <DEDENT> except OSError , e : <NEWLINE> <INDENT> CONSUMER_LOG . exception ( <NEWLINE> <INDENT> <STRING> % ( <NEWLINE> <INDENT> self . fname , str ( e ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def return_ball ( self , ball ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ball in self . balls_on_table ( ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for p in self . players . values ( ) <NEWLINE> <INDENT> if ball in p . init_balls : <NEWLINE> <INDENT> p . balls . append ( ball ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> self . unclaimed_balls . balls . append ( ball ) <NEWLINE> <DEDENT> <DEDENT>
def post ( self , id = None ) : <NEWLINE> <INDENT> if self . acl_write_check ( ) : <NEWLINE> <INDENT> self . bundle = self . model ( ) <NEWLINE> self . bundle [ <STRING> ] = str ( ObjectId ( id ) ) <NEWLINE> self . preprocess_bundle ( ) <NEWLINE> setattrs = self . set_attrs ( ) <NEWLINE> if setattrs . get ( <STRING> ) == 200 : <NEWLINE> return self . save_bundle ( ) <NEWLINE> else : <NEWLINE> return bundle_400 ( setattrs . get ( <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return action_401 ( ) <NEWLINE> <DEDENT> <DEDENT>
def requestNextWeek ( curWeek ) : <NEWLINE> <INDENT> url_planning = self . url + <STRING> <NEWLINE> next_WeekData = { <STRING> : <STRING> , <STRING> : self . viewState } <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class ExtraTreeClassifier ( DecisionTreeClassifier ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , <NEWLINE> <INDENT> criterion = <STRING> , <NEWLINE> max_depth = None , <NEWLINE> min_samples_split = 2 , <NEWLINE> min_samples_leaf = 1 , <NEWLINE> min_density = 0.1 , <NEWLINE> max_features = <STRING> , <NEWLINE> compute_importances = False , <NEWLINE> random_state = None ) : <NEWLINE> super ( ExtraTreeClassifier , self ) . __init__ ( criterion , <NEWLINE> <INDENT> max_depth , <NEWLINE> min_samples_split , <NEWLINE> min_samples_leaf , <NEWLINE> min_density , <NEWLINE> max_features , <NEWLINE> compute_importances , <NEWLINE> random_state ) <NEWLINE> self . find_split_ = _tree . TREE_SPLIT_RANDOM <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def random_key ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> random_key = self . redis_client . randomkey ( ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> return str ( e ) <NEWLINE> <DEDENT> return random_key <NEWLINE> <DEDENT>
def post ( self , request , * args , ** kwargs ) : <NEWLINE> <INDENT> if self . game . status == <STRING> : <NEWLINE> <INDENT> self . player = get_object_or_404 ( Player , game = self . game , active = True , user = request . user ) <NEWLINE> if not self . player . lead_zombie : <NEWLINE> <INDENT> raise PermissionDenied <NEWLINE> <DEDENT> return super ( SendZombieText , self ) . post ( request , * args , ** kwargs ) <NEWLINE> else : <NEWLINE> raise PermissionDenied <NEWLINE> <DEDENT> <DEDENT>
def timer ( ) : <NEWLINE> <INDENT> global t0 <NEWLINE> for c in clients : <NEWLINE> <INDENT> t = time . time ( ) - t0 <NEWLINE> print ( t0 ) <NEWLINE> c . write_message ( json . dumps ( { <STRING> : t , <STRING> : 0 , <STRING> : math . sin ( t ) * 0 , <STRING> : 0 * math . sin ( t ) , <STRING> : math . sin ( t ) * 5 , <STRING> : math . cos ( t ) * 5 , <STRING> : 0 , <STRING> : <STRING> } ) <NEWLINE> <DEDENT> <DEDENT>
def check_iteration ( self , tko_iterations , pb_iterations ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for tko_iteration , pb_iteration in zip ( tko_iterations , <NEWLINE> <INDENT> pb_iterations ) : <NEWLINE> self . assertEqual ( tko_iteration . index , pb_iteration . index ) <NEWLINE> self . check_dict ( tko_iteration . attr_keyval , <NEWLINE> self . convert_keyval_to_dict ( pb_iteration , <NEWLINE> <INDENT> <STRING> ) ) <NEWLINE> self . check_dict ( tko_iteration . perf_keyval , <NEWLINE> self . convert_keyval_to_dict ( pb_iteration , <NEWLINE> <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class DummyModelTestCase ( TestCase ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def setUp ( self ) : <NEWLINE> def test_model ( self ) : <NEWLINE> <INDENT> self . assertTrue ( True ) <NEWLINE> <DEDENT> <DEDENT>
def write ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . log_file is not None : <NEWLINE> <INDENT> for data_type in self . data : <NEWLINE> <INDENT> with open ( <STRING> . format ( self . data_dir , self . log_file , <NEWLINE> <INDENT> data_type ) , <STRING> ) as f : <NEWLINE> for data in self . data [ data_type ] : <NEWLINE> f . write ( data + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def read_maps ( self , db ) : <NEWLINE> <INDENT> for row in db . conn . execute ( <NEWLINE> <INDENT> <STRING> . format ( <NEWLINE> <INDENT> self . metadata [ <STRING> ] , self . link_table ) ) : <NEWLINE> if row [ 1 ] not in self . col_book_map : <NEWLINE> <DEDENT> self . col_book_map [ row [ 1 ] ] = set ( ) <NEWLINE> self . col_book_map [ row [ 1 ] ] . add ( row [ 0 ] ) <NEWLINE> self . book_col_map [ row [ 0 ] ] = row [ 1 ] <NEWLINE> <DEDENT> <DEDENT>
def queue_edit ( quality , imdb_id = None , tmdb_id = None , session = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> item = session . query ( QueuedMovie ) . filter ( QueuedMovie . imdb_id == imdb_id ) . one ( ) <NEWLINE> item . quality = quality <NEWLINE> return item . title <NEWLINE> <DEDENT> except NoResultFound as e : <NEWLINE> <INDENT> raise QueueError ( <STRING> % ( imdb_id , tmdb_id ) <NEWLINE> <DEDENT> <DEDENT>
def __str__ ( self ) : <NEWLINE> <INDENT> str = [ <STRING> % self . axesOri , <NEWLINE> <INDENT> <STRING> % <NEWLINE> self . __axesOriName [ self . __axesOri [ self . _axesOri ] ] <NEWLINE> <STRING> % self . bearingOri ] <NEWLINE> <DEDENT> return <STRING> . join ( str ) <NEWLINE> <DEDENT>
for aaa in range ( 0 , 10 ) : <NEWLINE> for bbb in range ( 0.0 , 10.0 ) : <NEWLINE>
def add_commit ( repo , path ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> repo . git . add ( path ) <NEWLINE> repo . git . commit ( m = <STRING> . format ( path ) <NEWLINE> <DEDENT>
def get_source_version ( source_root ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> with open ( os . path . join ( source_root , <STRING> ) ) as f : <NEWLINE> <INDENT> version = f . readline ( ) . strip ( ) <NEWLINE> <DEDENT> <DEDENT> except ( IOError , OSError ) , e : <NEWLINE> <INDENT> abort ( <STRING> % source_root , e ) <NEWLINE> <DEDENT> assert version is not None <NEWLINE> return version <NEWLINE> <DEDENT>
def run ( self , option_dict = None ) : <NEWLINE> <INDENT> cmd = [ self . executable ] <NEWLINE> if option_dict : <NEWLINE> <INDENT> for key , value in option_dict . items ( ) : <NEWLINE> value = option_dict [ key ] <NEWLINE> self . opt_dict [ key ] = value <NEWLINE> <DEDENT> for key , value in self . opt_dict . items ( ) : <NEWLINE> <INDENT> cmd . extend ( [ key , value ] ) <NEWLINE> <INDENT> if self . running : <NEWLINE> <INDENT> self . stop ( ) <NEWLINE> <DEDENT> self . running = True <NEWLINE> <DEDENT> <DEDENT> self . child = Popen ( cmd ) <NEWLINE> return self . child <NEWLINE> <DEDENT>
class ConfigOption : <NEWLINE> <INDENT> def __init__ ( self , name , default_value = None , required = False , <NEWLINE> <INDENT> description = None , data_type = None ) : <NEWLINE> self . name = name <NEWLINE> self . default_value = default_value <NEWLINE> self . required = required <NEWLINE> self . description = description <NEWLINE> if data_type is None and self . default_value is not None : <NEWLINE> self . data_type = type ( self . default_value ) <NEWLINE> elif data_type is None : <NEWLINE> self . data_type = str <NEWLINE> else : <NEWLINE> self . data_type = data_type <NEWLINE> <DEDENT> <DEDENT>
class Monitor : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . exit = False <NEWLINE> <DEDENT> def __del__ ( self ) : <NEWLINE> return <NEWLINE> def waitForAbort ( self , t ) : <NEWLINE> <INDENT> if self . exit : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> time . sleep ( t ) <NEWLINE> return False <NEWLINE> <DEDENT> def setAbort ( self ) : <NEWLINE> <INDENT> self . exit = True <NEWLINE> <DEDENT> <DEDENT>
def voidresp ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> resp = self . getresp ( ) <NEWLINE> if resp [ : 1 ] != <STRING> : <NEWLINE> <INDENT> raise error_reply , resp <NEWLINE> <DEDENT> return resp <NEWLINE> <DEDENT>
def main ( ) <NEWLINE> <INDENT> configuration = Configuration ( ) <NEWLINE> options = parse_command_line ( configuration ) <NEWLINE> send_message ( options , configuration ) <NEWLINE> <DEDENT>
class LoggingReceiver ( SocketServer . ThreadingTCPServer ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> logname = None <NEWLINE> def __init__ ( self , host = <STRING> , <NEWLINE> <INDENT> port = None , <NEWLINE> handler = LogRecordStreamHandler ) : <NEWLINE> if port is None : <NEWLINE> port = logging . handlers . DEFAULT_TCP_LOGGING_PORT <NEWLINE> SocketServer . ThreadingTCPServer . __init__ ( self , ( host , port ) , handler ) <NEWLINE> <DEDENT> <DEDENT>
def GetRawCharFunction ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for get_raw_char_function in ( _GetRawCharFunctionPosix , <NEWLINE> <INDENT> _GetRawCharFunctionWindows ) : <NEWLINE> try : <NEWLINE> return get_raw_char_function ( ) <NEWLINE> except : <NEWLINE> pass <NEWLINE> <DEDENT> return lambda : None <NEWLINE> <DEDENT>
def setUp ( self ) : <NEWLINE> <INDENT> wiki = WikiPage ( self . env ) <NEWLINE> wiki . name = <STRING> <NEWLINE> wiki . text = <STRING> <NEWLINE> wiki . save ( <STRING> , <STRING> , <STRING> , datetime . now ( utc ) <NEWLINE> if self . _setup : <NEWLINE> <INDENT> self . _setup ( self ) <NEWLINE> <DEDENT> <DEDENT>
def __eq__ ( self , other ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if type ( self ) == type ( other ) : <NEWLINE> return self . getId ( ) == other . getId ( ) <NEWLINE> else : <NEWLINE> return False <NEWLINE> <DEDENT>
def fake_get_object ( self , context , model , ** kwargs ) : <NEWLINE> <INDENT> objects = self . model_map [ model ] <NEWLINE> if not objects : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> return [ obj for obj in objects if obj [ <STRING> ] == kwargs [ <STRING> ] [ 0 ] <NEWLINE> <DEDENT>
def test_guest_log_action_publish_user ( self ) : <NEWLINE> <INDENT> with patch . object ( manager . Manager , <STRING> , <NEWLINE> <INDENT> return_value = False ) as mock_enable : <NEWLINE> with patch . object ( os . path , <STRING> , return_value = True ) : <NEWLINE> log_details = self . manager . guest_log_action ( self . context , <NEWLINE> <INDENT> self . log_name_user , <NEWLINE> False , False , <NEWLINE> True , False ) <NEWLINE> assert_equal ( log_details , self . expected_details_user , <NEWLINE> <STRING> % <NEWLINE> ( log_details , self . expected_details_user ) ) <NEWLINE> assert_equal ( 1 , mock_enable . call_count ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_device_BDF ( self , device_name ) : <NEWLINE> <INDENT> device = self . Cfg . CONFIG_PCI [ device_name ] <NEWLINE> if device is None or device == { } : raise DeviceNotFoundError , ( <STRING> % device_name ) <NEWLINE> b = int ( device [ <STRING> ] , 16 ) <NEWLINE> d = int ( device [ <STRING> ] , 16 ) <NEWLINE> f = int ( device [ <STRING> ] , 16 ) <NEWLINE> return ( b , d , f ) <NEWLINE> <DEDENT>
def xm_vbfs_attach ( args ) : <NEWLINE> <INDENT> arg_check ( args , <STRING> , 2 , 3 ) <NEWLINE> dom = args [ 0 ] <NEWLINE> vbfs = [ <STRING> ] <NEWLINE> if len ( args ) == 3 : <NEWLINE> vbfs . append ( [ <STRING> , args [ 2 ] ] ) <NEWLINE> vbfs . append ( args [ 1 ] . split ( <STRING> ) ) <NEWLINE> server . xend . domain . device_create ( dom , vbfs ) <NEWLINE> <DEDENT>
def set_border_width ( self , value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> self . borderwidth = value <NEWLINE> <DEDENT> <DEDENT>
def __setattr__ ( self , attr , value ) : <NEWLINE> <INDENT> if attr in { <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , } : <NEWLINE> <INDENT> if isinstance ( value , ( _np . ndarray , list , tuple ) and len ( value ) != len ( self . cur_bun ) : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> self . __dict__ [ <STRING> + attr ] = value <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . __dict__ [ attr ] = value <NEWLINE> <DEDENT> <DEDENT>
class FileRepository ( object ) : <NEWLINE> <INDENT> def find_file ( self host , filename <NEWLINE> ) : <NEWLINE> <STRING> <NEWLINE> <DEDENT>
class runlength_smearing ( PluginFunction ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self_type = ImageType ( [ ONEBIT ] ) <NEWLINE> return_type = ImageList ( <STRING> ) <NEWLINE> args = Args ( [ Int ( <STRING> , default = - 1 ) , Int ( <STRING> , default = - 1 ) , Int ( <STRING> , default = - 1 ) ] ) <NEWLINE> author = <STRING> <NEWLINE> def __call__ ( image , Cx = - 1 , Cy = - 1 , Csm = - 1 ) : <NEWLINE> return _pagesegmentation . runlength_smearing ( image , Cx , Cy , Csm ) <NEWLINE> __call__ = staticmethod ( __call__ ) <NEWLINE> <DEDENT>
def get_records_with_attachments ( attachment_table , rel_object_field = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if arcpyFound == False : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> OIDs = [ ] <NEWLINE> with arcpy . da . SearchCursor ( attachment_table , <NEWLINE> <INDENT> [ rel_object_field ] ) as rows : <NEWLINE> for row in rows : <NEWLINE> if not str ( row [ 0 ] ) in OIDs : <NEWLINE> OIDs . append ( <STRING> % str ( row [ 0 ] ) ) <NEWLINE> del row <NEWLINE> <DEDENT> del rows <NEWLINE> return OIDs <NEWLINE> <DEDENT>
def standoff_main ( words , docid ) : <NEWLINE> <INDENT> global output_directory <NEWLINE> output_directory = None <NEWLINE> fail_count = 0 <NEWLINE> try : <NEWLINE> process ( words , docid ) <NEWLINE> except Exception , e : <NEWLINE> print ( <STRING> % ( e ) ) <NEWLINE> fail_count += 1 <NEWLINE> if fail_count > 0 : <NEWLINE> <INDENT> print ( <STRING> % ( fail_count ) ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT>
import unittest <NEWLINE> import types <NEWLINE> from mock import MagicMock <NEWLINE> from mock import patch <NEWLINE> from xscontainer . util import tls_secret <NEWLINE> def _add_vm_other_config_record ( vm_records , vm_uuid , other_config_key , <NEWLINE> <INDENT> other_config_value ) : <NEWLINE> if not isinstance ( vm_records , types . DictType ) : <NEWLINE> vm_records = { } <NEWLINE> if vm_uuid not in vm_records : <NEWLINE> vm_records [ vm_uuid ] = { } <NEWLINE> if <STRING> not in vm_records [ vm_uuid ] : <NEWLINE> vm_records [ vm_uuid ] [ <STRING> ] = { } <NEWLINE> vm_records [ vm_uuid ] [ <STRING> ] [ other_config_key ] = other_config_value <NEWLINE> <DEDENT>
def convertToStr ( self , value , type ) : <NEWLINE> <INDENT> if value is not None : <NEWLINE> <INDENT> if type == <STRING> : <NEWLINE> return value . isoformat ( ) <NEWLINE> elif type == <STRING> : <NEWLINE> return value . strftime ( <STRING> ) <NEWLINE> else : <NEWLINE> return str ( value ) <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <DEDENT>
def test_mpsk_snr_est_svn ( self ) : <NEWLINE> <INDENT> expected_result = [ 10.92 , 6.02 , 4.78 , 4.98 , 5.51 ] <NEWLINE> <INDENT> N = 10000 <NEWLINE> alpha = 0.001 <NEWLINE> op = digital . mpsk_snr_est_cc ( digital . SNR_EST_SVR , N , alpha ) <NEWLINE> actual_result = self . mpsk_snr_est_setup ( op ) <NEWLINE> self . assertFloatTuplesAlmostEqual ( expected_result , actual_result , 2 ) <NEWLINE> <DEDENT> <DEDENT>
def specialized_langinfo_from_content ( self , li , text ) : <NEWLINE> <INDENT> hints , specialized_li = self . _specialization_hints_from_lang . get ( <NEWLINE> <INDENT> li . name , ( None , None ) <NEWLINE> <DEDENT> if not hints : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> for hint_str , hint_re in hints : <NEWLINE> <INDENT> if hint_str not in text : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if hint_re and not hint_re . search ( text ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> return specialized_li <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>
def print_packet ( self ) : <NEWLINE> <INDENT> if self . oper == 1 : <NEWLINE> <INDENT> print ( <STRING> % ( self . dip , self . sip ) ) <NEWLINE> <DEDENT> if self . oper == 2 : <NEWLINE> <INDENT> print ( <STRING> % ( self . sip , self . smac ) <NEWLINE> <DEDENT> <DEDENT>
def errback ( self , e , info ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> e . trap ( Exception ) <NEWLINE> print ( <STRING> % { <STRING> : info , <NEWLINE> <INDENT> <STRING> : e . getErrorMessage ( ) } <NEWLINE> <DEDENT> <DEDENT>
def process_commkit ( self , commkit_data ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> household_ids = list ( ) <NEWLINE> household_mapping = HouseHoldMapping ( self . env ) <NEWLINE> for household_data in commkit_data . get ( <STRING> , <NEWLINE> <INDENT> [ commkit_data ] ) : <NEWLINE> household = self . search ( [ <NEWLINE> ( <STRING> , <STRING> , household_data . get ( <STRING> ) ) ] ) <NEWLINE> if household : <NEWLINE> household_ids . append ( household . id ) <NEWLINE> household_vals = household_mapping . get_vals_from_connect ( <NEWLINE> household_data ) <NEWLINE> household . _major_revision ( household_vals ) <NEWLINE> <DEDENT> return household_ids <NEWLINE> <DEDENT>
class TestUtilsEnvironment ( unittest . TestCase ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def test_program_version ( self ) : <NEWLINE> <INDENT> self . assertEqual ( { { cookiecutter . package_name } } _version ( ) , __version__ ) <NEWLINE> <DEDENT> def test_python_version ( self ) : <NEWLINE> <INDENT> self . assertIn ( python_version ( ) , shell_python ( ) ) <NEWLINE> <DEDENT> def test_python_major_version ( self ) : <NEWLINE> <INDENT> self . assertEqual ( python_version ( <STRING> ) , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def set_default_headers ( self ) : <NEWLINE> <INDENT> self . set_header ( <STRING> , <STRING> ) <NEWLINE> <INDENT> def check_origin ( self , origin ) : <NEWLINE> <INDENT> if <STRING> in origin or self . domain in origin : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class FwdCashManager ( InstrumentManager ) : <NEWLINE> <INDENT> def get_data ( self , id , <NEWLINE> <INDENT> curncy = <STRING> , <NEWLINE> value_date = None , <NEWLINE> ** kwargs ) : <NEWLINE> data = super ( FwdCashManager , self ) . get_data ( id , ** kwargs ) <NEWLINE> value_date = convert ( <STRING> , value_date ) <NEWLINE> data . update ( { <STRING> : convert ( <STRING> , curncy ) , <NEWLINE> <INDENT> <STRING> : value_date } ) <NEWLINE> return data <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_alarms ( ) : <NEWLINE> <INDENT> alarm_vals = np . zeros ( len ( blm_names ) ) <NEWLINE> for i in xrange ( len ( blm_names ) ) : <NEWLINE> blm_channel = blms [ i ] . id + <STRING> <NEWLINE> h = np . array ( dcs . get_device_td ( blm_channel ) ) <NEWLINE> <INDENT> blm_alarm_ch = blms [ i ] . id . replace ( <STRING> , <STRING> ) + <STRING> <NEWLINE> alarm_val = dcs . get_device_val ( blm_alarm_ch ) * 1.25e-3 <NEWLINE> alarm_vals [ i ] = np . max ( np . abs ( h ) ) / alarm_val <NEWLINE> <DEDENT> return alarm_vals <NEWLINE> <DEDENT>
from django . conf . urls . defaults import patterns , include , url <NEWLINE> urlpatterns = patterns ( <STRING> , <NEWLINE> <INDENT> url ( <STRING> , include ( <STRING> ) , <NEWLINE> <DEDENT> ) <NEWLINE>
class FlashLayerCodeUpdate ( FlashAssetCodeUpdate ) : <NEWLINE> <INDENT> SEARCH_TYPE = <STRING> <NEWLINE> def get_default_code ( my ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> def get_naming ( my ) : <NEWLINE> <INDENT> return FlashLayerNaming ( ) <NEWLINE> <DEDENT> def execute ( my ) : <NEWLINE> if not my . sobject . is_insert ( ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> <DEDENT>
def isarchive ( cls , filename ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return tarfile . is_tarfile ( encode ( filename ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT>
def test_get_by_instance_and_network ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( db , <NEWLINE> <INDENT> <STRING> ) as get : <NEWLINE> get . return_value = fake_vif <NEWLINE> vif = vif_obj . VirtualInterface . get_by_instance_and_network ( <NEWLINE> <INDENT> self . context , <STRING> , 123 ) <NEWLINE> self . _compare ( self , fake_vif , vif ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_validate ( self ) : <NEWLINE> <INDENT> fixture = TModel . objects . create ( name = self . id ( ) ) <NEWLINE> form = TForm ( http . QueryDict ( <STRING> % ( <NEWLINE> <INDENT> self . id ( ) , self . get_value ( fixture ) ) ) ) <NEWLINE> <DEDENT> form . fields [ <STRING> ] . queryset = QuerySetSequence ( <NEWLINE> <INDENT> TModel . objects . exclude ( pk = fixture . pk ) ) <NEWLINE> <DEDENT> self . assertFalse ( form . is_valid ( ) <NEWLINE> <DEDENT>
def fstore_dump ( url_addr ) : <NEWLINE> <INDENT> store = HTTP4Store ( <STRING> ) <NEWLINE> status = store . status ( ) <NEWLINE> response = store . add_from_uri ( <STRING> ) <NEWLINE> <INDENT> return response <NEWLINE> <DEDENT> <DEDENT>
def main ( number ) : <NEWLINE> <INDENT> rospy . init_node ( <STRING> , anonymous = True ) <NEWLINE> global globaltime <NEWLINE> globaltime = time . time ( ) <NEWLINE> global fileno <NEWLINE> fileno = number <NEWLINE> <INDENT> sm = smach . StateMachine ( outcomes = [ <STRING> ] ) <NEWLINE> with sm : <NEWLINE> smach . StateMachine . add ( <STRING> , Flag1 ( ) , <NEWLINE> <INDENT> transitions = { <STRING> : <STRING> , <STRING> : <STRING> } ) <NEWLINE> smach . StateMachine . add ( <STRING> , Gazebo_check1 ( ) , <NEWLINE> transitions = { <STRING> : <STRING> } ) <NEWLINE> <DEDENT> outcome = sm . execute ( ) <NEWLINE> <DEDENT> <DEDENT>
def validate ( self ) : <NEWLINE> <INDENT> res = super ( SaharaClusterTemplate , self ) . validate ( ) <NEWLINE> if res : <NEWLINE> <INDENT> return res <NEWLINE> <DEDENT> if ( self . is_using_neutron ( ) and <NEWLINE> <INDENT> not self . properties [ self . MANAGEMENT_NETWORK ] ) : <NEWLINE> msg = _ ( <STRING> <NEWLINE> <INDENT> ) % self . MANAGEMENT_NETWORK <NEWLINE> raise exception . StackValidationFailed ( message = msg ) <NEWLINE> <DEDENT> <DEDENT> self . client_plugin ( ) . validate_hadoop_version ( <NEWLINE> <INDENT> self . properties [ self . PLUGIN_NAME ] , <NEWLINE> self . properties [ self . HADOOP_VERSION ] <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def blast_to_df_iter ( fn , delimiter = <STRING> , chunksize = 10000 , remap = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for group in pd . read_table ( fn , header = None , skipinitialspace = True , <NEWLINE> <INDENT> names = [ k for k , _ in blast_cols ] , <NEWLINE> delimiter = delimiter , chunksize = chunksize ) : <NEWLINE> convert_dtypes ( group , dict ( blast_cols ) ) <NEWLINE> if remap : <NEWLINE> remap_blast ( group ) <NEWLINE> yield group <NEWLINE> <DEDENT> <DEDENT>
def dashboard ( ) : <NEWLINE> <INDENT> user_count = User . query . filter_by ( status = USER_STATUS . ACTIVE ) . count ( ) <NEWLINE> mau = db . session . query ( <STRING> ) . from_statement ( db . text ( <NEWLINE> <INDENT> <STRING> <NEWLINE> ) ) . params ( status = USER_STATUS . ACTIVE ) . first ( ) [ 0 ] <NEWLINE> <DEDENT> return render_template ( <STRING> , <NEWLINE> <INDENT> user_count = user_count , <NEWLINE> , <NEWLINE> mau = mau <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from collections import Iterator <NEWLINE> from sqlalchemy . engine import ResultProxy , Connection <NEWLINE> from sqlalchemy . exc import IntegrityError <NEWLINE> from sqlalchemy . sql import Insert , Update <NEWLINE> def execute_with_exceptions ( connection : Connection , <NEWLINE> <INDENT> executable : [ Insert , Update ] , <NEWLINE> exceptions : Iterator ) -> ResultProxy : <NEWLINE> <STRING> <NEWLINE> try : <NEWLINE> return connection . execute ( executable ) <NEWLINE> except IntegrityError as exc : <NEWLINE> error = str ( exc . orig ) <NEWLINE> for name , exception in exceptions : <NEWLINE> if name in error : <NEWLINE> raise exception <NEWLINE> raise <NEWLINE> <DEDENT>
def run ( self , logger , jira_env , args ) : <NEWLINE> <INDENT> global soap , auth <NEWLINE> try : <NEWLINE> <INDENT> groupname = <STRING> <NEWLINE> group = soap . service . getGroup ( auth , groupname ) <NEWLINE> return group [ <STRING> ] <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> logger . exception ( e ) <NEWLINE> <DEDENT> <DEDENT>
def test_unknown ( self ) : <NEWLINE> <INDENT> header = self . _header ( 0 ) <NEWLINE> with mock . patch ( <STRING> , <NEWLINE> <INDENT> mock . Mock ( return_value = mock . sentinel . grid ) ) : <NEWLINE> with mock . patch ( <STRING> ) as warn : <NEWLINE> grid = header . grid ( ) <NEWLINE> <DEDENT> warn . assert_called_with ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> self . assertIs ( grid , mock . sentinel . grid ) <NEWLINE> <DEDENT>
def get_inst ( self , batch_sys_name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if batch_sys_name in self . _INSTANCES : <NEWLINE> <INDENT> return self . _INSTANCES [ batch_sys_name ] <NEWLINE> <DEDENT> for key in [ <NEWLINE> <INDENT> <STRING> + batch_sys_name , <NEWLINE> batch_sys_name ] : <NEWLINE> try : <NEWLINE> mod_of_name = __import__ ( key , fromlist = [ key ] ) <NEWLINE> self . _INSTANCES [ batch_sys_name ] = getattr ( <NEWLINE> <INDENT> mod_of_name , <STRING> ) <NEWLINE> <DEDENT> return self . _INSTANCES [ batch_sys_name ] <NEWLINE> except ImportError : <NEWLINE> if key == batch_sys_name : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def attach_cache_database ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . cur . execute ( <STRING> % CACHE_DB_PATH . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT> except sqlite . Error , e : <NEWLINE> <INDENT> log . debug ( <STRING> % str ( e ) ) <NEWLINE> <DEDENT> <DEDENT>
def test_geolocate ( ) : <NEWLINE> <INDENT> with open ( os . path . join ( os . path . dirname ( __file__ ) , <NEWLINE> <INDENT> <STRING> , <STRING> ) ) as journey_file : <NEWLINE> fixtures = yaml . load ( journey_file ) <NEWLINE> for fixture in fixtures : <NEWLINE> result = Greengraph ( ** fixture ) <NEWLINE> assert_equal ( result . start , fixture [ <STRING> ] ) <NEWLINE> assert_equal ( result . end , fixture [ <STRING> ] ) <NEWLINE> assert_equal ( result . geocoder . domain , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def dump ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> % ( <STRING> , self . name ) ) <NEWLINE> if self . comment : <NEWLINE> <INDENT> print <STRING> % ( <STRING> , self . comment ) <NEWLINE> <DEDENT> if self . sequence : <NEWLINE> <INDENT> print ( <STRING> % ( <STRING> , self . sequence [ : 25 ] ) , ) <NEWLINE> if len ( self . sequence ) > 25 : print <STRING> <NEWLINE> else : print <STRING> <NEWLINE> <DEDENT> <DEDENT>
def AcquireSamples ( nSamples = 1000 ) : <NEWLINE> <INDENT> global device <NEWLINE> colored ( <STRING> , <STRING> ) <NEWLINE> samples = [ ] <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> res = device . read ( nSamples ) <NEWLINE> <INDENT> hr = heart_rate ( res [ : , - 2 ] ) <NEWLINE> step = step_calc ( res [ : , - 1 ] , res [ : , - 3 ] , res [ : , - 4 ] ) <NEWLINE> format2json ( hr , step ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def euler ( n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not isscalar ( n ) or ( n < 0 ) : <NEWLINE> <INDENT> raise ValueError , <STRING> <NEWLINE> <DEDENT> n = int ( n ) <NEWLINE> if ( n < 2 ) : n1 = 2 <NEWLINE> else : n1 = n <NEWLINE> return specfun . eulerb ( n1 ) [ : ( n + 1 ) ] <NEWLINE> <DEDENT>
class AssertionIDRequest ( Request ) : <NEWLINE> <INDENT> msgtype = <STRING> <NEWLINE> def __init__ ( self , sec_context , receiver_addrs , attribute_converters , <NEWLINE> <INDENT> timeslack = 0 ) : <NEWLINE> Request . __init__ ( self , sec_context , receiver_addrs , <NEWLINE> <INDENT> attribute_converters , timeslack ) <NEWLINE> self . signature_check = self . sec . correctly_signed_assertion_id_request <NEWLINE> <DEDENT> <DEDENT> def attributes ( self ) : <NEWLINE> <INDENT> return to_local ( self . attribute_converters , self . message ) <NEWLINE> <DEDENT> <DEDENT>
{ <NEWLINE> <STRING> : { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : timedelta ( seconds = 30 ) <NEWLINE> <DEDENT> } , <NEWLINE> <STRING> : { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : timedelta ( seconds = 30 ) <NEWLINE> <DEDENT> } , <NEWLINE> <STRING> : { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : timedelta ( seconds = 30 ) <NEWLINE> <DEDENT> <DEDENT>
def post ( self , rv , * args , ** kwargs ) : <NEWLINE> <INDENT> LOG . debug ( <NEWLINE> <INDENT> <STRING> <NEWLINE> % ( rv , args , kwargs ) <NEWLINE> <DEDENT> self . _compute_driver = args [ 0 ] <NEWLINE> self . _init_fault_events ( ) <NEWLINE> LOG . debug ( <STRING> ) <NEWLINE> dnt_mgr = DntManager ( self . _compute_driver ) <NEWLINE> dnt_mgr . init_thread ( ) <NEWLINE> <DEDENT>
def __call__ ( self , history , predicted ) : <NEWLINE> <INDENT> backOffWeight = 1.0 <NEWLINE> while True : <NEWLINE> <INDENT> if ( history , predicted ) in self . prob : <NEWLINE> return backOffWeight * self . prob [ ( history , predicted ) ] <NEWLINE> backOffWeight *= self . prob . get ( ( history , None ) , 1.0 ) <NEWLINE> if history : <NEWLINE> history = history [ 1 : ] <NEWLINE> else : <NEWLINE> break <NEWLINE> <DEDENT> return backOffWeight <NEWLINE> <DEDENT>
def rollbackTransaction ( self ) : <NEWLINE> <INDENT> self . transactionDepth = 0 <NEWLINE> try : <NEWLINE> <INDENT> self . getConn ( ) . execute ( <STRING> ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> print ( e ) <NEWLINE> <DEDENT> <DEDENT>
def testDepthwiseConv2DInputGrad ( self ) : <NEWLINE> <INDENT> for index , ( input_size , filter_size , output_size , stride , <NEWLINE> <INDENT> padding ) in enumerate ( CheckGradConfigsToTest ( ) ) : <NEWLINE> print ( <STRING> , index , <STRING> , <NEWLINE> input_size , <STRING> , filter_size , <STRING> , stride , <STRING> , <NEWLINE> padding ) <NEWLINE> for data_type in [ dtypes . float32 , dtypes . float64 ] : <NEWLINE> self . _ConstructAndTestGradient ( <NEWLINE> input_size , <NEWLINE> filter_size , <NEWLINE> output_size , <NEWLINE> stride , <NEWLINE> padding , <NEWLINE> data_type , <NEWLINE> test_input = True , <NEWLINE> use_gpu = True ) <NEWLINE> <DEDENT> <DEDENT>
def getresp ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> resp = self . getline ( ) <NEWLINE> if self . debugging : print <STRING> , repr ( resp ) <NEWLINE> c = resp [ : 1 ] <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> raise NNTPTemporaryError ( resp ) <NEWLINE> <DEDENT> if c == <STRING> : <NEWLINE> <INDENT> raise NNTPPermanentError ( resp ) <NEWLINE> <DEDENT> if c not in <STRING> : <NEWLINE> <INDENT> raise NNTPProtocolError ( resp ) <NEWLINE> <DEDENT> return resp <NEWLINE> <DEDENT>
def validate_record ( self , data_fields , field_descs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> errors = 0 <NEWLINE> for index , field_value , field_desc in zip ( <NEWLINE> <INDENT> xrange ( len ( data_fields ) ) , <NEWLINE> data_fields , <NEWLINE> field_descs ) : <NEWLINE> new_value = self . validate_field ( field_value , field_desc ) <NEWLINE> if new_value : <NEWLINE> data_fields [ index ] = new_value <NEWLINE> else : <NEWLINE> errors += 1 <NEWLINE> <DEDENT> return errors <NEWLINE> <DEDENT>
def rx_callback ( self , data ) : <NEWLINE> <INDENT> if <STRING> in data [ 1 ] [ 1 ] and <STRING> == data [ 1 ] [ 2 ] : <NEWLINE> <INDENT> if data [ 1 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> self . receiver_monitor . send_command ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . receiver_monitor . send_command ( <STRING> % ( data [ 1 ] [ 0 ] , ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> self . __event_dispatch . send ( <STRING> , data ) <NEWLINE> <DEDENT> <DEDENT>
def fly_wrapper ( BOUNCE_COEFF , * args ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> ) <NEWLINE> Trial end . FINAL BOUNCE_COEFF : { 0 } <NEWLINE> SCORE : { 1 } <NEWLINE> <INDENT> { 2 } <NEWLINE> <DEDENT> logging . info ( msg ) <NEWLINE> print ( msg ) <NEWLINE> <DEDENT>
def rpm_install_pkg ( package_path package_name ) : <NEWLINE> <INDENT> code , output = run_cmd ( <STRING> + package_name ) <NEWLINE> if code == 0 : <NEWLINE> <INDENT> hutil . log ( package_name + <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> code , output = run_cmd ( <STRING> + package_path ) <NEWLINE> if code == 0 : <NEWLINE> <INDENT> hutil . log ( package_name + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> . format ( package_name , output ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def cache ( self , subject , session ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> path = self . path . format ( subject = subject , session = session ) <NEWLINE> if ( not exists ( path ) or getmtime ( path ) < <NEWLINE> <INDENT> self . mtime ( subject , session , self . _bad_chs_affect_cache ) ) : <NEWLINE> dir_path = dirname ( path ) <NEWLINE> if not exists ( dir_path ) : <NEWLINE> mkdir ( dir_path ) <NEWLINE> with CaptureLog ( path [ : - 3 ] + <STRING> ) : <NEWLINE> raw = self . _make ( subject , session ) <NEWLINE> raw . save ( path , overwrite = True ) <NEWLINE> <DEDENT> <DEDENT>
def open_cover ( self , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for value in self . _node . get_values ( <NEWLINE> <INDENT> class_id = zwave . const . COMMAND_CLASS_SWITCH_MULTILEVEL ) . values ( ) : <NEWLINE> if value . command_class == zwave . const . COMMAND_CLASS_SWITCH_MULTILEVEL and value . label == <STRING> or value . command_class == zwave . const . COMMAND_CLASS_SWITCH_MULTILEVEL and value . label == <STRING> : <NEWLINE> self . _lozwmgr . pressButton ( value . value_id ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
def set_corpus_path ( self , path ) : <NEWLINE> <INDENT> if path == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif osp . isdir ( path ) : self . graph ( flags ) <NEWLINE> <INDENT> self . corpus_path = path <NEWLINE> if self . corpus_path [ - 1 ] != <STRING> : <NEWLINE> <INDENT> self . corpus_path += <STRING> <NEWLINE> <DEDENT> print ( <STRING> + self . corpus_path + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + path + <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def writeMoreBlocksReportToFile ( self , filename ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> reportStr = <STRING> <NEWLINE> <DEDENT> for aSprite in self . sprites : <NEWLINE> <INDENT> reportStr += aSprite . name <NEWLINE> reportStr += ( <STRING> + <STRING> * len ( aSprite . name ) + <STRING> ) <NEWLINE> for aMoreBlocksDef in aSprite . moreBlocks : <NEWLINE> <INDENT> reportStr += aMoreBlocksDef <NEWLINE> reportStr += ( <STRING> + <STRING> * len ( aMoreBlocksDef ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> with open ( filename + <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( reportStr ) <NEWLINE> <DEDENT> <DEDENT>
class fileForm ( Form ) : <NEWLINE> <INDENT> title = TextField ( <STRING> , validators = [ validators . required ( ) ] ) <NEWLINE> <INDENT> link = TextField ( <STRING> , validators = [ validators . required ( ) ] ) <NEWLINE> comment = TextAreaField ( <STRING> ) <NEWLINE> adddate = ndb . DateTimeProperty ( auto_now_add = True ) <NEWLINE> <DEDENT> <DEDENT>
( <STRING> <NEWLINE> <DEDENT>
def retranslateUi ( self , HgStatusDialog ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> HgStatusDialog . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> HgStatusDialog . setWhatsThis ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def move_up ( self , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for value in self . _node . get_values ( <NEWLINE> <INDENT> class_id = COMMAND_CLASS_SWITCH_MULTILEVEL ) . values ( ) : <NEWLINE> if value . command_class == zwave . COMMAND_CLASS_SWITCH_MULTILEVEL and value . label == <STRING> or value . command_class == zwave . COMMAND_CLASS_SWITCH_MULTILEVEL and value . label == <STRING> : <NEWLINE> self . _lozwmgr . pressButton ( value . value_id ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
def test_star_imports ( ) : <NEWLINE> <INDENT> result = tlint ( <STRING> , Project ( ) <NEWLINE> assert not result <NEWLINE> <DEDENT>
def test0010currencies ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with Transaction ( ) . start ( DB_NAME , USER , <NEWLINE> <INDENT> context = CONTEXT ) as transaction : <NEWLINE> cu1 , cu2 = self . currency . create ( [ { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> } , { <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> } ] ) <NEWLINE> self . assert_ ( cu1 ) <NEWLINE> self . assert_ ( cu2 ) <NEWLINE> transaction . cursor . commit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def readPackets ( self , num , maxlen = None ) : <NEWLINE> <INDENT> packets = [ ] <NEWLINE> for i in range ( 0 , num ) : <NEWLINE> <INDENT> if self . debug > 0 : <NEWLINE> <INDENT> print <STRING> % ( i + 1 , num ) <NEWLINE> <DEDENT> packets . append ( self . readPacket ( maxlen ) ) <NEWLINE> <DEDENT> return packets <NEWLINE> <DEDENT>
class FakeSessionForVolumeTests ( fake . SessionBase ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def VDI_introduce ( self , _1 , uuid , _2 , _3 , _4 , _5 , <NEWLINE> <INDENT> _6 , _7 , _8 , _9 , _10 , _11 ) : <NEWLINE> valid_vdi = False <NEWLINE> refs = fake . get_all ( <STRING> ) <NEWLINE> for ref in refs : <NEWLINE> rec = fake . get_record ( <STRING> , ref ) <NEWLINE> if rec [ <STRING> ] == uuid : <NEWLINE> valid_vdi = True <NEWLINE> if not valid_vdi : <NEWLINE> raise fake . Failure ( [ [ <STRING> , <STRING> , self . _session ] ] ) <NEWLINE> <DEDENT> <DEDENT>
def GetMediaWithPlace ( self , placeid , sort_col = <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> % ( smart_utf8 ( placeid ) ) ) <NEWLINE> media = [ ] <NEWLINE> cur = self . dbconn . cursor ( ) <NEWLINE> try : <NEWLINE> <INDENT> if ( sort_col != <STRING> ) : <NEWLINE> sort_col = <STRING> + sort_col <NEWLINE> cur . execute ( <STRING> % ( sort_col ) , ( placeid , ) ) <NEWLINE> for tuple in cur : <NEWLINE> media . append ( tuple ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> print ( <STRING> + smart_utf8 ( e ) ) <NEWLINE> pass <NEWLINE> <DEDENT> cur . close ( ) <NEWLINE> return media <NEWLINE> <DEDENT>
def mergeCombiners ( ( bw1 , req_count1 ) , ( bw2 , req_count2 ) ) : <NEWLINE> <INDENT> for region in bw1 : <NEWLINE> <INDENT> bw1 [ region ] = bw1 [ region ] + bw2 [ region ] <NEWLINE> req_count1 [ region ] = req_count1 [ region ] + req_count2 [ region ] <NEWLINE> <DEDENT> return ( bw1 , req_count1 ) <NEWLINE> <DEDENT>
from PyQt5 . QtWidgets import ( QWidget , QLineEdit , QPushButton , QSystemTrayIcon <NEWLINE> <INDENT> QFileDialog , QFormLayout , QApplication ) <NEWLINE> <DEDENT> from PyQt5 . QtCore import QThread , QRegExp <NEWLINE> import requests <NEWLINE> import sys <NEWLINE>
try : <NEWLINE> <INDENT> basestring <NEWLINE> <DEDENT> except NameError : <NEWLINE> <INDENT> basestring = str <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> bool <NEWLINE> <DEDENT> except NameError : <NEWLINE> <INDENT> def bool ( x ) : <NEWLINE> return not not x <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> True <NEWLINE> <DEDENT> except NameError : <NEWLINE> <INDENT> False = 0 <NEWLINE> True = 1 <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> enumerate <NEWLINE> <DEDENT> except NameError : <NEWLINE> <INDENT> def enumerate ( lt ) : <NEWLINE> return map ( None , xrange ( len ( lt ) ) , lt ) <NEWLINE> <DEDENT>
def hot ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> listing = feedparser . parse ( TRENDING_URL ) [ <STRING> ] <NEWLINE> trends = [ item [ <STRING> ] for item in listing ] <NEWLINE> return trends <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> <INDENT> print ( <STRING> , str ( e ) ) ) <NEWLINE> return None <NEWLINE> <DEDENT> <DEDENT>
def label ( g , r ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> queries = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> <NEWLINE> <DEDENT>
def setContent ( self , content , ext = <STRING> ) <NEWLINE> <INDENT> sib = self . siblingExtension ( ext ) <NEWLINE> sib . open ( <STRING> ) . write ( content ) <NEWLINE> os . rename ( sib . path , self . path ) <NEWLINE> <DEDENT>
def on_adapter_property_changed ( self , List , adapter , ( key , value ) ) : <NEWLINE> <INDENT> if key == <STRING> : <NEWLINE> <INDENT> if value : <NEWLINE> <INDENT> self . b_search . props . sensitive = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . b_search . props . sensitive = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def main ( args ) : <NEWLINE> <INDENT> feature_files = glob . glob ( os . path . join ( args . feature_directory , <STRING> ) <NEWLINE> ( files , time_points , <NEWLINE> <INDENT> features ) = morphine . sample_feature_files ( feature_files , <NEWLINE> <INDENT> args . num_samples ) <NEWLINE> <DEDENT> <DEDENT> connections = morphine . build_kneighbors_table ( features , args . k_neighbors ) <NEWLINE> path = morphine . rand_acyclic_walk ( connections ) <NEWLINE> print ( path ) <NEWLINE> <DEDENT>
class Institucion ( models . Model ) : <NEWLINE> <INDENT> nombre = models . CharField ( , max_length = 144 ) <NEWLINE> publica = models . BooleanField ( default = False ) <NEWLINE> <INDENT> class Meta : <NEWLINE> <INDENT> verbose_name = _ ( <STRING> ) <NEWLINE> verbose_name_plural = _ ( <STRING> ) <NEWLINE> <DEDENT> def __unicode__ ( self ) : <NEWLINE> <INDENT> return self . nombre <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def GET ( self ) : <NEWLINE> <INDENT> global session <NEWLINE> chdir ( path [ 0 ] + sep + <STRING> ) <NEWLINE> render = template . render ( <STRING> ) <NEWLINE> fo = loginform ( ) <NEWLINE> if session == None : <NEWLINE> <INDENT> session = webconfig . _session <NEWLINE> <DEDENT> if session . login == 0 : <NEWLINE> <INDENT> return render . index ( False , fo ) <NEWLINE> elif session . login == 1 : <NEWLINE> return render . index ( True , fo ) <NEWLINE> <DEDENT> <DEDENT>
def __getstate__ ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> state = filter ( <NEWLINE> <INDENT> lambda ( k , v ) : k not in [ <STRING> , <STRING> ] , <NEWLINE> self . __dict__ . iteritems ( ) <NEWLINE> <DEDENT> ) <NEWLINE> return dict ( state ) <NEWLINE> <DEDENT>
def libtool_version_menu ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> current = get_libtool_version ( ) <NEWLINE> if confirm ( <STRING> <NEWLINE> <INDENT> <STRING> % current ) : <NEWLINE> library = confirm ( <STRING> ) <NEWLINE> added = confirm ( <STRING> ) <NEWLINE> removed = confirm ( <STRING> ) <NEWLINE> changed = confirm ( <STRING> ) <NEWLINE> set_libtool_version ( library = library , added = added , removed = removed , <NEWLINE> <INDENT> changed = changed ) <NEWLINE> version = get_libtool_version ( ) <NEWLINE> print ( <STRING> % version ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <DEDENT>
def ui_command_version ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> from rtslib import __version__ as rtslib_version <NEWLINE> from targetcli import __version__ as targetcli_version <NEWLINE> from configshell import __version__ as configshell_version <NEWLINE> for package , version in dict ( targetcli = targetcli_version , <NEWLINE> <INDENT> rtslib = rtslib_version , <NEWLINE> configshell = configshell_version ) . items ( ) : <NEWLINE> if version == <STRING> : <NEWLINE> self . shell . log . error ( <STRING> <NEWLINE> % ( package , package ) <NEWLINE> + <STRING> <NEWLINE> + <STRING> <NEWLINE> + <STRING> ) <NEWLINE> else : <NEWLINE> self . shell . log . info ( <STRING> % ( package , version ) ) <NEWLINE> <DEDENT> <DEDENT>
class TestRsqrt ( unittest . TestCase ) : <NEWLINE> <INDENT> def test_rsqrt ( self ) : <NEWLINE> <INDENT> x = numpy . random . uniform ( 0.1 , 5 , ( 3 , 2 ) ) . astype ( numpy . float32 ) <NEWLINE> testing . assert_allclose ( F . rsqrt ( x ) . data , rsqrt ( x ) <NEWLINE> <DEDENT> <DEDENT>
def serve_thread_tcp ( host , port , handler ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if OsInterfaceIsSupported ( ) : <NEWLINE> <INDENT> server = ThreadingTCPServer ( ( settings . Config . Bind_To , port ) , handler ) <NEWLINE> server . serve_forever ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> server = ThreadingTCPServer ( ( host , port ) , handler ) <NEWLINE> server . serve_forever ( ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> print ( color ( <STRING> , 1 , 1 ) + <STRING> + str ( <NEWLINE> <INDENT> port ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from django . conf . urls import patterns , include , url <NEWLINE> from django . contrib import admin <NEWLINE> urlpatterns = patterns ( <STRING> , <NEWLINE> <INDENT> url ( <STRING> , include ( admin . site . urls ) ) ) , <NEWLINE> url ( <STRING> , include ( <STRING> ) ) <NEWLINE> <DEDENT> ) <NEWLINE>
categories = [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ] <NEWLINE> <DEDENT> microcode = <STRING> <NEWLINE> for category in categories : <NEWLINE> <INDENT> exec <STRING> % category <NEWLINE> microcode += cat . microcode <NEWLINE> <DEDENT>
class ChoiceWidget ( WidgetBase , forms . Select ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , autocomplete = None , widget_js_attributes = None , <NEWLINE> <INDENT> autocomplete_js_attributes = None , extra_context = None , registry = None , <NEWLINE> widget_template = None , widget_attrs = None , * args , <NEWLINE> ** kwargs ) : <NEWLINE> forms . Select . __init__ ( self , * args , ** kwargs ) <NEWLINE> WidgetBase . __init__ ( self , autocomplete , widget_js_attributes , <NEWLINE> <INDENT> autocomplete_js_attributes , extra_context , registry , <NEWLINE> widget_template , widget_attrs ) <NEWLINE> self . widget_attrs . setdefault ( <STRING> , 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def _get_precedential_statuses ( self ) : <NEWLINE> <INDENT> statuses = [ ] <NEWLINE> for _ in range ( 0 , len ( self . case_names ) ) ) : <NEWLINE> <INDENT> if <STRING> in self . url . lower ( ) : <NEWLINE> <INDENT> statuses . append ( <STRING> ) <NEWLINE> <DEDENT> elif <STRING> in self . url . lower ( ) : <NEWLINE> <INDENT> statuses . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> statuses . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return statuses <NEWLINE> <DEDENT>
def _send ( self , msg ) : <NEWLINE> <INDENT> loop = asyncio . get_event_loop ( ) <NEWLINE> coro = asyncio . ensure_future ( self . _send_coro ( msg , loop ) ) ) <NEWLINE> loop . run_until_complete ( coro ) <NEWLINE> return coro . result ( ) <NEWLINE> <DEDENT>
def makeDirectory ( self , path ) : <NEWLINE> <INDENT> d = self . _get_root ( path ) <NEWLINE> d . addCallback ( lambda ( root , path ) : <NEWLINE> <INDENT> self . _get_or_create_directories ( root , path ) ) <NEWLINE> <DEDENT> return d <NEWLINE> <DEDENT>
def count1 ( dna , base ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> for c in dna : <NEWLINE> <INDENT> if c == base : <NEWLINE> i += 1 <NEWLINE> <DEDENT> return i <NEWLINE> <DEDENT>
ass Solution ( object ) : <NEWLINE> <INDENT> def canConstruct ( self , ransomNote , magazine ) : <NEWLINE> <INDENT> for i in ransomNote : <NEWLINE> <INDENT> if i not in magazine : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif ransomNote . count ( i ) > magazine . count ( i ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> <DEDENT>
def testDepthwiseConv2DInputGradCompare ( self ) : <NEWLINE> <INDENT> for index , ( input_size , filter_size , output_size , stride , <NEWLINE> <INDENT> padding ) in enumerate ( ConfigsToTest ( ) ) : <NEWLINE> print ( <STRING> , index , <STRING> ) <NEWLINE> self . _CompareBackpropInputFloat ( input_size , filter_size , output_size , <NEWLINE> <INDENT> stride , padding ) <NEWLINE> self . _CompareBackpropInputDouble ( input_size , filter_size , output_size , <NEWLINE> <INDENT> stride , padding ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def search ( self , ** kwargs ) : <NEWLINE> <INDENT> args = kwargs <NEWLINE> req_url = <STRING> % ( self . base_url , <NEWLINE> <INDENT> self . version , <NEWLINE> self . format <NEWLINE> self . api_key , <NEWLINE> uenc ( kwargs ) ) <NEWLINE> <DEDENT> rsp = urllib2 . urlopen ( req_url ) . read ( ) <NEWLINE> return DigitalNZResponse ( self , rsp ) <NEWLINE> <DEDENT>
def close ( self ) : <NEWLINE> <INDENT> sock = self . sock <NEWLINE> istream = self . istream <NEWLINE> ostream = self . ostream <NEWLINE> self . sock = 0 <NEWLINE> self . istream = 0 <NEWLINE> self . ostream = 0 <NEWLINE> <INDENT> if self . file_count == 0 : <NEWLINE> if istream : <NEWLINE> <INDENT> istream . close ( ) <NEWLINE> if ostream : <NEWLINE> ostream . close ( ) <NEWLINE> if sock : <NEWLINE> sock . close ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def canvas_detect ( self ) : <NEWLINE> <INDENT> self . lilnew1 . delete ( 0 , END ) <NEWLINE> holddevices = pcapy . findalldevs ( ) <NEWLINE> for devices in holddevices : <NEWLINE> <INDENT> if devices == <STRING> : <NEWLINE> <INDENT> self . lilnew1 . insert ( 0 , ) <NEWLINE> elif devices == <STRING> : <NEWLINE> self . lilnew1 . insert ( 0 , ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . lilnew1 . insert ( 0 , devices ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def parse_timezone ( tzstring , default_timezone = UTC ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if tzstring == <STRING> : <NEWLINE> return default_timezone <NEWLINE> if tzstring is None : <NEWLINE> return default_timezone <NEWLINE> m = TIMEZONE_REGEX . match ( tzstring ) <NEWLINE> prefix , hours , minutes = m . groups ( ) <NEWLINE> hours , minutes = int ( hours ) , int ( minutes ) <NEWLINE> if prefix == <STRING> : <NEWLINE> hours = - hours <NEWLINE> minutes = - minutes <NEWLINE> return FixedOffset ( hours , minutes , tzstring ) <NEWLINE> <DEDENT>
def on_action_ExecuteCode ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> code = self . dlg . CodeField . Model . Text <NEWLINE> exec code <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> debugexception ( ) <NEWLINE> <DEDENT> self . updateOutputInCreatorDialog ( ) <NEWLINE> <DEDENT>
def calculating_l ( ) : <NEWLINE> <INDENT> X = [ 1.0 , 0 ] <NEWLINE> g = [ 10.0 ** 14.0 , 10.0 ** 14.3 , 10.0 ** 14.6 , 10 ** 14.385 ] <NEWLINE> Teff = [ 0.075 , 0.1 , 0.125 , 0.272643294692 , 0.008621738 , 0.0343237572043 <NEWLINE> <DEDENT>
def test_forceacquire ( self ) : <NEWLINE> <INDENT> with utils . NonBlockingLock ( project = self . project_mock , <NEWLINE> <INDENT> version = self . version_mock ) as f_lock : <NEWLINE> try : <NEWLINE> with utils . NonBlockingLock ( project = self . project_mock , <NEWLINE> <INDENT> version = self . version_mock , max_lock_age = 0 ) as f_lock : <NEWLINE> pass <NEWLINE> except utils . LockTimeout : <NEWLINE> raise AssertionError ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> num = int ( input ( <STRING> ) ) <NEWLINE> print ( <STRING> + str ( trial_division ( num ) ) <NEWLINE> <DEDENT>
def __init__ ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> self . data = { } <NEWLINE> <DEDENT> <DEDENT>
def add_grid ( self , grid_name , grid ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> gname_new = grid_name <NEWLINE> <INDENT> while ( gname_new in self . d_grids ) : <NEWLINE> <INDENT> gname_new += <STRING> <NEWLINE> <DEDENT> <DEDENT> self . d_grids [ gname_new ] = grid <NEWLINE> return gname_new <NEWLINE> <DEDENT>
def readkeys ( module , filename ) : <NEWLINE> <INDENT> if not os . path . isfile ( filename ) <NEWLINE> <INDENT> return { } <NEWLINE> <DEDENT> keys = { } <NEWLINE> f = open ( filename ) <NEWLINE> for line in f . readlines ( ) : <NEWLINE> <INDENT> key_data = parsekey ( module , line ) <NEWLINE> if key_data : <NEWLINE> <INDENT> keys [ key_data [ 0 ] ] = key_data <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> keys [ line ] = line <NEWLINE> <DEDENT> <DEDENT> f . close ( ) <NEWLINE> return keys <NEWLINE> <DEDENT>
def parse_and_install_all ( lines , tag , skip_functions = None ) : <NEWLINE> <INDENT> if skip_functions == None : <NEWLINE> <INDENT> skip_functions = [ ] <NEWLINE> <DEDENT> ( structs , functions , const_globals ) = parse_all ( lines ) <NEWLINE> for f in skip_functions : <NEWLINE> <INDENT> if f in functions : <NEWLINE> del functions [ f ] <NEWLINE> <DEDENT> target_objects . structs . update ( structs ) <NEWLINE> target_objects . functions . update ( functions ) <NEWLINE> target_objects . const_globals . update ( const_globals ) <NEWLINE> if tag != None : <NEWLINE> <INDENT> target_objects . functions_by_tag [ tag ] = set ( functions ) <NEWLINE> <DEDENT> return ( structs , functions , const_globals ) <NEWLINE> <DEDENT>
<DEDENT> delta = self . cost_derivative ( activations [ - 1 ] ] , y ) * sigmoid_prime ( zs [ - 1 ] ) <NEWLINE>
def add ( self , ( s , p , o ) , context = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if context is not None : <NEWLINE> <INDENT> c = self . get_context ( context ) <NEWLINE> assert c . identifier == context , <STRING> % ( c . identifier , context ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = self . default_context <NEWLINE> <DEDENT> self . store . add ( ( s , p , o ) , context = c , quoted = False ) <NEWLINE> <DEDENT>
def is_false_positive ( i , j , all_gs , path_conditions ) : <NEWLINE> <INDENT> pathi = path_conditions [ i ] <NEWLINE> pathj = path_conditions [ j ] <NEWLINE> statei = all_gs [ i ] <NEWLINE> set_of_pcs , statei = rename_vars ( pathi , statei ) <NEWLINE> if PRINT_MODE : <NEWLINE> <INDENT> print <STRING> + str ( set_of_pcs ) <NEWLINE> <DEDENT> if PRINT_MODE : <NEWLINE> <INDENT> print <STRING> + str ( i ) + <STRING> + str ( statei ) <NEWLINE> <DEDENT> if is_feasible ( set_of_pcs , statei , pathj ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> <DEDENT>
def feed_data ( self , data , size = 0 ) : <NEWLINE> <INDENT> has_waiter = self . _waiter is not None and not self . _waiter . cancelled ( ) <NEWLINE> super ( ) . feed_data ( data ) <NEWLINE> if ( not self . _stream . paused and <NEWLINE> <INDENT> not has_waiter and self . _buffer_size > self . _b_limit ) : <NEWLINE> try : <NEWLINE> self . _stream . transport . pause_reading ( ) <NEWLINE> except ( AttributeError , NotImplementedError ) : <NEWLINE> pass <NEWLINE> else : <NEWLINE> self . _stream . paused = True <NEWLINE> <DEDENT> <DEDENT>
def apply_key_map ( key_map , table ) : <NEWLINE> <INDENT> new_dict = { } <NEWLINE> for key in table <NEWLINE> <INDENT> new_key = key_map . get ( key ) <NEWLINE> if new_key : <NEWLINE> <INDENT> new_dict [ new_key ] = table . get ( key ) <NEWLINE> <DEDENT> <DEDENT> return new_dict <NEWLINE> <DEDENT>
def render ( i ) : <NEWLINE> <INDENT> rank , fil = divmod ( i - A1 , 10 ) <NEWLINE> return chr ( fil + ord ( <STRING> ) + str ( - rank + 1 ) <NEWLINE> <DEDENT>
def serialize_data_type ( data_type ) : <NEWLINE> <INDENT> if is_instance ( data_type , basestring ) or is_instance ( data_type , int ) <NEWLINE> <INDENT> return str ( data_type ) <NEWLINE> <DEDENT> <DEDENT>
def findUSB ( query ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> try : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> print ( _winreg . EnumKey ( query , c ) ) <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> except WindowsError : <NEWLINE> pass <NEWLINE> <DEDENT>
def sql_remove_table_constraints ( self , model , references_to_delete , style ) <NEWLINE> <INDENT> <STRING> <NEWLINE> return [ ] <NEWLINE> <DEDENT>
def test_equality ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . statement . add_response ( Statement ( <STRING> ) <NEWLINE> self . assertEqual ( len ( self . statement . in_response_to ) , 1 ) <NEWLINE> self . assertIn ( <NEWLINE> <INDENT> Statement ( <STRING> ) , <NEWLINE> self . statement . in_response_to <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def save_state ( self ) : <NEWLINE> <INDENT> if self . has_saved_state ( ) : <NEWLINE> <INDENT> raise RuntimeError , <STRING> <NEWLINE> <DEDENT> if os . environ . has_key ( <STRING> ) : <NEWLINE> <INDENT> self . x509_proxy_saved_state = os . environ [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . x509_proxy_saved_state = None <NEWLINE> <DEDENT> ProtoRequest . save_state ( self ) <NEWLINE> <DEDENT>
def options ( self , inject ) : <NEWLINE> <INDENT> options = { <NEWLINE> <INDENT> <STRING> : self . bucket , <NEWLINE> <STRING> : self . profile , <NEWLINE> <STRING> : self . region , <NEWLINE> <DEDENT> } <NEWLINE> if inject : <NEWLINE> <INDENT> for option , var in [ <NEWLINE> <INDENT> ( <STRING> , self . bucket_var ) , <NEWLINE> ( <STRING> , self . profile_var ) , <NEWLINE> ( <STRING> , self . region_var ) , <NEWLINE> ] : <NEWLINE> if var and var in inject : <NEWLINE> options [ option ] = inject [ var ] <NEWLINE> <DEDENT> <DEDENT> return options <NEWLINE> <DEDENT>
def print_version ( ) : <NEWLINE> <INDENT> print ( <STRING> . format ( Constants . APP_NAME , <NEWLINE> <INDENT> Constants . APP_VERSION , <NEWLINE> Constants . APP_AUTHOR ) ; <NEWLINE> <DEDENT> print ( Constants . APP_COPYRIGHT ) <NEWLINE> print <NEWLINE> <DEDENT>
def drawString ( dst , ( x , y ) , s ) : <NEWLINE> <INDENT> cv2 . putText ( dst , s , ( x + 1 , y + 1 ) , cv2 . FONT_HERSHEY_PLAIN , 1.0 , ( 0 , 0 , 0 ) , thickness = 2 , lineType = cv2 . CV_AA ) <NEWLINE> cv2 . putText ( dst , s , ( x , y ) , cv2 . FONT_HERSHEY_PLAIN , 1.0 , ( 255 , 255 , 255 ) , lineType = cv2 . CV_AA ) <NEWLINE> <DEDENT>
def __len__ ( self ) : <NEWLINE> <INDENT> if self . stop is None : <NEWLINE> <INDENT> raise TypeError ( <STRING> ) <NEWLINE> <DEDENT> if self . _has_neg_step : <NEWLINE> <INDENT> calc = self . start - self . stop <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> calc = self . stop - self . start <NEWLINE> <DEDENT> return int ( ceil ( abs ( calc . total_seconds ( ) / self . step . total_seconds ( ) ) ) <NEWLINE> <DEDENT>
def define_residuals ( self , model_name , residuals , residuals_dictionnary ) : <NEWLINE> <INDENT> keys = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> self . residuals [ model_name ] = collections . namedtuple ( <STRING> , keys ) <NEWLINE> values = [ residuals [ : , residuals_dictionnary [ <STRING> ] ] , <NEWLINE> <INDENT> residuals [ : , residuals_dictionnary [ <STRING> ] ] , <NEWLINE> residuals [ : , residuals_dictionnary [ <STRING> ] ] <NEWLINE> ] <NEWLINE> <DEDENT> count = 0 <NEWLINE> <INDENT> for key in keys : <NEWLINE> <INDENT> setattr ( self . residuals [ model_name ] , key , values [ count ] ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def getflags ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if self . flags : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> except AttributeError : <NEWLINE> <INDENT> self . flags = [ <STRING> ] <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> if self . cl . c_display : <NEWLINE> <INDENT> self . flags += [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT> except AttributeError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> if self . cl . g_display : <NEWLINE> <INDENT> self . flags += [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT> except AttributeError : <NEWLINE> pass <NEWLINE> <DEDENT>
def run_once ( self , test_path = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> os . environ [ <STRING> ] = <STRING> % ( test_path ) <NEWLINE> ret_val = subprocess . call ( test_path + <STRING> + <STRING> , shell = True ) <NEWLINE> if ret_val != 0 : <NEWLINE> <INDENT> self . nfail += 1 <NEWLINE> <DEDENT> <DEDENT> except error . CmdError , e : <NEWLINE> <INDENT> self . nfail += 1 <NEWLINE> logging . error ( <STRING> , e ) <NEWLINE> <DEDENT> <DEDENT>
def testDeviceWrapper ( self ) : <NEWLINE> <INDENT> with variable_scope . variable_scope ( <NEWLINE> <INDENT> <STRING> , initializer = init_ops . constant_initializer ( 0.5 ) ) : <NEWLINE> x = array_ops . zeros ( [ 1 , 3 ] ) <NEWLINE> m = array_ops . zeros ( [ 1 , 3 ] ) <NEWLINE> cell = core_rnn_cell_impl . DeviceWrapper ( <NEWLINE> <INDENT> core_rnn_cell_impl . GRUCell ( 3 ) , <STRING> ) <NEWLINE> outputs , _ = cell ( x , m ) <NEWLINE> self . assertTrue ( <STRING> in outputs . device . lower ( ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def assertCollection ( self , obj , observed ) : <NEWLINE> <INDENT> observed_json = json . loads ( observed ) <NEWLINE> for what , fn in [ ( <STRING> , self . assertKind ) , <NEWLINE> <INDENT> ( <STRING> , self . assertMixin ) , <NEWLINE> ( <STRING> , self . assertAction ) , <NEWLINE> ( <STRING> , self . assertLink ) , <NEWLINE> ( <STRING> , self . assertResource ) ] : <NEWLINE> objs = getattr ( obj , what ) <NEWLINE> if objs : <NEWLINE> dumped_objs = [ json . dumps ( o ) for o in observed_json [ what ] ] <NEWLINE> map ( fn , objs , dumped_objs ) <NEWLINE> <DEDENT> <DEDENT>
class Error ( Exception ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , msg , status = None ) <NEWLINE> <INDENT> Exception . __init__ ( self ) <NEWLINE> self . msg = msg <NEWLINE> self . resultcode = 1 <NEWLINE> if status is not None : <NEWLINE> <INDENT> self . resultcode = status <NEWLINE> <DEDENT> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return self . msg <NEWLINE> <DEDENT> <DEDENT>
def setStartPoint ( self , x , y ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> if not isinstance ( x , int ) and not isinstance ( y , int ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> self . __start_point = [ x , y ] <NEWLINE> return self <NEWLINE> <DEDENT> <DEDENT>
( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def add_polygon_rec ( self , node , new_segment ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . is_included ( new_segment , node . content ) : <NEWLINE> <INDENT> for child in sorted ( list ( node . alive_children . values ( ) ) , <NEWLINE> <INDENT> key = lambda c : c . height , reverse = True ) : <NEWLINE> if self . add_polygon_rec ( child , new_segment ) : <NEWLINE> return True <NEWLINE> <DEDENT> if node . is_polygon or new_segment . height == node . height : <NEWLINE> <INDENT> self . add_child_in_tree ( node , new_segment ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>
def setupRedLedOff ( self ) : <NEWLINE> <INDENT> imRedLedOffTk = ImageTk . PhotoImage ( Image . open ( <STRING> ) ) <NEWLINE> label1 = Label ( Tk , image = imRedLedOffTk ) <NEWLINE> label1 . image = imRedLedOffTk <NEWLINE> label1 . place ( x = 180 , y = 20 ) <NEWLINE> try <NEWLINE> <INDENT> bus . write ( <STRING> ) <NEWLINE> bus . close ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> bus . close ( ) <NEWLINE> <DEDENT> raise <NEWLINE> <DEDENT>
def push_args ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return ( <STRING> % { <NEWLINE> <INDENT> <STRING> : <STRING> if self . force else <STRING> , <NEWLINE> <STRING> : self . source , <NEWLINE> <STRING> : self . target <NEWLINE> <DEDENT> <DEDENT>
def stop ( self ) : <NEWLINE> <INDENT> if not self . pid : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> os . kill ( self . pid , signal . SIGTERM ) <NEWLINE> <INDENT> os . waitpid ( self . pid , 0 ) <NEWLINE> <DEDENT> <DEDENT> except Exception , e : <NEWLINE> <INDENT> print ( <STRING> , e ) <NEWLINE> pass <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT>
class FakeFeedParser ( dict ) : <NEWLINE> <INDENT> def __init__ ( self , uri , etag = None , modified = None ) : <NEWLINE> <INDENT> self . update ( dict ( <NEWLINE> <INDENT> uri = uri , <NEWLINE> bozo = 0 , <NEWLINE> feed = FakeParsedFeed ( <STRING> ) , <NEWLINE> entries = [ <NEWLINE> <INDENT> FakeParsedEntry ( name ) for name in <STRING> , <STRING> , <STRING> , <STRING> ] , <NEWLINE> <DEDENT> status = 304 if etag else 200 , <NEWLINE> etag = etag , <NEWLINE> modified = modified , <NEWLINE> ) ) <NEWLINE> <DEDENT> <DEDENT> def __getattr__ ( self , name ) : <NEWLINE> <INDENT> return self [ name ] <NEWLINE> <DEDENT> <DEDENT>
def value ( self , value ) : <NEWLINE> <INDENT> if isinstance ( value , ( six . string_types , six . integer_types , float , bool ) : <NEWLINE> <INDENT> self . _value = value <NEWLINE> <DEDENT> <DEDENT>
def parse_nodename ( nodename ) : <NEWLINE> <INDENT> global NODE_EXPR <NEWLINE> parts = re . search ( <STRING> % NODE_EXPR , nodename , re . VERBOSE ) <NEWLINE> try : <NEWLINE> <INDENT> racknr = parts . group ( <STRING> ) <NEWLINE> <DEDENT> except Exception : <NEWLINE> racknr = 0 <NEWLINE> try : <NEWLINE> <INDENT> nodenr = parts . group ( <STRING> ) <NEWLINE> <DEDENT> except Exception : <NEWLINE> <INDENT> nodenr = 0 <NEWLINE> <DEDENT> return int ( racknr ) , int ( nodenr ) <NEWLINE> <DEDENT>
def test_distance_mi ( self , precision = 3 ) : <NEWLINE> <INDENT> index = GeoGridIndex ( precision = precision ) <NEWLINE> map ( index . add_point , self . points ) <NEWLINE> for pt , distance in index . get_nearest_points ( <NEWLINE> <INDENT> self . point_1bluxome , 10 , <STRING> ) : <NEWLINE> if pt == self . point_1bluxome : <NEWLINE> self . assertEquals ( distance , 0 ) <NEWLINE> if pt == self . point_market_street : <NEWLINE> self . assertEquals ( distance , 0.808573403337458 ) <NEWLINE> <DEDENT> <DEDENT>
def help_query ( self ) : <NEWLINE> <INDENT> print ( _ ( <STRING> ) <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> print <NEWLINE> print ( _ ( <STRING> ) ) <NEWLINE> <DEDENT>
def read_file ( option , opt , value , parser ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> with open ( value ) as f : <NEWLINE> <INDENT> setattr ( parser . values , option . dest , f . read ( ) ) <NEWLINE> <DEDENT> <DEDENT> except Exception , e : <NEWLINE> <INDENT> raise OptionValueError ( <STRING> % <NEWLINE> <INDENT> ( value , opt , e ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_tx_confirmations ( self , txhash ) : <NEWLINE> <INDENT> url = <STRING> % ( self . net_prefix , txhash ) <NEWLINE> try : <NEWLINE> <INDENT> resp = json . loads ( urllib2 . urlopen ( url ) . read ( ) <NEWLINE> if resp [ <STRING> ] == <STRING> : <NEWLINE> <INDENT> return resp [ <STRING> ] [ <STRING> ] [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT>
def _duplicateQualityChangesForMachineType ( self , quality_changes_name , base_name , machine_definition ) : <NEWLINE> <INDENT> new_change_instances = [ ] <NEWLINE> for container in QualityManager . getInstance ( ) . findQualityChangesByName ( quality_changes_name , <NEWLINE> <INDENT> machine_definition ) : <NEWLINE> base_id = container . getMetaDataEntry ( <STRING> ) <NEWLINE> if not base_id : <NEWLINE> base_id = container . getDefinition ( ) . getId ( ) <NEWLINE> new_unique_id = self . _createUniqueId ( base_id , base_name ) <NEWLINE> new_container = container . duplicate ( new_unique_id , base_name ) <NEWLINE> new_change_instances . append ( new_container ) <NEWLINE> self . _container_registry . addContainer ( new_container ) <NEWLINE> <DEDENT> return new_change_instances <NEWLINE> <DEDENT>
def sentence_word_order_vector ( s , joint_word_set ) : <NEWLINE> <INDENT> s_words = re . sub ( <STRING> , <STRING> , s1 ) . split ( ) <NEWLINE> wov = [ 0 ] * len ( joint_word_set ) <NEWLINE> for i in range ( 0 , len ( joint_word_set ) ) <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> index = s_words . index ( joint_word_set [ i ] ) <NEWLINE> wov [ i ] = index <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> index = word_semantic_similarity ( joint_word_set [ i ] , s ) [ 2 ] <NEWLINE> wov [ i ] = index <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def dss_command ( self , command ) : <NEWLINE> <INDENT> self . ser . flushInput ( ) <NEWLINE> command . insert ( 0 , self . options [ <STRING> ] ) <NEWLINE> while len ( command ) > 0 : <NEWLINE> <INDENT> a = command . pop ( 0 ) <NEWLINE> if debug : <NEWLINE> <INDENT> print <STRING> + str ( a ) <NEWLINE> <DEDENT> self . ser . write ( chr ( a ) ) <NEWLINE> <DEDENT> return self . __get_reply ( ) <NEWLINE> <DEDENT>
class Mixin ( category . Category ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , scheme , term , title , attributes = None , location = None , <NEWLINE> <INDENT> related = [ ] , actions = [ ] ) : <NEWLINE> super ( Mixin , self ) . __init__ ( scheme , term , title , attributes = attributes , <NEWLINE> <INDENT> location = location ) <NEWLINE> helpers . check_type ( related , Mixin ) <NEWLINE> helpers . check_type ( actions , action . Action ) <NEWLINE> self . related = related <NEWLINE> self . actions = actions <NEWLINE> <DEDENT> <DEDENT> def _class_name ( self ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT>
def replace_astral ( log_list ) : <NEWLINE> <INDENT> for item in log_list : <NEWLINE> <INDENT> for key in [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ] : <NEWLINE> if key in item : <NEWLINE> item [ key ] = astral_filter ( item [ key ] ) <NEWLINE> <DEDENT> yield item <NEWLINE> <DEDENT> <DEDENT>
def stop ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not self . conexion_status : <NEWLINE> <INDENT> raise Exception , <STRING> <NEWLINE> <DEDENT> reply = self . send_and_receive ( <STRING> ) <NEWLINE> self . _debug ( reply ) <NEWLINE> if reply == <STRING> : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT>
def worker_kill ( self , pid , sig ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> os . kill ( pid , sig ) <NEWLINE> <DEDENT> except OSError , e : <NEWLINE> <INDENT> if e . errno == errno . ESRCH : <NEWLINE> <INDENT> self . worker_pop ( pid ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def all_checked ( self ) : <NEWLINE> <INDENT> amber = Status . query . filter ( Status . status_name == <STRING> ) . first ( ) <NEWLINE> green = Status . query . filter ( Status . status_name == <STRING> ) . first ( ) <NEWLINE> return self . filter ( or_ ( Version . statuses == amber , Version . statuses == green ) ) . filter ( Version . checked == True ) . order_by ( Version . version_number . desc ( ) ) ] <NEWLINE> <DEDENT>
def Dot ( self , vector ) : <NEWLINE> <INDENT> dotProduct = 0.0 f <NEWLINE> dotProduct += self . _x * vector . x <NEWLINE> dotProduct += self . _y * vector . y <NEWLINE> dotProduct += self . _z * vector . z <NEWLINE> return dotProduct <NEWLINE> <DEDENT>
def find_goroutine ( goid ) : <NEWLINE> <INDENT> vp = gdb . lookup_type ( <STRING> ) . pointer ( ) <NEWLINE> for ptr in linked_list ( gdb . parse_and_eval ( <STRING> ) , <STRING> ) : <NEWLINE> <INDENT> if ptr [ <STRING> ] == 6 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ptr [ <STRING> ] == goid : <NEWLINE> <INDENT> return [ ptr [ <STRING> ] [ x ] . cast ( vp ) for x in <STRING> , <STRING> ] <NEWLINE> <DEDENT> <DEDENT> return None , None <NEWLINE> <DEDENT>
def retranslateUi ( self , SynoptiquesAtlas ) : <NEWLINE> <INDENT> SynoptiquesAtlas . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lblComp . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lblOverlap . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . lblOutDir . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def get_posts_count ( user ) : <NEWLINE> <INDENT> return r . table ( <STRING> ) <NEWLINE> <INDENT> . filter ( lambda post : post . user_id == user . age } ) <NEWLINE> . count ( ) <NEWLINE> <DEDENT> <DEDENT>
def retranslateUi ( self , EricdocExecDialog ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> EricdocExecDialog . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . messagesGroup . setTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . contents . setWhatsThis ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def euclidean_distance ( v1 , v2 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> sub = [ ] <NEWLINE> for i , f in enumerate ( v1 ) : <NEWLINE> <INDENT> sub . append ( math . pow ( ( v1 [ i ] - v2 [ i ] ) , 2 ) <NEWLINE> <DEDENT> dist = math . sqrt ( sum ( sub ) ) <NEWLINE> return dist <NEWLINE> <DEDENT>
import sys <NEWLINE> import antlr <NEWLINE> import SimpleLexer5 <NEWLINE> import LexerTester <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> lexer = SimpleLexer5 . Lexer ( sys . stdin ) <NEWLINE> parser = LexerTester . Parser ( lexer ) <NEWLINE> parser . setFilename ( <STRING> ) <NEWLINE> parser . source_text ( ) <NEWLINE> except antlr . TokenStreamException , e : <NEWLINE> sys . stderr . write ( <STRING> + str ( e ) + <STRING> ) <NEWLINE> except antlr . RecognitionException , e : <NEWLINE> sys . stderr . write ( <STRING> + str ( e ) + <STRING> ) <NEWLINE> <DEDENT>
def gen ( ( a , b , c ) ) : <NEWLINE> <INDENT> if b != 0 : <NEWLINE> <INDENT> pts = [ ( 0 , - c / b ) , ( 1 , ( - c - 1 ) / b ) ] <NEWLINE> <DEDENT> elif a != 0 : <NEWLINE> <INDENT> pts = [ ( - c / a , 0 ) , ( ( - c - 1 ) / a , 1 ) ] <NEWLINE> <DEDENT> return pts <NEWLINE> <DEDENT>
def __init__ ( self , * args , ** kwargs ) <NEWLINE> <INDENT> super ( LuckyshopsSider , self ) . __init__ ( * args , ** kwargs ) <NEWLINE> settings . set ( <STRING> , [ 500 , 503 , 504 , 400 , 408 , 404 ] ) <NEWLINE> settings . set ( <STRING> , 5 ) <NEWLINE> settings . set ( <STRING> , True ) <NEWLINE> settings . set ( <STRING> , True ) <NEWLINE> settings . set ( <STRING> , <STRING> ) <NEWLINE> <DEDENT>
( <NEWLINE> <INDENT> textwrap . dedent ( <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> op . drop_constraint ( <STRING> , <STRING> , type_ = None ) <NEWLINE> op . drop_column ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> alembic_ag_api . render_python_code ( contract . upgrade_ops ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def _getName ( self ) : <NEWLINE> <INDENT> name = re . search ( self . PATTERN_FILENAME , self . html ) <NEWLINE> if name is None : <NEWLINE> <INDENT> self . fail ( _ ( <STRING> ) <NEWLINE> <DEDENT> return name . group ( 1 ) <NEWLINE> <DEDENT>
( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def hello ( request ) : <NEWLINE> <INDENT> from django . db import connection , transaction <NEWLINE> cursor = connection . cursor ( ) <NEWLINE> query = <STRING> <NEWLINE> queryList = [ ( <STRING> , <STRING> ) ] <NEWLINE> cursor . executemany ( query , queryList ) <NEWLINE> transaction . commit ( ) <NEWLINE> <INDENT> return HttpResponse ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def product_review_row ( product , admin_type ) : <NEWLINE> <INDENT> rating_subjects = [ subject [ 1 ] for subject in Rating . SUBJECT_OPTIONS ] <NEWLINE> return { <STRING> : product , <NEWLINE> <INDENT> <STRING> : rating_subjects <NEWLINE> <STRING> : range ( 1 , 6 ) , <NEWLINE> <STRING> : admin_type <NEWLINE> } <NEWLINE> <DEDENT> <DEDENT>
( _ ( <STRING> <NEWLINE> <DEDENT>
def test_int_input ( self ) : <NEWLINE> <INDENT> self . assertEqual ( io . input_value ( <STRING> , default_value = 1 , prompt_fn = lambda ( m ) : <STRING> ) , 123 ) <NEWLINE> self . assertRaises ( ValueError , io . input_value , <STRING> , default_value = 1 , prompt_fn = lambda ( m ) : <STRING> ) <NEWLINE> <DEDENT>
def rename ( self , fromname , toname ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> resp = self . sendcmd ( <STRING> + fromname ) <NEWLINE> if resp [ 0 ] != <STRING> : <NEWLINE> <INDENT> raise error_reply , resp <NEWLINE> <DEDENT> return self . voidcmd ( <STRING> + toname ) <NEWLINE> <DEDENT>
def test__publish_event_async ( self ) : <NEWLINE> <INDENT> body = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> event_type = <STRING> <NEWLINE> with patch ( <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> ) as m_publish_event_async : <NEWLINE> self . result = self . target . _publish_event_async ( event_type , <NEWLINE> <INDENT> body ) <NEWLINE> m_publish_event_async . assert_called_one_with ( self . ObkectId , <NEWLINE> event_type , <NEWLINE> body ) <NEWLINE> self . assertNotEqual ( self . result , None ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def initGPIO ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> global haveGPIO <NEWLINE> pinNo = self . cfg . getConfigInt ( <STRING> ) <NEWLINE> self . pinNo = pinNo <NEWLINE> if ( self . debug ) : print <STRING> % pinNo <NEWLINE> if ( haveGPIO ) : <NEWLINE> <INDENT> GPIO . setmode ( GPIO . BCM ) <NEWLINE> GPIO . setup ( pinNo , GPIO . IN , pull_up_down = GPIO . PUD_UP ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> self . moveCamera ( 1 ) <NEWLINE> <DEDENT> self . lastButtonVal = 1 <NEWLINE> self . lastButtonTime = time . time ( ) <NEWLINE> <DEDENT>
def test_abort ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> def __time_cb ( ) : <NEWLINE> <INDENT> raise NotImplementedError , <STRING> <NEWLINE> <DEDENT> event . timeout ( 5 , __time_cb ) <NEWLINE> event . timeout ( 1 , event . abort ) <NEWLINE> event . dispatch ( ) <NEWLINE> <DEDENT>
def ensure_env_vars ( ) : <NEWLINE> <INDENT> for var in [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ] : <NEWLINE> if var not in environ : <NEWLINE> sys . exit ( <STRING> + var + <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def do_transmit ( self line ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . api_access is not None : <NEWLINE> <INDENT> self . api_access . send ( self . api_access . create ( line ) ) <NEWLINE> <DEDENT> <DEDENT>
def aiff ( self ) : <NEWLINE> <INDENT> if self . _nframeswritten : <NEWLINE> <INDENT> raise Error , <STRING> <NEWLINE> <DEDENT> self . _aifc = 0 <NEWLINE> <DEDENT>
def _get_and_create_snapshots_dir ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> snapshots_dir = os . path . join ( <NEWLINE> <INDENT> self . _config . file_server_root <NEWLINE> FILE_SERVER_SNAPSHOTS_FOLDER <NEWLINE> <DEDENT> ) <NEWLINE> if not os . path . exists ( snapshots_dir ) : <NEWLINE> <INDENT> os . makedirs ( snapshots_dir ) <NEWLINE> <DEDENT> return snapshots_dir <NEWLINE> <DEDENT>
def printResult ( classification ) : <NEWLINE> <INDENT> if classification == 0 : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
def serviceInterruptRain ( self , channel ) : <NEWLINE> <INDENT> currentTime = ( micros ( ) - SDL_Pi_Weather_80422 . _lastRainTime ) ; <NEWLINE> SDL_Pi_Weather_80422 . _lastRainTime = micros ( ) ; <NEWLINE> if ( currentTime > 500 ) : <NEWLINE> <INDENT> SDL_Pi_Weather_80422 . _currentRainCount = SDL_Pi_Weather_80422 . _currentRainCount + 1 <NEWLINE> if ( currentTime < SDL_Pi_Weather_80422 . _currentRainMin ) : <NEWLINE> SDL_Pi_Weather_80422 . _currentRainMin = currentTime ; <NEWLINE> <DEDENT> <DEDENT>
class string_loop_item ( DVBobject ) : <NEWLINE> <INDENT> def pack ( self ) : <NEWLINE> assert len ( self . ISO639_language_code ) == 3 <NEWLINE> data_bytes = string . join ( <NEWLINE> map ( lambda x : x . pack ( ) , <NEWLINE> self . segment_loop ) , <NEWLINE> <STRING> ) <NEWLINE> self . number_segments = len ( self . segment_loop ) <NEWLINE> fmt = <STRING> % ( len ( self . ISO639_language_code ) , len ( data_bytes ) ) <NEWLINE> return pack ( fmt , <NEWLINE> self . ISO639_language_code , <NEWLINE> self . number_segments , <NEWLINE> data_bytes <NEWLINE> ) <NEWLINE> <DEDENT>
def __set_year_and_month ( self , ( y , m ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . __current_month != m or self . __current_year != y : <NEWLINE> <INDENT> self . __current_month = m if 1 <= m <= 12 else datetime . now ( ) . month <NEWLINE> self . __current_year = y if 1900 <= y else datetime . now ( ) . year <NEWLINE> self . __reload_events ( ) <NEWLINE> <DEDENT> <DEDENT>
def render_helprequest_as_html ( fooditem ) : <NEWLINE> <INDENT> return render_template ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> transactions = reversed ( list ( enumerate ( TRANSACTION ) ) ) <NEWLINE> <DEDENT> <DEDENT>
( <STRING> when others = > fb_a_dat_in <= x <STRING> <NEWLINE> <DEDENT> <DEDENT> index += 1 <NEWLINE> col += 1 <NEWLINE> <DEDENT> <DEDENT>
def hover ( self , ( width , height ) , ( posx , posy ) ) : <NEWLINE> <INDENT> posx1 , posy1 = pygame . mouse . get_pos ( ) <NEWLINE> if ( posx1 >= posx - width and posx1 <= ( posx + width ) ) and ( posy1 >= posy - height and posy1 <= ( posy + height ) ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
def run ( self , args , opts ) : <NEWLINE> <INDENT> spider_loader = self . crawler_process . spider_loader <NEWLINE> for spidername in args or spider_loader . list ( ) : <NEWLINE> <INDENT> print ( <STRING> + spidername ) <NEWLINE> self . crawler_process . crawl ( spidername , ** opts . spargs ) <NEWLINE> <INDENT> self . crawler_process . start ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from . . activation import EndActivation <NEWLINE> from . import base <NEWLINE> class End ( base . TaskDescriptionMixin , <NEWLINE> <INDENT> base . DetailsViewMixin , <NEWLINE> base . UndoViewMixin , <NEWLINE> base . CancelViewMixin , <NEWLINE> base . PerformViewMixin , <NEWLINE> base . Event ) : <NEWLINE> <STRING> <NEWLINE> task_type = <STRING> <NEWLINE> activation_cls = EndActivation <NEWLINE> def __init__ ( self , ** kwargs ) : <NEWLINE> super ( End , self ) . __init__ ( ** kwargs ) <NEWLINE> def _outgoing ( self ) : <NEWLINE> return iter ( [ ] ) <NEWLINE> <DEDENT>
def check_pattern ( ( s , p , o ) ) : <NEWLINE> <INDENT> if s and not ( isinstance ( s , URIRef ) or isinstance ( s , BNode ) ) : <NEWLINE> <INDENT> raise SubjectTypeError ( s ) <NEWLINE> <DEDENT> if p and not isinstance ( p , URIRef ) : <NEWLINE> <INDENT> raise PredicateTypeError ( p ) <NEWLINE> <DEDENT> if o and not ( isinstance ( o , URIRef ) or isinstance ( o , Literal ) or isinstance ( o , BNode ) ) : <NEWLINE> <INDENT> raise ObjectTypeError ( o ) <NEWLINE> <DEDENT> <DEDENT>
def set_topleft ( self , ( x , y ) ) : <NEWLINE> <INDENT> self . r . x = int ( x ) <NEWLINE> self . r . y = int ( y ) <NEWLINE> <DEDENT>
def readme ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for x in self . blob_ids : <NEWLINE> <INDENT> if README_RE . match ( x . name ) : <NEWLINE> <INDENT> name = x . name <NEWLINE> blob = self [ name ] <NEWLINE> return ( x . name , h . really_unicode ( blob . text ) ) ) <NEWLINE> <DEDENT> <DEDENT> return None , None <NEWLINE> <DEDENT>
( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def putline ( self , line ) : <NEWLINE> <INDENT> line = line + CRLF <NEWLINE> if self . debugging > 1 : <NEWLINE> <INDENT> print <STRING> , self . sanitize ( line ) <NEWLINE> <DEDENT> self . sock . sendall ( line ) <NEWLINE> <DEDENT>
def get_version ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> return ( self . run_gpstart_cmd ( version = <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT>
def has_perm ( cls , user , permission ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return user . has_perm ( cls . perm_name ( permission ) <NEWLINE> <DEDENT>
( <STRING> , <NEWLINE> for j in xrange ( c ) : <NEWLINE> <INDENT> if left_digits != None : <NEWLINE> <INDENT> d = left_digits [ 0 , j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = 0 <NEWLINE> <DEDENT> fmt = ( <STRING> + <NEWLINE> <INDENT> str ( d + digits + 1 ) + <NEWLINE> <STRING> + str ( digits ) + <STRING> ) <NEWLINE> <DEDENT> print ( fmt % v [ j ] ) , <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def load_printer ( self , name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> serial = cbpos . config [ <STRING> , <STRING> + name ] <NEWLINE> if serial is None : <NEWLINE> <INDENT> raise InvalidPrinterName , <STRING> <NEWLINE> <DEDENT> printer = Printer ( name , serial ) <NEWLINE> return printer <NEWLINE> <DEDENT>
def keys_to_output ( keys ) : <NEWLINE> <INDENT> output = [ 0 , 0 , 0 ] <NEWLINE> if <STRING> in keys : <NEWLINE> <INDENT> output [ 0 ] = 1 <NEWLINE> <DEDENT> elif <STRING> in keys : <NEWLINE> <INDENT> output [ 2 ] = 1 <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> output [ 1 ] = 1 <NEWLINE> <DEDENT> return output <NEWLINE> <DEDENT>
def get ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return g . node . GET ( node = request . args . get ( <STRING> , None ) <NEWLINE> <DEDENT>
def index ( ) : <NEWLINE> <INDENT> contexto = { <STRING> router . to_path ( salvar ) } <NEWLINE> return TemplateResponse ( contexto ) ; <NEWLINE> <DEDENT>
def test_authenticated ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( self . dbapi , <STRING> , <NEWLINE> <INDENT> autospec = True ) as mock_get_node : <NEWLINE> mock_get_node . return_value = self . fake_db_node <NEWLINE> response = self . get_json ( self . node_path , <NEWLINE> <INDENT> headers = { <STRING> : utils . ADMIN_TOKEN } ) <NEWLINE> self . assertEqual ( self . fake_db_node [ <STRING> ] , response [ <STRING> ] ) <NEWLINE> mock_get_node . assert_called_once_with ( self . fake_db_node [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_missing_trailing_slash ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . _execute ( <STRING> , <STRING> , [ ] , True ) <NEWLINE> self . fail ( ) <NEWLINE> <DEDENT> except subprocess . CalledProcessError , e : <NEWLINE> <INDENT> out = e . output <NEWLINE> <DEDENT> self . _expect_no_tree ( ) <NEWLINE> self . _expect_no_result ( ) <NEWLINE> expected = <STRING> % os . path . join ( <NEWLINE> <INDENT> ROOT_DIR , <STRING> , <STRING> , <STRING> ) <NEWLINE> <DEDENT> self . assertEquals ( expected , out ) <NEWLINE> <DEDENT>
def addperm ( self , sender , res = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> lsender = sender . lower ( ) <NEWLINE> if self . has_key ( lsender ) : <NEWLINE> <INDENT> ts , res = self . cache [ lsender ] <NEWLINE> if not ts : return <NEWLINE> <DEDENT> self . cache [ lsender ] = ( None , res ) <NEWLINE> if not res : <NEWLINE> <INDENT> print ( <STRING> ) , sender ) <NEWLINE> <DEDENT> <DEDENT>
class InstallAndUpdateDataDirectory ( DistUtilsExtra . auto . install_auto ) : <NEWLINE> <INDENT> def run ( self ) : <NEWLINE> <INDENT> values = { <STRING> : <STRING> % ( self . prefix + <STRING> ) <NEWLINE> <INDENT> <STRING> : <STRING> % ( self . distribution . get_version ( ) ) } <NEWLINE> <DEDENT> previous_values = update_config ( values ) <NEWLINE> DistUtilsExtra . auto . install_auto . run ( self ) <NEWLINE> update_config ( previous_values ) <NEWLINE> <DEDENT> <DEDENT>
def get_project_data ( self ) : <NEWLINE> <INDENT> if self . _project_data is None : <NEWLINE> <INDENT> if not os . path . exists ( self . path ( ) ) : <NEWLINE> <INDENT> logging . info ( <STRING> ) <NEWLINE> logging . info ( self . path ( ) <NEWLINE> return None <NEWLINE> <DEDENT> project_file = open ( self . path ( ) , <STRING> ) <NEWLINE> self . _project_data = project_file . read ( ) <NEWLINE> <DEDENT> return self . _project_data <NEWLINE> <DEDENT>
def run ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if ( ( timeit . default_timer ( ) - self . starttime ) <= 10 and <NEWLINE> <DEDENT> <DEDENT>
def save_maxvel_pref ( self ) : <NEWLINE> <INDENT> self . prefs . putpref ( <STRING> , self . mv_val , int ) <NEWLINE> def postgui ( self ) : <NEWLINE> postgui_halfile = self . ini . find ( <STRING> , <STRING> ) <NEWLINE> return postgui_halfile , sys . argv [ 2 ] <NEWLINE> <DEDENT>
( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def unproject ( self , ( x , y ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> lng = x / EARTH_RADIUS * RAD_TO_DEG <NEWLINE> lat = 2 * atan ( exp ( y / EARTH_RADIUS ) ) - pi / 2 * RAD_TO_DEG <NEWLINE> return ( lng , lat ) <NEWLINE> <DEDENT>
def allowed ( self , request , instance = None ) : <NEWLINE> <INDENT> return ( ( instance . status in ACTIVE_STATES <NEWLINE> <INDENT> or instance . status == <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def handle_token ( tokenType , token , ( startRow , startCol ) , ( endRow , endCol ) , line ) : <NEWLINE> <INDENT> global useCounts <NEWLINE> if tokenize . tok_name [ tokenType ] == <STRING> : <NEWLINE> <INDENT> for obj in useCounts : <NEWLINE> <INDENT> useCounts [ obj ] += str ( token ) . count ( <STRING> % obj ) <NEWLINE> useCounts [ obj ] += str ( token ) . count ( <STRING> % obj ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def setCommand ( self , cmd ) <NEWLINE> <INDENT> if self . showDebug : <NEWLINE> <INDENT> self . setInfo ( <STRING> + cmd + <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class ServerGroupSoftAffinityWeigher ( _SoftAffinityWeigherBase ) : <NEWLINE> <INDENT> policy_name = <STRING> <NEWLINE> warning_sent = False <NEWLINE> def weight_multiplier ( self ) : <NEWLINE> <INDENT> if ( CONF . soft_affinity_weight_multiplier < 0 and <NEWLINE> <INDENT> not self . warning_sent ) : <NEWLINE> LOG . warn ( _LW ( <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) ) <NEWLINE> self . warning_sent = True <NEWLINE> <DEDENT> <DEDENT> return CONF . soft_affinity_weight_multiplier <NEWLINE> <DEDENT> <DEDENT>
def sign_request ( self , web_resource ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . permission_set : <NEWLINE> <INDENT> for shared_access_signature in self . permission_set : <NEWLINE> <INDENT> if self . _permission_matches_request ( shared_access_signature , web_resource , <NEWLINE> <INDENT> web_resource . properties [ SIGNED_RESOURCE_TYPE ] , <NEWLINE> web_resource . properties [ SHARED_ACCESS_PERMISSION ] ) : <NEWLINE> if web_resource . request_url . find ( <STRING> ) == - 1 : <NEWLINE> web_resource . request_url += <STRING> <NEWLINE> else : <NEWLINE> web_resource . request_url += <STRING> <NEWLINE> web_resource . request_url += self . _convert_query_string ( shared_access_signature . query_string ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return web_resource <NEWLINE> <DEDENT>
def diff ( self , other ) : <NEWLINE> <INDENT> for t in Event . terms : <NEWLINE> <INDENT> if not self . has_key ( t ) or not other . has_key ( t ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if not self . compare_data ( self [ t ] , other [ t ] ) : <NEWLINE> log . warning ( <STRING> % ( t , self [ t ] , other [ t ] ) ) <NEWLINE> <DEDENT> <DEDENT>
def _handleAuthenticate ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> client_id = self . flattr . customer_key <NEWLINE> if client_id : <NEWLINE> <INDENT> callback_uri = <STRING> % self . context . absolute_url ( ) <NEWLINE> self . request . response . redirect ( <STRING> <NEWLINE> <INDENT> <STRING> % ( <NEWLINE> <INDENT> self . flattr . authorize_url , <NEWLINE> callback_uri , <NEWLINE> client_id ) <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> IStatusMessage ( self . request ) . add ( _ ( <STRING> <NEWLINE> <INDENT> <STRING> ) , <NEWLINE> type = <STRING> ) <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
def test_016_disconnect_output ( self ) : <NEWLINE> <INDENT> hblock = gr . hier_block2 ( <STRING> , <NEWLINE> <INDENT> gr . io_signature ( 1 , 1 , gr . sizeof_int ) , <NEWLINE> gr . io_signature ( 1 , 1 , gr . sizeof_int ) ) <NEWLINE> <DEDENT> nop1 = blocks . nop ( gr . sizeof_int ) <NEWLINE> hblock . connect ( nop1 , hblock ) <NEWLINE> <INDENT> hblock . disconnect ( nop1 , hblock ) <NEWLINE> <DEDENT> <DEDENT>
def get_emails ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> regex = re . compile ( ( <STRING> <NEWLINE> <DEDENT>
def retranslateUi ( self , Form ) : <NEWLINE> <INDENT> Form . setWindowTitle ( _ ( <STRING> ) ) <NEWLINE> self . mm_label . setText ( _ ( <STRING> ) ) <NEWLINE> self . opt_manage_device_metadata . setItemText ( 0 , _ ( <STRING> ) ) <NEWLINE> self . opt_manage_device_metadata . setItemText ( 1 , _ ( <STRING> ) ) <NEWLINE> self . opt_manage_device_metadata . setItemText ( 2 , _ ( <STRING> ) ) <NEWLINE> self . label_41 . setText ( _ ( <STRING> <NEWLINE> <DEDENT>
def register_template_library ( package_name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not django . template . libraries . get ( package_name , None ) : <NEWLINE> django . template . add_to_builtins ( package_name ) <NEWLINE> <DEDENT>
def disconnect ( self ) : <NEWLINE> <INDENT> self . remove_listeners ( ) <NEWLINE> self . _last_track = None <NEWLINE> self . _clip_record_slot = None <NEWLINE> <INDENT> self . _midi_clip_length_slot = None <NEWLINE> <DEDENT> self . _parent = None <NEWLINE> if IS_LIVE_9 : <NEWLINE> <INDENT> ControlSurfaceComponent . disconnect ( self ) <NEWLINE> <DEDENT> <DEDENT>
class MaxPool1D ( _Pooling ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , pool_size = 2 , strides = None , padding = 0 , layout = <STRING> , <NEWLINE> <INDENT> ceil_mode = False , ** kwargs ) : <NEWLINE> assert layout == <STRING> , <STRING> <NEWLINE> if isinstance ( pool_size , numeric_types ) : <NEWLINE> pool_size = ( pool_size , ) <NEWLINE> assert len ( pool_size ) == 1 , <STRING> <NEWLINE> super ( MaxPool1D , self ) . __init__ ( <NEWLINE> pool_size , strides , padding , ceil_mode , False , <STRING> , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT>
def _get_instance_health ( self , lb ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> status = lb . get_instance_health ( [ self . instance_id ] ) [ 0 ] <NEWLINE> <DEDENT> except boto . exception . BotoServerError , e : <NEWLINE> <INDENT> if e . error_code == <STRING> : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> <DEDENT> return status <NEWLINE> <DEDENT>
def docycle ( iterations = 10000 , experiments = 10000 ) : <NEWLINE> <INDENT> step = pi * sqrt ( 2 ) <NEWLINE> for i in xrange ( experiments ) : <NEWLINE> sum = 0 <NEWLINE> x = 0 <NEWLINE> for j in xrange ( experiments ) : <NEWLINE> <INDENT> x += step <NEWLINE> sum += cos ( x ) <NEWLINE> <DEDENT> <DEDENT>
def pull_states ( tis ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> for idx in xrange ( tis . config [ <STRING> ] ) : <NEWLINE> state = State ( tis , idx ) <NEWLINE> state . pull_disk ( ) <NEWLINE> state . rollup ( ) <NEWLINE> res . append ( state ) <NEWLINE> return res <NEWLINE> <DEDENT>
def test_manual_true ( ) : <NEWLINE> <INDENT> assert integrate ( exp ( x ) * sin ( x ) , x , manual = True ) == ( exp ( x ) * sin ( x ) ) ) / 2 - ( exp ( x ) * cos ( x ) ) / 2 <NEWLINE> assert integrate ( sin ( x ) * cos ( x ) , x , manual = True ) in [ sin ( x ) ** 2 / 2 , - cos ( x ) ** 2 / 2 ] <NEWLINE> <DEDENT>
def _ProcessNewPreferences ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> modified = False <NEWLINE> for pref in ( launcher . Preferences . PREF_PYTHON , <NEWLINE> <INDENT> launcher . Preferences . PREF_APPENGINE , <NEWLINE> launcher . Preferences . PREF_DEPLOY_SERVER , <NEWLINE> launcher . Preferences . PREF_EDITOR ) : <NEWLINE> oldval = self . _preferences . Get ( pref ) <NEWLINE> newval = self . _dialog . Get ( pref ) <NEWLINE> if newval != oldval : <NEWLINE> modified = True <NEWLINE> self . _preferences [ pref ] = newval <NEWLINE> <DEDENT> if modified and hasattr ( self . _preferences , <STRING> ) : <NEWLINE> <INDENT> self . _preferences . Save ( ) <NEWLINE> <DEDENT> <DEDENT>
import sublime_plugin <NEWLINE> class AwesomeFooCommand ( sublime_plugin . ApplicationCommand ) <NEWLINE> <INDENT> <STRING> <NEWLINE> def run ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def _get_index_of_data ( self , fact ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return self . database . index ( fact ) <NEWLINE> <DEDENT> except ValueError as ve : <NEWLINE> <INDENT> if <STRING> in str ( self . type_son ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def _update_table_constraints ( table , distribution_column ) : <NEWLINE> <INDENT> for c in table . constraints : <NEWLINE> <INDENT> if ( isinstance ( c , PrimaryKeyConstraint ) or <NEWLINE> <INDENT> isinstance ( c , UniqueConstraint ) ) : <NEWLINE> if distribution_column not in c . columns : <NEWLINE> c . columns . add ( table . columns [ distribution_column ] ) <NEWLINE> <DEDENT> <DEDENT> return table <NEWLINE> <DEDENT>
def _GetMessage ( node ) : <NEWLINE> <INDENT> for c in ( n for n in node . childNodes <NEWLINE> <INDENT> if n . nodeType == xml . dom . Node . ELEMENT_NODE ) : <NEWLINE> if c . tagName == <STRING> : <NEWLINE> if ( len ( c . childNodes ) == 1 <NEWLINE> and c . childNodes [ 0 ] . nodeType == xml . dom . Node . TEXT_NODE ) : <NEWLINE> return c . childNodes [ 0 ] . data <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>
( self . config . set_key ( <STRING> , value ) <NEWLINE> self . callback ( ) <NEWLINE> <DEDENT> def on_checkbox ( self , b ) : <NEWLINE> <INDENT> self . update_text ( ) <NEWLINE> <DEDENT> <DEDENT>
def process_response ( self , resp , data ) : <NEWLINE> <INDENT> for metric , facet in resp . get ( <STRING> , { } ) . items ( ) : <NEWLINE> <INDENT> count = facet . get ( <STRING> , 0 ) <NEWLINE> if count > 0 : <NEWLINE> <INDENT> for field in ( <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> ) : <NEWLINE> value = facet . get ( field ) <NEWLINE> if value is not None : <NEWLINE> data [ metric ] [ field ] = value <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def process_spider_output ( self , response , result , spider ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> saved = False <NEWLINE> for out in result : <NEWLINE> <INDENT> if ( not saved and self . clustering_enabled and <NEWLINE> <INDENT> hasattr ( out , <STRING> ) and <NEWLINE> out . get ( <STRING> ) == _CLUSTER_NA ) : <NEWLINE> key = request_fingerprint ( response . request ) <NEWLINE> logging . debug ( <STRING> , <NEWLINE> <INDENT> response . request ) <NEWLINE> self . db [ key ] = json . dumps ( [ response . body_as_unicode ( ) , <NEWLINE> <INDENT> response . encoding ] ) <NEWLINE> saved = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> yield out <NEWLINE> <DEDENT> <DEDENT>
def _lock_state_file ( self ) : <NEWLINE> <INDENT> if not self . lock : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> self . _lockfile = LockFile ( self . path ) <NEWLINE> if ( self . _lockfile . is_locked ( ) and <NEWLINE> <INDENT> ( time ( ) - getmtime ( self . _lockfile . lock_file ) > 10 ) : <NEWLINE> self . _lockfile . break_lock ( ) <NEWLINE> <DEDENT> self . _lockfile . acquire ( ) <NEWLINE> <DEDENT>
def test_get_test_filename ( ) : <NEWLINE> <INDENT> assert_get_test_filename_finds ( <NEWLINE> <INDENT> os . path . join ( <STRING> , <STRING> ) , <NEWLINE> os . path . join ( <STRING> , <STRING> , <STRING> ) <NEWLINE> <DEDENT> ) <NEWLINE> assert_get_test_filename_finds ( <NEWLINE> <INDENT> os . path . join ( <STRING> , <STRING> ) <NEWLINE> os . path . join ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def _convert_to_ascii ( self , * values ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for value in values : <NEWLINE> <INDENT> if isinstance ( value , unicode ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> value = value . encode ( <STRING> ) <NEWLINE> <DEDENT> except UnicodeError , e : <NEWLINE> <INDENT> e . reason += <STRING> <NEWLINE> raise <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> value = str ( value ) <NEWLINE> <DEDENT> if <STRING> in value or <STRING> in value : <NEWLINE> <INDENT> raise BadHeaderError ( <STRING> % ( value ) ) <NEWLINE> <DEDENT> yield value <NEWLINE> <DEDENT> <DEDENT>
def split_array ( arr ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return min ( <NEWLINE> <INDENT> ( try_split ( arr , shift ) for shift in xrange ( len ( arr ) . bit_length ( ) ) ) , <NEWLINE> key = lambda ( t1 , t2 , shift ) : bytes_needed ( t1 ) [ 1 ] * len ( t1 ) <NEWLINE> <INDENT> + bytes_needed ( t2 ) [ 1 ] * len ( t2 ) <NEWLINE> <DEDENT> <DEDENT> ) <NEWLINE> <DEDENT>
def get_mathjax_header ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if CFG_MATHJAX_HOSTING . lower ( ) == <STRING> : <NEWLINE> <INDENT> mathjax_path = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mathjax_path = <STRING> <NEWLINE> <DEDENT> return <STRING> % { <NEWLINE> <STRING> : mathjax_path <NEWLINE> <DEDENT>
def broadcast ( self , * args ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . networking == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> data = cPickle . dumps ( args ) <NEWLINE> self . network_stream . sendto ( data , ( <STRING> , self . port ) ) <NEWLINE> <DEDENT> except socket . error , msg : <NEWLINE> <INDENT> if msg [ 0 ] != 9 : <NEWLINE> <INDENT> log . error ( str ( msg [ 0 ] ) + <STRING> + msg [ 1 ] ) <NEWLINE> print ( str ( msg [ 0 ] ) + <STRING> + msg [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
class BaseDbTemplateDecorator ( BaseTemplateDecorator ) : <NEWLINE> <INDENT> def __init__ ( self , ingress ) : <NEWLINE> <INDENT> super ( BaseDbTemplateDecorator , self ) . __init__ ( ) <NEWLINE> self . _ingress = ingress <NEWLINE> <DEDENT> def _add_client_resources ( self , resources , app_region , port , params , <NEWLINE> <INDENT> sg_ref ) : <NEWLINE> clients = params . get ( <STRING> , ( ) ) <NEWLINE> ingress_resources = self . _ingress . ingress_resources ( app_region , <NEWLINE> <INDENT> port , <NEWLINE> clients , <NEWLINE> sg_ref = sg_ref ) <NEWLINE> logger . debug ( <STRING> , len ( ingress_resources ) ) <NEWLINE> resources . update ( ingress_resources ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def countCrashes ( file_name ) : <NEWLINE> <INDENT> file_in = open ( file_name , <STRING> ) <NEWLINE> output_value = 0 <NEWLINE> for line in file_in : <NEWLINE> <INDENT> if <STRING> in line : <NEWLINE> <INDENT> output_value += 1 <NEWLINE> elif <STRING> in line : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return output_value <NEWLINE> <DEDENT>
import os <NEWLINE> import sys <NEWLINE> import pytest <NEWLINE> sys . path . append ( os . path . join ( os . path . dirname ( __file__ ) , <STRING> ) <NEWLINE> sys . exit ( pytest . main ( ) ) <NEWLINE>
def install_host ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for install in ( _install_maya , <NEWLINE> <INDENT> _install_houdini , <NEWLINE> _install_nuke , <NEWLINE> _install_hiero , <NEWLINE> _install_nukestudio ) : <NEWLINE> try : <NEWLINE> install ( ) <NEWLINE> except ImportError : <NEWLINE> pass <NEWLINE> else : <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
def __getattr__ ( self , name ) : <NEWLINE> <INDENT> if name in dir ( self ) : <NEWLINE> <INDENT> return getattr ( self , name ) <NEWLINE> <DEDENT> elif name . startswith ( <STRING> ) : <NEWLINE> <INDENT> raise AttributeError , <STRING> % name <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if self . __mlname__ is not None : <NEWLINE> <INDENT> name = ( self . __mlname__ + <STRING> + name ) <NEWLINE> <DEDENT> newname = MATLABName ( name ) <NEWLINE> setattr ( self , name , newname ) <NEWLINE> sys . modules [ newname . __name__ ] = newname <NEWLINE> return newname <NEWLINE> <DEDENT> <DEDENT>
def get_api_calls ( ) : <NEWLINE> <INDENT> calls = { } <NEWLINE> for t in rdf_ontology . api_calls : <NEWLINE> <INDENT> target = str ( t . target ) <NEWLINE> method = str ( t . method ) <NEWLINE> path = str ( t . path ) <NEWLINE> category = str ( t . category ) <NEWLINE> if method == <STRING> and ( category == <STRING> or <NEWLINE> <INDENT> path == <STRING> or <NEWLINE> path == <STRING> or <NEWLINE> path == <STRING> ) : <NEWLINE> if target not in calls . keys ( ) : <NEWLINE> calls [ target ] = path <NEWLINE> <DEDENT> <DEDENT> return calls <NEWLINE> <DEDENT>
def compare ( self , obj ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for prop in orm . object_mapper ( self ) . iterate_properties : <NEWLINE> <INDENT> if isinstance ( prop , orm . ColumnProperty ) or ( isinstance ( prop , orm . RelationshipProperty ) <NEWLINE> <INDENT> and prop . secondary ) : <NEWLINE> if getattr ( obj , prop . key ) != getattr ( self , prop . key ) : <NEWLINE> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT>
( <STRING> <NEWLINE> <DEDENT>
def print_status ( ) : <NEWLINE> <INDENT> if ( debugLevel ) : print <STRING> <NEWLINE> print ( <STRING> % ( enc_read ( 1 ) , enc_read ( 0 ) ) ) <NEWLINE> <DEDENT>
( <NEWLINE> for out in outs : <NEWLINE> <INDENT> out . encode ( <STRING> + str ( inc ) + <STRING> ) <NEWLINE> inc += 1 <NEWLINE> <DEDENT>
def ipc_server ( qapp , qtbot ) : <NEWLINE> <INDENT> server = ipc . IPCServer ( <STRING> ) <NEWLINE> yield server <NEWLINE> if ( server . _socket is not None and <NEWLINE> <INDENT> server . _socket . state ( ) != QLocalSocket . UnconnectedState ) : <NEWLINE> with qtbot . waitSignal ( server . _socket . disconnected , raising = False ) : <NEWLINE> server . _socket . abort ( ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> server . shutdown ( ) <NEWLINE> <DEDENT> except ipc . Error : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
def download_attachment ( self , url ) : <NEWLINE> <INDENT> url = url . strip ( <STRING> ) <NEWLINE> if self . no_download : <NEWLINE> <INDENT> if self . verbose : <NEWLINE> <INDENT> print ( <STRING> % url ) <NEWLINE> <DEDENT> content = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if self . verbose : <NEWLINE> <INDENT> print ( <STRING> % url ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> content = urllib . urlopen ( url ) . read ( ) <NEWLINE> <DEDENT> except IOError , e : <NEWLINE> <INDENT> raise DownloadError ( e ) <NEWLINE> <DEDENT> <DEDENT> return content <NEWLINE> <DEDENT>
def y1p_zeros ( nt , complex = 0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not isscalar ( nt ) or ( floor ( nt ) != nt ) or ( nt <= 0 ) : <NEWLINE> <INDENT> raise ValueError , <STRING> <NEWLINE> <DEDENT> kf = 2 <NEWLINE> kc = ( complex != 1 ) <NEWLINE> return specfun . cyzo ( nt , kf , kc ) <NEWLINE> <DEDENT>
self . state . se . BVV ( 0 , 64 ) ) <NEWLINE>
<INDENT> l_test_id = tank_msg [ <STRING> ] ) . json ( ) . pop ( ) <NEWLINE>
def resizeEvent ( self event ) : <NEWLINE> <INDENT> super ( GraphicsView , self ) . resizeEvent ( event ) <NEWLINE> if self . s is not None : <NEWLINE> <INDENT> self . s . auto_update_all_links ( ) <NEWLINE> <DEDENT> <DEDENT>
def fileExists ( fn ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if debug : <NEWLINE> <INDENT> print <STRING> % ( fn , ) <NEWLINE> <DEDENT> fn = os . path . expanduser ( fn ) <NEWLINE> readable = os . access ( fn , os . R_OK ) <NEWLINE> if not readable : return 0 <NEWLINE> mode = os . stat ( fn ) . st_mode <NEWLINE> return stat . S_ISREG ( mode ) <NEWLINE> <DEDENT>
def testFailedStreamRequestStreamResponse ( self ) : <NEWLINE> <INDENT> for ( group , method ) , test_messages_sequence in ( <NEWLINE> <INDENT> six . iteritems ( self . _digest . stream_stream_messages_sequences ) ) : <NEWLINE> for test_messages in test_messages_sequence : <NEWLINE> requests = test_messages . requests ( ) <NEWLINE> with self . _control . fail ( ) , self . assertRaises ( face . ExpirationError ) : <NEWLINE> <INDENT> response_iterator = self . _invoker . future ( group , method ) ( <NEWLINE> <INDENT> iter ( requests ) , _3069_test_constant . REALLY_SHORT_TIMEOUT ) <NEWLINE> <DEDENT> list ( response_iterator ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def _import_bears ( file_path , kinds ) : <NEWLINE> <INDENT> for bear_list in iimport_objects ( file_path , <NEWLINE> <INDENT> names = <STRING> , <NEWLINE> types = list ) : <NEWLINE> for bear_class in bear_list : <NEWLINE> if _get_kind ( bear_class ) in kinds : <NEWLINE> yield bear_class <NEWLINE> <DEDENT> for bear_class in iimport_objects ( file_path , <NEWLINE> <INDENT> attributes = <STRING> , <NEWLINE> local = True ) : <NEWLINE> if _get_kind ( bear_class ) in kinds : <NEWLINE> yield bear_class <NEWLINE> <DEDENT> <DEDENT>
def saveSQL ( data = None , name = None ) : <NEWLINE> <INDENT> if data is not None and name is not None and name . strip ( ) : <NEWLINE> <INDENT> filename = <STRING> % name <NEWLINE> try : <NEWLINE> <INDENT> dataFile = open ( filename , <STRING> ) <NEWLINE> for row in data : <NEWLINE> <INDENT> dataString = row . encode ( <STRING> , <STRING> ) <NEWLINE> dataFile . write ( dataString ) <NEWLINE> <DEDENT> dataFile . close ( ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test ( ) : <NEWLINE> <INDENT> from subprocess import call <NEWLINE> call ( [ <STRING> , <STRING> , <NEWLINE> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT>
class SchoolMember : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , name , age ) : <NEWLINE> <STRING> <NEWLINE> self . name = name <NEWLINE> self . age = age <NEWLINE> print ( <STRING> . format ( self . name ) ) <NEWLINE> def tell ( self ) : <NEWLINE> <STRING> <NEWLINE> <DEDENT>
def warn_version_mismatch ( ) : <NEWLINE> <INDENT> equo_ver = read_client_release ( ) <NEWLINE> entropy_ver = etpConst [ <STRING> ] <NEWLINE> if equo_ver != entropy_ver : <NEWLINE> <INDENT> print_warning ( <STRING> ) <NEWLINE> print_warning ( <STRING> % ( <NEWLINE> <INDENT> bold ( _ ( <STRING> ) , <NEWLINE> purple ( _ ( <STRING> ) ) , ) ) <NEWLINE> <DEDENT> print_warning ( <STRING> % ( <NEWLINE> <INDENT> blue ( equo_ver ) , <NEWLINE> blue ( entropy_ver ) , ) ) <NEWLINE> <DEDENT> print_warning ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , server , ( sock , addr ) ) : <NEWLINE> <INDENT> asyncore . dispatcher_with_send . __init__ ( self , sock ) <NEWLINE> self . server = server <NEWLINE> self . address = <STRING> . join ( map ( str , addr ) ) <NEWLINE> self . gpg = False <NEWLINE> self . data = <STRING> <NEWLINE> self . state = <STRING> <NEWLINE> self . connected = False <NEWLINE> <DEDENT>
def countDays ( begYear , endYear , day ) : <NEWLINE> <INDENT> first = sundays = 0 <NEWLINE> for year in range ( begYear , endYear ) : <NEWLINE> <INDENT> for month in range ( len ( months ) : <NEWLINE> <INDENT> first += getMonthLength ( year , month ) <NEWLINE> first = first % len ( daysOfWeek ) <NEWLINE> if year > 1900 and first == daysOfWeek [ day ] : <NEWLINE> <INDENT> sundays += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return sundays <NEWLINE> <DEDENT>
def test_solver2 ( N , plot = True , version = <STRING> ) : <NEWLINE> <INDENT> s = StoreSolution ( ) <NEWLINE> s . main ( N , version ) <NEWLINE> print ( <STRING> , s . cpu ) <NEWLINE> if len ( s . x ) < 10 : <NEWLINE> <INDENT> print s . solutions <NEWLINE> <DEDENT> if plot : <NEWLINE> <INDENT> from CurveViz import graph <NEWLINE> g = graph ( program = <STRING> , coor = s . x , ymax = 1 , ymin = - 1 ) <NEWLINE> for s in s . solutions : <NEWLINE> <INDENT> g . plotcurve ( s ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class DateDisplayZH_TW ( DateDisplay ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> formats = ( <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> ) <NEWLINE> <DEDENT> _bce_str = <STRING> <NEWLINE> display = DateDisplay . display_formatted <NEWLINE> def _display_calendar ( self , date_val , long_months , short_months = None , <NEWLINE> <INDENT> inflect = <STRING> ) : <NEWLINE> if short_months is None : <NEWLINE> short_months = long_months <NEWLINE> if self . format == 0 : <NEWLINE> return self . display_iso ( date_val ) <NEWLINE> else : <NEWLINE> value = self . dd_dformat01 ( date_val ) <NEWLINE> if date_val [ 2 ] < 0 : <NEWLINE> return self . _bce_str % value <NEWLINE> else : <NEWLINE> return value <NEWLINE> <DEDENT> <DEDENT>
def check ( self , verbose = True ) : <NEWLINE> <INDENT> self . share . refresh ( ) <NEWLINE> if verbose : print self . share . get_info ( ) [ <STRING> ] + <STRING> + self . share . get_volume ( ) + <STRING> + self . share . get_price ( ) + <STRING> + self . share . get_trade_datetime ( ) <NEWLINE> return { <STRING> : <STRING> } <NEWLINE> <DEDENT>
def _get_port_groups ( self , query = None ) : <NEWLINE> <INDENT> if not self . port_groups_in : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> tenant_id = self . _get_query_tenant_id ( query ) <NEWLINE> self . port_groups_out = [ ] <NEWLINE> for port_group in self . port_groups_in : <NEWLINE> <INDENT> self . port_groups_out . append ( get_port_group_mock ( <NEWLINE> <INDENT> id = port_group [ <STRING> ] , name = port_group [ <STRING> ] , <NEWLINE> tenant_id = tenant_id ) <NEWLINE> <DEDENT> <DEDENT> return self . port_groups_out <NEWLINE> <DEDENT>
def InitUniformRegionScalarQuant ( quantName , initValues ) : <NEWLINE> <INDENT> global regionNameDictionary <NEWLINE> Idx = 0. <NEWLINE> values = [ ] <NEWLINE> for key , value in sorted ( regionNameDictionary . iteritems ( ) , key = lambda ( k , v ) : ( v , k ) ) : <NEWLINE> <INDENT> if initValues . has_key ( key ) : <NEWLINE> <INDENT> values . append ( initValues [ key ] ) <NEWLINE> <DEDENT> elif key == <STRING> : <NEWLINE> <INDENT> values . append ( 0. ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> values . append ( 0. ) <NEWLINE> <DEDENT> Idx += 1 <NEWLINE> <DEDENT> setscalaruniformregion ( quantName , values ) <NEWLINE> return <NEWLINE> <DEDENT>
def najTarok ( self ) : <NEWLINE> <INDENT> return self . maxKarta ( list ( set ( [ Karta ( TAROK , i ) for i in range ( 1 , 23 ) ] ) - set ( [ x for <NEWLINE> <INDENT> x in self . padle [ TAROK ] ] ) ) . vrednost <NEWLINE> <DEDENT> <DEDENT>
def IPAddr ( vmip ) : <NEWLINE> <INDENT> for myip in net [ <STRING> ] : <NEWLINE> <INDENT> if re . match ( <STRING> , myip ) and myip != <STRING> : <NEWLINE> <DEDENT> return myip <NEWLINE> <INDENT> else : <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>
def test_flowgraph_page ( self ) : <NEWLINE> <INDENT> def callback ( ( response , data ) ) : <NEWLINE> <INDENT> self . assertEqual ( response . code , http . OK ) <NEWLINE> self . assertEqual ( response . headers . getRawHeaders ( <STRING> ) , [ <STRING> ] ) <NEWLINE> <DEDENT> return testutil . http_get ( reactor , self . url + <STRING> ) . addCallback ( callback ) <NEWLINE> <DEDENT>
def get_course_from_git ( self , gitloc , branch ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not ( gitloc . endswith ( <STRING> ) or gitloc . startswith ( <STRING> ) or <NEWLINE> <INDENT> gitloc . startswith ( <STRING> ) or gitloc . startswith ( <STRING> ) ) <NEWLINE> return _ ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return self . import_mongo_course ( gitloc , branch ) <NEWLINE> <DEDENT>
def test_input_A_dtypes ( ) : <NEWLINE> <INDENT> A , b = create_test_A_b_rand ( 10 , 0.5 ) <NEWLINE> for d in [ np . float16 , np . float32 , np . int16 , np . int32 , np . int64 , np . complex64 , <NEWLINE> <INDENT> np . complex128 , np . complex128 , np . uint16 , np . uint32 , np . uint64 ] : <NEWLINE> with pytest . raises ( TypeError ) : <NEWLINE> ps . solve ( A . astype ( d ) , b ) <NEWLINE> <DEDENT> <DEDENT>
( args . answer_tab . join ( <NEWLINE> <INDENT> index2word [ a ] + s <NEWLINE> <INDENT> for a , s in zip ( answers [ i ] , score_text ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( args . answer_tab . join ( index2word [ w ] for w in answers [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> X = output_queue_recv . recv ( ) <NEWLINE> <DEDENT> <DEDENT>
class StoreEmailsClass ( models . Model ) : <NEWLINE> <INDENT> accounts = models . ForeignKey ( AddEmail ) <NEWLINE> def __unicode__ ( self ) : <NEWLINE> return self . accounts <NEWLINE> <DEDENT>
def _last_marker ( f_path , l_obj ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return <STRING> % ( f_path , quoter ( url = l_obj ) <NEWLINE> <DEDENT>
<INDENT> req = urllib . request . Request ( url , <NEWLINE> <INDENT> headers = { <STRING> : <STRING> + os . getenv ( <STRING> ) ) } ) <NEWLINE>
def http_open ( self , req ) : <NEWLINE> <INDENT> response = urllib2 . addinfourl ( <NEWLINE> <INDENT> StringIO ( self . response_queue . popleft ( ) , <NEWLINE> <STRING> , <NEWLINE> req . get_full_url ( ) , <NEWLINE> <DEDENT> ) <NEWLINE> response . code = 200 <NEWLINE> response . msg = <STRING> <NEWLINE> return response <NEWLINE> <DEDENT>
def retrieve ( self , ids ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for batch in more_itertools . chunked ( ids , 50 ) : <NEWLINE> <INDENT> for page in self . session . get ( continuation = True , <NEWLINE> <INDENT> action = <STRING> , <NEWLINE> languages = <STRING> , <NEWLINE> ids = self . stringify_ids ( batch ) ) : <NEWLINE> assert page [ <STRING> ] == 1 <NEWLINE> for result in page [ <STRING> ] . values ( ) : <NEWLINE> yield result <NEWLINE> <DEDENT> time . sleep ( self . DELAY ) <NEWLINE> <DEDENT> <DEDENT>
def getRequiredAdapters ( iface , withViews = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> gsm = getGlobalSiteManager ( ) <NEWLINE> for meth in ( <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ) : <NEWLINE> for reg in getattr ( gsm , meth ) ( ) : <NEWLINE> if len ( reg . required ) == 0 : <NEWLINE> continue <NEWLINE> if not withViews and reg . required [ - 1 ] . isOrExtends ( IRequest ) : <NEWLINE> continue <NEWLINE> for required_iface in reg . required : <NEWLINE> if iface . isOrExtends ( required_iface ) : <NEWLINE> <INDENT> yield reg <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def OnActivate ( self , event ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( self . ControlObject != None ) and ( self . transcriptWindowNumber < len ( self . ControlObject . TranscriptWindow ) ) : <NEWLINE> <INDENT> self . ControlObject . activeTranscript = self . transcriptWindowNumber <NEWLINE> <DEDENT> elif ( self . ControlObject != None ) and ( self . ControlObject . activeTranscript >= len ( self . ControlObject . TranscriptWindow ) : <NEWLINE> <INDENT> self . ControlObject . activeTranscript = 0 <NEWLINE> <DEDENT> event . Skip ( ) <NEWLINE> <DEDENT>
( request , <STRING> , <NEWLINE> <INDENT> { <NEWLINE> <INDENT> <STRING> : hot_sina_news , <NEWLINE> <STRING> : hot_tencent_news , <NEWLINE> <STRING> : hot_sohu_news , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> <DEDENT>
a = int ( input ( <STRING> ) ) <NEWLINE> b = int ( input ( <STRING> ) ) <NEWLINE> if ( a + b == 0 ) <NEWLINE> <INDENT> print : ( <STRING> ) <NEWLINE> <DEDENT> if ( a + b < 0 ) <NEWLINE> <INDENT> print : ( <STRING> ) <NEWLINE> <DEDENT> if ( a + b > 0 ) <NEWLINE> <INDENT> print : ( <STRING> ) <NEWLINE> <DEDENT>
def launchChrome ( self url , title ) : <NEWLINE> <INDENT> action = <STRING> % ( <STRING> + url ) <NEWLINE> common . log ( <STRING> + str ( action ) ) <NEWLINE> xbmc . executebuiltin ( action ) <NEWLINE> <DEDENT>
( Levenshtein . distance ( testcase_list [ code ] , testcase_list [ elem ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def creds_dialog ( creds ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> retipc = [ ] <NEWLINE> def wrapper ( fn creds ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ret = fn ( creds ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> logging . exception ( <STRING> ) <NEWLINE> ret = - 1 <NEWLINE> <DEDENT> retipc . append ( ret ) <NEWLINE> <DEDENT> GLib . idle_add ( wrapper , creds_dialog_main , creds ) <NEWLINE> while not retipc : <NEWLINE> <INDENT> time . sleep ( .1 ) <NEWLINE> <DEDENT> return retipc [ 0 ] <NEWLINE> <DEDENT>
def _orphaned_files ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> base_dir = getattr ( <NEWLINE> <INDENT> settings , <STRING> , <NEWLINE> DEFAULT_ADJUSTED_IMAGE_PATH ) <NEWLINE> <DEDENT> known_paths = set ( <NEWLINE> <INDENT> AdjustedImage . objects . values_list ( <STRING> , flat = True ) . distinct ( ) <NEWLINE> <DEDENT> ) <NEWLINE> orphans = [ ] <NEWLINE> for dirpath , dirnames , filenames in self . _walk ( <NEWLINE> <INDENT> base_dir , topdown = False ) : <NEWLINE> for filename in filenames : <NEWLINE> filepath = os . path . join ( dirpath , filename ) <NEWLINE> if filepath not in known_paths : <NEWLINE> <INDENT> orphans . append ( filepath ) <NEWLINE> <DEDENT> <DEDENT> return orphans <NEWLINE> <DEDENT>
def canFindBuiltinHeaders ( index , args = [ ] ) : <NEWLINE> <INDENT> flags = 0 <NEWLINE> currentFile = ( <STRING> , <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> tu = index . parse ( <STRING> , args , [ currentFile ] , flags ) <NEWLINE> <DEDENT> except TranslationUnitLoadError , e : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return len ( tu . diagnostics ) == 0 <NEWLINE> <DEDENT>
def testKnownValues ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for name , result in self . knownValues : <NEWLINE> self . assertEqual ( soundex . soundex ( name ) , result ) <NEWLINE> <DEDENT>
def filter_python_develop ( line ) : <NEWLINE> <INDENT> if not line . strip ( ) : <NEWLINE> <INDENT> return Logger . DEBUG <NEWLINE> <DEDENT> for prefix in [ <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> ] : <NEWLINE> if line . startswith ( prefix ) : <NEWLINE> return Logger . DEBUG <NEWLINE> <DEDENT> return Logger . NOTIFY <NEWLINE> <DEDENT>
def set_distro ( self , distro_name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> d = self . config . distros ( ) . find ( name = distro_name ) <NEWLINE> if d is not None : <NEWLINE> <INDENT> self . distro = distro_name <NEWLINE> self . depth = d . depth + 1 <NEWLINE> return True <NEWLINE> <DEDENT> raise CX ( _ ( <STRING> ) <NEWLINE> <DEDENT>
def spdiags ( data , diags , m , n , format = None ) <NEWLINE> <INDENT> <STRING> <NEWLINE> return dia_matrix ( ( data , diags ) , shape = ( m , n ) ) . asformat ( format ) <NEWLINE> <DEDENT>
def match ( self , entry ) : <NEWLINE> <INDENT> if self . neg : <NEWLINE> <INDENT> for f in entry . keys ( ) : <NEWLINE> field = entry [ f ] <NEWLINE> if field . match ( self . __test ) is not None : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for f in entry . keys ( ) : <NEWLINE> field = entry [ f ] <NEWLINE> if field . match ( self . __test ) is not None : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT> <DEDENT>
