def _addVersionString ( self , versionkey , value ) : <NEWLINE> <INDENT> self . log . warning ( <STRING> ) <NEWLINE> self . version [ versionkey ] = value <NEWLINE> self . versionkeys . append ( versionkey ) <NEWLINE> <DEDENT>
def make_shared ( shape ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return shared ( np . zeros ( shape ) ) <NEWLINE> <DEDENT>
def partition ( self , s ) : <NEWLINE> <INDENT> if not s : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> mincut = [ len ( s ) ] <NEWLINE> res = self . PalindromePart ( s , 0 , mincut ) <NEWLINE> return mincut [ 0 ] <NEWLINE> <DEDENT>
def jsonify_annual_water_use_volume ( request ) : <NEWLINE> <INDENT> result = get_annual_water_use_volume ( request ) <NEWLINE> return HttpResponse ( json . dumps ( result ) , content_type = <STRING> ) <NEWLINE> <DEDENT>
def R2vec ( self , i ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> d = self . _model_vec ( i ) - self . data <NEWLINE> return 1.0 - N . var ( d [ self . _unmasked ] ) / self . _unmasked_data_var <NEWLINE> <DEDENT>
def test_extend_with_tuple ( self ) : <NEWLINE> <INDENT> D1 = DistinctList ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] ) <NEWLINE> D1 . extend ( ( 9 , 10 , 11 , 12 ) ) <NEWLINE> self . assertSequenceEqual ( D1 , DistinctList ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 ] ) , seq_type = DistinctList ) <NEWLINE> <DEDENT>
from SpaceDock . config import _cfg <NEWLINE> from SpaceDock . celery import update_patreon <NEWLINE> import celery <NEWLINE> import redis <NEWLINE> import time <NEWLINE> import json <NEWLINE> donation_cache = redis . Redis ( host = _cfg ( <STRING> ) , port = _cfg ( <STRING> ) , db = _cfg ( <STRING> ) ) <NEWLINE>
def test_write_read_settings ( self ) : <NEWLINE> <INDENT> lyr1 = self . defaultLayerSettings ( ) <NEWLINE> lyr1dict = self . settingsDict ( lyr1 ) <NEWLINE> lyr1 . writeToLayer ( self . layer ) <NEWLINE> lyr2 = QgsPalLayerSettings ( ) <NEWLINE> lyr2 . readFromLayer ( self . layer ) <NEWLINE> lyr2dict = self . settingsDict ( lyr1 ) <NEWLINE> msg = <STRING> <NEWLINE> self . assertDictEqual ( lyr1dict , lyr2dict , msg ) <NEWLINE> <DEDENT>
def actualizar ( self ) : <NEWLINE> <INDENT> self . contador += 16 <NEWLINE> self . dx += self . _incremento_aceleracion_x <NEWLINE> self . dy += self . _incremento_aceleracion_y <NEWLINE> self . x += self . dx <NEWLINE> self . y += self . dy <NEWLINE> self . escala += self . _incremento_escala <NEWLINE> self . transparencia += self . _incremento_transparencia <NEWLINE> self . rotacion += self . _incremento_rotacion <NEWLINE> if self . contador > self . vida : <NEWLINE> <INDENT> self . emisor . se_elimina_particula ( self ) <NEWLINE> self . eliminar ( ) <NEWLINE> <DEDENT> <DEDENT>
def sanitize_url ( url ) : <NEWLINE> <INDENT> valid_utf8 = True <NEWLINE> try : <NEWLINE> <INDENT> url . decode ( <STRING> ) <NEWLINE> <DEDENT> except UnicodeDecodeError : <NEWLINE> <INDENT> valid_utf8 = False <NEWLINE> return url [ : - 1 ] <NEWLINE> <DEDENT> return url <NEWLINE> <DEDENT>
def init_config ( self , app ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if <STRING> in app . config : <NEWLINE> <INDENT> app . config . setdefault ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> app . config [ <STRING> ] , <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> for k in dir ( config ) : <NEWLINE> <INDENT> if k . startswith ( <STRING> ) : <NEWLINE> <INDENT> app . config . setdefault ( k , getattr ( config , k ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def visit_VARCHAR ( self , type_ ) : <NEWLINE> <INDENT> if self . dialect . _supports_char_length : <NEWLINE> <INDENT> return <STRING> % { <STRING> : type_ . length } <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> % { <STRING> : type_ . length } <NEWLINE> <DEDENT> <DEDENT>
from sys import version_info <NEWLINE> from setuptools import setup , find_packages <NEWLINE> basename = <STRING> <NEWLINE> version = <STRING> <NEWLINE> pyversion = <STRING> % ( version_info . major , version_info . minor ) <NEWLINE> setup ( <NEWLINE> <INDENT> name = basename , <NEWLINE> version = version , <NEWLINE> packages = find_packages ( ) , <NEWLINE> zip_safe = True , <NEWLINE> author = <STRING> , <NEWLINE> author_email = <STRING> , <NEWLINE> description = <STRING> , <NEWLINE> keywords = <STRING> , <NEWLINE> install_requires = ( <STRING> , ) <NEWLINE> <DEDENT> ) <NEWLINE>
from django . db import models <NEWLINE> from django . utils . translation import ugettext_lazy as _ <NEWLINE> COLOR_CHOICES = ( ( <STRING> , _ ( <STRING> ) ) , <NEWLINE> <INDENT> ( <STRING> , _ ( <STRING> ) ) , <NEWLINE> ( <STRING> , _ ( <STRING> ) ) , <NEWLINE> ( <STRING> , _ ( <STRING> ) ) , <NEWLINE> ( <STRING> , _ ( <STRING> ) ) , <NEWLINE> ( <STRING> , _ ( <STRING> ) ) ) <NEWLINE> <DEDENT>
def tout_decharger ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for module in self . modules : <NEWLINE> <INDENT> self . decharger_module ( module . type , module . nom ) <NEWLINE> <DEDENT> <DEDENT>
def oid_repr ( oid ) : <NEWLINE> <INDENT> if isinstance ( oid , StringType ) and len ( oid ) == 8 : <NEWLINE> <INDENT> return <STRING> % U64 ( oid ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return repr ( oid ) <NEWLINE> <DEDENT> <DEDENT>
class L : <NEWLINE> <INDENT> ModManager = None <NEWLINE> InputManager = None <NEWLINE> PlayerManager = None <NEWLINE> GameLoopManager = None <NEWLINE> MapManager = None <NEWLINE> ModManager = None <NEWLINE> UnitManager = None <NEWLINE> CityManager = None <NEWLINE> WidgetManager = None <NEWLINE> TileMap = None <NEWLINE> Screen = None <NEWLINE> Grid = None <NEWLINE> RootDirectory = None <NEWLINE> <DEDENT>
class GetCreditCardResult : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> self . swaggerTypes = { <NEWLINE> <INDENT> <STRING> : <STRING> <NEWLINE> <DEDENT> } <NEWLINE> self . credit_card = None <NEWLINE> <DEDENT> <DEDENT>
def IsAllowed ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . isAllowed <NEWLINE> <DEDENT>
__author__ = <STRING> <NEWLINE> from config import * <NEWLINE> from prepare import prepareDataStringFile as pd <NEWLINE> update_file_names = [ ] <NEWLINE> for per in pers : <NEWLINE> <INDENT> update_file_name = data_dir + <STRING> + str ( per ) + suffix <NEWLINE> pd . prepareUpdateList ( per , num_lines , update_file_name ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
def __init__ ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> Algorithm . __init__ ( self ) <NEWLINE> self . name = <STRING> <NEWLINE> self . parent = <STRING> <NEWLINE> self . kernelsize = IntegerSlider ( <STRING> , 1 , 20 , 1 , 1 ) <NEWLINE> self . sigmaX = FloatSlider ( <STRING> , 1.0 , 100.0 , 0.1 , 1.0 ) <NEWLINE> self . channel1 = CheckBox ( <STRING> , True ) <NEWLINE> self . channel2 = CheckBox ( <STRING> , True ) <NEWLINE> self . channel3 = CheckBox ( <STRING> , True ) <NEWLINE> self . integer_sliders . append ( self . kernelsize ) <NEWLINE> self . float_sliders . append ( self . sigmaX ) <NEWLINE> <DEDENT>
{ <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : [ <STRING> ] , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : [ <STRING> ] , <NEWLINE> <STRING> : [ ] , <NEWLINE> <STRING> : True , <NEWLINE> <STRING> : False , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : False , <NEWLINE> } <NEWLINE> <DEDENT>
from haystack . indexes import * <NEWLINE> from haystack import site <NEWLINE> from models import Contact <NEWLINE>
<STRING> <NEWLINE> n1 = 1 <NEWLINE> n2 = 2 <NEWLINE> tot = n2 <NEWLINE> i = 1 <NEWLINE> while ( ( n1 + n2 ) < 4000000 ) : <NEWLINE> <INDENT> sum = n1 + n2 <NEWLINE> n1 = n2 <NEWLINE> n2 = sum <NEWLINE> if ( i == 3 ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> tot += sum <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( str ( tot ) ) <NEWLINE>
<STRING> <NEWLINE> import json <NEWLINE> from common import findFileInTheProject <NEWLINE> import logging . config <NEWLINE> logger = logging . getLogger ( __name__ ) <NEWLINE> DEFAULT_LOG_FILENAME = <STRING> <NEWLINE>
class ResponsiveImageSerializer ( TaggitSerializer , serializers . ModelSerializer ) : <NEWLINE> <INDENT> tags = TagListSerializerField ( ) <NEWLINE> class Meta ( object ) : <NEWLINE> <INDENT> model = ResponsiveImage <NEWLINE> fields = ( <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> <DEDENT>
import socket <NEWLINE> import asyncio <NEWLINE> import aiohttp <NEWLINE> import re <NEWLINE>
def update_requirements_file ( filename ) : <NEWLINE> <INDENT> with open ( filename , <STRING> ) as file : <NEWLINE> <INDENT> content = file . read ( ) <NEWLINE> content = re . sub ( <STRING> , <STRING> . format ( libgit2_version ) , content , flags = re . MULTILINE ) <NEWLINE> <DEDENT> with open ( filename , <STRING> ) as file : <NEWLINE> <INDENT> file . write ( content ) <NEWLINE> <DEDENT> <DEDENT>
class tee : <NEWLINE> <INDENT> def __init__ ( self , * files ) : <NEWLINE> <INDENT> self . files = files <NEWLINE> <DEDENT> def write ( self , bytes ) : <NEWLINE> <INDENT> for file in self . files : <NEWLINE> <INDENT> file . write ( bytes ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_version ( self ) : <NEWLINE> <INDENT> expected_resp = json . dumps ( { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : 200 , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> } , sort_keys = True ) <NEWLINE> <DEDENT> mb = MessageBusAPIClient ( self . api_key ) <NEWLINE> mb . __dict__ [ <NEWLINE> <INDENT> <STRING> ] = self . _setup_mock_connection ( <STRING> , <STRING> , <STRING> , 200 , <NEWLINE> <INDENT> expected_resp ) <NEWLINE> <DEDENT> <DEDENT> received_resp = json . dumps ( mb . api_version ( ) , sort_keys = True ) <NEWLINE> self . _validate_results ( expected_resp , received_resp ) <NEWLINE> self . mocker . UnsetStubs ( ) <NEWLINE> <DEDENT>
def cwh_to_chw ( m ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if m . ndim == 3 : <NEWLINE> <INDENT> m = m . transpose ( ( 0 , 2 , 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise AttributeError ( <STRING> % m . ndim ) <NEWLINE> <DEDENT> return m <NEWLINE> <DEDENT>
def add_test_dimensions ( cls ) : <NEWLINE> <INDENT> super ( TestStringQueries , cls ) . add_test_dimensions ( ) <NEWLINE> cls . TestMatrix . add_dimension ( <NEWLINE> <INDENT> create_exec_option_dimension ( disable_codegen_options = [ False , True ] ) ) <NEWLINE> <DEDENT> cls . TestMatrix . add_constraint ( lambda v : v . get_value ( <STRING> ) . file_format in [ <STRING> ] and <NEWLINE> <INDENT> v . get_value ( <STRING> ) . compression_codec in [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT>
from . ListAndSearch import ListAndSearch <NEWLINE> from . Encode import Encode <NEWLINE> from . Decode import Decode <NEWLINE>
def u2opener ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . urlopener is None or self . proxy != self . options . proxy : <NEWLINE> <INDENT> openers = self . u2handlers ( ) <NEWLINE> openers . insert ( 0 , self . build_ssl_opener ( ) ) <NEWLINE> self . urlopener = u2 . build_opener ( * openers ) <NEWLINE> <DEDENT> return self . urlopener <NEWLINE> <DEDENT>
def poll_stat_namer ( event ) : <NEWLINE> <INDENT> if not isinstance ( event , int ) : <NEWLINE> <INDENT> raise TypeError ( <STRING> . format ( event ) ) <NEWLINE> <DEDENT> devided = poll_stat_devider ( event ) <NEWLINE> names = set ( ) <NEWLINE> for i in POLL_CONSTS . keys ( ) : <NEWLINE> <INDENT> for j in devided : <NEWLINE> <INDENT> if POLL_CONSTS [ i ] == j : <NEWLINE> <INDENT> names . add ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return list ( names ) <NEWLINE> <DEDENT>
def build_rsync_manifest ( self ) : <NEWLINE> <INDENT> manifest_path = os . path . normpath ( os . path . join ( OUTPUT_DIRECTORY , <STRING> ) ) <NEWLINE> with open ( manifest_path , <STRING> , encoding = <STRING> ) as f : <NEWLINE> <INDENT> for each in self . static : <NEWLINE> <INDENT> new_path = each . replace ( RSYNC_STRIP , <STRING> ) . replace ( <STRING> , <STRING> ) <NEWLINE> f . write ( new_path + <STRING> ) <NEWLINE> <DEDENT> for each in self . compressed : <NEWLINE> <INDENT> new_path = each . replace ( RSYNC_STRIP , <STRING> ) . replace ( <STRING> , <STRING> ) <NEWLINE> f . write ( new_path + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def suite ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> test_suite = trytond . tests . test_tryton . suite ( ) <NEWLINE> test_suite . addTests ( <NEWLINE> <INDENT> unittest . TestLoader ( ) . loadTestsFromTestCase ( TestSerialization ) <NEWLINE> <DEDENT> ) <NEWLINE> return test_suite <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import sys <NEWLINE> import CGAT . Experiment as E <NEWLINE>
<STRING> <NEWLINE> from flask import current_app , request , url_for <NEWLINE> from . utils import merge_dict <NEWLINE>
class DateTimeConstraint ( BaseConstraint ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> name_type = <STRING> <NEWLINE> constraints = [ <STRING> ] <NEWLINE> def __init__ ( self , base_type , pkey = False ) : <NEWLINE> <INDENT> self . base_type = base_type <NEWLINE> self . pkey = pkey <NEWLINE> <DEDENT> def control ( self , value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT>
def list_resource_group ( self ) : <NEWLINE> <INDENT> self . log ( <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> response = self . storage_client . storage_accounts . list_by_resource_group ( self . resource_group ) <NEWLINE> <DEDENT> except Exception as exc : <NEWLINE> <INDENT> self . fail ( <STRING> . format ( self . resource_group , str ( exc ) ) ) <NEWLINE> <DEDENT> results = [ ] <NEWLINE> for item in response : <NEWLINE> <INDENT> if self . has_tags ( item . tags , self . tags ) : <NEWLINE> <INDENT> results . append ( self . serialize_obj ( item , AZURE_OBJECT_CLASS ) ) <NEWLINE> <DEDENT> <DEDENT> return results <NEWLINE> <DEDENT>
appcode = <STRING> <NEWLINE> appdesc = <STRING> <NEWLINE> from _branch import branch <NEWLINE> VERSION_BRANCH = branch <NEWLINE> from _version import apptype , appType , appinfo <NEWLINE> VERSION_MAJOR = 1 <NEWLINE> VERSION_MINOR = 5 <NEWLINE> VERSION_RELEASE = 46 <NEWLINE> VERSION_TAG = <STRING> <NEWLINE> VERSION_TYPE = apptype <NEWLINE> VERSION_TYPEXT = appType <NEWLINE> VERSION_INFO = appinfo <NEWLINE> __min_compat_ver__ = <STRING> <NEWLINE> VERSION = ( VERSION_MAJOR , VERSION_MINOR , VERSION_RELEASE , VERSION_TAG ) <NEWLINE> VERSION_STRING = <STRING> % ( VERSION_MAJOR , <NEWLINE> <INDENT> VERSION_MINOR , <NEWLINE> str ( VERSION_RELEASE ) . zfill ( 2 ) ) <NEWLINE> <DEDENT> __version_exe__ = VERSION_STRING <NEWLINE> if VERSION_TAG : <NEWLINE> <INDENT> VERSION_STRING += <STRING> % VERSION_TAG <NEWLINE> <DEDENT> __version__ = VERSION_STRING <NEWLINE>
def application ( chip ) : <NEWLINE> <INDENT> keyboard_test = Component ( <NEWLINE> <STRING> , inline = True ) <NEWLINE> keyboard_test ( <NEWLINE> <INDENT> chip , <NEWLINE> inputs = { <NEWLINE> <INDENT> <STRING> : chip . inputs [ <STRING> ] , <NEWLINE> <STRING> : chip . inputs [ <STRING> ] , <NEWLINE> <DEDENT> } , <NEWLINE> outputs = { <NEWLINE> <INDENT> <STRING> : chip . outputs [ <STRING> ] , <NEWLINE> <DEDENT> } , <NEWLINE> parameters = { } <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT>
def reload_settings ( ** kwargs ) : <NEWLINE> <INDENT> if kwargs [ <STRING> ] == <STRING> : <NEWLINE> <INDENT> settings . update ( kwargs [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT>
class MockSeries ( learn . Series ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , cachekey , mock_tensor ) : <NEWLINE> <INDENT> super ( MockSeries , self ) . __init__ ( ) <NEWLINE> self . _cachekey = cachekey <NEWLINE> self . _mock_tensor = mock_tensor <NEWLINE> <DEDENT> def build ( self , cache ) : <NEWLINE> <INDENT> return self . _mock_tensor <NEWLINE> <DEDENT> def __repr__ ( self ) : <NEWLINE> <INDENT> return self . _cachekey <NEWLINE> <DEDENT> <DEDENT>
from . udp import UdpDiscoveryMedium <NEWLINE> from . memory import MemoryDiscoveryMedium <NEWLINE> __all__ = [ UdpDiscoveryMedium , MemoryDiscoveryMedium ] <NEWLINE>
import logging <NEWLINE> import os <NEWLINE> CONFIG_PATH = <STRING> <NEWLINE> SSH_KEY_PATH = <STRING> <NEWLINE> IP_DETECT_PATH = <STRING> <NEWLINE> REXRAY_CONFIG_PATH = <STRING> <NEWLINE> SERVE_DIR = <STRING> <NEWLINE> STATE_DIR = <STRING> <NEWLINE> GENCONF_DIR = <STRING> <NEWLINE> log = logging . getLogger ( __name__ ) <NEWLINE>
<STRING> <NEWLINE> from __future__ import absolute_import <NEWLINE> from pycounter import exceptions , report , sushi <NEWLINE> from pycounter . version import __version__ <NEWLINE> __all__ = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE>
import argparse <NEWLINE> import os <NEWLINE> from cbc . parsers import CBCConfigParser , ExtendedInterpolation <NEWLINE> RECIPE_TYPES = [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ] <NEWLINE> <DEDENT>
def _set_discount ( self ) : <NEWLINE> <INDENT> discount = 0.0 <NEWLINE> if self . price_unit : <NEWLINE> <INDENT> total_discount_perc = self . total_discount / 100.0 <NEWLINE> list_discount_perc = self . list_discount / 100.0 <NEWLINE> discount = 1.0 - ( ( 1.0 - total_discount_perc ) / ( 1.0 - list_discount_perc ) ) <NEWLINE> <DEDENT> self . discount = discount * 100.0 <NEWLINE> <DEDENT>
def send_message ( message ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if message [ <STRING> ] in INDEX : <NEWLINE> <INDENT> INDEX [ message [ <STRING> ] ] . sendMessage ( <NEWLINE> <INDENT> message [ <STRING> ] . encode ( <STRING> ) , False ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> LOGGER . warning ( <STRING> , <NEWLINE> <INDENT> message [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from __future__ import unicode_literals <NEWLINE> import regex as re <NEWLINE> from rebulk import Rebulk <NEWLINE> from . . common . validators import seps_surround <NEWLINE>
def fetch_files ( self ) : <NEWLINE> <INDENT> folder = UPLOAD_FOLDER <NEWLINE> allfiles = [ f for f in listdir ( folder ) if isfile ( join ( folder , f ) ) if not f . startswith ( <STRING> ) ] <NEWLINE> if allfiles : <NEWLINE> <INDENT> return allfiles <NEWLINE> <DEDENT> <DEDENT>
import testlib <NEWLINE> import pybitcoin <NEWLINE> import json <NEWLINE> import os <NEWLINE> import sys <NEWLINE> import virtualchain <NEWLINE> wallets = [ <NEWLINE> <INDENT> testlib . Wallet ( <STRING> , 100000000000 ) , <NEWLINE> testlib . Wallet ( <STRING> , 100000000000 ) , <NEWLINE> testlib . Wallet ( <STRING> , 100000000000 ) , <NEWLINE> testlib . Wallet ( <STRING> , 100000000000 ) , <NEWLINE> testlib . Wallet ( <STRING> , 100000000000 ) <NEWLINE> <DEDENT> ] <NEWLINE> consensus = <STRING> <NEWLINE> working_dir = None <NEWLINE>
def test_execute ( self ) : <NEWLINE> <INDENT> result = self . task_ep . execute ( task_name = self . task_cls_name , <NEWLINE> <INDENT> task_uuid = self . task_uuid , <NEWLINE> arguments = self . task_args , <NEWLINE> progress_callback = None ) <NEWLINE> <DEDENT> self . assertEqual ( result , self . task_result ) <NEWLINE> <DEDENT>
from rtc_handle import * <NEWLINE> from BasicDataType_idl import * <NEWLINE> import time <NEWLINE> import commands <NEWLINE> env = RtmEnv ( sys . argv , [ <STRING> ] ) <NEWLINE> list0 = env . name_space [ <STRING> ] . list_obj ( ) <NEWLINE> env . name_space [ <STRING> ] . rtc_handles . keys ( ) <NEWLINE> ns = env . name_space [ <STRING> ] <NEWLINE> time . sleep ( 2 ) <NEWLINE> compo1 = ns . rtc_handles [ <STRING> ] <NEWLINE> compo0 = ns . rtc_handles [ <STRING> ] <NEWLINE> seqin0 = ns . rtc_handles [ <STRING> ] <NEWLINE> ec = compo0 . rtc_ref . get_owned_contexts ( ) <NEWLINE>
DOCUMENTATION = <STRING> <NEWLINE> import json <NEWLINE> import requests <NEWLINE> import sys <NEWLINE> import time <NEWLINE> from ansible . module_utils . basic import AnsibleModule <NEWLINE> API_BASE = <STRING> <NEWLINE> API_HEADERS = { <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE>
import json <NEWLINE> from Tribler . Core . exceptions import TriblerException <NEWLINE> from Tribler . Test . twisted_thread import deferred <NEWLINE> from base_api_test import AbstractApiTest <NEWLINE>
def migrate_users ( index ) : <NEWLINE> <INDENT> logger . info ( <STRING> . format ( index ) ) <NEWLINE> n_migr = 0 <NEWLINE> n_iter = 0 <NEWLINE> for user in User . find ( ) : <NEWLINE> <INDENT> if user . is_active : <NEWLINE> <INDENT> search . update_user ( user , index = index ) <NEWLINE> n_migr += 1 <NEWLINE> <DEDENT> n_iter += 1 <NEWLINE> <DEDENT> logger . info ( <STRING> . format ( n_iter , n_migr ) ) <NEWLINE> <DEDENT>
class Users ( AbstractUser ) : <NEWLINE> <INDENT> profile_pic = models . CharField ( max_length = 30 , null = True ) <NEWLINE> last_activity = models . DateTimeField ( null = True , blank = True ) <NEWLINE> class Meta ( AbstractUser . Meta ) : <NEWLINE> <INDENT> swappable = <STRING> <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from django . core . management . base import NoArgsCommand <NEWLINE> from media_bundler . conf import bundler_settings <NEWLINE> from media_bundler import bundler <NEWLINE> from media_bundler import versioning <NEWLINE>
def __init__ ( self ) : <NEWLINE> <INDENT> self . name = <STRING> <NEWLINE> self . description = <STRING> <NEWLINE> self . benchmark = <STRING> <NEWLINE> self . country = <STRING> <NEWLINE> self . currency = <STRING> <NEWLINE> self . f_penny_threshold = 5.0 <NEWLINE> self . suffix = <STRING> <NEWLINE> now = dt . datetime . now ( ) <NEWLINE> year = now . year <NEWLINE> self . all_symbols_list = <STRING> % year <NEWLINE> self . ls_indexes = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> super ( NYSEExchange , self ) . __init__ ( ) <NEWLINE> <DEDENT>
import copy <NEWLINE> import re <NEWLINE> import sys <NEWLINE> from SilverCity import ScintillaConstants <NEWLINE> import logging <NEWLINE> MAX_REASONABLE_LIMIT = 10000 <NEWLINE> WHITESPACE = <STRING> <NEWLINE> ws_re = re . compile ( <STRING> + WHITESPACE + <STRING> + <STRING> ) <NEWLINE> trailing_spaces_re = re . compile ( <STRING> ) <NEWLINE> trim_ws_re2 = re . compile ( <STRING> ) <NEWLINE> trim_ws_re3 = re . compile ( <STRING> ) <NEWLINE>
def get_delivery_backend_class ( delivery_str = None ) : <NEWLINE> <INDENT> return str_to_class ( delivery_str , <STRING> , <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def _update_registration_date_end ( self , registration ) : <NEWLINE> <INDENT> super ( WizEventDeleteAssistant , self ) . _update_registration_date_end ( <NEWLINE> <INDENT> registration ) <NEWLINE> <DEDENT> reg_date_end = str2datetime ( registration . date_end ) <NEWLINE> wiz_from_date = _convert_to_utc_date ( <NEWLINE> <INDENT> self . from_date , time = self . start_time , tz = self . env . user . tz ) <NEWLINE> <DEDENT> if wiz_from_date != reg_date_end : <NEWLINE> <INDENT> registration . date_end = wiz_from_date <NEWLINE> <DEDENT> <DEDENT>
import os <NEWLINE> import datetime <NEWLINE> current_dir = os . path . abspath ( os . path . dirname ( __file__ ) ) <NEWLINE> picture = current_dir + <STRING> <NEWLINE> today = str ( datetime . date . today ( ) ) <NEWLINE>
class NewCSVForm ( Form ) : <NEWLINE> <INDENT> file_upload = FileField ( validators = [ DataRequired ( ) ] ) <NEWLINE> replace_or_merge = SelectField ( <STRING> , choices = [ ( <STRING> , <STRING> ) , ( <STRING> , <STRING> ) ] , validators = [ DataRequired ( ) ] ) <NEWLINE> submit = SubmitField ( <STRING> ) <NEWLINE> <DEDENT>
from django import forms <NEWLINE> import Image <NEWLINE> from models import Post <NEWLINE> from django . utils . translation import ugettext_lazy as _ <NEWLINE>
def __receive_mode__ ( self ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> beacon = self . receive ( ) <NEWLINE> if beacon : <NEWLINE> <INDENT> print ( beacon ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def database_forwards ( self , app_label , schema_editor , from_state , to_state ) : <NEWLINE> <INDENT> old_apps = from_state . render ( ) <NEWLINE> new_apps = to_state . render ( ) <NEWLINE> old_model = old_apps . get_model ( app_label , self . name ) <NEWLINE> new_model = new_apps . get_model ( app_label , self . name ) <NEWLINE> if self . allowed_to_migrate ( schema_editor . connection . alias , new_model ) : <NEWLINE> <INDENT> schema_editor . alter_db_table ( <NEWLINE> <INDENT> new_model , <NEWLINE> old_model . _meta . db_table , <NEWLINE> new_model . _meta . db_table , <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> <DEDENT>
class TestPickleFix ( GPflowTestCase ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def test ( self ) : <NEWLINE> <INDENT> with self . test_session ( ) : <NEWLINE> <INDENT> k = gpflow . kernels . PeriodicKernel ( 1 ) <NEWLINE> k . period . fixed = True <NEWLINE> k = pickle . loads ( pickle . dumps ( k ) ) <NEWLINE> x = np . linspace ( 0 , 1 , 100 ) . reshape ( [ - 1 , 1 ] ) <NEWLINE> k . compute_K ( x , x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from flask import Blueprint , request , redirect , render_template , url_for <NEWLINE> from flask . views import MethodView <NEWLINE> from flask . ext . mongoengine . wtf import model_form <NEWLINE> from watchmen . models import Event , History <NEWLINE> events = Blueprint ( <STRING> , __name__ , template_folder = <STRING> ) <NEWLINE>
class converter ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , callback , descr ) : <NEWLINE> <INDENT> self . callback = callback <NEWLINE> self . descr = descr <NEWLINE> <DEDENT> def describe ( self ) : <NEWLINE> <INDENT> return self . descr <NEWLINE> <DEDENT> def convert ( self , val ) : <NEWLINE> <INDENT> return self . callback ( val ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from . BankAccount import BankAccount <NEWLINE> from . import client_support <NEWLINE>
class Content ( Box ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> super ( Content , self ) . __init__ ( ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , uri , uid ) : <NEWLINE> <INDENT> client = pymongo . MongoClient ( uri ) <NEWLINE> self . database = client [ uid ] <NEWLINE> <DEDENT>
import os <NEWLINE> import imp <NEWLINE> import sys <NEWLINE>
def _get_x_y_from_header ( hdr ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> X = { <STRING> : np . arange ( 0. , hdr [ <STRING> ] * hdr [ <STRING> ] , hdr [ <STRING> ] ) , <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> } <NEWLINE> <DEDENT> Y = { <STRING> : np . arange ( 0. , hdr [ <STRING> ] * hdr [ <STRING> ] , hdr [ <STRING> ] ) , <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> } <NEWLINE> <DEDENT> return X , Y <NEWLINE> <DEDENT>
def throwError ( message ) : <NEWLINE> <INDENT> print ( <STRING> . format ( message ) ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT>
def checkFileExits ( self , path ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if os . path . exists ( path ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT>
class CDS ( Document ) : <NEWLINE> <INDENT> hostname = StringField ( required = True , unique = True ) <NEWLINE> display_name = StringField ( required = False ) <NEWLINE> client_hostname = StringField ( required = False ) <NEWLINE> description = StringField ( required = False ) <NEWLINE> created_at = DateTimeField ( required = True , default = datetime . utcnow ( ) ) <NEWLINE> sync_schedule = StringField ( required = False ) <NEWLINE> cluster_id = StringField ( required = True ) <NEWLINE> meta = { <STRING> : <STRING> } <NEWLINE> last_sync = DateTimeField ( required = False ) <NEWLINE> <DEDENT>
def dumps ( content , pretty = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if pretty and <STRING> in content and <STRING> in content : <NEWLINE> <INDENT> tags = [ <STRING> + e for e in content . split ( <STRING> ) if e != <STRING> ] <NEWLINE> content = <STRING> . join ( prettify_xml ( tags ) ) <NEWLINE> <DEDENT> if not content . lstrip ( ) . startswith ( <STRING> ) : <NEWLINE> <INDENT> content = DOCTYPE + content <NEWLINE> <DEDENT> return <STRING> . format ( pretty * <STRING> , content ) <NEWLINE> <DEDENT>
def get_headers ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> headers = self . BASIC_HEADERS <NEWLINE> if self . session is None : <NEWLINE> <INDENT> self . init_session ( ) <NEWLINE> <DEDENT> headers [ <STRING> ] = <STRING> . format ( self . session ) <NEWLINE> return headers <NEWLINE> <DEDENT>
def test_najdi ( ) : <NEWLINE> <INDENT> herni_pole = 20 * ( <STRING> ) <NEWLINE> symbol_hrace = <STRING> <NEWLINE> assert najdi_symboly ( herni_pole , symbol_hrace ) == list ( ) <NEWLINE> assert najdi_symboly ( <STRING> , symbol_hrace ) == [ 2 , 4 , 6 , 8 ] <NEWLINE> <DEDENT>
from glob import glob <NEWLINE> from setuptools import setup <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> version = <STRING> , <NEWLINE> author = <STRING> , <NEWLINE> author_email = <STRING> , <NEWLINE> description = ( <STRING> ) , <NEWLINE> license = <STRING> , <NEWLINE> keywords = <STRING> , <NEWLINE> url = <STRING> , <NEWLINE> packages = [ <STRING> ] , <NEWLINE> scripts = glob ( <STRING> ) , <NEWLINE> long_description = open ( <STRING> ) . read ( ) , <NEWLINE> classifiers = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <DEDENT> ] , <NEWLINE> <DEDENT> ) <NEWLINE>
default_app_config = <STRING> <NEWLINE> try : <NEWLINE> <INDENT> from wechat_sdk . context . framework . django . models import Context as DatabaseContext <NEWLINE> from wechat_sdk . context . framework . django . backends . db import ContextStore as DatabaseContextStore <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
from PySide . QtCore import * <NEWLINE> from PySide . QtGui import * <NEWLINE> from Settings import Settings <NEWLINE> import pdb <NEWLINE> import types <NEWLINE>
def make_instance_obj ( self , obj ) : <NEWLINE> <INDENT> return { <NEWLINE> <INDENT> <STRING> : obj . nodes . all ( ) , <NEWLINE> <STRING> : obj <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>
from scrapy . spiders import Spider <NEWLINE> from projects . bixiawenxue . bixiawenxue . items import ChapterItem <NEWLINE> from helper . textUtil import removeTagsAndWhiteSpaces <NEWLINE> from pymongo . mongo_client import MongoClient <NEWLINE>
import requests <NEWLINE> import base64 <NEWLINE> import copy <NEWLINE> from sjcl import SJCL <NEWLINE>
def _command_handler ( self , url , command ) : <NEWLINE> <INDENT> self . req_urls . append ( url ) <NEWLINE> self . req_commands . append ( command ) <NEWLINE> <DEDENT>
def delete ( self , trans , ** kwd ) : <NEWLINE> <INDENT> idnum = kwd [ self . tagged_item_id ] <NEWLINE> item = self . _get_item_from_id ( trans , idnum ) <NEWLINE> if item is not None : <NEWLINE> <INDENT> return self . delete_item_annotation ( trans . sa_session , trans . get_user ( ) , item ) <NEWLINE> <DEDENT> <DEDENT>
from __future__ import unicode_literals <NEWLINE> from django . db import models , migrations <NEWLINE> from django . apps import apps <NEWLINE>
from otz . Timestream import CalibrationTimestream , CapturedTimestream <NEWLINE> from otz . Calibration import Calibration <NEWLINE> from otz . Beam import Beam , Bead <NEWLINE>
class Piece : <NEWLINE> <INDENT> <STRING> <NEWLINE> __metaclass__ = ABCMeta <NEWLINE> colors = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> def __init__ ( self , name , label , player ) : <NEWLINE> <INDENT> self . name = name <NEWLINE> self . label = label <NEWLINE> self . color = None <NEWLINE> self . player_num = player <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return self . name <NEWLINE> <DEDENT> def __lt__ ( self , other ) : <NEWLINE> <INDENT> return self . name < other . name <NEWLINE> <DEDENT> @ abstractmethod <NEWLINE> def moves ( self , x , y , board ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from . generate import nextprime , prevprime , prime , primepi , primerange , randprime , Sieve , sieve , primorial , cycle_length <NEWLINE> from . primetest import isprime <NEWLINE> from . factor_ import divisors , factorint , multiplicity , perfect_power , pollard_pm1 , pollard_rho , primefactors , totient , trailing , divisor_count , divisor_sigma <NEWLINE> from . partitions_ import npartitions <NEWLINE> from . residue_ntheory import is_primitive_root , is_quad_residue , legendre_symbol , jacobi_symbol , n_order , sqrt_mod , quadratic_residues , primitive_root , nthroot_mod , is_nthpow_residue , sqrt_mod_iter , mobius <NEWLINE> from . multinomial import binomial_coefficients , binomial_coefficients_list , multinomial_coefficients <NEWLINE> from . continued_fraction import continued_fraction_periodic , continued_fraction_iterator , continued_fraction_reduce , continued_fraction_convergents <NEWLINE> from . egyptian_fraction import egyptian_fraction <NEWLINE>
import sys <NEWLINE> import json <NEWLINE> import time <NEWLINE> import ibmiotf . application <NEWLINE> from ibmiotf import APIException <NEWLINE> import requests <NEWLINE> import signal <NEWLINE> import argparse <NEWLINE> import logging <NEWLINE> from logging . handlers import RotatingFileHandler <NEWLINE>
from distutils . core import setup <NEWLINE> from setuptools import find_packages <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> version = <STRING> , <NEWLINE> author = <STRING> , <NEWLINE> author_email = <STRING> , <NEWLINE> url = <STRING> , <NEWLINE> license = <STRING> , <NEWLINE> description = <STRING> , <NEWLINE> long_description = open ( <STRING> ) . read ( ) , <NEWLINE> zip_safe = False , <NEWLINE> packages = find_packages ( ) , <NEWLINE> setup_requires = [ <STRING> , <STRING> ] , <NEWLINE> install_requires = [ <STRING> , <STRING> ] <NEWLINE> <DEDENT> ) <NEWLINE>
class LoginForm ( BaseForm ) : <NEWLINE> <INDENT> username = TextField ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> validators = [ DataRequired ( ) ] <NEWLINE> <DEDENT> ) <NEWLINE> password = PasswordField ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> validators = [ DataRequired ( ) ] <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
from django . contrib . gis . db import models <NEWLINE> from lizard_security . manager import FilteredGeoManager <NEWLINE> from lizard_security . models import DataSet <NEWLINE> from lizard_measure . models import ( <NEWLINE> <INDENT> WaterBody , <NEWLINE> Measure , <NEWLINE> <DEDENT> ) <NEWLINE> from lizard_area . models import Area <NEWLINE> from lizard_workspace . models import ( <NEWLINE> <INDENT> LayerWorkspace , <NEWLINE> LayerCollage , <NEWLINE> <DEDENT> ) <NEWLINE> from lizard_history . utils import get_simple_history <NEWLINE> import copy <NEWLINE> from django . contrib . contenttypes . models import ContentType <NEWLINE> from django . contrib . contenttypes import generic <NEWLINE> from django . core . urlresolvers import reverse <NEWLINE> from django . utils . translation import ugettext as _ <NEWLINE>
class OutlineCodeItemsResponse ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . swaggerTypes = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> <DEDENT> } <NEWLINE> self . attributeMap = { <NEWLINE> <INDENT> <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> <DEDENT> self . OutlineCodes = None <NEWLINE> self . Code = None <NEWLINE> self . Status = None <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from __future__ import print_function <NEWLINE> import time <NEWLINE> import argparse <NEWLINE> from notary_db import ndb <NEWLINE> import notary_common <NEWLINE> DEFAULT_OUTFILE = <STRING> <NEWLINE>
class iCalentador ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> logging . info ( <STRING> ) <NEWLINE> self . calentador = mraa . Gpio ( 3 ) <NEWLINE> self . estado = 0 <NEWLINE> <DEDENT> def iCalentadorPrender ( self , estado ) : <NEWLINE> <INDENT> self . calentador . dir ( mraa . DIR_OUT ) <NEWLINE> self . calentador . write ( estado ) <NEWLINE> <DEDENT> def iCalentadorEstado ( self ) : <NEWLINE> <INDENT> return self . calentador . read ( ) <NEWLINE> <DEDENT> <DEDENT>
import skills . _kick <NEWLINE> import behavior <NEWLINE> import constants <NEWLINE> import robocup <NEWLINE> import enum <NEWLINE> import main <NEWLINE> import role_assignment <NEWLINE>
def selectOption ( self , selector ) : <NEWLINE> <INDENT> self . client . nowait ( <STRING> , ( selector , ) ) <NEWLINE> return self <NEWLINE> <DEDENT>
import urllib <NEWLINE> import requests <NEWLINE> import soundcloud <NEWLINE> import hashconversions <NEWLINE>
class LeftRightHandWordsTest ( unittest . TestCase ) : <NEWLINE> <INDENT> def test_search ( self ) : <NEWLINE> <INDENT> res = search ( [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ] ) <NEWLINE> <DEDENT> smallest_left , smallest_right , largest_left , largest_right = res <NEWLINE> self . assertEquals ( <STRING> , smallest_left ) <NEWLINE> self . assertEquals ( <STRING> , smallest_right ) <NEWLINE> self . assertEquals ( <STRING> , largest_left ) <NEWLINE> self . assertEquals ( <STRING> , largest_right ) <NEWLINE> <DEDENT> <DEDENT>
def format_directive ( module , package = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> directive = <STRING> % makename ( package , module ) <NEWLINE> for option in OPTIONS : <NEWLINE> <INDENT> directive += <STRING> % option <NEWLINE> <DEDENT> return directive <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from . parameters import PARAMETERS_DEFAULT , set_base_folder , scale_parameters <NEWLINE> from . data_handler import DataHandler <NEWLINE> from . pass1 import FirstPass <NEWLINE> from . pass2 import SecondPass <NEWLINE> from . pass3 import ThirdPass <NEWLINE> from . pass4 import FourthPass <NEWLINE>
def start ( urls ) : <NEWLINE> <INDENT> logger . debug ( <STRING> ) <NEWLINE> logger . debug ( urls ) <NEWLINE> for url in urls : <NEWLINE> <INDENT> logger . debug ( <STRING> ) <NEWLINE> Task ( url , None ) <NEWLINE> Thread ( target = Task ( url , None ) . run ( ) ) <NEWLINE> <DEDENT> <DEDENT>
class About ( Resource ) : <NEWLINE> <INDENT> def get ( self , app_id = None ) : <NEWLINE> <INDENT> if app_id : <NEWLINE> <INDENT> return api_util . attach_meta ( utils . get_app_info_object ( app_id ) , <NEWLINE> <INDENT> meta_success ) , 200 <NEWLINE> <DEDENT> <DEDENT> message = ( <STRING> <NEWLINE> <INDENT> <STRING> . format ( <STRING> . join ( utils . get_supported_apps ( ) ) ) ) <NEWLINE> <DEDENT> return api_util . attach_meta ( { } , <NEWLINE> <INDENT> meta_success , <NEWLINE> message = message ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from . import summary <NEWLINE> from . import summary_seq <NEWLINE> from . import summary_address_person <NEWLINE> from . import summary_address_event <NEWLINE> from . import summary_address_document <NEWLINE> from . import summary_address_lab_test_request <NEWLINE> from . import summary_person_event <NEWLINE> from . import summary_person_document <NEWLINE> from . import summary_person_lab_test_request <NEWLINE>
def is_strict_mode ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return os . environ . get ( <STRING> , <STRING> ) == <STRING> <NEWLINE> <DEDENT>
from twisted . protocols import basic <NEWLINE> from twisted . python import log <NEWLINE> from PyChat import command as cmd <NEWLINE> CLIENT_PREFIX = cmd . CLIENT_PREFIX <NEWLINE>
def listClasses ( module = None ) : <NEWLINE> <INDENT> if module : <NEWLINE> <INDENT> __import__ ( module ) <NEWLINE> pkg = sys . modules [ module ] <NEWLINE> print ( <STRING> ) <NEWLINE> for k , v in sorted ( list ( pkg . __dict__ . items ( ) ) ) : <NEWLINE> <INDENT> if inspect . isclass ( v ) and issubclass ( v , Interface ) : <NEWLINE> <INDENT> print ( <STRING> % k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
from . models import ( load_fmm_model , <NEWLINE> <INDENT> RetinotopyModel , RetinotopyMeshModel , RegisteredRetinotopyModel , <NEWLINE> SchiraModel ) <NEWLINE> <DEDENT> from . retinotopy import ( empirical_retinotopy_data , predicted_retinotopy_data , retinotopy_data , <NEWLINE> <INDENT> extract_retinotopy_argument , <NEWLINE> register_retinotopy , retinotopy_anchors , retinotopy_model , <NEWLINE> predict_retinotopy , register_retinotopy_initialize , <NEWLINE> mesh_retinotopy , as_retinotopy , retinotopic_field_sign , <NEWLINE> clean_retinotopy , predict_pRF_radius ) <NEWLINE> <DEDENT> from . cmag import ( neighborhood_cortical_magnification , path_cortical_magnification , <NEWLINE> <INDENT> isoangular_path ) <NEWLINE> <DEDENT>
def _register_psutil_metrics ( self , stats , names_to_metric_types ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> base_metric = <STRING> <NEWLINE> for k , v in stats . iteritems ( ) : <NEWLINE> <INDENT> metric_type = names_to_metric_types [ k ] <NEWLINE> if isinstance ( v , dict ) : <NEWLINE> <INDENT> for _k , _v in v . iteritems ( ) : <NEWLINE> <INDENT> full_metric_name = base_metric . format ( k , _k ) <NEWLINE> self . _send_single_metric ( full_metric_name , _v , metric_type ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> full_metric_name = <STRING> . format ( k ) <NEWLINE> self . _send_single_metric ( full_metric_name , v , metric_type ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import os <NEWLINE> import urllib . request <NEWLINE> import shutil <NEWLINE> from bs4 import BeautifulSoup <NEWLINE> URL = <STRING> <NEWLINE> headers = { <STRING> : <STRING> , } <NEWLINE>
import sys <NEWLINE> import optparse <NEWLINE> import inspect <NEWLINE> import time <NEWLINE> import imaplib <NEWLINE> import re <NEWLINE>
def test ( var ) : <NEWLINE> <INDENT> x = var <NEWLINE> try : x <NEWLINE> except NameError : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT>
def getAFBC_vof ( x , flag ) : <NEWLINE> <INDENT> if flag == boundaryTags [ <STRING> ] : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> elif flag == boundaryTags [ <STRING> ] : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> elif flag == boundaryTags [ <STRING> ] : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return lambda x , t : 0.0 <NEWLINE> <DEDENT> <DEDENT>
def construct_int ( value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if value == <STRING> or value is None : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> print ( value ) <NEWLINE> index = value . find ( <STRING> ) <NEWLINE> if index is - 1 : <NEWLINE> <INDENT> return int ( value ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return int ( value [ : index ] + value [ index + 1 : ] ) <NEWLINE> <DEDENT> <DEDENT>
def to_json ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return json . dumps ( self , cls = ReportJSONEncoder ) <NEWLINE> <DEDENT>
from __future__ import ( absolute_import , unicode_literals , division , <NEWLINE> <INDENT> print_function ) <NEWLINE> <DEDENT> from . . attributes import TimeAttribute <NEWLINE> from . utils import DEFAULT_OBSTIME <NEWLINE> from . baseradec import _base_radec_docstring , BaseRADecFrame <NEWLINE>
revision = <STRING> <NEWLINE> down_revision = <STRING> <NEWLINE> from alembic import op <NEWLINE> import sqlalchemy as sa <NEWLINE> from sqlalchemy . ext . declarative import declarative_base <NEWLINE> from sqlalchemy . orm import sessionmaker <NEWLINE> import re <NEWLINE>
def test_alias_cleanup ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> tests = [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE> for dirty , clean in tests : <NEWLINE> <INDENT> self . assertEqual ( Alias . clean_up_name ( dirty ) , clean ) <NEWLINE> <DEDENT> <DEDENT>
class WPTagTest ( WPTestCase ) : <NEWLINE> <INDENT> def test_get_absolute_url_works ( self ) : <NEWLINE> <INDENT> tag = WPTagFactory ( ) <NEWLINE> self . assertTrue ( tag . get_absolute_url ( ) ) <NEWLINE> <DEDENT> <DEDENT>
class TestCIPlugInInterface ( TestCase ) : <NEWLINE> <INDENT> def testMethods ( self ) : <NEWLINE> <INDENT> self . assertResultIsBOOL ( TestCIPluginInterfaceHelper . load_ ) <NEWLINE> <DEDENT> def no_testProtocol ( self ) : <NEWLINE> <INDENT> p = objc . protocolNamed ( <STRING> ) <NEWLINE> self . assertIsInstancE ( p , objc . formal_protocol ) <NEWLINE> <DEDENT> <DEDENT>
class Anthill : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , arg ) : <NEWLINE> <INDENT> self . arg = arg <NEWLINE> <DEDENT> <DEDENT>
def create_slots ( self , cursor ) : <NEWLINE> <INDENT> from queries import create_slots <NEWLINE> print ( <STRING> ) <NEWLINE> cursor . execute ( create_slots ) <NEWLINE> self . connection . commit ( ) <NEWLINE> <DEDENT>
def register_goals ( ) : <NEWLINE> <INDENT> Goal . register ( <STRING> , <STRING> ) <NEWLINE> task ( name = <STRING> , action = SquareDepmap ) . install ( <STRING> ) <NEWLINE> <DEDENT>
import datetime <NEWLINE> import hashlib <NEWLINE> import os <NEWLINE> import unicodedata <NEWLINE> from django . db import models <NEWLINE> from django . contrib . auth . models import User <NEWLINE> from crashstats . base . utils import get_now <NEWLINE>
<STRING> <NEWLINE> from setuptools import setup <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> version = <STRING> , <NEWLINE> url = <STRING> , <NEWLINE> license = <STRING> , <NEWLINE> description = <STRING> , <NEWLINE> author = <STRING> , <NEWLINE> author_email = <STRING> , <NEWLINE> packages = [ <STRING> ] , <NEWLINE> install_requires = [ <STRING> ] , <NEWLINE> include_package_data = True , <NEWLINE> classifiers = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <DEDENT> ] , <NEWLINE> <DEDENT> ) <NEWLINE>
from ooop import OOOP <NEWLINE> o = OOOP ( dbname = <STRING> ) <NEWLINE> partners = o . ResPartner . all ( ) <NEWLINE> for partner in partners : <NEWLINE> <INDENT> print ( <STRING> % ( partner . _ref , partner . name ) ) <NEWLINE> <DEDENT>
class URLTest ( unittest . TestCase ) : <NEWLINE> <INDENT> def test_valid_url ( self ) : <NEWLINE> <INDENT> url = <STRING> <NEWLINE> option = config_options . URL ( ) <NEWLINE> value = option . validate ( url ) <NEWLINE> self . assertEqual ( value , url ) <NEWLINE> <DEDENT> def test_invalid_url ( self ) : <NEWLINE> <INDENT> option = config_options . URL ( ) <NEWLINE> self . assertRaises ( config_options . ValidationError , <NEWLINE> <INDENT> option . validate , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def test_invalid ( self ) : <NEWLINE> <INDENT> option = config_options . URL ( ) <NEWLINE> self . assertRaises ( config_options . ValidationError , <NEWLINE> <INDENT> option . validate , 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import arcrest <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> url = <STRING> <NEWLINE> username = <STRING> <NEWLINE> password = <STRING> <NEWLINE> sh = arcrest . AGOLTokenSecurityHandler ( username , password ) <NEWLINE> agolServices = arcrest . hostedservice . Services ( url , securityHandler = sh ) <NEWLINE> for service in agolServices . services : <NEWLINE> <INDENT> if isinstance ( service , arcrest . hostedservice . AdminMapService ) : <NEWLINE> <INDENT> print ( service . id ) <NEWLINE> print ( service . urlService ) <NEWLINE> print ( service . name ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def has_user_profile ( u ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> u . get_profile ( ) <NEWLINE> <DEDENT> except UserProfile . DoesNotExist : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT>
def getDirs ( software_folders ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> software_folders += [ folder for folder in os . listdir ( <NEWLINE> <INDENT> dir ) if os . path . isdir ( folder ) ] <NEWLINE> <DEDENT> <DEDENT> except IOError as e : <NEWLINE> <INDENT> print ( <STRING> . format ( e . errno , e . strerror ) ) <NEWLINE> <DEDENT> except OSError as e : <NEWLINE> <INDENT> print ( <STRING> . format ( e . errno , e . strerror ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> , sys . exc_info ( ) [ 0 ] ) <NEWLINE> raise <NEWLINE> <DEDENT> <DEDENT>
file_for_reading = open ( <STRING> , <STRING> ) <NEWLINE> file_for_writing = open ( <STRING> , <STRING> ) <NEWLINE> file_for_appending = open ( <STRING> , <STRING> ) <NEWLINE> file_for_writing . close ( ) <NEWLINE> count = 0 <NEWLINE> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> for line in f : <NEWLINE> <INDENT> if re . match ( <STRING> , line ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import logging <NEWLINE> from django . conf import settings <NEWLINE> from django . core . mail . message import EmailMultiAlternatives <NEWLINE> from django . template . loader import get_template <NEWLINE> from django . urls import reverse <NEWLINE> from django . utils . translation import ugettext_lazy as _ <NEWLINE> from opaque_keys . edx . keys import CourseKey <NEWLINE> from course_discovery . apps . publisher . models import CourseRun <NEWLINE> from course_discovery . apps . publisher . utils import is_email_notification_enabled <NEWLINE> log = logging . getLogger ( __name__ ) <NEWLINE>
def get_data ( self ) : <NEWLINE> <INDENT> links = self . generate_link ( ) <NEWLINE> pool = Pool ( 8 ) <NEWLINE> pool . map ( self . sub_get , links ) <NEWLINE> <DEDENT>
from distutils . core import setup <NEWLINE> import py2exe <NEWLINE> import gio <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> description = <STRING> , <NEWLINE> version = <STRING> , <NEWLINE> windows = [ <NEWLINE> <INDENT> { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : [ ( 1 , <STRING> ) ] , <NEWLINE> <DEDENT> } <NEWLINE> ] , <NEWLINE> <DEDENT> options = { <NEWLINE> <INDENT> <STRING> : { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <DEDENT> } <NEWLINE> } , <NEWLINE> data_files = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> <NEWLINE> ] <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def ListDirectoryAbsolute ( directory ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return ( os . path . join ( directory , path ) <NEWLINE> <INDENT> for path in tf . gfile . ListDirectory ( directory ) ) <NEWLINE> <DEDENT> <DEDENT>
from distutils . core import setup <NEWLINE> setup ( name = <STRING> , <NEWLINE> <INDENT> version = <STRING> , <NEWLINE> author = <STRING> , <NEWLINE> author_email = <STRING> , <NEWLINE> url = <STRING> , <NEWLINE> description = <STRING> , <NEWLINE> long_description = <STRING> , <NEWLINE> requires = [ <STRING> ] , <NEWLINE> packages = [ <STRING> ] , <NEWLINE> py_modules = [ <STRING> ] , <NEWLINE> package_dir = { <STRING> : <STRING> } , <NEWLINE> license = <STRING> <NEWLINE> ) <NEWLINE> <DEDENT>
def OrEvent ( * events ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> or_event = threading . Event ( ) <NEWLINE> def changed ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> bools = [ event_i . is_set ( ) for event_i in events ] <NEWLINE> if any ( bools ) : <NEWLINE> <INDENT> or_event . set ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> or_event . clear ( ) <NEWLINE> <DEDENT> <DEDENT> for event_i in events : <NEWLINE> <INDENT> orify ( event_i , changed ) <NEWLINE> <DEDENT> changed ( ) <NEWLINE> return or_event <NEWLINE> <DEDENT>
def test_name_returns_custom_name_when_given ( self ) : <NEWLINE> <INDENT> f = File ( io . StringIO ( <STRING> ) , <STRING> ) <NEWLINE> self . assertEqual ( f . name , <STRING> ) <NEWLINE> <DEDENT>
class TestMobileSpecAppFunctions ( unittest . TestCase ) : <NEWLINE> <INDENT> def test_launch ( self ) : <NEWLINE> <INDENT> comm . setUp ( ) <NEWLINE> app_name = <STRING> <NEWLINE> pkg_name = <STRING> + app_name . lower ( ) <NEWLINE> if not comm . check_app_installed ( pkg_name , self ) : <NEWLINE> <INDENT> comm . app_install ( app_name , pkg_name , self ) <NEWLINE> <DEDENT> comm . app_launch ( app_name , pkg_name , self ) <NEWLINE> <DEDENT> <DEDENT>
import matplotlib . pyplot as plt <NEWLINE> import numpy as np <NEWLINE> fig = plt . figure ( ) <NEWLINE> ent = ( np . loadtxt ( <STRING> ) ) . T <NEWLINE> plt . xlabel ( <STRING> ) <NEWLINE> plt . ylabel ( <STRING> , rotation = <STRING> ) <NEWLINE> plt . plot ( ent [ 0 ] , ent [ 1 ] , <STRING> ) <NEWLINE> plt . grid ( True ) <NEWLINE> plt . show ( ) <NEWLINE>
def headerData ( self , col , orientation = Qt . Horizontal , role = Qt . DisplayRole ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if role != Qt . DisplayRole : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> if orientation == Qt . Horizontal : <NEWLINE> <INDENT> if col == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif col == 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif col == 2 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class Sample ( object ) : <NEWLINE> <INDENT> def __init__ ( self , the_id , filename , size , size_in_bytes , upload_date_utc , upload_status ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . id = the_id <NEWLINE> self . filename = filename <NEWLINE> self . human_readable_size = size <NEWLINE> self . size_in_bytes = size_in_bytes , <NEWLINE> self . upload_date = upload_date_utc <NEWLINE> self . upload_status = upload_status <NEWLINE> <DEDENT> @ property <NEWLINE> def localized_upload_date ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return localize_utc_datetime_to_local_timezone ( self . upload_date ) <NEWLINE> <DEDENT> <DEDENT>
import pecan <NEWLINE> from webtest import TestApp <NEWLINE> from peacock import model <NEWLINE>
from flask import abort <NEWLINE> from flask . ext . sqlalchemy import Pagination <NEWLINE> from sqlalchemy import func <NEWLINE> from sqlalchemy . orm import aliased <NEWLINE> from sqlalchemy . sql import and_ <NEWLINE> from MonkeyBook . extensions import db <NEWLINE> from MonkeyBook . models . monkey import Monkey , monkey_friends , best_friends <NEWLINE>
from nose . tools import ( <NEWLINE> <INDENT> eq_ , <NEWLINE> ok_ , <NEWLINE> <DEDENT> ) <NEWLINE> from . . mapping import ( <NEWLINE> <INDENT> Mapping , <NEWLINE> MappingProperty , <NEWLINE> object_property , <NEWLINE> <DEDENT> ) <NEWLINE> from . . schema import JSONSchema <NEWLINE> from . . types import ( <NEWLINE> <INDENT> Integer , <NEWLINE> String , <NEWLINE> <DEDENT> ) <NEWLINE>
<STRING> <NEWLINE> __author__ = <STRING> <NEWLINE> __date__ = <STRING> <NEWLINE> __copyright__ = <STRING> <NEWLINE> __revision__ = <STRING> <NEWLINE> import os <NEWLINE> from PyQt4 import uic <NEWLINE> from PyQt4 . QtCore import QUrl <NEWLINE> from PyQt4 . QtGui import QDesktopServices <NEWLINE> pluginPath = os . path . split ( os . path . dirname ( __file__ ) ) [ 0 ] <NEWLINE> WIDGET , BASE = uic . loadUiType ( <NEWLINE> <INDENT> os . path . join ( pluginPath , <STRING> , <STRING> ) ) <NEWLINE> <DEDENT>
from django . conf . urls import url <NEWLINE> from django . contrib import admin <NEWLINE> from actors . views import ActorsView <NEWLINE> urlpatterns = [ <NEWLINE> <INDENT> url ( <STRING> , admin . site . urls ) , <NEWLINE> url ( <STRING> , ActorsView . as_view ( ) , name = <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE>
def handle_departure ( event ) : <NEWLINE> <INDENT> aircraft = event . sender <NEWLINE> aircraft . depart ( ) <NEWLINE> aircraft . controller . calibrate ( ) <NEWLINE> <DEDENT>
def forwards ( self , orm ) : <NEWLINE> <INDENT> db . add_column ( <STRING> , <STRING> , self . gf ( <STRING> ) ( default = 2.0 ) , keep_default = False ) <NEWLINE> db . add_column ( <STRING> , <STRING> , self . gf ( <STRING> ) ( default = 100.0 ) , keep_default = False ) <NEWLINE> <DEDENT>
def enable_default_plugins ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> global config <NEWLINE> changed = False <NEWLINE> for module_path in DEFAULT_PLUGINS : <NEWLINE> <INDENT> if module_path not in config [ <STRING> ] : <NEWLINE> <INDENT> config [ <STRING> ] . append ( module_path ) <NEWLINE> logger . warning ( <NEWLINE> <INDENT> ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> <DEDENT> ) . format ( mod = module_path ) <NEWLINE> <DEDENT> ) <NEWLINE> changed = True <NEWLINE> <DEDENT> <DEDENT> if changed : <NEWLINE> <INDENT> save ( ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> __author__ = <STRING> <NEWLINE> import os <NEWLINE> import time <NEWLINE> import re <NEWLINE> import datetime <NEWLINE>
<STRING> <NEWLINE> import uuid <NEWLINE> from beacons import app <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> app . secret_key = str ( uuid . uuid4 ( ) ) <NEWLINE> app . run ( debug = True ) <NEWLINE> <DEDENT>
class GUIThread ( Thread ) : <NEWLINE> <INDENT> def run ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> self . gtkWindow = GUI ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> Gtk . main ( ) <NEWLINE> <DEDENT> def join ( self ) : <NEWLINE> <INDENT> Gtk . main_quit ( ) <NEWLINE> <DEDENT> <DEDENT>
from django . core . management . base import BaseCommand , CommandError <NEWLINE> from apps . models . models import Initiative <NEWLINE> <STRING> <NEWLINE>
def solve ( self , n_iter = 0 , eps = 1.0e-16 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> err = self . timeStep ( ) <NEWLINE> count = 1 <NEWLINE> while err > eps : <NEWLINE> <INDENT> if n_iter and count >= n_iter : <NEWLINE> <INDENT> return err <NEWLINE> <DEDENT> err = self . timeStep ( ) <NEWLINE> count = count + 1 <NEWLINE> <DEDENT> return count <NEWLINE> <DEDENT>
class ChaincodeSupportStub ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , channel ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . Register = channel . stream_stream ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> request_serializer = ChaincodeMessage . SerializeToString , <NEWLINE> response_deserializer = ChaincodeMessage . FromString , <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class Migration ( SchemaMigration ) : <NEWLINE> <INDENT> def forwards ( self , orm ) : <NEWLINE> <INDENT> safe_add_column ( <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> self . gf ( <STRING> ) ( default = False ) , keep_default = False ) <NEWLINE> <DEDENT> <DEDENT> def backwards ( self , orm ) : <NEWLINE> <INDENT> db . delete_column ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> complete_apps = [ <STRING> ] <NEWLINE> <DEDENT>
def kill ( self , session , name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> self . _ipopo . kill ( name ) <NEWLINE> session . write_line ( <STRING> , name ) <NEWLINE> <DEDENT> except ValueError as ex : <NEWLINE> <INDENT> session . write_line ( <STRING> , ex ) <NEWLINE> return False <NEWLINE> <DEDENT> <DEDENT>
class Migration ( migrations . Migration ) : <NEWLINE> <INDENT> dependencies = [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE> operations = [ <NEWLINE> <INDENT> migrations . AlterField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> field = models . ManyToManyField ( blank = True , help_text = <STRING> , to = <STRING> ) , <NEWLINE> <DEDENT> ) , <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT>
def requires_admin ( f ) : <NEWLINE> <INDENT> @ wraps ( f ) <NEWLINE> def decorated_function ( * args , ** kwargs ) : <NEWLINE> <INDENT> if <STRING> not in g or g . user is None or not g . user . is_admin ( ) : <NEWLINE> <INDENT> flash ( gettext ( <STRING> ) ) <NEWLINE> return redirect ( url_for ( <STRING> ) ) <NEWLINE> <DEDENT> return f ( * args , ** kwargs ) <NEWLINE> <DEDENT> return decorated_function <NEWLINE> <DEDENT>
class QuickbooksToken ( models . Model ) : <NEWLINE> <INDENT> user = models . ForeignKey ( settings . AUTH_USER_MODEL , related_name = <STRING> ) <NEWLINE> access_token = models . CharField ( max_length = 255 ) <NEWLINE> access_token_secret = models . CharField ( max_length = 255 ) <NEWLINE> realm_id = models . CharField ( max_length = 64 ) <NEWLINE> data_source = models . CharField ( max_length = 10 ) <NEWLINE> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> % ( str ( self . user ) , self . id ) <NEWLINE> <DEDENT> <DEDENT>
def GetGccVersion ( env ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not env . Bit ( <STRING> ) : <NEWLINE> <INDENT> return ( None , None , None ) <NEWLINE> <DEDENT> if env . Bit ( <STRING> ) : <NEWLINE> <INDENT> gcc_command = env [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gcc_command = <STRING> <NEWLINE> <DEDENT> version_string = _OutputFromShellCommand ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> % gcc_command ) <NEWLINE> <DEDENT> return tuple ( [ int ( x or <STRING> ) for x in version_string . split ( <STRING> ) ] ) <NEWLINE> <DEDENT>
from bpcs_steg_decode import decode <NEWLINE> from bpcs_steg_encode import encode <NEWLINE> from bpcs_steg_capacity import capacity <NEWLINE> from bpcs_steg_test import test_all <NEWLINE> __version__ = <STRING> <NEWLINE>
class OverrideBackendTestCase ( TestCase ) : <NEWLINE> <INDENT> @ patch ( <STRING> ) <NEWLINE> def test_runcmd ( self , mock_post ) : <NEWLINE> <INDENT> ret = notify ( <STRING> , <STRING> , { <NEWLINE> <INDENT> <STRING> : [ <STRING> ] , <NEWLINE> <STRING> : { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } ) <NEWLINE> self . assertEqual ( ret , 0 ) <NEWLINE> <DEDENT> <DEDENT>
class MultiplexTransport ( BaseTransportMixin ) : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> def __init__ ( self , conn_info ) : <NEWLINE> <INDENT> self . conn_info = conn_info <NEWLINE> <DEDENT> def get_conn_info ( self ) : <NEWLINE> <INDENT> return self . conn_info <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from time import sleep <NEWLINE> sys . path . append ( <STRING> ) <NEWLINE>
def test_pheno_objects_shh_2 ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> objs = get_objects_for_subject ( subject = HUMAN_SHH , <NEWLINE> <INDENT> object_category = <STRING> ) <NEWLINE> <DEDENT> print ( objs ) <NEWLINE> assert HOLOPROSENCEPHALY in objs <NEWLINE> assert len ( objs ) > 50 <NEWLINE> <DEDENT>
def line_matrix ( line ) : <NEWLINE> <INDENT> v0 = line [ 0 : 2 , 0 ] <NEWLINE> v1 = line [ 0 : 2 , 1 ] <NEWLINE> v = v1 - v0 <NEWLINE> length = norm ( v ) <NEWLINE> angle = math . atan2 ( get_y ( v ) , get_x ( v ) ) <NEWLINE> shift_to_v0 = shift_matrix ( get_x ( v0 ) , get_y ( v0 ) ) <NEWLINE> shift_to_center = shift_matrix ( 0 , - 0.5 ) <NEWLINE> scale_to_line = scale_matrix ( length , c2 ) <NEWLINE> rotate_to_line = rotate_matrix ( angle ) <NEWLINE> return shift_to_v0 * shift_to_center * rotate_to_line * scale_to_line <NEWLINE> <DEDENT>
def setUp ( self ) : <NEWLINE> <INDENT> super ( TestSecurityGroupsClient , self ) . setUp ( ) <NEWLINE> fake_auth = fake_auth_provider . FakeAuthProvider ( ) <NEWLINE> self . client = security_groups_client . SecurityGroupsClient ( <NEWLINE> <INDENT> fake_auth , <STRING> , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class Location ( TimeStampedModel ) : <NEWLINE> <INDENT> address = models . TextField ( ) <NEWLINE> def __unicode__ ( self ) : <NEWLINE> <INDENT> return self . address <NEWLINE> <DEDENT> <DEDENT>
from django . contrib import admin <NEWLINE> from answrs . models import UserProfile , Category , Question , Answer <NEWLINE> admin . site . register ( UserProfile ) <NEWLINE> admin . site . register ( Category ) <NEWLINE> admin . site . register ( Question ) <NEWLINE> admin . site . register ( Answer ) <NEWLINE>
from setuptools import setup <NEWLINE> long_description = <STRING> <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> version = <STRING> , <NEWLINE> description = <STRING> , <NEWLINE> long_description = long_description , <NEWLINE> url = <STRING> , <NEWLINE> author = <STRING> , <NEWLINE> author_email = <STRING> , <NEWLINE> license = <STRING> , <NEWLINE> classifiers = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> <NEWLINE> <DEDENT> ] , <NEWLINE> keywords = <STRING> , <NEWLINE> packages = [ <STRING> ] , <NEWLINE> install_requires = [ <STRING> , <STRING> ] <NEWLINE> <DEDENT> ) <NEWLINE>
from isat . rules import * <NEWLINE> from isat . tools import isat_filename <NEWLINE> from game import GameState <NEWLINE> from os . path import exists <NEWLINE> import unittest <NEWLINE>
def testPeek ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . cache . Clear ( ) <NEWLINE> self . cache . PutItem ( <STRING> ) <NEWLINE> self . cache . PutItem ( <STRING> ) <NEWLINE> self . cache . PutItem ( <STRING> ) <NEWLINE> self . assertEquals ( self . cache . PeekNext ( ) , <STRING> ) <NEWLINE> self . assertEquals ( self . cache . PeekPrev ( ) , <STRING> ) <NEWLINE> <DEDENT>
class CompressTestCase ( unittest . TestCase ) : <NEWLINE> <INDENT> def test_regular ( self ) : <NEWLINE> <INDENT> self . assertEquals ( <STRING> , compress ( <STRING> ) ) <NEWLINE> <DEDENT> def test_singles ( self ) : <NEWLINE> <INDENT> self . assertEquals ( <STRING> , compress ( <STRING> ) ) <NEWLINE> <DEDENT> def test_single_letter ( self ) : <NEWLINE> <INDENT> self . assertEquals ( <STRING> , compress ( <STRING> ) ) <NEWLINE> <DEDENT> def test_empty ( self ) : <NEWLINE> <INDENT> self . assertEquals ( <STRING> , compress ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT>
def __components_items_changed ( self , event ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for item in event . removed : <NEWLINE> <INDENT> item . on_trait_change ( self . _component_size_hint_changed , <NEWLINE> <INDENT> <STRING> , remove = True ) <NEWLINE> <DEDENT> del self . _component_map [ item . id ] <NEWLINE> <DEDENT> self . _check_and_add_components ( event . added ) <NEWLINE> <DEDENT>
import unittest <NEWLINE> import mock <NEWLINE> from pollicino import geocoder , exceptions <NEWLINE>
from dal import autocomplete <NEWLINE> import dal_queryset_sequence <NEWLINE> import dal_select2_queryset_sequence <NEWLINE> from django import forms <NEWLINE> from django . forms . widgets import HiddenInput <NEWLINE> from django . forms import ModelForm <NEWLINE> from mezzanine . core . models import Orderable <NEWLINE>
class TestSystemInjector ( TestSystem ) : <NEWLINE> <INDENT> def __init__ ( self , name , system ) : <NEWLINE> <INDENT> self . injected = False <NEWLINE> self . name = name <NEWLINE> self . system = system <NEWLINE> <DEDENT> def step ( self , dt ) : <NEWLINE> <INDENT> TestSystem . step ( self , dt ) <NEWLINE> if not self . injected : <NEWLINE> <INDENT> setattr ( self . world . systems , self . name , self . system ) <NEWLINE> self . injected = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from __future__ import absolute_import <NEWLINE> import os <NEWLINE> import sys <NEWLINE> from _socket import getservbyname , getaddrinfo , gaierror , error <NEWLINE> from gevent . hub import Waiter , get_hub , string_types , text_type , integer_types , reraise , PY3 <NEWLINE> from gevent . socket import AF_UNSPEC , AF_INET , AF_INET6 , SOCK_STREAM , SOCK_DGRAM , SOCK_RAW , AI_NUMERICHOST , EAI_SERVICE , AI_PASSIVE <NEWLINE> from gevent . ares import channel , InvalidIP <NEWLINE> __all__ = [ <STRING> ] <NEWLINE>
def table ( self , name , database = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> alch_table = self . _get_sqla_table ( name ) <NEWLINE> node = SQLiteTable ( alch_table , self ) <NEWLINE> return self . _table_expr_klass ( node ) <NEWLINE> <DEDENT>
import re <NEWLINE> iterations = 40 <NEWLINE> with open ( <STRING> ) as fileobj : <NEWLINE> <INDENT> puzzle = fileobj . readline ( ) . strip ( ) <NEWLINE> <DEDENT> print ( puzzle ) <NEWLINE> for x in range ( 40 ) : <NEWLINE> <INDENT> newpuzzle = <STRING> <NEWLINE> for y in re . finditer ( <STRING> , puzzle ) : <NEWLINE> <INDENT> newpuzzle += str ( len ( y . group ( 0 ) ) ) + y . group ( 0 ) [ 0 ] <NEWLINE> <DEDENT> puzzle = newpuzzle <NEWLINE> <DEDENT> print ( len ( puzzle ) ) <NEWLINE>
class TokenTests ( common . IdentityTests ) : <NEWLINE> <INDENT> def test_token_issue ( self ) : <NEWLINE> <INDENT> raw_output = self . openstack ( <STRING> ) <NEWLINE> items = self . parse_show ( raw_output ) <NEWLINE> self . assert_show_fields ( items , self . TOKEN_FIELDS ) <NEWLINE> <DEDENT> <DEDENT>
def register ( ) : <NEWLINE> <INDENT> Pool . register ( <NEWLINE> <INDENT> Configuration , <NEWLINE> ConfigurationSequence , <NEWLINE> Type , <NEWLINE> Package , <NEWLINE> Move , <NEWLINE> ShipmentOut , <NEWLINE> ShipmentInReturn , <NEWLINE> module = <STRING> , type_ = <STRING> ) <NEWLINE> <DEDENT> Pool . register ( <NEWLINE> <INDENT> PackageLabel , <NEWLINE> module = <STRING> , type_ = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import os <NEWLINE> try : <NEWLINE> <INDENT> import pygimli as pg <NEWLINE> from pygimli . mplviewer import drawMesh , drawModel , drawField <NEWLINE> from pygimli . mplviewer import drawSensors , showLater <NEWLINE> from pygimli . mplviewer import createColorbar , drawStreams , addCoverageAlpha <NEWLINE> <DEDENT> except ImportError as e : <NEWLINE> <INDENT> print ( e ) <NEWLINE> import traceback <NEWLINE> import sys <NEWLINE> traceback . print_exc ( file = sys . stdout ) <NEWLINE> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> import matplotlib . pyplot as plt <NEWLINE> import numpy as np <NEWLINE>
import logging <NEWLINE> logger = logging . getLogger ( <STRING> ) <NEWLINE> _logfile = open ( <STRING> , <STRING> ) <NEWLINE> logging . basicConfig ( stream = _logfile , level = logging . INFO ) <NEWLINE>
def initialize_app ( ) : <NEWLINE> <INDENT> instance_path = os . path . abspath ( os . path . dirname ( __file__ ) + <STRING> ) <NEWLINE> template_folder = os . path . join ( instance_path , <STRING> ) <NEWLINE> static_folder = os . path . join ( instance_path , <STRING> ) <NEWLINE> app = Flask ( <STRING> , static_folder = static_folder , template_folder = template_folder , instance_path = instance_path ) <NEWLINE> initialize_config ( app ) <NEWLINE> initialize_db ( app ) <NEWLINE> initialize_routes ( app ) <NEWLINE> return app <NEWLINE> <DEDENT>
class PymagingException ( Exception ) : pass <NEWLINE> class FormatNotSupported ( PymagingException ) : pass <NEWLINE> class InvalidColor ( PymagingException ) : pass <NEWLINE>
def __check_logged ( self ) : <NEWLINE> <INDENT> if self . __connected and not self . __logged_in : <NEWLINE> <INDENT> logger . warn ( <STRING> , self . cid ( ) ) <NEWLINE> self . transport . abortConnection ( ) <NEWLINE> self . __connected = False <NEWLINE> <DEDENT> <DEDENT>
def try_parse_number ( number_value , cls = float , default = 0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if isinstance ( number_value , int ) or isinstance ( number_value , long ) or isinstance ( number_value , float ) : <NEWLINE> <INDENT> return number_value <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> return int_or_float ( cls ( number_value ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> if default is None : <NEWLINE> <INDENT> return default <NEWLINE> <DEDENT> return cls ( default ) <NEWLINE> <DEDENT> <DEDENT>
class BasketVoucherForm ( forms . Form ) : <NEWLINE> <INDENT> code = forms . CharField ( max_length = 128 , label = _ ( <STRING> ) ) <NEWLINE> def __init__ ( self , * args , ** kwargs ) : <NEWLINE> <INDENT> super ( BasketVoucherForm , self ) . __init__ ( * args , ** kwargs ) <NEWLINE> <DEDENT> def clean_code ( self ) : <NEWLINE> <INDENT> return self . cleaned_data [ <STRING> ] . strip ( ) . upper ( ) <NEWLINE> <DEDENT> <DEDENT>
from config import API_URL , CONNECT_TIME_OUT <NEWLINE> from tornado . httpclient import HTTPRequest , HTTPClient , HTTPError <NEWLINE> import urllib <NEWLINE>
def parse_args ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> parser = argparse . ArgumentParser ( ) <NEWLINE> parser . add_argument ( <STRING> , help = <STRING> ) <NEWLINE> parser . add_argument ( <STRING> , <STRING> , help = <STRING> , <NEWLINE> <INDENT> default = False , action = <STRING> ) <NEWLINE> <DEDENT> if QWebEngineView is not None : <NEWLINE> <INDENT> parser . add_argument ( <STRING> , help = <STRING> , <NEWLINE> <INDENT> default = False , action = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return parser . parse_known_args ( ) [ 0 ] <NEWLINE> <DEDENT>
class ReceiveData ( State ) : <NEWLINE> <INDENT> def run ( self , _input ) : <NEWLINE> <INDENT> if _input == <STRING> : <NEWLINE> <INDENT> self . context . append_received_data ( ) <NEWLINE> self . context . reception_complete ( ) <NEWLINE> self . context . currentState = WaitForStart ( self . context ) <NEWLINE> <DEDENT> elif _input == <STRING> : <NEWLINE> <INDENT> self . context . append_received_data ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . context . receive_data ( _input ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def run_ssh_cmd ( self , cmd ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ssh = paramiko . SSHClient ( ) <NEWLINE> ssh . set_missing_host_key_policy ( paramiko . AutoAddPolicy ( ) ) <NEWLINE> ssh . load_system_host_keys ( ) <NEWLINE> ssh . connect ( hostname = self . labconfig [ <STRING> ] , <NEWLINE> <INDENT> username = self . labconfig [ <STRING> ] , <NEWLINE> password = self . labconfig [ <STRING> ] ) <NEWLINE> <DEDENT> stdin , stdout , stderr = ssh . exec_command ( cmd ) <NEWLINE> res = stdout . readlines ( ) <NEWLINE> print ( <STRING> % res ) <NEWLINE> ssh . close ( ) <NEWLINE> return res <NEWLINE> <DEDENT>
def setUp ( self ) : <NEWLINE> <INDENT> super ( TestAccountApi , self ) . setUp ( ) <NEWLINE> self . request_factory = RequestFactory ( ) <NEWLINE> self . table = <STRING> <NEWLINE> self . user = UserFactory . create ( password = self . password ) <NEWLINE> self . default_request = self . request_factory . get ( <STRING> ) <NEWLINE> self . default_request . user = self . user <NEWLINE> self . different_user = UserFactory . create ( password = self . password ) <NEWLINE> self . staff_user = UserFactory ( is_staff = True , password = self . password ) <NEWLINE> self . reset_tracker ( ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import urlparse , base64 , urllib <NEWLINE> import re , time , datetime <NEWLINE> import json , sys <NEWLINE> from resources . lib . lib import control <NEWLINE> from resources . lib . lib import client <NEWLINE> from resources . lib . lib import client2 <NEWLINE> HOST = <STRING> <NEWLINE> headers = { <STRING> : HOST , <STRING> : <STRING> } <NEWLINE>
class GroupSerializer ( serializers . HyperlinkedModelSerializer ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> class Meta : <NEWLINE> <INDENT> model = Group <NEWLINE> fields = ( <STRING> , <STRING> , <STRING> , ) <NEWLINE> <DEDENT> <DEDENT>
def pagesize ( request ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return pagination . from_request ( request ) [ 0 ] <NEWLINE> <DEDENT>
class LoginForm ( Form ) : <NEWLINE> <INDENT> provider = HiddenField ( <STRING> , validators = [ validators . Required ( ) ] ) <NEWLINE> remember_me = BooleanField ( <STRING> , default = False ) <NEWLINE> <DEDENT>
def __init__ ( self , dimIn , dimOut , actionList , features ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> Actor . __init__ ( self , dimIn , dimOut ) <NEWLINE> self . _actionList = actionList <NEWLINE> self . _features = features <NEWLINE> self . _dimPar = features . size ( ) <NEWLINE> self . _parameters = 0.05 * np . random . randn ( ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> __author__ = <STRING> <NEWLINE> __copyright__ = <STRING> <NEWLINE> __version__ = <STRING> <NEWLINE> import get_challenge <NEWLINE> import wave <NEWLINE> wavs = [ wave . open ( get_challenge . download ( <STRING> , <STRING> , <STRING> % i ) ) for i in range ( 1 , 26 ) ] <NEWLINE>
def get_verb_by_iri ( self , verb_iri ) : <NEWLINE> <INDENT> for verb , iri in self . VERB_IRI_MAPPER . items ( ) : <NEWLINE> <INDENT> if iri == verb_iri : <NEWLINE> <INDENT> return verb <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import os <NEWLINE> import sys <NEWLINE> import tornado . web <NEWLINE> import tornado . httpserver <NEWLINE> import tornado . ioloop <NEWLINE> import tornado . websocket <NEWLINE> import json <NEWLINE> unnamed = [ ] <NEWLINE> connected = { } <NEWLINE>
def fixed_ellipse ( th , a , b ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> xcomp = ( ( abs ( np . cos ( th ) ) ** 2.0 ) / a ** 2.0 ) <NEWLINE> ycomp = ( ( abs ( np . sin ( th ) ) ** 2.0 ) / b ** 2.0 ) <NEWLINE> gell = ( ( xcomp + ycomp ) ) ** ( - 1. / 2.0 ) <NEWLINE> return gell <NEWLINE> <DEDENT>
def _get_compressor ( self , algorithm ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if algorithm . lower ( ) in ( <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> elif algorithm . lower ( ) in ( <STRING> , <STRING> ) : <NEWLINE> <INDENT> import zlib as compressor <NEWLINE> return compressor <NEWLINE> <DEDENT> elif algorithm . lower ( ) in ( <STRING> , <STRING> ) : <NEWLINE> <INDENT> import bz2 as compressor <NEWLINE> return compressor <NEWLINE> <DEDENT> <DEDENT> except ImportError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> err = _ ( <STRING> ) % algorithm <NEWLINE> raise ValueError ( unicode ( err ) ) <NEWLINE> <DEDENT>
from lingpyd import * <NEWLINE> from lingpyd . plugins . burmish import ipa2tokens <NEWLINE> import os <NEWLINE> from lingpyd . settings import rcParams <NEWLINE> rcParams [ <STRING> ] = Model ( <STRING> ) <NEWLINE>
def load_ipython_extension ( ip ) : <NEWLINE> <INDENT> transformer = XalcInputTransformer ( ) <NEWLINE> ip . input_transformer_manager . logical_line_transforms . append ( transformer ) <NEWLINE> formatter = ip . display_formatter . formatters [ <STRING> ] <NEWLINE> formatter . for_type ( int , XalcFormatter ( ) . format_int ) <NEWLINE> <DEDENT>
class graphiteapiTest ( TestCase ) : <NEWLINE> <INDENT> def setUp ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def tearDown ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
class DeNoronha ( DstTzInfo ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> zone = <STRING> <NEWLINE> <DEDENT>
def get_cap_state ( keyboard ) : <NEWLINE> <INDENT> result = False <NEWLINE> if <STRING> in mapFirstElement ( keyboard . active_keys ( verbose = True ) ) or <STRING> in mapFirstElement ( keyboard . active_keys ( verbose = True ) ) : <NEWLINE> <INDENT> result = not result <NEWLINE> <DEDENT> if <STRING> in mapFirstElement ( keyboard . leds ( verbose = True ) ) : <NEWLINE> <INDENT> result = not result <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT>
from NotifierClass import Notifier <NEWLINE> import twitter <NEWLINE> import re <NEWLINE>
def get_auth_header ( signature , timestamp , client , api_key = None ) : <NEWLINE> <INDENT> header = [ <NEWLINE> <INDENT> ( <STRING> , timestamp ) , <NEWLINE> ( <STRING> , signature ) , <NEWLINE> ( <STRING> , client ) , <NEWLINE> <DEDENT> ] <NEWLINE> if api_key : <NEWLINE> <INDENT> header . append ( ( <STRING> , api_key ) ) <NEWLINE> <DEDENT> return <STRING> % <STRING> . join ( <STRING> % ( k , v ) for k , v in header ) <NEWLINE> <DEDENT>
class PlaceBase : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , source = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if source : <NEWLINE> <INDENT> self . place = source . place <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . place = <STRING> <NEWLINE> <DEDENT> <DEDENT> def set_place_handle ( self , place_handle ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . place = place_handle <NEWLINE> <DEDENT> def get_place_handle ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . place <NEWLINE> <DEDENT> <DEDENT>
def invalidate_cms_page_cache ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> version = _get_cache_version ( ) <NEWLINE> _set_cache_version ( version + 1 ) <NEWLINE> <DEDENT>
import os <NEWLINE> import tempfile <NEWLINE> import unittest <NEWLINE> import logging <NEWLINE> from pyidf import ValidationLevel <NEWLINE> import pyidf <NEWLINE> from pyidf . idf import IDF <NEWLINE> from pyidf . detailed_ground_heat_transfer import GroundHeatTransferBasementComBldg <NEWLINE> log = logging . getLogger ( __name__ ) <NEWLINE>
def make_rectangle ( p1 , p2 , color , bottom = 0.0 , top = 1.0 ) : <NEWLINE> <INDENT> verts = [ <NEWLINE> <INDENT> ( p1 , bottom ) , <NEWLINE> ( p1 , top ) , <NEWLINE> ( p2 , top ) , <NEWLINE> ( p2 , bottom ) , <NEWLINE> ( 0.0 , 0.0 ) <NEWLINE> <DEDENT> ] <NEWLINE> codes = [ <NEWLINE> <INDENT> Path . MOVETO , <NEWLINE> Path . LINETO , <NEWLINE> Path . LINETO , <NEWLINE> Path . LINETO , <NEWLINE> Path . CLOSEPOLY <NEWLINE> <DEDENT> ] <NEWLINE> path = Path ( verts , codes ) <NEWLINE> return patches . PathPatch ( path , facecolor = color , lw = 0 ) <NEWLINE> <DEDENT>
class PizzaViewSet ( viewsets . ModelViewSet ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> queryset = Pizza . objects . all ( ) <NEWLINE> serializer_class = PizzaSerializer <NEWLINE> <DEDENT>
def setUp ( self ) : <NEWLINE> <INDENT> super ( FilemapIntegrationTest , self ) . setUp ( ) <NEWLINE> project_tree = FileSystemProjectTree ( os . path . abspath ( self . PATH_PREFIX ) , [ <STRING> , <STRING> ] ) <NEWLINE> scan_set = set ( ) <NEWLINE> for root , dirs , files in project_tree . walk ( <STRING> ) : <NEWLINE> <INDENT> scan_set . update ( { os . path . join ( root , f ) for f in files } ) <NEWLINE> <DEDENT> self . assertEquals ( scan_set , self . TEST_EXCLUDE_FILES ) <NEWLINE> <DEDENT>
import numpy <NEWLINE> import theano <NEWLINE> import theano . tensor as T <NEWLINE> from hidden import HiddenLayer <NEWLINE>
def sum_of_n ( n ) : <NEWLINE> <INDENT> last = 0 <NEWLINE> is_positive = n > 0 <NEWLINE> result = [ 0 ] <NEWLINE> for a in xrange ( 1 , abs ( n ) + 1 ) : <NEWLINE> <INDENT> last += a <NEWLINE> result . append ( last if is_positive else last * - 1 ) <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT>
class FibonacciHandler : <NEWLINE> <INDENT> <STRING> <NEWLINE> def GET ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> desired_sequence = int ( web . input ( ) . desired_sequence ) <NEWLINE> fibonacci = Fibonacci ( desired_sequence ) <NEWLINE> return fibonacci . calculate ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> raise web . HTTPError ( <STRING> , { } ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import contextlib <NEWLINE> import six <NEWLINE> from shuup . apps . provides import get_provide_objects <NEWLINE> from shuup . utils . importing import cached_load , load <NEWLINE> _registry = [ ] <NEWLINE>
def test_request_shortcut ( self ) : <NEWLINE> <INDENT> from pyrake . http import Request , FormRequest <NEWLINE> self . assertIs ( pyrake . Request , Request ) <NEWLINE> self . assertIs ( pyrake . FormRequest , FormRequest ) <NEWLINE> <DEDENT>
class BaseMiddleware ( object ) : <NEWLINE> <INDENT> def __init__ ( self , get_response ) : <NEWLINE> <INDENT> self . get_response = get_response <NEWLINE> <DEDENT> def __call__ ( self , request ) : <NEWLINE> <INDENT> return self . get_response ( request ) <NEWLINE> <DEDENT> <DEDENT>
class SplashHandler ( BaseHandler ) : <NEWLINE> <INDENT> def get ( self ) : <NEWLINE> <INDENT> self . render ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class TestDriver ( notifier . _Driver ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def notify ( self , ctxt , message , priority , retry ) : <NEWLINE> <INDENT> NOTIFICATIONS . append ( ( ctxt , message , priority , retry ) ) <NEWLINE> <DEDENT> <DEDENT>
import redis <NEWLINE> from smithers import conf <NEWLINE> if conf . REDIS_UNIX_SOCKET_PATH : <NEWLINE> <INDENT> client = redis . StrictRedis ( unix_socket_path = conf . REDIS_UNIX_SOCKET_PATH ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> client = redis . StrictRedis ( host = conf . REDIS_HOST , port = conf . REDIS_PORT ) <NEWLINE> <DEDENT>
def test_requires ( self ) : <NEWLINE> <INDENT> y2 = Y2 ( ) <NEWLINE> x = X ( ) <NEWLINE> self . assertEqual ( y2 . requires ( ) , x ) <NEWLINE> self . assertEqual ( y2 . n , 42 ) <NEWLINE> <DEDENT>
__license__ = <STRING> <NEWLINE> import http . cookiejar <NEWLINE> import urllib . request , urllib . error , urllib . parse <NEWLINE> import json <NEWLINE> from . exceptions import ECUnknownException , ECDataItemException <NEWLINE> import elfcloud . exceptions as exceptions <NEWLINE>
try : paraview . simple <NEWLINE> except : from paraview . simple import * <NEWLINE> paraview . simple . _DisableFirstRenderCameraReset ( ) <NEWLINE> ImageExtractComponents ( ) <NEWLINE>
class Options ( usage . Options , strcred . AuthOptionMixin ) : <NEWLINE> <INDENT> supportedInterfaces = ( credentials . IUsernamePassword , ) <NEWLINE> optFlags = [ <NEWLINE> <INDENT> [ <STRING> , <STRING> , <STRING> ] , <NEWLINE> ] <NEWLINE> <DEDENT> optParameters = [ <NEWLINE> <INDENT> [ <STRING> , <STRING> , None , <STRING> ] , <NEWLINE> [ <STRING> , <STRING> , None , <STRING> ] , <NEWLINE> ] <NEWLINE> <DEDENT> def __init__ ( self ) : <NEWLINE> <INDENT> usage . Options . __init__ ( self ) <NEWLINE> <DEDENT> <DEDENT>
class EmbeddedCollections ( document . BaseDocument ) : <NEWLINE> <INDENT> field_list = fields . ListField ( <STRING> ) <NEWLINE> field_dict = fields . DictField ( <STRING> ) <NEWLINE> field_id = fields . ObjectIdField ( field_name = <STRING> , null = True ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from buildbot . steps . shell import ShellCommand <NEWLINE> import os <NEWLINE> from twisted . python import log <NEWLINE> import ast , json <NEWLINE>
import os <NEWLINE> import requests <NEWLINE> import json <NEWLINE> from settings import API_GW_BASE_URL , SERVICE_MOVIE_RESOURCE , SERVICE_POLITICS_RESOURCE , SERVICE_MOVIE_NAME , SERVICE_POLITICS_NAME <NEWLINE> movies_info = { <NEWLINE> <INDENT> <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> <DEDENT> } <NEWLINE> politics_info = { <NEWLINE> <INDENT> <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <STRING> : <STRING> <NEWLINE> <DEDENT> } <NEWLINE> weather_info = { <NEWLINE> <INDENT> <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <STRING> : <STRING> <NEWLINE> <DEDENT> } <NEWLINE> services_info = [ <NEWLINE> <INDENT> movies_info , <NEWLINE> politics_info , <NEWLINE> weather_info <NEWLINE> <DEDENT> ] <NEWLINE> <STRING> <NEWLINE>
def encode_frame ( self , frame ) : <NEWLINE> <INDENT> if frame . extended : <NEWLINE> <INDENT> cmd = <STRING> <NEWLINE> can_id = <STRING> . format ( frame . id ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cmd = <STRING> <NEWLINE> can_id = <STRING> . format ( frame . id ) <NEWLINE> <DEDENT> length = <STRING> . format ( frame . data_length ) <NEWLINE> data = <STRING> <NEWLINE> for b in frame . data : <NEWLINE> <INDENT> data += <STRING> . format ( b ) <NEWLINE> <DEDENT> return cmd + can_id + length + data <NEWLINE> <DEDENT>
import optparse <NEWLINE> import random <NEWLINE> import sys <NEWLINE>
from config import CONFIG_FILE <NEWLINE> from ifcb . util import get_config <NEWLINE> import re <NEWLINE> CONFIG_SCHEMA = [ <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) <NEWLINE> ] <NEWLINE>
def distribution ( x , label ) : <NEWLINE> <INDENT> fig = plt . figure ( ) <NEWLINE> ax1 = fig . add_subplot ( 2 , 1 , 1 ) <NEWLINE> ax1 . set_title ( label + <STRING> ) <NEWLINE> ax1 . hist ( x , bins = 100 , histtype = <STRING> ) <NEWLINE> ax2 = fig . add_subplot ( 2 , 1 , 2 ) <NEWLINE> ax2 . set_title ( label + <STRING> ) <NEWLINE> ax2 . hist ( x , bins = 100 , cumulative = True , normed = True , histtype = <STRING> ) <NEWLINE> plt . savefig ( label ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from nzbget import ScanScript <NEWLINE> import tekuila . teksavvy <NEWLINE> import tekuila . startca <NEWLINE> import xmlrpclib <NEWLINE> from sys import exit <NEWLINE>
def __activate_cb ( self , * args ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . __manager . match ( ) <NEWLINE> <DEDENT> except AttributeError : <NEWLINE> <INDENT> from Manager import Manager <NEWLINE> self . __manager = Manager ( self . __editor ) <NEWLINE> self . __manager . match ( ) <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
def find_existing_toc ( container ) : <NEWLINE> <INDENT> toc = container . opf_xpath ( <STRING> ) <NEWLINE> if toc : <NEWLINE> <INDENT> toc = container . manifest_id_map . get ( toc [ 0 ] , None ) <NEWLINE> <DEDENT> if not toc : <NEWLINE> <INDENT> ncx = guess_type ( <STRING> ) <NEWLINE> toc = container . manifest_type_map . get ( ncx , [ None ] ) [ 0 ] <NEWLINE> <DEDENT> if not toc : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> return toc <NEWLINE> <DEDENT>
def test_load_balancer ( self ) : <NEWLINE> <INDENT> body = { <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : uuidutils . generate_uuid ( ) } <NEWLINE> <DEDENT> lb = wsme_json . fromjson ( self . _type , body ) <NEWLINE> self . assertTrue ( lb . admin_state_up ) <NEWLINE> <DEDENT>
def dodetectplatform ( visualstudio ) : <NEWLINE> <INDENT> global toolset <NEWLINE> if <STRING> in visualstudio : <NEWLINE> <INDENT> toolset = <STRING> <NEWLINE> <DEDENT> elif <STRING> in visualstudio : <NEWLINE> <INDENT> toolset = <STRING> <NEWLINE> <DEDENT> elif <STRING> in visualstudio : <NEWLINE> <INDENT> toolset = <STRING> <NEWLINE> <DEDENT> elif <STRING> in visualstudio : <NEWLINE> <INDENT> toolset = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + visualstudio + <STRING> ) <NEWLINE> toolset = <STRING> <NEWLINE> <DEDENT> <DEDENT>
class TaxAgencyTests ( unittest . TestCase ) : <NEWLINE> <INDENT> def test_unicode ( self ) : <NEWLINE> <INDENT> deposit = TaxAgency ( ) <NEWLINE> deposit . DisplayName = <STRING> <NEWLINE> self . assertEquals ( unicode ( deposit ) , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def isimage ( filename ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> filename = filename . lower ( ) <NEWLINE> return filename [ filename . rfind ( <STRING> ) + 1 : ] in ext2conttype <NEWLINE> <DEDENT>
def test_log_exception ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> mock_logger = Mock ( ) <NEWLINE> @ log_exceptions ( mock_logger ) <NEWLINE> def raise_exception ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> self . assertRaises ( Exception , raise_exception ) <NEWLINE> self . assertTrue ( mock_logger . exception . called ) <NEWLINE> <DEDENT>
class TestUtils ( unittest . TestCase ) : <NEWLINE> <INDENT> def test_reldir ( self ) : <NEWLINE> <INDENT> assert goatd . utils . reldir ( <STRING> , <STRING> ) == <STRING> <NEWLINE> <DEDENT> <DEDENT>
def step ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . reduce ( ) or self . shift ( ) <NEWLINE> <DEDENT>
def check ( mf ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> m = mf . findNode ( <STRING> ) <NEWLINE> if m is None or m . filename is None : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> return dict ( <NEWLINE> <INDENT> packages = [ <STRING> ] , <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def hello ( a ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> x = input ( <STRING> ) <NEWLINE> print ( x ) <NEWLINE> <DEDENT>
def test_username_max_length ( self ) : <NEWLINE> <INDENT> response = self . client . post ( self . list_url , { <NEWLINE> <INDENT> <STRING> : <STRING> * 31 , <NEWLINE> <STRING> : 1 , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <DEDENT> } ) <NEWLINE> assert_equal ( response . status_code , status . HTTP_400_BAD_REQUEST ) <NEWLINE> <DEDENT>
class ValueAction ( eg . ActionWithStringParameter ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __call__ ( self , data ) : <NEWLINE> <INDENT> self . plugin . serial . write ( self . cmd + str ( data ) + chr ( 13 ) ) <NEWLINE> <DEDENT> <DEDENT>
def gga2ddm ( gga ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> gga = str ( gga ) <NEWLINE> dot_index = gga . index ( <STRING> ) <NEWLINE> degrees = gga [ : dot_index - 2 ] <NEWLINE> decimal_minutes = gga [ dot_index - 2 : ] <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> degrees = gga [ : - 2 ] <NEWLINE> decimal_minutes = gga [ - 2 : ] <NEWLINE> <DEDENT> return ( degrees , decimal_minutes ) <NEWLINE> <DEDENT>
def __init__ ( self , appKey , push ) : <NEWLINE> <INDENT> self . batchId = str ( uuid . uuid1 ( ) ) <NEWLINE> self . APPKEY = appKey <NEWLINE> self . push = push <NEWLINE> self . seqId = 0 <NEWLINE> self . innerMsgList = list ( ) <NEWLINE> self . lastPostData = None <NEWLINE> <DEDENT>
import os <NEWLINE> import string <NEWLINE> import tempfile <NEWLINE> import time <NEWLINE> import datetime <NEWLINE> import unittest <NEWLINE> import subprocess <NEWLINE> from exportable . columns import IntColumn , DateTimeColumn , TextColumn , FloatColumn <NEWLINE> from exportable . exporters import SPSSExporter <NEWLINE> from exportable . exporters . spss import write_table <NEWLINE> from exportable . table import ListTable <NEWLINE>
import sys <NEWLINE> import string <NEWLINE> CHAR_MAP = dict ( zip ( <NEWLINE> <INDENT> string . ascii_lowercase , <NEWLINE> string . ascii_lowercase [ 13 : 26 ] + string . ascii_lowercase [ 0 : 13 ] <NEWLINE> ) <NEWLINE> <DEDENT> ) <NEWLINE>
def spider_ended ( spider ) : <NEWLINE> <INDENT> db_conn . close ( ) <NEWLINE> db_cursor . close ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> list_1 = evenele ( list_a ) <NEWLINE> list_b = ranlist ( ) <NEWLINE> list_2 = evenele ( list_b ) <NEWLINE> print ( list_1 ) <NEWLINE> print ( list_2 ) <NEWLINE> <DEDENT>
class Pointer ( object ) : <NEWLINE> <INDENT> def __init__ ( self , d ) : <NEWLINE> <INDENT> self . d = d <NEWLINE> self . indices = [ ] <NEWLINE> <DEDENT> @ property <NEWLINE> def r ( self ) : <NEWLINE> <INDENT> self . indices . append ( 1 ) <NEWLINE> return self <NEWLINE> <DEDENT> @ property <NEWLINE> def l ( self ) : <NEWLINE> <INDENT> self . indices . append ( 0 ) <NEWLINE> return self <NEWLINE> <DEDENT> @ property <NEWLINE> def E ( self ) : <NEWLINE> <INDENT> d = self . d <NEWLINE> for i in self . indices : <NEWLINE> <INDENT> d = d [ i ] <NEWLINE> <DEDENT> return d <NEWLINE> <DEDENT> <DEDENT>
def test_notificationStore ( self ) : <NEWLINE> <INDENT> n = self . ns . get_notifications ( ) <NEWLINE> self . assertIsNone ( n ) <NEWLINE> self . ns . save_notification ( self . u . guid , self . m . handle , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> ) <NEWLINE> <DEDENT> n = self . ns . get_notifications ( ) <NEWLINE> self . assertIsNotNone ( n ) <NEWLINE> self . ns . delete_notfication ( self . u . guid , <STRING> ) <NEWLINE> n = self . ns . get_notifications ( ) <NEWLINE> self . assertIsNone ( n ) <NEWLINE> <DEDENT>
def set_list_write ( filename , entries ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> values = set ( entries ) <NEWLINE> with open ( filename , <STRING> , encoding = <STRING> ) as f : <NEWLINE> <INDENT> f . writelines ( values ) <NEWLINE> os . fchmod ( f . fileno ( ) , 0o644 ) <NEWLINE> <DEDENT> <DEDENT>
from django . conf . urls import patterns , url <NEWLINE> from sites import views <NEWLINE> urlpatterns = patterns ( <STRING> , <NEWLINE> <INDENT> url ( <STRING> , views . SearchView . as_view ( ) ) , <NEWLINE> url ( <STRING> , views . StatView . as_view ( ) ) , <NEWLINE> url ( <STRING> , views . WordCloudView . as_view ( ) ) , <NEWLINE> <DEDENT> ) <NEWLINE>
import logging <NEWLINE> from tasklib . actions import action <NEWLINE> from tasklib import exceptions <NEWLINE> from tasklib import utils <NEWLINE> log = logging . getLogger ( __name__ ) <NEWLINE>
class TForm ( autocomplete . FutureModelForm ) : <NEWLINE> <INDENT> test = autocomplete . QuerySetSequenceModelField ( <NEWLINE> <INDENT> queryset = autocomplete . QuerySetSequence ( <NEWLINE> <INDENT> Group . objects . all ( ) , <NEWLINE> TModel . objects . all ( ) , <NEWLINE> <DEDENT> ) , <NEWLINE> required = False , <NEWLINE> widget = autocomplete . QuerySetSequenceSelect2 ( <STRING> ) , <NEWLINE> <DEDENT> ) <NEWLINE> class Meta : <NEWLINE> <INDENT> model = TModel <NEWLINE> fields = ( <STRING> , ) <NEWLINE> <DEDENT> <DEDENT>
class CountryGrid ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , meta , name = <STRING> ) : <NEWLINE> <INDENT> self . data = Table ( name , meta , <NEWLINE> <INDENT> Column ( <STRING> , String ) , <NEWLINE> Column ( <STRING> , Float ) , <NEWLINE> Column ( <STRING> , Geometry ) <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT> def column_cc ( self ) : <NEWLINE> <INDENT> return self . data . c . country_code <NEWLINE> <DEDENT> def column_geom ( self ) : <NEWLINE> <INDENT> return self . data . c . geom <NEWLINE> <DEDENT> <DEDENT>
def extract_features ( document ) : <NEWLINE> <INDENT> document_words = set ( document ) <NEWLINE> features = { } <NEWLINE> for word in word_features : <NEWLINE> <INDENT> features [ <STRING> % ( word ) ] = ( word in document_words ) <NEWLINE> <DEDENT> return features <NEWLINE> <DEDENT>
def _get_measurement_kwargs ( self ) : <NEWLINE> <INDENT> r = Command . _get_measurement_kwargs ( self ) <NEWLINE> r [ <STRING> ] = self . arguments . packets <NEWLINE> r [ <STRING> ] = self . arguments . packet_interval <NEWLINE> r [ <STRING> ] = self . arguments . size <NEWLINE> return r <NEWLINE> <DEDENT>
def test_lt ( self ) : <NEWLINE> <INDENT> assert Location ( 1 , 1 ) < Location ( 1 , 2 ) <NEWLINE> assert Location ( 1 , 1 ) < Location ( 2 , 1 ) <NEWLINE> assert not ( Location ( 1 , 1 ) < Location ( 1 , 1 ) ) <NEWLINE> assert not ( Location ( 2 , 1 ) < Location ( 1 , 1 ) ) <NEWLINE> assert not ( Location ( 1 , 2 ) < Location ( 1 , 1 ) ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from __future__ import print_function <NEWLINE> from __future__ import division <NEWLINE> import numpy as np <NEWLINE> from collections import Counter <NEWLINE> from sklearn . cross_validation import StratifiedKFold <NEWLINE> from . . base import SamplerMixin <NEWLINE> ESTIMATOR_KIND = ( <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> ) <NEWLINE> <DEDENT>
class DataSample ( models . Model ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> metric = models . ForeignKey ( Metric ) <NEWLINE> utc_timestamp = models . DateTimeField ( default = datetime . datetime . utcnow ) <NEWLINE> value = models . BigIntegerField ( ) <NEWLINE> class Meta : <NEWLINE> <INDENT> ordering = [ <STRING> ] <NEWLINE> get_latest_by = <STRING> <NEWLINE> verbose_name_plural = <STRING> <NEWLINE> <DEDENT> <DEDENT>
def send_data ( json_data ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> db_client = influxdb . InfluxDBClient ( <STRING> , <NEWLINE> <INDENT> 8086 , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> db_client . write_points ( json_data ) <NEWLINE> <DEDENT>
class SVMClassifier ( AbstractZnormClassifier ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , C = 1 , ** kwargs ) : <NEWLINE> <INDENT> super ( SVMClassifier , self ) . __init__ ( <STRING> , C = C , ** kwargs ) <NEWLINE> self . _svm = SVC ( C = C , ** kwargs ) <NEWLINE> <DEDENT> def _train ( self , X , Y ) : <NEWLINE> <INDENT> self . _svm . fit ( X , Y ) <NEWLINE> <DEDENT> def _classify ( self , test_X ) : <NEWLINE> <INDENT> return self . _svm . predict ( test_X ) <NEWLINE> <DEDENT> <DEDENT>
def test ( n , k ) : <NEWLINE> <INDENT> sol = Solution ( ) <NEWLINE> print ( <STRING> % ( n , k ) ) <NEWLINE> print ( <STRING> % ( sol . getPermutation ( n , k ) ) ) <NEWLINE> <DEDENT>
def gediVolatility ( strike , forward , expiry , atmVol , skew , kurt ) : <NEWLINE> <INDENT> moneyness = math . log ( strike / forward ) / math . sqrt ( expiry ) <NEWLINE> s = math . atan ( moneyness ) <NEWLINE> return atmVol + s * skew + kurt * ( s ** 2 ) <NEWLINE> <DEDENT>
from __future__ import absolute_import , unicode_literals <NEWLINE> from base import GAETestCase <NEWLINE> from pswdclient . model import SignSecret <NEWLINE> from pswdclient . manager import FindOrCreateSecrets , RenewSecrets , RevokeSecrets <NEWLINE>
g = ( x ** 2 for x in range ( 6 ) ) <NEWLINE> <STRING> <NEWLINE> print ( g ) <NEWLINE> for x in g : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
def rm ( self , grp ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> grp = self . _get_item ( grp ) <NEWLINE> del self [ grp . name ] <NEWLINE> <DEDENT>
from sys import argv <NEWLINE> script , user_name , location = argv <NEWLINE> prompt = <STRING> <NEWLINE> print ( <STRING> % ( user_name , script ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> % user_name ) <NEWLINE> likes = raw_input ( prompt ) <NEWLINE> print ( <STRING> % user_name ) <NEWLINE> lives = raw_input ( prompt ) <NEWLINE> print ( <STRING> ) <NEWLINE> computer = raw_input ( prompt ) <NEWLINE> if location != lives : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> % ( likes , lives , computer ) ) <NEWLINE>
def summary_scope ( name , family = None , default_name = None , values = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> name = clean_tag ( name ) <NEWLINE> family = clean_tag ( family ) <NEWLINE> scope_base_name = name if family is None else <STRING> . format ( family , name ) <NEWLINE> with ops . name_scope ( scope_base_name , default_name , values = values ) as scope : <NEWLINE> <INDENT> if family is None : <NEWLINE> <INDENT> tag = scope . rstrip ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tag = <STRING> . format ( family , scope . rstrip ( <STRING> ) ) <NEWLINE> <DEDENT> yield ( tag , scope ) <NEWLINE> <DEDENT> <DEDENT>
import logging <NEWLINE> import random <NEWLINE> import threading <NEWLINE> from tornado import gen , ioloop <NEWLINE> from zoonado import Zoonado <NEWLINE> log = logging . getLogger ( ) <NEWLINE> monitor_ioloop = None <NEWLINE>
def deallocvmss ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> global refresh_thread_running <NEWLINE> current_vmss . dealloc ( ) <NEWLINE> statusmsg ( current_vmss . status ) <NEWLINE> refresh_thread_running = True <NEWLINE> <DEDENT>
class SearchMembers ( BaseApi ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , * args , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> super ( SearchMembers , self ) . __init__ ( * args , ** kwargs ) <NEWLINE> self . endpoint = <STRING> <NEWLINE> self . list_id = None <NEWLINE> <DEDENT> def get ( self , ** queryparams ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if <STRING> in queryparams : <NEWLINE> <INDENT> self . list_id = queryparams [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . list_id = None <NEWLINE> <DEDENT> return self . _mc_client . _get ( url = self . _build_path ( ) , ** queryparams ) <NEWLINE> <DEDENT> <DEDENT>
class DataSource : <NEWLINE> <INDENT> def __init__ ( self , params ) : <NEWLINE> <INDENT> self . params = params <NEWLINE> self . data = None <NEWLINE> <DEDENT> def connect ( self ) : <NEWLINE> <INDENT> raise NotImplementedError <NEWLINE> <DEDENT> def __iter__ ( self ) : <NEWLINE> <INDENT> return self . data <NEWLINE> <DEDENT> <DEDENT>
from dateutil . relativedelta import relativedelta <NEWLINE> from time import sleep <NEWLINE> from django . conf import settings <NEWLINE> from django . core . mail import send_mail <NEWLINE> from django . core . management . base import BaseCommand <NEWLINE> from django . template . loader import render_to_string <NEWLINE> from django . utils import timezone <NEWLINE> from ... models import Win , Notification <NEWLINE>
<STRING> <NEWLINE> from django . conf . urls import include , url <NEWLINE> from django . contrib import admin <NEWLINE> from django . conf import settings <NEWLINE> from django . conf . urls . static import static <NEWLINE> urlpatterns = [ <NEWLINE> <INDENT> url ( <STRING> , include ( <STRING> ) ) , <NEWLINE> url ( <STRING> , include ( <STRING> , namespace = <STRING> ) ) , <NEWLINE> url ( <STRING> , include ( <STRING> , namespace = <STRING> ) ) , <NEWLINE> url ( <STRING> , include ( admin . site . urls ) ) , <NEWLINE> <DEDENT> ] <NEWLINE>
def recursiveReverseString ( stringInput , stringTracker ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if len ( stringInput ) > 0 : <NEWLINE> <INDENT> stringTracker += stringInput [ - 1 ] <NEWLINE> return recursiveReverseString ( stringInput [ : - 1 ] , stringTracker ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return stringTracker <NEWLINE> <DEDENT> <DEDENT>
__all__ = [ <STRING> ] <NEWLINE> from types import ClassType , InstanceType <NEWLINE> classtypes = type , ClassType <NEWLINE>
def can_edit_session ( user , session ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if user . is_anonymous ( ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if user . is_superuser or user . is_staff : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> speaker = user . speaker_profile <NEWLINE> if not speaker : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if session . speaker == speaker : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return speaker in session . additional_speakers . all ( ) <NEWLINE> <DEDENT>
def index ( request ) : <NEWLINE> <INDENT> context = { <STRING> : 1 } <NEWLINE> return render ( request , <STRING> , context ) <NEWLINE> <DEDENT>
def get_mount_point ( pathname ) : <NEWLINE> <INDENT> pathname = os . path . normcase ( os . path . realpath ( pathname ) ) <NEWLINE> parent_device = path_device = os . stat ( pathname ) . st_dev <NEWLINE> while parent_device == path_device : <NEWLINE> <INDENT> mount_point = pathname <NEWLINE> pathname = os . path . dirname ( pathname ) <NEWLINE> if pathname == mount_point : break <NEWLINE> parent_device = os . stat ( pathname ) . st_dev <NEWLINE> <DEDENT> return mount_point <NEWLINE> <DEDENT>
def setUp ( self ) : <NEWLINE> <INDENT> self . settings = get_appsettings ( <STRING> , name = <STRING> ) <NEWLINE> self . request = testing . DummyRequest ( ) <NEWLINE> self . request . session [ <STRING> ] = os . path . join ( os . path . dirname ( __file__ ) , <STRING> , <STRING> ) <NEWLINE> self . temp_directory = tempfile . mkdtemp ( ) <NEWLINE> self . it = InterfaceTPS ( self . settings , self . request ) <NEWLINE> self . it . empty ( ) <NEWLINE> self . it . load_test1 ( ) <NEWLINE> <DEDENT>
import os <NEWLINE> import re <NEWLINE> import pickle <NEWLINE>
