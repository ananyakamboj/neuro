def pattern_matching ( pattern , genome , d ) : <NEWLINE> <INDENT> pattern_length = len ( pattern ) <NEWLINE> pos = [ ] <NEWLINE> for i in range ( 0 , len ( genome ) - pattern_length + 1 ) : <NEWLINE> <INDENT> _pattern = genome [ i : i + pattern_length ] <NEWLINE> if ( hamming_distance ( pattern , _pattern ) <= d ) : <NEWLINE> <INDENT> pos . append ( i ) <NEWLINE> <DEDENT> <DEDENT> return pos <NEWLINE> <DEDENT>
def timeonline ( self , unused , player ) : <NEWLINE> <INDENT> playerid = player . GameID <NEWLINE> timeplayed = DataStore . Get ( <STRING> , playerid ) <NEWLINE> totaltime = DataStore . Get ( <STRING> , playerid ) <NEWLINE> timeplayed = datetime . datetime . fromtimestamp ( timeplayed ) . strftime ( <STRING> ) <NEWLINE> if timeplayed and totaltime is not None : <NEWLINE> <INDENT> player . Message ( <STRING> + str ( timeplayed ) ) <NEWLINE> player . Message ( <STRING> + str ( totaltime ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> player . Message ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
__all__ = [ <STRING> ] <NEWLINE> from pyasm . common import Environment <NEWLINE> from pyasm . biz import File <NEWLINE> from pyasm . web import DivWdg , HtmlElement , SpanWdg <NEWLINE> from tactic . ui . common import BaseRefreshWdg <NEWLINE> import os <NEWLINE>
from dolfin import * <NEWLINE> from dolfin_adjoint import * <NEWLINE> if not hasattr ( dolfin , <STRING> ) : <NEWLINE> <INDENT> info_red ( <STRING> ) <NEWLINE> import sys <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> mesh = UnitIntervalMesh ( 2 ) <NEWLINE> V = VectorFunctionSpace ( mesh , <STRING> , 2 ) <NEWLINE> P = FunctionSpace ( mesh , <STRING> , 1 ) <NEWLINE> Z = MixedFunctionSpace ( [ V , P ] ) <NEWLINE>
<STRING> <NEWLINE> from __future__ import absolute_import <NEWLINE> from __future__ import division <NEWLINE> from __future__ import print_function <NEWLINE> import numpy as np <NEWLINE> import tensorflow as tf <NEWLINE> from tensorflow . contrib . distributions . python . ops . shape import _ShapeUtil <NEWLINE>
def fromDB ( rank_method_code ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> id = run_sql ( <STRING> , ( rank_method_code , ) ) <NEWLINE> res = run_sql ( <STRING> , ( id [ 0 ] [ 0 ] , ) ) <NEWLINE> if res : <NEWLINE> <INDENT> return deserialize_via_marshal ( res [ 0 ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return { } <NEWLINE> <DEDENT> <DEDENT>
def forward_content_url_scheme ( apps , schema_editor ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> Post = apps . get_model ( <STRING> , <STRING> ) <NEWLINE> files = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <DEDENT> ] <NEWLINE> for i in range ( len ( files ) ) : <NEWLINE> <INDENT> post = Post . objects . get ( pk = i + 1 ) <NEWLINE> post . content_url = files [ i ] <NEWLINE> post . save ( ) <NEWLINE> <DEDENT> <DEDENT>
def handle_tree_change ( symbol ) : <NEWLINE> <INDENT> if symbol == key . BACKSPACE : <NEWLINE> <INDENT> global root <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> root = generate_tree ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> , Branch . branch_count , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def test_redirect_keeps_language ( self ) : <NEWLINE> <INDENT> Redirect . objects . create ( <NEWLINE> <INDENT> project = self . pip , redirect_type = <STRING> , <NEWLINE> from_url = <STRING> , to_url = <STRING> ) <NEWLINE> <DEDENT> with patch ( <STRING> ) as _serve_docs : <NEWLINE> <INDENT> _serve_docs . side_effect = Http404 ( ) <NEWLINE> r = self . client . get ( <STRING> , <NEWLINE> <INDENT> HTTP_HOST = <STRING> ) <NEWLINE> <DEDENT> self . assertEqual ( r . status_code , 302 ) <NEWLINE> self . assertEqual ( <NEWLINE> <INDENT> r [ <STRING> ] , <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def quality_checks ( str_ , economy ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if str_ == <STRING> : <NEWLINE> <INDENT> assert ( economy . get_status ( ) is False ) <NEWLINE> assert ( economy . attr [ <STRING> ] is False ) <NEWLINE> <DEDENT> elif str_ == <STRING> : <NEWLINE> <INDENT> assert ( economy . get_status ( ) is True ) <NEWLINE> assert ( economy . attr [ <STRING> ] is True ) <NEWLINE> assert ( economy . attr [ <STRING> ] is False ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise OSError <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT>
class Command ( BaseCommand ) : <NEWLINE> <INDENT> help = <STRING> <NEWLINE> def handle ( self , * args , ** options ) : <NEWLINE> <INDENT> start = datetime . datetime ( 2016 , 1 , 1 ) <NEWLINE> end = datetime . datetime ( 2017 , 1 , 1 ) <NEWLINE> n = 0 <NEWLINE> d = start <NEWLINE> while d < end : <NEWLINE> <INDENT> tc = TweetCountCache . get_or_create ( day = d ) <NEWLINE> n += tc . count <NEWLINE> d += datetime . timedelta ( days = 1 ) <NEWLINE> <DEDENT> self . stdout . write ( self . style . SUCCESS ( <STRING> % n ) ) <NEWLINE> <DEDENT> <DEDENT>
class CollectionGetterFromObjectGetter ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , object_getter ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . _object_getter = object_getter <NEWLINE> self . _collection = None <NEWLINE> <DEDENT> def __call__ ( self ) : <NEWLINE> <INDENT> if not self . _collection : <NEWLINE> <INDENT> self . _collection = [ self . _object_getter ( ) ] <NEWLINE> <DEDENT> return self . _collection <NEWLINE> <DEDENT> <DEDENT>
def create_cuboid_xml ( height , width , depth ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> half_height , half_width , half_thick = 0.5 * height , 0.5 * width , 0.5 * depth <NEWLINE> xml_str = <STRING> + <STRING> + <STRING> % ( half_width , - half_height , half_thick ) + <STRING> + <STRING> % ( half_width , half_height , half_thick ) + <STRING> + <STRING> % ( half_width , - half_height , - half_thick ) + <STRING> + <STRING> % ( - half_width , - half_height , half_thick ) + <STRING> <NEWLINE> return xml_str <NEWLINE> <DEDENT>
class ComparisonOperator ( tuple ) : <NEWLINE> <INDENT> def __new__ ( cls , <NEWLINE> <INDENT> name : str , <NEWLINE> operator_fun : types . FunctionType ) : <NEWLINE> return tuple . __new__ ( cls , ( name , operator_fun ) ) <NEWLINE> <DEDENT> @ property <NEWLINE> def name ( self ) -> str : <NEWLINE> <INDENT> return self [ 0 ] <NEWLINE> <DEDENT> @ property <NEWLINE> def operator_fun ( self ) -> types . FunctionType : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self [ 1 ] <NEWLINE> <DEDENT> <DEDENT>
class TestInsertController ( APIController ) : <NEWLINE> <INDENT> def process ( self ) : <NEWLINE> <INDENT> param = self . get_parameters ( [ <STRING> , <STRING> ] ) <NEWLINE> self . db . test_db . insert ( param ) <NEWLINE> <DEDENT> <DEDENT>
from decimal import Decimal <NEWLINE> from weboob . browser . pages import HTMLPage , JsonPage <NEWLINE> from weboob . browser . elements import ItemElement , ListElement , method <NEWLINE> from weboob . browser . filters . json import Dict <NEWLINE> from weboob . browser . filters . standard import Format , CleanText , Regexp , CleanDecimal , Date , Env , BrowserURL <NEWLINE> from weboob . browser . filters . html import XPath <NEWLINE> from weboob . capabilities . housing import Housing , HousingPhoto , City <NEWLINE> from weboob . capabilities . base import NotAvailable <NEWLINE>
class Migration ( migrations . Migration ) : <NEWLINE> <INDENT> dependencies = [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE> operations = [ <NEWLINE> <INDENT> migrations . AlterField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> field = models . CharField ( choices = [ ( <STRING> , <STRING> ) , ( <STRING> , <STRING> ) , ( <STRING> , <STRING> ) ] , max_length = 1 ) , <NEWLINE> <DEDENT> ) , <NEWLINE> migrations . AlterField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> field = models . CharField ( max_length = 255 ) , <NEWLINE> <DEDENT> ) , <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> from itertools import product <NEWLINE> import numpy as np <NEWLINE> DEF_BASES_DNA = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE>
def _prepare_invoice_line_details ( self , line , desc_rule ) : <NEWLINE> <INDENT> details = [ ] <NEWLINE> if desc_rule [ 0 ] == <STRING> : <NEWLINE> <INDENT> details . append ( line . date ) <NEWLINE> <DEDENT> if desc_rule [ 1 ] == <STRING> : <NEWLINE> <INDENT> details . append ( <NEWLINE> <INDENT> <STRING> % ( line . unit_amount , line . product_uom_id . name ) ) <NEWLINE> <DEDENT> <DEDENT> if desc_rule [ 2 ] == <STRING> : <NEWLINE> <INDENT> details . append ( line . name ) <NEWLINE> <DEDENT> return details <NEWLINE> <DEDENT>
def set_model ( self , likelihood_model_instance ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if likelihood_model_instance is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . _source_name is not None : <NEWLINE> <INDENT> assert self . _source_name in likelihood_model_instance . sources , <STRING> <STRING> % ( self . _source_name ) <NEWLINE> <DEDENT> self . _likelihood_model = likelihood_model_instance <NEWLINE> <DEDENT>
from distutils . core import setup <NEWLINE> import os <NEWLINE> import codecs <NEWLINE> try : <NEWLINE> <INDENT> codecs . lookup ( <STRING> ) <NEWLINE> <DEDENT> except LookupError : <NEWLINE> <INDENT> ascii = codecs . lookup ( <STRING> ) <NEWLINE> func = lambda name , enc = ascii : { True : enc } . get ( name == <STRING> ) <NEWLINE> codecs . register ( func ) <NEWLINE> <DEDENT>
def update_sub_domain ( self , domain , tld , domain_id , ip ) : <NEWLINE> <INDENT> if self . delete_sub_domain ( domain_id ) : <NEWLINE> <INDENT> self . create_sub_domain ( domain , tld , ip ) <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT>
def _load ( self , name , k , P ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if name not in self . _loadable_power_terms : <NEWLINE> <INDENT> raise ValueError ( <STRING> <NEWLINE> <INDENT> <STRING> % ( name , self . _loadable_power_terms ) ) <NEWLINE> <DEDENT> <DEDENT> self . _loaded_data [ name ] = spline ( k , P ) <NEWLINE> setattr ( self , name + <STRING> , True ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> n = <STRING> <NEWLINE> if len ( s ) > 1 : <NEWLINE> <INDENT> for i in s : <NEWLINE> <INDENT> if ( i == <STRING> or i == <STRING> or i == <STRING> or i == <STRING> or i == <STRING> ) : <NEWLINE> <INDENT> n += i <NEWLINE> <DEDENT> <DEDENT> n2 = n [ : : - 1 ] <NEWLINE> if ( n2 == n ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def test_invalid_form_data ( self ) : <NEWLINE> <INDENT> self . register ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> response = self . login ( <STRING> , <STRING> ) <NEWLINE> self . assertIn ( <STRING> , response . data ) <NEWLINE> <DEDENT>
def do_upgrade ( env , ver , cursor ) : <NEWLINE> <INDENT> cursor . execute ( sql ) <NEWLINE> env . config . set ( <STRING> , <STRING> , <STRING> ) <NEWLINE> env . config . save ( ) <NEWLINE> <DEDENT>
def test_key_is_created_for_project ( self ) : <NEWLINE> <INDENT> user = self . create_user ( <STRING> ) <NEWLINE> team = self . create_team ( name = <STRING> ) <NEWLINE> project = self . create_project ( name = <STRING> , team = team ) <NEWLINE> assert project . key_set . exists ( ) is True <NEWLINE> <DEDENT>
def register ( ) : <NEWLINE> <INDENT> logging . debug ( <STRING> , time . strftime ( <STRING> ) ) <NEWLINE> return <STRING> <NEWLINE> <DEDENT>
def cron_remove_empty_session ( self ) : <NEWLINE> <INDENT> hours = 1 <NEWLINE> self . env . cr . execute ( <STRING> , ( <STRING> % hours , ) ) <NEWLINE> empty_channel_ids = [ item [ <STRING> ] for item in self . env . cr . dictfetchall ( ) ] <NEWLINE> self . browse ( empty_channel_ids ) . unlink ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import os <NEWLINE> sys . path . insert ( 0 , os . path . join ( os . path . dirname ( __file__ ) , <STRING> ) ) <NEWLINE> testinfo = <STRING> <NEWLINE> tags = <STRING> <NEWLINE> import cocos <NEWLINE> from cocos . director import director <NEWLINE> from cocos . actions import RotateBy <NEWLINE> from cocos . sprite import Sprite <NEWLINE> from cocos . layer import * <NEWLINE> import pyglet <NEWLINE>
def next_layer ( self ) : <NEWLINE> <INDENT> if self . __current_frame == self . __top_frame : <NEWLINE> <INDENT> self . __ended = True <NEWLINE> <DEDENT> frame = self . layers [ self . __current_frame ] <NEWLINE> if self . __current_frame < self . __top_frame : <NEWLINE> <INDENT> self . __current_frame += 1 <NEWLINE> <DEDENT> return frame <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from PyQt4 import QtCore <NEWLINE> from PyQt4 import QtGui <NEWLINE> from authenticate_ui import Ui_Dialog <NEWLINE> import csv <NEWLINE> import numpy as np <NEWLINE>
import paramiko <NEWLINE> import MySQLdb <NEWLINE> import os <NEWLINE> import sys <NEWLINE> import time <NEWLINE> from optparse import OptionParser <NEWLINE> user_value = <STRING> ; pass_value = <STRING> ; port_value = 3306 ; <NEWLINE>
def __init__ ( self , consumer_key , consumer_secret , request_token_url = REQUEST_TOKEN_URL , access_token_url = ACCESS_TOKEN_URL , authorization_url = AUTHORIZATION_URL ) : <NEWLINE> <INDENT> self . consumer_secret = consumer_secret <NEWLINE> self . consumer_key = consumer_key <NEWLINE> self . consumer = oauth . OAuthConsumer ( consumer_key , consumer_secret ) <NEWLINE> self . signature_method = oauth . OAuthSignatureMethod_HMAC_SHA1 ( ) <NEWLINE> self . request_token_url = request_token_url <NEWLINE> self . access_token_url = access_token_url <NEWLINE> self . authorization_url = authorization_url <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import os <NEWLINE> from oslo_log import log as logging <NEWLINE> from oslo_utils import excutils <NEWLINE> from vif_plug_midonet . i18n import _LE <NEWLINE> from vif_plug_midonet import processutils <NEWLINE> LOG = logging . getLogger ( __name__ ) <NEWLINE>
def test_parse_volumes_invalid_params ( self ) : <NEWLINE> <INDENT> self . assertEquals ( <NEWLINE> <INDENT> ( { } , [ ] ) , utils . parse_volumes ( None ) ) <NEWLINE> <DEDENT> self . assertEquals ( <NEWLINE> <INDENT> ( { } , [ ] ) , utils . parse_volumes ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT>
def __set__ ( self , instance , value ) : <NEWLINE> <INDENT> if value in self . choices : <NEWLINE> <INDENT> return super ( ChoiceProperty , self ) . __set__ ( instance , value ) <NEWLINE> <DEDENT> possible_choices = <STRING> . join ( self . choices . keys ( ) ) <NEWLINE> raise ValueError ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> . format ( value , self . name , possible_choices ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
class Client ( object ) : <NEWLINE> <INDENT> def __init__ ( self , api_key ) : <NEWLINE> <INDENT> self . api_key = api_key <NEWLINE> <DEDENT> def get_historical_rates ( self , date ) : <NEWLINE> <INDENT> response = requests . get ( HISTORICAL_ENDPOINT % date , params = { <STRING> : self . api_key } ) <NEWLINE> return response . json ( ) [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT>
def datespan ( self ) : <NEWLINE> <INDENT> datespan = DateSpan . since ( self . default_days , timezone = self . timezone , inclusive = self . inclusive ) <NEWLINE> if self . request . datespan . is_valid ( ) and self . slug == <STRING> : <NEWLINE> <INDENT> datespan . startdate = self . request . datespan . startdate <NEWLINE> datespan . enddate = self . request . datespan . enddate <NEWLINE> <DEDENT> return datespan <NEWLINE> <DEDENT>
class Transform ( RegisterLookupMixin , Func ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> bilateral = False <NEWLINE> arity = 1 <NEWLINE> @ property <NEWLINE> def lhs ( self ) : <NEWLINE> <INDENT> return self . get_source_expressions ( ) [ 0 ] <NEWLINE> <DEDENT> def get_bilateral_transforms ( self ) : <NEWLINE> <INDENT> if hasattr ( self . lhs , <STRING> ) : <NEWLINE> <INDENT> bilateral_transforms = self . lhs . get_bilateral_transforms ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bilateral_transforms = [ ] <NEWLINE> <DEDENT> if self . bilateral : <NEWLINE> <INDENT> bilateral_transforms . append ( self . __class__ ) <NEWLINE> <DEDENT> return bilateral_transforms <NEWLINE> <DEDENT> <DEDENT>
def __sub__ ( self , other ) : <NEWLINE> <INDENT> return RationalFunction ( self . numerator * other . denominator - <NEWLINE> <INDENT> self . denominator * other . numerator , <NEWLINE> self . denominator * other . denominator ) <NEWLINE> <DEDENT> <DEDENT>
def testCreateEdfContainer ( self , fname ) : <NEWLINE> <INDENT> print ( <STRING> . format ( fname ) ) <NEWLINE> edf_container = self . createEdfContainer ( fname ) <NEWLINE> print ( <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> not_edf_c = self . createEdfContainer ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> except FileNotFoundError : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> return edf_container <NEWLINE> <DEDENT>
import os <NEWLINE> import os . path <NEWLINE> import logging <NEWLINE> from lascaux import config <NEWLINE> if not os . path . isdir ( <STRING> ) : <NEWLINE> <INDENT> os . mkdir ( <STRING> ) <NEWLINE> <DEDENT> logging . basicConfig ( filename = <STRING> , level = logging . DEBUG ) <NEWLINE> formatter = logging . Formatter ( <STRING> ) <NEWLINE> stream_handler = logging . StreamHandler ( ) <NEWLINE> stream_handler . setFormatter ( formatter ) <NEWLINE>
<STRING> <NEWLINE> from config_models . admin import ConfigurationModelAdmin <NEWLINE> from config_models . models import ConfigurationModel <NEWLINE> from django . contrib import admin <NEWLINE> from django . core . cache import cache <NEWLINE> from django . db import models <NEWLINE> from openedx . core . djangoapps . xmodule_django . models import CourseKeyField <NEWLINE>
def get_newslink_create_url ( self ) : <NEWLINE> <INDENT> return reverse ( <STRING> , kwargs = { <NEWLINE> <INDENT> <STRING> : self . slug } ) <NEWLINE> <DEDENT> <DEDENT>
import pprint <NEWLINE> import click <NEWLINE> import os <NEWLINE> import subprocess <NEWLINE> import glob <NEWLINE> import time <NEWLINE> import sys <NEWLINE> import datetime <NEWLINE> import re <NEWLINE> import csv <NEWLINE>
class RandomSequenceInside ( Block ) : <NEWLINE> <INDENT> def apply ( self , x ) : <NEWLINE> <INDENT> out = T . scan ( self . rec , sequences = x , outputs_info = [ None ] ) <NEWLINE> return out <NEWLINE> <DEDENT> def rec ( self , x_t ) : <NEWLINE> <INDENT> return RVal ( ) . normal ( x_t . shape ) <NEWLINE> <DEDENT> <DEDENT>
from django . conf import settings <NEWLINE> from django . http import Http404 <NEWLINE> from amanda . redirects . views import DynamicRedirectView <NEWLINE>
def on_completed ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> os = None <NEWLINE> with self . lock : <NEWLINE> <INDENT> self . check_disposed ( ) <NEWLINE> if not self . is_stopped : <NEWLINE> <INDENT> os = self . observers [ : ] <NEWLINE> self . observers = [ ] <NEWLINE> self . is_stopped = True <NEWLINE> <DEDENT> <DEDENT> if os : <NEWLINE> <INDENT> for observer in os : <NEWLINE> <INDENT> observer . on_completed ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class PostgreSQLDatabases ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> DATABASES = values . DictValue ( { <NEWLINE> <INDENT> <STRING> : { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : None , <NEWLINE> <DEDENT> } , <NEWLINE> <DEDENT> } ) <NEWLINE> <DEDENT>
from fabric . api import abort , run , settings , sudo , local <NEWLINE> from fabric . colors import blue , red , green , magenta , cyan <NEWLINE> from fabric . context_managers import hide <NEWLINE> from fabric . contrib import console <NEWLINE> import fnmatch <NEWLINE> import os <NEWLINE> import os . path <NEWLINE> from bismarck_cli . utils import term <NEWLINE> from bismarck_cli . utils . misc import is_sequence <NEWLINE> OK = 0 <NEWLINE> INFO = 10 <NEWLINE> WARN = 50 <NEWLINE> ERROR = 100 <NEWLINE>
def get_nodes ( self , flag ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> match = [ ] <NEWLINE> for n in self . _nodes : <NEWLINE> <INDENT> if n . has_flag ( flag ) : <NEWLINE> <INDENT> match . append ( n ) <NEWLINE> <DEDENT> <DEDENT> return match <NEWLINE> <DEDENT>
def delete_room ( self , room_token ) : <NEWLINE> <INDENT> resp = self . session . delete ( <NEWLINE> <INDENT> self . base_url + <STRING> % room_token , <NEWLINE> headers = { <STRING> : <STRING> } , <NEWLINE> auth = self . hawk_room_owner <NEWLINE> <DEDENT> ) <NEWLINE> self . assertEquals ( 204 , resp . status_code , <NEWLINE> <INDENT> <STRING> % ( <NEWLINE> <INDENT> resp . status_code , resp . content ) ) <NEWLINE> <DEDENT> <DEDENT> self . incr_counter ( <STRING> ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import util <NEWLINE> from util import out , nl <NEWLINE>
import numpy as np <NEWLINE> from sklearn . ensemble import GradientBoostingClassifier <NEWLINE> from random import sample , seed <NEWLINE> from collections import OrderedDict <NEWLINE>
from matplotlib . contour import ContourSet <NEWLINE> from matplotlib . tri . triangulation import Triangulation <NEWLINE> import matplotlib . _tri as _tri <NEWLINE> import numpy as np <NEWLINE>
version_info = ( 0 , 3 , 2 ) <NEWLINE> __version__ = <STRING> . join ( str ( s ) for s in version_info ) <NEWLINE> __author__ = <STRING> <NEWLINE>
def score ( self , p , x , y , sample_weight = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return r2_score ( y_pred = self . predict ( p , x ) , <NEWLINE> <INDENT> y_true = y , <NEWLINE> sample_weight = sample_weight ) <NEWLINE> <DEDENT> <DEDENT>
def add_mdf ( * args , ** argv ) : <NEWLINE> <INDENT> ro = mkRO ( astrotype = <STRING> , copy_input = True , <NEWLINE> <INDENT> args = args , argv = argv ) <NEWLINE> <DEDENT> ro . runstep ( <STRING> , ro . context ) <NEWLINE> outputs = ro . context . get_outputs ( style = <STRING> ) <NEWLINE> if len ( outputs ) == 0 : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> elif len ( outputs ) == 1 : <NEWLINE> <INDENT> return outputs [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return outputs <NEWLINE> <DEDENT> <DEDENT>
def test_wrong_schema ( self ) : <NEWLINE> <INDENT> httpretty . HTTPretty . register_uri ( httpretty . HTTPretty . GET , <STRING> , <NEWLINE> <INDENT> status = 200 , body = json . dumps ( { } ) , <NEWLINE> content_type = <STRING> ) <NEWLINE> <DEDENT> mailroute . configure ( * self . ACCESS_USER , server = <STRING> ) <NEWLINE> for QClass in self . entity_classes : <NEWLINE> <INDENT> QClass . Entity . schema . when . called_with ( ) . should . throw ( mailroute . CanNotInitSchema ) <NEWLINE> <DEDENT> <DEDENT>
from __future__ import ( division , print_function ) <NEWLINE> import random <NEWLINE> import numpy <NEWLINE> import dendropy <NEWLINE> import re <NEWLINE> from Bio import Phylo <NEWLINE> from cStringIO import StringIO <NEWLINE>
def factor_result ( base_result : dict , result_type : ResultType ) -> dict : <NEWLINE> <INDENT> if result_type == ResultType . Field : <NEWLINE> <INDENT> base_result [ <STRING> ] = result_type <NEWLINE> <DEDENT> elif result_type == ResultType . ListField : <NEWLINE> <INDENT> base_result [ <STRING> ] = result_type <NEWLINE> <DEDENT> elif result_type == ResultType . ListFieldItem : <NEWLINE> <INDENT> base_result [ <STRING> ] = result_type <NEWLINE> <DEDENT> return base_result <NEWLINE> <DEDENT>
class LoginForm ( FlaskForm ) : <NEWLINE> <INDENT> username = StringField ( <STRING> , validators = [ DataRequired ( ) ] ) <NEWLINE> password = StringField ( <STRING> , validators = [ DataRequired ( ) ] ) <NEWLINE> redirectonlogin = StringField ( <STRING> , default = <STRING> , validators = [ ] ) <NEWLINE> <DEDENT>
def get_back_file_rarity ( back_file_name ) : <NEWLINE> <INDENT> for r in BACK_FILE_DICT . keys ( ) : <NEWLINE> <INDENT> if ( is_a_back_file_with_rarity ( r , back_file_name ) ) : <NEWLINE> <INDENT> return r <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def task6 ( a , b ) : <NEWLINE> <INDENT> if isinstance ( a , str ) or isinstance ( b , str ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from . demo import * <NEWLINE> SITE = Site ( <NEWLINE> <INDENT> globals ( ) , <NEWLINE> use_java = True , <NEWLINE> ignore_model_errors = True , <NEWLINE> remote_user_header = <STRING> ) <NEWLINE> <DEDENT> DEBUG = True <NEWLINE> SITE . webdav_url = <STRING> <NEWLINE>
def detail ( self , req , resp_obj ) : <NEWLINE> <INDENT> context = req . environ [ <STRING> ] <NEWLINE> if instance_authorize ( context ) : <NEWLINE> <INDENT> resp_obj . attach ( xml = PciServersTemplate ( ) ) <NEWLINE> servers = list ( resp_obj . obj [ <STRING> ] ) <NEWLINE> for server in servers : <NEWLINE> <INDENT> instance = req . get_db_instance ( server [ <STRING> ] ) <NEWLINE> self . _extend_server ( server , instance ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import pyblish . main <NEWLINE> pyblish . main . publish ( ) <NEWLINE>
<STRING> <NEWLINE> import os <NEWLINE> import json <NEWLINE> import h5py <NEWLINE> import numpy as np <NEWLINE> from origin . server import Destination <NEWLINE> from origin import data_types , TIMESTAMP <NEWLINE>
def test_logger_connection_id ( self ) : <NEWLINE> <INDENT> log = logging . getLogger ( __name__ ) <NEWLINE> log . connection_id = <STRING> <NEWLINE> self . assertEqual ( log . connection_id , <STRING> ) <NEWLINE> del log . connection_id <NEWLINE> self . assertEqual ( log . connection_id , <STRING> ) <NEWLINE> <DEDENT>
def edge_splits ( t , taxa ) : <NEWLINE> <INDENT> splits = t . splits ( ) <NEWLINE> splits = filter ( lambda x : len ( x [ 0 ] ) != 1 and len ( x [ 1 ] ) != 1 , splits ) <NEWLINE> ret = [ ] <NEWLINE> for split in splits : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> for i in range ( len ( taxa ) ) : <NEWLINE> <INDENT> if taxa [ i ] in split [ 0 ] : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> <DEDENT> ret . append ( s ) <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT>
def __init__ ( self , ** kwargs ) : <NEWLINE> <INDENT> self . availableOptions . update ( { <NEWLINE> <INDENT> <STRING> : True , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : 1 , <NEWLINE> <DEDENT> } ) <NEWLINE> super ( DuosManagingBot , self ) . __init__ ( ** kwargs ) <NEWLINE> self . store = QueryStore ( ) <NEWLINE> <DEDENT>
def false_value ( self , value ) : <NEWLINE> <INDENT> if not value : <NEWLINE> <INDENT> value = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> value = str ( value ) <NEWLINE> <DEDENT> original_value = self . _name <NEWLINE> if value != original_value : <NEWLINE> <INDENT> self . _false_value = value <NEWLINE> self . _false_value_changed ( self , original_value , value ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import os <NEWLINE> import ruamel . yaml as yaml <NEWLINE> from ddf_utils . chef . api import Chef <NEWLINE> from ddf_utils . chef . ingredient import Ingredient <NEWLINE> from ddf_utils . chef . exceptions import IngredientError <NEWLINE> wd = os . path . dirname ( __file__ ) <NEWLINE>
def get_latest_plans ( self , date ) : <NEWLINE> <INDENT> iso_dt = parse_date ( date ) <NEWLINE> dt = iso_dt . strftime ( <STRING> ) <NEWLINE> tm = iso_dt . strftime ( <STRING> ) <NEWLINE> response = self . _get_resource_item ( <NEWLINE> <INDENT> <STRING> . format ( <NEWLINE> <INDENT> self . prefix_path , <NEWLINE> dt , <NEWLINE> tm <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> ) <NEWLINE> if response . status_int == 200 : <NEWLINE> <INDENT> plan_list = munchify ( loads ( response . body_string ( ) ) ) <NEWLINE> self . _update_params ( plan_list . next_page ) <NEWLINE> return plan_list . data <NEWLINE> <DEDENT> raise InvalidResponse <NEWLINE> <DEDENT>
def removeQuotes ( line ) : <NEWLINE> <INDENT> for i in range ( len ( line ) ) : <NEWLINE> <INDENT> if line [ i ] [ 0 ] == <STRING> : line [ i ] = line [ i ] [ 1 : ] <NEWLINE> if line [ i ] [ - 1 ] == <STRING> : line [ i ] = line [ i ] [ : - 1 ] <NEWLINE> <DEDENT> <DEDENT>
def init ( self , ** parameters ) : <NEWLINE> <INDENT> self . instance . run_commands ( <NEWLINE> <INDENT> <STRING> + self . dir , <NEWLINE> <STRING> , <NEWLINE> <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> if parameters : <NEWLINE> <INDENT> self . set_parameters ( ** parameters ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , sender = None , * a , ** k ) : <NEWLINE> <INDENT> super ( ModInputSignal , self ) . __init__ ( sender = sender , * a , ** k ) <NEWLINE> self . _input_control = sender <NEWLINE> <DEDENT>
def get_max_product ( n , k , num ) : <NEWLINE> <INDENT> str_n = list ( str ( num ) ) <NEWLINE> result = - 1 ; <NEWLINE> for i in xrange ( n - k ) : <NEWLINE> <INDENT> temp = 1 <NEWLINE> for j in map ( int , str_n [ i : i + k ] ) : <NEWLINE> <INDENT> temp = temp * j <NEWLINE> <DEDENT> if result < temp : <NEWLINE> <INDENT> result = temp <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <DEDENT>
def splitPathFN ( PathFN ) : <NEWLINE> <INDENT> Dir , FN = os . path . split ( PathFN ) <NEWLINE> BN = os . path . splitext ( FN ) [ 0 ] <NEWLINE> DIRBN = Dir + <STRING> + BN <NEWLINE> return ( FN , BN , Dir , DIRBN , PathFN ) <NEWLINE> <DEDENT>
def compute_bins ( interval ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> halfsz = interval / 2. <NEWLINE> multi = int ( 80. / interval ) <NEWLINE> v = halfsz + interval * multi <NEWLINE> return np . arange ( 0 - v , v + 0.1 , interval ) <NEWLINE> <DEDENT>
def test_get_header ( self ) : <NEWLINE> <INDENT> robj = wsgi . ResponseObject ( { } ) <NEWLINE> robj [ <STRING> ] = <STRING> <NEWLINE> self . assertEqual ( robj [ <STRING> ] , <STRING> ) <NEWLINE> <DEDENT>
def get_uid ( oauth_token ) : <NEWLINE> <INDENT> r = requests . get ( <STRING> % ( eb_api_endpoint , oauth_token ) ) <NEWLINE> return r . json ( ) [ <STRING> ] <NEWLINE> <DEDENT>
def get_value ( self ) : <NEWLINE> <INDENT> has_ace = False <NEWLINE> result = 0 <NEWLINE> for card in self . __cards : <NEWLINE> <INDENT> value = VALUES [ card . get_rank ( ) ] <NEWLINE> result += value <NEWLINE> if value == 1 : <NEWLINE> <INDENT> has_ace = True <NEWLINE> <DEDENT> <DEDENT> if has_ace and result + 10 <= 21 : <NEWLINE> <INDENT> result += 10 <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT>
def pdfparser ( file_name ) : <NEWLINE> <INDENT> fp = file ( file_name , <STRING> ) <NEWLINE> rsrcmgr = PDFResourceManager ( ) <NEWLINE> retstr = StringIO ( ) <NEWLINE> codec = <STRING> <NEWLINE> laparams = LAParams ( ) <NEWLINE> device = TextConverter ( rsrcmgr , retstr , codec = codec , laparams = laparams ) <NEWLINE> interpreter = PDFPageInterpreter ( rsrcmgr , device ) <NEWLINE> for page in PDFPage . get_pages ( fp ) : <NEWLINE> <INDENT> interpreter . process_page ( page ) <NEWLINE> data = retstr . getvalue ( ) <NEWLINE> <DEDENT> return data <NEWLINE> <DEDENT>
from ypip . sources . requirements_txt import RequirementsTxt <NEWLINE> from ypip . sources . git_github import GitOnGitHub <NEWLINE> from ypip . sources . pip_fallback import PipFallback <NEWLINE>
import eventlet <NEWLINE> import falcon <NEWLINE> from eventlet import wsgi <NEWLINE> from include . common . db . db_connection_handler import DbConnectionHandler <NEWLINE> from include . web_server . css_manager import CssManager <NEWLINE> from include . web_server . endpoints . generic_endpoint import GenericEndpoint <NEWLINE> from include . web_server . endpoints . home_endpoint import HomeEndpoint <NEWLINE> from include . web_server . endpoints . logout_endpoint import LogoutEndpoint <NEWLINE> from include . web_server . endpoints . user_details_endpoint import UserDetailsEndpoint <NEWLINE> from include . web_server . endpoints . users_list_endpoint import UsersListEndpoint <NEWLINE> from include . web_server . web_links_factory import WebLinksFactory <NEWLINE> DbConnectionHandler . initialize_db_connection_handler ( ) <NEWLINE>
import unittest <NEWLINE> import tempfile <NEWLINE> from mathics . core . parser . feed import SingleLineFeeder , MultiLineFeeder , FileLineFeeder <NEWLINE>
class OperationDisplay ( Model ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> _validation = { <NEWLINE> <INDENT> <STRING> : { <STRING> : True } , <NEWLINE> <STRING> : { <STRING> : True } , <NEWLINE> <STRING> : { <STRING> : True } , <NEWLINE> <DEDENT> } <NEWLINE> _attribute_map = { <NEWLINE> <INDENT> <STRING> : { <STRING> : <STRING> , <STRING> : <STRING> } , <NEWLINE> <STRING> : { <STRING> : <STRING> , <STRING> : <STRING> } , <NEWLINE> <STRING> : { <STRING> : <STRING> , <STRING> : <STRING> } , <NEWLINE> <DEDENT> } <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> self . provider = None <NEWLINE> self . resource = None <NEWLINE> self . operation = None <NEWLINE> <DEDENT> <DEDENT>
class RelationInline ( admin . StackedInline ) : <NEWLINE> <INDENT> extra = 1 <NEWLINE> fk_name = <STRING> <NEWLINE> model = models . Relation <NEWLINE> <DEDENT>
def addRef ( self , blockName ) : <NEWLINE> <INDENT> assert not blockName in self . _refTo <NEWLINE> self . _refTo . add ( blockName ) <NEWLINE> <DEDENT>
def testNewStyleIndividualAudioRoute ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> response = self . server . get ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> self . assertEqual ( 200 , response . status_code ) <NEWLINE> self . assertEqual ( <STRING> , response . headers . get ( <STRING> ) ) <NEWLINE> <DEDENT>
def enclose_in_double_quotes ( query_txt ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> query_words = query_txt . split ( <STRING> ) <NEWLINE> return <STRING> + <STRING> . join ( [ word for word in query_words if word ] ) + <STRING> <NEWLINE> <DEDENT>
class WagtailRoutablePageTestsAppConfig ( AppConfig ) : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> label = <STRING> <NEWLINE> verbose_name = <STRING> <NEWLINE> <DEDENT>
from cStringIO import StringIO <NEWLINE> import mock <NEWLINE> from nose . tools import eq_ , ok_ <NEWLINE> from funfactory . urlresolvers import reverse <NEWLINE> from airmozilla . main . models import Event <NEWLINE> from . base import ManageTestCase <NEWLINE> from airmozilla . manage . tests . test_vidly import SAMPLE_MEDIALIST_XML <NEWLINE>
<STRING> <NEWLINE> from django . test import TestCase <NEWLINE> from api . apikey import APIKey <NEWLINE> from api . redis import save_key , exists , get_apikeys , flush_all <NEWLINE> from config . settings . base import get_config <NEWLINE> from api . apikeyhandler import ApiKeyHandler <NEWLINE>
def handle_process ( conn , data ) : <NEWLINE> <INDENT> command = struct . unpack ( <STRING> , data [ : 4 ] ) [ 0 ] <NEWLINE> data = data [ 4 : ] <NEWLINE> content = public . pack_dict . loads_json_unicode ( data ) <NEWLINE> print ( __name__ , <STRING> , command , content ) <NEWLINE> process = HANDLE_PROCESS . get ( command ) <NEWLINE> if not process : <NEWLINE> <INDENT> print ( __name__ , <STRING> , command , content ) <NEWLINE> return <NEWLINE> <DEDENT> process ( conn , content ) <NEWLINE> <DEDENT>
def css_files ( self ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> for f in self . _get_resources ( <STRING> ) : <NEWLINE> <INDENT> if isinstance ( f , ( unicode_type , bytes_type ) ) : <NEWLINE> <INDENT> result . append ( f ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . extend ( f ) <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <DEDENT>
def do_ngram ( ori , mode , num ) : <NEWLINE> <INDENT> if mode == <STRING> : <NEWLINE> <INDENT> str = [ ] <NEWLINE> str = ori . split ( ) <NEWLINE> <DEDENT> elif mode == <STRING> : <NEWLINE> <INDENT> str = <STRING> <NEWLINE> str = ori . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> i = 0 <NEWLINE> n = num <NEWLINE> ngram = [ ] <NEWLINE> while i < len ( str ) - 1 : <NEWLINE> <INDENT> ngram . append ( str [ i : n ] ) <NEWLINE> i += 1 <NEWLINE> n += 1 <NEWLINE> <DEDENT> return ngram <NEWLINE> <DEDENT>
def handleClientRequest ( request , successorSocket ) : <NEWLINE> <INDENT> clientId = request [ <STRING> ] <NEWLINE> clientAddress = request [ <STRING> ] <NEWLINE> sc = context . socket ( zmq . PUSH ) <NEWLINE> sc . connect ( clientAddress ) <NEWLINE> clients [ clientId ] = sc <NEWLINE> key = request [ <STRING> ] <NEWLINE> if in_range ( key ) : <NEWLINE> <INDENT> print ( <STRING> . format ( key ) ) <NEWLINE> localOP ( request ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( key ) ) <NEWLINE> successorSocket . send_json ( request ) <NEWLINE> <DEDENT> <DEDENT>
def sum_values_generator ( kvi ) : <NEWLINE> <INDENT> for k , vs in kvi : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> yield k , sum ( vs ) <NEWLINE> <DEDENT> except TypeError : <NEWLINE> <INDENT> yield k , vs <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def standard_cl_params ( items ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> out = [ ] <NEWLINE> def _skip_duplicates ( data ) : <NEWLINE> <INDENT> return ( dd . get_coverage_interval ( data ) == <STRING> or <NEWLINE> <INDENT> ( dd . get_aligner ( data ) and not dd . get_mark_duplicates ( data ) ) ) <NEWLINE> <DEDENT> <DEDENT> if any ( _skip_duplicates ( d ) for d in items ) : <NEWLINE> <INDENT> broad_runner = broad . runner_from_config ( items [ 0 ] [ <STRING> ] ) <NEWLINE> if LooseVersion ( broad_runner . gatk_major_version ( ) ) >= LooseVersion ( <STRING> ) : <NEWLINE> <INDENT> out += [ <STRING> , <STRING> ] <NEWLINE> <DEDENT> <DEDENT> return out <NEWLINE> <DEDENT>
import json <NEWLINE> from crypt import encrypt , decrypt <NEWLINE> from google . appengine . ext import ndb <NEWLINE>
class CommandEchoer ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def solr_query_raw ( self , query_string ) : <NEWLINE> <INDENT> return query_string <NEWLINE> <DEDENT> def solr_query ( self , applied_facets = None , filter_queries = None ) : <NEWLINE> <INDENT> return applied_facets , filter_queries <NEWLINE> <DEDENT> def get_science_object_through_cache ( self , pid ) : <NEWLINE> <INDENT> return pid <NEWLINE> <DEDENT> def get_system_metadata_through_cache ( self , pid ) : <NEWLINE> <INDENT> return pid <NEWLINE> <DEDENT> <DEDENT>
def create_omf_iface ( ec , ip , node ) : <NEWLINE> <INDENT> iface = ec . register_resource ( <STRING> ) <NEWLINE> ec . set ( iface , <STRING> , <STRING> ) <NEWLINE> ec . set ( iface , <STRING> , <STRING> ) <NEWLINE> ec . set ( iface , <STRING> , <STRING> ) <NEWLINE> ec . set ( iface , <STRING> , <STRING> ) <NEWLINE> ec . set ( iface , <STRING> , ip ) <NEWLINE> ec . register_connection ( iface , node ) <NEWLINE> return iface <NEWLINE> <DEDENT>
def conv_to_double_link ( self , head ) : <NEWLINE> <INDENT> pre = None <NEWLINE> root = head <NEWLINE> while root : <NEWLINE> <INDENT> if not root . left : <NEWLINE> <INDENT> root . left = pre <NEWLINE> pre = root <NEWLINE> root = root . right <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = root . left <NEWLINE> while p . right : <NEWLINE> <INDENT> p = p . right <NEWLINE> <DEDENT> p . right = root . right <NEWLINE> root . right = root . left <NEWLINE> root . left = None <NEWLINE> <DEDENT> <DEDENT> return head <NEWLINE> <DEDENT>
def test_lp_all ( dummy_site ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> s = dummy_site ( lambda x : [ x ] , <STRING> ) <NEWLINE> cmd = ProjectList ( <STRING> ) . execute_on ( s ) <NEWLINE> assert len ( cmd ) == 1 <NEWLINE> assert cmd [ 0 ] == <STRING> <NEWLINE> cmd = ProjectList ( ) . execute_on ( s ) <NEWLINE> assert len ( cmd ) == 1 <NEWLINE> assert cmd [ 0 ] == <STRING> <NEWLINE> <DEDENT>
from . physical import PhysicalGraph <NEWLINE> from . shader import HasUniforms <NEWLINE> from . utils import mixins <NEWLINE>
from wetteronline . api import get <NEWLINE> from wetteronline . api import manual <NEWLINE> from wetteronline . api import request_url <NEWLINE>
def __init__ ( self , name = <STRING> , ** config ) : <NEWLINE> <INDENT> super ( Signal , self ) . __init__ ( ** config ) <NEWLINE> self . name = name <NEWLINE> latency = 0 <NEWLINE> self . connections_ = set ( ) <NEWLINE> self . new_samples = 0 <NEWLINE> self . timestamp = 0 <NEWLINE> self . _buffer_size_changed ( ) <NEWLINE> <DEDENT>
from oslo . config import cfg <NEWLINE> LOG_DIR = <STRING> <NEWLINE> LOG_FILE_NAME = <STRING> <NEWLINE> CONF_DIR = <STRING> <NEWLINE> CONF_FILE = CONF_DIR + <STRING> + <STRING> <NEWLINE> SERVICE_URL = <STRING> <NEWLINE> ofp_ofc_config = None <NEWLINE>
def setUp ( self ) : <NEWLINE> <INDENT> sample_doc_path = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> blair_doc_path = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> sample_doc_stream = RawIStream ( join ( * sample_doc_path ) ) <NEWLINE> blair_doc_stream = RawIStream ( join ( * blair_doc_path ) ) <NEWLINE> self . sample_doc_stream = sample_doc_stream <NEWLINE> self . blair_doc_stream = blair_doc_stream <NEWLINE> self . sample_doc = CompoundFile ( sample_doc_stream ) <NEWLINE> self . blair_doc = CompoundFile ( blair_doc_stream ) <NEWLINE> <DEDENT>
def check_config ( config ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> cfg = vodka . config . Config ( read = config ) <NEWLINE> vodka . log . set_loggers ( cfg . get ( <STRING> ) ) <NEWLINE> vodka . app . load_all ( cfg ) <NEWLINE> click . echo ( <STRING> % config ) <NEWLINE> num_crit , num_warn = vodka . config . InstanceHandler . validate ( cfg ) <NEWLINE> click . echo ( <STRING> % ( num_crit , num_warn ) ) <NEWLINE> <DEDENT>
class RQDashboard ( object ) : <NEWLINE> <INDENT> def __init__ ( self , app = None , url_prefix = <STRING> , auth_handler = None ) : <NEWLINE> <INDENT> self . url_prefix = url_prefix <NEWLINE> if app is not None : <NEWLINE> <INDENT> self . app = app <NEWLINE> self . init_app ( app ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . app = None <NEWLINE> <DEDENT> self . auth_handler = auth_handler <NEWLINE> self . redis_conn = None <NEWLINE> <DEDENT> def init_app ( self , app ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> app . register_blueprint ( dashboard , url_prefix = self . url_prefix ) <NEWLINE> app . extensions [ <STRING> ] = self <NEWLINE> <DEDENT> <DEDENT>
import sqlite3 <NEWLINE> import yaml <NEWLINE> with open ( <STRING> , <STRING> ) as config_file : <NEWLINE> <INDENT> config = yaml . load ( config_file ) <NEWLINE> <DEDENT> print ( <STRING> % config [ <STRING> ] ) <NEWLINE> conn = sqlite3 . connect ( config [ <STRING> ] ) <NEWLINE> cursor = conn . cursor ( ) <NEWLINE> from collections import OrderedDict <NEWLINE> db_model = OrderedDict ( ) <NEWLINE>
class Migration ( migrations . Migration ) : <NEWLINE> <INDENT> dependencies = [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE> operations = [ <NEWLINE> <INDENT> migrations . AlterField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> field = models . DateTimeField ( blank = True , default = datetime . datetime ( 2016 , 3 , 23 , 23 , 4 , 21 , 358722 ) ) , <NEWLINE> <DEDENT> ) , <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT>
def setUp ( self ) : <NEWLINE> <INDENT> self . dist_version = DIST_VERSION <NEWLINE> self . log_file = LOG_FILE <NEWLINE> self . log_level = LOG_LEVEL <NEWLINE> self . celery_pid_path = CELERY_PID_PATH <NEWLINE> if self . dist_version == <STRING> : <NEWLINE> <INDENT> self . run = subprocess . check_call <NEWLINE> subprocess . check_call = MagicMock ( ) <NEWLINE> <DEDENT> elif self . dist_version == <STRING> : <NEWLINE> <INDENT> self . run = subprocess . run <NEWLINE> subprocess . run = MagicMock ( ) <NEWLINE> <DEDENT> if os . path . isfile ( self . log_file ) : <NEWLINE> <INDENT> os . remove ( self . log_file ) <NEWLINE> <DEDENT> remove_test_dir ( ) <NEWLINE> <DEDENT>
import curses <NEWLINE> import json <NEWLINE> import locale <NEWLINE> import urllib . request , urllib . parse , urllib . error <NEWLINE> import argparse <NEWLINE> import os <NEWLINE> import livestreamer <NEWLINE> from . featured import FeaturedScreen <NEWLINE> from . games import GamesScreen <NEWLINE> from . streams import StreamsScreen <NEWLINE> from . search import SearchScreen <NEWLINE> from . util import SCREEN_CODE , QUALITY , DESCRIPTION , EPILOG <NEWLINE>
class NotImplementedYet ( NotImplementedError , VEOIBDSynapseError ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , msg = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if msg is None : <NEWLINE> <INDENT> msg = <STRING> . format ( author = __author__ , email = __email__ ) <NEWLINE> <DEDENT> self . args = ( msg , * self . args ) <NEWLINE> <DEDENT> <DEDENT>
import os <NEWLINE> import pytest <NEWLINE> DEFAULT_POSTGRESQL_TEST_URL = <STRING> <NEWLINE>
<STRING> <NEWLINE> import datetime <NEWLINE> from django . db import models <NEWLINE> from django . utils import timezone <NEWLINE> from . FuelSupplierStatus import FuelSupplierStatus <NEWLINE> from . FuelSupplierActionsType import FuelSupplierActionsType <NEWLINE> from auditable . models import Auditable <NEWLINE>
class AnnSearchForm ( SearchForm ) : <NEWLINE> <INDENT> CHANNEL_CHOICES = [ ] <NEWLINE> for channel_pk , channel_str in channel_name . items ( ) : <NEWLINE> <INDENT> CHANNEL_CHOICES . append ( ( channel_pk , channel_str ) ) <NEWLINE> <DEDENT> channel = forms . ChoiceField ( choices = CHANNEL_CHOICES , initial = DEFAULT_CHANNEL ) <NEWLINE> <DEDENT>
class Migration ( migrations . Migration ) : <NEWLINE> <INDENT> dependencies = [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE> operations = [ <NEWLINE> <INDENT> migrations . AlterField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> field = models . IntegerField ( blank = True , null = True , verbose_name = <STRING> ) , <NEWLINE> <DEDENT> ) , <NEWLINE> migrations . AlterField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> field = models . IntegerField ( blank = True , null = True , verbose_name = <STRING> ) , <NEWLINE> <DEDENT> ) , <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT>
def build_job_script ( self , builder , command ) : <NEWLINE> <INDENT> ensure_galaxy_lib_available ( ) <NEWLINE> tool_dependency_manager = deps . build_dependency_manager ( self ) <NEWLINE> dependencies = get_dependencies ( builder ) <NEWLINE> handle_dependencies = <STRING> <NEWLINE> if dependencies : <NEWLINE> <INDENT> handle_dependencies = <STRING> . join ( tool_dependency_manager . dependency_shell_commands ( dependencies , job_directory = builder . tmpdir ) ) <NEWLINE> <DEDENT> template_kwds = dict ( handle_dependencies = handle_dependencies ) <NEWLINE> job_script = COMMAND_WITH_DEPENDENCIES_TEMPLATE . substitute ( template_kwds ) <NEWLINE> return job_script <NEWLINE> <DEDENT>
def load_module ( name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> mod = None <NEWLINE> for mod_name in name . split ( <STRING> ) : <NEWLINE> <INDENT> file , pathname , desc = imp . find_module ( mod_name , mod and mod . __path__ ) <NEWLINE> mod = imp . load_module ( mod_name , file , pathname , desc ) <NEWLINE> <DEDENT> return mod <NEWLINE> <DEDENT>
def getkeymap ( searchkey ) : <NEWLINE> <INDENT> modmapraw = Popen ( [ <STRING> , <STRING> ] , stdout = PIPE ) . communicate ( ) [ 0 ] . decode ( <STRING> ) <NEWLINE> match = re . search ( <STRING> + searchkey + <STRING> , modmapraw ) <NEWLINE> if match : <NEWLINE> <INDENT> return ( int ( re . search ( <STRING> , match . group ( 0 ) ) . group ( 1 ) ) , match . group ( 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT>
def unpack_int ( s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = 0 <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> b = ord ( s [ i ] ) <NEWLINE> ret |= ( b & 127 ) << ( i * 7 ) <NEWLINE> i += 1 <NEWLINE> if b & 128 == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <DEDENT>
<STRING> <NEWLINE> __RCSID__ = <STRING> <NEWLINE> import unittest <NEWLINE> from DIRAC . RequestManagementSystem . private . OperationHandlerBase import OperationHandlerBase <NEWLINE> from DIRAC . RequestManagementSystem . Client . Request import Request <NEWLINE> from DIRAC . RequestManagementSystem . Client . Operation import Operation <NEWLINE> from DIRAC . DataManagementSystem . Client . DataManager import DataManager <NEWLINE>
def __eq__ ( self , other ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not isinstance ( other , PostUiOpenwindowInformationInternalServerError ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return self . __dict__ == other . __dict__ <NEWLINE> <DEDENT>
import pstats <NEWLINE> p = pstats . Stats ( <STRING> ) <NEWLINE> p . sort_stats ( <STRING> ) . print_stats ( 10 ) <NEWLINE>
from pony . orm import * <NEWLINE> from datetime import datetime <NEWLINE> from model . group import Group <NEWLINE> from model . contact import Contact <NEWLINE> from pymysql . converters import encoders , decoders , convert_mysql_timestamp <NEWLINE>
from senpy . plugins import SentimentPlugin <NEWLINE> from senpy . models import Response , Entry <NEWLINE> import logging <NEWLINE> logger = logging . getLogger ( __name__ ) <NEWLINE>
def _gen_times ( base , size , delay_period = 0.05 ) : <NEWLINE> <INDENT> times = <STRING> <NEWLINE> j = 0 <NEWLINE> k = 0 <NEWLINE> two_places = decimal . Decimal ( <STRING> ) ** - 2 <NEWLINE> while j < size : <NEWLINE> <INDENT> times += str ( decimal . Decimal ( base + delay_period * j ) . quantize ( two_places ) ) + <STRING> <NEWLINE> j += 1 <NEWLINE> <DEDENT> k = delay_period * ( j - 1 ) + base <NEWLINE> return k , times <NEWLINE> <DEDENT>
import testbasenode <NEWLINE> import testbdf <NEWLINE> import testcv <NEWLINE> import testdataset <NEWLINE> import testedf <NEWLINE> import testeegmontage <NEWLINE> import testexpinfo <NEWLINE> import testfiltering <NEWLINE> import testmarkers <NEWLINE> import testnonstat <NEWLINE> import testparafac <NEWLINE> import testperf <NEWLINE> import testplots <NEWLINE> import testpositions <NEWLINE> import testsimple <NEWLINE> import testslidingwindow <NEWLINE> import testspatialfilter <NEWLINE> import teststat <NEWLINE> import testtimefreq <NEWLINE> import testtrials <NEWLINE> import testutils <NEWLINE>
def connectionMade ( self ) : <NEWLINE> <INDENT> self . out ( <STRING> ) <NEWLINE> self . state = <STRING> <NEWLINE> <DEDENT>
class Upload ( models . Model ) : <NEWLINE> <INDENT> upload = models . FileField ( ) <NEWLINE> def __str__ ( self ) : <NEWLINE> <INDENT> return self . upload . name <NEWLINE> <DEDENT> <DEDENT>
def get_uptime ( self ) : <NEWLINE> <INDENT> bash_output = commands . getstatusoutput ( <STRING> ) [ 1 ] <NEWLINE> split_output = bash_output . split ( <STRING> ) <NEWLINE> return split_output [ 4 ] <NEWLINE> <DEDENT>
from setuptools import setup <NEWLINE> from setuptools import find_packages <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> version = <STRING> , <NEWLINE> description = <STRING> , <NEWLINE> author = <STRING> , <NEWLINE> author_email = <STRING> , <NEWLINE> classifiers = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <DEDENT> ] , <NEWLINE> packages = find_packages ( ) , <NEWLINE> license = <STRING> , <NEWLINE> package_dir = { <STRING> : <STRING> } , <NEWLINE> entry_points = { <NEWLINE> <INDENT> <STRING> : [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <DEDENT> ] , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> ) <NEWLINE>
def computeMatchProbability ( string , GCContent ) : <NEWLINE> <INDENT> probabilities = computeProbabilities ( GCContent ) <NEWLINE> res = 1 <NEWLINE> for c in string : <NEWLINE> <INDENT> res *= probabilities [ c ] <NEWLINE> <DEDENT> return commonLogarithm ( res ) <NEWLINE> <DEDENT>
def dbCursor ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . _dbCursor is None : <NEWLINE> <INDENT> self . _dbCursor = self . dbConnection . cursor ( ) <NEWLINE> <DEDENT> return self . _dbCursor <NEWLINE> <DEDENT>
import tagpy <NEWLINE> import glob <NEWLINE> import os <NEWLINE> import sys <NEWLINE> import re <NEWLINE>
from redlib . api . misc import Retry <NEWLINE> from redlib . api . image import get_image_info <NEWLINE> from PIL import Image <NEWLINE> from . base import SourceError <NEWLINE> from . . web . func import get , HttpError , exists <NEWLINE> from . . db . app . config import Config <NEWLINE> from . . util . logger import log <NEWLINE> from . . util . printer import printer <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> from tempfile import mkdtemp <NEWLINE> from cement . core . foundation import CementApp <NEWLINE> from cement . core import exc as cement_exc <NEWLINE> from cement . utils import fs , misc <NEWLINE> from boss . core import exc as boss_exc <NEWLINE> CONFIG_DEFAULTS = misc . init_defaults ( <STRING> , <STRING> ) <NEWLINE> CONFIG_DEFAULTS [ <STRING> ] [ <STRING> ] = <STRING> <NEWLINE>
def get_unique_variable ( var_op_name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> candidates = get_variables ( scope = var_op_name ) <NEWLINE> if not candidates : <NEWLINE> <INDENT> raise ValueError ( <STRING> % var_op_name ) <NEWLINE> <DEDENT> for candidate in candidates : <NEWLINE> <INDENT> if candidate . op . name == var_op_name : <NEWLINE> <INDENT> return candidate <NEWLINE> <DEDENT> <DEDENT> raise ValueError ( <STRING> % <NEWLINE> <INDENT> var_op_name ) <NEWLINE> <DEDENT> <DEDENT>
def matches_count ( text , words ) : <NEWLINE> <INDENT> text_words = flatten ( text ) . split ( ) <NEWLINE> matches = { word : text_words . count ( flatten ( word ) ) for word in words } <NEWLINE> return matches <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> parser = create_parsers ( ) <NEWLINE> args = vars ( parser . parse_args ( ) ) <NEWLINE> in_f = args [ <STRING> ] <NEWLINE> out_f = args [ <STRING> ] <NEWLINE> convert_file ( in_f , out_f ) <NEWLINE> <DEDENT>
def setProtocol ( self , protocol ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . defaultprotocol = protocol <NEWLINE> <DEDENT>
def buildResponseBody ( response , request ) : <NEWLINE> <INDENT> responseBody = { <NEWLINE> <INDENT> <STRING> : request [ <STRING> ] , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : request [ <STRING> ] , <NEWLINE> <STRING> : response <NEWLINE> <DEDENT> } <NEWLINE> return responseBody <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from collections import namedtuple <NEWLINE> import re <NEWLINE> import os <NEWLINE> import logging <NEWLINE> from ragout . parsers . phylogeny_parser import get_leaves_names , PhyloException <NEWLINE> import ragout . shared . config as config <NEWLINE> logger = logging . getLogger ( ) <NEWLINE>
from PyQt5 import QtCore <NEWLINE> from PyQt5 . QtCore import QUrl <NEWLINE> from PyQt5 . QtGui import QKeySequence <NEWLINE> from PyQt5 . QtWidgets import QMainWindow , QTreeWidget , QTreeWidgetItem , QMenuBar , QAction <NEWLINE> import os <NEWLINE> __all__ = [ <STRING> , ] <NEWLINE>
def load_from_file ( self ) : <NEWLINE> <INDENT> events = validate_json ( self . filename ) <NEWLINE> if events is False : <NEWLINE> <INDENT> with open ( filename , <STRING> ) as f : <NEWLINE> <INDENT> json . dump ( TEMPLATE , f ) <NEWLINE> f . close ( ) <NEWLINE> <DEDENT> <DEDENT> return mergesort ( events ) <NEWLINE> <DEDENT>
def submissions_zip_generator ( submissions ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> bytes_io = StreamingBytesIO ( ) <NEWLINE> with ZipFile ( bytes_io , mode = <STRING> , compression = ZIP_DEFLATED , allowZip64 = True ) as zip_file : <NEWLINE> <INDENT> for submission in submissions : <NEWLINE> <INDENT> filename = os . path . basename ( submission . student_document . name ) <NEWLINE> zip_file . writestr ( filename , submission . student_document . read ( ) ) <NEWLINE> yield bytes_io . getvalue ( ) <NEWLINE> bytes_io . empty ( ) <NEWLINE> <DEDENT> <DEDENT> yield bytes_io . getvalue ( ) <NEWLINE> <DEDENT>
class ZabbixNS ( ProtocolDriver ) : <NEWLINE> <INDENT> def recv_data ( self , data ) : <NEWLINE> <INDENT> return data <NEWLINE> <DEDENT> def send_data ( self , data ) : <NEWLINE> <INDENT> data [ <STRING> ] = 0 <NEWLINE> return data <NEWLINE> <DEDENT> <DEDENT>
def __call__ ( self ) : <NEWLINE> <INDENT> actors = self . actors ( ) <NEWLINE> directors = self . directors ( ) <NEWLINE> ratings = self . ratings ( ) <NEWLINE> return { <NEWLINE> <INDENT> <STRING> : directors , <NEWLINE> <STRING> : ratings , <NEWLINE> <STRING> : actors <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>
def extract_error_detail ( self , login_response ) : <NEWLINE> <INDENT> details_str = <STRING> <NEWLINE> try : <NEWLINE> <INDENT> if login_response . content : <NEWLINE> <INDENT> json_object = common . json_decode ( login_response . content ) <NEWLINE> if <STRING> in json_object : <NEWLINE> <INDENT> details_str = json_object [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT> return details_str <NEWLINE> <DEDENT> except common . CoprHdError : <NEWLINE> <INDENT> return details_str <NEWLINE> <DEDENT> <DEDENT>
from flask_restplus import reqparse <NEWLINE> new_symbol = reqparse . RequestParser ( ) <NEWLINE> new_symbol . add_argument ( <STRING> , <NEWLINE> <INDENT> type = str , <NEWLINE> required = False , <NEWLINE> location = <STRING> , <NEWLINE> help = <STRING> ) <NEWLINE> <DEDENT> new_symbol . add_argument ( <STRING> , <NEWLINE> <INDENT> type = str , <NEWLINE> required = False , <NEWLINE> location = <STRING> , <NEWLINE> help = <STRING> ) <NEWLINE> <DEDENT> add_field = reqparse . RequestParser ( ) <NEWLINE> add_field . add_argument ( <STRING> , <NEWLINE> <INDENT> type = str , <NEWLINE> required = False , <NEWLINE> location = <STRING> , <NEWLINE> help = <STRING> ) <NEWLINE> <DEDENT>
def append ( self , font ) : <NEWLINE> <INDENT> item = self . _wrapFontForList ( font ) <NEWLINE> super ( FontList , self ) . append ( item ) <NEWLINE> <DEDENT>
class ValuesGetterThread ( QtCore . QThread ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> result = QtCore . Signal ( str ) <NEWLINE> def __init__ ( self , crawling_supervisor ) : <NEWLINE> <INDENT> QtCore . QThread . __init__ ( self ) <NEWLINE> self . cs = crawling_supervisor <NEWLINE> <DEDENT> def run ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for e in self . cs . do_crawling ( ) : <NEWLINE> <INDENT> self . result . emit ( e ) <NEWLINE> <DEDENT> <DEDENT> def stop ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . terminate ( ) <NEWLINE> <DEDENT> <DEDENT>
def update_mem ( self , size ) : <NEWLINE> <INDENT> if not size : <NEWLINE> <INDENT> size = _ ( <STRING> ) <NEWLINE> fraction = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fraction = size / self . total_mem <NEWLINE> size = <STRING> % formatting . formatStorage ( size ) <NEWLINE> <DEDENT> self . mem . set_text ( size ) <NEWLINE> self . mem . set_fraction ( fraction ) <NEWLINE> <DEDENT>
def compress_group ( string ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return str ( string [ 0 ] ) + str ( len ( string ) ) <NEWLINE> <DEDENT>
class Interval ( object ) : <NEWLINE> <INDENT> def __init__ ( self , gene_id , start , stop ) : <NEWLINE> <INDENT> self . start = start <NEWLINE> self . stop = stop <NEWLINE> self . gene = gene_id <NEWLINE> <DEDENT> def __repr__ ( self ) : <NEWLINE> <INDENT> return <STRING> % ( self . gene , self . start , self . stop ) <NEWLINE> <DEDENT> <DEDENT>
def _select_file ( self , item ) : <NEWLINE> <INDENT> doc = self . _diff_view . document ( ) <NEWLINE> cursor = doc . find ( QRegExp ( <STRING> + item . text ( ) ) ) <NEWLINE> cursor . movePosition ( QTextCursor . StartOfLine ) <NEWLINE> self . _diff_view . setTextCursor ( cursor ) <NEWLINE> self . _diff_view . centerCursor ( ) <NEWLINE> <DEDENT>
class Solution ( object ) : <NEWLINE> <INDENT> def shortestPalindrome ( self , s ) : <NEWLINE> <INDENT> r = s [ : : - 1 ] <NEWLINE> for i in range ( len ( s ) + 1 ) : <NEWLINE> <INDENT> if s . startswith ( r [ i : ] ) : <NEWLINE> <INDENT> return r [ : i ] + s <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def _jsonb_io_factory ( oid , typeio ) : <NEWLINE> <INDENT> _pack = lambda x : jsonb_pack ( x , typeio ) <NEWLINE> _unpack = lambda x : jsonb_unpack ( x , typeio ) <NEWLINE> return ( _pack , _unpack , str ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import unittest <NEWLINE> from sample import Echo <NEWLINE>
from distutils . core import setup <NEWLINE> setup ( name = <STRING> , <NEWLINE> <INDENT> version = <STRING> , <NEWLINE> description = <STRING> , <NEWLINE> author = <STRING> , <NEWLINE> author_email = <STRING> , <NEWLINE> url = <STRING> , <NEWLINE> license = <STRING> , <NEWLINE> package_dir = { <STRING> : <STRING> } , <NEWLINE> packages = [ <STRING> ] , <NEWLINE> package_data = { <STRING> : [ <STRING> ] } , <NEWLINE> scripts = [ <STRING> ] <NEWLINE> <DEDENT> ) <NEWLINE>
def diff_trees ( left_version , right_version ) : <NEWLINE> <INDENT> left_tree = RegNode . objects . get ( tag = <STRING> , version = left_version ) <NEWLINE> right_tree = RegNode . objects . get ( tag = <STRING> , version = right_version ) <NEWLINE> left_tree . get_descendants ( ) <NEWLINE> right_tree . get_descendants ( ) <NEWLINE> left_tree . compute_merkle_hash ( ) <NEWLINE> right_tree . compute_merkle_hash ( ) <NEWLINE> left_labels = set ( gather_regnode_labels ( left_tree ) ) <NEWLINE> right_labels = set ( gather_regnode_labels ( right_tree ) ) <NEWLINE> only_left_labels = left_labels - right_labels <NEWLINE> only_right_labels = right_labels - left_labels <NEWLINE> both_labels = left_labels & right_labels <NEWLINE> for label in only_right_labels : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
def format_engine_status ( engine = None ) : <NEWLINE> <INDENT> status = get_engine_status ( engine ) <NEWLINE> s = <STRING> <NEWLINE> for test , result in status [ <STRING> ] : <NEWLINE> <INDENT> s += <STRING> % ( test , result ) <NEWLINE> <DEDENT> s += <STRING> <NEWLINE> for spider , tests in status [ <STRING> ] . items ( ) : <NEWLINE> <INDENT> s += <STRING> % spider <NEWLINE> for test , result in tests : <NEWLINE> <INDENT> s += <STRING> % ( test , result ) <NEWLINE> <DEDENT> <DEDENT> return s <NEWLINE> <DEDENT>
def infer_outcome ( self , l , a , c , query ) : <NEWLINE> <INDENT> c = asarray ( c ) <NEWLINE> a = ( asarray ( a [ 0 ] ) , asarray ( a [ 1 ] ) ) <NEWLINE> click_ids = where ( c == 1 ) [ 0 ] <NEWLINE> if not len ( click_ids ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> c1 , c2 = self . check_constraints ( l , a , click_ids ) <NEWLINE> return 1 if c1 > c2 else - 1 if c2 > c1 else 0 <NEWLINE> <DEDENT>
class VLANManualResourceModel ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . access_mode = <STRING> <NEWLINE> self . isolation_level = <STRING> <NEWLINE> self . virtual_network = <STRING> <NEWLINE> self . virtual_network_attribute = <STRING> <NEWLINE> self . vlan_id = <STRING> <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> __revision__ = 0 <NEWLINE> import abc <NEWLINE>
def test_const ( injector ) : <NEWLINE> <INDENT> call_check = Mock ( return_value = None ) <NEWLINE> @ injector . factory ( <STRING> , scope = scopes . Const ) <NEWLINE> def factory ( ) : <NEWLINE> <INDENT> return call_check ( ) <NEWLINE> <DEDENT> assert injector . get ( <STRING> ) == None <NEWLINE> assert injector . get ( <STRING> ) == None <NEWLINE> call_check . assert_called_once_with ( ) <NEWLINE> <DEDENT>
def __init__ ( self , sqs_settings = None , processor = None , exception = None ) : <NEWLINE> <INDENT> if not processor : <NEWLINE> <INDENT> raise GatherException ( <STRING> ) <NEWLINE> <DEDENT> self . _processor = processor <NEWLINE> self . _exception = exception if exception else processor . EXCEPTION_CLASS <NEWLINE> self . _settings = sqs_settings if sqs_settings else settings . AWS_SQS . get ( processor . SETTINGS_NAME ) <NEWLINE> self . _topicArn = self . _settings . get ( <STRING> ) <NEWLINE> self . _queue = SQSQueue ( settings = self . _settings ) <NEWLINE> self . _log = getLogger ( __name__ ) <NEWLINE> <DEDENT>
class UcsmDisconnectFailed ( exceptions . NeutronException ) : <NEWLINE> <INDENT> message = _ ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import project_source_info <NEWLINE> import subprocess <NEWLINE> import sys <NEWLINE> import os <NEWLINE> USE_QUIET = ( os . environ . get ( <STRING> , None ) is not None ) <NEWLINE> CHECKER_IGNORE_PREFIX = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> ] <NEWLINE> <DEDENT> CHECKER_BIN = <STRING> <NEWLINE> CHECKER_ARGS = [ <NEWLINE> <INDENT> os . path . join ( os . path . dirname ( __file__ ) , <STRING> ) , <NEWLINE> <STRING> + os . path . join ( project_source_info . SOURCE_DIR , <STRING> , <STRING> , <STRING> ) , <NEWLINE> <STRING> <NEWLINE> ] <NEWLINE> <DEDENT>
def send_event_create_mail ( event , users_emails ) : <NEWLINE> <INDENT> current_site = Site . objects . get_current ( ) <NEWLINE> extra_context = { <STRING> : event , <STRING> : get_event_review_url ( event ) , <NEWLINE> <INDENT> <STRING> : <STRING> . format ( settings . SITE_SCHEME , current_site . domain ) } <NEWLINE> <DEDENT> send_email ( <STRING> + event . name [ : 15 ] + <STRING> , <NEWLINE> <INDENT> <STRING> , users_emails , <NEWLINE> extra_context , <STRING> ) <NEWLINE> <DEDENT> send_email ( <STRING> + event . name [ : 15 ] + <STRING> , <NEWLINE> <INDENT> <STRING> , [ event . owner_email ] , <NEWLINE> extra_context , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> import matplotlib . pyplot as plt <NEWLINE> from sklearn import datasets <NEWLINE>
def _SetupPaths ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> tracing_dir = os . path . abspath ( os . path . dirname ( __file__ ) ) <NEWLINE> sys . path . append ( tracing_dir ) <NEWLINE> sys . path . append ( os . path . normpath ( os . path . join ( tracing_dir , os . pardir ) ) ) <NEWLINE> <DEDENT>
def test_get_response_check ( self ) : <NEWLINE> <INDENT> t = operators . SimpleHttpOperator ( <NEWLINE> <INDENT> task_id = <STRING> , <NEWLINE> method = <STRING> , <NEWLINE> endpoint = <STRING> , <NEWLINE> data = { <STRING> : <STRING> , <STRING> : <STRING> } , <NEWLINE> response_check = lambda response : ( <STRING> in response . text ) , <NEWLINE> headers = { } , <NEWLINE> dag = self . dag ) <NEWLINE> <DEDENT> t . run ( start_date = DEFAULT_DATE , end_date = DEFAULT_DATE , force = True ) <NEWLINE> <DEDENT>
def __init__ ( self , ignore_border , mode = <STRING> , ndim = 2 ) : <NEWLINE> <INDENT> self . ndim = ndim <NEWLINE> self . ignore_border = ignore_border <NEWLINE> self . mode = mode <NEWLINE> CGpuKernelBase . __init__ ( self , [ <STRING> ] , <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> assert mode == <STRING> <NEWLINE> assert ndim in [ 2 , 3 ] <NEWLINE> <DEDENT>
def add_owner ( apps , schema_editor ) : <NEWLINE> <INDENT> LieuAFO = apps . get_model ( <STRING> , <STRING> ) <NEWLINE> EvenementAFO = apps . get_model ( <STRING> , <STRING> ) <NEWLINE> if not LieuAFO . objects . exists ( ) and not EvenementAFO . objects . exists ( ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> owner = apps . get_model ( <STRING> , <STRING> ) . objects . get ( <NEWLINE> <INDENT> username = <STRING> ) <NEWLINE> <DEDENT> LieuAFO . objects . update ( owner = owner ) <NEWLINE> EvenementAFO . objects . update ( owner = owner ) <NEWLINE> <DEDENT>
class AStarSearchModel : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> pass <NEWLINE> <DEDENT> def getActionListWithMetric ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> pass <NEWLINE> <DEDENT> def doAction ( self , action ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>
from __future__ import absolute_import <NEWLINE> from __future__ import division <NEWLINE> from __future__ import print_function <NEWLINE> from __future__ import unicode_literals <NEWLINE> import glob <NEWLINE> import os <NEWLINE> modules = glob . glob ( os . path . dirname ( __file__ ) + <STRING> ) <NEWLINE> ALL_TABLES = [ os . path . basename ( f ) [ : - 3 ] for f in modules ] <NEWLINE>
def test_oneway_C_SSL ( self ) : <NEWLINE> <INDENT> self . _ssl_check ( ) <NEWLINE> self . _do_oneway_test ( MessengerReceiverC ( ) , MessengerSenderC ( ) , <STRING> ) <NEWLINE> <DEDENT>
from . homepage import HomePage <NEWLINE> from . history import HistoryPage , DetailsPage , BillsPage <NEWLINE> from . login import LoginPage <NEWLINE> __all__ = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE>
def accumulate_m2m_mapping ( obj , container_key , item_key , container_coerce = identity , item_coerce = identity ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = { } <NEWLINE> for item in obj : <NEWLINE> <INDENT> container_id = container_coerce ( item [ container_key ] ) <NEWLINE> item_id = item_coerce ( item [ item_key ] ) <NEWLINE> if container_id in ret : <NEWLINE> <INDENT> ret [ container_id ] . append ( item_id ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret [ container_id ] = [ item_id ] <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import math <NEWLINE> data = input ( ) <NEWLINE> n , m , a = [ int ( x ) for x in data . split ( ) ] <NEWLINE> x = math . ceil ( n / a ) <NEWLINE> y = math . ceil ( m / a ) <NEWLINE> print ( x * y ) <NEWLINE>
import os <NEWLINE> import shutil <NEWLINE> import traceback <NEWLINE> from lib . FileManager . workers . baseUploadWorker import BaseUploadWorker <NEWLINE>
def post_receive ( self , alert ) : <NEWLINE> <INDENT> LOG . info ( <STRING> , alert . get_id ( ) , self . topic_arn ) <NEWLINE> LOG . debug ( <STRING> , alert . get_body ( ) ) <NEWLINE> response = self . connection . publish ( topic = self . topic_arn , message = alert . get_body ( ) ) <NEWLINE> LOG . debug ( <STRING> , response ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> __authors__ = <STRING> . join ( [ <STRING> <NEWLINE> <INDENT> <STRING> ] ) <NEWLINE> <DEDENT> __all__ = [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> <NEWLINE> ] <NEWLINE> <DEDENT> import networkx as nx <NEWLINE>
def find_index ( vec_vals , target ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> target = np . atleast_1d ( target ) <NEWLINE> vec_vals = np . array ( vec_vals ) <NEWLINE> index_list = [ ] <NEWLINE> for item in target : <NEWLINE> <INDENT> first_index = np . argmin ( np . abs ( vec_vals - item ) ) <NEWLINE> index_list . append ( first_index ) <NEWLINE> <DEDENT> return index_list <NEWLINE> <DEDENT>
def test_lasso_zero ( ) : <NEWLINE> <INDENT> X = [ [ 0 ] , [ 0 ] , [ 0 ] ] <NEWLINE> y = [ 0 , 0 , 0 ] <NEWLINE> clf = Lasso ( alpha = 0.1 ) . fit ( X , y ) <NEWLINE> pred = clf . predict ( [ [ 1 ] , [ 2 ] , [ 3 ] ] ) <NEWLINE> assert_array_almost_equal ( clf . coef_ , [ 0 ] ) <NEWLINE> assert_array_almost_equal ( pred , [ 0 , 0 , 0 ] ) <NEWLINE> assert_almost_equal ( clf . dual_gap_ , 0 ) <NEWLINE> <DEDENT>
class SystemCapabilities ( Packet ) : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> fields_desc = [ BitField ( <STRING> , 7 , 7 ) , <NEWLINE> <INDENT> BitField ( <STRING> , 4 , 9 ) , <NEWLINE> ShortField ( <STRING> , 2 ) , <NEWLINE> ShortField ( <STRING> , 1 ) ] <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> import matplotlib . pyplot as plt <NEWLINE> from pylab import * <NEWLINE> x = [ - 5 , - 3 , - 4 , - 6 , - 5 , - 3 , 3 , 4 , 5 ] <NEWLINE> y = [ - 3 , - 4 , - 5 , 3 , 5 , 6 , 7 , 5 , 5 ] <NEWLINE> color = [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 ] <NEWLINE> plt . scatter ( x , y , c = color , s = 500 ) <NEWLINE> savefig ( <STRING> ) <NEWLINE> plt . show ( ) <NEWLINE>
def __init__ ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . input = <STRING> <NEWLINE> self . output = <STRING> <NEWLINE> self . env = None <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import numpy as np <NEWLINE> import scipy . linalg as la <NEWLINE>
class SystemctlSSRCommandLogicTests ( TestCase , SystemctlCommandLogicMixin ) : <NEWLINE> <INDENT> def _test_ssr ( self , output , expected_error = False ) : <NEWLINE> <INDENT> assertMethod = self . assertTrue if expected_error else self . assertFalse <NEWLINE> with self . app . test_request_context ( ) : <NEWLINE> <INDENT> with self . patch_getoutput ( output ) : <NEWLINE> <INDENT> error = systemctl_ssr_command ( <STRING> , <STRING> ) <NEWLINE> assertMethod ( error ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> def test_no_error ( self ) : <NEWLINE> <INDENT> self . _test_ssr ( <STRING> ) <NEWLINE> <DEDENT> def test_error ( self ) : <NEWLINE> <INDENT> self . _test_ssr ( SYSTEMCTL_SSR_ERROR_OUTPUT , expected_error = True ) <NEWLINE> <DEDENT> <DEDENT>
import os <NEWLINE> import logging <NEWLINE> from glob import glob <NEWLINE> import fnmatch <NEWLINE> import h5py <NEWLINE> from PIL import Image <NEWLINE> import numpy as np <NEWLINE> import pyglet <NEWLINE> from . roi import ROI <NEWLINE>
def factorial ( n ) : <NEWLINE> <INDENT> factorial_total = 1 <NEWLINE> while n >= 1 : <NEWLINE> <INDENT> factorial_total = factorial_total * n <NEWLINE> n = n - 1 <NEWLINE> <DEDENT> return factorial_total <NEWLINE> <DEDENT>
def apply_to_one ( f ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return f ( 1 ) <NEWLINE> <DEDENT>
import pymc <NEWLINE> x = pymc . Uniform ( <STRING> , lower = 0.0 , upper = 1.0 ) <NEWLINE> y = pymc . Uniform ( <STRING> , lower = 0.0 , upper = 1.0 ) <NEWLINE>
<STRING> <NEWLINE> import sys <NEWLINE> from numpy import zeros , arange , flatnonzero as find <NEWLINE> from pypower . idx_cost import MODEL , NCOST , PW_LINEAR , COST <NEWLINE>
def _get_elem_at_rank ( rank , data , n_negative , n_zeros ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if rank < n_negative : <NEWLINE> <INDENT> return data [ rank ] <NEWLINE> <DEDENT> if rank - n_negative < n_zeros : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return data [ rank - n_zeros ] <NEWLINE> <DEDENT>
def get_table_info ( table_id ) : <NEWLINE> <INDENT> config_instance = MIRNDataSourceConfig . from_dict ( BIGQUERY_CONFIG ) <NEWLINE> table_info = None <NEWLINE> for table_config in config_instance . data_table_list : <NEWLINE> <INDENT> if table_config . internal_table_id == table_id : <NEWLINE> <INDENT> table_info = table_config <NEWLINE> <DEDENT> <DEDENT> return table_info <NEWLINE> <DEDENT>
from . api import API <NEWLINE> from . baseservice import BaseService <NEWLINE> from . defaults import Defaults <NEWLINE> LOCATOR_DEFAULT_ENDPOINTS = Defaults . locators <NEWLINE>
def guest_required ( f ) : <NEWLINE> <INDENT> @ wraps ( f ) <NEWLINE> def decorated_function ( * args , ** kwargs ) : <NEWLINE> <INDENT> if <STRING> in session : <NEWLINE> <INDENT> return redirect ( url_for ( <STRING> ) ) <NEWLINE> <DEDENT> return f ( * args , ** kwargs ) <NEWLINE> <DEDENT> return decorated_function <NEWLINE> <DEDENT>
def getUserConsentByUniqueID ( self , uniqueID ) : <NEWLINE> <INDENT> if self . getByUniqueID ( uniqueID ) . date_signed is not None : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT>
def make_public ( modeladmin , request , queryset ) : <NEWLINE> <INDENT> for obj in queryset . filter ( is_public = False ) : <NEWLINE> <INDENT> obj . __dict__ . update ( is_public = True , published_by_id = request . user . id ) <NEWLINE> obj . save ( ) <NEWLINE> if obj . speakers : <NEWLINE> <INDENT> thread = SessionApprovedEmailThread ( obj ) <NEWLINE> if thread . should_send : <NEWLINE> <INDENT> SentEmail ( email_thread = thread ) . save ( ) <NEWLINE> thread . start ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from _10gen import getglobal <NEWLINE> import _10gen <NEWLINE> _10gen . pyX = getglobal ( <STRING> ) <NEWLINE> _10gen . pyY = getglobal ( <STRING> ) <NEWLINE>
class IElementForStg ( object ) : <NEWLINE> <INDENT> def __init__ ( self , templates , settingsObject ) : <NEWLINE> <INDENT> self . templatesRepository = templates <NEWLINE> self . settingsObject = settingsObject <NEWLINE> self . templateResolver = TemplateResolver ( self . templatesRepository , self . getTemplateName ( ) ) <NEWLINE> <DEDENT> def getType ( self ) : <NEWLINE> <INDENT> raise NotImplementedError ( <STRING> ) <NEWLINE> <DEDENT> def getTemplateName ( self ) : <NEWLINE> <INDENT> raise NotImplementedError ( <STRING> ) <NEWLINE> <DEDENT> def resolve ( self ) : <NEWLINE> <INDENT> return self . templateResolver . fill ( self . settingsObject ) <NEWLINE> <DEDENT> <DEDENT>
def _delete_object_method ( obj_name ) : <NEWLINE> <INDENT> def del_obj ( self , obj_id , ** kwargs ) : <NEWLINE> <INDENT> url = <STRING> <NEWLINE> if not self . simulate : <NEWLINE> <INDENT> full_url = url . format ( url = self . api_base_url , obj_name = obj_name , obj_id = obj_id ) <NEWLINE> logging . debug ( <STRING> , full_url ) <NEWLINE> resp = requests . delete ( <NEWLINE> <INDENT> full_url , <NEWLINE> headers = self . headers , <NEWLINE> params = kwargs ) <NEWLINE> <DEDENT> return self . handle_resp ( resp , 200 ) <NEWLINE> <DEDENT> return { <STRING> : obj_id } <NEWLINE> <DEDENT> return del_obj <NEWLINE> <DEDENT>
import requests <NEWLINE> import sys <NEWLINE> import json <NEWLINE> import time <NEWLINE> from portality . core import app <NEWLINE> config = app . config <NEWLINE> ENDPOINT_TEMPLATE = <STRING> <NEWLINE>
def django_version_after ( available , limit ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return StrictVersion ( available ) > StrictVersion ( limit ) <NEWLINE> <DEDENT>
def get_window ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . _window <NEWLINE> <DEDENT>
def add_default_values_to_help ( parser ) : <NEWLINE> <INDENT> for group in parser . option_groups + [ parser ] : <NEWLINE> <INDENT> for option in group . option_list : <NEWLINE> <INDENT> if option . default != NO_DEFAULT and option . help : <NEWLINE> <INDENT> option . help += <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
class Fasta2Nexus ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , infile , outfile , * args , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . infile = infile <NEWLINE> self . outfile = outfile <NEWLINE> <DEDENT> def __call__ ( self ) : <NEWLINE> <INDENT> input_handle = open ( self . infile , <STRING> ) <NEWLINE> output_handle = open ( self . outfile , <STRING> ) <NEWLINE> alignments = AlignIO . parse ( input_handle , <STRING> ) <NEWLINE> AlignIO . write ( alignments , output_handle , <STRING> ) <NEWLINE> output_handle . close ( ) <NEWLINE> input_handle . close ( ) <NEWLINE> <DEDENT> <DEDENT>
class Facilitator ( Person ) : <NEWLINE> <INDENT> bio = models . TextField ( max_length = 500 ) <NEWLINE> twitter = models . CharField ( max_length = 25 ) <NEWLINE> def __str__ ( self ) : <NEWLINE> <INDENT> return self . name <NEWLINE> <DEDENT> <DEDENT>
from persistent import Persistent <NEWLINE> from zope . component . factory import Factory <NEWLINE> from zope . interface import implements <NEWLINE> from sparc . entity import SparcEntity <NEWLINE> from interfaces import IPerson <NEWLINE>
def Pull ( self , request , context ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> context . set_code ( grpc . StatusCode . UNIMPLEMENTED ) <NEWLINE> context . set_details ( <STRING> ) <NEWLINE> raise NotImplementedError ( <STRING> ) <NEWLINE> <DEDENT>
class CUDA_build_ext ( build_ext ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def build_extensions ( self ) : <NEWLINE> <INDENT> self . compiler . src_extensions . append ( <STRING> ) <NEWLINE> self . compiler . set_executable ( <STRING> , <STRING> ) <NEWLINE> self . compiler . set_executable ( <STRING> , <STRING> ) <NEWLINE> build_ext . build_extensions ( self ) <NEWLINE> <DEDENT> <DEDENT>
class SelectionPane ( TraitsDockPane ) : <NEWLINE> <INDENT> id = <STRING> <NEWLINE> name = <STRING> <NEWLINE> def traits_view ( self ) : <NEWLINE> <INDENT> origin_grp = VGroup ( UItem ( <STRING> , <NEWLINE> <INDENT> editor = ListStrEditor ( selected = <STRING> , <NEWLINE> <INDENT> editable = False ) ) , <NEWLINE> show_border = True , label = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> local_grp = VGroup ( UItem ( <STRING> , <NEWLINE> <INDENT> editor = ListStrEditor ( selected = <STRING> , <NEWLINE> <INDENT> editable = False ) ) , <NEWLINE> show_border = True , label = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> v = View ( VGroup ( local_grp , origin_grp ) ) <NEWLINE> return v <NEWLINE> <DEDENT> <DEDENT>
from common import * <NEWLINE> from mayatools . transforms import transfer_global_transforms <NEWLINE> from mayatools . locators import bake_global_locators <NEWLINE>
class DisconnectError ( Exception ) : <NEWLINE> <INDENT> def __init__ ( self , reason_code , message ) : <NEWLINE> <INDENT> self . reason_code = reason_code <NEWLINE> self . message = message <NEWLINE> super ( DisconnectError , self ) . __init__ ( message ) <NEWLINE> <DEDENT> <DEDENT>
def _slug ( self , url ) : <NEWLINE> <INDENT> url = unquote ( url ) <NEWLINE> fragments = urlparse ( url ) <NEWLINE> directory = self . _domain_to_directory ( fragments . netloc ) <NEWLINE> path , file_fragment = os . path . split ( fragments . path ) <NEWLINE> path = self . _path_to_directory ( path ) <NEWLINE> filename = file_fragment <NEWLINE> path = os . path . join ( directory , path , filename ) <NEWLINE> return self . _remove_invaild_characters ( path ) <NEWLINE> <DEDENT>
def path ( f ) : <NEWLINE> <INDENT> for d in os . listdir ( f ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> for s in os . listdir ( os . path . join ( f , d ) ) : <NEWLINE> <INDENT> if s . endswith ( <STRING> ) : <NEWLINE> <INDENT> return os . path . join ( f , d ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> return None <NEWLINE> <DEDENT>
def set_option ( self , section , option , value ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . conf . set ( section , option , value ) <NEWLINE> with open ( self . file , <STRING> ) as configfile : <NEWLINE> <INDENT> self . conf . write ( configfile ) <NEWLINE> <DEDENT> <DEDENT> except Exception as err : <NEWLINE> <INDENT> self . log . warning ( <STRING> % err ) <NEWLINE> <DEDENT> <DEDENT>
from estrella_classes import * <NEWLINE> from sys import exit <NEWLINE> from os import getcwd <NEWLINE> import matplotlib . pyplot as plt <NEWLINE>
from glob import glob <NEWLINE> from os . path import join <NEWLINE> import sys <NEWLINE> from setuptools import setup , find_packages <NEWLINE> import bioframework <NEWLINE>
def download_image ( auction_id , img_link ) : <NEWLINE> <INDENT> if not os . path . exists ( <STRING> ) : <NEWLINE> <INDENT> os . system ( <STRING> ) <NEWLINE> <DEDENT> file_path = <STRING> + auction_id + <STRING> <NEWLINE> urlretrieve ( img_link , file_path ) <NEWLINE> return file_path <NEWLINE> <DEDENT>
def post ( path ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def decorator ( func ) : <NEWLINE> <INDENT> @ functools . wraps ( func ) <NEWLINE> def wrapper ( * args , ** kw ) : <NEWLINE> <INDENT> return func ( * args , ** kw ) <NEWLINE> <DEDENT> wrapper . __method__ = <STRING> <NEWLINE> wrapper . __path__ = path <NEWLINE> return wrapper <NEWLINE> <DEDENT> return decorator <NEWLINE> <DEDENT>
from django import forms <NEWLINE> from django . conf import settings <NEWLINE> from django . contrib import admin <NEWLINE> from . models import Category , Link <NEWLINE>
def _sigterm ( self , signum , frame ) : <NEWLINE> <INDENT> log . info ( <STRING> ) <NEWLINE> self . stop ( ) <NEWLINE> <DEDENT>
class CommentsAdmin ( admin . TabularInline ) : <NEWLINE> <INDENT> model = Comments <NEWLINE> extra = 3 <NEWLINE> <DEDENT>
def unregister_db_events ( self ) : <NEWLINE> <INDENT> self . _unregister_db_event ( model_base . StandardAttribute , <NEWLINE> <INDENT> <STRING> , self . _add_timestamp ) <NEWLINE> <DEDENT> self . _unregister_db_event ( se . Session , <STRING> , <NEWLINE> <INDENT> self . update_timestamp ) <NEWLINE> <DEDENT> <DEDENT>
def x ( a , b , * c ) : <NEWLINE> <INDENT> print ( <STRING> + str ( a ) ) <NEWLINE> print ( <STRING> + str ( b ) ) <NEWLINE> print ( <STRING> + str ( c ) ) <NEWLINE> print ( <STRING> + str ( c [ 0 ] ) ) <NEWLINE> <DEDENT>
from __future__ import division <NEWLINE> from sys import stdin , stdout <NEWLINE> import numpy as np <NEWLINE> from utils import * <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> k , t = ReadIntegers ( ) <NEWLINE> text_list = ReadAllLines ( ) <NEWLINE> motifs = BruteForceMedianString ( text_list , k ) <NEWLINE> PrintList ( <NEWLINE> <INDENT> motifs , <NEWLINE> <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
class Builder ( wayround_org . aipsetup . builder_scripts . std . Builder ) : <NEWLINE> <INDENT> def builder_action_configure_define_opts ( self , called_as , log ) : <NEWLINE> <INDENT> return super ( ) . builder_action_configure_define_opts ( called_as , log ) + [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def has_fit_parameter ( estimator , parameter ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return parameter in getargspec ( estimator . fit ) [ 0 ] <NEWLINE> <DEDENT>
def __init__ ( self ) : <NEWLINE> <INDENT> super ( Article , self ) . __init__ ( ) <NEWLINE> self . title = None <NEWLINE> self . author = None <NEWLINE> self . published = None <NEWLINE> self . body = None <NEWLINE> self . link = None <NEWLINE> <DEDENT>
def tryPlainGetPhoton ( p0 , pvar , start , seed ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for curndx in range ( start , len ( pvar ) ) : <NEWLINE> <INDENT> rnd = random . random ( ) <NEWLINE> if rnd < p0 : <NEWLINE> <INDENT> return 0 , curndx <NEWLINE> <DEDENT> if rnd < pvar [ curndx ] : <NEWLINE> <INDENT> return 1 , curndx <NEWLINE> <DEDENT> <DEDENT> return - 1 , len ( pvar ) <NEWLINE> <DEDENT>
class UserProfile ( models . Model ) : <NEWLINE> <INDENT> user = models . OneToOneField ( settings . AUTH_USER_MODEL , <NEWLINE> <INDENT> primary_key = True , related_name = <STRING> ) <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return self . user . username <NEWLINE> <DEDENT> class Meta : <NEWLINE> <INDENT> verbose_name = <STRING> <NEWLINE> verbose_name_plural = <STRING> <NEWLINE> db_table = <STRING> <NEWLINE> <DEDENT> <DEDENT>
def dispose ( self ) : <NEWLINE> <INDENT> self . stack . clear ( ) <NEWLINE> self . length . clear ( ) <NEWLINE> self . isDisposed = True <NEWLINE> <DEDENT>
from Products . CMFCore . utils import getToolByName <NEWLINE> import logging <NEWLINE> logger = logging . getLogger ( <STRING> ) <NEWLINE>
from django import forms <NEWLINE> from school_calendar . models import * <NEWLINE> from school_calendar . widgets import * <NEWLINE> from school_calendar . fields import * <NEWLINE> from dateutil import rrule <NEWLINE> DAY_CHOICES = ( <NEWLINE> <INDENT> ( MO , <STRING> ) , <NEWLINE> ( TU , <STRING> ) , <NEWLINE> ( WE , <STRING> ) , <NEWLINE> ( TH , <STRING> ) , <NEWLINE> ( FR , <STRING> ) , <NEWLINE> ( SA , <STRING> ) , <NEWLINE> ( SU , <STRING> ) , <NEWLINE> <DEDENT> ) <NEWLINE>
def setUp ( self ) : <NEWLINE> <INDENT> TestCase . setUp ( self ) <NEWLINE> self . jane = self . make_user ( <STRING> , group = <STRING> ) <NEWLINE> self . bob = self . make_user ( <STRING> , group = <STRING> ) <NEWLINE> self . brian = self . make_user ( <STRING> , group = <STRING> ) <NEWLINE> self . stacy = self . make_user ( <STRING> ) <NEWLINE> self . channel = self . make_channel ( self . stacy ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import sys <NEWLINE> if <STRING> in sys . argv : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> import PyQt5 <NEWLINE> pyqt = 5 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pyqt = 4 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pyqt = 4 <NEWLINE> <DEDENT> if pyqt == 4 : <NEWLINE> <INDENT> import sip <NEWLINE> sip . setapi ( <STRING> , 2 ) <NEWLINE> sip . setapi ( <STRING> , 2 ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> __RCSID__ = <STRING> <NEWLINE> import DIRAC <NEWLINE> from DIRAC . Core . Base import Script <NEWLINE> from DIRAC . Core . Security . ProxyInfo import getProxyInfo <NEWLINE> from DIRAC . ConfigurationSystem . Client . Helpers import cfgInstallPath , cfgPath , Resources , Registry <NEWLINE> import sys , os <NEWLINE> logLevel = None <NEWLINE> setup = None <NEWLINE> configurationServer = None <NEWLINE> includeAllServers = False <NEWLINE> gatewayServer = None <NEWLINE> siteName = None <NEWLINE> useServerCert = False <NEWLINE> skipCAChecks = False <NEWLINE> skipCADownload = False <NEWLINE> useVersionsDir = False <NEWLINE> architecture = None <NEWLINE> localSE = None <NEWLINE> ceName = None <NEWLINE> vo = None <NEWLINE> update = False <NEWLINE>
def test_count_frames ( self ) : <NEWLINE> <INDENT> f = inspect . currentframe ( ) <NEWLINE> frame_count = Mstack . count_frames ( f ) <NEWLINE> self . assertTrue ( Mstack . count_frames ( f ) > 2 ) <NEWLINE> self . assertEqual ( frame_count - 1 , Mstack . count_frames ( f . f_back ) ) <NEWLINE> self . assertEqual ( frame_count - 1 , Mstack . count_frames ( f , 1 ) ) <NEWLINE> return <NEWLINE> <DEDENT>
def load ( ) : <NEWLINE> <INDENT> allowed = [ hardware . name for hardware in opas . hardwares if hardware . driver . poynting_type is not None ] <NEWLINE> return len ( allowed ) > 0 <NEWLINE> <DEDENT>
def p_camkes ( t ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if len ( t ) == 1 : <NEWLINE> <INDENT> t [ 0 ] = [ ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> assert len ( t ) == 3 <NEWLINE> t [ 0 ] = t [ 1 ] + t [ 2 ] <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> barFeed = barfeed . CSVTradeFeed ( ) <NEWLINE> barFeed . addBarsFromCSV ( <STRING> , fromDateTime = datetime . datetime ( 2014 , 1 , 1 ) ) <NEWLINE> resample . resample_to_csv ( barFeed , bar . Frequency . MINUTE * 30 , <STRING> ) <NEWLINE> <DEDENT>
def mark ( h ) : <NEWLINE> <INDENT> title = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> p = <STRING> <NEWLINE> for i in title : <NEWLINE> <INDENT> p = p + <STRING> + i <NEWLINE> <DEDENT> p = p + <STRING> <NEWLINE> izq = <STRING> <NEWLINE> p = p + <STRING> + izq + izq + izq + izq + <STRING> <NEWLINE> for j in h : <NEWLINE> <INDENT> for i in j : <NEWLINE> <INDENT> p = p + <STRING> + str ( i ) <NEWLINE> <DEDENT> p = p + <STRING> + <STRING> <NEWLINE> <DEDENT> return p <NEWLINE> <DEDENT>
def conditional_entropy ( f1 , f2 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ce = ee . entropyd ( f1 ) - ee . midd ( f1 , f2 ) <NEWLINE> return ce <NEWLINE> <DEDENT>
def median ( a_list ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not a_list : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> sorted_list = sorted ( a_list ) <NEWLINE> list_size = len ( a_list ) <NEWLINE> index = ( list_size - 1 ) // 2 <NEWLINE> if ( list_size % 2 ) : <NEWLINE> <INDENT> return sorted_list [ index ] <NEWLINE> <DEDENT> return ( sorted_list [ index ] + sorted_list [ index + 1 ] ) / 2.0 <NEWLINE> <DEDENT>
def get_help_uri ( page = None ) : <NEWLINE> <INDENT> here = os . path . dirname ( __file__ ) <NEWLINE> help_uri = os . path . abspath ( os . path . join ( here , <STRING> , <STRING> , <STRING> ) ) <NEWLINE> if not os . path . exists ( help_uri ) : <NEWLINE> <INDENT> help_uri = <STRING> <NEWLINE> <DEDENT> if page is not None : <NEWLINE> <INDENT> help_uri = <STRING> % ( help_uri , page ) <NEWLINE> <DEDENT> return help_uri <NEWLINE> <DEDENT>
def disassociate ( self , host , group ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . _disassoc ( <STRING> , host , group ) <NEWLINE> <DEDENT>
def glInitS3TcS3 ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> from OpenGL import extensions <NEWLINE> return extensions . hasGLExtension ( _EXTENSION_NAME ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import json <NEWLINE> import logging <NEWLINE> import logging . config <NEWLINE> from ConfigParser import NoOptionError , SafeConfigParser <NEWLINE> from . . serializers import bind_prefix <NEWLINE>
<STRING> <NEWLINE> from sqlalchemy . orm import validates <NEWLINE> from sqlalchemy import Column , String <NEWLINE> from sqlalchemy . ext . declarative import declarative_base <NEWLINE> Base = declarative_base ( ) <NEWLINE>
class SSH101 ( Plugin ) : <NEWLINE> <INDENT> @ classmethod <NEWLINE> def can_handle_url ( self , url ) : <NEWLINE> <INDENT> return _url_re . match ( url ) <NEWLINE> <DEDENT> def _get_streams ( self ) : <NEWLINE> <INDENT> res = http . get ( self . url , schema = _live_schema ) <NEWLINE> if not res : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if res [ <STRING> ] == <STRING> and urlparse ( res [ <STRING> ] ) . path . endswith ( <STRING> ) : <NEWLINE> <INDENT> stream = HLSStream ( self . session , res [ <STRING> ] ) <NEWLINE> return dict ( hls = stream ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def __init__ ( self ) : <NEWLINE> <INDENT> super ( TemplateViewFactory , self ) . __init__ ( ) <NEWLINE> self . __parent_class_list = [ ] <NEWLINE> self . __form_class = None <NEWLINE> self . __model_class = None <NEWLINE> self . __generic_parent_class = None <NEWLINE> self . __exclude = [ ] <NEWLINE> self . __operation = <STRING> <NEWLINE> <DEDENT>
import unittest <NEWLINE> import os <NEWLINE> from scimap . xrdstore import XRDStore <NEWLINE> from cases import HDFTestCase <NEWLINE>
import sys <NEWLINE> import socket <NEWLINE> import struct <NEWLINE> import toml <NEWLINE> import SocketServer <NEWLINE>
from __future__ import print_function <NEWLINE> __all__ = [ <STRING> , <STRING> ] <NEWLINE> __docformat__ = <STRING> <NEWLINE> import math <NEWLINE> import numpy <NEWLINE> from pyctools . core . config import ConfigEnum , ConfigFloat , ConfigInt <NEWLINE> from pyctools . core . base import Transformer <NEWLINE> from pyctools . core . types import pt_float <NEWLINE>
def getIntersection ( keywords ) : <NEWLINE> <INDENT> fixed = [ ] <NEWLINE> for keyword in keywords : <NEWLINE> <INDENT> fixed . append ( keyFormat . format ( keyStringPrefix , keyword ) ) <NEWLINE> <DEDENT> return keywordRedisDB . sinter ( fixed ) <NEWLINE> <DEDENT>
class CollectionCreationTesting ( unittest . TestCase ) : <NEWLINE> <INDENT> def setUp ( self ) : <NEWLINE> <INDENT> gludb . config . default_database ( gludb . config . Database ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> conn_string = PG_CONN_STR <NEWLINE> <DEDENT> ) ) <NEWLINE> delete_test_tables ( ) <NEWLINE> <DEDENT> def tearDown ( self ) : <NEWLINE> <INDENT> delete_test_tables ( ) <NEWLINE> gludb . config . clear_database_config ( ) <NEWLINE> <DEDENT> def test_repeated_creates ( self ) : <NEWLINE> <INDENT> SimpleStorage . ensure_table ( ) <NEWLINE> SimpleStorage . ensure_table ( ) <NEWLINE> SimpleStorage . ensure_table ( ) <NEWLINE> IndexedData . ensure_table ( ) <NEWLINE> IndexedData . ensure_table ( ) <NEWLINE> IndexedData . ensure_table ( ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import tinctest <NEWLINE> import unittest2 as unittest <NEWLINE> from mpp . lib . config import GPDBConfig <NEWLINE> from mpp . lib . PSQL import PSQL <NEWLINE> from mpp . gpdb . tests . storage . walrepl . gpcrondump import BkupRestore <NEWLINE> from gppylib . commands . base import Command <NEWLINE> from mpp . gpdb . tests . storage . walrepl . gpinitstandby import GpinitStandby <NEWLINE> from mpp . gpdb . tests . storage . walrepl . gpactivatestandby import GpactivateStandby <NEWLINE> config = GPDBConfig ( ) <NEWLINE>
def handle_request ( module , session , parameter ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> func = module [ <STRING> ] <NEWLINE> signature = module [ <STRING> ] <NEWLINE> try : <NEWLINE> <INDENT> parameter = utils . validate_parameter ( signature , parameter ) <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> <INDENT> raise ParametersInvalid ( str ( e ) ) from None <NEWLINE> <DEDENT> return func ( session , parameter ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from __future__ import absolute_import , division , unicode_literals <NEWLINE> import string <NEWLINE> import sys <NEWLINE> import time <NEWLINE> from shinysdr . plugins import aprs <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> print ( string . rstrip ( line , <STRING> ) ) <NEWLINE> parsed = aprs . parse_tnc2 ( line , time . time ( ) ) <NEWLINE> for error in parsed . errors : <NEWLINE> <INDENT> print ( <STRING> , error ) <NEWLINE> <DEDENT> for fact in parsed . facts : <NEWLINE> <INDENT> print ( <STRING> , fact ) <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT> <DEDENT>
def get_song_urls ( self , page_num = 1 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> bsObj_list = self . _get_songs_BSObj ( page_num ) <NEWLINE> if bsObj_list is None : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> song_urls = [ ] <NEWLINE> for bsObj in bsObj_list : <NEWLINE> <INDENT> anchor = bsObj . find ( <STRING> , { <STRING> : <STRING> } ) <NEWLINE> if anchor is not None : <NEWLINE> <INDENT> url = anchor . attrs [ <STRING> ] <NEWLINE> if url is not None : <NEWLINE> <INDENT> song_urls += [ url ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return song_urls if len ( song_urls ) > 0 else None <NEWLINE> <DEDENT>
def load ( self , path ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return self . __resources [ path ] <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT>
import sys , os . path as path <NEWLINE> kroll_dir = path . join ( path . abspath ( <STRING> ) , <STRING> , <STRING> ) <NEWLINE> sys . path . append ( kroll_dir ) <NEWLINE> import kroll <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> parent_dir = os . path . dirname ( os . path . abspath ( __file__ ) ) <NEWLINE> sys . path . insert ( 0 , os . path . join ( parent_dir , <STRING> ) ) <NEWLINE> sys . path . insert ( 1 , os . path . join ( parent_dir , <STRING> ) ) <NEWLINE> os . environ [ <STRING> ] = <STRING> <NEWLINE> from django . conf import settings <NEWLINE> import django <NEWLINE>
class PistonHelpers : <NEWLINE> <INDENT> GET_REVIEWS = <STRING> <NEWLINE> GET_REVIEW_STATS = <STRING> <NEWLINE> GET_USEFUL_VOTES = <STRING> <NEWLINE> SOFTWARE_CENTER_AGENT = <STRING> <NEWLINE> <DEDENT>
__title__ = <STRING> <NEWLINE> __version__ = <STRING> <NEWLINE> __build__ = 0x000101 <NEWLINE> __author__ = <STRING> <NEWLINE> __copyright__ = <STRING> <NEWLINE> from . torte import Torte <NEWLINE>
def get_thread ( self , _id ) : <NEWLINE> <INDENT> for t in self . iter_threads ( ) : <NEWLINE> <INDENT> if t . id == _id : <NEWLINE> <INDENT> return t <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def isEmpty ( self , geom ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ogr . Geometry . IsEmpty <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if ( geom . IsEmpty ( ) == False ) : <NEWLINE> <INDENT> geom . Destroy ( ) <NEWLINE> gdaltest . post_reason ( <STRING> ) <NEWLINE> return <STRING> <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <DEDENT>
def _dropout_from_layer ( rng , layer , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> srng = theano . tensor . shared_randomstreams . RandomStreams ( <NEWLINE> <INDENT> rng . randint ( 999999 ) ) <NEWLINE> <DEDENT> mask = srng . binomial ( n = 1 , p = 1 - p , size = layer . shape ) <NEWLINE> output = layer * T . cast ( mask , theano . config . floatX ) <NEWLINE> return output <NEWLINE> <DEDENT>
class VertexModification ( object ) : <NEWLINE> <INDENT> def __init__ ( self , vertex_index , displacement ) : <NEWLINE> <INDENT> self . vertex_index = vertex_index <NEWLINE> self . displacement = displacement <NEWLINE> <DEDENT> <DEDENT>
def clear_buffer ( buffer ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> del buffer [ : ] <NEWLINE> <DEDENT>
class MyModel ( Model ) : <NEWLINE> <INDENT> obj = AdHocClass ( ) <NEWLINE> __observables__ = ( <STRING> , ) <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> Model . __init__ ( self ) <NEWLINE> return <NEWLINE> <DEDENT> pass <NEWLINE> <DEDENT>
from flask_restful import Resource <NEWLINE> from project . db import db , User <NEWLINE> from project . utils . auth import get_token , require_admin <NEWLINE> from sqlalchemy . exc import IntegrityError <NEWLINE> from project . utils . status import return_error , return_ok <NEWLINE> from . parsers import RegisterParser , LoginParser <NEWLINE>
def with_amex ( self ) : <NEWLINE> <INDENT> self . digesters . append ( AmexNotificationDigester ( self . new_charge_summary ) ) <NEWLINE> return self <NEWLINE> <DEDENT>
from consts import * <NEWLINE> from Button import Button <NEWLINE> from RawHTML import RawHTML <NEWLINE> from Container import Container <NEWLINE> from TextArea import TextArea <NEWLINE> from TextField import TextField <NEWLINE> from PageCleaner import Uniq_Block <NEWLINE> from Server import get_server <NEWLINE> HEADER = [ <STRING> ] <NEWLINE> HTML = <STRING> <NEWLINE> JS_INIT = <STRING> <NEWLINE> JS_FOCUS = <STRING> <NEWLINE>
def load_quotes_by_range ( self , code , start_date , end_date ) : <NEWLINE> <INDENT> idx_start = self . find_date_idx ( code , start_date ) <NEWLINE> idx_end = self . find_date_idx ( code , end_date ) + 1 <NEWLINE> return self . quote_range ( code , idx_start , idx_end ) <NEWLINE> <DEDENT>
def test_authorization_header_empty ( self , get_key_secret ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> request = Request ( self . environ ) <NEWLINE> request . authorization = <STRING> <NEWLINE> request . body = self . get_request_body ( ) <NEWLINE> response = self . xmodule . grade_handler ( request , <STRING> ) <NEWLINE> real_response = self . get_response_values ( response ) <NEWLINE> expected_response = { <NEWLINE> <INDENT> <STRING> : None , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : self . DEFAULTS [ <STRING> ] , <NEWLINE> <DEDENT> } <NEWLINE> self . assertEqual ( response . status_code , 200 ) <NEWLINE> self . assertDictEqual ( expected_response , real_response ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from misura . client import iutils , browser , live <NEWLINE> import multiprocessing <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> multiprocessing . freeze_support ( ) <NEWLINE> iutils . initApp ( ) <NEWLINE> live . registry . toggle_run ( False ) <NEWLINE> app = iutils . app <NEWLINE> mw = browser . MainWindow ( ) <NEWLINE> if len ( sys . argv ) > 1 : <NEWLINE> <INDENT> mw . open_file ( sys . argv [ 1 ] ) <NEWLINE> <DEDENT> mw . show ( ) <NEWLINE> sys . exit ( app . exec_ ( ) ) <NEWLINE> <DEDENT>
def ii_open_with_config_test ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print <NEWLINE> pic_owc = oiio . ImageInput . create ( <STRING> , plugin_path ) <NEWLINE> if pic_owc == None : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print <NEWLINE> return <NEWLINE> <DEDENT> spec_owc = oiio . ImageSpec ( ) <NEWLINE> <DEDENT>
class UrlEncoded ( validatorBase ) : <NEWLINE> <INDENT> def validate ( self ) : <NEWLINE> <INDENT> from urllib import quote , unquote <NEWLINE> import re <NEWLINE> for value in self . value . split ( ) : <NEWLINE> <INDENT> if type ( value ) == unicode : value = value . encode ( <STRING> ) <NEWLINE> value = re . sub ( <STRING> , lambda x : x . group ( 0 ) . upper ( ) , value ) <NEWLINE> if value != quote ( unquote ( value ) ) : <NEWLINE> <INDENT> self . log ( NotURLEncoded ( { } ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def test_add_group ( app , json_groups ) : <NEWLINE> <INDENT> group = json_groups <NEWLINE> old_groups = app . group . get_group_list ( ) <NEWLINE> app . group . create ( group ) <NEWLINE> assert len ( old_groups ) + 1 == app . group . count ( ) <NEWLINE> new_groups = app . group . get_group_list ( ) <NEWLINE> old_groups . append ( group ) <NEWLINE> assert sorted ( old_groups , key = Group . id_or_max ) == sorted ( new_groups , key = Group . id_or_max ) <NEWLINE> <DEDENT>
def entuple ( * args ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return tuple ( args ) <NEWLINE> <DEDENT>
i = 20 <NEWLINE> while i != 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> i -= 1 <NEWLINE> <DEDENT>
def test__validate_requests ( self ) : <NEWLINE> <INDENT> get_requests = self . get_securetrading_requests <NEWLINE> get_request = self . get_securetrading_request <NEWLINE> tests = [ ( [ ] , None , None ) , <NEWLINE> <INDENT> ( [ get_request ( { <STRING> : <STRING> } ) ] , None , None ) , <NEWLINE> ( [ { <STRING> : <STRING> } ] , AssertionError , <STRING> ) <NEWLINE> ] <NEWLINE> <DEDENT> for requests_list , exp_exception , exp_message in tests : <NEWLINE> <INDENT> if exp_exception is None : <NEWLINE> <INDENT> requests = get_requests ( requests_list ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . assertRaisesRegexp ( exp_exception , exp_message , <NEWLINE> <INDENT> get_requests , <NEWLINE> requests_list ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import json <NEWLINE> import time <NEWLINE> import os <NEWLINE> import base58 <NEWLINE> from stp_core . common . constants import ZMQ_NETWORK_PROTOCOL <NEWLINE> from stp_core . common . log import getlogger <NEWLINE> logger = getlogger ( ) <NEWLINE>
def setUpClass ( cls ) : <NEWLINE> <INDENT> handlers = { <NEWLINE> <INDENT> <STRING> : ( PDQHandler , ) , <NEWLINE> <STRING> : ( CustomArgsPDQHandler , True ) , <NEWLINE> <STRING> : ( ErrorHandler , ) <NEWLINE> <DEDENT> } <NEWLINE> cls . server , cls . thread = launch_server ( HOST , PORT , handlers ) <NEWLINE> <DEDENT>
class Item ( models . Model ) : <NEWLINE> <INDENT> title = models . CharField ( max_length = 255 ) <NEWLINE> content = models . TextField ( default = <STRING> ) <NEWLINE> owner = models . ForeignKey ( User , null = True ) <NEWLINE> publish_date = models . DateTimeField ( auto_now_add = True ) <NEWLINE> price = models . DecimalField ( max_digits = 7 , decimal_places = 2 ) <NEWLINE> contect_email = models . EmailField ( ) <NEWLINE> <DEDENT>
class Book ( models . Model ) : <NEWLINE> <INDENT> title = models . CharField ( max_length = 100 ) <NEWLINE> price = models . DecimalField ( max_digits = 6 , decimal_places = 2 ) <NEWLINE> average_rating = models . FloatField ( ) <NEWLINE> def __unicode__ ( self ) : <NEWLINE> <INDENT> return self . title <NEWLINE> <DEDENT> <DEDENT>
from . _delete import PaymentMethodDeleteView , ShippingMethodDeleteView <NEWLINE> from . _edit import PaymentMethodEditView , ShippingMethodEditView <NEWLINE> from . _list import PaymentMethodListView , ShippingMethodListView <NEWLINE> __all__ = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> <NEWLINE> <DEDENT> ] <NEWLINE>
from django . contrib . admin import SimpleListFilter <NEWLINE> from django . utils . translation import ugettext_lazy as _ <NEWLINE> from django . contrib . contenttypes . models import ContentType <NEWLINE> from efenua . models import Favorite <NEWLINE>
class Delegate : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , master ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> object . __setattr__ ( self , <STRING> , master ) <NEWLINE> <DEDENT> def __getattr__ ( self , name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return getattr ( self . master , name ) <NEWLINE> <DEDENT> def __setattr__ ( self , name , value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if hasattr ( self . master , name ) : <NEWLINE> <INDENT> return setattr ( self . master , name , value ) <NEWLINE> <DEDENT> return object . __setattr__ ( self , name , value ) <NEWLINE> <DEDENT> <DEDENT>
def uri ( x ) : <NEWLINE> <INDENT> y = int ( x ) <NEWLINE> for i in range ( 0 , 10 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i , y ) ) <NEWLINE> y *= 2 <NEWLINE> <DEDENT> <DEDENT>
