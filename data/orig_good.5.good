def dataIterator ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> batch_idx = 0 <NEWLINE> while True : <NEWLINE> <INDENT> idxs = np . arange ( 0 , len ( X_train ) ) <NEWLINE> np . random . shuffle ( idxs ) <NEWLINE> shuf_features = X_train [ idxs ] <NEWLINE> shuf_labels = y_train [ idxs ] <NEWLINE> for batch_idx in range ( 0 , len ( X_train ) , batch_size ) : <NEWLINE> <INDENT> features_batch = shuf_features [ batch_idx : batch_idx + batch_size ] <NEWLINE> features_batch = features_batch . astype ( <STRING> ) <NEWLINE> labels_batch = shuf_labels [ batch_idx : batch_idx + batch_size ] <NEWLINE> yield features_batch , labels_batch <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_installation ( ) : <NEWLINE> <INDENT> assert sys . version_info . major == 3 <NEWLINE> assert sys . version_info . minor >= 5 <NEWLINE> <DEDENT>
from appmain import appmain <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> appmain . show ( ) <NEWLINE> appmain . run ( ) <NEWLINE> <DEDENT>
import os <NEWLINE> import argparse <NEWLINE> from dtoolcore import DataSet <NEWLINE>
<STRING> <NEWLINE> from PyQt4 . QtGui import QFormLayout , QToolButton <NEWLINE> from ert_gui . ide . keywords . definitions import RangeStringArgument , ProperNameFormatStringArgument <NEWLINE> from ert_gui . models . connectors import EnsembleSizeModel <NEWLINE> from ert_gui . models . connectors . init import CaseSelectorModel <NEWLINE> from ert_gui . models . connectors . run import SensitivityStudy , ActiveRealizationsModel , RunPathModel , SensitivityTargetCaseFormatModel <NEWLINE> from ert_gui . simulation import SensitivityStudyParametersPanel <NEWLINE> from ert_gui . simulation . simulation_config_panel import SimulationConfigPanel <NEWLINE> from ert_gui . widgets import util <NEWLINE> from ert_gui . widgets . active_label import ActiveLabel <NEWLINE> from ert_gui . widgets . closable_dialog import ClosableDialog <NEWLINE> from ert_gui . widgets . combo_choice import ComboChoice <NEWLINE> from ert_gui . widgets . string_box import StringBox <NEWLINE>
def _validate_user_data ( self , user_data ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not user_data : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> base64 . b64decode ( user_data ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> expl = _ ( <STRING> ) <NEWLINE> raise exc . HTTPBadRequest ( explanation = expl ) <NEWLINE> <DEDENT> <DEDENT>
def commits_months ( period , authors ) : <NEWLINE> <INDENT> M = Matrix_empty ( 13 , len ( period ) ) <NEWLINE> M [ 0 ] = period <NEWLINE> for author in authors : <NEWLINE> <INDENT> for aux in author : <NEWLINE> <INDENT> M [ int ( aux [ 2 ] . month ) ] [ int ( aux [ 2 ] . year - date_min ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> return M <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from aquilon . worker . broker import BrokerCommand <NEWLINE> from aquilon . worker . commands . update_machine import CommandUpdateMachine <NEWLINE> from aquilon . worker . dbwrappers . host import hostname_to_host <NEWLINE>
from bluffinmuffin . protocol . enums import BluffinMessageIdEnum <NEWLINE> from bluffinmuffin . protocol . interfaces import AbstractResponse <NEWLINE> from . check_display_exist_command import CheckDisplayExistCommand <NEWLINE>
def find_best_stations ( needed , states ) : <NEWLINE> <INDENT> all_names = set ( ) <NEWLINE> while needed : <NEWLINE> <INDENT> joint = set ( ) <NEWLINE> saved = set ( ) <NEWLINE> names = None <NEWLINE> for name , serial in states . items ( ) : <NEWLINE> <INDENT> joint = serial & needed <NEWLINE> if len ( joint ) > len ( saved ) : <NEWLINE> <INDENT> saved = joint <NEWLINE> names = name <NEWLINE> <DEDENT> <DEDENT> if names != None : <NEWLINE> <INDENT> all_names . add ( names ) <NEWLINE> needed -= saved <NEWLINE> <DEDENT> <DEDENT> return all_names <NEWLINE> <DEDENT>
def get_content_field ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for field_name , field in self . fields . items ( ) : <NEWLINE> <INDENT> if field . document is True : <NEWLINE> <INDENT> return field . index_fieldname <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def backwards ( self , orm ) : <NEWLINE> <INDENT> db . delete_table ( <STRING> ) <NEWLINE> db . delete_table ( <STRING> ) <NEWLINE> db . delete_table ( db . shorten_name ( <STRING> ) ) <NEWLINE> db . delete_table ( db . shorten_name ( <STRING> ) ) <NEWLINE> db . delete_table ( <STRING> ) <NEWLINE> db . delete_table ( <STRING> ) <NEWLINE> db . delete_table ( <STRING> ) <NEWLINE> <DEDENT>
import argparse <NEWLINE> import numpy as np <NEWLINE> import pylab as plt <NEWLINE> from flowtools . datamaps import Spread <NEWLINE> from flowtools . draw import plot_line <NEWLINE> from flowtools . utils import calc_radius , combine_spread , get_colours , get_labels , get_linestyles , get_shift <NEWLINE>
<STRING> <NEWLINE> import re <NEWLINE> from pygments . lexer import RegexLexer , default <NEWLINE> from pygments . token import Text , Comment , Keyword , Name , Literal <NEWLINE> __all__ = [ <STRING> ] <NEWLINE>
<STRING> <NEWLINE> import os <NEWLINE> import itertools <NEWLINE> import numpy as np <NEWLINE> from ipyrad . assemble . util import IPyradWarningExit , AMBIGS <NEWLINE> BASE2IDX = { <NEWLINE> <INDENT> <STRING> : 0 , <NEWLINE> <STRING> : 1 , <NEWLINE> <STRING> : 2 , <NEWLINE> <STRING> : 3 , <NEWLINE> <DEDENT> } <NEWLINE> HEADER = <STRING> <NEWLINE>
from __future__ import unicode_literals <NEWLINE> import binascii <NEWLINE> import base64 <NEWLINE> import hashlib <NEWLINE> import re <NEWLINE> import json <NEWLINE> from . common import InfoExtractor <NEWLINE> from . . compat import ( <NEWLINE> <INDENT> compat_ord , <NEWLINE> compat_urllib_parse , <NEWLINE> compat_urllib_parse_unquote , <NEWLINE> <DEDENT> ) <NEWLINE> from . . utils import ( <NEWLINE> <INDENT> ExtractorError , <NEWLINE> sanitized_Request , <NEWLINE> <DEDENT> ) <NEWLINE>
from __future__ import print_function <NEWLINE> from WindowsWifi import getWirelessInterfaces <NEWLINE> from WindowsWifi import getWirelessProfiles <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> ifaces = getWirelessInterfaces ( ) <NEWLINE> for iface in ifaces : <NEWLINE> <INDENT> print ( iface ) <NEWLINE> guid = iface . guid <NEWLINE> profiles = getWirelessProfiles ( iface ) <NEWLINE> print ( <STRING> ) <NEWLINE> for profile in profiles : <NEWLINE> <INDENT> print ( profile ) <NEWLINE> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class Migration ( migrations . Migration ) : <NEWLINE> <INDENT> dependencies = [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE> operations = [ <NEWLINE> <INDENT> migrations . AddField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> field = models . CharField ( default = 1 , unique = True , max_length = 50 ) , <NEWLINE> preserve_default = False , <NEWLINE> <DEDENT> ) , <NEWLINE> migrations . AlterField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> field = models . CharField ( max_length = 50 ) , <NEWLINE> <DEDENT> ) , <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT>
def deserialize ( self ) : <NEWLINE> <INDENT> request = self . get_django_request ( ) <NEWLINE> return { <STRING> : request . POST , <NEWLINE> <INDENT> <STRING> : request . FILES , } <NEWLINE> <DEDENT> <DEDENT>
def run_command ( self , command ) : <NEWLINE> <INDENT> proc = subprocess . Popen ( command , <NEWLINE> <INDENT> shell = True , <NEWLINE> stdout = subprocess . PIPE , <NEWLINE> stderr = subprocess . PIPE ) <NEWLINE> <DEDENT> out , err = proc . communicate ( ) <NEWLINE> if err : <NEWLINE> <INDENT> logger . error ( <STRING> % <NEWLINE> <INDENT> ( command , err ) ) <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT> return out <NEWLINE> <DEDENT>
import mlt <NEWLINE> from PIL import Image <NEWLINE> mlt . Factory . init ( ) <NEWLINE> profile = mlt . Profile ( ) <NEWLINE> prod = mlt . Producer ( profile , <STRING> ) <NEWLINE> size = ( 320 , 240 ) <NEWLINE> for i in range ( 0 , prod . get_length ( ) ) : <NEWLINE> <INDENT> frm = prod . get_frame ( ) <NEWLINE> wav = mlt . frame_get_waveform ( frm , size [ 0 ] , size [ 1 ] ) <NEWLINE> img = Image . fromstring ( <STRING> , size , wav ) <NEWLINE> img . save ( <STRING> % ( i ) ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> __author__ = <STRING> <NEWLINE> import atom . data <NEWLINE> import gdata . apps <NEWLINE> import gdata . apps . apps_property_entry <NEWLINE> import gdata . apps_property <NEWLINE> import gdata . data <NEWLINE> pyproperty = property <NEWLINE> GROUP_ID = <STRING> <NEWLINE> GROUP_NAME = <STRING> <NEWLINE> DESCRIPTION = <STRING> <NEWLINE> EMAIL_PERMISSION = <STRING> <NEWLINE> MEMBER_ID = <STRING> <NEWLINE> MEMBER_TYPE = <STRING> <NEWLINE> DIRECT_MEMBER = <STRING> <NEWLINE>
def get_word_features ( all_words ) : <NEWLINE> <INDENT> wordlist = nltk . FreqDist ( all_words ) <NEWLINE> word_features = wordlist . keys ( ) <NEWLINE> return word_features <NEWLINE> <DEDENT>
class User ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , nome , email , password , id = id ) : <NEWLINE> <INDENT> self . nome = nome <NEWLINE> self . email = email <NEWLINE> self . password = convert_md5 ( password ) <NEWLINE> self . id = id <NEWLINE> <DEDENT> <DEDENT>
def python_help ( help_string ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> needle = help_string <NEWLINE> if needle . startswith ( <STRING> ) and needle . endswith ( <STRING> ) : <NEWLINE> <INDENT> needle = needle [ 1 : - 1 ] <NEWLINE> <DEDENT> elif needle . startswith ( <STRING> ) and needle . endswith ( <STRING> ) : <NEWLINE> <INDENT> needle = needle [ 1 : - 1 ] <NEWLINE> <DEDENT> help ( needle ) <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> <INDENT> print ( e ) <NEWLINE> sys . stderr . write ( <STRING> ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
def pytest_collect_file ( parent , path ) : <NEWLINE> <INDENT> if ( path . ext == <STRING> <NEWLINE> <INDENT> and NATIVE_TESTS in path . dirname + os . sep <NEWLINE> and path . basename != <STRING> <NEWLINE> and not ( <STRING> in path . basename and not PY3 ) <NEWLINE> and not ( <STRING> in path . basename and not PY35 ) ) : <NEWLINE> m = _pytest . python . pytest_pycollect_makemodule ( path , parent ) <NEWLINE> m . name = m . name [ : - len ( <STRING> ) ] + <STRING> <NEWLINE> return m <NEWLINE> <DEDENT> <DEDENT>
from __future__ import unicode_literals <NEWLINE> import random <NEWLINE> import re <NEWLINE> from . common import InfoExtractor <NEWLINE> from . . compat import compat_str <NEWLINE> from . . utils import ( <NEWLINE> <INDENT> determine_ext , <NEWLINE> float_or_none , <NEWLINE> parse_age_limit , <NEWLINE> qualities , <NEWLINE> try_get , <NEWLINE> unified_timestamp , <NEWLINE> urljoin , <NEWLINE> <DEDENT> ) <NEWLINE>
import os <NEWLINE> from modularodm import Q <NEWLINE> from modularodm . exceptions import ModularOdmException <NEWLINE> from framework . auth . core import User <NEWLINE> from website import settings <NEWLINE> from website . app import init_app <NEWLINE> from website . conferences . model import Conference <NEWLINE>
def restoreIpAddresses ( self , s ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> cand = [ ] <NEWLINE> self . restore_ip ( s , cand , res ) <NEWLINE> return res <NEWLINE> <DEDENT>
def upgrade ( ) : <NEWLINE> <INDENT> op . get_bind ( ) <NEWLINE> op . execute ( <STRING> ) <NEWLINE> op . alter_column ( <STRING> , <STRING> , nullable = False ) <NEWLINE> <DEDENT>
def main ( argv ) : <NEWLINE> <INDENT> _ , device , command = argv <NEWLINE> import serial <NEWLINE> arduino = Arduino ( serial . Serial ( device , 9600 ) ) <NEWLINE> print ( arduino . send ( command . encode ( <STRING> ) ) ) <NEWLINE> <DEDENT>
def control_verification_request ( self , params = None , ** kwargs ) : <NEWLINE> <INDENT> warnings . warn ( <STRING> , DeprecationWarning , stacklevel = 2 ) <NEWLINE> return self . post ( self . api_host , <STRING> , params or kwargs ) <NEWLINE> <DEDENT>
def __init__ ( self , data , cols = COLUMNS , max_field_size = MAX_FIELD_SIZE ) : <NEWLINE> <INDENT> self . cols = cols <NEWLINE> self . max_field_size = max_field_size <NEWLINE> self . data = data <NEWLINE> <DEDENT>
def forwards ( apps , schema_editor ) : <NEWLINE> <INDENT> from autoslug . settings import slugify <NEWLINE> Deck = apps . get_model ( <STRING> , <STRING> ) <NEWLINE> for deck in Deck . objects . all ( ) . iterator ( ) : <NEWLINE> <INDENT> deck . slug = slugify ( deck . name ) <NEWLINE> deck . save ( update_fields = [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT>
def test_len_collection ( self ) : <NEWLINE> <INDENT> first_feed = next ( self . _container . itervalues ( ) ) <NEWLINE> collection = first_feed . OpenCollection ( ) <NEWLINE> with RequestsMock ( ) as rsp : <NEWLINE> <INDENT> rsp . add ( rsp . GET , re . compile ( <STRING> ) , <NEWLINE> <INDENT> json = json_count ( collection . name ) , match_querystring = True ) <NEWLINE> <DEDENT> len_collection = len ( collection ) <NEWLINE> <DEDENT> self . assertEqual ( len_collection , NUM_TEST_POINTS ) <NEWLINE> <DEDENT>
def hilite ( string , bold ) : <NEWLINE> <INDENT> attr = [ ] <NEWLINE> attr . append ( <STRING> ) <NEWLINE> if bold : <NEWLINE> <INDENT> attr . append ( <STRING> ) <NEWLINE> <DEDENT> return <STRING> % ( <STRING> . join ( attr ) , string ) <NEWLINE> <DEDENT>
from socket import socket , AF_INET , SOCK_DGRAM <NEWLINE> from optparse import OptionParser <NEWLINE> from time import time <NEWLINE>
import logging <NEWLINE> import re <NEWLINE> from webkitpy . common . host import Host <NEWLINE> from webkitpy . common . webkit_finder import WebKitFinder <NEWLINE> from HTMLParser import HTMLParser <NEWLINE> _log = logging . getLogger ( __name__ ) <NEWLINE>
class CampListView ( ListView ) : <NEWLINE> <INDENT> allow_empty = True <NEWLINE> model = Camp <NEWLINE> template_name = <STRING> <NEWLINE> <DEDENT>
def handle_result ( self , parseResult ) : <NEWLINE> <INDENT> for member in self . get_hostgroup ( ) . get_members ( ) : <NEWLINE> <INDENT> for failKey , pingResult in parseResult . items ( ) : <NEWLINE> <INDENT> for task in member . get_tasks ( ) : <NEWLINE> <INDENT> if failKey == task . get_task_type ( ) : <NEWLINE> <INDENT> task . _execute ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
class ClassFactory ( object ) : <NEWLINE> <INDENT> def instance ( self ) : <NEWLINE> <INDENT> return Class ( attribute_1 = <STRING> , attribute_2 = <STRING> , attribute_3 = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import pyeapi <NEWLINE> import json <NEWLINE> from pprint import pprint <NEWLINE> pynet_sw3 = pyeapi . connect_to ( <STRING> ) <NEWLINE> result = pynet_sw3 . enable ( <STRING> ) <NEWLINE> parse = result [ 0 ] [ <STRING> ] <NEWLINE> interfaces = parse [ <STRING> ] <NEWLINE> for i in interfaces : <NEWLINE> <INDENT> print ( <STRING> + i ) <NEWLINE> counters = interfaces [ i ] [ <STRING> ] <NEWLINE> print ( <STRING> + str ( counters [ <STRING> ] ) ) <NEWLINE> print ( <STRING> + str ( counters [ <STRING> ] ) ) <NEWLINE> <DEDENT>
from evoque . api import hooks <NEWLINE> app = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : [ <STRING> ] , <NEWLINE> <STRING> : False , <NEWLINE> <STRING> : [ <NEWLINE> <INDENT> hooks . ContextHook ( ) , <NEWLINE> hooks . RPCHook ( ) , <NEWLINE> <DEDENT> ] , <NEWLINE> <STRING> : [ <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> ] , <NEWLINE> <DEDENT> } <NEWLINE>
<STRING> <NEWLINE> __author__ = <STRING> <NEWLINE> __date__ = <STRING> <NEWLINE> __copyright__ = ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> import unittest <NEWLINE> import os <NEWLINE> import qgis <NEWLINE> from PyQt4 . QtGui import QDialogButtonBox <NEWLINE> from safe . gui . tools . shake_grid . shakemap_converter_dialog import ( <NEWLINE> <INDENT> ShakemapConverterDialog ) <NEWLINE> <DEDENT> from safe . common . utilities import unique_filename , temp_dir <NEWLINE> from safe . test . utilities import standard_data_path , get_qgis_app , TESTDATA <NEWLINE> QGIS_APP , CANVAS , IFACE , PARENT = get_qgis_app ( ) <NEWLINE>
def readdict ( fin ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> retDict = { } <NEWLINE> fin . next ( ) <NEWLINE> for [ uid , cid , edate ] in fin : <NEWLINE> <INDENT> retDict [ uid ] = course_enrollment ( uid , cid , edate ) <NEWLINE> <DEDENT> return retDict <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import trac . core <NEWLINE> import trac . wiki <NEWLINE> import trac . wiki . macros <NEWLINE> from genshi . builder import tag <NEWLINE> import genshi . core <NEWLINE> import uuid <NEWLINE> import StringIO <NEWLINE> ARROW_RIGHT = <STRING> <NEWLINE> ARROW_DOWN = <STRING> <NEWLINE>
import guiClass <NEWLINE> app = guiClass . GUI ( ) <NEWLINE> app . version = <STRING> <NEWLINE> app . appVer = 0.94 <NEWLINE> app . appUrl = <STRING> <NEWLINE> app . gitUrl = <STRING> <NEWLINE> app . feedUrl = <STRING> <NEWLINE> app . run ( ) <NEWLINE>
def process_stop ( self , address , stop , verbose , mode = <STRING> ) : <NEWLINE> <INDENT> if verbose : <NEWLINE> <INDENT> print ( <STRING> . <NEWLINE> <INDENT> format ( stop . latitude , stop . longitude , stop . id ) ) <NEWLINE> <DEDENT> <DEDENT> result = self . wrapper . get_distance_from_api ( address , stop , mode ) <NEWLINE> if verbose : <NEWLINE> <INDENT> print ( <STRING> . format ( result [ <STRING> ] , <NEWLINE> <INDENT> result [ <STRING> ] ) ) <NEWLINE> <DEDENT> <DEDENT> self . handler . add_route ( address . id , <NEWLINE> <INDENT> stop . id , <NEWLINE> result [ <STRING> ] , <NEWLINE> result [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT>
def url_rewritable ( self , task , entry ) : <NEWLINE> <INDENT> if entry [ <STRING> ] . startswith ( <STRING> ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if entry [ <STRING> ] . startswith ( <STRING> ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from sqlalchemy import and_ <NEWLINE> from sqlalchemy import case <NEWLINE> from sqlalchemy import literal <NEWLINE> from sqlalchemy import or_ <NEWLINE> from sqlalchemy . orm import aliased <NEWLINE> from sqlalchemy . sql import func <NEWLINE> from ggrc import db <NEWLINE> from ggrc . models . relationship import Relationship <NEWLINE>
def siteinfo ( request ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> siteinfo = SiteInformation . objects . get ( pk = 1 ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> siteinfo = <STRING> <NEWLINE> <DEDENT> return { <STRING> : siteinfo } <NEWLINE> <DEDENT>
def __init__ ( self , module ) : <NEWLINE> <INDENT> self . module = module <NEWLINE> self . state = module . params [ <STRING> ] <NEWLINE> self . name = module . params [ <STRING> ] <NEWLINE> self . gid = module . params [ <STRING> ] <NEWLINE> self . system = module . params [ <STRING> ] <NEWLINE> <DEDENT>
def Variable ( data , * args , ** kwargs ) : <NEWLINE> <INDENT> var = autograd . Variable ( data , * args , ** kwargs ) <NEWLINE> if USE_CUDA : <NEWLINE> <INDENT> var = var . cuda ( ) <NEWLINE> <DEDENT> return var <NEWLINE> <DEDENT>
def raw_entry ( word ) : <NEWLINE> <INDENT> word_range = ( 0 , len ( word ) ) <NEWLINE> dictionary_result = DCSCopyTextDefinition ( None , word , word_range ) <NEWLINE> if not dictionary_result : <NEWLINE> <INDENT> print ( <STRING> . format ( word ) ) <NEWLINE> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return dictionary_result <NEWLINE> <DEDENT> <DEDENT>
def testGET ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> MyHTTPHandler . get = echo_path_get <NEWLINE> http = httpclass . HTTPClient ( ) <NEWLINE> path = <STRING> <NEWLINE> url = <STRING> % ( BASEHOST , BASEPORT , path ) <NEWLINE> req = http . GET ( url ) <NEWLINE> self . assertTrue ( req != None , <STRING> ) <NEWLINE> self . assertTrue ( req . code == 200 ) <NEWLINE> self . assertTrue ( req . body . find ( path ) >= 0 , <STRING> % req . body ) <NEWLINE> <DEDENT>
class World : <NEWLINE> <INDENT> <STRING> <NEWLINE> EXIT = <STRING> <NEWLINE> <STRING> <NEWLINE> CAVE = <STRING> <NEWLINE> <STRING> <NEWLINE> EMPTY = <STRING> <NEWLINE> <STRING> <NEWLINE> <DEDENT>
from itertools import tee <NEWLINE> from cryptotools . xor import xor_bytes <NEWLINE> from cryptotools . cipher . block import blockify <NEWLINE>
def get_largest_area ( reg_props ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> a = [ _x [ <STRING> ] for _x in reg_props ] <NEWLINE> l = [ _x [ <STRING> ] for _x in reg_props ] <NEWLINE> i = np . argmax ( a ) <NEWLINE> return a [ i ] , l [ i ] <NEWLINE> <DEDENT>
import glob <NEWLINE> import itertools <NEWLINE> import json <NEWLINE> import operator <NEWLINE> import os <NEWLINE> from mako . template import Template <NEWLINE> from openerp . modules import module <NEWLINE> from . main import module_topological_sort <NEWLINE> from . . import http <NEWLINE> NOMODULE_TEMPLATE = Template ( <STRING> ) <NEWLINE> NOTFOUND = Template ( <STRING> ) <NEWLINE> TESTING = Template ( <STRING> ) <NEWLINE>
def has_handler ( self , handler_name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return handler_name in self . _handlers <NEWLINE> <DEDENT>
def conv_bn_dr ( net , num_filt , dr , k = 3 ) : <NEWLINE> <INDENT> net = conv_bn ( net , num_filt , k ) <NEWLINE> return l . Dropout ( dr ) ( net ) <NEWLINE> <DEDENT>
class Constants ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> API_URL = <STRING> <NEWLINE> VERSION = <STRING> <NEWLINE> IG_SIG_KEY = <STRING> <NEWLINE> EXPERIMENTS = <STRING> <NEWLINE> LOGIN_EXPERIMENTS = <STRING> <NEWLINE> SIG_KEY_VERSION = <STRING> <NEWLINE> ANDROID_VERSION = 18 <NEWLINE> ANDROID_RELEASE = <STRING> <NEWLINE> <DEDENT>
__revision__ = <STRING> <NEWLINE> import TestSCons <NEWLINE> test = TestSCons . TestSCons ( ) <NEWLINE> test . write ( <STRING> , <STRING> ) <NEWLINE> test . run ( arguments = <STRING> , <NEWLINE> <INDENT> stderr = <STRING> , <NEWLINE> status = 2 ) <NEWLINE> <DEDENT> test . run ( arguments = <STRING> , <NEWLINE> <INDENT> stderr = <STRING> , <NEWLINE> status = 2 ) <NEWLINE> <DEDENT> test . pass_test ( ) <NEWLINE>
def _dense ( attrs ) : <NEWLINE> <INDENT> op_name , new_attrs = <STRING> , { } <NEWLINE> new_attrs [ <STRING> ] = _required_attr ( attrs , <STRING> ) <NEWLINE> new_attrs [ <STRING> ] = not _parse_bool_str ( attrs , <STRING> ) <NEWLINE> major , minor , micro = _get_mxnet_version ( ) <NEWLINE> if major >= 0 and minor >= 11 and micro >= 1 : <NEWLINE> <INDENT> new_attrs [ <STRING> ] = _parse_bool_str ( attrs , <STRING> , <STRING> ) <NEWLINE> <DEDENT> return op_name , new_attrs <NEWLINE> <DEDENT>
class IfOperStatusIfTable ( SnmpTable ) : <NEWLINE> <INDENT> def table_names ( self ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> def ifOperStatus_translator ( self , snmp_dict ) : <NEWLINE> <INDENT> self . data = { } <NEWLINE> for x in snmp_dict [ <STRING> ] : <NEWLINE> <INDENT> self . data [ int ( x . iid ) ] = self . normalize ( x ) <NEWLINE> <DEDENT> <DEDENT> def py_obj ( self ) : <NEWLINE> <INDENT> return self . data <NEWLINE> <DEDENT> <DEDENT>
def check_request_method ( method ) : <NEWLINE> <INDENT> if method . upper ( ) != <STRING> : <NEWLINE> <INDENT> return 500 <NEWLINE> <DEDENT> <DEDENT>
def config_setup ( ) : <NEWLINE> <INDENT> config = Config ( ) <NEWLINE> config . trace_filter = GlobbingFilter ( include = [ <STRING> ] ) <NEWLINE> return config <NEWLINE> <DEDENT>
class Solution : <NEWLINE> <INDENT> <STRING> <NEWLINE> def isValidBST ( self , root ) : <NEWLINE> <INDENT> def validate ( bst , mini , maxi ) : <NEWLINE> <INDENT> if ( bst is None ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if ( bst . val <= mini or bst . val >= maxi ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> isLeftValid = validate ( bst . left , mini , bst . val ) <NEWLINE> isRightValid = validate ( bst . right , bst . val , maxi ) <NEWLINE> return isLeftValid and isRightValid <NEWLINE> <DEDENT> return validate ( root , - sys . maxsize - 1 , sys . maxsize ) <NEWLINE> <DEDENT> <DEDENT>
def checar ( cliente_sat ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> resposta = cliente_sat . consultar_status_operacional ( ) <NEWLINE> alertas = [ ] <NEWLINE> for classe_alerta in AlertaOperacao . alertas_registrados : <NEWLINE> <INDENT> alerta = classe_alerta ( resposta ) <NEWLINE> if alerta . checar ( ) : <NEWLINE> <INDENT> alertas . append ( alerta ) <NEWLINE> <DEDENT> <DEDENT> return alertas <NEWLINE> <DEDENT>
def _check_recursion ( self , cr , uid , ids , context = None ) : <NEWLINE> <INDENT> level = 100 <NEWLINE> while len ( ids ) : <NEWLINE> <INDENT> cr . execute ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> ( tuple ( ids ) , ) <NEWLINE> <DEDENT> ) <NEWLINE> ids = filter ( None , map ( lambda x : x [ 0 ] , cr . fetchall ( ) ) ) <NEWLINE> if not level : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> level -= 1 <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT>
class FluentdHttpIntegration ( Integration ) : <NEWLINE> <INDENT> def __init__ ( self , fluentd_http_url ) : <NEWLINE> <INDENT> self . fluentd_http_url = fluentd_http_url <NEWLINE> <DEDENT> def after_function ( self , func_name , args , kwargs , result ) : <NEWLINE> <INDENT> status_code = requests . post ( <NEWLINE> <INDENT> self . fluentd_http_url , <NEWLINE> data = json . dumps ( { <NEWLINE> <INDENT> <STRING> : func_name , <NEWLINE> <STRING> : args , <NEWLINE> <STRING> : kwargs , <NEWLINE> <STRING> : result <NEWLINE> <DEDENT> } ) <NEWLINE> <DEDENT> ) . status_code <NEWLINE> if status_code >= 400 : <NEWLINE> <INDENT> sys . stderr . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def store ( path , l ) : <NEWLINE> <INDENT> f = open ( path , <STRING> ) <NEWLINE> for w in l : <NEWLINE> <INDENT> w = <STRING> % w <NEWLINE> f . write ( w . encode ( <STRING> ) ) <NEWLINE> <DEDENT> f . close ( ) <NEWLINE> <DEDENT>
def Goal ( self ) : <NEWLINE> <INDENT> if self . lex . token in [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> val = self . Expr ( ) <NEWLINE> self . lex . match ( <STRING> ) <NEWLINE> print ( val ) <NEWLINE> <DEDENT> elif self . lex . token == <STRING> : <NEWLINE> <INDENT> self . Assign ( ) <NEWLINE> self . lex . match ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise SyntaxError ( ) <NEWLINE> <DEDENT> <DEDENT>
def check_changed ( self , new_params ) : <NEWLINE> <INDENT> if self . check_exists ( ) : <NEWLINE> <INDENT> old_params = self . get_params ( ) <NEWLINE> if <STRING> not in old_params : <NEWLINE> <INDENT> old_params [ <STRING> ] = <STRING> <NEWLINE> <DEDENT> if <STRING> not in old_params : <NEWLINE> <INDENT> old_params [ <STRING> ] = <STRING> <NEWLINE> <DEDENT> return old_params [ <STRING> ] != new_params [ <STRING> ] or old_params [ <STRING> ] != new_params [ <STRING> ] or old_params [ <STRING> ] != new_params [ <STRING> ] or old_params [ <STRING> ] != new_params [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import operator <NEWLINE> from django . db import router <NEWLINE> from django . db . models . fields import BLANK_CHOICE_DASH <NEWLINE> from django . contrib . auth . models import AnonymousUser <NEWLINE> from taggit . managers import TaggableManager , _TaggableManager <NEWLINE> from taggit . models import GenericTaggedItemBase , Tag <NEWLINE> from taggit . utils import edit_string_for_tags , require_instance_manager <NEWLINE>
def allow_all_perms_policy ( wbrequest ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return Perms ( ) <NEWLINE> <DEDENT>
def __init__ ( self , path , listeners ) : <NEWLINE> <INDENT> self . cs = None <NEWLINE> self . listeners = listeners <NEWLINE> inputFile = open ( path ) <NEWLINE> try : <NEWLINE> <INDENT> for line in inputFile : <NEWLINE> <INDENT> self . parseLine ( line ) <NEWLINE> <DEDENT> <DEDENT> finally : <NEWLINE> <INDENT> inputFile . close ( ) <NEWLINE> <DEDENT> for listener in self . listeners : <NEWLINE> <INDENT> listener . finishGroup ( ) <NEWLINE> <DEDENT> <DEDENT>
def on_access ( self ) : <NEWLINE> <INDENT> self . _current_access_list = self . cards_to_access ( ) <NEWLINE> self . _current_rnd_access_list = self . rnd_cards_to_access ( ) <NEWLINE> self . game . register_choice_provider ( <NEWLINE> <INDENT> timing_phases . ApproachServer_4_5 , self , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def __set__ ( self , obj , value ) : <NEWLINE> <INDENT> if self . setter : <NEWLINE> <INDENT> if self . cast_to : <NEWLINE> <INDENT> setattr ( _CastTo ( obj . __dict__ [ self . zos_interface_attr ] , self . cast_to ) , self . property_name , value ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> setattr ( obj . __dict__ [ self . zos_interface_attr ] , self . property_name , value ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> raise AttributeError ( <STRING> . format ( self . property_name ) ) <NEWLINE> <DEDENT> <DEDENT>
def get_description_custom ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . game_dict : <NEWLINE> <INDENT> desc = self . game_dict . get ( <STRING> , <STRING> ) [ 0 : self . short ] <NEWLINE> _cut = int ( <NEWLINE> <INDENT> ( len ( desc ) - <NEWLINE> <INDENT> len ( desc . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) ) ) <NEWLINE> <DEDENT> / 2 + self . short ) <NEWLINE> <DEDENT> desc = self . game_dict . get ( <STRING> , <STRING> ) [ 0 : _cut ] <NEWLINE> return desc [ 0 : - 3 ] + <STRING> <NEWLINE> <DEDENT> <DEDENT>
def loadSettings ( self ) : <NEWLINE> <INDENT> s = QSettings ( ) <NEWLINE> s . beginGroup ( <STRING> ) <NEWLINE> roman = s . value ( <STRING> , <STRING> , str ) <NEWLINE> self . romanCombo . setCurrentFont ( QFont ( roman ) ) <NEWLINE> sans = s . value ( <STRING> , <STRING> , str ) <NEWLINE> self . sansCombo . setCurrentFont ( QFont ( sans ) ) <NEWLINE> typewriter = s . value ( <STRING> , <STRING> , str ) <NEWLINE> self . typewriterCombo . setCurrentFont ( QFont ( typewriter ) ) <NEWLINE> <DEDENT>
def has_plugin_permission ( user , plugin_type , permission_type ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> from cms . plugin_pool import plugin_pool <NEWLINE> plugin_class = plugin_pool . get_plugin ( plugin_type ) <NEWLINE> plugin_model = plugin_class . model <NEWLINE> plugin_opts = plugin_model . _meta <NEWLINE> return user . has_perm ( <STRING> % ( plugin_opts . app_label , permission_type , <NEWLINE> <INDENT> plugin_opts . object_name . lower ( ) ) ) <NEWLINE> <DEDENT> <DEDENT>
def __load_rom_content ( self , filename ) : <NEWLINE> <INDENT> fd = open ( filename , <STRING> ) <NEWLINE> i = 0 <NEWLINE> for line in fd : <NEWLINE> <INDENT> temp_data = line . split ( ) <NEWLINE> for t in temp_data : <NEWLINE> <INDENT> self . __data [ i ] = int ( t , 16 ) <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class PerfilForm ( ModelForm ) : <NEWLINE> <INDENT> class Meta : <NEWLINE> <INDENT> model = Perfil <NEWLINE> widgets = { <NEWLINE> <INDENT> <STRING> : Textarea ( attrs = { <STRING> : 20 , <STRING> : 5 } ) <NEWLINE> } <NEWLINE> <DEDENT> fields = [ <STRING> , <STRING> ] <NEWLINE> <DEDENT> <DEDENT>
class Whitewater ( FixtureTest ) : <NEWLINE> <INDENT> def test_put_in_egress ( self ) : <NEWLINE> <INDENT> self . load_fixtures ( [ <STRING> ] ) <NEWLINE> self . assert_has_feature ( <NEWLINE> <INDENT> 16 , 19591 , 23939 , <STRING> , <NEWLINE> { <STRING> : <STRING> } ) <NEWLINE> <DEDENT> <DEDENT> def test_portage_way ( self ) : <NEWLINE> <INDENT> self . load_fixtures ( [ <STRING> ] ) <NEWLINE> self . assert_has_feature ( <NEWLINE> <INDENT> 13 , 2448 , 2992 , <STRING> , <NEWLINE> { <STRING> : <STRING> } ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def retrieve_data ( target ) : <NEWLINE> <INDENT> url , values , path = target <NEWLINE> req_data = urllib . urlencode ( values ) <NEWLINE> req = urllib2 . Request ( url , req_data ) <NEWLINE> response = urllib2 . urlopen ( req ) <NEWLINE> data = response . read ( ) <NEWLINE> if not data : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> data = data . strip ( ) <NEWLINE> data = data . replace ( <STRING> , <STRING> ) <NEWLINE> if data : <NEWLINE> <INDENT> dill_save_obj ( data , path ) <NEWLINE> <DEDENT> <DEDENT>
import os <NEWLINE> import json <NEWLINE> from datetime import datetime , date <NEWLINE> from decimal import Decimal <NEWLINE>
import sys <NEWLINE> import atrshmlog <NEWLINE> id = int ( sys . argv [ 1 ] ) <NEWLINE> print ( <STRING> + str ( id ) + <STRING> ) <NEWLINE> r = atrshmlog . delete ( id ) <NEWLINE> print ( <STRING> + str ( r ) + <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> exit ( 0 ) ; <NEWLINE>
def map_filter ( obj ) : <NEWLINE> <INDENT> obj [ <STRING> ] = 2 <NEWLINE> return obj <NEWLINE> <DEDENT>
class Localizable ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , ID , language , brief , description ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> super ( Localizable , self ) . __init__ ( ) <NEWLINE> self . ID = ID <NEWLINE> self . language = language <NEWLINE> self . brief = brief <NEWLINE> self . description = description <NEWLINE> <DEDENT> <DEDENT>
def google_voice_login ( email , passwd ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> global _voice <NEWLINE> if not _gv_available : <NEWLINE> <INDENT> print ( <STRING> <STRING> , file = sys . stderr ) <NEWLINE> return <NEWLINE> <DEDENT> _voice = googlevoice . Voice ( ) <NEWLINE> _voice . login ( email , passwd ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> __version__ = <STRING> <NEWLINE> import smtpd <NEWLINE> import asyncore <NEWLINE> server = smtpd . DebuggingServer ( ( <STRING> , 1025 ) , None ) <NEWLINE> asyncore . loop ( ) <NEWLINE>
class OperationProcessingFailedException ( BaseException ) : <NEWLINE> <INDENT> message = <STRING> <NEWLINE> def __init__ ( self , code = <STRING> , locator = <STRING> , layer = <STRING> , message = <STRING> , dump = <STRING> ) : <NEWLINE> <INDENT> self . message = self . message <NEWLINE> if len ( message ) > 0 : <NEWLINE> <INDENT> self . message = message <NEWLINE> BaseException . __init__ ( <NEWLINE> <INDENT> self , self . message , self . code , locator , layer , dump ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def add_tapa ( bar , nombre , votos = 0 ) : <NEWLINE> <INDENT> t = Tapa . objects . get_or_create ( bar = bar , nombre = nombre ) [ 0 ] <NEWLINE> t . votos = votos <NEWLINE> t . save ( ) <NEWLINE> return t <NEWLINE> <DEDENT>
import datetime <NEWLINE> from Spider import Spider <NEWLINE> app = Spider ( <STRING> , 8 , 100 ) <NEWLINE> print ( datetime . datetime . now ( ) ) <NEWLINE> app . start ( ) <NEWLINE>
import ctypes <NEWLINE> import osgDB , osgViewer , osg , osgGA , osgAnimation <NEWLINE> floatKeys = osgAnimation . FloatKeyframeContainer ( ) <NEWLINE> key0 = osgAnimation . FloatKeyframe ( 0.0 , 1.0 ) <NEWLINE> floatKeys . push_back ( key0 ) <NEWLINE> vec3Keys = osgAnimation . Vec3KeyframeContainer ( ) <NEWLINE> key0 = osgAnimation . Vec3Keyframe ( 0.0 , osg . Vec3 ( 1 , 2 , 3 ) ) <NEWLINE> vec3Keys . push_back ( key0 ) <NEWLINE> vec4Keys = osgAnimation . Vec4KeyframeContainer ( ) <NEWLINE> key0 = osgAnimation . Vec4Keyframe ( 0.0 , osg . Vec4 ( 1 , 2 , 3 , 4 ) ) <NEWLINE> vec4Keys . push_back ( key0 ) <NEWLINE>
{ <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : 6 , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : [ <STRING> , <STRING> ] , <NEWLINE> <STRING> : [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <DEDENT> ] , <NEWLINE> <STRING> : True , <NEWLINE> <STRING> : False , <NEWLINE> <DEDENT> } <NEWLINE>
def number_of_comments ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . get_number_of_comments ( ) <NEWLINE> <DEDENT>
def lcs ( list_x , list_y ) : <NEWLINE> <INDENT> __len_dict = { } <NEWLINE> __ele_dict = { } <NEWLINE> end_x = len ( list_x ) - 1 <NEWLINE> end_y = len ( list_y ) - 1 <NEWLINE> result = __lcs ( list_x , list_y , end_x , end_y , __len_dict , __ele_dict ) <NEWLINE> return { <NEWLINE> <INDENT> <STRING> : result , <NEWLINE> <STRING> : extra_lcs ( __ele_dict , list_x , end_x , end_y ) <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>
def rand_hi ( name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> reps = random . randint ( 1 , 100 ) <NEWLINE> return multi_hi ( name , reps ) <NEWLINE> <DEDENT>
def __init__ ( self , docroot , index , errorpage , phpstate , phpexec ) : <NEWLINE> <INDENT> self . docroot = docroot <NEWLINE> self . errorpage = errorpage <NEWLINE> self . index = index <NEWLINE> self . sender = PageSender ( self . docroot , self . errorpage ) <NEWLINE> self . php = handlePhp ( self . docroot , phpexec , self . errorpage ) <NEWLINE> self . phpstate = phpstate <NEWLINE> <DEDENT>
import os <NEWLINE> import xbmcaddon <NEWLINE> ADDON = <STRING> <NEWLINE> SETTINGS = xbmcaddon . Addon ( ) <NEWLINE> LANGUAGE = SETTINGS . getLocalizedString <NEWLINE> IMAGES_PATH = os . path . join ( xbmcaddon . Addon ( ) . getAddonInfo ( <STRING> ) , <STRING> , <STRING> ) <NEWLINE> DATE = <STRING> <NEWLINE> VERSION = <STRING> <NEWLINE>
def itemNames ( ) : <NEWLINE> <INDENT> return [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> ] <NEWLINE> <DEDENT>
def _check_login_with_skewed_otp ( self ) : <NEWLINE> <INDENT> interval = 30 <NEWLINE> otp = self . new_user [ <STRING> ] . totp . at ( <NEWLINE> <INDENT> datetime . datetime . now ( ) - datetime . timedelta ( seconds = interval ) ) <NEWLINE> <DEDENT> self . _check_login_with_otp ( otp ) <NEWLINE> otp = self . new_user [ <STRING> ] . totp . at ( <NEWLINE> <INDENT> datetime . datetime . now ( ) + datetime . timedelta ( seconds = interval ) ) <NEWLINE> <DEDENT> self . _check_login_with_otp ( otp ) <NEWLINE> <DEDENT>
def opStringTuple1 ( self , s1 , current = None ) : <NEWLINE> <INDENT> test ( isinstance ( s1 , tuple ) ) <NEWLINE> return ( s1 , s1 ) <NEWLINE> <DEDENT>
import django_filters <NEWLINE> from nodeconductor . core import filters as core_filters <NEWLINE> from . import models <NEWLINE>
def define_simple_tag ( tag_name , self_closing_tag = False ) : <NEWLINE> <INDENT> class new_tag ( Element ) : <NEWLINE> <INDENT> tag = tag_name <NEWLINE> self_closing = self_closing_tag <NEWLINE> <DEDENT> new_tag . __name__ = tag_name <NEWLINE> return new_tag <NEWLINE> <DEDENT>
class DateField ( DateTimeField ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , label = None , validators = None , parse_kwargs = None , <NEWLINE> <INDENT> display_format = <STRING> , ** kwargs ) : <NEWLINE> super ( DateField , self ) . __init__ ( label , validators , parse_kwargs = parse_kwargs , display_format = display_format , ** kwargs ) <NEWLINE> <DEDENT> def process_formdata ( self , valuelist ) : <NEWLINE> <INDENT> super ( DateField , self ) . process_formdata ( valuelist ) <NEWLINE> if self . data is not None and hasattr ( self . data , <STRING> ) : <NEWLINE> <INDENT> self . data = self . data . date ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_update_plugin_by_copying_its_files_to_plugins_path ( mock_update_operations , runner ) : <NEWLINE> <INDENT> runner . invoke ( cli . main , [ <STRING> , <STRING> , <STRING> , <STRING> ] ) <NEWLINE> src_path = os . path . join ( PLUGINS_LOCAL_REPOSITORY , <STRING> ) <NEWLINE> dst_path = <STRING> <NEWLINE> shutil . rmtree . assert_called_once_with ( dst_path ) <NEWLINE> shutil . copytree . assert_called_once_with ( src_path , dst_path ) <NEWLINE> <DEDENT>
class test_init ( common . basetest ) : <NEWLINE> <INDENT> def test_exists ( self ) : <NEWLINE> <INDENT> self . assertRaises ( hglib . error . CommandError , hglib . init ) <NEWLINE> <DEDENT> def test_basic ( self ) : <NEWLINE> <INDENT> self . client . close ( ) <NEWLINE> self . client = None <NEWLINE> shutil . rmtree ( <STRING> ) <NEWLINE> self . client = hglib . init ( ) . open ( ) <NEWLINE> self . assertTrue ( self . client . root ( ) . endswith ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT>
import unittest <NEWLINE> from urllib3 . connectionpool import ( <NEWLINE> <INDENT> connection_from_url , <NEWLINE> HTTPConnection , <NEWLINE> HTTPConnectionPool , <NEWLINE> <DEDENT> ) <NEWLINE> from urllib3 . util . timeout import Timeout <NEWLINE> from urllib3 . packages . ssl_match_hostname import CertificateError <NEWLINE> from urllib3 . exceptions import ( <NEWLINE> <INDENT> ClosedPoolError , <NEWLINE> EmptyPoolError , <NEWLINE> HostChangedError , <NEWLINE> LocationValueError , <NEWLINE> MaxRetryError , <NEWLINE> ProtocolError , <NEWLINE> SSLError , <NEWLINE> <DEDENT> ) <NEWLINE> from socket import error as SocketError <NEWLINE> from ssl import SSLError as BaseSSLError <NEWLINE> try : <NEWLINE> <INDENT> from queue import Empty <NEWLINE> from http . client import HTTPException <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> from Queue import Empty <NEWLINE> from httplib import HTTPException <NEWLINE> <DEDENT>
def generateIV128 ( pwdhash ) : <NEWLINE> <INDENT> from genutils import invertWord <NEWLINE> import struct <NEWLINE> res = <STRING> <NEWLINE> i = 0 <NEWLINE> while ( i < 16 ) : <NEWLINE> <INDENT> a = struct . unpack ( <STRING> , invertWord ( pwdhash [ i : i + 2 ] ) ) [ 0 ] <NEWLINE> b = struct . unpack ( <STRING> , pwdhash [ i + 16 : i + 16 + 2 ] ) [ 0 ] <NEWLINE> res += struct . pack ( <STRING> , a ^ b ) <NEWLINE> i += 2 <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT>
class UserMapper ( datamapper . ModelDataMapper ) : <NEWLINE> <INDENT> class Meta : <NEWLINE> <INDENT> model = get_user_model ( ) <NEWLINE> fields = ( get_user_model ( ) . USERNAME_FIELD , ) <NEWLINE> readonly = ( get_user_model ( ) . USERNAME_FIELD , ) <NEWLINE> <DEDENT> <DEDENT>
def get_form_class ( self ) : <NEWLINE> <INDENT> if not hasattr ( self , <STRING> ) : <NEWLINE> <INDENT> kw = self . kwargs <NEWLINE> kw [ <STRING> ] = self . form_class <NEWLINE> kw [ <STRING> ] = self . form_class . Meta . widgets <NEWLINE> self . _form_class = form_repository . get_generic_form ( ** self . kwargs ) <NEWLINE> <DEDENT> return self . _form_class <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import cv2 <NEWLINE> from matplotlib import pyplot as plt <NEWLINE> img = cv2 . imread ( <STRING> , 0 ) <NEWLINE> plt . imshow ( img , cmap = <STRING> , interpolation = <STRING> ) <NEWLINE> plt . xticks ( [ ] ) , plt . yticks ( [ ] ) <NEWLINE> plt . show ( ) <NEWLINE> cv2 . imshow ( <STRING> , img ) <NEWLINE> cv2 . waitKey ( 0 ) <NEWLINE>
from bs4 import BeautifulSoup <NEWLINE> import requests <NEWLINE> from pprint import pprint <NEWLINE> url = <STRING> <NEWLINE> r = requests . get ( <STRING> + url ) <NEWLINE> data = r . text <NEWLINE> soup = BeautifulSoup ( data ) <NEWLINE> from sqlitedict import SqliteDict <NEWLINE> dict_db = SqliteDict ( <STRING> , autocommit = True ) <NEWLINE> treknobabble = [ ] <NEWLINE> failure = { } <NEWLINE> myset = [ ] <NEWLINE>
def scale_x ( x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return int ( x * scale_factor ) + window_width // 2 <NEWLINE> <DEDENT>
import os <NEWLINE> from app import create_app , db <NEWLINE> from app . models import User <NEWLINE> from flask_script import Manager , Shell , Command <NEWLINE> from flask_migrate import Migrate , MigrateCommand <NEWLINE> app = create_app ( os . getenv ( <STRING> ) or <STRING> ) <NEWLINE> manager = Manager ( app ) <NEWLINE> migrate = Migrate ( app , db ) <NEWLINE>
def add_marker ( self , lon , lat , cls = MapMarker , options = None ) : <NEWLINE> <INDENT> if options is None : <NEWLINE> <INDENT> options = { } <NEWLINE> <DEDENT> marker = Marker ( lon , lat , cls , options ) <NEWLINE> self . cluster_markers . append ( marker ) <NEWLINE> return marker <NEWLINE> <DEDENT>
class Type ( Enum ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> CSV = 0 <NEWLINE> XLSX = 1 <NEWLINE> XML = 2 <NEWLINE> <DEDENT>
from django . utils . safestring import mark_safe <NEWLINE> from rest_framework . utils import formatting <NEWLINE> from rest_framework . compat import smart_text <NEWLINE>
def parseContacts ( f ) : <NEWLINE> <INDENT> contacts = set ( ) <NEWLINE> for l in open ( f ) : <NEWLINE> <INDENT> x = l . split ( ) <NEWLINE> if len ( x ) != 3 : <NEWLINE> <INDENT> sys . stderr . write ( <STRING> + f ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> if float ( x [ - 1 ] ) < 8 : <NEWLINE> <INDENT> contacts . add ( ( int ( x [ 0 ] ) , int ( x [ 1 ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> return contacts <NEWLINE> <DEDENT>
import mock <NEWLINE> from django . test import TestCase <NEWLINE> from django . core . urlresolvers import reverse <NEWLINE>
from django . db import models <NEWLINE> from lino . api import dd <NEWLINE> from lino . utils import join_elems <NEWLINE> from lino . utils . xmlgen . html import E <NEWLINE> from lino . core . actors import qs2summary <NEWLINE>
class TestCbh_core_ws ( TestCase ) : <NEWLINE> <INDENT> def setUp ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def test_something ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def tearDown ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
def _get_interface_state ( self ) : <NEWLINE> <INDENT> if <STRING> in self . _raw_configuration : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT>
def test_no_rules_with_grandparent_filter ( self ) : <NEWLINE> <INDENT> res = self . app . get ( self . lawless_url + <STRING> . format ( self . subA . pk ) ) <NEWLINE> assert_equal ( res . status_code , 200 ) <NEWLINE> assert_equal ( res . json [ <STRING> ] [ <STRING> ] [ <STRING> ] , 3 ) <NEWLINE> <DEDENT>
def AppendMemSRAMStartAddress ( mem , address ) : <NEWLINE> <INDENT> mem . append ( 0x800000 + address ) <NEWLINE> return mem <NEWLINE> <DEDENT>
def update_keyword ( node , keyword ) : <NEWLINE> <INDENT> found = False <NEWLINE> for i in range ( len ( node . keywords ) ) : <NEWLINE> <INDENT> if node . keywords [ i ] . arg == keyword . arg : <NEWLINE> <INDENT> node . keywords [ i ] = keyword <NEWLINE> found = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not found : <NEWLINE> <INDENT> node . keywords . append ( keyword ) <NEWLINE> <DEDENT> <DEDENT>
def ack_host ( host_name , message ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> cmd = <STRING> % locals ( ) <NEWLINE> command ( cmd ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import os <NEWLINE> from feedplatform . management import NoArgsCommand <NEWLINE> from optparse import make_option <NEWLINE>
import os <NEWLINE> import subprocess <NEWLINE> import re <NEWLINE> if os . name == <STRING> : <NEWLINE> <INDENT> from ctypes import windll , create_unicode_buffer <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> import sublime <NEWLINE> <DEDENT> except ( ImportError ) : <NEWLINE> <INDENT> sublime = None <NEWLINE> <DEDENT> from . console_write import console_write <NEWLINE> from . unicode import unicode_from_os <NEWLINE> from . show_error import show_error <NEWLINE> try : <NEWLINE> <INDENT> str_cls = unicode <NEWLINE> <DEDENT> except ( NameError ) : <NEWLINE> <INDENT> str_cls = str <NEWLINE> <DEDENT>
def __get_select_area ( self , pos ) : <NEWLINE> <INDENT> ( x , y ) = self . _img_position <NEWLINE> x *= self . scale <NEWLINE> y *= self . scale <NEWLINE> x_min = x - ( self . GRIP_SIZE / 2 ) <NEWLINE> y_min = y - ( self . GRIP_SIZE / 2 ) <NEWLINE> x_max = x + ( self . GRIP_SIZE / 2 ) <NEWLINE> y_max = y + ( self . GRIP_SIZE / 2 ) <NEWLINE> return ( ( x_min , y_min ) , ( x_max , y_max ) ) <NEWLINE> <DEDENT>
from twitfin . testsuite import main <NEWLINE> main ( ) <NEWLINE>
<STRING> <NEWLINE> import os <NEWLINE> import json <NEWLINE> from tempfile import NamedTemporaryFile <NEWLINE> import six <NEWLINE> from playitagainsam . util import get_default_shell <NEWLINE>
def selfdir ( ) : <NEWLINE> <INDENT> cwd = os . path . dirname ( os . path . abspath ( __file__ ) ) <NEWLINE> return os . path . dirname ( cwd ) <NEWLINE> <DEDENT>
class PickleSerializer ( api . Serializer ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> supports_backward_migration = True <NEWLINE> extension = <STRING> <NEWLINE> saves_migration_name = True <NEWLINE> def _save ( self , file , migration ) : <NEWLINE> <INDENT> import pickle <NEWLINE> pickle . dump ( migration , file ) <NEWLINE> <DEDENT> def _load ( self , file , migration_name , is_guess ) : <NEWLINE> <INDENT> import pickle <NEWLINE> return pickle . load ( file ) <NEWLINE> <DEDENT> <DEDENT>
class UsersView ( LoginRequiredMixin , TemplateView ) : <NEWLINE> <INDENT> template_name = <STRING> <NEWLINE> def get_context_data ( self , ** kwargs ) : <NEWLINE> <INDENT> return { <NEWLINE> <INDENT> <STRING> : self . request . user . get_users ( ) . prefetch_related ( <STRING> ) , <NEWLINE> <STRING> : self . request . user . get_organizations ( ) <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> realmain ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> sys . stderr . write ( <STRING> % str ( asyncore . compact_traceback ( ) ) ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
def get_filename ( self , runSetName , fileExtension ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> fileName = self . benchmark . output_base_name + <STRING> <NEWLINE> if runSetName : <NEWLINE> <INDENT> fileName += runSetName + <STRING> <NEWLINE> <DEDENT> return fileName + fileExtension <NEWLINE> <DEDENT>
def kill_topology_by_name ( topology_name , wait_time = 0 ) : <NEWLINE> <INDENT> id = StormUI . getTopologyIdByName ( topology_name ) <NEWLINE> if id is not None : <NEWLINE> <INDENT> return StormUI . killTopology ( id , wait_time ) <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>
def draw_screen ( ) : <NEWLINE> <INDENT> global stdscr , query <NEWLINE> stdscr . erase ( ) <NEWLINE> stdscr . addstr ( 0 , 0 , <STRING> ) <NEWLINE> stdscr . addstr ( 2 , 0 , query ) <NEWLINE> for i in range ( len ( matches ) ) : <NEWLINE> <INDENT> stdscr . addstr ( 4 + i , 0 , matches [ i ] [ 1 ] ) <NEWLINE> <DEDENT> stdscr . refresh ( ) <NEWLINE> <DEDENT>
def _randFloat ( self , shape ) : <NEWLINE> <INDENT> vals = np . random . normal ( 0 , 1 , np . prod ( shape ) ) . reshape ( shape ) <NEWLINE> return np . array ( vals , dtype = np . float32 ) <NEWLINE> <DEDENT>
import os <NEWLINE> import sys <NEWLINE> try : <NEWLINE> <INDENT> from setuptools import setup , find_packages <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> from distutils . core import setup , find_packages <NEWLINE> <DEDENT> if sys . version_info < ( 2 , 6 ) : <NEWLINE> <INDENT> raise NotImplementedError ( <STRING> ) <NEWLINE> <DEDENT> from setuptools . command . test import test as TestCommand <NEWLINE>
def _bounds_changed ( self , old , new ) : <NEWLINE> <INDENT> super ( DataView , self ) . _bounds_changed ( old , new ) <NEWLINE> self . _update_mappers ( ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import sys <NEWLINE> from base64 import urlsafe_b64encode , urlsafe_b64decode <NEWLINE> __version__ = <STRING> <NEWLINE> PY2 = sys . version_info < ( 3 , 0 ) <NEWLINE>
from sha import sha as sha1 <NEWLINE>
def unframe ( self , bytestring ) : <NEWLINE> <INDENT> if is_valid_frame ( bytestring ) : <NEWLINE> <INDENT> u = unescape ( bytestring [ : - 1 ] ) <NEWLINE> return u [ : - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return bytestring <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> from OpenGL . GL import * <NEWLINE> from . . GLGraphicsItem import GLGraphicsItem <NEWLINE> from ... import QtGui <NEWLINE> __all__ = [ <STRING> ] <NEWLINE>
def _time_str_to_unix ( timestring ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if isinstance ( timestring , ( int , float ) ) : <NEWLINE> <INDENT> return timestring <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> t = int ( time . mktime ( datetime . strptime ( timestring , <STRING> ) . timetuple ( ) ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> t = None <NEWLINE> <DEDENT> return t <NEWLINE> <DEDENT>
def getUsage ( self , ** kwargs ) : <NEWLINE> <INDENT> t = usage . Options . getUsage ( self , ** kwargs ) <NEWLINE> return t + <STRING> <NEWLINE> <DEDENT>
def get_magnet ( self , pageLink ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> downloadLocationTest = self . get_specific_tracker ( self . domain + pageLink ) <NEWLINE> magnet = False <NEWLINE> while magnet is False : <NEWLINE> <INDENT> trackerLink = next ( downloadLocationTest , None ) <NEWLINE> if trackerLink is not None : <NEWLINE> <INDENT> magnet = self . get_magnet_from_tracker ( trackerLink ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return magnet <NEWLINE> <DEDENT>
import pytest <NEWLINE> import json <NEWLINE> import re <NEWLINE> from share . change import ChangeGraph <NEWLINE> from share . models import ChangeSet <NEWLINE> from tests . share . models . factories import NormalizedDataFactory <NEWLINE>
def test ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . __test is None : <NEWLINE> <INDENT> self . __test = Test ( self ) <NEWLINE> <DEDENT> return self . __test <NEWLINE> <DEDENT>
def read_hdf_as_results ( hdf ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> f = h5py . File ( name , <STRING> ) <NEWLINE> pass <NEWLINE> return results <NEWLINE> <DEDENT>
import ConfigParser <NEWLINE> from pygame import Color <NEWLINE> config = ConfigParser . RawConfigParser ( ) <NEWLINE> config . read ( <STRING> ) <NEWLINE> G = 1 <NEWLINE> MAXRESPAWNTIME = 3000 <NEWLINE> BULLET_LIFE = 7000 <NEWLINE> BULLET_MASS = 0.3 <NEWLINE> BULLET_VEL = 6 <NEWLINE> FUEL_MASS = 0.2 <NEWLINE> MAX_FUEL = 16 <NEWLINE> MAX_AMMO = 16 <NEWLINE> GAME_SPEED = 40 <NEWLINE> SYS_FONT = <STRING> <NEWLINE> STATS_FONT = <STRING> <NEWLINE> MAX_OBJECTS = config . getint ( <STRING> , <STRING> ) <NEWLINE> DEBRIS_R = 6 <NEWLINE> DEBRIS_SCALING = 3.0 <NEWLINE> DEBRIS_COLORS = ( Color ( <STRING> ) , Color ( <STRING> ) ) <NEWLINE> HELLDEBRIS_COLORS = ( Color ( <STRING> ) , Color ( <STRING> ) ) <NEWLINE>
def mood ( self ) : <NEWLINE> <INDENT> unhappiness = self . hunger + self . boredom <NEWLINE> if unhappiness < 5 : <NEWLINE> <INDENT> m = <STRING> <NEWLINE> <DEDENT> elif 5 <= unhappiness <= 10 : <NEWLINE> <INDENT> m = <STRING> <NEWLINE> <DEDENT> elif 11 <= unhappiness <= 15 : <NEWLINE> <INDENT> m = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = <STRING> <NEWLINE> <DEDENT> return m <NEWLINE> <DEDENT>
def get_table ( key ) : <NEWLINE> <INDENT> m = hashlib . md5 ( ) <NEWLINE> m . update ( key ) <NEWLINE> s = m . digest ( ) <NEWLINE> ( a , b ) = struct . unpack ( <STRING> , s ) <NEWLINE> table = [ c for c in string . maketrans ( <STRING> , <STRING> ) ] <NEWLINE> for i in xrange ( 1 , 1024 ) : <NEWLINE> <INDENT> table . sort ( lambda x , y : int ( a % ( ord ( x ) + i ) - a % ( ord ( y ) + i ) ) ) <NEWLINE> <DEDENT> return table <NEWLINE> <DEDENT>
import re <NEWLINE> import urlparse <NEWLINE> from pyload . plugin . internal . SimpleHoster import SimpleHoster <NEWLINE> from pyload . utils import html_unescape <NEWLINE>
from datetime import datetime <NEWLINE> import random <NEWLINE> import numpy <NEWLINE> import torch <NEWLINE> import torch . nn as nn <NEWLINE> import torch . nn . functional as F <NEWLINE> import torchvision <NEWLINE> from torchvision . datasets . folder import * <NEWLINE> from torch . optim import SGD , Adadelta , Adam , Adagrad , RMSprop , ASGD <NEWLINE> OPTIMIZERS = { <NEWLINE> <INDENT> <STRING> : SGD , <NEWLINE> <STRING> : Adadelta , <NEWLINE> <STRING> : Adam , <NEWLINE> <STRING> : Adagrad , <NEWLINE> <STRING> : RMSprop , <NEWLINE> <STRING> : ASGD <NEWLINE> <DEDENT> } <NEWLINE>
class DjangoBNRApp ( AppConfig ) : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> verbose_name = <STRING> <NEWLINE> <DEDENT>
def _mapdamage_plot ( self , config , destination , prefix , files_and_nodes ) : <NEWLINE> <INDENT> title = <STRING> % ( self . name , ) <NEWLINE> dependencies = files_and_nodes . values ( ) <NEWLINE> plot = MapDamagePlotNode . customize ( config = config , <NEWLINE> <INDENT> reference = prefix [ <STRING> ] , <NEWLINE> input_files = files_and_nodes . keys ( ) , <NEWLINE> output_directory = destination , <NEWLINE> title = title , <NEWLINE> dependencies = dependencies ) <NEWLINE> <DEDENT> apply_options ( plot . command , self . options [ <STRING> ] ) <NEWLINE> return plot . build_node ( ) <NEWLINE> <DEDENT>
class Command ( migrate . Command ) : <NEWLINE> <INDENT> def handle ( self , * args , ** kwargs ) : <NEWLINE> <INDENT> patch_sae_restful_mysql ( ) <NEWLINE> kwargs . setdefault ( <STRING> , DEFAULT_DB_ALIAS ) <NEWLINE> super ( Command , self ) . handle ( * args , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT>
def close ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . _thread . stop ( ) <NEWLINE> try : <NEWLINE> <INDENT> if self . cradio : <NEWLINE> <INDENT> self . cradio . close ( ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> self . cradio = None <NEWLINE> while not self . out_queue . empty ( ) : <NEWLINE> <INDENT> self . out_queue . get ( ) <NEWLINE> <DEDENT> self . link_error_callback = None <NEWLINE> self . link_quality_callback = None <NEWLINE> <DEDENT>
import sys <NEWLINE> lines = [ line . decode ( <STRING> ) . rstrip ( <STRING> ) for line in sys . stdin . readlines ( ) ] <NEWLINE> lines = sorted ( lines , key = lambda l : l . split ( <STRING> ) [ 0 ] ) <NEWLINE> lines = sorted ( lines , key = lambda l : l . split ( <STRING> ) [ 1 ] ) <NEWLINE> for line in lines : <NEWLINE> <INDENT> print ( line . encode ( <STRING> ) ) <NEWLINE> <DEDENT>
def test_08_bury ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . assertTrue ( tbury ( <NEWLINE> <INDENT> self . keyfile , self . passphrase2 , self . imagefile <NEWLINE> ) [ 0 ] <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT>
class FeuerFreiTestCase ( unittest . TestCase ) : <NEWLINE> <INDENT> def test_equal_1 ( self ) : <NEWLINE> <INDENT> self . assertEqual ( feuer_frei ( 5 , 20 ) , <STRING> ) <NEWLINE> <DEDENT> def test_equal_2 ( self ) : <NEWLINE> <INDENT> self . assertEqual ( feuer_frei ( 5 , 200 ) , 900 ) <NEWLINE> <DEDENT> def test_equal_3 ( self ) : <NEWLINE> <INDENT> self . assertEqual ( feuer_frei ( 5 , 2 ) , <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def computeCost ( X , y , theta ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> m = len ( y ) <NEWLINE> J = 0 <NEWLINE> h = X . dot ( theta ) <NEWLINE> J = ( 1.0 / ( 2 * m ) ) * np . sum ( np . square ( h - y ) ) <NEWLINE> return J <NEWLINE> <DEDENT>
def remove_all_subsequent_objects ( root , objects ) : <NEWLINE> <INDENT> if objects . has_key ( root ) : <NEWLINE> <INDENT> while root in objects and objects [ root ] : <NEWLINE> <INDENT> child = objects [ root ] . pop ( ) <NEWLINE> remove_all_subsequent_objects ( child , objects ) <NEWLINE> <DEDENT> if objects . has_key ( root ) : <NEWLINE> <INDENT> remove_edge_from_objects ( root , objects ) <NEWLINE> del objects [ root ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> remove_edge_from_objects ( root , objects ) <NEWLINE> <DEDENT> <DEDENT>
def tweetWordCount ( kvs ) : <NEWLINE> <INDENT> lines = kvs . map ( lambda x : x [ 1 ] ) <NEWLINE> counts = lines . flatMap ( lambda line : json . loads ( line ) [ <STRING> ] . split ( <STRING> ) ) . map ( lambda word : ( word , 1 ) ) . reduceByKey ( lambda a , b : a + b ) <NEWLINE> sys . stdout . flush ( ) <NEWLINE> return counts <NEWLINE> <DEDENT>
from django . db import models <NEWLINE> from perfil . models import Persona <NEWLINE> from especialidad import Especialidad <NEWLINE>
class Connection ( protocol . Protocol ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> db = adbapi . ConnectionPool ( <NEWLINE> <INDENT> <STRING> , db = <STRING> , user = <STRING> , <NEWLINE> passwd = <STRING> , host = <STRING> ) <NEWLINE> <DEDENT> def dataReceived ( self , data ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . db . runQuery ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> ) . addCallback ( self . respond ) <NEWLINE> <DEDENT> def respond ( self , _ ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . transport . write ( <STRING> ) <NEWLINE> self . transport . loseConnection ( ) <NEWLINE> <DEDENT> <DEDENT>
from test_framework . mininode import * <NEWLINE> from test_framework . test_framework import InfinitumTestFramework <NEWLINE> from test_framework . util import * <NEWLINE> import time <NEWLINE> from test_framework . blocktools import create_block , create_coinbase <NEWLINE> <STRING> <NEWLINE>
def encode ( self , o ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> encoded_o = super ( PlotlyJSONEncoder , self ) . encode ( o ) <NEWLINE> try : <NEWLINE> <INDENT> new_o = _json . loads ( encoded_o , <NEWLINE> <INDENT> parse_constant = self . coerce_to_strict ) <NEWLINE> <DEDENT> <DEDENT> except ValueError : <NEWLINE> <INDENT> raise ValueError ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return _json . dumps ( new_o , sort_keys = self . sort_keys , <NEWLINE> <INDENT> indent = self . indent , <NEWLINE> separators = ( self . item_separator , <NEWLINE> <INDENT> self . key_separator ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import aiohttp <NEWLINE> import logging <NEWLINE> import json <NEWLINE> import collections <NEWLINE> logger = logging . getLogger ( __name__ ) <NEWLINE>
def simplify ( robot ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for i in range ( robot . numLinks ( ) ) : <NEWLINE> <INDENT> geom = robot . link ( i ) . geometry ( ) <NEWLINE> if geom . empty ( ) : continue <NEWLINE> BB = geom . getBB ( ) <NEWLINE> print ( BB [ 0 ] , BB [ 1 ] ) <NEWLINE> BBgeom = GeometricPrimitive ( ) <NEWLINE> BBgeom . setAABB ( BB [ 0 ] , BB [ 1 ] ) <NEWLINE> geom . setGeometricPrimitive ( BBgeom ) <NEWLINE> <DEDENT> <DEDENT>
from django . db import models <NEWLINE> from dbmail import app_installed <NEWLINE> HTMLField = models . TextField <NEWLINE> if app_installed ( <STRING> ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> from tinymce . models import HTMLField <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
def module_test ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> ) <NEWLINE> doctest . testmod ( convert ) <NEWLINE> doctest . testmod ( file_data ) <NEWLINE> doctest . testmod ( uv_data ) <NEWLINE> <DEDENT>
class SponsorListView ( ListView ) : <NEWLINE> <INDENT> model = Sponsor <NEWLINE> context_object_name = <STRING> <NEWLINE> template_name = <STRING> <NEWLINE> def get_queryset ( self ) : <NEWLINE> <INDENT> return super ( SponsorListView , self ) . get_queryset ( ) . order_by ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import json <NEWLINE> DIR = sys . argv . pop + sys . argv . pop <NEWLINE> metadata = open ( DIR ) <NEWLINE> print ( json . load ( metadata ) ) <NEWLINE>
def _fft_factory ( invec , outvec , nbatch = 1 , size = None ) : <NEWLINE> <INDENT> backend = get_backend ( ) <NEWLINE> cls = getattr ( backend , <STRING> ) <NEWLINE> return cls <NEWLINE> <DEDENT>
def get_user ( keystone , name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> users = [ x for x in keystone . users . list ( ) if x . name == name ] <NEWLINE> count = len ( users ) <NEWLINE> if count == 0 : <NEWLINE> <INDENT> raise KeyError ( <STRING> % name ) <NEWLINE> <DEDENT> elif count > 1 : <NEWLINE> <INDENT> raise ValueError ( <STRING> % ( count , name ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return users [ 0 ] <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import os <NEWLINE> import sys <NEWLINE> import mutagen . mp3 <NEWLINE>
def rms ( input ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for v in input : <NEWLINE> <INDENT> sum += v * v <NEWLINE> <DEDENT> sum /= float ( len ( input ) ) <NEWLINE> return sum ** 0.5 <NEWLINE> <DEDENT>
def set_config ( self , section_id = None , custom_thumb = <STRING> , do_notify = 1 , keep_history = 1 , do_notify_created = 1 ) : <NEWLINE> <INDENT> if section_id : <NEWLINE> <INDENT> monitor_db = database . MonitorDatabase ( ) <NEWLINE> key_dict = { <STRING> : section_id } <NEWLINE> value_dict = { <STRING> : custom_thumb , <NEWLINE> <INDENT> <STRING> : do_notify , <NEWLINE> <STRING> : do_notify_created , <NEWLINE> <STRING> : keep_history } <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> monitor_db . upsert ( <STRING> , value_dict , key_dict ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> logger . warn ( <STRING> % e ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import re <NEWLINE> import requests <NEWLINE> WORDS = [ <STRING> , <STRING> ] <NEWLINE>
from __future__ import print_function <NEWLINE> import tensorflow as tf <NEWLINE> with tf . Session ( ) : <NEWLINE> <INDENT> input1 = tf . constant ( [ 1.0 , 1.0 , 1.0 , 1.0 ] ) <NEWLINE> input2 = tf . constant ( [ 2.0 , 2.0 , 2.0 , 2.0 ] ) <NEWLINE> output = tf . add ( input1 , input2 ) <NEWLINE> result = output . eval ( ) <NEWLINE> print ( <STRING> , result ) <NEWLINE> <DEDENT>
class CharaModelAdmin ( admin . ModelAdmin ) : <NEWLINE> <INDENT> list_display = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> search_fields = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> class Meta : <NEWLINE> <INDENT> model = Character <NEWLINE> <DEDENT> <DEDENT>
__author__ = <STRING> <NEWLINE> __version__ = <STRING> <NEWLINE> __license__ = <STRING> <NEWLINE> import sys <NEWLINE> import os , os . path <NEWLINE> from functools import partial <NEWLINE> from jinja2 import Environment <NEWLINE> from collections import defaultdict <NEWLINE> from argparse import ArgumentParser <NEWLINE> import click <NEWLINE>
import supybot . conf as conf <NEWLINE> import supybot . registry as registry <NEWLINE> import supybot . callbacks as callbacks <NEWLINE> from supybot . i18n import PluginInternationalization , internationalizeDocstring <NEWLINE> _ = PluginInternationalization ( <STRING> ) <NEWLINE>
class Migration ( migrations . Migration ) : <NEWLINE> <INDENT> dependencies = [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE> operations = [ <NEWLINE> <INDENT> migrations . AlterField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> field = models . DateTimeField ( blank = True , default = None , null = True , unique = True ) , <NEWLINE> <DEDENT> ) , <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT>
from setuptools import setup , find_packages <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> version = <STRING> , <NEWLINE> description = <STRING> , <NEWLINE> author = [ <STRING> , <STRING> ] , <NEWLINE> author_email = <STRING> , <NEWLINE> url = <STRING> , <NEWLINE> packages = find_packages ( ) , <NEWLINE> include_package_data = True , <NEWLINE> zip_safe = False , <NEWLINE> classifiers = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <DEDENT> ] , <NEWLINE> install_requires = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <DEDENT> ] , <NEWLINE> <DEDENT> ) <NEWLINE>
import sys <NEWLINE> line = sys . stdin . readline ( ) ; <NEWLINE> lines = [ ] <NEWLINE> count = 0 ; <NEWLINE> while line != <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> lines . append ( line ) ; <NEWLINE> line = sys . stdin . readline ( ) <NEWLINE> <DEDENT>
def test_long_options_error_handling ( ) : <NEWLINE> <INDENT> with raises ( DocoptExit ) : <NEWLINE> <INDENT> docopt ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> with raises ( DocoptExit ) : <NEWLINE> <INDENT> docopt ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> with raises ( DocoptLanguageError ) : <NEWLINE> <INDENT> docopt ( <STRING> ) <NEWLINE> <DEDENT> with raises ( DocoptExit ) : <NEWLINE> <INDENT> docopt ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> with raises ( DocoptLanguageError ) : <NEWLINE> <INDENT> docopt ( <STRING> ) <NEWLINE> <DEDENT> with raises ( DocoptExit ) : <NEWLINE> <INDENT> docopt ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from __future__ import unicode_literals <NEWLINE> import base64 <NEWLINE> import random <NEWLINE> import string <NEWLINE> from django . utils . encoding import force_bytes , force_text <NEWLINE> from Crypto . Cipher import AES <NEWLINE> from modoboa . parameters import tools as param_tools <NEWLINE>
class UsagepanelTabs ( tabs . TabGroup ) : <NEWLINE> <INDENT> slug = <STRING> <NEWLINE> tabs = ( UsageTab , ) <NEWLINE> sticky = True <NEWLINE> <DEDENT>
def __init__ ( self ) : <NEWLINE> <INDENT> self . log_config = None <NEWLINE> self . ctrl_adv = False <NEWLINE> self . ctrl_ip = ip_address ( <STRING> ) <NEWLINE> self . ctrl_port = 5533 <NEWLINE> self . ctrl_adv_iface = <STRING> <NEWLINE> <DEDENT>
from test . test_support import TestFailed , verbose <NEWLINE> t = ( 1 , 2 , 3 ) <NEWLINE> l = [ 4 , 5 , 6 ] <NEWLINE>
def is_divisible ( * args ) : <NEWLINE> <INDENT> f = args [ 0 ] <NEWLINE> return all ( f % x == 0 for x in args [ 1 : ] ) <NEWLINE> <DEDENT>
def files_in ( package , directory ) : <NEWLINE> <INDENT> paths = [ ] <NEWLINE> for root , dirs , files in walk ( join_path ( package , directory ) ) : <NEWLINE> <INDENT> for file in files : <NEWLINE> <INDENT> paths . append ( join_path ( root , file ) [ ( len ( package ) + 1 ) : ] ) <NEWLINE> <DEDENT> <DEDENT> return paths <NEWLINE> <DEDENT>
def processMessage ( self , currentMessage , envelope ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if envelope [ <STRING> ] == <STRING> or envelope [ <STRING> ] == <STRING> or envelope [ <STRING> ] == self . chordNode . nodeLocation . id : <NEWLINE> <INDENT> self . classChordClientObj . receiveMessage ( currentMessage , envelope ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT>
def test_single_line_comment_is_ignored ( self ) : <NEWLINE> <INDENT> lexer . input ( <STRING> ) <NEWLINE> token = lexer . token ( ) <NEWLINE> self . assertEqual ( lexer . lineno , 1 ) <NEWLINE> self . assertIsNone ( token ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> __all__ = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ] <NEWLINE> <DEDENT> from music21 . alpha import analysis <NEWLINE> from music21 . alpha import counterpoint <NEWLINE> from music21 . alpha import theoryAnalysis <NEWLINE> from music21 . alpha import trecento <NEWLINE> from music21 . alpha import webapps <NEWLINE> from music21 . alpha import chant <NEWLINE> from music21 . alpha import contour <NEWLINE> from music21 . alpha import medren <NEWLINE>
def toggle_capture ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> screen . tracer ( 0 ) <NEWLINE> global capture_mode <NEWLINE> capture_mode = not capture_mode <NEWLINE> if capture_mode : <NEWLINE> <INDENT> turtobj_cm . fillcolor ( <STRING> ) <NEWLINE> turtobj_main . shape ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> turtobj_cm . fillcolor ( <STRING> ) <NEWLINE> capture_shape ( ) <NEWLINE> <DEDENT> screen . tracer ( 1 ) <NEWLINE> <DEDENT>
class PhaseRunner : <NEWLINE> <INDENT> def stand_phase ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> def draw_phase ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> def ride_phase ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> def main_phase ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> def battle_phase ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> def end_phase ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def kill ( self ) : <NEWLINE> <INDENT> if self . is_running ( ) == True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> os . kill ( self . get_property ( <STRING> ) , signal . SIGKILL ) <NEWLINE> killedpid , stat = os . wait ( ) <NEWLINE> self . set_property ( <STRING> , 0 ) <NEWLINE> <DEDENT> except OSError : <NEWLINE> <INDENT> sys . stderr . write ( <STRING> % self . pid ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import os <NEWLINE> import json <NEWLINE> from datetime import datetime , timedelta <NEWLINE> from settings import TEMPDIR , TEXTDIR , JSONDIR <NEWLINE> from settings import logging <NEWLINE> from defs import dump_data , load_data <NEWLINE>
def peewee_init ( config ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> env = config . env [ <STRING> ] <NEWLINE> db_class = getattr ( peewee_async , env . get ( <STRING> ) or <STRING> ) <NEWLINE> db = db_class ( <NEWLINE> <INDENT> env . get ( <STRING> ) , <NEWLINE> user = env . get ( <STRING> ) , <NEWLINE> password = env . get ( <STRING> ) <NEWLINE> <DEDENT> ) <NEWLINE> db_proxy . initialize ( db ) <NEWLINE> <DEDENT>
class GetReportByIdChoreographyExecution ( ChoreographyExecution ) : <NEWLINE> <INDENT> def _make_result_set ( self , response , path ) : <NEWLINE> <INDENT> return GetReportByIdResultSet ( response , path ) <NEWLINE> <DEDENT> <DEDENT>
def combine_name_pair ( name , suffix ) : <NEWLINE> <INDENT> if suffix : <NEWLINE> <INDENT> if suffix [ 0 ] == <STRING> : <NEWLINE> <INDENT> return name + suffix <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return name + <STRING> + suffix <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return name <NEWLINE> <DEDENT> <DEDENT>
class NetworkError ( HangupsError ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> pass <NEWLINE> <DEDENT>
class HideChoicesCharField ( models . CharField ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def deconstruct ( self ) : <NEWLINE> <INDENT> name , path , args , kwargs = models . CharField . deconstruct ( self ) <NEWLINE> if path == <STRING> : <NEWLINE> <INDENT> path = <STRING> <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> del kwargs [ <STRING> ] <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> return name , path , args , kwargs <NEWLINE> <DEDENT> <DEDENT>
class MyHtmlParser ( HTMLParser ) : <NEWLINE> <INDENT> def handle_starttag ( self , tag , attrs ) : <NEWLINE> <INDENT> print ( <STRING> % tag ) <NEWLINE> <DEDENT> <DEDENT>
def update_user_type ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . rb_tutor . isChecked ( ) : <NEWLINE> <INDENT> self . user_type = <STRING> <NEWLINE> <DEDENT> elif self . rb_student . isChecked ( ) : <NEWLINE> <INDENT> self . user_type = <STRING> <NEWLINE> <DEDENT> self . accept ( ) <NEWLINE> <DEDENT>
def is_valid_us_zip_code ( zip ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if re . match ( <STRING> , zip ) is not None : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
import sys <NEWLINE> from app . standalone_app import StandaloneApp <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> StandaloneApp ( ) . run ( ) <NEWLINE> <DEDENT>
def get_yaml_config ( file_name ) : <NEWLINE> <INDENT> with open ( file_name , <STRING> ) as open_file : <NEWLINE> <INDENT> contents = yaml . load ( open_file ) <NEWLINE> LOGGER . debug ( contents ) <NEWLINE> return contents <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>
def my_handler ( channel , data ) : <NEWLINE> <INDENT> msg = example_t . decode ( data ) <NEWLINE> print ( <STRING> % channel ) <NEWLINE> print ( <STRING> % str ( msg . position [ 0 ] ) ) <NEWLINE> print ( <STRING> % str ( msg . position [ 1 ] ) ) <NEWLINE> print ( <STRING> % str ( msg . position [ 2 ] ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
from pkg_resources import resource_filename <NEWLINE> import dclab <NEWLINE> cfgfile = resource_filename ( <STRING> , <STRING> ) <NEWLINE> datas = [ ( cfgfile , <STRING> ) ] <NEWLINE> hiddenimports = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> hiddenimports += [ <STRING> ] <NEWLINE>
from trump . orm import SymbolManager <NEWLINE> sm = SymbolManager ( ) <NEWLINE> oil = sm . get ( <STRING> ) <NEWLINE> oil . cache ( ) <NEWLINE> print ( oil . df . tail ( ) ) <NEWLINE> sm . finish ( ) <NEWLINE>
<STRING> <NEWLINE> from urllib import urlencode <NEWLINE> from urlparse import urljoin <NEWLINE> from lxml import html <NEWLINE> import string <NEWLINE> import re <NEWLINE> categories = [ <STRING> ] <NEWLINE> paging = False <NEWLINE> base_url = <STRING> <NEWLINE> search_url = base_url + <STRING> <NEWLINE>
def get_boundary_length ( boundary_file_name , island_file_names ) : <NEWLINE> <INDENT> l = 0.0 <NEWLINE> boundary_points = read_points ( boundary_file_name ) <NEWLINE> l += get_polygon_length ( boundary_points ) <NEWLINE> for island_file in island_file_names : <NEWLINE> <INDENT> islands_points = read_points ( island_file ) <NEWLINE> l += get_polygon_length ( islands_points ) <NEWLINE> <DEDENT> return l <NEWLINE> <DEDENT>
class ShowSymbol ( Filter ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __call__ ( self , * a , ** kw ) : <NEWLINE> <INDENT> return get_symbols ( ) <NEWLINE> <DEDENT> <DEDENT>
def deconstruct ( self ) : <NEWLINE> <INDENT> name , path , args , kwargs = super ( AggregateField , self ) . deconstruct ( ) <NEWLINE> del kwargs [ <STRING> ] <NEWLINE> args = [ self . denorm . manager_name ] + args <NEWLINE> return name , path , args , kwargs <NEWLINE> <DEDENT>
class GameSerializer ( serializers . ModelSerializer ) : <NEWLINE> <INDENT> class Meta : <NEWLINE> <INDENT> model = Game <NEWLINE> <DEDENT> <DEDENT>
def test_http_get_P1 ( self ) : <NEWLINE> <INDENT> self . conn . build_request ( <STRING> ) <NEWLINE> response = self . conn . execute_request ( ) <NEWLINE> self . assertTrue ( response . ok ( ) ) <NEWLINE> self . assertIn ( <STRING> , response . response_text ( ) ) <NEWLINE> <DEDENT>
class Command ( BaseCommand ) : <NEWLINE> <INDENT> help = ( <STRING> ) <NEWLINE> option_list = BaseCommand . option_list + ( <NEWLINE> <INDENT> make_option ( <STRING> , <NEWLINE> <INDENT> help = <STRING> , <NEWLINE> type = <STRING> , <NEWLINE> default = <STRING> ) , ) <NEWLINE> <DEDENT> <DEDENT> @ transaction . commit_on_success <NEWLINE> def handle ( self , * args , ** options ) : <NEWLINE> <INDENT> slug = options [ <STRING> ] <NEWLINE> sync_layers_ekr_task ( slug ) <NEWLINE> <DEDENT> <DEDENT>
def index ( request ) : <NEWLINE> <INDENT> if request . user . is_authenticated ( ) : <NEWLINE> <INDENT> return redirect ( current_user_profile ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return render ( request , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def alienvault ( ipInput ) : <NEWLINE> <INDENT> url = <STRING> + ipInput <NEWLINE> proxy = urllib2 . ProxyHandler ( ) <NEWLINE> opener = urllib2 . build_opener ( proxy ) <NEWLINE> response = opener . open ( <STRING> + ipInput ) <NEWLINE> content = response . read ( ) <NEWLINE> contentString = str ( content ) <NEWLINE> rpd = re . compile ( <STRING> ) <NEWLINE> rpdFind = re . findall ( rpd , contentString ) <NEWLINE> if not rpdFind : <NEWLINE> <INDENT> print ( <STRING> + url ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def getTag ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> attrs = [ ] <NEWLINE> for ( k , v ) in self . __dict__ . items ( ) : <NEWLINE> <INDENT> if k not in [ <STRING> ] : <NEWLINE> <INDENT> if v : <NEWLINE> <INDENT> attrs . append ( <STRING> % ( k , quoteattr ( str ( v ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return <STRING> + <STRING> . join ( attrs ) + <STRING> <NEWLINE> <DEDENT>
def initialize ( self ) : <NEWLINE> <INDENT> self . parser = LILACSQuestionParser ( ) <NEWLINE> self . service = KnowledgeService ( self . emitter ) <NEWLINE> self . build_intents ( ) <NEWLINE> self . make_bump_thread ( ) <NEWLINE> <DEDENT>
def format_bw ( bits ) : <NEWLINE> <INDENT> if not bits % 1000000 : <NEWLINE> <INDENT> return str ( bits / 1000000 ) + <STRING> <NEWLINE> <DEDENT> if not bits % 1000 : <NEWLINE> <INDENT> return str ( bits / 1000 ) + <STRING> <NEWLINE> <DEDENT> return str ( bits ) + <STRING> <NEWLINE> <DEDENT>
def from_topp ( topp_traj ) : <NEWLINE> <INDENT> return FunctionalChunk ( <NEWLINE> <INDENT> duration = topp_traj . duration , <NEWLINE> q_fun = topp_traj . Eval , <NEWLINE> qd_fun = topp_traj . Evald , <NEWLINE> qdd_fun = topp_traj . Evaldd ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , db , user = None ) : <NEWLINE> <INDENT> self . db = db <NEWLINE> self . user = user <NEWLINE> self . lock = threading . RLock ( ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import os <NEWLINE> import numpy as np <NEWLINE> units = <STRING> <NEWLINE> dir = os . path . join ( os . path . dirname ( __file__ ) , <STRING> ) <NEWLINE> files = os . listdir ( dir ) <NEWLINE> Standards = { } <NEWLINE> for file in files : <NEWLINE> <INDENT> if file [ 0 ] != <STRING> : continue <NEWLINE> std_name = file [ 1 : - 4 ] <NEWLINE> dat = np . loadtxt ( os . path . join ( dir , file ) ) <NEWLINE> Standards [ std_name ] = dat <NEWLINE> <DEDENT>
def addblockInputReference0 ( self , * blockInputReference0 ) : <NEWLINE> <INDENT> for obj in blockInputReference0 : <NEWLINE> <INDENT> obj . metaBlockInput0 = self <NEWLINE> <DEDENT> <DEDENT>
class Family ( family . Family ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> super ( Family , self ) . __init__ ( ) <NEWLINE> self . name = <STRING> <NEWLINE> self . langs = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> def version ( self , code ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT>
def print_verbose ( s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if verbose : print ( <STRING> . format ( s ) ) <NEWLINE> <DEDENT>
from pyromaths . outils . Arithmetique import pgcd , valeur_alea <NEWLINE> from random import choice , randrange <NEWLINE> import string , math <NEWLINE>
from bson . objectid import ObjectId <NEWLINE> import json <NEWLINE> from pymongo import MongoClient <NEWLINE>
def test_init_invalid_url_path_leading_slash ( self ) : <NEWLINE> <INDENT> bases = ( rest_requests . RestResource , ) <NEWLINE> attrs = dict ( url_path = <STRING> ) <NEWLINE> self . assertRaises ( ValueError , type , <STRING> , bases , attrs ) <NEWLINE> <DEDENT>
def main ( cisco_file = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> cisco_cfg = CiscoConfParse ( cisco_file ) <NEWLINE> for crypto_map in cisco_cfg . find_objects ( <STRING> ) : <NEWLINE> <INDENT> print <NEWLINE> print ( crypto_map . text ) <NEWLINE> for child in crypto_map . children : <NEWLINE> <INDENT> print ( child . text ) <NEWLINE> <DEDENT> <DEDENT> print <NEWLINE> <DEDENT>
def search ( ** kwargs ) : <NEWLINE> <INDENT> kwargs = { k : v for k , v in kwargs . items ( ) if v } <NEWLINE> return InternshipSpeciality . objects . filter ( ** kwargs ) . select_related ( <STRING> ) . order_by ( <STRING> , <STRING> ) <NEWLINE> <DEDENT>
from distutils . core import setup <NEWLINE> setup ( name = <STRING> , <NEWLINE> <INDENT> version = <STRING> , <NEWLINE> description = <STRING> , <NEWLINE> author = <STRING> , <NEWLINE> url = <STRING> , <NEWLINE> package_dir = { <STRING> : <STRING> } , <NEWLINE> py_modules = [ <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import os <NEWLINE> __all__ = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE>
def test_basic ( self ) : <NEWLINE> <INDENT> sot = health_monitor . HealthMonitor ( ) <NEWLINE> self . assertEqual ( <STRING> , sot . resource_key ) <NEWLINE> self . assertEqual ( <STRING> , sot . resources_key ) <NEWLINE> self . assertEqual ( <STRING> , sot . base_path ) <NEWLINE> self . assertEqual ( <STRING> , sot . service . service_type ) <NEWLINE> self . assertTrue ( sot . allow_create ) <NEWLINE> self . assertTrue ( sot . allow_retrieve ) <NEWLINE> self . assertTrue ( sot . allow_update ) <NEWLINE> self . assertTrue ( sot . allow_delete ) <NEWLINE> self . assertTrue ( sot . allow_list ) <NEWLINE> <DEDENT>
def config ( self , app = None , cpu = None , cores = None , cache = None , ** params ) : <NEWLINE> <INDENT> r = CPULimitedHost . config ( self , cpu , cores , ** params ) <NEWLINE> self . setParam ( r , <STRING> , app = app ) <NEWLINE> self . setParam ( r , <STRING> , cache = cache ) <NEWLINE> return r <NEWLINE> <DEDENT>
def load_config ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if os . path . isfile ( <STRING> ) : <NEWLINE> <INDENT> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> config = json . load ( f ) <NEWLINE> <DEDENT> return config <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return dict ( ) <NEWLINE> <DEDENT> <DEDENT>
class LanguageChangerMixin ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def get ( self , request , * args , ** kwargs ) : <NEWLINE> <INDENT> if not hasattr ( self , <STRING> ) : <NEWLINE> <INDENT> self . object = self . get_object ( ) <NEWLINE> <DEDENT> set_language_changer ( request , self . object . get_absolute_url ) <NEWLINE> return super ( LanguageChangerMixin , self ) . get ( request , * args , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT>
from __future__ import absolute_import <NEWLINE> from __future__ import print_function <NEWLINE> from __future__ import unicode_literals <NEWLINE> from setuptools import setup <NEWLINE> setup ( <NEWLINE> <INDENT> name = str ( <STRING> ) , <NEWLINE> version = <STRING> , <NEWLINE> url = <STRING> , <NEWLINE> author = <STRING> , <NEWLINE> author_email = <STRING> , <NEWLINE> py_modules = [ str ( <STRING> ) ] , <NEWLINE> entry_points = { <NEWLINE> <INDENT> <STRING> : [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <DEDENT> ] , <NEWLINE> <DEDENT> } , <NEWLINE> <DEDENT> ) <NEWLINE>
def test_finish_job_started_registry ( redis ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> yield from enqueue_job ( redis = redis , ** stubs . job ) <NEWLINE> stored_id , stored_spec = yield from dequeue_job ( redis , stubs . queue ) <NEWLINE> stored_id = stored_id . decode ( ) <NEWLINE> queue = stored_spec [ <STRING> ] . decode ( ) <NEWLINE> timeout = stored_spec [ <STRING> ] <NEWLINE> yield from start_job ( redis , queue , stored_id , timeout ) <NEWLINE> yield from finish_job ( redis , queue , stored_id , stubs . job_result ) <NEWLINE> assert not ( yield from started_jobs ( redis , stubs . queue ) ) <NEWLINE> <DEDENT>
def test_previous_and_next_in_order ( self ) : <NEWLINE> <INDENT> a1 = self . q1 . answer_set . all ( ) [ 0 ] <NEWLINE> self . assertEqual ( a1 . text , <STRING> ) <NEWLINE> self . assertEqual ( a1 . get_next_in_order ( ) . text , <STRING> ) <NEWLINE> a2 = list ( self . q1 . answer_set . all ( ) ) [ - 1 ] <NEWLINE> self . assertEqual ( a2 . text , <STRING> ) <NEWLINE> self . assertEqual ( a2 . get_previous_in_order ( ) . text , <STRING> ) <NEWLINE> <DEDENT>
def is_disconnect ( self , e , connection , cursor ) : <NEWLINE> <INDENT> for msg in ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <DEDENT> ) : <NEWLINE> <INDENT> if msg in str ( e ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT>
def test_post_auth_digest ( self ) : <NEWLINE> <INDENT> auth = HTTPDigestAuth ( <STRING> , <STRING> ) <NEWLINE> self . _http = self . successResultOf ( <NEWLINE> <INDENT> httpclientservice . HTTPClientService . getService ( self . parent , <STRING> , <NEWLINE> <INDENT> auth = auth ) ) <NEWLINE> <DEDENT> <DEDENT> self . _http . post ( <STRING> , data = { <STRING> : <STRING> } ) <NEWLINE> self . _http . _session . request . assert_called_once_with ( <STRING> , <STRING> , <NEWLINE> <INDENT> background_callback = mock . ANY , <NEWLINE> data = dict ( <NEWLINE> <INDENT> foo = <STRING> ) , <NEWLINE> <DEDENT> auth = auth , <NEWLINE> headers = { <NEWLINE> } ) <NEWLINE> <DEDENT> <DEDENT>
from . git_commit_utils import * <NEWLINE> from . git_etl import GitETL <NEWLINE> from . git_client import GitClient <NEWLINE>
def assertContent ( self , vt , content ) : <NEWLINE> <INDENT> with open ( os . path . join ( vt . results_dir , self . _filename ) , <STRING> ) as f : <NEWLINE> <INDENT> self . assertEquals ( f . read ( ) , content ) <NEWLINE> <DEDENT> <DEDENT>
def replaceNone ( input ) : <NEWLINE> <INDENT> if input is None : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return input <NEWLINE> <DEDENT> <DEDENT>
from warnings import warn <NEWLINE> from djangotoolbox . fields import RawField , AbstractIterableField , EmbeddedModelField <NEWLINE> __all__ = [ <STRING> ] <NEWLINE> DJANGOTOOLBOX_FIELDS = ( RawField , AbstractIterableField , EmbeddedModelField ) <NEWLINE>
class Comment ( APIMixin , Base ) : <NEWLINE> <INDENT> __tablename__ = <STRING> <NEWLINE> id = Column ( Integer , primary_key = True ) <NEWLINE> content = Column ( UnicodeText ) <NEWLINE> user_id = Column ( Integer , ForeignKey ( <STRING> ) ) <NEWLINE> post_id = Column ( Integer , ForeignKey ( <STRING> ) ) <NEWLINE> user = relationship ( <STRING> , lazy = <STRING> , <NEWLINE> <INDENT> backref = backref ( <STRING> , lazy = <STRING> ) ) <NEWLINE> <DEDENT> post = relationship ( <STRING> , lazy = <STRING> , <NEWLINE> <INDENT> backref = backref ( <STRING> , lazy = <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , frame_buffer , movie_length ) : <NEWLINE> <INDENT> self . last_time = self . current_milli_time ( ) <NEWLINE> self . current_frame = 0 <NEWLINE> self . frame_buffer = frame_buffer <NEWLINE> self . movie_length = movie_length <NEWLINE> self . times = [ ] <NEWLINE> threading . Thread . __init__ ( self ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from __future__ import unicode_literals <NEWLINE> import os <NEWLINE> import sys <NEWLINE> import time <NEWLINE> import subprocess <NEWLINE> from tempfile import TemporaryFile <NEWLINE> import warnings <NEWLINE> from applib . misc import xjoin <NEWLINE> from applib . misc import safe_unicode <NEWLINE> __all__ = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> warnings . filterwarnings ( <STRING> , message = <STRING> , <NEWLINE> <INDENT> category = DeprecationWarning ) <NEWLINE> <DEDENT>
def setUp ( self ) : <NEWLINE> <INDENT> self . crud . delete ( self . ncc , ietf_aug_base_1 . Cpython ( ) ) <NEWLINE> self . crud . delete ( self . ncc , ietf_aug_base_2 . Cpython ( ) ) <NEWLINE> <DEDENT>
import re <NEWLINE> from json . decoder import JSONDecoder <NEWLINE> __all__ = ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> <NEWLINE> <DEDENT> ) <NEWLINE>
def __init__ ( self , nmarea , g2area , nmmodule , options ) : <NEWLINE> <INDENT> lev = nmmodule . params . Level <NEWLINE> if getv ( lev ) == 127 and not lev . knob and not lev . morph and not lev . ctrl : <NEWLINE> <INDENT> self . maing2module = <STRING> <NEWLINE> <DEDENT> if len ( filter ( isxoutput , nmarea . modules ) ) < 2 : <NEWLINE> <INDENT> self . maing2module = <STRING> <NEWLINE> <DEDENT> Convert . __init__ ( self , nmarea , g2area , nmmodule , options ) <NEWLINE> <DEDENT>
def keepInWindow ( self ) : <NEWLINE> <INDENT> x , y = self . position <NEWLINE> if self . outOfBoundsLeft ( ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> elif self . outOfBoundsRight ( ) : <NEWLINE> <INDENT> x = GameConstants . SCREEN_SIZE [ 0 ] - self . size [ 0 ] <NEWLINE> <DEDENT> elif self . outOfBoundsAbove ( ) : <NEWLINE> <INDENT> y = 0 <NEWLINE> <DEDENT> elif self . outOfBoundsBelow ( ) : <NEWLINE> <INDENT> y = GameConstants . SCREEN_SIZE [ 1 ] - self . size [ 1 ] <NEWLINE> <DEDENT> self . position = ( x , y ) <NEWLINE> <DEDENT>
import sqlite3 <NEWLINE> import os <NEWLINE> try : <NEWLINE> <INDENT> os . remove ( <STRING> ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> db = sqlite3 . connect ( <STRING> ) <NEWLINE> c = db . cursor ( ) <NEWLINE> c . execute ( <STRING> ) <NEWLINE> c . execute ( <STRING> ) <NEWLINE> for line in open ( <STRING> ) : <NEWLINE> <INDENT> values = line [ : - 1 ] . split ( <STRING> ) <NEWLINE> c . execute ( <STRING> , values ) <NEWLINE> <DEDENT> c . execute ( <NEWLINE> <STRING> ) <NEWLINE> c . execute ( <STRING> ) <NEWLINE> c . execute ( <STRING> ) <NEWLINE>
class TestCommand ( ExternCmdPackagerBase ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> name = <STRING> <NEWLINE> pkgtype = <STRING> <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> ExternCmdPackagerBase . __init__ ( self ) <NEWLINE> self . packager = ExternalTestCmd ( self . log ) <NEWLINE> <DEDENT> def supported ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT>
def test_get_cached_minifest_caching_force ( self , storage_mock ) : <NEWLINE> <INDENT> storage_mock . size . return_value = 999 <NEWLINE> minifest = json . loads ( get_cached_minifest ( self . webapp ) [ 0 ] ) <NEWLINE> eq_ ( minifest [ <STRING> ] , 999 ) <NEWLINE> storage_mock . size . return_value = 666 <NEWLINE> new_minifest = json . loads ( <NEWLINE> <INDENT> get_cached_minifest ( self . webapp , force = True ) [ 0 ] ) <NEWLINE> <DEDENT> ok_ ( new_minifest != minifest ) <NEWLINE> eq_ ( new_minifest [ <STRING> ] , 666 ) <NEWLINE> <DEDENT>
def inject_nomination_status ( organizations , assume_nominated = False ) : <NEWLINE> <INDENT> nominations = { } <NEWLINE> if c . user_is_loggedin : <NEWLINE> <INDENT> if not assume_nominated : <NEWLINE> <INDENT> nominations = DonationNominationsByAccount . fast_query ( <NEWLINE> <INDENT> c . user , organizations ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> nominations = { ( c . user , org ) : True for org in organizations } <NEWLINE> <DEDENT> <DEDENT> wrapped = [ ] <NEWLINE> for org in organizations : <NEWLINE> <INDENT> data = org . data . copy ( ) <NEWLINE> data [ <STRING> ] = ( c . user , org ) in nominations <NEWLINE> wrapped . append ( data ) <NEWLINE> <DEDENT> return wrapped <NEWLINE> <DEDENT>
def select_data_assets ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . _select ( element . WidgetBar . DATA_ASSETS ) <NEWLINE> <DEDENT>
import os . path <NEWLINE> from sqlalchemy import create_engine <NEWLINE> from sqlalchemy . orm import scoped_session , sessionmaker <NEWLINE> from sqlalchemy . ext . declarative import declarative_base <NEWLINE> engine = create_engine ( <STRING> , convert_unicode = True ) <NEWLINE> session = scoped_session ( sessionmaker ( autocommit = False , autoflush = False , <NEWLINE> <INDENT> bind = engine ) ) <NEWLINE> <DEDENT> Base = declarative_base ( ) <NEWLINE> Base . query = session . query_property ( ) <NEWLINE>
def __init__ ( self , capacity , speed ) : <NEWLINE> <INDENT> self . cap = capacity <NEWLINE> self . speed = speed <NEWLINE> self . onBus = 0 <NEWLINE> <DEDENT>
class CreateSeriesView ( LibraryMixin , CreateView ) : <NEWLINE> <INDENT> model = Series <NEWLINE> template_name = <STRING> <NEWLINE> fields = [ <STRING> , <STRING> ] <NEWLINE> def get_success_url ( self ) : <NEWLINE> <INDENT> return reverse ( <STRING> ) <NEWLINE> <DEDENT> def get_context_data ( self , ** kwargs ) : <NEWLINE> <INDENT> context = super ( CreateSeriesView , self ) . get_context_data ( ** kwargs ) <NEWLINE> context [ <STRING> ] = reverse ( <STRING> ) <NEWLINE> return context <NEWLINE> <DEDENT> <DEDENT>
def upload_file ( request ) : <NEWLINE> <INDENT> if request . method == <STRING> : <NEWLINE> <INDENT> form = UploadFileForm ( request . POST , request . FILES ) <NEWLINE> if form . is_valid ( ) : <NEWLINE> <INDENT> handle_uploaded_file ( request . FILES [ <STRING> ] ) <NEWLINE> return HttpResponseRedirect ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> form = UploadFileForm ( ) <NEWLINE> <DEDENT> return render_to_response ( <STRING> , { <STRING> : form } ) <NEWLINE> <DEDENT>
class SwitchTelnetFactory ( Factory ) : <NEWLINE> <INDENT> def __init__ ( self , switch_core ) : <NEWLINE> <INDENT> self . switch_core = switch_core <NEWLINE> <DEDENT> def protocol ( self ) : <NEWLINE> <INDENT> return SwitchTelnetShell ( self . switch_core ) <NEWLINE> <DEDENT> <DEDENT>
def convert_to_unicode ( input_str ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if isinstance ( input_str , binary_type ) : <NEWLINE> <INDENT> input_str = input_str . decode ( <STRING> ) <NEWLINE> <DEDENT> return input_str <NEWLINE> <DEDENT>
def get_profile ( var , doy , depth , lat , lon ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return extract ( var = var , doy = doy , depth = depth , lat = lat , lon = lon ) <NEWLINE> <DEDENT>
def test_agent_default_not_present ( self ) : <NEWLINE> <INDENT> self . flags ( use_agent_default = False , group = <STRING> ) <NEWLINE> instance = { <STRING> : [ ] } <NEWLINE> self . assertFalse ( agent . should_use_agent ( instance ) ) <NEWLINE> <DEDENT>
def override_file_copy ( self , expected_from_path , expected_to_dir ) : <NEWLINE> <INDENT> def file_copy ( from_path , to_path ) : <NEWLINE> <INDENT> if not from_path . endswith ( names . PICKLED_MAIN_SESSION_FILE ) : <NEWLINE> <INDENT> self . assertEqual ( expected_from_path , from_path ) <NEWLINE> self . assertEqual ( utils . path . join ( expected_to_dir , <NEWLINE> <INDENT> names . DATAFLOW_SDK_TARBALL_FILE ) , <NEWLINE> to_path ) <NEWLINE> <DEDENT> <DEDENT> if from_path . startswith ( <STRING> ) or to_path . startswith ( <STRING> ) : <NEWLINE> <INDENT> logging . info ( <STRING> , from_path , to_path ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> shutil . copyfile ( from_path , to_path ) <NEWLINE> <DEDENT> <DEDENT> dependency . _dependency_file_copy = file_copy <NEWLINE> <DEDENT>
def iter ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return list ( self . _conversations ) <NEWLINE> <DEDENT>
def _extract_description ( self ) : <NEWLINE> <INDENT> section = self . soup . select ( <NEWLINE> <INDENT> <STRING> ) [ 0 ] . select ( <STRING> ) [ 0 ] <NEWLINE> <DEDENT> collapsed = section . select ( <STRING> ) <NEWLINE> description = <STRING> <NEWLINE> if ( collapsed ) : <NEWLINE> <INDENT> expanded = section . select ( <STRING> ) <NEWLINE> description = ( collapsed [ 0 ] . text + expanded [ 0 ] . text ) . strip ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> description = ( section . text . strip ( ) ) <NEWLINE> <DEDENT> return ( description ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from django . conf import settings <NEWLINE> from django . core . exceptions import ImproperlyConfigured <NEWLINE> from spotseeker_server . load_module import load_object_by_name <NEWLINE>
def advertising_save ( self , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . _save ( advertising_form , <STRING> , values = kwargs ) <NEWLINE> <DEDENT>
def decode_jwt ( self , token ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import jwt <NEWLINE> target_check = jwt . decode ( token , verify = False ) <NEWLINE> if target_check [ ATTR_TARGET ] in self . registrations : <NEWLINE> <INDENT> possible_target = self . registrations [ target_check [ ATTR_TARGET ] ] <NEWLINE> key = possible_target [ ATTR_SUBSCRIPTION ] [ ATTR_KEYS ] [ ATTR_AUTH ] <NEWLINE> try : <NEWLINE> <INDENT> return jwt . decode ( token , key ) <NEWLINE> <DEDENT> except jwt . exceptions . DecodeError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> return self . json_message ( <STRING> , <NEWLINE> <INDENT> status_code = HTTP_UNAUTHORIZED ) <NEWLINE> <DEDENT> <DEDENT>
def deploy ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> env . host_string = config . HOST_STRING <NEWLINE> with cd ( <STRING> ) : <NEWLINE> <INDENT> with shell_env ( MODE = <STRING> ) : <NEWLINE> <INDENT> run ( <STRING> ) <NEWLINE> run ( <STRING> ) <NEWLINE> with prefix ( <STRING> ) : <NEWLINE> <INDENT> run ( <STRING> ) <NEWLINE> run ( <STRING> ) <NEWLINE> run ( <STRING> ) <NEWLINE> <DEDENT> run ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def Draw ( obj , jsDrawMethod = <STRING> , objIsJSON = False ) : <NEWLINE> <INDENT> if objIsJSON : <NEWLINE> <INDENT> dat = obj <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dat = ROOT . TBufferJSON . ConvertToJSON ( obj ) <NEWLINE> dat = str ( dat ) . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> JsDraw . __divUID += 1 <NEWLINE> display ( HTML ( JsDraw . __jsCode . substitute ( { <NEWLINE> <INDENT> <STRING> : jsDrawMethod , <NEWLINE> <STRING> : <STRING> + str ( JsDraw . __divUID ) , <NEWLINE> <STRING> : dat , <NEWLINE> <STRING> : JsDraw . jsCanvasWidth , <NEWLINE> <STRING> : JsDraw . jsCanvasHeight <NEWLINE> } ) ) ) <NEWLINE> <DEDENT> <DEDENT>
def togglestate ( ) : <NEWLINE> <INDENT> new_state = not get_pyrevit_env_var ( SYNC_VIEW_ENV_VAR ) <NEWLINE> set_pyrevit_env_var ( SYNC_VIEW_ENV_VAR , new_state ) <NEWLINE> this_script . toggle_icon ( new_state ) <NEWLINE> <DEDENT>
def rsum ( so_far , place ) : <NEWLINE> <INDENT> global coins , ways <NEWLINE> coin = coins [ place ] <NEWLINE> max_p = ( 200 - so_far ) / coin + 1 <NEWLINE> for p in xrange ( max_p ) : <NEWLINE> <INDENT> with_p_coins = so_far + coin * p <NEWLINE> if with_p_coins == 200 : <NEWLINE> <INDENT> ways += 1 <NEWLINE> <DEDENT> if with_p_coins < 200 and place + 1 < len ( coins ) : <NEWLINE> <INDENT> rsum ( with_p_coins , place + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from actions import script <NEWLINE> print ( script . run ( 1 , { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <DEDENT> } ) ) <NEWLINE>
def NG50 ( numlist , reference_length , percentage = 50.0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> assert percentage >= 0.0 <NEWLINE> assert percentage <= 100.0 <NEWLINE> numlist . sort ( reverse = True ) <NEWLINE> s = reference_length <NEWLINE> limit = reference_length * ( 100.0 - percentage ) / 100.0 <NEWLINE> for l in numlist : <NEWLINE> <INDENT> s -= l <NEWLINE> if s <= limit : <NEWLINE> <INDENT> return l <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class PRC ( DstTzInfo ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> zone = <STRING> <NEWLINE> <DEDENT>
class BaseMagnet ( BaseElement ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def _mad_backend ( self ) : <NEWLINE> <INDENT> return self . _construct ( self . mad_cls ( ) ) <NEWLINE> <DEDENT> @ property <NEWLINE> def dvm_params ( self ) : <NEWLINE> <INDENT> return self . dvm_converter . param_info <NEWLINE> <DEDENT> <DEDENT>
def test_index_of ( self , predicate , iterable , expected ) : <NEWLINE> <INDENT> actual = index_of ( predicate , iterable ) <NEWLINE> self . assertEqual ( actual , expected ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> __author__ = <STRING> <NEWLINE> __copyright__ = <STRING> <NEWLINE> __license__ = <STRING> <NEWLINE> __maintainer__ = <STRING> <NEWLINE> __email__ = <STRING> <NEWLINE> __status__ = <STRING> <NEWLINE> __all__ = [ ] <NEWLINE> import sys <NEWLINE> sys . setdefaultencoding ( <STRING> ) <NEWLINE>
def _auditpol_import ( ) : <NEWLINE> <INDENT> dict_return = { } <NEWLINE> export = _auditpol_export ( ) <NEWLINE> auditpol_csv = csv . DictReader ( export ) <NEWLINE> for row in auditpol_csv : <NEWLINE> <INDENT> if row : <NEWLINE> <INDENT> dict_return [ row [ <STRING> ] ] = row [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT> return dict_return <NEWLINE> <DEDENT>
class OverusedBufferScrapy ( OverusedBuffer ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def _get_key ( self , request , type ) : <NEWLINE> <INDENT> key = urlparse_cached ( request ) . hostname or <STRING> <NEWLINE> if type == <STRING> : <NEWLINE> <INDENT> key = dnscache . get ( key , key ) <NEWLINE> <DEDENT> return key <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from nltk_contrib import classify <NEWLINE> from nltk import detect <NEWLINE> from nltk . corpus import udhr <NEWLINE> import string <NEWLINE>
<STRING> <NEWLINE> __author__ = <STRING> <NEWLINE> import string <NEWLINE> import iptables <NEWLINE> import nacaddr <NEWLINE>
def test_no_int_if_ifs ( self ) : <NEWLINE> <INDENT> params = self . params . copy ( ) <NEWLINE> del params [ <STRING> ] <NEWLINE> system = self . system_class ( ** params ) <NEWLINE> self . assertSequenceEqual ( system . int_if . ifsv4 , [ ipaddress . IPv4Interface ( <STRING> ) ] , <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> self . assertSequenceEqual ( self . system . int_if . ifsv6 , [ ipaddress . IPv6Interface ( <STRING> ) ] , <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class SkiaBuildbotDesktopPage ( page_module . Page ) : <NEWLINE> <INDENT> def __init__ ( self , url , page_set ) : <NEWLINE> <INDENT> super ( SkiaBuildbotDesktopPage , self ) . __init__ ( <NEWLINE> <INDENT> url = url , <NEWLINE> page_set = page_set , <NEWLINE> credentials_path = <STRING> ) <NEWLINE> <DEDENT> self . user_agent_type = <STRING> <NEWLINE> self . archive_data_file = <STRING> <NEWLINE> <DEDENT> def RunNavigateSteps ( self , action_runner ) : <NEWLINE> <INDENT> action_runner . NavigateToPage ( self ) <NEWLINE> action_runner . Wait ( 90 ) <NEWLINE> <DEDENT> <DEDENT>
def client ( self ) : <NEWLINE> <INDENT> return client_context ( addressbook . AddressBookService , <NEWLINE> <INDENT> host = <STRING> , port = self . PORT , <NEWLINE> proto_factory = self . PROTOCOL_FACTORY , <NEWLINE> trans_factory = self . TRANSPORT_FACTORY ) <NEWLINE> <DEDENT> <DEDENT>
