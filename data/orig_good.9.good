class ASCIIFileSystemStorage ( FileSystemStorage ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def get_valid_name ( self , name ) : <NEWLINE> <INDENT> if not isinstance ( name , unicode ) : <NEWLINE> <INDENT> name = unicode ( name ) <NEWLINE> <DEDENT> name = unicodedata . normalize ( <STRING> , name ) . encode ( <STRING> , <STRING> ) <NEWLINE> return super ( ASCIIFileSystemStorage , self ) . get_valid_name ( name ) <NEWLINE> <DEDENT> <DEDENT>
def testGetInfo ( self ) : <NEWLINE> <INDENT> info = self . Server . info ( ) <NEWLINE> self . assert_ ( info . has_key ( <STRING> ) ) <NEWLINE> <DEDENT>
def example ( ) : <NEWLINE> <INDENT> f = open ( INPUT ) <NEWLINE> while 1 : <NEWLINE> <INDENT> gid = codes_grib_new_from_file ( f ) <NEWLINE> if gid is None : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> iterid = codes_keys_iterator_new ( gid , <STRING> ) <NEWLINE> while codes_keys_iterator_next ( iterid ) : <NEWLINE> <INDENT> keyname = codes_keys_iterator_get_name ( iterid ) <NEWLINE> keyval = codes_get_string ( iterid , keyname ) <NEWLINE> print ( <STRING> % ( keyname , keyval ) ) <NEWLINE> <DEDENT> codes_keys_iterator_delete ( iterid ) <NEWLINE> codes_release ( gid ) <NEWLINE> <DEDENT> f . close ( ) <NEWLINE> <DEDENT>
def getOtherStats ( dir , distance_threshold , size_threshold ) : <NEWLINE> <INDENT> import clone_refiner <NEWLINE> stat = clone_refiner . main ( dir , distance_threshold , size_threshold , True ) <NEWLINE> for i in stat : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> j = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> j += 1 <NEWLINE> n = j * ( 3 * j - 1 ) // 2 <NEWLINE> for k in range ( j - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> m = k * ( 3 * k - 1 ) // 2 <NEWLINE> if ( is_pentagonal ( n - m ) and is_pentagonal ( n + m ) ) : <NEWLINE> <INDENT> return n - m <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<STRING> <NEWLINE> __author__ = <STRING> <NEWLINE> __svnid__ = <STRING> <NEWLINE> __revision__ = <STRING> <NEWLINE> __all__ = [ <STRING> , ] <NEWLINE> import wx <NEWLINE> import signal <NEWLINE> import collections <NEWLINE> HASWIN32 = False <NEWLINE> if wx . Platform == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> import win32api <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> HASWIN32 = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> HASWIN32 = True <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> f = file ( sys . argv [ 2 ] , <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> for line in file ( sys . argv [ 1 ] ) : <NEWLINE> <INDENT> line = re . sub ( <STRING> , <STRING> , line ) <NEWLINE> f . write ( line ) <NEWLINE> <DEDENT> <DEDENT> finally : <NEWLINE> <INDENT> f . close ( ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , toolboxdef ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . __gobject_init__ ( ) <NEWLINE> self . buttons = [ ] <NEWLINE> self . shortcuts = { } <NEWLINE> self . _construct ( toolboxdef ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from __future__ import division <NEWLINE> from __future__ import print_function <NEWLINE> from __future__ import unicode_literals <NEWLINE> from __future__ import absolute_import <NEWLINE> import datetime <NEWLINE> from south . db import db <NEWLINE> from south . v2 import DataMigration <NEWLINE> from django . conf import settings <NEWLINE> from django . db import models <NEWLINE>
def add_alias_for ( lang , alias , mapper ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> alias_list = mapper [ lang ] . setdefault ( <STRING> , [ ] ) <NEWLINE> alias_list . append ( alias ) <NEWLINE> <DEDENT>
class RegexValidatorTests ( TestCase ) : <NEWLINE> <INDENT> def test_valid_string ( self ) : <NEWLINE> <INDENT> valid_string = <STRING> <NEWLINE> eq_ ( validate_regex ( valid_string ) , valid_string ) <NEWLINE> <DEDENT> def test_valid_regex ( self ) : <NEWLINE> <INDENT> valid_regex = <STRING> <NEWLINE> eq_ ( validate_regex ( valid_regex ) , valid_regex ) <NEWLINE> <DEDENT> def test_invalid_regex ( self ) : <NEWLINE> <INDENT> bogus_regex = <STRING> <NEWLINE> assert_raises ( ValidationError , validate_regex , bogus_regex ) <NEWLINE> <DEDENT> <DEDENT>
def set_started ( self , date = None ) : <NEWLINE> <INDENT> if isinstance ( date , NoneType ) : <NEWLINE> <INDENT> self . _started = datetime . datetime . utcnow ( ) . isoformat ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . _started = date <NEWLINE> <DEDENT> <DEDENT>
import pandas as pd <NEWLINE> import numpy as np <NEWLINE> import re <NEWLINE> import copy <NEWLINE> from math import * <NEWLINE> from datetime import datetime <NEWLINE> import networkx as nx <NEWLINE>
def spySetMax ( env , max ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> env . spy . setMax ( max ) <NEWLINE> return <STRING> <NEWLINE> <DEDENT>
from GlobalHeader import * <NEWLINE> from mrjob . compat import get_jobconf_value <NEWLINE> from mrjob . job import MRJob <NEWLINE> from mrjob . protocol import JSONProtocol <NEWLINE> from mrjob . step import MRStep <NEWLINE> import math <NEWLINE> import sys <NEWLINE>
def __init__ ( self ) : <NEWLINE> <INDENT> self . _pos = 0 <NEWLINE> self . _positionsHit = { } <NEWLINE> for i in range ( boardSize ) : <NEWLINE> <INDENT> self . _positionsHit [ i ] = 0 <NEWLINE> <DEDENT> self . _doublesTurns = 0 <NEWLINE> self . _jailed = False <NEWLINE> self . _jailedTurns = 0 <NEWLINE> self . _turns = 0 <NEWLINE> <DEDENT>
def __init__ ( self , callback = None , ttype = None , source = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . group = Group ( ) <NEWLINE> self . task_queue = Queue ( ) <NEWLINE> self . task_type = ttype <NEWLINE> self . cb = callback <NEWLINE> self . source = source <NEWLINE> self . task_name = <STRING> % ( socket . gethostname ( ) , <NEWLINE> <INDENT> self . source , <NEWLINE> self . task_type ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import logging <NEWLINE> logging . basicConfig ( level = <STRING> ) <NEWLINE> import matplotlib <NEWLINE> matplotlib . use ( <STRING> ) <NEWLINE> import matplotlib . pyplot as plt <NEWLINE> import numpy as np <NEWLINE> import mlp <NEWLINE> print ( <STRING> ) <NEWLINE> np . random . seed ( 750 ) <NEWLINE> N_TRAIN = 100000 <NEWLINE> N_TEST = 1000 <NEWLINE> NOISE_STDDEV = 0.1 <NEWLINE> PATH_TRAIN = <STRING> <NEWLINE> PATH_TEST = <STRING> <NEWLINE>
from django . db import models <NEWLINE> from edc_base . audit_trail import AuditTrail <NEWLINE> from edc_base . model . models import BaseUuidModel <NEWLINE> from edc_lab . lab_packing . models import PackingListMixin <NEWLINE> from edc_sync . models import SyncModelMixin <NEWLINE> from . . managers import PackingListManager <NEWLINE>
import argparse <NEWLINE> import smtplib <NEWLINE> import os <NEWLINE> import getpass <NEWLINE> from email . mime . text import MIMEText <NEWLINE> import sys <NEWLINE> sys . path . insert ( 0 , <STRING> ) <NEWLINE> from conf import work_dir <NEWLINE> from options import cfg2dict <NEWLINE> from build_template import _from_template <NEWLINE> args = None <NEWLINE> password = None <NEWLINE>
def fetch ( self , url ) : <NEWLINE> <INDENT> response = requests . get ( url ) <NEWLINE> return response . content <NEWLINE> <DEDENT>
def getText ( self ) : <NEWLINE> <INDENT> assert self . type not in ( self . LOCK , self . SLOT_NUMBER ) , <STRING> <NEWLINE> percent = None <NEWLINE> if self . type == self . SNRTEXT : <NEWLINE> <INDENT> percent = self . source . snr <NEWLINE> <DEDENT> elif self . type == self . AGCTEXT : <NEWLINE> <INDENT> percent = self . source . agc <NEWLINE> <DEDENT> if percent is None : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return <STRING> % ( percent * 100 / 65536 ) <NEWLINE> <DEDENT>
def do_ecuRegister ( self , data ) : <NEWLINE> <INDENT> if data [ <STRING> ] == <STRING> : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> elif data [ <STRING> ] . startswith ( <STRING> ) : <NEWLINE> <INDENT> self . send_response ( int ( data [ <STRING> ] [ 7 : ] ) ) <NEWLINE> self . end_headers ( ) <NEWLINE> <DEDENT> elif data [ <STRING> ] == <STRING> : <NEWLINE> <INDENT> self . send_response ( 200 ) <NEWLINE> self . end_headers ( ) <NEWLINE> self . wfile . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from mpi4py import MPI <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> comm = MPI . COMM_WORLD <NEWLINE> rank = comm . Get_rank ( ) <NEWLINE> size = comm . Get_size ( ) <NEWLINE> send_buffer = [ rank * size + i for i in range ( size ) ] <NEWLINE> data = comm . alltoall ( send_buffer ) <NEWLINE> print ( <STRING> . format ( rank , <STRING> . join ( ( str ( x ) for x in data ) ) ) ) <NEWLINE> <DEDENT>
from __future__ import unicode_literals <NEWLINE> from optparse import make_option <NEWLINE> from django . core . management . base import NoArgsCommand <NEWLINE> from docutil . cache_util import clear_cache <NEWLINE> from docutil . commands_util import recocommand <NEWLINE> from docutil . str_util import smart_decode <NEWLINE> from codebase . actions import link_code <NEWLINE>
def login ( self , password ) : <NEWLINE> <INDENT> response = self . session . post ( self . base_url + <STRING> , { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : password , <NEWLINE> <DEDENT> } ) <NEWLINE> match = re . search ( <STRING> , response . text ) <NEWLINE> if match : <NEWLINE> <INDENT> return match . group ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . stok = re . search ( <STRING> , response . text ) . group ( ) <NEWLINE> self . api_base_url = self . base_url + <STRING> + self . stok + <STRING> <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , notification_owner_id , notification_author_id , analysis_comment_id ) : <NEWLINE> <INDENT> Notification . __init__ ( self , notification_owner_id , notification_author_id ) <NEWLINE> self . analysis_comment_id = analysis_comment_id <NEWLINE> <DEDENT>
def get_function_abi ( cpu , os , machine ) : <NEWLINE> <INDENT> if os == <STRING> and machine == <STRING> : <NEWLINE> <INDENT> return I386CdeclAbi ( cpu ) <NEWLINE> <DEDENT> elif os == <STRING> and machine == <STRING> : <NEWLINE> <INDENT> return SystemVAbi ( cpu ) <NEWLINE> <DEDENT> elif os == <STRING> and machine == <STRING> : <NEWLINE> <INDENT> return Armv7CdeclAbi ( cpu ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return NotImplementedError ( <STRING> . format ( os , machine ) ) <NEWLINE> <DEDENT> <DEDENT>
def load_flows ( self , flows ) : <NEWLINE> <INDENT> for i in flows : <NEWLINE> <INDENT> if i . response : <NEWLINE> <INDENT> l = self . flowmap . setdefault ( self . _hash ( i ) , [ ] ) <NEWLINE> l . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def forwards ( self , orm ) : <NEWLINE> <INDENT> db . create_table ( <STRING> , ( <NEWLINE> <INDENT> ( <STRING> , self . gf ( <STRING> ) ( primary_key = True ) ) , <NEWLINE> ( <STRING> , self . gf ( <STRING> ) ( max_length = 60 ) ) , <NEWLINE> ( <STRING> , self . gf ( <STRING> ) ( ) ) , <NEWLINE> ( <STRING> , self . gf ( <STRING> ) ( max_length = 200 ) ) , <NEWLINE> ( <STRING> , self . gf ( <STRING> ) ( default = False ) ) , <NEWLINE> <DEDENT> ) ) <NEWLINE> db . send_create_signal ( <STRING> , [ <STRING> ] ) <NEWLINE> <DEDENT>
def backward ( self , indexes , grad_outputs ) : <NEWLINE> <INDENT> x , gamma = self . get_retained_inputs ( ) <NEWLINE> gy , = grad_outputs <NEWLINE> f = BatchNormalizationGrad ( <NEWLINE> <INDENT> self . eps , self . use_cudnn , self . mode , self . expander , self . axis , <NEWLINE> self . mean , self . inv_std ) <NEWLINE> <DEDENT> return f ( x , gamma , gy ) <NEWLINE> <DEDENT>
import math <NEWLINE> from pyspark import SparkConf , SparkContext <NEWLINE> from pyspark . sql import SQLContext , functions as sqlfunctions , types <NEWLINE> from pyspark . tests import QuietTest as SuppressSparkLogs <NEWLINE> from graphframes import GraphFrame <NEWLINE> from graphframes . lib import AggregateMessages as AM <NEWLINE> import graphframes . examples <NEWLINE> __all__ = [ <STRING> ] <NEWLINE>
from gym import Env <NEWLINE> import matplotlib . pyplot as plt <NEWLINE> import numpy as np <NEWLINE>
import sys <NEWLINE> import os <NEWLINE> from os import path <NEWLINE> sys . path . append ( <STRING> ) <NEWLINE> from igor . vcs . git import Git <NEWLINE>
import re <NEWLINE> import datetime <NEWLINE> from south . db import db <NEWLINE> from south . v2 import DataMigration <NEWLINE> from django . db import models <NEWLINE> from transifex . resources . models import ( Resource , SourceEntity , Translation , <NEWLINE> <INDENT> Template ) <NEWLINE> <DEDENT> from xml . sax . saxutils import escape , unescape <NEWLINE>
def backspace ( self , length ) : <NEWLINE> <INDENT> for _ in range ( length ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> sys . stdout . flush ( ) <NEWLINE> self . typing_change ( ) <NEWLINE> time . sleep ( self . type_delay ) <NEWLINE> <DEDENT> <DEDENT>
class Node ( object ) : <NEWLINE> <INDENT> def __init__ ( self , data = None , previous = None ) : <NEWLINE> <INDENT> self . data = data <NEWLINE> self . previous = previous <NEWLINE> <DEDENT> <DEDENT>
from Axon . AxonExceptions import AxonException as _AxonException <NEWLINE> class socketSendFailure ( _AxonException ) : pass <NEWLINE> class connectionClosedown ( _AxonException ) : pass <NEWLINE> class connectionDied ( connectionClosedown ) : pass <NEWLINE> class connectionDiedSending ( connectionDied ) : pass <NEWLINE> class connectionDiedReceiving ( connectionDied ) : pass <NEWLINE> class connectionServerShutdown ( connectionClosedown ) : pass <NEWLINE>
def test ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> global curDict <NEWLINE> if fail : <NEWLINE> <INDENT> import defaultPresets <NEWLINE> curDict = defaultPresets . defPresetDict <NEWLINE> <DEDENT> <DEDENT>
class TestController ( Sofa . PythonScriptController ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> def onBeginAnimationStep ( self , v ) : <NEWLINE> <INDENT> name = self . findData ( <STRING> ) <NEWLINE> name . setValue ( 123 ) <NEWLINE> <DEDENT> def onEndAnimationStep ( self , v ) : <NEWLINE> <INDENT> name = self . findData ( <STRING> ) <NEWLINE> name . setValue ( 123 ) <NEWLINE> <DEDENT> def f2 ( self ) : <NEWLINE> <INDENT> f3 ( ) <NEWLINE> <DEDENT> def draw ( self ) : <NEWLINE> <INDENT> self . f2 ( ) <NEWLINE> <DEDENT> <DEDENT>
class BugreportTests ( unittest . TestCase ) : <NEWLINE> <INDENT> def test_default ( self ) : <NEWLINE> <INDENT> report = bugreport ( ) <NEWLINE> self . assertFalse ( <STRING> in report ) <NEWLINE> self . assertTrue ( <STRING> in report ) <NEWLINE> self . assertTrue ( <STRING> in report ) <NEWLINE> self . assertTrue ( <STRING> in report ) <NEWLINE> <DEDENT> def test_with_app ( self ) : <NEWLINE> <INDENT> app = Celery ( ) <NEWLINE> report = bugreport ( app ) <NEWLINE> self . assertFalse ( <STRING> in report ) <NEWLINE> self . assertTrue ( <STRING> in report ) <NEWLINE> self . assertTrue ( <STRING> in report ) <NEWLINE> self . assertTrue ( <STRING> in report ) <NEWLINE> <DEDENT> <DEDENT>
def is_prime ( num ) : <NEWLINE> <INDENT> if num < 2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for i in range ( num ) : <NEWLINE> <INDENT> if i < 2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if num % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT>
class tektronixMSO4034 ( tektronixMSO4000 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , * args , ** kwargs ) : <NEWLINE> <INDENT> self . __dict__ . setdefault ( <STRING> , <STRING> ) <NEWLINE> super ( tektronixMSO4034 , self ) . __init__ ( * args , ** kwargs ) <NEWLINE> self . _analog_channel_count = 4 <NEWLINE> self . _digital_channel_count = 16 <NEWLINE> self . _channel_count = self . _analog_channel_count + self . _digital_channel_count <NEWLINE> self . _bandwidth = 350e6 <NEWLINE> self . _init_channels ( ) <NEWLINE> <DEDENT> <DEDENT>
def get_lowest_bid_id ( self , orders ) : <NEWLINE> <INDENT> lowest_bid_id = None <NEWLINE> lowest_bid_price = float ( <STRING> ) <NEWLINE> for order in orders : <NEWLINE> <INDENT> if order [ <STRING> ] == <STRING> and float ( order [ <STRING> ] ) < lowest_bid_price : <NEWLINE> <INDENT> lowest_bid_price = float ( order [ <STRING> ] ) <NEWLINE> lowest_bid_id = order [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT> return lowest_bid_id <NEWLINE> <DEDENT>
def do_yank_pop ( self ) : <NEWLINE> <INDENT> if self . smart_match ( self . previous_key , [ <STRING> , <STRING> ] ) : <NEWLINE> <INDENT> self . owner . yank_pop ( self . yank_index ) <NEWLINE> self . yank_index -= 1 <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <DEDENT>
def code_detecter ( data ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return chardet . detect ( data ) [ <STRING> ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT>
from inspect import isgenerator <NEWLINE> from collections import namedtuple <NEWLINE> import numpy as np <NEWLINE> from scipy import linalg , sparse <NEWLINE> from . . externals . six import string_types <NEWLINE> from . . source_estimate import SourceEstimate <NEWLINE> from . . epochs import _BaseEpochs <NEWLINE> from . . evoked import Evoked , EvokedArray <NEWLINE> from . . utils import logger , _reject_data_segments , warn <NEWLINE> from . . io . pick import pick_types , pick_info <NEWLINE> from . . fixes import in1d <NEWLINE>
def __init__ ( self , textSettings , customTitle = None , customIcon = None , customThumb = None ) : <NEWLINE> <INDENT> self . textSettings = textSettings <NEWLINE> self . customTitle = customTitle <NEWLINE> self . customIcon = customIcon <NEWLINE> self . customThumb = customThumb <NEWLINE> <DEDENT>
def clear ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> sys . stdout . write ( <NEWLINE> <INDENT> self . lines * ( terminal . UP + terminal . BOL + terminal . CLEAR_EOL ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def is_fieldcode ( self , concept ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> result = False <NEWLINE> if concept . simple : <NEWLINE> <INDENT> result = self . _available ( concept . lbfc ) <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT>
def trans_status ( status , to_label = False ) : <NEWLINE> <INDENT> if asbool ( to_label ) : <NEWLINE> <INDENT> return label_status_translation . get ( status , status ) <NEWLINE> <DEDENT> return dict_status . get ( status , status ) <NEWLINE> <DEDENT>
def clone ( self , name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . id is None : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> clone_script = { <STRING> : self . id , <STRING> : name } <NEWLINE> return self . connection . post ( self . service + <STRING> , json . dumps ( clone_script ) ) <NEWLINE> <DEDENT>
def getDetail ( self , rid ) : <NEWLINE> <INDENT> url = <STRING> + rid <NEWLINE> res = self . session . get ( url ) . content . decode ( <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> res = re . findall ( <STRING> , res ) [ 0 ] . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return json . loads ( res ) <NEWLINE> <DEDENT> <DEDENT>
class ObsObject ( object ) : <NEWLINE> <INDENT> def __init__ ( self , x_rel , uvi_rel , x_abs , y_rel , y_abs ) : <NEWLINE> <INDENT> self . x_rel , self . uvi_rel , self . x_abs , self . y_rel , self . y_abs = x_rel , uvi_rel , x_abs , y_rel , y_abs <NEWLINE> <DEDENT> <DEDENT>
class fedex_message ( models . TransientModel ) : <NEWLINE> <INDENT> _name = <STRING> <NEWLINE> _description = <STRING> <NEWLINE> name = fields . Text ( <STRING> ) <NEWLINE> <DEDENT>
def test_delete_item ( ) : <NEWLINE> <INDENT> table = create_table ( ) <NEWLINE> item_data = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <DEDENT> } <NEWLINE> item = Item ( table , item_data ) <NEWLINE> item [ <STRING> ] = <STRING> <NEWLINE> item . save ( ) <NEWLINE> table . count ( ) . should . equal ( 1 ) <NEWLINE> response = item . delete ( ) <NEWLINE> response . should . equal ( True ) <NEWLINE> table . count ( ) . should . equal ( 0 ) <NEWLINE> item . delete ( ) . should . equal ( False ) <NEWLINE> <DEDENT>
import re <NEWLINE> from django import template <NEWLINE> from django . conf import settings <NEWLINE> from django . template import TemplateSyntaxError <NEWLINE> from django . utils import six <NEWLINE> from django . utils . encoding import smart_str <NEWLINE> from django_hosts . reverse import reverse_full <NEWLINE> register = template . Library ( ) <NEWLINE> kwarg_re = re . compile ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> qts = [ 0 for i in range ( 101 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> qts [ arr [ i ] ] += 1 <NEWLINE> <DEDENT> print ( n - max ( qts ) ) <NEWLINE>
def delete ( self , client = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> client = self . _require_client ( client ) <NEWLINE> api = client . subscriber_api <NEWLINE> api . subscription_delete ( self . full_name ) <NEWLINE> <DEDENT>
def json_object ( self , recursive = True ) : <NEWLINE> <INDENT> obj = { <NEWLINE> <INDENT> <STRING> : self . v_id , <NEWLINE> <STRING> : self . v_retrieval_method_type , <NEWLINE> <STRING> : self . v_retrieval_method_uri , <NEWLINE> <STRING> : self . v_cipher_reference_uri , <NEWLINE> <STRING> : <NEWLINE> <INDENT> self . v_encryption_method_algorithm , <NEWLINE> <DEDENT> <DEDENT> } <NEWLINE> return obj <NEWLINE> <DEDENT>
def predict_ints ( self , inputs ) : <NEWLINE> <INDENT> preds = self . predict_func ( self . spark , self . model , inputs ) <NEWLINE> return [ str ( p ) for p in preds ] <NEWLINE> <DEDENT>
def progress_callback ( total_downloaded , total_size ) : <NEWLINE> <INDENT> global progress_dialog <NEWLINE> if progress_dialog == None : <NEWLINE> <INDENT> progress_dialog = create_progress_dialog ( ) <NEWLINE> progress_dialog . Show ( ) <NEWLINE> <DEDENT> if total_downloaded == total_size : <NEWLINE> <INDENT> progress_dialog . Destroy ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> progress_dialog . Update ( ( total_downloaded * 100 ) / total_size , _ ( <STRING> ) % ( str ( utils . convert_bytes ( total_downloaded ) ) , str ( utils . convert_bytes ( total_size ) ) ) ) <NEWLINE> <DEDENT> <DEDENT>
def bind ( self , userargs ) : <NEWLINE> <INDENT> self . rq . bind ( userargs ) <NEWLINE> return self <NEWLINE> <DEDENT>
class BaseTestCase ( unittest . TestCase ) : <NEWLINE> <INDENT> def setUp ( self ) : <NEWLINE> <INDENT> Application . app . wsgi_app = FlaskTestClientProxy ( Application . app . wsgi_app ) <NEWLINE> Application . app . config [ <STRING> ] = True <NEWLINE> Application . app . config [ <STRING> ] = False <NEWLINE> self . app = Application . app . test_client ( ) <NEWLINE> self . _app = Application . app <NEWLINE> <DEDENT> def tearDown ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def test_sample ( self ) : <NEWLINE> <INDENT> response = self . app . get ( <STRING> ) <NEWLINE> assert <STRING> in response . data . decode ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def add_current_tie ( self , name , available_ties ) : <NEWLINE> <INDENT> if self . fit_radioButton . isChecked ( ) and self . ties_comboBox . findText ( name ) == - 1 : <NEWLINE> <INDENT> self . ties_comboBox . addItem ( name ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import os <NEWLINE> import sys <NEWLINE> from oslo_config import cfg <NEWLINE> from oslo_log import log as logging <NEWLINE> from nova . console import websocketproxy <NEWLINE> from nova . openstack . common . report import guru_meditation_report as gmr <NEWLINE> from nova import version <NEWLINE> CONF = cfg . CONF <NEWLINE> CONF . import_opt ( <STRING> , <STRING> ) <NEWLINE> CONF . import_opt ( <STRING> , <STRING> ) <NEWLINE> CONF . import_opt ( <STRING> , <STRING> ) <NEWLINE> CONF . import_opt ( <STRING> , <STRING> ) <NEWLINE> CONF . import_opt ( <STRING> , <STRING> ) <NEWLINE> CONF . import_opt ( <STRING> , <STRING> ) <NEWLINE> CONF . import_opt ( <STRING> , <STRING> ) <NEWLINE>
def test_get_printer_info ( tmpdir ) : <NEWLINE> <INDENT> ppd_path = tmpdir . join ( <STRING> ) <NEWLINE> ppd_path . write ( <STRING> ) <NEWLINE> cups = mock . Mock ( name = <STRING> ) <NEWLINE> cups . getPPD . return_value = str ( ppd_path ) <NEWLINE> cups . getPrinterAttributes . return_value = { <NEWLINE> <INDENT> <STRING> : mock . sentinel . desc <NEWLINE> <DEDENT> } <NEWLINE> ppd , description = cloudprint . get_printer_info ( cups , <STRING> ) <NEWLINE> assert ppd == <STRING> <NEWLINE> assert description == mock . sentinel . desc <NEWLINE> cups . getPPD . assert_called_with ( <STRING> ) <NEWLINE> cups . getPrinterAttributes . assert_called_with ( <STRING> ) <NEWLINE> <DEDENT>
class JsonHandler ( webapp2 . RequestHandler ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def emit_json ( self , data ) : <NEWLINE> <INDENT> self . response . headers [ <STRING> ] = <STRING> <NEWLINE> self . response . write ( json . dumps ( data ) ) <NEWLINE> <DEDENT> <DEDENT>
from __future__ import print_function <NEWLINE> try : <NEWLINE> <INDENT> import sqlite3 as sqlite <NEWLINE> <DEDENT> except ImportError as e : <NEWLINE> <INDENT> from pysqlite2 import dbapi2 as sqlite <NEWLINE> <DEDENT> from weboob . core import Weboob <NEWLINE> from weboob . exceptions import ModuleLoadError <NEWLINE> import sys <NEWLINE> import logging <NEWLINE> level = logging . DEBUG <NEWLINE> logging . basicConfig ( stream = sys . stdout , level = level ) <NEWLINE>
def executeWithPriceOnly ( self , price ) : <NEWLINE> <INDENT> currenTime = time . strftime ( <STRING> ) <NEWLINE> timeInSeconds = self . _get_sec ( currenTime ) <NEWLINE> correcpondingAlphabet = self . _findCorrespondingAlphabetForGivenTime ( timeInSeconds , self . timeFrameToAlphabetList ) <NEWLINE> if self . doStoreOnlyInHeap == True : <NEWLINE> <INDENT> self . _isAlphabetAlreadyIncludedInTheTick ( price , correcpondingAlphabet ) <NEWLINE> <DEDENT> <DEDENT>
from zeit . newsletter . newsletter import Newsletter <NEWLINE> import mock <NEWLINE> import zeit . newsletter . testing <NEWLINE>
def operation ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . _operation <NEWLINE> <DEDENT>
def __init__ ( self ) : <NEWLINE> <INDENT> addApiView ( <STRING> , self . automationView ) <NEWLINE> addApiView ( <STRING> , self . ignoreView ) <NEWLINE> <DEDENT>
def __init__ ( self , serviceName , url , failureLimit , retestDelay ) : <NEWLINE> <INDENT> self . _init ( ) <NEWLINE> ( self ) . serviceName = serviceName <NEWLINE> ( self ) . url = url <NEWLINE> ( self ) . breaker = behaviors . CircuitBreaker ( ( ( ( ( <STRING> ) + ( serviceName ) ) + ( <STRING> ) ) + ( url ) ) + ( <STRING> ) , failureLimit , retestDelay ) <NEWLINE> <DEDENT>
class Nothing ( Chain ) : <NEWLINE> <INDENT> def step ( self ) : <NEWLINE> <INDENT> globals . controller . empty_input ( ) <NEWLINE> self . interruptible = True <NEWLINE> <DEDENT> <DEDENT>
def _6 ( ) : <NEWLINE> <INDENT> gw ( 1 , 0 , 99 ) <NEWLINE> sa ( sp ( ) + sp ( ) ) ; <NEWLINE> return 7 <NEWLINE> <DEDENT>
import numpy <NEWLINE> import csv <NEWLINE> import datetime <NEWLINE> import sys <NEWLINE> import os . path <NEWLINE> unscaled_mmsi = [ 224068000 , 224098250 , 224108130 ] <NEWLINE>
from functools import wraps <NEWLINE> from django . contrib . auth . decorators import login_required <NEWLINE> from django . core . exceptions import PermissionDenied <NEWLINE> from . models import Member <NEWLINE>
class GazelleTest ( BackendTest ) : <NEWLINE> <INDENT> BACKEND = <STRING> <NEWLINE> def test_torrent ( self ) : <NEWLINE> <INDENT> l = list ( self . backend . iter_torrents ( <STRING> ) ) <NEWLINE> if len ( l ) > 0 : <NEWLINE> <INDENT> self . backend . get_torrent_file ( l [ 0 ] . id ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def ontvkg_genres ( ) : <NEWLINE> <INDENT> items = [ ] <NEWLINE> item_list = get_genres ( ) <NEWLINE> items = [ { <NEWLINE> <INDENT> <STRING> : item [ <STRING> ] , <NEWLINE> <STRING> : plugin . url_for ( <STRING> , type = <STRING> , id = item [ <STRING> ] ) , <NEWLINE> <STRING> : item [ <STRING> ] , <NEWLINE> <DEDENT> } for item in item_list ] <NEWLINE> return items <NEWLINE> <DEDENT>
def dmesg_and_objdump ( application ) : <NEWLINE> <INDENT> app_name = application . split ( <STRING> ) [ - 1 ] [ : 15 ] <NEWLINE> error , output = commands . getstatusoutput ( <STRING> ) <NEWLINE> errmsg = None <NEWLINE> for line in output . split ( <STRING> ) : <NEWLINE> <INDENT> if app_name in line : <NEWLINE> <INDENT> errmsg = line . strip ( ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> error , dottxt_asm = commands . getstatusoutput ( <STRING> % application ) <NEWLINE> return errmsg , dottxt_asm . split ( <STRING> ) <NEWLINE> <DEDENT>
def GetBookmarks ( ) : <NEWLINE> <INDENT> oc = ObjectContainer ( title2 = unicode ( L ( <STRING> ) ) ) <NEWLINE> response = service . get_bookmarks ( ) <NEWLINE> for media in archive . HandleMediaList ( response [ <STRING> ] [ <STRING> ] ) : <NEWLINE> <INDENT> oc . add ( media ) <NEWLINE> <DEDENT> return oc <NEWLINE> <DEDENT>
class Crawler ( CrawlerBase ) : <NEWLINE> <INDENT> schedule = <STRING> <NEWLINE> time_zone = <STRING> <NEWLINE> def crawl ( self , pub_date ) : <NEWLINE> <INDENT> page = self . parse_page ( <STRING> ) <NEWLINE> url = page . src ( <STRING> ) <NEWLINE> title = page . alt ( <STRING> ) <NEWLINE> text = <STRING> <NEWLINE> for content in page . text ( <NEWLINE> <INDENT> <STRING> , allow_multiple = True ) : <NEWLINE> text += content + <STRING> <NEWLINE> <DEDENT> text = text . strip ( ) <NEWLINE> return CrawlerImage ( url , title , text ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from __future__ import division <NEWLINE> import os , sys , subprocess , inspect , platform , argparse , threading , time , math , inspect , platform <NEWLINE> from PyQt4 import QtCore , QtGui <NEWLINE> import common <NEWLINE> try : <NEWLINE> <INDENT> import onionshare <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> sys . path . append ( os . path . abspath ( common . onionshare_gui_dir + <STRING> ) ) <NEWLINE> import onionshare <NEWLINE> <DEDENT> from onionshare import strings , helpers , web <NEWLINE> from file_selection import FileSelection <NEWLINE> from server_status import ServerStatus <NEWLINE> from downloads import Downloads <NEWLINE> from options import Options <NEWLINE>
<STRING> <NEWLINE> import c4d <NEWLINE> from c4d . storage import HyperFile , MemoryFileStruct <NEWLINE>
class L1ADimensions ( Enum ) : <NEWLINE> <INDENT> echo_sample_ind = <STRING> <NEWLINE> sar_ku_pulse_burst_ind = <STRING> <NEWLINE> sar_c_pulse_burst_ind = <STRING> <NEWLINE> ltm_max_ind = <STRING> <NEWLINE> time_l1a_echo_sar_ku = <STRING> <NEWLINE> time_l1a_echo_plrm = <STRING> <NEWLINE> <DEDENT>
class ViewForm ( forms . Form ) : <NEWLINE> <INDENT> viewsorting = forms . ChoiceField ( choices = VIEWSORTING , <NEWLINE> <INDENT> widget = forms . Select ( attrs = { <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> } ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def my_dict ( x ) : <NEWLINE> <INDENT> for i in x : <NEWLINE> <INDENT> if x % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def to ( self , event ) : <NEWLINE> <INDENT> setting = <STRING> % event [ <STRING> ] [ 0 ] <NEWLINE> messages = event [ <STRING> ] . get_setting ( setting , [ ] ) <NEWLINE> messages . append ( [ event [ <STRING> ] . nickname , <NEWLINE> <INDENT> <STRING> . join ( event [ <STRING> ] [ 1 : ] ) ] ) <NEWLINE> <DEDENT> event [ <STRING> ] . set_setting ( setting , messages ) <NEWLINE> event [ <STRING> ] . write ( <STRING> ) <NEWLINE> <DEDENT>
def require_ajax ( func ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> @ wraps ( func ) <NEWLINE> def _decorator ( request , * args , ** kwargs ) : <NEWLINE> <INDENT> if request . is_ajax ( ) : <NEWLINE> <INDENT> return func ( request , * args , ** kwargs ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Http404 ( ) <NEWLINE> <DEDENT> <DEDENT> return _decorator <NEWLINE> <DEDENT>
import unittest <NEWLINE> import pygame <NEWLINE> import pygame . image <NEWLINE> from pgzero . screen import Screen <NEWLINE> from pgzero . loaders import set_root , images <NEWLINE> pygame . init ( ) <NEWLINE> surf = pygame . display . set_mode ( ( 200 , 100 ) ) <NEWLINE>
<STRING> <NEWLINE> from setuptools import setup <NEWLINE> setup ( name = <STRING> , <NEWLINE> <INDENT> version = <STRING> , <NEWLINE> description = <STRING> , <NEWLINE> author = <STRING> , <NEWLINE> author_email = <STRING> , <NEWLINE> url = <STRING> , <NEWLINE> packages = [ <STRING> ] , <NEWLINE> keywords = [ <STRING> , <STRING> , <STRING> ] , <NEWLINE> classifiers = [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ] , <NEWLINE> <DEDENT> license = <STRING> <NEWLINE> ) <NEWLINE> <DEDENT>
import os <NEWLINE> import sys <NEWLINE> path = os . path . abspath ( __file__ ) <NEWLINE> path = os . path . dirname ( os . path . dirname ( path ) ) <NEWLINE> os . chdir ( path ) <NEWLINE> sys . path . append ( path ) <NEWLINE> from config import * <NEWLINE> mode1 = __import__ ( pat , fromlist = True ) <NEWLINE> if hasattr ( mode1 , classname ) : <NEWLINE> <INDENT> cls = getattr ( mode1 , classname ) <NEWLINE> obj = cls ( ) <NEWLINE> obj . f1 ( ) <NEWLINE> <DEDENT>
class Category ( models . Model ) : <NEWLINE> <INDENT> title = models . CharField ( max_length = 20 ) <NEWLINE> slug = models . SlugField ( ) <NEWLINE> description = models . TextField ( blank = True , null = True ) <NEWLINE> def __unicode__ ( self ) : <NEWLINE> <INDENT> return self . title <NEWLINE> <DEDENT> class Meta : <NEWLINE> <INDENT> ordering = [ <STRING> ] <NEWLINE> verbose_name_plural = <STRING> <NEWLINE> <DEDENT> <DEDENT>
def write_plain_text ( self , text , start , end ) : <NEWLINE> <INDENT> if start < end : <NEWLINE> <INDENT> self . wrapped . write ( text [ start : end ] ) <NEWLINE> self . wrapped . flush ( ) <NEWLINE> <DEDENT> <DEDENT>
class Action : <NEWLINE> <INDENT> def same_as ( self , other ) : <NEWLINE> <INDENT> return self is other <NEWLINE> <DEDENT> <DEDENT>
def source_pitch_range ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . _source_pitch_range <NEWLINE> <DEDENT>
def postCaseCleanup ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> calls = self . _cleanPending ( ) <NEWLINE> if calls : <NEWLINE> <INDENT> aggregate = DirtyReactorAggregateError ( calls ) <NEWLINE> self . result . addError ( self . test , Failure ( aggregate ) ) <NEWLINE> return False <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT>
def __init__ ( self , name = <STRING> , doc = <STRING> , args = ( ) , type = <STRING> , timeout = None ) : <NEWLINE> <INDENT> self . parent = None <NEWLINE> self . name = name <NEWLINE> self . doc = doc <NEWLINE> self . args = args <NEWLINE> self . type = type <NEWLINE> self . timeout = timeout <NEWLINE> self . messages = None <NEWLINE> self . keywords = None <NEWLINE> <DEDENT>
def apt_install ( packages ) : <NEWLINE> <INDENT> if not packages : <NEWLINE> <INDENT> return ( ) <NEWLINE> <DEDENT> return ( <STRING> + <STRING> . join ( packages ) , ) <NEWLINE> <DEDENT>
def append_or_empty_output_dir ( parent , output_dir ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> message_box = QMessageBox ( ) <NEWLINE> message_box . setWindowTitle ( <STRING> ) <NEWLINE> message_box . setText ( <STRING> . format ( output_dir ) ) <NEWLINE> button_clean = QPushButton ( <STRING> ) <NEWLINE> message_box . addButton ( button_clean , QMessageBox . YesRole ) <NEWLINE> button_cancel = QPushButton ( <STRING> ) <NEWLINE> message_box . addButton ( button_cancel , QMessageBox . NoRole ) <NEWLINE> button_append = QPushButton ( <STRING> ) <NEWLINE> message_box . addButton ( button_append , QMessageBox . ActionRole ) <NEWLINE> ret = message_box . exec_ ( ) ; <NEWLINE> return ret <NEWLINE> <DEDENT>
def copy_param ( target_link , source_link ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> target_params = dict ( target_link . namedparams ( ) ) <NEWLINE> for param_name , param in source_link . namedparams ( ) : <NEWLINE> <INDENT> target_params [ param_name ] . data [ : ] = param . data <NEWLINE> <DEDENT> <DEDENT>
class MovingObject ( Object ) : <NEWLINE> <INDENT> def __init__ ( self , window , game , init_point , slope ) : <NEWLINE> <INDENT> Object . __init__ ( self , window , game ) <NEWLINE> self . point = init_point <NEWLINE> self . slope = slope <NEWLINE> <DEDENT> <DEDENT>
from json import load <NEWLINE> from urllib2 import urlopen <NEWLINE> from pprint import pprint <NEWLINE> import operator <NEWLINE> baseurl = <STRING> <NEWLINE> cities = [ <STRING> , <STRING> ] <NEWLINE> substract = 273 <NEWLINE>
def rollback_checkpoints ( self , rollback = 1 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> self . reverter . rollback_checkpoints ( rollback ) <NEWLINE> <DEDENT> except errors . ReverterError as err : <NEWLINE> <INDENT> raise errors . PluginError ( str ( err ) ) <NEWLINE> <DEDENT> self . aug . load ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import gevent <NEWLINE> from gevent import monkey <NEWLINE> if not <STRING> in sys . modules : <NEWLINE> <INDENT> monkey . patch_all ( ) <NEWLINE> <DEDENT> import requests <NEWLINE> import uuid <NEWLINE> import json <NEWLINE> import hashlib <NEWLINE> import socket <NEWLINE> from disc_utils import * <NEWLINE> from disc_consts import * <NEWLINE> import services <NEWLINE> import hashlib <NEWLINE> import socket <NEWLINE> from sandesh . discovery_client import ttypes as sandesh <NEWLINE> from pysandesh . connection_info import ConnectionState <NEWLINE> from pysandesh . gen_py . process_info . ttypes import ConnectionStatus , ConnectionType <NEWLINE>
from kivy import platform <NEWLINE> __all__ = ( <STRING> , ) <NEWLINE> if platform ( ) == <STRING> : <NEWLINE> <INDENT> from openIABilling import OpenIABilling as Billing <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from mockbilling import MockBilling as Billing <NEWLINE> <DEDENT>
def randomUUID ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return [ random . randint ( 0 , 255 ) for dummy in range ( 0 , 16 ) ] <NEWLINE> <DEDENT>
class BaseView ( Resource ) : <NEWLINE> <INDENT> def abort_if_does_not_exist ( self , o_id ) : <NEWLINE> <INDENT> o , is_new = self . __managed_class__ . get_unique ( o_id ) <NEWLINE> if is_new : <NEWLINE> <INDENT> self . __managed_class__ . remove_from_cache ( o ) <NEWLINE> abort ( 404 , message = <STRING> . format ( o_id ) ) <NEWLINE> <DEDENT> return o <NEWLINE> <DEDENT> def pagination ( self , page = 1 , step = 10 ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
def dfs_do_func_on_graph ( node , func , * args , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for _node in node . tree_iterator ( ) : <NEWLINE> <INDENT> func ( _node , * args , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT>
def create_html_summary ( ) : <NEWLINE> <INDENT> txt = <STRING> <NEWLINE> for f in files : <NEWLINE> <INDENT> txt += summarise_file_as_html ( f ) <NEWLINE> <DEDENT> txt += <STRING> <NEWLINE> with open ( <STRING> , <STRING> ) as fop : <NEWLINE> <INDENT> fop . write ( txt ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def xmlrpc_get_message ( self ) : <NEWLINE> <INDENT> if self . completed : <NEWLINE> <INDENT> response = { <STRING> : <STRING> } <NEWLINE> response [ <STRING> ] = self . value <NEWLINE> Timer ( 1 , self . xmlrpc_kill ) . start ( ) <NEWLINE> self . after ( 10 , self . withdraw ) <NEWLINE> return response <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT>
def test_instance_field_overrides_class ( self ) : <NEWLINE> <INDENT> class Person3 ( m . Model ) : <NEWLINE> <INDENT> name = m . CharField ( ) <NEWLINE> birthday = m . DateTimeField ( ) <NEWLINE> <DEDENT> person = Person3 ( ) <NEWLINE> person . add_field ( <STRING> , m . DateField ( ) ) <NEWLINE> self . assertTrue ( isinstance ( person . get_field ( <STRING> ) , m . DateField ) ) <NEWLINE> <DEDENT>
class LeaseTable ( Base ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> __tablename__ = <STRING> <NEWLINE> job_id = Column ( Integer , primary_key = True ) <NEWLINE> slice_hrn = Column ( String ) <NEWLINE> def __init__ ( self , job_id , slice_hrn ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . job_id = job_id <NEWLINE> self . slice_hrn = slice_hrn <NEWLINE> <DEDENT> def __repr__ ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> result = <STRING> % ( self . job_id , <NEWLINE> <INDENT> self . slice_hrn ) <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT> <DEDENT>
def test_report_error ( self ) : <NEWLINE> <INDENT> showerror = Mbox . showerror <NEWLINE> Equal = self . assertEqual <NEWLINE> pat = <STRING> <NEWLINE> msg = <STRING> <NEWLINE> Equal ( self . engine . report_error ( pat , msg ) , None ) <NEWLINE> Equal ( showerror . title , <STRING> ) <NEWLINE> expected_message = ( <STRING> + msg + <STRING> ) <NEWLINE> Equal ( showerror . message , expected_message ) <NEWLINE> Equal ( self . engine . report_error ( pat , msg , 5 ) , None ) <NEWLINE> Equal ( showerror . title , <STRING> ) <NEWLINE> expected_message += <STRING> <NEWLINE> Equal ( showerror . message , expected_message ) <NEWLINE> <DEDENT>
def main ( platform ) : <NEWLINE> <INDENT> ap = argparse . ArgumentParser ( description = <STRING> ) <NEWLINE> ap . add_argument ( <STRING> , action = <STRING> ) <NEWLINE> ap . add_argument ( <STRING> , action = <STRING> ) <NEWLINE> ops = ap . parse_args ( ) <NEWLINE> if ops . info : <NEWLINE> <INDENT> print ( platform ) <NEWLINE> <DEDENT> if ops . env : <NEWLINE> <INDENT> print ( platform . get_environment ( ) ) <NEWLINE> <DEDENT> <DEDENT>
def test_set_cell_content ( field ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> x = y = 0 <NEWLINE> assert field . field [ ( x , y ) ] is None <NEWLINE> field . set_cell_content ( x , y , <STRING> ) <NEWLINE> assert field . field [ ( x , y ) ] == <STRING> <NEWLINE> with pytest . raises ( KeyError ) : <NEWLINE> <INDENT> field . set_cell_content ( field . width , 0 , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import uuid <NEWLINE> import sys <NEWLINE> from twisted . python import log <NEWLINE> from twisted . internet import reactor <NEWLINE> from twisted . web . server import Site <NEWLINE> from twisted . web . wsgi import WSGIResource <NEWLINE> from flask import Flask , render_template <NEWLINE> from autobahn . twisted . websocket import WebSocketServerFactory , WebSocketServerProtocol <NEWLINE> from autobahn . twisted . resource import WebSocketResource , WSGIRootResource , HTTPChannelHixie76Aware <NEWLINE>
from __future__ import unicode_literals <NEWLINE> from django . apps import apps <NEWLINE> from django . conf import settings <NEWLINE> from django . db import connection <NEWLINE> from django . test import TestCase , skipIfDBFeature , skipUnlessDBFeature <NEWLINE> from . models . tablespaces import ( <NEWLINE> <INDENT> Article , ArticleRef , Authors , Reviewers , Scientist , ScientistRef , <NEWLINE> <DEDENT> ) <NEWLINE>
def truncation_replacement ( random , population , parents , offspring , args ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> psize = len ( population ) <NEWLINE> population . extend ( list ( offspring ) ) <NEWLINE> population . sort ( reverse = True ) <NEWLINE> return population [ : psize ] <NEWLINE> <DEDENT>
class Users ( Base ) : <NEWLINE> <INDENT> email_address = fields . Email ( ) <NEWLINE> first_name = fields . String ( ) <NEWLINE> last_name = fields . String ( ) <NEWLINE> <DEDENT>
def test_repr ( self ) : <NEWLINE> <INDENT> foo = terminal . Color ( <STRING> ) <NEWLINE> foo . fgcolor = <STRING> <NEWLINE> assert repr ( foo ) == repr ( str ( foo ) ) <NEWLINE> <DEDENT>
class SecurityGroups ( horizon . Panel ) : <NEWLINE> <INDENT> name = _ ( <STRING> ) <NEWLINE> slug = <STRING> <NEWLINE> permissions = ( <STRING> , ) <NEWLINE> <DEDENT>
def GetRequired ( ) : <NEWLINE> <INDENT> with open ( <STRING> , <STRING> ) as fin : <NEWLINE> <INDENT> return json . loads ( fin . read ( ) ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , records ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> assert all ( type ( r ) is FastaRecord for r in records ) <NEWLINE> assert all ( len ( r . sequence ) == len ( records [ 0 ] . sequence ) <NEWLINE> <INDENT> for r in records ) <NEWLINE> <DEDENT> self . _records = records <NEWLINE> <DEDENT> except AssertionError : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def test_works_with_dag ( self ) : <NEWLINE> <INDENT> self . art2 . source . dependencies = [ self . art4 ] <NEWLINE> self . art3 . source . dependencies = [ self . art4 ] <NEWLINE> self . art1 . source . dependencies = [ self . art2 , self . art3 ] <NEWLINE> self . verify_round_trip ( self . art1 ) <NEWLINE> <DEDENT>
def shutdown ( ) : <NEWLINE> <INDENT> move . shutdown ( ) <NEWLINE> sensors . shutdown ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
from __future__ import print_function <NEWLINE> import numpy as np <NEWLINE> import tensorflow as tf <NEWLINE> from utility . duration import Duration <NEWLINE> import utility . logger_tool <NEWLINE> import logging <NEWLINE> import os <NEWLINE> from A1_notmnistdataset . p5_findduplication import DataExploration <NEWLINE>
import numpy as np <NEWLINE> import wx <NEWLINE> from OM . Manager import ObjectManager <NEWLINE> import funcs as fn <NEWLINE> import scipy <NEWLINE>
<STRING> <NEWLINE> import functools <NEWLINE> from flask import request , url_for <NEWLINE> import json <NEWLINE>
<STRING> <NEWLINE> from django . core . management . commands . flush import Command <NEWLINE> from boardinghouse . schema import _wrap_command <NEWLINE> Command . handle = _wrap_command ( Command . handle ) <NEWLINE>
def test_dimensions ( self ) : <NEWLINE> <INDENT> from html5video . encoders . base import BaseEncoder <NEWLINE> e = BaseEncoder ( <STRING> ) <NEWLINE> self . assertEqual ( e . dimensions , None ) <NEWLINE> e . dimensions = <STRING> <NEWLINE> self . assertEqual ( e . width , <STRING> ) <NEWLINE> self . assertEqual ( e . height , <STRING> ) <NEWLINE> self . assertEqual ( e . dimensions , <STRING> ) <NEWLINE> with self . assertRaises ( AttributeError ) : <NEWLINE> <INDENT> e . dimensions = None <NEWLINE> <DEDENT> <DEDENT>
class DiagnoseTestCase ( TestCase ) : <NEWLINE> <INDENT> def test_runCommand ( self ) : <NEWLINE> <INDENT> code , stdout , stderr = runCommand ( <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> self . assertEquals ( code , 0 ) <NEWLINE> self . assertEquals ( stderr , <STRING> ) <NEWLINE> self . assertTrue ( <STRING> in stdout ) <NEWLINE> <DEDENT> def test_runCommand_nonExistent ( self ) : <NEWLINE> <INDENT> self . assertRaises ( FileNotFound , runCommand , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def get_key ( self , key , include_keys = False ) : <NEWLINE> <INDENT> path = <STRING> % key <NEWLINE> if include_keys : <NEWLINE> <INDENT> path += <STRING> <NEWLINE> <DEDENT> resp = self . server . request ( <STRING> , path ) <NEWLINE> return self . server . json_body ( resp ) <NEWLINE> <DEDENT>
from abc import ABC , abstractmethod <NEWLINE> from collections import namedtuple <NEWLINE> from urllib . parse import urljoin <NEWLINE> from bs4 import BeautifulSoup <NEWLINE> Link = namedtuple ( <STRING> , [ <STRING> , <STRING> ] ) <NEWLINE>
from . bot import dorna_go , commands <NEWLINE> __all__ = [ <STRING> , <STRING> ] <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> from mozbuild . base import MozbuildObject <NEWLINE> config = MozbuildObject . from_environment ( ) <NEWLINE> for var in ( <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> value = getattr ( config , var ) <NEWLINE> setattr ( sys . modules [ __name__ ] , var , value ) <NEWLINE> <DEDENT> substs = dict ( substs ) <NEWLINE> for var in os . environ : <NEWLINE> <INDENT> if var not in ( <STRING> , <STRING> , <STRING> ) and var in substs : <NEWLINE> <INDENT> substs [ var ] = os . environ [ var ] <NEWLINE> <DEDENT> <DEDENT>
class JobForTest ( MongoJob ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> collection_name = <STRING> <NEWLINE> def build_row ( self , _str ) : <NEWLINE> <INDENT> return { <NEWLINE> <INDENT> <STRING> : _str . strip ( ) , <NEWLINE> <STRING> : 0 , <NEWLINE> <STRING> : 0 <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> <DEDENT>
def forwards ( self , orm ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> Book = orm [ <STRING> ] <NEWLINE> UserBook = orm [ <STRING> ] <NEWLINE> for book in Book . objects . all ( ) : <NEWLINE> <INDENT> user = book . user <NEWLINE> userBook = UserBook ( user = user , book = book ) <NEWLINE> userBook . desired = book . desired <NEWLINE> userBook . purchase_store = book . purchase_store <NEWLINE> userBook . purchased = book . purchased <NEWLINE> userBook . purchase_value = book . purchase_value <NEWLINE> userBook . purchase_date = book . purchase_date <NEWLINE> userBook . save ( ) <NEWLINE> <DEDENT> <DEDENT>
import gettext <NEWLINE> __trans = gettext . translation ( <STRING> , fallback = True ) <NEWLINE> _ = __trans . ugettext <NEWLINE> import pisi <NEWLINE> import pisi . context as ctx <NEWLINE>
from flatland . util import signal <NEWLINE> validator_validated = signal ( <STRING> , doc = <STRING> ) <NEWLINE>
<STRING> <NEWLINE> import luna . plugins <NEWLINE> import automatic . state <NEWLINE>
<STRING> <NEWLINE> from . version import __version__ <NEWLINE> import os <NEWLINE> if os . path . exists ( <STRING> ) & os . path . exists ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> from . import utils_c <NEWLINE> from . import utils <NEWLINE> from . import grismconf <NEWLINE> from . import model <NEWLINE> from . import multifit <NEWLINE> if os . getenv ( <STRING> ) is None : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from launcher . util . stack_config import StackConf , apply_template <NEWLINE> from launcher . util . configuration import LauncherConf <NEWLINE> from launcher . ansible . executor import generate as playbook_generate <NEWLINE> from StringIO import StringIO <NEWLINE> import pytest <NEWLINE> import yaml <NEWLINE> CONF = <STRING> <NEWLINE> STACK = <STRING> <NEWLINE> EXPECTED_STACK = <STRING> <NEWLINE>
def anything_but ( self , letter ) : <NEWLINE> <INDENT> self . raw_source += <STRING> % re . escape ( letter ) <NEWLINE> return self <NEWLINE> <DEDENT>
def on_response ( self , dialog , * args ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> dialog . destroy ( ) <NEWLINE> <DEDENT>
def do_import ( plugin_module_name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> plugin_module = __import__ ( plugin_module_name ) <NEWLINE> if <STRING> in plugin_module_name : <NEWLINE> <INDENT> modules = plugin_module_name . split ( <STRING> ) <NEWLINE> for module in modules [ 1 : ] : <NEWLINE> <INDENT> plugin_module = getattr ( plugin_module , module ) <NEWLINE> <DEDENT> <DEDENT> log . debug ( <STRING> + plugin_module_name ) <NEWLINE> return plugin_module <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> log . exception ( <STRING> , plugin_module_name ) <NEWLINE> raise <NEWLINE> <DEDENT> <DEDENT>
def mouseReleaseEvent ( self , event ) : <NEWLINE> <INDENT> if self . m_is_resize : <NEWLINE> <INDENT> self . m_is_resize = False <NEWLINE> self . restoreCursor ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> instrument = self . get_instrument ( ) <NEWLINE> if instrument : <NEWLINE> <INDENT> instrument . mouse_release_event ( event , self ) <NEWLINE> <DEDENT> <DEDENT> super ( ) . mouseReleaseEvent ( event ) <NEWLINE> <DEDENT>
def runJob ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> getData ( ) <NEWLINE> <DEDENT> except ( Exception ) : <NEWLINE> <INDENT> sys . stderr . write ( <STRING> ) <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>
from . . tasks import print_message <NEWLINE> print_message ( <STRING> ) <NEWLINE>
def GetHostProject ( self , project ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> request_tuple = ( <NEWLINE> <INDENT> self . client . projects , <NEWLINE> <STRING> , <NEWLINE> self . messages . ComputeProjectsGetXpnHostRequest ( project = project ) ) <NEWLINE> <DEDENT> msg = <STRING> . format ( project = project ) <NEWLINE> return self . _MakeRequestSync ( request_tuple , msg ) <NEWLINE> <DEDENT>
def _get_position ( self ) : <NEWLINE> <INDENT> if self . _player is None : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return self . _player . get_position ( ) <NEWLINE> <DEDENT>
def update ( self , input_signal , torque , acceleration ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . draw_shapes ( input_signal ) <NEWLINE> while gtk . events_pending ( ) : <NEWLINE> <INDENT> gtk . main_iteration ( False ) <NEWLINE> <DEDENT> if self . screencast : <NEWLINE> <INDENT> self . take_a_screenshot ( ) <NEWLINE> <DEDENT> <DEDENT>
def RunBotCommands ( options , commands , env ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( DictDiff ( dict ( os . environ ) , env ) ) <NEWLINE> for command in commands : <NEWLINE> <INDENT> print ( bb_utils . CommandToString ( command ) ) <NEWLINE> sys . stdout . flush ( ) <NEWLINE> if options . testing : <NEWLINE> <INDENT> env [ <STRING> ] = <STRING> <NEWLINE> <DEDENT> return_code = subprocess . call ( command , cwd = bb_utils . CHROME_SRC , env = env ) <NEWLINE> if return_code != 0 : <NEWLINE> <INDENT> return return_code <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from importlib import import_module <NEWLINE> import os <NEWLINE> import pkgutil <NEWLINE> from threading import local <NEWLINE> from django . conf import settings <NEWLINE> from django . core . exceptions import ImproperlyConfigured <NEWLINE> from django . utils . functional import cached_property <NEWLINE> from django . utils . _os import upath <NEWLINE> DEFAULT_LIBSMS_ALIAS = <STRING> <NEWLINE>
<STRING> <NEWLINE> from __future__ import ( print_function , <NEWLINE> <INDENT> unicode_literals , <NEWLINE> division ) <NEWLINE> <DEDENT> import subprocess <NEWLINE> import os <NEWLINE> import re <NEWLINE> import time <NEWLINE> import xml . etree . ElementTree as ET <NEWLINE> import jube2 . util <NEWLINE> import jube2 . conf <NEWLINE> import jube2 . log <NEWLINE> LOGGER = jube2 . log . get_logger ( __name__ ) <NEWLINE>
import argparse <NEWLINE> import os , sys <NEWLINE> import rcs_utils <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> parser = argparse . ArgumentParser ( description = <STRING> + <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> parser . add_argument ( <STRING> , <NEWLINE> <INDENT> help = <STRING> ) <NEWLINE> <DEDENT> parser . add_argument ( <STRING> , <NEWLINE> <INDENT> help = <STRING> ) <NEWLINE> <DEDENT> args = parser . parse_args ( ) <NEWLINE> cmd = rcs_utils . load_all_plugins ( <STRING> ) <NEWLINE> cmd += <STRING> <NEWLINE> cmd += <STRING> + args . loc <NEWLINE> cmd += <STRING> <NEWLINE> cmd += <STRING> + args . bc <NEWLINE> rcs_utils . invoke ( cmd ) <NEWLINE> <DEDENT>
def __init__ ( self , fixed : MQTTFixedHeader = None , variable_header : PacketIdVariableHeader = None ) : <NEWLINE> <INDENT> if fixed is None : <NEWLINE> <INDENT> header = MQTTFixedHeader ( PUBREL , 0x02 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if fixed . packet_type is not PUBREL : <NEWLINE> <INDENT> raise HBMQTTException ( <STRING> % fixed . packet_type ) <NEWLINE> <DEDENT> header = fixed <NEWLINE> <DEDENT> super ( ) . __init__ ( header ) <NEWLINE> self . variable_header = variable_header <NEWLINE> self . payload = None <NEWLINE> <DEDENT>
def exit_from_exception ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT>
def sumfile ( filename ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> f = open ( filename , <STRING> ) <NEWLINE> m = hashlib . new ( <STRING> ) <NEWLINE> while True : <NEWLINE> <INDENT> d = f . read ( 8096 ) <NEWLINE> if not d : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m . update ( d ) <NEWLINE> <DEDENT> f . close ( ) <NEWLINE> return m . hexdigest ( ) <NEWLINE> <DEDENT>
class TestFeedController ( TestController ) : <NEWLINE> <INDENT> def test_index ( self ) : <NEWLINE> <INDENT> response = self . app . get ( url ( controller = <STRING> , action = <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT>
class RutaAdmin ( admin . ModelAdmin ) : <NEWLINE> <INDENT> list_display = ( <STRING> , <STRING> ) <NEWLINE> search_fields = [ <STRING> , <STRING> ] <NEWLINE> ordering = [ <STRING> ] <NEWLINE> <DEDENT>
def onchange_partner_id ( self , partner_id ) : <NEWLINE> <INDENT> val = super ( SaleOrder , self ) . onchange_partner_id ( partner_id ) <NEWLINE> if partner_id : <NEWLINE> <INDENT> partner = self . env [ <STRING> ] . browse ( partner_id ) <NEWLINE> comment , pcomment = partner . _get_sale_comments ( ) <NEWLINE> val [ <STRING> ] . update ( { <STRING> : comment , <NEWLINE> <INDENT> <STRING> : pcomment } ) <NEWLINE> <DEDENT> <DEDENT> return val <NEWLINE> <DEDENT>
list = [ <STRING> , <STRING> , 40 , <STRING> , <STRING> ] <NEWLINE> dictionary = { <STRING> : <STRING> , <STRING> : 31 , <STRING> : <STRING> } <NEWLINE> num = 0 <NEWLINE> for items in list : <NEWLINE> <INDENT> num += 1 <NEWLINE> print ( str ( num ) + <STRING> + str ( items ) ) <NEWLINE> <DEDENT> print ( num ) <NEWLINE>
class Language : <NEWLINE> <INDENT> def isLang ( self , line ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return False <NEWLINE> <DEDENT> def isLangPrefix ( self , line ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return False <NEWLINE> <DEDENT> def complete ( self , line ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> yield Completion ( <STRING> ) <NEWLINE> <DEDENT> def evaluate ( self , line , processor = None , stdin = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return <STRING> <NEWLINE> <DEDENT> <DEDENT>
def rawCall ( self , method , * args ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> url = self . __createURL ( method , args ) <NEWLINE> result = urlopen ( url ) . read ( ) <NEWLINE> return result <NEWLINE> <DEDENT>
class Migration ( migrations . Migration ) : <NEWLINE> <INDENT> dependencies = [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE> operations = [ <NEWLINE> <INDENT> migrations . AlterField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> field = models . EmailField ( default = 1 , max_length = 254 ) , <NEWLINE> preserve_default = False , <NEWLINE> <DEDENT> ) , <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT>
class myExtractions ( UserExtractions . UserExtractions ) : <NEWLINE> <INDENT> def nodeDegree ( ) : <NEWLINE> <INDENT> return degree <NEWLINE> <DEDENT> def betweenness ( ) : <NEWLINE> <INDENT> return bCentrality <NEWLINE> <DEDENT> def closeness ( ) : <NEWLINE> <INDENT> return cCentrality <NEWLINE> <DEDENT> def clusteringCoefficient ( ) : <NEWLINE> <INDENT> return clustering <NEWLINE> <DEDENT> def greaterNeighborhoodState ( ) : <NEWLINE> <INDENT> avg_neighbor_state = sum ( neighborStates ) / degree <NEWLINE> if state >= avg_neighbor_state : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> def netIn ( ) : <NEWLINE> <INDENT> netIn = inDegree - outDegree <NEWLINE> return max ( netIn , 0 ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> __author__ = <STRING> <NEWLINE> __copyright__ = <STRING> <NEWLINE> __license__ = <STRING> <NEWLINE> __version__ = <STRING> <NEWLINE> import vivotools as vt <NEWLINE> from datetime import datetime <NEWLINE> print ( datetime . now ( ) , <STRING> ) <NEWLINE> print ( vt . key_string ( <STRING> ) ) <NEWLINE> print ( vt . key_string ( <STRING> ) ) <NEWLINE> print ( vt . key_string ( <STRING> ) ) <NEWLINE> print ( vt . key_string ( <STRING> ) ) <NEWLINE> print ( datetime . now ( ) , <STRING> ) <NEWLINE>
def test_untransform ( transfs ) : <NEWLINE> <INDENT> transfs . untransform ( <STRING> , DummyTransformer ) <NEWLINE> assert transfs . list ( ) == { <STRING> , <STRING> , <STRING> , <STRING> } <NEWLINE> <DEDENT>
def create_event_packet ( self , title , text ) : <NEWLINE> <INDENT> p = <STRING> . format ( <NEWLINE> <INDENT> title_len = len ( title ) , <NEWLINE> text_len = len ( text ) , <NEWLINE> title = title , <NEWLINE> text = text <NEWLINE> ) <NEWLINE> <DEDENT> return p <NEWLINE> <DEDENT>
def __init__ ( self , config , osc = None ) : <NEWLINE> <INDENT> super ( VolumeMigrate , self ) . __init__ ( config ) <NEWLINE> self . temp_username = utils . random_string ( 10 ) <NEWLINE> self . temp_password = utils . random_string ( 10 ) <NEWLINE> self . cinder_util = cinder_helper . CinderHelper ( osc = self . osc ) <NEWLINE> self . nova_util = nova_helper . NovaHelper ( osc = self . osc ) <NEWLINE> <DEDENT>
def _ouc ( x , y ) : <NEWLINE> <INDENT> out = np . empty_like ( x , dtype = bool ) <NEWLINE> xzero = ( x == 0 ) <NEWLINE> yzero = ( y == 0 ) <NEWLINE> out [ xzero & yzero ] = False <NEWLINE> out [ ~ xzero & yzero ] = True <NEWLINE> out [ ~ yzero ] = ( abs ( x [ ~ yzero ] / y [ ~ yzero ] ) > 1.0 ) <NEWLINE> return out <NEWLINE> <DEDENT>
def __init__ ( self , arr , offset_x , offset_y , scale = 1 ) : <NEWLINE> <INDENT> self . arr = arr <NEWLINE> self . offset_x = offset_x <NEWLINE> self . offset_y = offset_y <NEWLINE> self . scale = scale <NEWLINE> <DEDENT>
def SetBrightnes ( self , brightnes ) : <NEWLINE> <INDENT> if ( brightnes > 7 ) : <NEWLINE> <INDENT> brightnes = 7 ; <NEWLINE> <DEDENT> elif ( brightnes < 0 ) : <NEWLINE> <INDENT> brightnes = 0 ; <NEWLINE> <DEDENT> if ( self . __brightnes != brightnes ) : <NEWLINE> <INDENT> self . __brightnes = brightnes ; <NEWLINE> self . Show ( self . __currentData ) ; <NEWLINE> <DEDENT> <DEDENT>
def p_param ( p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( p ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import os <NEWLINE> EVENT_DB_HOST = os . getenv ( <STRING> , None ) <NEWLINE> EVENT_DB_USER = os . getenv ( <STRING> , None ) <NEWLINE> EVENT_DB_PASS = os . getenv ( <STRING> , None ) <NEWLINE> EVENT_DB_NAME = os . getenv ( <STRING> , <STRING> ) <NEWLINE>
try : <NEWLINE> <INDENT> from . ldap_auth import ldap_auth_backend <NEWLINE> <DEDENT> except SystemError : <NEWLINE> <INDENT> from ldap_auth import ldap_auth_backend <NEWLINE> <DEDENT>
import functools <NEWLINE> import os , os . path <NEWLINE> import re <NEWLINE> import threading <NEWLINE> import urllib <NEWLINE> import core <NEWLINE>
class Post ( models . Model ) : <NEWLINE> <INDENT> title = models . CharField ( max_length = 100 ) <NEWLINE> date_time = models . DateTimeField ( auto_now_add = True ) <NEWLINE> content = models . TextField ( blank = True , null = True ) <NEWLINE> created_time = models . DateTimeField ( auto_now_add = True ) <NEWLINE> modified_time = models . DateTimeField ( auto_now = True ) <NEWLINE> category = models . ForeignKey ( Category ) <NEWLINE> author = models . ForeignKey ( User ) <NEWLINE> def __str__ ( self ) : <NEWLINE> <INDENT> return self . title <NEWLINE> <DEDENT> class Meta : <NEWLINE> <INDENT> ordering = [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT>
from __future__ import ( absolute_import , division , generators , nested_scopes , print_function , <NEWLINE> <INDENT> unicode_literals , with_statement ) <NEWLINE> <DEDENT> import os <NEWLINE> from collections import defaultdict <NEWLINE> from twitter . common . collections import OrderedSet <NEWLINE> from pants . backend . jvm . targets . jar_dependency import JarDependency <NEWLINE> from pants . backend . jvm . tasks . coverage . base import Coverage , CoverageTaskSettings <NEWLINE> from pants . base . build_environment import get_buildroot <NEWLINE> from pants . base . exceptions import TaskError <NEWLINE> from pants . binaries import binary_util <NEWLINE> from pants . util . contextutil import temporary_file <NEWLINE> from pants . util . dirutil import relativize_paths , safe_delete , safe_mkdir , touch <NEWLINE>
def __repr__ ( self ) : <NEWLINE> <INDENT> if self . name : <NEWLINE> <INDENT> return <STRING> % self . name <NEWLINE> <DEDENT> return object . __repr__ ( self ) <NEWLINE> <DEDENT>
def getWriters ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return list ( self . _writers ) <NEWLINE> <DEDENT>
def test_install_from_wheel_gui_entrypoint ( script , data ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> result = script . pip ( <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> + data . find_links , <NEWLINE> expect_error = False , <NEWLINE> <DEDENT> ) <NEWLINE> if os . name == <STRING> : <NEWLINE> <INDENT> wrapper_file = script . bin / <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wrapper_file = script . bin / <STRING> <NEWLINE> <DEDENT> assert wrapper_file in result . files_created <NEWLINE> <DEDENT>
class Server ( object ) : <NEWLINE> <INDENT> def get_interface ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def add_vlan_to_interface ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def ping ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def setup_link ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def check_ports_on_br ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def setup_iperf_server ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def start_iperf_client ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def teardown_iperf_server ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def check_dhcp_on_comp ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> args = parser . parse_args ( ) <NEWLINE> for i , ( ff , inputfile ) in enumerate ( list_tiffs ( args . inputfile ) ) : <NEWLINE> <INDENT> process_file ( ff , inputfile ) <NEWLINE> print ( <STRING> % ( i + 1 ) ) <NEWLINE> <DEDENT> <DEDENT>
def _decode_val ( self , val ) : <NEWLINE> <INDENT> [ retry_times , timestamp , buff ] = val . split ( <STRING> , 2 ) <NEWLINE> retry_times = int ( retry_times ) <NEWLINE> timestamp = int ( timestamp ) <NEWLINE> packet = protocol . Packet . decode ( buff ) <NEWLINE> packet . retry_times = retry_times <NEWLINE> packet . timestamp = timestamp <NEWLINE> return packet <NEWLINE> <DEDENT>
def prepare_search_results ( res ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> projects = list ( res ) <NEWLINE> for project in projects : <NEWLINE> <INDENT> project [ <STRING> ] = <STRING> if project . get ( <STRING> ) in current_user . bookmarks else <STRING> <NEWLINE> project [ <STRING> ] = <STRING> if current_user [ <STRING> ] in project . get ( <STRING> ) else <STRING> <NEWLINE> <DEDENT> return projects <NEWLINE> <DEDENT>
from __future__ import unicode_literals <NEWLINE> from django . utils . translation import ugettext_lazy as _ <NEWLINE> from shuup . admin . utils . picotable import ChoicesFilter , Column , MPTTFilter <NEWLINE> from shuup . admin . utils . views import PicotableListView <NEWLINE> from shuup . core . models import Category , CategoryStatus , CategoryVisibility <NEWLINE>
def new_incoming_message ( self , msg_id , producer_dn , msg_data ) : <NEWLINE> <INDENT> msg_file = self . _inpath + msg_id <NEWLINE> if self . _dup_check ( msg_data , msg_file + <STRING> + producer_dn + <STRING> ) : <NEWLINE> <INDENT> self . _atomic_write_file ( msg_file , msg_data ) <NEWLINE> sigfile = open ( msg_file + <STRING> , <STRING> ) <NEWLINE> sigfile . write ( producer_dn + <STRING> ) <NEWLINE> sigfile . close ( ) <NEWLINE> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT>
def errcheck ( result , func , arguments ) : <NEWLINE> <INDENT> if result < 0 : <NEWLINE> <INDENT> errno = ctypes . get_errno ( ) <NEWLINE> raise OSError ( errno , os . strerror ( errno ) ) <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT>
def brower ( self ) : <NEWLINE> <INDENT> if self . LWweb . currentItem ( ) : <NEWLINE> <INDENT> url = self . LWweb . currentItem ( ) . text ( ) <NEWLINE> webbrowser . open ( url ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import unittest <NEWLINE> from testbundle . bundle import Bundle <NEWLINE> from databundles . identity import * <NEWLINE> from test_base import TestBase <NEWLINE> from osgeo . gdalconst import GDT_Float32 <NEWLINE> import ogr <NEWLINE>
from django . db import models <NEWLINE> from django . contrib . auth . models import User <NEWLINE> from django . db . models . signals import post_save , pre_save <NEWLINE> from django . core . mail import send_mail <NEWLINE> from django . conf import settings <NEWLINE>
def test_keys ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> i = self . instance . keys ( ) <NEWLINE> self . get_next ( i ) <NEWLINE> self . session . get . assert_called_once_with ( <NEWLINE> <INDENT> url_for ( <STRING> ) , <NEWLINE> params = { <STRING> : 100 } , <NEWLINE> headers = { } <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def tushare_code_2_order_book_id ( code ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return TUSHARE_CODE_MAPPING [ code ] <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> if code . startswith ( <STRING> ) : <NEWLINE> <INDENT> return <STRING> . format ( code ) <NEWLINE> <DEDENT> elif code [ 0 ] in [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> return <STRING> . format ( code ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise RuntimeError ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import unittest <NEWLINE> import tempfile <NEWLINE> from openglider . jsonify import load <NEWLINE> from openglider . plots import flatten_glider <NEWLINE> from openglider . plots . glider . cell import flattened_cell <NEWLINE> from openglider . plots . part import create_svg <NEWLINE> from openglider . glider . cell_elements import Panel <NEWLINE> from openglider . graphics import Line , Graphics2D , Red , Graphics3D <NEWLINE>
def section ( function ) : <NEWLINE> <INDENT> sections . append ( function ) <NEWLINE> return function <NEWLINE> <DEDENT>
import logging <NEWLINE> from threading import local <NEWLINE> from django . conf import settings <NEWLINE> from django . core import signals <NEWLINE> from django . db import models <NEWLINE> from django . db . models . signals import pre_delete , post_save , m2m_changed <NEWLINE> from django . dispatch import receiver <NEWLINE> from elasticutils . contrib . django import MappingType , Indexable , MLT <NEWLINE> from elasticsearch . exceptions import NotFoundError <NEWLINE> from kitsune . search import es_utils <NEWLINE> from kitsune . search . tasks import index_task , unindex_task <NEWLINE> from kitsune . sumo . models import ModelBase <NEWLINE> log = logging . getLogger ( <STRING> ) <NEWLINE> _search_mapping_types = { } <NEWLINE>
def walk ( self , oid , host , port , community ) : <NEWLINE> <INDENT> ret = { } <NEWLINE> snmpAuthData = cmdgen . CommunityData ( community ) <NEWLINE> snmpTransportData = cmdgen . UdpTransportTarget ( ( host , port ) ) <NEWLINE> resultTable = self . snmpCmdGen . nextCmd ( snmpAuthData , <NEWLINE> <INDENT> snmpTransportData , <NEWLINE> oid ) <NEWLINE> <DEDENT> varBindTable = resultTable [ 3 ] <NEWLINE> for varBindTableRow in varBindTable : <NEWLINE> <INDENT> for o , v in varBindTableRow : <NEWLINE> <INDENT> ret [ o . prettyPrint ( ) ] = v . prettyPrint ( ) <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <DEDENT>
def rl_complete ( self , text , state ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if state == 0 : <NEWLINE> <INDENT> cword_prequote , cword_prefix , cword_suffix , comp_words , first_colon_pos = split_line ( text ) <NEWLINE> comp_words . insert ( 0 , sys . argv [ 0 ] ) <NEWLINE> matches = self . _get_completions ( comp_words , cword_prefix , cword_prequote , first_colon_pos ) <NEWLINE> self . _rl_matches = [ text + match [ len ( cword_prefix ) : ] for match in matches ] <NEWLINE> <DEDENT> if state < len ( self . _rl_matches ) : <NEWLINE> <INDENT> return self . _rl_matches [ state ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT>
def phenotips_view_patient_pdf ( request , project_guid , patient_id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> url = <STRING> % locals ( ) <NEWLINE> project = Project . objects . get ( guid = project_guid ) <NEWLINE> permissions_level = <STRING> <NEWLINE> auth_tuple = _check_user_permissions ( request . user , project , permissions_level ) <NEWLINE> return _send_request_to_phenotips ( <STRING> , url , auth_tuple = auth_tuple ) <NEWLINE> <DEDENT>
def test_fstab_baduuid ( self ) : <NEWLINE> <INDENT> self . addFstabEntry ( <STRING> ) <NEWLINE> pdb . set_trace ( ) <NEWLINE> self . assertNotEqual ( self . _watcher . handle_fstab ( ignoretime = True ) , 0 ) <NEWLINE> <DEDENT>
class FetchableEntityApiMixin ( object ) : <NEWLINE> <INDENT> def _fetch ( self , id , entity_model = None ) : <NEWLINE> <INDENT> response = self . get ( endpoint = <STRING> . format ( id = id ) ) <NEWLINE> if response . status_code == 200 : <NEWLINE> <INDENT> return self . deserialize ( response , model = entity_model ) <NEWLINE> <DEDENT> self . handle ( response ) <NEWLINE> <DEDENT> <DEDENT>
class NoneAttrs ( object ) : <NEWLINE> <INDENT> def __getattr__ ( self , attr ) : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT>
def get_root_tree_identity ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return ( self . __class__ . tree_class , <NEWLINE> <INDENT> self . __workflow . workflow_name , <NEWLINE> self . __from_invocation . invocation_id , <NEWLINE> self . __relationship_type ) <NEWLINE> <DEDENT> <DEDENT>
def test_preprint_private_invisible_no_auth ( self ) : <NEWLINE> <INDENT> res = self . app . get ( self . url ) <NEWLINE> assert len ( res . json [ <STRING> ] ) == 1 <NEWLINE> self . project . is_public = False <NEWLINE> self . project . save ( ) <NEWLINE> res = self . app . get ( self . url , expect_errors = True ) <NEWLINE> assert_equal ( res . status_code , 401 ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import gzip <NEWLINE> import os <NEWLINE> from theano import config <NEWLINE> import numpy as np <NEWLINE>
def test_L3_Reaction_id ( self ) : <NEWLINE> <INDENT> id = <STRING> ; <NEWLINE> self . assertEqual ( False , self . R . isSetId ( ) ) <NEWLINE> self . R . setId ( id ) <NEWLINE> self . assert_ ( ( id == self . R . getId ( ) ) ) <NEWLINE> self . assertEqual ( True , self . R . isSetId ( ) ) <NEWLINE> if ( self . R . getId ( ) == id ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> pass <NEWLINE> <DEDENT>
class Role ( serializers . ModelSerializer ) : <NEWLINE> <INDENT> class Meta : <NEWLINE> <INDENT> model = RoleModel <NEWLINE> fields = ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <DEDENT> ) <NEWLINE> extra_kwargs = { <NEWLINE> <INDENT> <STRING> : { <NEWLINE> <INDENT> <STRING> : False , <NEWLINE> <DEDENT> } , <NEWLINE> <STRING> : { <NEWLINE> <INDENT> <STRING> : False , <NEWLINE> <DEDENT> } , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> <DEDENT>
def test_one_listener ( self ) : <NEWLINE> <INDENT> cb = MagicMock ( ) <NEWLINE> self . l . add_listener ( cb ) <NEWLINE> changes = dict ( foo = 32 ) <NEWLINE> self . l . notify_listeners ( changes ) <NEWLINE> cb . assert_called_once_with ( self . l , changes ) <NEWLINE> cb . reset_mock ( ) <NEWLINE> self . l . remove_listener ( cb ) <NEWLINE> self . l . notify_listeners ( dict ( bo = 3 ) ) <NEWLINE> self . assertEqual ( cb . call_count , 0 ) <NEWLINE> <DEDENT>
class WorkerPoolPaged ( Paged ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> _attribute_map = { <NEWLINE> <INDENT> <STRING> : { <STRING> : <STRING> , <STRING> : <STRING> } , <NEWLINE> <STRING> : { <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> <DEDENT> } <NEWLINE> def __init__ ( self , * args , ** kwargs ) : <NEWLINE> <INDENT> super ( WorkerPoolPaged , self ) . __init__ ( * args , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT>
from ... template . session . participatingSessionsContentGridsData import ParticipatingSessionsContentGridsData <NEWLINE> from ... utility import generateRandomString , generateGridTable <NEWLINE> from ... template . gridTableData import GridTableData <NEWLINE> from ... models import ResponseGrid <NEWLINE>
def FFT_inverse ( N , data ) : <NEWLINE> <INDENT> n = N / 2 <NEWLINE> norm = 0.0 <NEWLINE> FFT_transform_internal ( N , data , + 1 ) <NEWLINE> norm = 1 / float ( n ) <NEWLINE> for i in xrange ( N ) : <NEWLINE> <INDENT> data [ i ] *= norm <NEWLINE> <DEDENT> <DEDENT>
def update ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> self . _state = template . render ( self . hass , self . _template ) <NEWLINE> <DEDENT> except TemplateError as ex : <NEWLINE> <INDENT> if ex . args and ex . args [ 0 ] . startswith ( <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> _LOGGER . warning ( ex ) <NEWLINE> return <NEWLINE> <DEDENT> self . _state = None <NEWLINE> _LOGGER . error ( ex ) <NEWLINE> <DEDENT> <DEDENT>
import os <NEWLINE> import argparse <NEWLINE> import yaml <NEWLINE> import six <NEWLINE>
from django . db import models <NEWLINE> from django . contrib . contenttypes . fields import GenericForeignKey <NEWLINE> from django . contrib . contenttypes . models import ContentType <NEWLINE>
<STRING> <NEWLINE> from string import uppercase <NEWLINE> datas = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> datas += raw_input ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> score = lambda name , pos : sum ( uppercase . index ( c ) + 1 for c in name ) * pos <NEWLINE> datas = [ name . strip ( ) [ 1 : - 1 ] for name in datas . split ( <STRING> ) ] <NEWLINE> datas . sort ( ) <NEWLINE> print ( sum ( score ( name , pos + 1 ) for pos , name in enumerate ( datas ) ) ) <NEWLINE>
from tde . util . splits import check_intervals , truncate_intervals <NEWLINE> from tde . data . corpus import Corpus <NEWLINE> from tde . data . interval import Interval , IntervalDB <NEWLINE> from tde . data . classes import ClassDict , ClassID <NEWLINE> from tde . data . fragment import FragmentToken <NEWLINE> from tde . data . segment_annotation import SegmentAnnotation <NEWLINE>
def create_dataframe_from_files ( self , locations , df_format = <STRING> , csv_dates = None , index_col = None ) : <NEWLINE> <INDENT> local_file = self . work_folder + <STRING> <NEWLINE> self . _copy_features_locally ( locations , local_file , df_format ) <NEWLINE> return self . _convert_dataframe ( local_file , df_format , csv_dates , index_col ) <NEWLINE> <DEDENT>
def figures ( request ) : <NEWLINE> <INDENT> context = RequestContext ( request ) <NEWLINE> figure_list = Figure . objects . order_by ( <STRING> ) [ : 5 ] <NEWLINE> context_dict = { <STRING> : figure_list } <NEWLINE> return render_to_response ( <STRING> , context_dict , context ) <NEWLINE> <DEDENT>
from resort import Resort <NEWLINE> from conditions import Conditions <NEWLINE> from ski_pass import SkiPass <NEWLINE>
class SmartsnippetAppConfig ( django . apps . AppConfig ) : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> verbose_name = <STRING> <NEWLINE> verbose_plural_name = <STRING> <NEWLINE> <DEDENT>
class PostcodeForm ( forms . Form ) : <NEWLINE> <INDENT> postcode = GBPostcodeField ( <NEWLINE> <INDENT> widget = forms . TextInput ( <NEWLINE> <INDENT> attrs = { <STRING> : <STRING> } <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def clear_done_flag ( self ) : <NEWLINE> <INDENT> for stukje in self . puzzelstukjes : <NEWLINE> <INDENT> self . puzzelstukjes [ stukje ] . done = False <NEWLINE> <DEDENT> <DEDENT>
def tracking_collection ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . _track <NEWLINE> <DEDENT>
def is_prime ( p ) : <NEWLINE> <INDENT> if p <= SMALL_PRIMES [ - 1 ] : <NEWLINE> <INDENT> return p in SMALL_PRIMES <NEWLINE> <DEDENT> if not all ( p % q for q in SMALL_PRIMES ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if p < 1373653 : <NEWLINE> <INDENT> return miller_rabin ( p , 2 ) and miller_rabin ( p , 3 ) <NEWLINE> <DEDENT> elif p < 9080191 : <NEWLINE> <INDENT> return miller_rabin ( p , 31 ) and miller_rabin ( p , 73 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return miller_rabin ( p , 2 ) and miller_rabin ( p , 7 ) and miller_rabin ( p , 61 ) <NEWLINE> <DEDENT> <DEDENT>
class IOWarning ( UserWarning ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> pass <NEWLINE> <DEDENT>
class SaleOrder ( models . Model ) : <NEWLINE> <INDENT> _inherit = <STRING> <NEWLINE> def _prepare_order_line_procurement ( self , cr , uid , order , line , group_id = False , context = None ) : <NEWLINE> <INDENT> vals = super ( SaleOrder , self ) . _prepare_order_line_procurement ( cr , uid , order , line , group_id , context ) <NEWLINE> if line and line . address_allotment_id : <NEWLINE> <INDENT> vals [ <STRING> ] = line . address_allotment_id . id <NEWLINE> <DEDENT> return vals <NEWLINE> <DEDENT> <DEDENT>
def __eq__ ( self , other ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return comparison . float_equal ( self . x , other . x ) and comparison . float_equal ( self . y , other . y ) <NEWLINE> <DEDENT>
from collections import OrderedDict <NEWLINE> from django . contrib import admin <NEWLINE> from edc_export . actions import export_as_csv_action <NEWLINE> from edc_consent . actions import flag_as_verified_against_paper , unflag_as_verified_against_paper <NEWLINE> from edc_registration . models import RegisteredSubject <NEWLINE> from tshilo_dikotla . base_model_admin import MembershipBaseModelAdmin <NEWLINE> from . . forms import SpecimenConsentForm <NEWLINE> from . . models import SpecimenConsent <NEWLINE>
def test_getFitsWithShip_RifterFit ( DB , RifterFit ) : <NEWLINE> <INDENT> DB [ <STRING> ] . save ( RifterFit ) <NEWLINE> assert Fit . getFitsWithShip ( 587 ) [ 0 ] [ 1 ] == <STRING> <NEWLINE> DB [ <STRING> ] . remove ( RifterFit ) <NEWLINE> <DEDENT>
from __future__ import unicode_literals <NEWLINE> from thetvdb . exceptions import tvdb_attributenotfound , tvdb_episodenotfound , tvdb_error , tvdb_exception , tvdb_seasonnotfound , tvdb_showincomplete , tvdb_shownotfound , tvdb_userabort <NEWLINE> __author__ = <STRING> <NEWLINE> __version__ = <STRING> <NEWLINE> indexerExcepts = [ <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <STRING> , <STRING> ] <NEWLINE> <DEDENT> tvdbExcepts = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> ] <NEWLINE> <DEDENT> indexer_exception = tvdb_exception <NEWLINE> indexer_error = tvdb_error <NEWLINE> indexer_userabort = tvdb_userabort <NEWLINE> indexer_attributenotfound = tvdb_attributenotfound <NEWLINE> indexer_episodenotfound = tvdb_episodenotfound <NEWLINE> indexer_seasonnotfound = tvdb_seasonnotfound <NEWLINE> indexer_shownotfound = tvdb_shownotfound <NEWLINE> indexer_showincomplete = tvdb_showincomplete <NEWLINE>
<STRING> <NEWLINE> from django . dispatch import Signal <NEWLINE> vcs_post_push = Signal ( providing_args = [ <STRING> ] ) <NEWLINE> vcs_post_update = Signal ( providing_args = [ <STRING> , <STRING> ] ) <NEWLINE> vcs_pre_commit = Signal ( providing_args = [ <STRING> ] ) <NEWLINE> vcs_post_commit = Signal ( providing_args = [ <STRING> ] ) <NEWLINE> translation_post_add = Signal ( providing_args = [ <STRING> ] ) <NEWLINE> user_pre_delete = Signal ( ) <NEWLINE>
from gi . repository import Gtk <NEWLINE> from gi . repository . GdkPixbuf import Pixbuf <NEWLINE> from gi . repository import Gio <NEWLINE> import urllib2 <NEWLINE>
from django . conf . urls import url <NEWLINE> from django . contrib . auth . views import login , logout <NEWLINE> from charcoallog . accounts . views import register <NEWLINE> urlpatterns = [ <NEWLINE> <INDENT> url ( <STRING> , login , <NEWLINE> <INDENT> { <STRING> : <STRING> } , name = <STRING> ) , <NEWLINE> <DEDENT> url ( <STRING> , logout , <NEWLINE> <INDENT> { <STRING> : <STRING> } , name = <STRING> ) , <NEWLINE> <DEDENT> url ( <STRING> , register , name = <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE>
def cull ( self ) : <NEWLINE> <INDENT> for k , v in self . iteritems_older_than ( self . ttl ) : <NEWLINE> <INDENT> self . data . popitem ( last = False ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import config <NEWLINE> import code <NEWLINE> import mobile , widget , feed , util <NEWLINE> import webinstall <NEWLINE>
def saw_test ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . _lines_seen [ <STRING> ] += 1 <NEWLINE> <DEDENT>
def test_returns_a_403_error_if_no_journal_can_be_associated_with_the_current_user ( self ) : <NEWLINE> <INDENT> class MyView ( JournalScopeMixin , TemplateView ) : <NEWLINE> <INDENT> template_name = <STRING> <NEWLINE> <DEDENT> user = UserFactory . create ( ) <NEWLINE> journal = JournalFactory . create ( collection = self . collection ) <NEWLINE> url = reverse ( <NEWLINE> <INDENT> <STRING> , kwargs = { <STRING> : journal . pk } ) <NEWLINE> <DEDENT> request = self . get_request ( url ) <NEWLINE> request . user = user <NEWLINE> my_view = MyView . as_view ( ) <NEWLINE> with self . assertRaises ( PermissionDenied ) : <NEWLINE> <INDENT> my_view ( request , journal_pk = self . journal . pk ) <NEWLINE> <DEDENT> <DEDENT>
class CompassSensor ( sensor . DigitalSensor ) : <NEWLINE> <INDENT> __metaclass__ = _MetaCMPS_Nx <NEWLINE> def __init__ ( self , brick , port ) : <NEWLINE> <INDENT> super ( CompassSensor , self ) . __init__ ( brick , port ) <NEWLINE> self . sensor_type = Type . LOW_SPEED_9V <NEWLINE> self . mode = Mode . RAW <NEWLINE> self . set_input_mode ( ) <NEWLINE> sleep ( 0.1 ) <NEWLINE> <DEDENT> <DEDENT>
class SkipHours : <NEWLINE> <INDENT> <STRING> <NEWLINE> element_attrs = { } <NEWLINE> def __init__ ( self , hours ) : <NEWLINE> <INDENT> self . hours = hours <NEWLINE> <DEDENT> def publish ( self , handler ) : <NEWLINE> <INDENT> if self . hours : <NEWLINE> <INDENT> handler . startElement ( <STRING> , self . element_attrs ) <NEWLINE> for hour in self . hours : <NEWLINE> <INDENT> _element ( handler , <STRING> , str ( hour ) ) <NEWLINE> <DEDENT> handler . endElement ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def skew ( v ) : <NEWLINE> <INDENT> return sympy . Matrix ( [ [ 0 , - v [ 2 ] , v [ 1 ] ] , <NEWLINE> <INDENT> [ v [ 2 ] , 0 , - v [ 0 ] ] , <NEWLINE> [ - v [ 1 ] , v [ 0 ] , 0 ] ] ) <NEWLINE> <DEDENT> <DEDENT>
def get_object ( self ) : <NEWLINE> <INDENT> if not hasattr ( self , <STRING> ) : <NEWLINE> <INDENT> ipam_id = filters . get_int_or_uuid ( self . kwargs [ <STRING> ] ) <NEWLINE> try : <NEWLINE> <INDENT> self . _object = ipam_show ( self . request , ipam_id ) <NEWLINE> <DEDENT> except Exception : <NEWLINE> <INDENT> msg = _ ( <STRING> ) <NEWLINE> url = reverse ( <STRING> ) <NEWLINE> exceptions . handle ( self . request , msg , redirect = url ) <NEWLINE> <DEDENT> <DEDENT> return self . _object <NEWLINE> <DEDENT>
class FavCreateSerializer ( serializers . ModelSerializer ) : <NEWLINE> <INDENT> user = serializers . ReadOnlyField ( source = <STRING> ) <NEWLINE> foodtruck = serializers . PrimaryKeyRelatedField ( <NEWLINE> <INDENT> queryset = Foodtruck . objects . all ( ) , <NEWLINE> ) <NEWLINE> <DEDENT> class Meta : <NEWLINE> <INDENT> model = Fav <NEWLINE> fields = ( <STRING> , <STRING> , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def validateRegexp ( regexp ) : <NEWLINE> <INDENT> import re <NEWLINE> def inner ( user ) : <NEWLINE> <INDENT> if not re . match ( regexp , user ) : <NEWLINE> <INDENT> raise argparse . ArgumentTypeError ( <STRING> ) <NEWLINE> <DEDENT> return user <NEWLINE> <DEDENT> return inner <NEWLINE> <DEDENT>
def error ( * strings ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> global errors <NEWLINE> errors += 1 <NEWLINE> message = <STRING> . join ( str ( x ) for x in strings ) <NEWLINE> logging . error ( message ) <NEWLINE> return message <NEWLINE> <DEDENT>
class QuestionApp ( CMSApp ) : <NEWLINE> <INDENT> name = _ ( <STRING> ) <NEWLINE> urls = [ <STRING> ] <NEWLINE> <DEDENT>
from __future__ import print_function <NEWLINE> from openturns import * <NEWLINE> from math import * <NEWLINE> TESTPREAMBLE ( ) <NEWLINE> try : <NEWLINE> <INDENT> b = Basis ( ) <NEWLINE> print ( <STRING> , b ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> import sys <NEWLINE> print ( <STRING> , sys . exc_info ( ) [ 0 ] , sys . exc_info ( ) [ 1 ] ) <NEWLINE> <DEDENT>
def add_node ( self , node , parent = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not isinstance ( node , TreeViewNode ) : <NEWLINE> <INDENT> raise TreeViewException ( <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if parent is None and self . _root : <NEWLINE> <INDENT> parent = self . _root <NEWLINE> <DEDENT> if parent : <NEWLINE> <INDENT> parent . is_leaf = False <NEWLINE> parent . nodes . append ( node ) <NEWLINE> node . parent_node = parent <NEWLINE> node . level = parent . level + 1 <NEWLINE> <DEDENT> node . bind ( size = self . _trigger_layout ) <NEWLINE> self . _trigger_layout ( ) <NEWLINE> return node <NEWLINE> <DEDENT>
def set_context ( self , serializer ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . instance = getattr ( serializer , <STRING> , None ) <NEWLINE> <DEDENT>
def createAuthQuery ( self ) : <NEWLINE> <INDENT> query = self . API_QUERY <NEWLINE> query [ <STRING> ] = self . _usr <NEWLINE> query [ <STRING> ] = self . _pwd <NEWLINE> return query <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import numpy as np <NEWLINE> import pandas as pd <NEWLINE> steps_df = pd . read_csv ( <STRING> , <NEWLINE> <INDENT> index_col = 0 , parse_dates = True ) <NEWLINE> <DEDENT>
class IssueQuerySet ( QuerySet ) : <NEWLINE> <INDENT> def published ( self ) : <NEWLINE> <INDENT> return self . filter ( is_published = True ) <NEWLINE> <DEDENT> <DEDENT>
import unittest <NEWLINE> from ubuntutweak . settings . gsettings import Schema <NEWLINE> from ubuntutweak . settings . gconfsettings import GconfSetting <NEWLINE>
<STRING> <NEWLINE> import os <NEWLINE> os . chdir ( <STRING> ) <NEWLINE> f = open ( <STRING> , <STRING> ) . read ( ) [ : - 1 ] <NEWLINE> d = { } <NEWLINE> for i in f : <NEWLINE> <INDENT> if i not in d : <NEWLINE> <INDENT> d [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i ] = d [ i ] + 1 <NEWLINE> <DEDENT> <DEDENT> for items in d : <NEWLINE> <INDENT> print ( items , d [ items ] ) <NEWLINE> <DEDENT> <STRING> <NEWLINE>
def erepl ( t ) : <NEWLINE> <INDENT> bad = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in bad : <NEWLINE> <INDENT> t = t . replace ( i , <STRING> ) <NEWLINE> <DEDENT> return t . split ( <STRING> ) <NEWLINE> <DEDENT>
def getConfig ( ) : <NEWLINE> <INDENT> confFile = open ( <STRING> , <STRING> ) <NEWLINE> conf = yaml . load ( confFile ) <NEWLINE> confFile . close <NEWLINE> return conf <NEWLINE> <DEDENT>
class VolumePerturbAugmentor ( AugmentorBase ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , rng , min_gain_dBFS , max_gain_dBFS ) : <NEWLINE> <INDENT> self . _min_gain_dBFS = min_gain_dBFS <NEWLINE> self . _max_gain_dBFS = max_gain_dBFS <NEWLINE> self . _rng = rng <NEWLINE> <DEDENT> def transform_audio ( self , audio_segment ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> gain = self . _rng . uniform ( min_gain_dBFS , max_gain_dBFS ) <NEWLINE> audio_segment . apply_gain ( gain ) <NEWLINE> <DEDENT> <DEDENT>
from __future__ import absolute_import , division , print_function <NEWLINE> from . form import Form , TornadoInputWrapper <NEWLINE> __author__ = <STRING> <NEWLINE> __since__ = <STRING> <NEWLINE> __version__ = <STRING> <NEWLINE> __all__ = [ <STRING> , <STRING> ] <NEWLINE>
import glob <NEWLINE> import os <NEWLINE> import re <NEWLINE> import shutil <NEWLINE> import cleanttl <NEWLINE> from ttlhead import ttlhead <NEWLINE>
from flask import Blueprint <NEWLINE> index = Blueprint ( <STRING> , __name__ , template_folder = <STRING> ) <NEWLINE> from . import view <NEWLINE>
<STRING> <NEWLINE> <STRING> <NEWLINE> import urllib2 <NEWLINE> from BeautifulSoup import BeautifulSoup <NEWLINE> from smap . driver import SmapDriver <NEWLINE> from smap . util import periodicSequentialCall <NEWLINE> from twisted . python import log <NEWLINE>
def handler ( fit , skill , context ) : <NEWLINE> <INDENT> fit . modules . filteredItemBoost ( lambda mod : mod . item . requiresSkill ( skill ) , <STRING> , <NEWLINE> <INDENT> skill . getModifiedItemAttr ( <STRING> ) * skill . level ) <NEWLINE> <DEDENT> <DEDENT>
def get_config ( ) : <NEWLINE> <INDENT> config = { <STRING> : PronounPrediction , <NEWLINE> <INDENT> <STRING> : [ 50 ] , <NEWLINE> <STRING> : 50 , <NEWLINE> <STRING> : T . tanh , <NEWLINE> <STRING> : cross_entropy , <NEWLINE> <STRING> : 100000 , <NEWLINE> <STRING> : 1000 , <NEWLINE> <STRING> : 100 , <NEWLINE> <STRING> : 23 , <NEWLINE> <STRING> : ( 4 , 4 ) , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : [ <STRING> ] , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : 3 } <NEWLINE> <DEDENT> return config <NEWLINE> <DEDENT>
def delete_frame ( self , key , ignoreMissingKey = True , timeoutSecs = 60 , ** kwargs ) : <NEWLINE> <INDENT> assert key is not None , <STRING> <NEWLINE> result = self . __do_json_request ( <STRING> + key , cmd = <STRING> , timeout = timeoutSecs ) <NEWLINE> if not ignoreMissingKey and <STRING> in result : <NEWLINE> <INDENT> raise ValueError ( <STRING> + key ) <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import copy <NEWLINE> import json <NEWLINE> import uuid <NEWLINE> from migrate . versioning import api as versioning_api <NEWLINE> import sqlalchemy <NEWLINE> from keystone . common import sql <NEWLINE> from keystone . common . sql import migration <NEWLINE> from keystone import config <NEWLINE> from keystone import test <NEWLINE> import default_fixtures <NEWLINE> CONF = config . CONF <NEWLINE> DEFAULT_DOMAIN_ID = CONF . identity . default_domain_id <NEWLINE>
class CustomUserCreationForm ( UserCreationForm ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> class Meta ( UserCreationForm . Meta ) : <NEWLINE> <INDENT> model = User <NEWLINE> <DEDENT> def clean_username ( self ) : <NEWLINE> <INDENT> username = self . cleaned_data [ <STRING> ] <NEWLINE> try : <NEWLINE> <INDENT> User . _default_manager . get ( username = username ) <NEWLINE> <DEDENT> except User . DoesNotExist : <NEWLINE> <INDENT> return username <NEWLINE> <DEDENT> raise forms . ValidationError ( <NEWLINE> <INDENT> self . error_messages [ <STRING> ] , <NEWLINE> code = <STRING> , <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> <DEDENT>
class Pentium ( Machine ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def load ( self , factory , fp ) : <NEWLINE> <INDENT> from lang . asm . att_lexer import Lexer <NEWLINE> from lang . asm . att_parser import Parser <NEWLINE> lexer = Lexer ( fp ) <NEWLINE> parser = Parser ( lexer , factory = factory ) <NEWLINE> term = parser . start ( ) <NEWLINE> return term <NEWLINE> <DEDENT> def translate ( self , term ) : <NEWLINE> <INDENT> from machine . pentium import translator <NEWLINE> from transf . context import Context <NEWLINE> term = translator . doModule . apply ( term , Context ( ) ) <NEWLINE> return term <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import optparse <NEWLINE> import sys <NEWLINE> import test . test_endtoend <NEWLINE> import unittest <NEWLINE> _DEFAULT_WEB_SOCKET_PORT = 80 <NEWLINE>
def read_cat_facts_file ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> dir = os . path . dirname ( __file__ ) <NEWLINE> fact_file_path = os . path . join ( dir , <STRING> ) <NEWLINE> for line in open ( fact_file_path ) : <NEWLINE> <INDENT> self . cat_facts . append ( line . rstrip ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> self . log . error ( <STRING> % fact_file_path ) <NEWLINE> <DEDENT> <DEDENT>
from sqlalchemy import Boolean , Column , DateTime <NEWLINE> from sqlalchemy import MetaData , Integer , String , Table <NEWLINE> from nova . openstack . common import log as logging <NEWLINE> LOG = logging . getLogger ( __name__ ) <NEWLINE>
def test_endpoint ( self ) : <NEWLINE> <INDENT> customer = invoiced . Customer ( self . client , 123 ) <NEWLINE> self . assertEqual ( <STRING> , customer . endpoint ( ) ) <NEWLINE> customer . set_endpoint_base ( <STRING> ) <NEWLINE> self . assertEqual ( <STRING> , customer . endpoint_base ( ) ) <NEWLINE> self . assertEqual ( <STRING> , customer . endpoint ( ) ) <NEWLINE> <DEDENT>
import json <NEWLINE> import requests <NEWLINE> TIMEOUT = 30 <NEWLINE>
import os <NEWLINE> import shutil <NEWLINE> import logging <NEWLINE> import tarfile <NEWLINE> import tempfile <NEWLINE> import subprocess <NEWLINE> import distutils . spawn <NEWLINE> from threading import Thread <NEWLINE> if not distutils . spawn . find_executable ( <STRING> ) : <NEWLINE> <INDENT> raise ImportError ( <STRING> ) <NEWLINE> <DEDENT>
def logadd ( self , a , b ) : <NEWLINE> <INDENT> g = T . maximum ( a , b ) <NEWLINE> l = T . minimum ( a , b ) <NEWLINE> return g + T . log ( 1 + T . exp ( l - g ) ) <NEWLINE> <DEDENT>
def _compare_periods ( self , first : Period , second : Period ) : <NEWLINE> <INDENT> self . assertEqual ( first . start , second . start ) <NEWLINE> self . assertEqual ( first . duration , second . duration ) <NEWLINE> return True <NEWLINE> <DEDENT>
helptable = { <NEWLINE> <INDENT> <STRING> : <NEWLINE> <STRING> , <NEWLINE> <STRING> : <NEWLINE> <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <DEDENT> } <NEWLINE>
def plot_dista_distrib_autocor ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> plt . plot ( np . arange ( self . _min_hop_shift , self . _max_hop_shift ) * self . gcd / float ( self . sampling_rate ) , self . dista_distrib_autocor ) <NEWLINE> plt . title ( <STRING> ) <NEWLINE> plt . xlabel ( <STRING> ) <NEWLINE> plt . ylabel ( <STRING> ) <NEWLINE> plt . show ( ) <NEWLINE> <DEDENT>
def evaluateModuleMSE ( self , module , averageOver = 1 , ** args ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> res = 0. <NEWLINE> for dummy in range ( averageOver ) : <NEWLINE> <INDENT> module . reset ( ) <NEWLINE> res += self . evaluateMSE ( module . activate , ** args ) <NEWLINE> <DEDENT> return res / averageOver <NEWLINE> <DEDENT>
def web_delete_authzs_bucket ( key_name , bucket ) : <NEWLINE> <INDENT> with db_trans ( ) as c : <NEWLINE> <INDENT> c . execute ( <STRING> <NEWLINE> <INDENT> <STRING> , locals ( ) ) <NEWLINE> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <DEDENT>
class Tfg_Asig ( models . Model ) : <NEWLINE> <INDENT> tfg = models . ForeignKey ( Tfg , default = None ) <NEWLINE> alumno_1 = models . ForeignKey ( Alumno , related_name = <STRING> , default = None ) <NEWLINE> alumno_2 = models . ForeignKey ( Alumno , related_name = <STRING> , default = None , null = True ) <NEWLINE> alumno_3 = models . ForeignKey ( Alumno , related_name = <STRING> , default = None , null = True ) <NEWLINE> <DEDENT>
def WritePotentialLeaks ( graph_dumps ) : <NEWLINE> <INDENT> for graph in graph_dumps : <NEWLINE> <INDENT> if graph . leaks : <NEWLINE> <INDENT> filename = <STRING> % ( graph . pid , graph . heap ) <NEWLINE> output_filename = os . path . join ( _OUTPUT_DIR , filename ) <NEWLINE> with open ( output_filename , <STRING> ) as output : <NEWLINE> <INDENT> json . dump ( graph . leaks , output ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> form = cgi . FieldStorage ( ) <NEWLINE> if ( form . has_key ( <STRING> ) and form . has_key ( <STRING> ) and form . has_key ( <STRING> ) ) : <NEWLINE> <INDENT> if ( form [ <STRING> ] . value == <STRING> ) : <NEWLINE> <INDENT> display_data ( form [ <STRING> ] . value , form [ <STRING> ] . value ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> generate_form ( ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from __future__ import division <NEWLINE> import docopt <NEWLINE> import os <NEWLINE> import pandas as pd <NEWLINE> import propyte <NEWLINE> import sklearn . preprocessing <NEWLINE> name = <STRING> <NEWLINE> version = <STRING> <NEWLINE> logo = name <NEWLINE>
class test_Potential_1d ( object ) : <NEWLINE> <INDENT> def test_single_run ( self ) : <NEWLINE> <INDENT> P = Potential_1d_single_run ( ) <NEWLINE> <DEDENT> def test_many_runs ( self ) : <NEWLINE> <INDENT> P = Potential_1d_many_runs ( ) <NEWLINE> <DEDENT> <DEDENT>
from django . contrib import admin <NEWLINE> from django . contrib . admin import AdminSite <NEWLINE> from . models import Figure <NEWLINE> from . models import Animation <NEWLINE>
class CartItemInline ( admin . TabularInline ) : <NEWLINE> <INDENT> model = CartItem <NEWLINE> extra = 0 <NEWLINE> exclude = ( <STRING> , ) <NEWLINE> readonly_fields = ( <STRING> , ) <NEWLINE> <DEDENT>
class DiskCommand ( ConstantBase ) : <NEWLINE> <INDENT> FUA = ( ) <NEWLINE> AHEAD = ( ) <NEWLINE> SYNC = ( ) <NEWLINE> META = ( ) <NEWLINE> FLUSH = ( ) <NEWLINE> <DEDENT>
def thread_run ( ) : <NEWLINE> <INDENT> Log . logger . debug ( <STRING> ) <NEWLINE> return <STRING> <NEWLINE> <DEDENT>
def test_with_many_matching_ignore_channel_patterns ( self ) : <NEWLINE> <INDENT> self . destalinator = destalinator . Destalinator ( self . slacker , self . slackbot , activated = True ) <NEWLINE> self . destalinator . config . config [ <STRING> ] = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> self . assertTrue ( self . destalinator . ignore_channel ( <STRING> ) ) <NEWLINE> <DEDENT>
