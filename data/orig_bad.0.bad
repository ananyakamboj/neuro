def test_delitem_keyerror ( self ) : <NEWLINE> <INDENT> e = EntryBase ( req_ ( ) <NEWLINE> del e [ <STRING> ] <NEWLINE> <DEDENT>
def retranslateUi ( self , SettingsDialog_base ) : <NEWLINE> <INDENT> SettingsDialog_base . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . textLabel3_2_2 . setText ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def process ( fn , mergefile = None , lazy = False ) : <NEWLINE> <INDENT> if lazy and mergefile and os . stat ( fn ) . st_mtime < os . stat ( mergefile ) . st_mtime : <NEWLINE> return <NEWLINE> print ( mergefile ) <NEWLINE> gen = Gen ( ) <NEWLINE> directives . execute ( directives . load ( fn ) , gen ) <NEWLINE> result = gen . generate ( ) <NEWLINE> if mergefile is None : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> else : <NEWLINE> print ( <STRING> % ( fn , mergefile ) ) <NEWLINE> <INDENT> result = merge ( mergefile , result ) <NEWLINE> <DEDENT> <DEDENT>
def samePath ( path1 , path2 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if os . path . abspath ( path1 ) == os . path . abspath ( path2 ) : <NEWLINE> return True <NEWLINE> else : <NEWLINE> return False <NEWLINE> <DEDENT>
def output_to_file ( filename , mode = <STRING> ) : <NEWLINE> <INDENT> with contextlib . closing ( open ( filename , mode ) ) as port : <NEWLINE> with CURRENT_OUTPUT_PORT . let ( port ) : <NEWLINE> <INDENT> yield <NEWLINE> <DEDENT> <DEDENT>
def create ( self , req , body = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> context = req . environ [ <STRING> ] <NEWLINE> authorize ( context ) <NEWLINE> pk , cert = rpc . call ( context , FLAGS . cert_topic , <NEWLINE> <INDENT> { <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : { <STRING> : context . user_id , <NEWLINE> <INDENT> <STRING> : context . project_id } ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> context = req . environ [ <STRING> ] <NEWLINE> return { <STRING> : _translate_certificate_view ( cert , pk ) } <NEWLINE> <DEDENT>
def get_mimetype ( res , filename ) : <NEWLINE> <INDENT> if res in ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> ) : <NEWLINE> guessed_type , _ = mimetypes . guess_type ( filename ) <NEWLINE> if guessed_type : <NEWLINE> res = guessed_type <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT>
def _GenApiConfigCallback ( args , api_func = GenApiConfig ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> service_configs = api_func ( args . service <NEWLINE> <INDENT> hostname = args . hostname , <NEWLINE> application_path = args . application ) <NEWLINE> <DEDENT> for api_name_version , config in service_configs . iteritems ( ) : <NEWLINE> <INDENT> _WriteFile ( args . output , api_name_version + <STRING> , config ) <NEWLINE> <DEDENT> <DEDENT>
def expand_light_count ( dimmed_rgb count ) : <NEWLINE> <INDENT> dmx_channels = [ ] <NEWLINE> for light in range ( count ) : <NEWLINE> <INDENT> dmx_channels . extend ( dimmed_rgb ) <NEWLINE> <DEDENT> return dmx_channels <NEWLINE> <DEDENT>
( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
( <STRING> % ( n_atoms , len ( coordinates ) ) <NEWLINE> <DEDENT> return atoms , coordinates <NEWLINE> <DEDENT>
def read_file ( self , tmp_file ) : <NEWLINE> <INDENT> self . getLogger ( ) . debug ( <STRING> ) <NEWLINE> ts = time . time ( ) <NEWLINE> self . _logger . debug ( ts ) <NEWLINE> with open ( tmp_file , <STRING> ) as stateFile : <NEWLINE> <INDENT> fileJsonState = json . load ( stateFile ) <NEWLINE> if fileJsonState is not None : <NEWLINE> self . jsonState = fileJsonState <NEWLINE> <DEDENT> stateFile . close ( ) <NEWLINE> self . createWindowExercises ( ) <NEWLINE> <DEDENT>
class UserNotice ( types . Sequence ) : <NEWLINE> <INDENT> components = ( <NEWLINE> <INDENT> types . Component ( NOTICE_REF , NoticeReference , optional = True ) , <NEWLINE> types . Component ( EXPLICIT_TEXT , DisplayText , optional = True ) <NEWLINE> <DEDENT> <DEDENT>
class DBVistrail ( _DBVistrail ) : <NEWLINE> <INDENT> def __init__ ( self , * args , ** kwargs ) : <NEWLINE> _DBVistrail . __init__ ( self , * args , ** kwargs ) <NEWLINE> <INDENT> self . idScope = IdScope ( ) <NEWLINE> self . idScope . setBeginId ( <STRING> , 1 ) <NEWLINE> <DEDENT> <DEDENT>
def _wait ( timeout , cloud , server , action ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for count in shade . _utils . _iterate_timeout ( <NEWLINE> <INDENT> timeout , <NEWLINE> <STRING> % action ) : <NEWLINE> try : <NEWLINE> server = cloud . get_server ( server . id ) <NEWLINE> except Exception : <NEWLINE> continue <NEWLINE> if server . status == _action_map [ action ] : <NEWLINE> return <NEWLINE> if server . status == <STRING> : <NEWLINE> module . fail_json ( msg = <STRING> % action ) <NEWLINE> <DEDENT> <DEDENT>
class Comment ( models . Model ) : <NEWLINE> <INDENT> comment_title = models . ForeignKey ( <STRING> ) <NEWLINE> comment_body = models . TextField ( ) <NEWLINE> comment_author = models . CharField ( max_length = 60 ) <NEWLINE> comment_created = models . DateField ( ) <NEWLINE> comment_updated = models . DateField ( ) <NEWLINE> def body_first_sixty ( self ) : <NEWLINE> <INDENT> return self . title [ : 60 ] <NEWLINE> <INDENT> def __unicode__ ( self ) : <NEWLINE> <DEDENT> return self . comment_author <NEWLINE> <DEDENT> <DEDENT>
class _ListSetter : <NEWLINE> <INDENT> def __init__ ( self , L ) : <NEWLINE> <INDENT> self . L = L <NEWLINE> <DEDENT> def setitem ( self , ( item , value ) ) : <NEWLINE> <INDENT> diff = item - len ( self . L ) + 1 <NEWLINE> if diff > 0 : <NEWLINE> <INDENT> self . L . extend ( [ None ] * diff ) <NEWLINE> <DEDENT> self . L [ item ] = value <NEWLINE> <DEDENT> <DEDENT>
def load_processing_settings ( settings ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> processing_settings_path = settings [ <STRING> ] <NEWLINE> with open ( processing_settings_path , <STRING> ) as f : <NEWLINE> <INDENT> settings . update ( yaml . load ( f . read ( ) ) ) ) <NEWLINE> <DEDENT> <DEDENT>
def raise_object ( self , name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> try : avatar = self . avatars [ name ] <NEWLINE> except : self . debug ( <STRING> % name ) <NEWLINE> else : <NEWLINE> <INDENT> self . sprites . above ( avatar ) <NEWLINE> self . redraw ( avatar . rect ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from django . views import generic <NEWLINE> from viewflow import views as flow_views <NEWLINE> class CreateRequestView ( flow_views . StartViewMixin , <NEWLINE> <INDENT> generic . UpdateView ) : <NEWLINE> fields = [ <STRING> ] <NEWLINE> def get_object ( self ) : <NEWLINE> return self . activation . process <NEWLINE> <DEDENT> class ApproveRequestView ( flow_views . TaskViewMixin , <NEWLINE> <INDENT> generic . UpdateView ) : <NEWLINE> fields = [ <STRING> ] <NEWLINE> def get_object ( self ) : <NEWLINE> return self . activation . process <NEWLINE> <DEDENT>
def test_monitor_ac_usage_leave_on ( fake_events , arduino ) : <NEWLINE> <INDENT> old_event = fake_events . timestamp <NEWLINE> monitor_ac_usage ( ) <NEWLINE> new_event = Event . last_event ( ) <NEWLINE> old_event = Event . query . filter ( Event . timestamp == old_event ) . first ( ) <NEWLINE> assert naturally_equivalent ( old_event new_event ) <NEWLINE> assert new_event . event == EventType . on <NEWLINE> assert new_event . event_description is None <NEWLINE> <DEDENT>
def prevent_l3_port_deletion ( self , context , port_id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> port_db = self . _core_plugin . _get_port ( context , port_id ) <NEWLINE> if port_db [ <STRING> ] in [ DEVICE_OWNER_ROUTER_INTF , <NEWLINE> <INDENT> DEVICE_OWNER_ROUTER_GW , <NEWLINE> DEVICE_OWNER_FLOATINGIP ] : <NEWLINE> fixed_ips = port_db [ <STRING> ] <NEWLINE> if fixed_ips : <NEWLINE> raise l3 . L3PortInUse ( port_id = port_id , <NEWLINE> device_owner = port_db [ <STRING> ] ) <NEWLINE> else : <NEWLINE> LOG . debug ( _ ( <STRING> <NEWLINE> <STRING> ) , <NEWLINE> { <STRING> : port_db [ <STRING> ] , <NEWLINE> <STRING> : port_db [ <STRING> ] } ) <NEWLINE> <DEDENT> <DEDENT>
def _BecomePager ( pager ) : <NEWLINE> <INDENT> a , b , c = select . select ( [ 0 ] , [ ] , [ 0 ] ) <NEWLINE> os . environ [ <STRING> ] = <STRING> <NEWLINE> try : <NEWLINE> <INDENT> os . execvp ( pager , [ pager ] ) <NEWLINE> <DEDENT> except OSError , e : <NEWLINE> <INDENT> os . execv ( <STRING> , [ <STRING> , <STRING> , pager ] ) <NEWLINE> <DEDENT> <DEDENT>
def test_get_with_unpopulated_report ( self ) : <NEWLINE> <INDENT> report = models . SectorsReport . objects . create ( soc_codes = <STRING> ) <NEWLINE> with patch ( <STRING> , <NEWLINE> <INDENT> new_callable = PropertyMock ) as mock_is_populated : <NEWLINE> mock_is_populated . return_value = False <NEWLINE> response = self . client . get ( <NEWLINE> reverse ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> kwargs = { <NEWLINE> <INDENT> <STRING> : report . pk <NEWLINE> <DEDENT> } <NEWLINE> ) <NEWLINE> ) <NEWLINE> self . assertEqual ( response . status_code , 202 ) <NEWLINE> self . assertTemplateUsed ( response , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def usage ( ) : <NEWLINE> <INDENT> print ( ( <STRING> ) . format ( sys . argv [ 0 ] ) ) <NEWLINE> print ( ( <STRING> ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT>
def get_bitstring ( integer , length ) : <NEWLINE> <INDENT> bitString = bin ( integer ) <NEWLINE> resultString = <STRING> <NEWLINE> if length < 1 : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> bitStringLength = len ( bitString ) <NEWLINE> if bitStringLength > length : <NEWLINE> <INDENT> position = 1 <NEWLINE> while position <= length : <NEWLINE> <INDENT> resultString = bitString [ ( bitStringLength - position ) : ( ( bitStringLength - position ) + 1 ) ] + resultString <NEWLINE> position += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> resultString = bitString <NEWLINE> while ( len ( resultString ) < length ) : <NEWLINE> resultString = <STRING> + resultString <NEWLINE> <DEDENT> return resultString <NEWLINE> <DEDENT>
def test_story_with_pre_tags ( self ) : <NEWLINE> <INDENT> text = <STRING> <STRING> <STRING> <STRING> item = { <STRING> : text } <NEWLINE> res , diff = preserve ( item ) <NEWLINE> self . assertEqual ( item [ <STRING> ] , <STRING> ) <NEWLINE> <DEDENT>
def PrintFailureHeader ( self , test ) : <NEWLINE> <INDENT> if test . IsNegative ( ) : <NEWLINE> <INDENT> negative_marker = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> negative_marker = <STRING> <NEWLINE> <DEDENT> print ( <STRING> % { <NEWLINE> <INDENT> <STRING> : test . GetLabel ( ) , <NEWLINE> <STRING> : negative_marker <NEWLINE> <DEDENT> } <NEWLINE> print ( <STRING> % <STRING> . join ( test . path ) ) <NEWLINE> <DEDENT>
def is_django_dir ( path ) : <NEWLINE> <INDENT> path = validations . is_local_dir_exists ( path ) <NEWLINE> manage = os . path . join ( path , <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> validations . is_local_file_exists ( manage ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> raise ValueError , _ ( <STRING> ) <NEWLINE> <DEDENT> return path <NEWLINE> <DEDENT>
def _putline ( self , line ) : <NEWLINE> <INDENT> if self . _debugging > 1 : <NEWLINE> <INDENT> print <STRING> , repr ( line ) <NEWLINE> <DEDENT> self . sock . sendall ( <STRING> % ( line , CRLF ) ) <NEWLINE> <DEDENT>
def setup_module ( module ) : <NEWLINE> <INDENT> for variable in ( <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> ) : <NEWLINE> if variable in os . environ : <NEWLINE> del os . environ [ variable ] <NEWLINE> <DEDENT> run . external = outer is None <NEWLINE> import tempfile <NEWLINE> run . work = tempfile . mktemp ( ) <NEWLINE> <DEDENT>
from settings import * <NEWLINE> DEBUG = False <NEWLINE> TEMPLATE_DEBUG = DEBUG <NEWLINE> THUMBNAIL_DEBUG = DEBUG <NEWLINE> } BASES = { <NEWLINE> <INDENT> <STRING> : { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> EMAIL_HOST = <STRING> <NEWLINE> EMAIL_PORT = 25 <NEWLINE>
def get_logo ( size ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if deluge . common . windows_check ( ) or deluge . common . osx_check ( ) : <NEWLINE> <INDENT> return gtk . gdk . pixbuf_new_from_file_at_size ( deluge . common . get_pixmap ( <STRING> ) , size , size ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return gtk . gdk . pixbuf_new_from_file_at_size ( deluge . common . get_pixmap ( <STRING> ) , size , size ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> log . warning ( e ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def TestRapiInstanceFailover ( instance ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not IsFailoverSupported ( instance ) : <NEWLINE> <INDENT> print ( qa_utils . FormatInfo ( <STRING> ) <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> _WaitForRapiJob ( _rapi_client . FailoverInstance ( instance . name ) ) <NEWLINE> qa_utils . RunInstanceCheck ( instance , True ) <NEWLINE> _WaitForRapiJob ( _rapi_client . FailoverInstance ( instance . name ) ) <NEWLINE> <DEDENT>
class UpdateReplace ( Exception ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> _message = _ ( <STRING> ) <NEWLINE> def __init__ ( self , resource_name = <STRING> , <NEWLINE> <INDENT> message = _ ( <STRING> ) ) : <NEWLINE> try : <NEWLINE> msg = message % resource_name <NEWLINE> except TypeError : <NEWLINE> msg = message <NEWLINE> super ( Exception , self ) . __init__ ( msg ) <NEWLINE> <DEDENT> <DEDENT>
def await_completion ( self ) : <NEWLINE> <INDENT> update = self . visible_updates . take ( ) <NEWLINE> try : <NEWLINE> <INDENT> if update . exception : <NEWLINE> <INDENT> t , v , tb = update . exc_info <NEWLINE> raise t , v , tb <NEWLINE> <DEDENT> <DEDENT> finally : <NEWLINE> <INDENT> self . executor_service . shutdown ( ) <NEWLINE> <DEDENT> <DEDENT>
def test_upload__others_invalid ( self , _ ) : <NEWLINE> <INDENT> self . reddit . read_only = False <NEWLINE> with self . recorder . use_cassette ( <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> for method in [ <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ] : <NEWLINE> <DEDENT> with pytest . raises ( APIException ) as excinfo : <NEWLINE> <INDENT> getattr ( self . subreddit . stylesheet , method ) ( <NEWLINE> <INDENT> self . image_path ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> assert excinfo . value . error_type == <STRING> <NEWLINE> <DEDENT> <DEDENT>
class Limiter ( object ) : <NEWLINE> <INDENT> limit = timedelta ( seconds = 1 ) <NEWLINE> last = datetime . now ( ) <NEWLINE> def wait ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> now = datetime . now ( ) <NEWLINE> dt = now - self . last <NEWLINE> if dt < self . limit : <NEWLINE> <INDENT> sleep_time = ( self . limit - dt ) . seconds <NEWLINE> <INDENT> + float ( 0.000001 ) * ( self . limit - dt ) . microseconds <NEWLINE> <DEDENT> sleep ( sleep_time ) <NEWLINE> <DEDENT> self . last = datetime . now ( ) <NEWLINE> return dt <NEWLINE> <DEDENT> <DEDENT>
class FipRulePriorityAllocator ( ItemAllocator ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , data_store_path , priority_rule_start , <NEWLINE> <INDENT> priority_rule_end ) : <NEWLINE> <STRING> <NEWLINE> pool = set ( FipPriority ( str ( s ) ) for s in range ( priority_rule_start , <NEWLINE> <INDENT> priority_rule_end ) ) <NEWLINE> super ( FipRulePriorityAllocator , self ) . __init__ ( data_store_path , <NEWLINE> <INDENT> FipPriority , <NEWLINE> pool ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def sum ( lst ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for i in range ( len ( lst ) : <NEWLINE> <INDENT> tmp = tmp + lst [ i ] <NEWLINE> <DEDENT> return tmp <NEWLINE> <DEDENT>
def _find_existing_gist_by_name ( self , gist_args , nb_filename , py_filename ) : <NEWLINE> <INDENT> match_counter = 0 <NEWLINE> matchID = None <NEWLINE> for gist in gist_args : <NEWLINE> <INDENT> gist_files = gist . get ( <STRING> , None ) <NEWLINE> if ( gist_files is not None and nb_filename in gist_files and <NEWLINE> <INDENT> py_filename in gist_files ) : <NEWLINE> match_counter += 1 <NEWLINE> if <STRING> in gist : <NEWLINE> matchID = gist [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT> if match_counter > 1 : <NEWLINE> <INDENT> raise_error ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return matchID <NEWLINE> <DEDENT>
def check_adoptions ( ) : <NEWLINE> <INDENT> log . debug ( <STRING> ) <NEWLINE> for proposal in Proposal . all ( ) : <NEWLINE> <INDENT> if ( not proposal . adopted and proposal . is_adopt_polling ( ) <NEWLINE> <INDENT> and proposal . adopt_poll . is_stable ( ) ) : <NEWLINE> log . info ( <STRING> % <NEWLINE> <INDENT> proposal . title ) <NEWLINE> proposal . adopt ( ) <NEWLINE> meta . Session . commit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def mmPrettyPrintSequenceCellRepresentations ( self , sortby = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . _mmComputeTransitionTraces ( ) <NEWLINE> table = PrettyTable ( [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> for sequenceLabel , predictedActiveCells in ( <NEWLINE> <INDENT> self . _mmData [ <STRING> ] . iteritems ( ) ) : <NEWLINE> cellsForColumn = self . mapCellsToColumns ( predictedActiveCells ) <NEWLINE> for column , cells in cellsForColumn . iteritems ( ) : <NEWLINE> table . add_row ( [ sequenceLabel , column , list ( cells ) ] ) <NEWLINE> <DEDENT> return table . get_string ( sortby = sortby ) . encode ( <STRING> ) <NEWLINE> <DEDENT>
def test_check_equal ( self ) : <NEWLINE> <INDENT> task_api = self . compute_api . compute_task_api <NEWLINE> tests = set ( ) <NEWLINE> for ( name , value ) in inspect . getmembers ( self inspect . ismethod ) : <NEWLINE> <INDENT> if name . startswith ( <STRING> ) and name != <STRING> : <NEWLINE> <INDENT> tests . add ( name [ 5 : ] ) <NEWLINE> <DEDENT> <DEDENT> if tests != set ( task_api . cells_compatible ) : <NEWLINE> <INDENT> self . fail ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , local_endpoint , autobind = True , timeout = 0.5 , bind_single = False , debug = 0 ) : <NEWLINE> <INDENT> super ( PacketSocket , self ) . __init__ ( socket . AF_INET , socket . SOCK_DGRAM ) <NEWLINE> self . debug = debug <NEWLINE> self . local_endpoint = local_endpoint <NEWLINE> self . recvfrom_timeout = timeout <NEWLINE> self . settimeout ( self . recvfrom_timeout ) <NEWLINE> self . bbind_single = bind_single <NEWLINE> self . autobind = autobind <NEWLINE> if self . debug > 0 : <NEWLINE> <INDENT> print <STRING> % ( self . recvfrom_timeout ) <NEWLINE> <DEDENT> if self . autobind : <NEWLINE> <INDENT> self . packet_bind ( ) <NEWLINE> <DEDENT> <DEDENT>
def parse_result ( step , result ) : <NEWLINE> <INDENT> parsed = <STRING> % step <NEWLINE> keyless = parsed <NEWLINE> for key in [ <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> ] : <NEWLINE> if key in result : <NEWLINE> parsed = <STRING> % ( parsed , key , result [ key ] ) <NEWLINE> <DEDENT> if parsed == keyless : <NEWLINE> <INDENT> parsed = <STRING> % ( parsed , result ) <NEWLINE> <DEDENT> return parsed <NEWLINE> <DEDENT>
def test_get_regions_all_regions ( self ) : <NEWLINE> <INDENT> args = Namespace ( all_regions = True ) <NEWLINE> supported_regions = { <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <NEWLINE> , <NEWLINE> <STRING> , <STRING> , <STRING> } <NEWLINE> <DEDENT> all_regions = set ( get_regions ( args , None ) ) <NEWLINE> self . assertTrue ( all_regions . issuperset ( supported_regions ) ) <NEWLINE> <DEDENT>
def get_wsdl ( self url ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . __wsdl is None : <NEWLINE> <INDENT> return self . __build_wsdl ( url ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . __wsdl <NEWLINE> <DEDENT> <DEDENT>
def collide ( self , rect , propname ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> r = [ ] <NEWLINE> for object in self . get_in_region ( rect . left , rect . top , rect . right , <NEWLINE> <INDENT> rect . bottom ) : <NEWLINE> if propname in object or propname in self . properties : <NEWLINE> r . append ( object ) <NEWLINE> <DEDENT> return r <NEWLINE> <DEDENT>
def androidManifest ( topDomain , domain , appName , workingDir ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> manifestName = <STRING> <NEWLINE> outStr = <STRING> <STRING> <STRING> + topDomain + <STRING> + domain + <STRING> + appName + <STRING> <STRING> + appName + <STRING> <STRING> + appName + <STRING> <STRING> <STRING> + <STRING> <STRING> <STRING> <STRING> <STRING> fo = open ( workingDir + os . sep + manifestName , <STRING> ) <NEWLINE> fo . write ( outStr ) <NEWLINE> fo . close ( ) <NEWLINE> <DEDENT>
def OnAutoscale ( self , event ) : <NEWLINE> <INDENT> state = self . autoscale_button . GetValue ( ) <NEWLINE> <INDENT> if state : <NEWLINE> <INDENT> self . autoscale_button . SetLabel ( <STRING> ) <NEWLINE> self . autoscale_button . SetForegroundColour ( <STRING> ) <NEWLINE> self . plot_type = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . autoscale_button . SetLabel ( <STRING> ) <NEWLINE> self . autoscale_button . SetForegroundColour ( <STRING> ) <NEWLINE> self . plot_type = <STRING> <NEWLINE> <DEDENT> self . set_plot_type ( ) <NEWLINE> <DEDENT> <DEDENT>
def TestInstanceConvertDiskToPlain ( instance , inodes ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> name = instance . name <NEWLINE> template = instance . disk_template <NEWLINE> if template != constants . DT_DRBD8 : <NEWLINE> <INDENT> print ( qa_utils . FormatInfo ( <STRING> ) <NEWLINE> <INDENT> <STRING> % template ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> assert len ( inodes ) == 2 <NEWLINE> AssertCommand ( [ <STRING> , <STRING> , <STRING> , constants . DT_PLAIN , name ] ) <NEWLINE> AssertCommand ( [ <STRING> , <STRING> , <STRING> , constants . DT_DRBD8 , <NEWLINE> <INDENT> <STRING> , inodes [ 1 ] . primary , name ] ) <NEWLINE> <DEDENT> <DEDENT>
def get_drive_info ( drive , os_list_position ) : <NEWLINE> <INDENT> osVersion = [ ] <NEWLINE> for new_releases in drive [ <STRING> ] : <NEWLINE> <INDENT> osVersion += [ new_releases ] <NEWLINE> <DEDENT> osVersion_str = osVersion [ os_list_position ] <NEWLINE> dev_type_str = drive [ <STRING> ] [ osVersion_str ] [ <STRING> ] <NEWLINE> major_str = drive [ <STRING> ] [ osVersion_str ] [ <STRING> ] <NEWLINE> minor_str = drive [ <STRING> ] [ osVersion_str ] <STRING> ] <NEWLINE> firmware_str = drive [ <STRING> ] [ osVersion_str ] [ <STRING> ] <NEWLINE> model_str = drive [ <STRING> ] <NEWLINE> drive_info = DiskDrive ( osVersion_str , dev_type_str , major_str , minor_str , firmware_str , model_str ) <NEWLINE> return drive_info <NEWLINE> <DEDENT>
def parse ( text , execsnippet ) : <NEWLINE> <INDENT> result = None <NEWLINE> toparse = text <NEWLINE> try : <NEWLINE> <INDENT> exec execsnippet <NEWLINE> return result <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT>
def test_duplicate_global_local ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> exec <STRING> <NEWLINE> self . fail ( <STRING> ) <NEWLINE> <DEDENT> except SyntaxError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
( <NEWLINE> path = <STRING> , <NEWLINE> allowed_param = [ <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] + [ <STRING> % x for x in xrange ( 0 , 25 ) ] <NEWLINE> <DEDENT> <DEDENT>
def list_releases_scenario ( runner ) : <NEWLINE> <INDENT> runner . request ( <NEWLINE> <INDENT> method = <STRING> <NEWLINE> path = <STRING> % ( <NEWLINE> <INDENT> runner . org . slug , runner . default_project . slug ) <NEWLINE> <DEDENT> <DEDENT> ) <NEWLINE> <DEDENT>
def check_paired_end_read_consistency ( reads ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> pe_reads = reads [ : , 0 ] <NEWLINE> frag_lens = reads [ : , 1 ] <NEWLINE> num_reads = len ( pe_reads ) <NEWLINE> print ( <STRING> % ( num_reads ) ) <NEWLINE> print ( reads ) <NEWLINE> is_consistent = False <NEWLINE> is_consistent = all ( frag_lens [ nonzero ( pe_reads == 1 ) ] != - Inf ) <NEWLINE> if not is_consistent : <NEWLINE> return is_consistent <NEWLINE> is_consistent = all ( frag_lens [ nonzero ( pe_reads == 0 ) ] == - Inf ) <NEWLINE> return is_consistent <NEWLINE> <DEDENT>
def import_text ( filename , separator ) : <NEWLINE> <INDENT> for line in csv . reader ( open ( filename ) , delimiter = separator , <NEWLINE> <INDENT> skipinitialspace = True ) : <NEWLINE> if line : <NEWLINE> yield line <NEWLINE> <DEDENT> <DEDENT>
def test ( self ) : <NEWLINE> <INDENT> for exchange in self . exchanges : <NEWLINE> <INDENT> for ticker in self . Tickers [ exchange ] : <NEWLINE> print ( exchange , ticker ) <NEWLINE> try : <NEWLINE> <INDENT> print ( self . Ticker ( exchange , ticker ) ) <NEWLINE> except BTCEError as e : <NEWLINE> print ( <STRING> % e . value ) <NEWLINE> continue <NEWLINE> except : <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def prepend ( elem , l ) : <NEWLINE> <INDENT> if l is None or l == <STRING> : <NEWLINE> <INDENT> tail = [ ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tail = l <NEWLINE> <DEDENT> if elem is None : <NEWLINE> return tail <NEWLINE> return [ elem ] + tail <NEWLINE> <DEDENT>
def test_original_excepthook ( self ) : <NEWLINE> <INDENT> savestderr = sys . stderr <NEWLINE> err = cStringIO . StringIO ( ) <NEWLINE> sys . stderr = err <NEWLINE> eh = sys . __excepthook__ <NEWLINE> self . assertRaises ( TypeError , eh ) <NEWLINE> try : <NEWLINE> <INDENT> raise ValueError ( 42 ) <NEWLINE> <DEDENT> except ValueError , exc : <NEWLINE> <INDENT> eh ( * sys . exc_info ( ) ) <NEWLINE> <DEDENT> sys . stderr = savestderr <NEWLINE> self . assert_ ( err . getvalue ( ) . endswith ( <STRING> ) ) <NEWLINE> <DEDENT>
def policies ( self , objectId = <STRING> , status = <STRING> ) : <NEWLINE> <INDENT> <STRING> policy <NEWLINE> return self . actions ( <STRING> , objectId , status ) <NEWLINE> <DEDENT>
def get_location_as_dict ( location ) : <NEWLINE> <INDENT> tmp_dict = location . __dict__ <NEWLINE> tmp_dict [ <STRING> ] = tmp_dict [ <STRING> ] . coords [ 0 ] <NEWLINE> tmp_dict [ <STRING> ] = tmp_dict [ <STRING> ] . coords [ 1 ] <NEWLINE> del tmp_dict [ <STRING> ] <NEWLINE> del tmp_dict [ <STRING> ] <NEWLINE> tmp_dict [ <STRING> ] = Category . objects . get ( pk = tmp_dict [ <STRING> ] ) . name <NEWLINE> del tmp_dict [ <STRING> ] <NEWLINE> if <STRING> in tmp_dict : <NEWLINE> del tmp_dict [ <STRING> ] <NEWLINE> if <STRING> in tmp_dict : <NEWLINE> tmp_dict [ <STRING> ] = tmp_dict [ <STRING> ] . m <NEWLINE> return tmp_dict <NEWLINE> <DEDENT>
def opened_w_error ( filename , mode = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> f = codecs . open ( filename , encoding = <STRING> , mode = mode ) <NEWLINE> <DEDENT> except IOError , err : <NEWLINE> <INDENT> yield None , err <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> yield f , None <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> f . close ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def to_utf8_optional_iterator ( x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if isinstance ( x , basestring ) : <NEWLINE> <INDENT> return to_utf8 ( x ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> l = list ( x ) <NEWLINE> <DEDENT> except TypeError , e : <NEWLINE> <INDENT> assert <STRING> in str ( e ) <NEWLINE> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ to_utf8_if_string ( e ) for e in l ] <NEWLINE> <DEDENT> <DEDENT>
def sample_crash_data ( n , path , folder ) : <NEWLINE> <INDENT> df = read_crash_csv ( os . path . join ( path , <STRING> ) ) <NEWLINE> logging . basicConfig ( filename = os . path . join ( path , <STRING> ) , level = logging . DEBUG ) <NEWLINE> df_new = df <NEWLINE> if n != - 1 : <NEWLINE> <INDENT> start = dt . date . today ( ) <NEWLINE> logging . info ( <STRING> % ( dt . datetime . strftime ( start , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class hotmail : <NEWLINE> <INDENT> def ataque ( self , user , password ) : <NEWLINE> <INDENT> print ( <STRING> . format ( user , password ) ) <NEWLINE> try : <NEWLINE> <INDENT> serverSMTP = smtplib . SMTP ( <STRING> ) <NEWLINE> serverSMTP . starttls ( ) <NEWLINE> serverSMTP . login ( user , password ) <NEWLINE> serverSMTP . quit ( ) <NEWLINE> table_datas = [ <NEWLINE> [ <STRING> ] , <NEWLINE> [ <STRING> . format ( user , password ) ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def getopts ( argv ) : <NEWLINE> <INDENT> opts = { } <NEWLINE> while argv : <NEWLINE> if argv [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> opts [ argv [ 0 ] ] = argv [ 1 ] <NEWLINE> argv = argv [ 2 : ] <NEWLINE> else : <NEWLINE> argv = argv [ 1 : ] <NEWLINE> <DEDENT> return opts <NEWLINE> <DEDENT>
def shape ( arr ) : <NEWLINE> <INDENT> i = ndim ( arr ) <NEWLINE> shape_val = [ 0 ] * i <NEWLINE> j = 0 <NEWLINE> while j < i : <NEWLINE> <INDENT> shape_val [ j ] = native rtl_dsize ( arr , j ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> return shape_val <NEWLINE> <DEDENT>
def get_links ( self , network = None ) : <NEWLINE> <INDENT> return [ ] <NEWLINE> <INDENT> return PGv2Link . get_links ( self . xml ) <NEWLINE> <DEDENT> <DEDENT>
def test_attribute_failed ( self ) : <NEWLINE> <INDENT> rsrc = self . create_firewall_policy ( ) <NEWLINE> self . m . ReplayAll ( ) <NEWLINE> scheduler . TaskRunner ( rsrc . create ) ( ) <NEWLINE> error = self . assertRaises ( exception . InvalidTemplateAttribute , <NEWLINE> <INDENT> rsrc . FnGetAtt , <STRING> ) <NEWLINE> <DEDENT> self . assertEqual ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> , six . text_type ( error ) <NEWLINE> <DEDENT> self . m . VerifyAll ( ) <NEWLINE> <DEDENT>
DOCUMENTATION = <STRING> <NEWLINE> EXAMPLES = <STRING> <NEWLINE> import sys <NEWLINE> import urllib2 <NEWLINE> try : <NEWLINE> <INDENT> import consul <NEWLINE> from requests . exceptions import ConnectionError <NEWLINE> python_consul_installed = True <NEWLINE> <DEDENT> except ImportError , e : <NEWLINE> <INDENT> python_consul_installed = False <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> import hcl <NEWLINE> pyhcl_installed = True <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> pyhcl_installed = False <NEWLINE> <DEDENT> from requests . exceptions import ConnectionError <NEWLINE>
def should_call_set_folder ( self , folder_info , instance , auth , node_settings ) : <NEWLINE> <INDENT> if ( folder_info and not ( <NEWLINE> <INDENT> instance and getattr ( instance , <STRING> , False ) and ( <NEWLINE> <INDENT> instance . folder_id == folder_info or ( hasattr ( folder_info , <STRING> ) and instance . folder_id == folder_info . get ( <STRING> , False ) ) <NEWLINE> <DEDENT> ) ) ) : <NEWLINE> if auth . user . _id != node_settings . user_settings . owner . _id : <NEWLINE> raise exceptions . PermissionDenied ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
def get_language_by_extension ( problem_instance , ext ) : <NEWLINE> <INDENT> for lang , extension_list in get_allowed_languages_dict ( <NEWLINE> <INDENT> problem_instance ) . items ( ) : <NEWLINE> if ext in extension_list : <NEWLINE> return lang <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from __future__ import unicode_literals <NEWLINE> from gi . repository import Gtk , Gdk , GLib <NEWLINE> from syncthing_gtk import Configuration , DaemonProcess <NEWLINE> from syncthing_gtk import DaemonOutputDialog , StDownloader <NEWLINE> from syncthing_gtk . tools import get_config_dir , IS_WINDOWS <NEWLINE> from syncthing_gtk . tools import can_upgrade_binary , compare_version <NEWLINE> import os , sys , socket , random , string <NEWLINE> import logging , traceback , platform <NEWLINE> from xml . dom import minidom <NEWLINE> _ = lambda ( a ) : a <NEWLINE> log = logging . getLogger ( <STRING> ) <NEWLINE> DEFAULT_PORT = 8080 <NEWLINE> MAX_PORT = 8100 <NEWLINE>
def default_source_layer ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for network , default_layer in [ ( <STRING> , <STRING> ) , <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) ] : <NEWLINE> if self . spec . network_unit . registered_name . endswith ( network ) : <NEWLINE> return default_layer <NEWLINE> <DEDENT> raise ValueError ( <STRING> % <NEWLINE> <INDENT> self . spec . network_unit ) <NEWLINE> <DEDENT> <DEDENT>
def find ( item_in , list_search ) : <NEWLINE> <INDENT> try : <NEWLINE> return list_search . index ( item_in ) != None <NEWLINE> except ValueError : <NEWLINE> return False <NEWLINE> <DEDENT>
def verify_default_url ( self , actual_url , expected_pixels ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . assertEqual ( <NEWLINE> <INDENT> actual_url <NEWLINE> <STRING> . format ( size = expected_pixels ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
import codecs <NEWLINE> import os <NEWLINE> import re <NEWLINE> from setuptools import setup , find_packages <NEWLINE> with codecs . open ( os . path . join ( os . path . abspath ( os . path . dirname ( <NEWLINE> <INDENT> __file__ ) ) , <STRING> , <STRING> ) , <STRING> , <STRING> ) as fp : <NEWLINE> try : <NEWLINE> version = re . findall ( <STRING> , <NEWLINE> <INDENT> fp . read ( ) , re . M ) [ 0 ] <NEWLINE> except IndexError : <NEWLINE> <DEDENT> raise RuntimeError ( <STRING> ) <NEWLINE> <DEDENT> install_requires = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> tests_require = install_requires + [ <STRING> ] <NEWLINE>
class Music : <NEWLINE> <INDENT> def play ( self ) : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> <INDENT> self . player = subprocess . Popen ( [ <STRING> , name , <STRING> , <STRING> ] , stdin = subprocess . PIPE , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <DEDENT> def stop ( self ) : <NEWLINE> <INDENT> self . player . stdin . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class HTTPSConnection ( HTTPConnection ) : <NEWLINE> <INDENT> protocol = <STRING> <NEWLINE> default_port = HTTPS_PORT <NEWLINE> def __init__ ( self , host , port = None , key_file = None , cert_file = None , <NEWLINE> <INDENT> strict = None ) : <NEWLINE> if key_file is not None or cert_file is not None : <NEWLINE> raise NotImplemented ( <NEWLINE> <INDENT> <STRING> ) <NEWLINE> super ( HTTPSConnection , self ) . __init__ ( <NEWLINE> <DEDENT> host , port = port , strict = strict ) <NEWLINE> <DEDENT> <DEDENT>
def get ( self , action ) : <NEWLINE> <INDENT> if action == <STRING> : <NEWLINE> <INDENT> self . initializeDashboard ( ) <NEWLINE> <DEDENT> elif action == <STRING> : <NEWLINE> <INDENT> self . logout ( ) <NEWLINE> <DEDENT> elif action == <STRING> : <NEWLINE> <INDENT> self . endExercise ( ) <NEWLINE> <DEDENT> elif action == <STRING> : <NEWLINE> <INDENT> self . sendStats ( ) <NEWLINE> <DEDENT> else : <NEWLINE> self . renderLoginPage ( ) <NEWLINE> <DEDENT>
def _set_win32_java_home ( self ) : <NEWLINE> <INDENT> if <STRING> in self . buildozer . environ : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> import _winreg <NEWLINE> with _winreg . OpenKey ( <NEWLINE> <INDENT> _winreg . HKEY_LOCAL_MACHINE , <NEWLINE> <STRING> ) as jdk : <NEWLINE> current_version , _type = _winreg . QueryValueEx ( <NEWLINE> jdk , <STRING> ) <NEWLINE> with _winreg . OpenKey ( jdk , <NEWLINE> <INDENT> current_version ) as cv : <NEWLINE> <DEDENT> java_home , _type = _winreg . QueryValueEx ( <NEWLINE> <INDENT> cv , <STRING> ) <NEWLINE> self . buildozer . environ [ <STRING> ] = java_home <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def set_cmd_args ( self , mesg ) : <NEWLINE> <INDENT> cmd = self . base_cmd_args ( mesg ) <NEWLINE> if mesg == <STRING> : <NEWLINE> cmd . append ( <STRING> + str ( self . sci_id ) + <STRING> + str ( self . sci_id ) + <STRING> ) <NEWLINE> elif mesg == <STRING> : <NEWLINE> <INDENT> cmd . append ( <STRING> ) <NEWLINE> elif mesg == <STRING> : <NEWLINE> cmd . append ( <STRING> ) <NEWLINE> elif mesg == <STRING> : <NEWLINE> cmd . append ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return cmd <NEWLINE> <DEDENT>
def __getitem__ ( self , index ) : <NEWLINE> <INDENT> if index < 0 : index = self . length + index <NEWLINE> let vec : float32x4 = self [ ... ] [ index // 4 ] <NEWLINE> lane = index % 4 <NEWLINE> if lane == 0 : return vec . x <NEWLINE> elif lane == 1 : return vec . y <NEWLINE> elif lane == 2 : return vec . z <NEWLINE> elif lane == 3 : return vec . w <NEWLINE> <DEDENT>
class Translate ( Collection ) : <NEWLINE> <INDENT> def __init__ ( self , parts , x , y , z ) : <NEWLINE> self . parts = parts <NEWLINE> self . where = x , y , z <NEWLINE> def apply ( self ) : <NEWLINE> glPushMatrix ( ) <NEWLINE> glTranslatef ( * self . where ) <NEWLINE> def unapply ( self ) : <NEWLINE> glPopMatrix ( ) <NEWLINE> <DEDENT>
def ck_stringz_2 ( self ) : <NEWLINE> <INDENT> return self . DFilterCount ( pkt_tftp , <NEWLINE> <INDENT> <STRING> , 0 ) <NEWLINE> <INDENT> def ck_contains_1 ( self ) : <NEWLINE> <DEDENT> <DEDENT> return self . DFilterCount ( pkt_http , <NEWLINE> <INDENT> <STRING> , 1 ) <NEWLINE> <DEDENT> <DEDENT>
from django . db import models <NEWLINE> class Reporter ( models . Model ) <NEWLINE> <INDENT> email = models . EmailField ( ) <NEWLINE> <DEDENT>
def cross_correl ( VX , VY , klag ) : <NEWLINE> <INDENT> Np = len ( VX ) <NEWLINE> if Np != len ( VY ) : <NEWLINE> <INDENT> print <STRING> , Np , len ( VY ) <NEWLINE> <DEDENT> if klag >= 0 : <NEWLINE> <INDENT> Rxyl = correl ( VX [ : Np - klag ] , VY [ klag : ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Rxyl = correl ( VX [ - klag : ] , VY [ : Np + klag ] ) <NEWLINE> <DEDENT> return Rxyl <NEWLINE> <DEDENT>
( <STRING> <NEWLINE> <DEDENT>
def external_gateway_removed ( self , ri , ext_gw_port ) : <NEWLINE> <INDENT> if self . _is_global_router ( ri ) : <NEWLINE> <INDENT> self . _remove_sub_interface ( ext_gw_port ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ex_gw_ip = ext_gw_port [ <STRING> ] [ 0 ] [ <STRING> ] <NEWLINE> if ( ex_gw_ip and <NEWLINE> <INDENT> ext_gw_port [ <STRING> ] == DEVICE_OWNER_ROUTER_GW ) : <NEWLINE> if self . _is_port_v6 ( ext_gw_port ) : <NEWLINE> self . _remove_default_route_v6 ( ri , ex_gw_ip , ext_gw_port ) <NEWLINE> else : <NEWLINE> self . _set_nat_pool ( ri , ext_gw_port , True ) <NEWLINE> self . _remove_default_route ( ri , ext_gw_port ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def _InitializePropertyToDefault ( self , prop , dst ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> c = Code ( ) <NEWLINE> underlying_type = self . _type_helper . FollowRef ( prop . type_ ) <NEWLINE> if ( underlying_type . property_type == PropertyType . ENUM and <NEWLINE> <INDENT> prop . optional ) : <NEWLINE> namespace_prefix = ( <STRING> % underlying_type . namespace . unix_name <NEWLINE> <INDENT> if underlying_type . namespace != self . _namespace <NEWLINE> else <STRING> ) <NEWLINE> c . Append ( <STRING> % ( <NEWLINE> <DEDENT> dst , <NEWLINE> prop . unix_name , <NEWLINE> namespace_prefix , <NEWLINE> self . _type_helper . GetEnumNoneValue ( prop . type_ ) ) ) <NEWLINE> <DEDENT> return c <NEWLINE> <DEDENT>
def _after_authenticate ( user , password ) : <NEWLINE> <INDENT> for ( confirmed , factory_method ) in ( ( True , _confirmed_logins ) , <NEWLINE> <INDENT> ( False , _unconfirmed_logins ) ) : <NEWLINE> logins = factory_method ( user ) <NEWLINE> db_logins = set ( <NEWLINE> [ pd . login for pd in PartialDigest . objects . filter ( user = user , <NEWLINE> <INDENT> confirmed = confirmed ) ] ) <NEWLINE> if db_logins != logins : <NEWLINE> _prepare_partial_digests ( user , password ) <NEWLINE> _persist_partial_digests ( user ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def convertTemp ( temperature , t_in = <STRING> , t_out = <STRING> ) : <NEWLINE> <INDENT> if t_in == <STRING> and t_out == <STRING> : <NEWLINE> <INDENT> return float ( 9 ) / 5 ) * temperature + 32 <NEWLINE> elif t_in == <STRING> and t_out == <STRING> : <NEWLINE> return float ( 5 ) / 9 ) * ( temperature - 32 ) <NEWLINE> else : <NEWLINE> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def _format_row ( self , ( slug , title , visits , num_unreviewed ) ) : <NEWLINE> <INDENT> needs_review = int ( num_unreviewed > 0 ) <NEWLINE> status , view_name , dummy = REVIEW_STATUSES [ needs_review ] <NEWLINE> return dict ( title = title , <NEWLINE> <INDENT> url = reverse ( <STRING> , args = [ slug ] , <NEWLINE> <INDENT> locale = self . locale ) , <NEWLINE> <DEDENT> visits = visits , <NEWLINE> status = status , <NEWLINE> status_url = reverse ( view_name , args = [ slug ] , <NEWLINE> <INDENT> locale = self . locale ) <NEWLINE> <DEDENT> if view_name else <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def put_group_psa ( self , group , psa_id , token = None ) : <NEWLINE> <INDENT> url = self . base_URL + <STRING> + group + <STRING> <NEWLINE> data = { } <NEWLINE> <INDENT> if token is not None : <NEWLINE> <INDENT> data [ <STRING> ] = token <NEWLINE> <DEDENT> <DEDENT> data [ <STRING> ] = psa_id <NEWLINE> return put ( url , data = json . dumps ( data ) , headers = self . headers ) <NEWLINE> <DEDENT>
def _chooseargmax ( self , state ) : <NEWLINE> <INDENT> self . vstate2 = state <NEWLINE> self . temp = - 10000 <NEWLINE> self . vQ <NEWLINE> self . action <NEWLINE> for a in range ( self . actions ) : <NEWLINE> <INDENT> self . vQ = self . QL [ state [ 0 ] , state [ 1 ] , a ] <NEWLINE> if self . vQ > self . temp : <NEWLINE> self . temp = self . vQ <NEWLINE> self . action = a <NEWLINE> <INDENT> return self . action <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import datetime <NEWLINE> import errno <NEWLINE> import os <NEWLINE> import sqlite3 <NEWLINE> import stat <NEWLINE> import sys <NEWLINE> import unicodedata <NEWLINE> from types import * <NEWLINE> try : <NEWLINE> <INDENT> import _find_fuse_parts <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> import fuse <NEWLINE> from fuse import Fuse <NEWLINE> if not hasattr ( fuse , <STRING> ) : <NEWLINE> <INDENT> raise RuntimeError , <STRING> <NEWLINE> <DEDENT> fuse . fuse_python_api = ( 0 , 2 ) <NEWLINE> DEFAULT_SHOTWELL_DB = os . environ [ <STRING> ] + <STRING> <NEWLINE> TAGS_ROOT = <STRING> <NEWLINE> EVENTS_ROOT = <STRING> <NEWLINE> DEFAULT_MIN_EVENT_RATING = 0 <NEWLINE>
def translate_scancode ( scancode ) : <NEWLINE> <INDENT> if autosense : <NEWLINE> scancode = check_auto ( scancode ) <NEWLINE> if scancode : <NEWLINE> <INDENT> if foundxt : return translate_xt ( scancode ) <NEWLINE> else : return translate_at ( scancode ) <NEWLINE> <DEDENT> <DEDENT>
def is_uwsgi_cfg ( filename ) : <NEWLINE> <INDENT> filename = validations . is_local_file_exists ( filename ) <NEWLINE> for k in UWSGI_DEFAULT_CONFS : <NEWLINE> if filename . endswith ( k ) : <NEWLINE> return filename <NEWLINE> for k in UWSGI_MAGIC_CONFS : <NEWLINE> if filename . endswith ( k ) : <NEWLINE> return filename <NEWLINE> return filename <NEWLINE> <DEDENT>
def test_blacklist_regex_with_comments_and_regex ( self ) : <NEWLINE> <INDENT> with io . StringIO ( ) as blacklist_file : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> blacklist_file . write ( <STRING> % i ) <NEWLINE> <DEDENT> blacklist_file . seek ( 0 ) <NEWLINE> with mock . patch ( <STRING> , <NEWLINE> <INDENT> return_value = blacklist_file ) : <NEWLINE> result = os_testr . construct_regex ( <STRING> , None , <NEWLINE> <INDENT> <STRING> , False ) <NEWLINE> expected_regex = ( <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> self . assertEqual ( result , expected_regex ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def __init__ ( self , options ) : <NEWLINE> <INDENT> self . options = options <NEWLINE> self . seed = FuzzResultFactory . from_options ( options ) <NEWLINE> self . baseline = FuzzResultFactory . from_baseline ( self . seed ) <NEWLINE> self . dictio = self . get_dictio ( ) <NEWLINE> self . stats = FuzzStats . from_requestGenerator ( self ) <NEWLINE> self . _allvar_gen = None <NEWLINE> if self . seed . history . wf_allvars is not None : <NEWLINE> self . _allvar_gen = self . __allvars_gen ( self . dictio ) <NEWLINE> <DEDENT>
def filter_rooms ( self room_ids ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> room_ids = set ( room_ids ) <NEWLINE> disallowed_rooms = set ( self . filter_json . get ( <STRING> , [ ] ) ) <NEWLINE> room_ids -= disallowed_rooms <NEWLINE> allowed_rooms = self . filter_json . get ( <STRING> , None ) <NEWLINE> if allowed_rooms is not None : <NEWLINE> <INDENT> room_ids &= set ( allowed_rooms ) <NEWLINE> <DEDENT> return room_ids <NEWLINE> <DEDENT>
def _append_root_row ( self , root_info , parent ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> info = sorted ( root_info . iteritems ( ) , <NEWLINE> <INDENT> key = lambda ( name , data ) : ( data . kind , name ) ) <NEWLINE> <DEDENT> for child_name , child_info in info : <NEWLINE> <INDENT> if child_info . kind == queue_content . KIND_DIR : <NEWLINE> <INDENT> self . _append_folder_row ( child_name , child_info , parent ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . _append_file_row ( child_name , child_info , parent ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class ConditionOr ( Automation ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , params ) : <NEWLINE> <INDENT> self . out = core . GsSldConditionOr ( params [ <STRING> ] [ <STRING> ] ( params [ <STRING> ] ) ( ) , params [ <STRING> ] [ <STRING> ] ( params [ <STRING> ] ) ( ) <NEWLINE> <DEDENT> <DEDENT>
def avg_temp ( P , varname = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for c in P . expers . values ( ) [ 0 ] . axes : <NEWLINE> <INDENT> exec c . name + <STRING> <NEWLINE> <DEDENT> for k in P . expers . keys ( ) : <NEWLINE> <INDENT> if varname in P . expers [ k ] . vars : <NEWLINE> <INDENT> mTEMP = P . expers [ k ] . vars [ varname ] / ( X * Y * Z ) <NEWLINE> P . expers [ k ] . insert ( mTEMP , name = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def set_center_abs ( self , ( x , y ) ) : <NEWLINE> <INDENT> self . rect . center = ( x , y ) <NEWLINE> x_center_percent = self . page . x_px2pc ( x ) <NEWLINE> y_center_percent = self . page . y_px2pc ( y ) <NEWLINE> self . x_percent = x_center_percent - ( self . width_percent / 2.0 ) <NEWLINE> self . y_percent = y_center_percent - ( self . height_percent / 2.0 ) <NEWLINE> <DEDENT>
def find_module ( self , fullname , path = None ) : <NEWLINE> <INDENT> path = path or self . path_entry <NEWLINE> print ( <STRING> % ( fullname , path ) ) <NEWLINE> with contextlib . closing ( shelve . open ( self . path_entry , <STRING> ) <NEWLINE> <INDENT> ) as db : <NEWLINE> key_name = _get_key_name ( fullname , db ) <NEWLINE> if key_name : <NEWLINE> print ( <STRING> % key_name ) <NEWLINE> return ShelveLoader ( path ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> return None <NEWLINE> <DEDENT>
def wrapper ( a : int , c : chan int ) : <NEWLINE> <INDENT> result = 100 <NEWLINE> c < - result <NEWLINE> <DEDENT>
def phenotype_mutants ( self ) : <NEWLINE> <INDENT> dpm = defaultdict ( set ) <NEWLINE> for mutant , phenotypes in [ ( mutant , self . mutant_phenotypes ( mutant ) ) <NEWLINE> <INDENT> for mutant in self . mutants ( ) ] : <NEWLINE> for phenotype in phenotypes : <NEWLINE> dpm [ phenotype ] . add ( mutant ) <NEWLINE> <DEDENT> return dpm <NEWLINE> <DEDENT>
def cleanup ( self ) : <NEWLINE> <INDENT> for user , tenant_id in utils . iterate_per_tenants ( <NEWLINE> <INDENT> self . context [ <STRING> ] ) : <NEWLINE> with logging . ExceptionLogger ( <NEWLINE> <INDENT> LOG , _ ( <STRING> ) % <NEWLINE> user [ <STRING> ] [ <STRING> ] ) : <NEWLINE> <DEDENT> clients = osclients . Clients ( user [ <STRING> ] ) <NEWLINE> clients . nova ( ) . security_groups . get ( <NEWLINE> <INDENT> user [ <STRING> ] [ <STRING> ] ) . delete ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def retranslateUi ( self , BandwidthDialog ) : <NEWLINE> <INDENT> BandwidthDialog . setWindowTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . button1 . setText ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
class MathTestCase ( unittest . TestCase ) : <NEWLINE> <INDENT> def testInt2b128 ( self ) : <NEWLINE> <INDENT> funkylist = range ( 0 , 100 ) + range ( 1000 , 1100 ) + range ( 1000000 , 1000100 ) + [ 1024 ** 10 l ] <NEWLINE> for i in funkylist : <NEWLINE> <INDENT> x = StringIO . StringIO ( ) <NEWLINE> banana . int2b128 ( i , x . write ) <NEWLINE> v = x . getvalue ( ) <NEWLINE> y = banana . b1282int ( v ) <NEWLINE> assert y == i , <STRING> % ( y , i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def _check_args ( self , target , * args ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not isinstance ( target , Target ) : <NEWLINE> <INDENT> raise TypeError ( <STRING> . format ( target ) ) <NEWLINE> <DEDENT> if target in ( Target . userscript , Target . spawn , Target . run , <NEWLINE> <INDENT> Target . fill ) : <NEWLINE> if not args : <NEWLINE> raise cmdexc . CommandError ( <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if args : <NEWLINE> <INDENT> raise cmdexc . CommandError ( <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def load_hpo ( ) : <NEWLINE> <INDENT> if not mongo [ <STRING> ] . find_one ( ) : <NEWLINE> <INDENT> hpo_file = open ( <STRING> . join ( [ settings . RESOURCES_PATH , <STRING> ] ) ) <NEWLINE> <INDENT> hpo = json . loads ( hpo_file . read ( ) ) <NEWLINE> payload = [ ] <NEWLINE> for key , val in hpo . iteritems ( ) : <NEWLINE> <INDENT> payload . append ( { <STRING> : key , <STRING> : val } ) <NEWLINE> <DEDENT> mongo [ <STRING> ] . insert ( payload ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def __getstate__ ( self ) -> Dict [ str , Any ] : <NEWLINE> <INDENT> state = thor . events . EventEmitter . __getstate__ ( self ) <NEWLINE> for key in [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ] : <NEWLINE> if key in state : <NEWLINE> del state [ key ] <NEWLINE> <DEDENT> return state <NEWLINE> <DEDENT>
def handle_premium ( self , pyfile ) : <NEWLINE> <INDENT> self . html = json_loads ( self . load ( <STRING> , <NEWLINE> <INDENT> get = { <STRING> : self . account . get_data ( <STRING> ) , <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : pyfile . url } ) <NEWLINE> <DEDENT> <DEDENT> data = self . html ) <NEWLINE> self . log_debug ( <STRING> , data ) <NEWLINE> if <STRING> in self . html : <NEWLINE> <INDENT> self . offline ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . link = data [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT>
class WSSimpleEcho ( HTTPWebSocketsHandler ) : <NEWLINE> <INDENT> def on_ws_message ( self , message ) : <NEWLINE> <INDENT> if message is None : <NEWLINE> <INDENT> message = <STRING> <NEWLINE> <DEDENT> self . send_message ( message ) <NEWLINE> self . log_message ( <STRING> % s <STRING> , str ( message ) ) <NEWLINE> <DEDENT> def on_ws_connected ( self ) : <NEWLINE> <INDENT> self . log_message ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> def on_ws_closed ( self ) : <NEWLINE> <INDENT> self . log_message ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def test_onethousand_scenarios ( self ) : <NEWLINE> <INDENT> _args = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> <NEWLINE> ] <NEWLINE> <DEDENT> options = getOptions ( _args ) <NEWLINE> steerStats = SteerStats ( options ) <NEWLINE> results = steerStats . RunStats ( ) <NEWLINE> self . assertEqual ( 1000 , len ( results ) <NEWLINE> <DEDENT>
def remove_devices ( self , dev_list ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for d in dev_list : <NEWLINE> <INDENT> if d . name_has_listener ( self . setup_devices ) : <NEWLINE> d . remove_name_listener ( self . setup_devices ) <NEWLINE> if self . _parent . _can_have_nested_devices and d . can_have_chains : <NEWLINE> if d . chains_has_listener ( self . setup_devices ) : <NEWLINE> <INDENT> d . remove_chains_listener ( self . setup_devices ) <NEWLINE> for c in d . chains : <NEWLINE> if c . devices_has_listener ( self . setup_devices ) : <NEWLINE> <DEDENT> c . remove_devices_listener ( self . setup_devices ) <NEWLINE> <INDENT> self . remove_devices ( c . devices ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def nltk_stemming ( vectorizer_type ) : <NEWLINE> <INDENT> english_stemmer = nltk . stem . SnowballStemmer ( <STRING> ) <NEWLINE> class StemmedVectorizer ( vectorizer_type ) : <NEWLINE> <INDENT> def build_analyzer ( self ) : <NEWLINE> <INDENT> analyser = super ( StemmedVectorizer , self ) . build_analyzer ( ) <NEWLINE> return lambda doc : ( english_stemmer . stem ( w ) for w in analyser ( doc ) <NEWLINE> <DEDENT> <DEDENT> return StemmedVectorizer <NEWLINE> <DEDENT>
def __init__ ( self , input_iter ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . input_iter = input_iter <NEWLINE> self . offset = 0 l <NEWLINE> self . process_waiting = False <NEWLINE> self . process_next_vol_number = None <NEWLINE> self . previous_index = None <NEWLINE> self . previous_block = None <NEWLINE> self . remember_next = False <NEWLINE> self . remember_value = None <NEWLINE> self . remember_block = None <NEWLINE> self . queued_data = None <NEWLINE> <DEDENT>
def __setitem__ ( self , ( channel , id ) , v ) : <NEWLINE> <INDENT> if channel not in self . channels : <NEWLINE> <INDENT> self . channels [ channel ] = self . IdDict ( ) <NEWLINE> <DEDENT> self . channels [ channel ] [ id ] = v <NEWLINE> <DEDENT>
def repair_software_only ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . repair_filesystem_only ( ) <NEWLINE> break <NEWLINE> <DEDENT> except ( error . AutoservSshPingHostError , error . AutoservSSHTimeout , <NEWLINE> <INDENT> error . AutoservSshPermissionDeniedError , <NEWLINE> error . AutoservDiskFullHostError ) , err : <NEWLINE> logging . exception ( <STRING> ) <NEWLINE> logging . info ( <STRING> ) <NEWLINE> self . _call_repair_func ( err , self . machine_install ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class AuthnQueryResponse ( AuthnResponse ) : <NEWLINE> <INDENT> msgtype = <STRING> <NEWLINE> def __init__ ( self , sec_context , attribute_converters , entity_id , <NEWLINE> <INDENT> return_addrs = None , timeslack = 0 , asynchop = False , test = False ) : <NEWLINE> AuthnResponse . __init__ ( self , sec_context , attribute_converters , <NEWLINE> <INDENT> entity_id , return_addrs , timeslack = timeslack , <NEWLINE> asynchop = asynchop , test = test ) <NEWLINE> self . entity_id = entity_id <NEWLINE> self . attribute_converters = attribute_converters <NEWLINE> self . assertion = None <NEWLINE> self . context = <STRING> <NEWLINE> <DEDENT> <DEDENT> def condition_ok ( self , lax = False ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT>
def _caesar ( self , plaintext , shift ) : <NEWLINE> <INDENT> lower = string . ascii_lowercase <NEWLINE> lower_trans = lower [ shift : ] + lower [ : shift ] <NEWLINE> alphabet = lower + lower . upper ( ) <NEWLINE> shifted = lower_trans + lower_trans . upper ( ) <NEWLINE> return plaintext . translate ( string . maketrans ( alphabet , shifted ) <NEWLINE> <DEDENT>
def test_active ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . F . ApiKeyFactory . create ( active = False ) <NEWLINE> k = self . F . ApiKeyFactory . create ( active = True ) <NEWLINE> self . assertEqual ( list ( self . model . ApiKey . objects . active ( ) , [ k ] ) <NEWLINE> <DEDENT>
def get_initial_image ( self , node , top ) : <NEWLINE> <INDENT> for e in top . elements : <NEWLINE> <INDENT> if isinstance ( e , topdl . Computer ) : <NEWLINE> if node == e . name : <NEWLINE> <INDENT> if e . os and len ( e . os ) == 1 : <NEWLINE> <DEDENT> return e . os [ 0 ] . get_attribute ( <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return None <NEWLINE> <DEDENT>
def print_spanning ( G ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> . format ( G . size ( weight = <STRING> ) ) ) <NEWLINE> T = nx . minimum_spanning_tree ( G ) <NEWLINE> print ( <STRING> . format ( T . size ( weight = <STRING> ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> for i in sorted ( T . edges ( data = True ) ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
def get_documents_for_today ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> docs = [ ] <NEWLINE> diff_days = self . days_in_advance <NEWLINE> if self . event == <STRING> : <NEWLINE> <INDENT> diff_days = - diff_days <NEWLINE> <DEDENT> for name in frappe . db . sql_list ( <STRING> . format ( self . document_type , <NEWLINE> <INDENT> self . date_changed ) , ( nowdate ( ) , diff_days or 0 ) ) : <NEWLINE> doc = frappe . get_doc ( self . document_type , name ) <NEWLINE> if self . condition and not eval ( self . condition , get_context ( doc ) ) : <NEWLINE> continue <NEWLINE> docs . append ( doc ) <NEWLINE> <DEDENT> return docs <NEWLINE> <DEDENT>
def retranslateUi ( self , SyntaxCheckerDialog ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> SyntaxCheckerDialog . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> SyntaxCheckerDialog . setWhatsThis ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
class Stormwaterdrainsetup : <NEWLINE> <INDENT> def __init__ ( self , numberofStormwaterpipes , starting_value_i , ** Stormwaterpipeattributes ) : <NEWLINE> <INDENT> self . numberofStormwaterpipes = numberofStormwaterpipes <NEWLINE> self . Stormwaterpipeattributelist = [ ] <NEWLINE> self . Stormwaterpipenodelist = [ ] <NEWLINE> for i in range ( numberofStormwaterpipes + starting_value_i ) [ starting_value_i : ] : <NEWLINE> <INDENT> exec <STRING> + str ( i ) + <STRING> <NEWLINE> exec <STRING> <NEWLINE> alllines = <STRING> <NEWLINE> for n in range ( 1 ) : <NEWLINE> <INDENT> exec <STRING> + str ( n + 1 ) <NEWLINE> <DEDENT> self . Stormwaterpipenodelist . append ( alllines ) <NEWLINE> <DEDENT> print ( str ( numberofStormwaterpipes ) + <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT>
def process ( self , timeout = None ) : <NEWLINE> <INDENT> if DEBUG : <NEWLINE> <INDENT> print <STRING> , self . _callback_map . keys ( ) <NEWLINE> <DEDENT> if DEBUG : <NEWLINE> <INDENT> print <STRING> , self . _callback_write_map . keys ( ) <NEWLINE> <DEDENT> pass <NEWLINE> <DEDENT>
def testNegativeLong ( self ) : <NEWLINE> <INDENT> self . enc . sendEncoded ( - 1015 l ) <NEWLINE> self . enc . dataReceived ( self . io . getvalue ( ) ) <NEWLINE> assert self . result == - 1015 l , <STRING> % self . result <NEWLINE> <DEDENT>
def getReward ( state , minAltitude , scale ) : <NEWLINE> <INDENT> if ( state [ 0 ] [ 2 ] ) < minAltitude : <NEWLINE> <INDENT> return - 1. <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> return 1. / np . sqrt ( np . sum ( np . square ( state [ 0 ] [ 0 : 2 ] / scale ) ) ) <NEWLINE> <DEDENT> <DEDENT>
class TestDataPlugin ( unittest . TestCase ) : <NEWLINE> <INDENT> def test_run ( self ) : <NEWLINE> <INDENT> vodka . data . data_types . instantiate_from_config ( <NEWLINE> [ { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : [ <NEWLINE> <INDENT> { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : 10 <NEWLINE> <DEDENT> } <NEWLINE> ] <NEWLINE> <DEDENT> <DEDENT> } ] <NEWLINE> <DEDENT> <DEDENT>
def __main__ ( ) : <NEWLINE> <INDENT> options , args = doc_optparse . parse ( __doc__ ) <NEWLINE> try : <NEWLINE> <INDENT> refindex = int ( args [ 0 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> doc_optparse . exit ( ) <NEWLINE> <DEDENT> maf_reader = maf . Reader ( sys . stdin ) <NEWLINE> for m in maf_reader : <NEWLINE> c = m . components [ refindex ] . src <NEWLINE> print ( c [ c . rfind ( <STRING> ) + 3 : ] ) <NEWLINE> <DEDENT>
def run_command ( cmd ) : <NEWLINE> <INDENT> print ( <STRING> + cmd ) <NEWLINE> pipe = subprocess . Popen ( cmd , shell = True , stderr = subprocess . PIPE ) <NEWLINE> <INDENT> pipe . wait ( ) <NEWLINE> <DEDENT> ret = pipe . returncode <NEWLINE> if ret : <NEWLINE> <INDENT> print ( <STRING> + str ( ret ) ) <NEWLINE> <INDENT> print ( pipe . stderr . readlines ( ) ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> <DEDENT>
def test_streaming_fetchall ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> count = 100 <NEWLINE> do_write ( count ) <NEWLINE> master_conn = get_master_connection ( ) <NEWLINE> stream_cursor = cursor . StreamCursor ( master_conn ) <NEWLINE> stream_cursor . execute ( <STRING> , { } ) <NEWLINE> rows = stream_cursor . fetchall ( ) <NEWLINE> rowcount = 0 <NEWLINE> for r in rows : <NEWLINE> <INDENT> rowcount += 1 <NEWLINE> <DEDENT> self . assertEqual ( rowcount , count ) <NEWLINE> stream_cursor . close ( ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> self . fail ( <STRING> % ( str ( e ) , traceback . print_exc ( ) ) ) <NEWLINE> <DEDENT> <DEDENT>
def reduce_time_left ( self , time_left ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with self . _lock : <NEWLINE> <INDENT> if time_left >= 0 and ( self . _time_left < 0 <NEWLINE> <INDENT> or self . _time_left > time_left ) : <NEWLINE> self . _time_left = time_left <NEWLINE> if self . _time_left == 0 and self . handler is not None : <NEWLINE> m = getattr ( <NEWLINE> getattr ( <NEWLINE> self . handler , <STRING> , getattr ( <NEWLINE> self . handler , <STRING> <NEWLINE> ) <NEWLINE> ) , <NEWLINE> <STRING> , None <NEWLINE> ) <NEWLINE> if m is not None and ismethod ( m ) : <NEWLINE> m ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def __setstate__ ( self , ( children , doctype , root ) ) : <NEWLINE> <INDENT> FtNode . __setstate__ ( self , children ) <NEWLINE> self . __dict__ [ <STRING> ] = doctype <NEWLINE> self . __dict__ [ <STRING> ] = root <NEWLINE> return <NEWLINE> <DEDENT>
def request ( url , method = <STRING> , data = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> self = TargetProcess ( ) <NEWLINE> if not self . _api_key or self . _username : <NEWLINE> <INDENT> raise TypeError ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def OnAddQuit ( self , event ) : <NEWLINE> <INDENT> while not self . Add ( event ) : <NEWLINE> True <NEWLINE> self . OnCancel ( event ) <NEWLINE> <DEDENT>
def extractTextFromTxt ( f ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> from tempfile import NamedTemporaryFile <NEWLINE> destination = NamedTemporaryFile ( ) <NEWLINE> destination . write ( f . read ( ) ) <NEWLINE> import codecs <NEWLINE> str = codecs . open ( destination . name , <STRING> , <STRING> , <STRING> ) <NEWLINE> return str . read ( ) <NEWLINE> <DEDENT> <DEDENT>
def _modules_to_main ( modList ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not modList : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> main = sys . modules [ <STRING> ] <NEWLINE> for modname in modList : <NEWLINE> <INDENT> if type ( modname ) is str : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> mod = __import__ ( modname ) <NEWLINE> <DEDENT> except Exception , i : <NEWLINE> <INDENT> sys . stderr . write ( <STRING> % modname ) <NEWLINE> print_exec ( sys . stderr ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> setattr ( main , mod . __name__ , mod ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> setattr ( main , modname . __name__ , modname ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def _loadmodule ( module ) : <NEWLINE> <INDENT> if module not in sys . modules : <NEWLINE> <INDENT> modules = module . split ( <STRING> ) <NEWLINE> s = <STRING> <NEWLINE> for i in range ( len ( modules ) ) : <NEWLINE> <INDENT> s = <STRING> . join ( modules [ : i + 1 ] ) <NEWLINE> exec <STRING> + s <NEWLINE> <DEDENT> <DEDENT> return sys . modules [ module ] <NEWLINE> <DEDENT>
( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>
def __init__ ( self , debug = False , dataSxtr = None , logger = None ) : <NEWLINE> <INDENT> super ( Ds9DisplayThread , self ) . __init__ ( ) <NEWLINE> self . debug = debug <NEWLINE> self . dataSxtr = dataSxtr <NEWLINE> self . logger = logger <NEWLINE> self . stoprequest = threading . Event ( ) <NEWLINE> self . display = None <NEWLINE> try : <NEWLINE> <INDENT> self . display = ds9 ( ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> self . logger . warn ( <STRING> . format ( e ) ) <NEWLINE> <DEDENT> <DEDENT>
class AddAmbienceConfirmationDialog ( QDialog ) : <NEWLINE> <INDENT> def __init__ ( self , filenames , filepaths , cutnames ) : <NEWLINE> <INDENT> QDialog . __init__ ( self ) <NEWLINE> self . filenames = filenames <NEWLINE> self . filepaths = filepaths <NEWLINE> self . cutnames = cutnames <NEWLINE> self . resize ( 593 , 398 ) <NEWLINE> self . setStyleSheet ( _fromUtf8 ( <STRING> ) ) <NEWLINE> self . filesListView = QtGui . QListWidget ( self ) <NEWLINE> self . filesListView . setGeometry ( QtCore . QRect ( 20 , 70 , 261 , 261 ) ) <NEWLINE> self . filesListView . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
def test_positive_create_with_lastname ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for lastname in generate_strings_list ( <NEWLINE> <INDENT> exclude_types = [ <STRING> ] , max_length = 50 ) : <NEWLINE> with self . subTest ( lastname ) : <NEWLINE> user = entities . User ( lastname = lastname ) . create ( ) <NEWLINE> self . assertEqual ( user . lastname , lastname ) <NEWLINE> <DEDENT> <DEDENT>
def is_batch_topic_distribution_created ( path ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> batch_topic_distribution_id = None <NEWLINE> try : <NEWLINE> <INDENT> with open ( <STRING> <NEWLINE> <INDENT> % ( path , os . sep ) ) as batch_prediction_file : <NEWLINE> batch_topic_distribution_id = batch_prediction_file . readline ( ) . strip ( ) <NEWLINE> try : <NEWLINE> batch_topic_distribution_id = bigml . api . get_batch_topic_distribution_id ( batch_topic_distribution_id ) <NEWLINE> return True , batch_topic_distribution_id <NEWLINE> except ValueError : <NEWLINE> return False , None <NEWLINE> <DEDENT> <DEDENT> except IOError : <NEWLINE> <INDENT> return False , None <NEWLINE> <DEDENT> <DEDENT>
def test_abort ( self req ) : <NEWLINE> <INDENT> reply = networkreply . FixedDataNetworkReply ( req , <STRING> , <STRING> ) <NEWLINE> reply . abort ( ) <NEWLINE> assert reply . readAll ( ) == <STRING> <NEWLINE> <DEDENT>
<DEDENT> else if chunk and re . search ( <STRING> , chunk ) != = None ) : <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = SHORT + <STRING> <NEWLINE> defsoutput = TOOLBOXDIR + LONG + <STRING> <NEWLINE> scanner = MyScanner ( input , output , defsoutput ) <NEWLINE> scanner . scan ( ) <NEWLINE> scanner . close ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> execfile ( defsoutput , { } , { } ) <NEWLINE> print ( <STRING> ) <NEWLINE> exec <STRING> + SHORT + <STRING> <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
def show_section_vehicle_type_template ( self , pif , sect ) : <NEWLINE> <INDENT> flago = mflags . FlagList ( ) <NEWLINE> sect [ <STRING> ] = [ self . get_vt_model_table ( pif , self . mdict [ mod ] , flago ) for mod in sect [ <STRING> ] ] <NEWLINE> <INDENT> return sect <NEWLINE> <DEDENT> <DEDENT>
def _iteritems ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for name in self . _obj . obj_fields : <NEWLINE> <INDENT> if ( self . _obj . obj_attr_is_set ( name ) or <NEWLINE> <INDENT> name in self . _obj . obj_extra_fields ) : <NEWLINE> if name == <STRING> : <NEWLINE> yield name , self . id <NEWLINE> elif name == <STRING> : <NEWLINE> yield name , self . host <NEWLINE> else : <NEWLINE> yield name , getattr ( self . _obj , name ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def define_tables ( cls metadata ) : <NEWLINE> <INDENT> cls . define_reflected_tables ( metadata , None ) <NEWLINE> if testing . requires . schemas . enabled : <NEWLINE> <INDENT> cls . define_reflected_tables ( metadata , testing . config . test_schema ) <NEWLINE> <DEDENT> <DEDENT>
def send_data ( A : chan Sender < int > , B : chan Sender < int > , X : int , Y : int ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> A < - X <NEWLINE> B < - Y <NEWLINE> <DEDENT> <DEDENT>
def server_names_and_ips_loop ( server_variable ) : <NEWLINE> <INDENT> serverList = [ ] <NEWLINE> while server_variable > 0 : <NEWLINE> serverName = raw_input ( <STRING> ) <NEWLINE> serverIP = raw_input ( <STRING> ) <NEWLINE> serverName = str ( serverName ) <NEWLINE> serverIP = str ( serverIP ) <NEWLINE> serverList . append ( serverName ) <NEWLINE> serverList . append ( serverIP ) <NEWLINE> server_variable -= 1 <NEWLINE> return serverList <NEWLINE> <DEDENT>
def usage ( status ) <NEWLINE> <INDENT> print ( __doc__ % globals ( ) ) <NEWLINE> sys . exit ( status ) <NEWLINE> <DEDENT>
class ZulipDummyBackend ( ZulipAuthMixin ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def authenticate ( self , username = None , realm_subdomain = None , use_dummy_backend = False , <NEWLINE> <INDENT> return_data = None ) : <NEWLINE> if use_dummy_backend : <NEWLINE> user_profile = common_get_active_user_by_email ( username ) <NEWLINE> if user_profile is None : <NEWLINE> return None <NEWLINE> if not check_subdomain ( realm_subdomain , user_profile . realm . subdomain ) : <NEWLINE> return_data [ <STRING> ] = True <NEWLINE> return None <NEWLINE> return user_profile <NEWLINE> return None <NEWLINE> <DEDENT> <DEDENT>
def cb_init_hook ( option , optname , value , parser ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> exec value <NEWLINE> <DEDENT>
def flush ( self ) : <NEWLINE> <INDENT> data = <STRING> . join ( self . buff ) <NEWLINE> del self . buff [ : ] <NEWLINE> self . buff_len = 0 <NEWLINE> if debug_write : <NEWLINE> <INDENT> print <STRING> % ( repr ( data ) , ) <NEWLINE> <DEDENT> while data : <NEWLINE> <INDENT> self . _wait ( ) <NEWLINE> data = data [ self . _write ( data ) : ] <NEWLINE> <DEDENT> <DEDENT>
def reg ( self , identity , password ) : <NEWLINE> <INDENT> salt = os . urandom ( 64 ) <NEWLINE> x = bin_str_to_big_int ( sha256 ( salt , password ) <NEWLINE> verifier = mod_exp ( self . config . g , x , self . config . N ) <NEWLINE> self . server . reg ( identity , salt , verifier ) <NEWLINE> <DEDENT>
def getDataPath ( ) : <NEWLINE> <INDENT> import os <NEWLINE> data_path = None <NEWLINE> for testpath in [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ] : <NEWLINE> if os . path . exists ( testpath ) and os . path . isdir ( testpath ) : <NEWLINE> data_path = testpath <NEWLINE> break <NEWLINE> <DEDENT> return data_path <NEWLINE> <DEDENT>
( <STRING> A = 2 <NEWLINE> <DEDENT> with path_modifier ( <STRING> ) as p : <NEWLINE> <INDENT> with stdout_trapper ( ) as output : <NEWLINE> <INDENT> new_module = clr . Use ( test_name . split ( <STRING> ) [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> self . assertEqual ( output . messages , [ ] ) <NEWLINE> self . assertEqual ( new_module . A , 1 ) <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> os . remove ( test_name ) <NEWLINE> <DEDENT> except : pass <NEWLINE> <DEDENT> <DEDENT>
def update_docs_pull ( record = False , force = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for version in Version . objects . filter ( built = True ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> update_docs ( <NEWLINE> <INDENT> pk = version . project . pk , version_pk = version . pk , record = record ) <NEWLINE> <DEDENT> <DEDENT> except Exception , e : <NEWLINE> <INDENT> log . error ( <STRING> , exc_info = True ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
using System ; <NEWLINE> using System . Collections . Generic ; <NEWLINE> using System . Linq ; <NEWLINE> using System . Text ; <NEWLINE> namespace Feed <NEWLINE> { <NEWLINE> <INDENT> public class CurrentData <NEWLINE> { <NEWLINE> <INDENT> public Info Info = new Info ( ) ; <NEWLINE> public List < Item > Items = new List < Item > ( ) ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE>
class MenuCascade ( MenuEntry ) : <NEWLINE> <INDENT> def __init__ ( self , text , entries , ** kw ) : <NEWLINE> self . entries = entries <NEWLINE> self . label = text <NEWLINE> self . submenu = None <NEWLINE> self . kwargs = kw <NEWLINE> def AddToMenu ( self , menu ) : <NEWLINE> if menu : <NEWLINE> <INDENT> self . submenu = apply ( UpdatedMenu , ( menu , self . entries ) , self . kwargs ) <NEWLINE> menu . add ( <STRING> , label = self . label , menu = self . submenu . menu ) <NEWLINE> self . menu = menu <NEWLINE> <DEDENT> <DEDENT>
def resnet_v2_block ( scope , base_depth , num_units , stride ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return resnet_utils . Block ( scope , bottleneck , [ { <NEWLINE> <INDENT> <STRING> : base_depth * 4 , <NEWLINE> <STRING> : base_depth , <NEWLINE> <STRING> : 1 <NEWLINE> <DEDENT> } ] * ( num_units - 1 ) + [ { <NEWLINE> <INDENT> <STRING> : base_depth * 4 , <NEWLINE> <STRING> : base_depth <NEWLINE> <STRING> : stride <NEWLINE> <DEDENT> } ] ) <NEWLINE> <DEDENT>
def launch_about_dialog ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> view = AboutView ( qtutils . active_window ( ) ) <NEWLINE> view . set_version ( version . version ( ) <NEWLINE> view . show ( ) <NEWLINE> <DEDENT>
def _dcommit_calls_bypassed ( cls ) : <NEWLINE> <INDENT> return [ <NEWLINE> <INDENT> ( ( [ <STRING> , <STRING> , <STRING> ] , ) , <STRING> ) , <NEWLINE> ( ( [ <STRING> , <STRING> , <STRING> ] , ) , <NEWLINE> <INDENT> <STRING> ) , <NEWLINE> <DEDENT> ( ( <STRING> , <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_page_creation_rev_doc ( ) : <NEWLINE> <INDENT> extractor = Extractor ( mwapi . Session ( <STRING> ) ) <NEWLINE> page_creation_rev_doc = PageCreationRevDoc ( ro . revision . page , extractor ) <NEWLINE> hash ( page_creation_rev_doc ) <NEWLINE> eq_ ( pickle . loads ( pickle . dumps ( page_creation_rev_doc ) , <NEWLINE> <INDENT> page_creation_rev_doc ) <NEWLINE> <DEDENT> <DEDENT>
class Anca : <NEWLINE> <INDENT> event died ( when ) <NEWLINE> def kill ( self , time ) : <NEWLINE> <INDENT> return self . died ( time ) <NEWLINE> <DEDENT> <DEDENT>
def create ( self , block_code , block_level = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> return_var = None <NEWLINE> <DEDENT> logger . info ( <STRING> + str ( block_code ) + <STRING> + str ( block_level ) + <STRING> ) <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return_var = self . get_by_block_code ( block_code = block_code ) <NEWLINE> <DEDENT> except QuestionBlock . DoesNotExist : <NEWLINE> <INDENT> if block_code and block_level : <NEWLINE> <INDENT> QuestionBlock_obj = QuestionBlock ( ) <NEWLINE> QuestionBlock_obj . block_code = block_code <NEWLINE> QuestionBlock_obj . block_level = block_level <NEWLINE> QuestionBlock_obj . save ( ) <NEWLINE> return_var = QuestionBlock_obj <NEWLINE> <DEDENT> <DEDENT> return return_var <NEWLINE> <DEDENT> <DEDENT>
def test_update_endpoint_enabled_str_random ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . patch ( <NEWLINE> <INDENT> <STRING> % { <NEWLINE> <INDENT> <STRING> : self . endpoint_id } , <NEWLINE> <DEDENT> body = { <STRING> : { <STRING> : <STRING> } , <NEWLINE> expected_status = http_client . BAD_REQUEST ) <NEWLINE> <DEDENT> <DEDENT>
from . command import RbxComponentSetCommandAction <NEWLINE> from . volume import RbxComponentSetVolumeAction <NEWLINE> from . image import RbxComponentSetImageAction <NEWLINE> from . port import RbxComponentSetPortAction <NEWLINE> class RbxComponentSetAction ( RbxComponentSetPortAction , <NEWLINE> <INDENT> RbxComponentSetVolumeAction , <NEWLINE> RbxComponentSetCommandAction , <NEWLINE> RbxComponentSetImageAction ) : <NEWLINE> def do_action_set ( self ) : <NEWLINE> getattr ( self , <STRING> . format ( self . params . configurator ) ) ( ) <NEWLINE> <DEDENT>
def strip_bom ( data ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for bom in ( codecs . BOM_UTF32_BE , <NEWLINE> <INDENT> codecs . BOM_UTF32_LE , <NEWLINE> codecs . BOM_UTF16_BE , <NEWLINE> codecs . BOM_UTF16_LE , <NEWLINE> codecs . BOM_UTF8 ) : <NEWLINE> if data . startswith ( bom ) : <NEWLINE> data = data [ len ( bom ) : ] <NEWLINE> break <NEWLINE> <DEDENT> return data <NEWLINE> <DEDENT>
def create_voucher ( self , ** kw ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> cl = self . get_doc_model ( ) <NEWLINE> kw . update ( journal = self ) <NEWLINE> try : <NEWLINE> <INDENT> doc = cl ( ) <NEWLINE> for k , v in kw . items ( ) : <NEWLINE> <INDENT> setattr ( doc , k , v ) <NEWLINE> <DEDENT> <DEDENT> except TypeError , e : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> doc . on_create ( None ) <NEWLINE> return doc <NEWLINE> <DEDENT>
def open ( self , pathobj ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> url = str ( pathobj ) <NEWLINE> raw , code = self . rest_get_stream ( url , auth = pathobj . auth , verify = pathobj . verify <NEWLINE> <INDENT> cert = pathobj . cert ) <NEWLINE> <DEDENT> if not code == 200 : <NEWLINE> <INDENT> raise RuntimeError ( <STRING> % code ) <NEWLINE> <DEDENT> return raw <NEWLINE> <DEDENT>
def retranslateUi ( self , MainWindow ) : <NEWLINE> <INDENT> MainWindow . setWindowTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . widgetFrameOuter . setProperty ( <STRING> , _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . resistanceInductor . setToolTip ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def IsActiveOn ( self , date , date_object = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if date in self . date_exceptions : <NEWLINE> <INDENT> exception_type , _ = self . date_exceptions [ date ] <NEWLINE> if exception_type == self . _EXCEPTION_TYPE_ADD : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> if ( self . start_date and self . end_date and self . start_date <= date and <NEWLINE> <INDENT> date <= self . end_date ) : <NEWLINE> if date_object is None : <NEWLINE> date_object = util . DateStringToDateObject ( date ) <NEWLINE> return self . day_of_week [ date_object . weekday ( ) ] <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
def dash_sidebar_modules ( request ) : <NEWLINE> <INDENT> signals_call = signals . dash_modules_detect ( ) <NEWLINE> if signals_call : <NEWLINE> <INDENT> if signals_call [ 0 ] [ 1 ] [ <STRING> ] == <STRING> : <NEWLINE> <INDENT> return { <STRING> : [ module [ 1 ] for module in signals_call ] <NEWLINE> <INDENT> <STRING> : request } <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return { } <NEWLINE> <DEDENT> <DEDENT>
def testFormatPretty ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( oauth2l , <STRING> , <NEWLINE> <INDENT> return_value = self . credentials , <NEWLINE> autospec = True ) as mock_credentials : <NEWLINE> output = _GetCommandOutput ( <STRING> , self . _Args ( <STRING> ) ) <NEWLINE> expecteds = [ <STRING> , <NEWLINE> self . access_token ] <NEWLINE> for expected in expecteds : <NEWLINE> self . assertIn ( expected , output ) <NEWLINE> self . assertEqual ( 1 , mock_credentials . call_count ) <NEWLINE> <DEDENT> <DEDENT>
def onPaint ( self , evt ) : <NEWLINE> <INDENT> dc = self . __getClientDC ( ) <NEWLINE> <INDENT> self . doPaint ( dc ) <NEWLINE> evt . Skip ( ) <NEWLINE> <DEDENT> <DEDENT>
from django . conf . urls import patterns , include , url <NEWLINE> from django . contrib import admin <NEWLINE> admin . autodiscover ( ) <NEWLINE> urlpatterns = patterns ( <STRING> , <NEWLINE> <INDENT> url ( <STRING> , include ( admin . site . urls ) , <NEWLINE> <DEDENT> ) <NEWLINE>
def ucsdJsonParser ( text ) : <NEWLINE> <INDENT> jsondict = None <NEWLINE> if text : <NEWLINE> <INDENT> try : <NEWLINE> jsondict = json . loads ( text ) <NEWLINE> except : pass <NEWLINE> try : <NEWLINE> jsondict = yaml . loads ( text ) <NEWLINE> except : pass <NEWLINE> try : <NEWLINE> jsondict = demjson . decode ( text ) <NEWLINE> except : pass <NEWLINE> <DEDENT> return jsondict <NEWLINE> <DEDENT>
def hostname_contains ( pattern ) : <NEWLINE> <INDENT> hostname = socket . gethostbyaddr ( socket . gethostname ( ) [ 0 ] <NEWLINE> if re . search ( pattern , hostname ) == None : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT>
[ <NEWLINE> for cmd in commands : <NEWLINE> <INDENT> print ( cmd ) <NEWLINE> ret = os . system ( cmd ) <NEWLINE> if ret != 0 : <NEWLINE> <INDENT> print ( <STRING> + cmd ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def getProcess ( ) : <NEWLINE> <INDENT> fullsc = ImageGrab . grab ( ) <NEWLINE> saveProcess = fullsc . crop ( Pcbox ) . save ( wokingp + <STRING> , <STRING> ) <NEWLINE> picPc = open ( wokingp + <STRING> , <STRING> ) <NEWLINE> Pmd5 = hashlib . md5 ( picPc . read ( ) ) . hexdigest ( ) . upper ( ) <NEWLINE> picPc . close ( ) <NEWLINE> if Pmd5 != Pcmd5 : <NEWLINE> click ( 655 , 770 ) <NEWLINE> cNp ( ) <NEWLINE> <DEDENT>
class ChromeHistoryFileDownloadedEvent ( time_events . TimestampEvent ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> DATA_TYPE = <STRING> <NEWLINE> def __init__ ( <NEWLINE> <INDENT> self , timestamp , row_id , url , full_path , received_bytes , total_bytes ) : <NEWLINE> <STRING> <NEWLINE> super ( ChromeHistoryFileDownloadedEvent , self ) . __init__ ( <NEWLINE> <INDENT> timestamp , eventdata . EventTimestamp . FILE_DOWNLOADED ) <NEWLINE> self . offset = row_id <NEWLINE> self . url = url <NEWLINE> self . full_path = full_path <NEWLINE> self . received_bytes = received_bytes <NEWLINE> self . total_bytes = total_bytes <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get ( self , id ) : <NEWLINE> <INDENT> { resource } _query = { Resources } . query . get_or_404 ( id ) <NEWLINE> result = schema . dump ( { resource } _query ) . data <NEWLINE> return result <NEWLINE> <DEDENT>
def skip_checks ( cls ) : <NEWLINE> <INDENT> super ( TestGettingAddress , cls ) . skip_checks ( ) <NEWLINE> if not ( CONF . network_feature_enabled . ipv6 <NEWLINE> <INDENT> and CONF . network_feature_enabled . ipv6_subnet_attributes ) : <NEWLINE> raise cls . skipException ( <STRING> ) <NEWLINE> <DEDENT> if not ( CONF . network . tenant_networks_reachable <NEWLINE> <INDENT> or CONF . network . public_network_id ) : <NEWLINE> msg = ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> raise cls . skipException ( msg ) <NEWLINE> <DEDENT> <DEDENT> if CONF . baremetal . driver_enabled : <NEWLINE> <INDENT> msg = ( <STRING> ) <NEWLINE> raise cls . skipException ( msg ) <NEWLINE> <DEDENT> <DEDENT>
def retranslateUi ( self , Dialog ) : <NEWLINE> <INDENT> Dialog . setWindowTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . flactagBrowser . setHtml ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
class Field : <NEWLINE> <INDENT> def __init__ ( self , ( x , y , z ) , radius ) : <NEWLINE> <INDENT> self . coords = ( x , y , z ) <NEWLINE> self . radius = radius <NEWLINE> <DEDENT> <DEDENT>
def build_bound_meth ( ctx , name , sig ) : <NEWLINE> <INDENT> def method ( self , * args , ** kw ) : <NEWLINE> <INDENT> adom , bdom = sig . dom [ 0 ] , sig . dom [ 1 : ] <NEWLINE> saturated = len ( bdom ) == len ( args ) <NEWLINE> if saturated : <NEWLINE> <INDENT> outsig = instantiate ( ctx , sig ) <NEWLINE> return Proxy ( outsig ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise TypeError , <STRING> % ( name , len ( sig . dom ) , len ( args ) + 1 ) <NEWLINE> <DEDENT> <DEDENT> return method <NEWLINE> <DEDENT>
def onClose ( self , widget , action , data ) : <NEWLINE> <INDENT> self . hide ( ) <NEWLINE> <INDENT> def onHighlightMenu ( self , widget , action , data ) : <NEWLINE> <INDENT> self . eventPopup . show ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_current_user ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return jsonify ( { <STRING> : session [ <STRING> ] <NEWLINE> <INDENT> <STRING> : session [ <STRING> ] } ) <NEWLINE> <DEDENT> <DEDENT> except KeyError : <NEWLINE> <INDENT> abort ( 404 ) <NEWLINE> <DEDENT> <DEDENT>
def Ungroup ( self ) : <NEWLINE> <INDENT> objects = [ ] <NEWLINE> for obj in self . objects : <NEWLINE> <INDENT> if obj . __class__ is BlendInterpolation : <NEWLINE> objects . append ( obj . AsGroup ( ) ) <NEWLINE> else : <NEWLINE> objects . append ( obj ) <NEWLINE> <DEDENT> return objects <NEWLINE> <DEDENT>
def load_bytecode ( self , f ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> magic = f . read ( len ( bc_magic ) <NEWLINE> if magic != bc_magic : <NEWLINE> <INDENT> self . reset ( ) <NEWLINE> return <NEWLINE> <DEDENT> checksum = pickle . load ( f ) <NEWLINE> if self . checksum != checksum : <NEWLINE> <INDENT> self . reset ( ) <NEWLINE> return <NEWLINE> <DEDENT> self . code = marshal_load ( f ) <NEWLINE> <DEDENT>
def import_credential ( self , file = None , data = None ) : <NEWLINE> <INDENT> if data : <NEWLINE> <INDENT> if self . context . load_id_chunk ( data ) != ABAC . ABAC_CERT_SUCCESS : <NEWLINE> return self . context . load_attribute_chunk ( data ) == ABAC . ABAC_CERT_SUCCESS <NEWLINE> else : <NEWLINE> return True <NEWLINE> <DEDENT> elif file : <NEWLINE> <INDENT> if self . context . load_id_file ( file ) != ABAC . ABAC_CERT_SUCCESS : <NEWLINE> return self . context . load_attribute_file ( file ) == ABAC . ABAC_CERT_SUCCESS <NEWLINE> else : <NEWLINE> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT>
def rax_find_volume ( module , rax_module , name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> cbs = rax_module . cloud_blockstorage <NEWLINE> try : <NEWLINE> <INDENT> UUID ( name ) <NEWLINE> volume = cbs . get ( name ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> volume = cbs . find ( name = name ) <NEWLINE> <DEDENT> except rax_module . exc . NotFound : <NEWLINE> <INDENT> volume = None <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> module . fail_json ( msg = <STRING> % e ) <NEWLINE> <DEDENT> <DEDENT> return volume <NEWLINE> <DEDENT>
def parse_BL ( self , indent ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> while self . parse_BI_helper ( indent ) : i = i + 1 <NEWLINE> if i == 0 : print <STRING> , sys . exit ( 1 ) <NEWLINE> self . reduce ( BL , i , indent ) <NEWLINE> <DEDENT>
def pomfremember ( inp , chan = None , nick = None , say = None , db = None , adminonly = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> word , url = inp . split ( None , 1 ) <NEWLINE> <DEDENT> pomfurl = upload ( url ) <NEWLINE> strsave = <STRING> . format ( word , pomfurl ) <NEWLINE> hashtags . remember ( strsave , nick , db ) <NEWLINE> return ( formatting . output ( <STRING> , [ <STRING> . format ( word , pomfurl ) ] ) ) <NEWLINE> <DEDENT>
class Solution ( object ) : <NEWLINE> <INDENT> def bulbSwitch ( self , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return int ( math . sqrt ( n ) <NEWLINE> <DEDENT> <DEDENT>
def cumulative_sma ( cls , a_bar , series , prevma ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if a_bar [ 0 ] <= 0 : <NEWLINE> return series [ 0 ] <NEWLINE> else : <NEWLINE> return prevma + ( ( series [ a_bar [ 0 ] ] - prevma ) / ( a_bar [ 0 ] + 1.0 ) ) <NEWLINE> <DEDENT>
def startElementNS ( self , name , qname , attr ) : <NEWLINE> <INDENT> print ( <STRING> , qname ) <NEWLINE> print ( <STRING> , name ) <NEWLINE> uri , elem = name <NEWLINE> if ( elem == <STRING> ) : print <STRING> , attr . getValueByQName ( <STRING> ) , <STRING> <NEWLINE> self . startElement ( elem , attr ) <NEWLINE> pass <NEWLINE> <DEDENT>
def IndentLevel ( by = 1 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> global _Level <NEWLINE> if _Level + by < 0 : <NEWLINE> <INDENT> raise Error , <STRING> <NEWLINE> <DEDENT> _Level = _Level + by <NEWLINE> <DEDENT>
class Label ( Widget ) : <NEWLINE> <INDENT> def setText ( self , text ) : <NEWLINE> self . w . labelText ( text ) <NEWLINE> def __init__ ( self , text ) : <NEWLINE> self . w = _snack . label ( text ) <NEWLINE> <DEDENT>
def get_nodes_with_slivers ( xml , filter = { } ) : <NEWLINE> <INDENT> xpath = <STRING> <NEWLINE> <INDENT> node_elems = xml . xpath ( xpath ) <NEWLINE> <DEDENT> if not node_elems : <NEWLINE> <INDENT> node_elems = xml . xpath ( <STRING> ) <NEWLINE> <INDENT> return OcfVtNode . get_node_objs ( node_elems ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_monary_count1 ( self ) : <NEWLINE> <INDENT> with self . assertRaisesRegexp ( <NEWLINE> <INDENT> monary . monary . MonaryError , <NEWLINE> <STRING> ) : <NEWLINE> with monary . Monary ( ) as m : <NEWLINE> m . query ( <STRING> , <STRING> , { } , <NEWLINE> <INDENT> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , [ <STRING> ] * 5 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def autocomplete_light_data_attributes ( attributes , prefix = <STRING> ) : <NEWLINE> <INDENT> html = [ ] <NEWLINE> for key , value in attributes . items ( ) <NEWLINE> <INDENT> html . append ( <STRING> % ( prefix , key . replace ( <STRING> , <STRING> ) , value ) ) <NEWLINE> <DEDENT> return safestring . mark_safe ( <STRING> . join ( html ) ) <NEWLINE> <DEDENT>
def identifies ( id , schema , table , alias ) <NEWLINE> <INDENT> return id == alias or id == table or ( <NEWLINE> <INDENT> schema and ( id == schema + <STRING> + table ) ) <NEWLINE> <DEDENT> <DEDENT>
def save_connections ( self , output_dir ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for conn_grp in self . connection_groups . itervalues ( ) : <NEWLINE> <INDENT> if isinstance ( conn_grp . synapse_type <NEWLINE> <INDENT> pyNN . standardmodels . synapses . ElectricalSynapse ) : <NEWLINE> attributes = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> attributes = <STRING> <NEWLINE> <DEDENT> conn_grp . save ( attributes , os . path . join ( <NEWLINE> <INDENT> output_dir , conn_grp . label + <STRING> ) , format = <STRING> , <NEWLINE> gather = True ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def checkParameter ( self , Id , ( class_id , parameter_id ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for p in self . session . query ( rel_pv_par ) . filter_by ( pv_id = Id ) . filter_by ( tc_clpar_id = class_id ) . filter_by ( tc_par_id = parameter_id ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
def usage ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
def _handle_process_end ( pid , condition , ( myself , stderr ) ) : <NEWLINE> <INDENT> myself . _running = False <NEWLINE> if os . WIFEXITED ( condition ) and os . WEXITSTATUS ( condition ) == 0 : <NEWLINE> <INDENT> myself . emit ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> myself . _notify_error ( stderr ) <NEWLINE> <DEDENT> <DEDENT>
def get_repos ( path ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> p = str ( path ) <NEWLINE> ret = [ ] <NEWLINE> if not os . path . exists ( p ) : <NEWLINE> <INDENT> return ret <NEWLINE> <DEDENT> for d in os . listdir ( p ) : <NEWLINE> <INDENT> pd = os . path . join ( p , d ) <NEWLINE> if os . path . exists ( pd ) and is_repo ( pd ) : <NEWLINE> <INDENT> ret . append ( Local ( pd ) <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <DEDENT>
def IsHighStaff ( user ) : <NEWLINE> <INDENT> if conf [ <STRING> ] == <STRING> : <NEWLINE> <INDENT> HighStaff = config [ <STRING> ] . split ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> HighStaff = GetHighStaff ( ) <NEWLINE> <DEDENT> if user in HighStaff : <NEWLINE> return True <NEWLINE> else : <NEWLINE> return False <NEWLINE> <DEDENT>
def load_game ( filepath ) : <NEWLINE> <INDENT> global gamedata <NEWLINE> if gamedata . _game is not None : <NEWLINE> <INDENT> from gui . prompts import QuitPrompt <NEWLINE> prompt = QuitPrompt ( ( <STRING> ) <NEWLINE> if prompt . get_input ( ) == True : <NEWLINE> <INDENT> _do_loading_stuff ( filepath ) <NEWLINE> <DEDENT> <DEDENT> else : _do_loading_stuff ( filepath ) <NEWLINE> <DEDENT>
def draw_rubberband ( self , event , x0 , y0 , x1 , y1 ) : <NEWLINE> <INDENT> height = self . canvas . figure . bbox . height <NEWLINE> y1 = height - y1 <NEWLINE> y0 = height - y0 <NEWLINE> w = abs ( x1 - x0 ) <NEWLINE> h = abs ( y1 - y0 ) <NEWLINE> rect = [ int ( val ) for val in min ( x0 , x1 ) , min ( y0 , y1 ) , w , h ] <NEWLINE> self . canvas . drawRectangle ( rect ) <NEWLINE> <DEDENT>
def build_crop_image_directory ( self , custom_crop_directory_name = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> crop_image_directory = settings . MEDIA_ROOT + <STRING> + APP_BASE_DIRECTORY + CROPPED_IMG_DIRECTORY + custom_crop_directory_name + <STRING> <NEWLINE> <INDENT> logger . debug ( <STRING> + str ( crop_image_directory ) ) <NEWLINE> <DEDENT> return crop_image_directory <NEWLINE> <DEDENT>
def status ( self , args ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . connection . request ( <STRING> , route [ <STRING> ] [ args ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> return ( msg [ <STRING> ] % ( host , port ) <NEWLINE> <DEDENT> response = self . connection . getresponse ( ) <NEWLINE> return response . read ( ) <NEWLINE> <DEDENT>
def test_save_config ( self ) : <NEWLINE> <INDENT> with mock . patch ( <STRING> <NEWLINE> <INDENT> <STRING> ) as r_t , mock . patch ( <STRING> ) as replace : <NEWLINE> r_t . return_value = <STRING> <NEWLINE> lb = mock . Mock ( ) <NEWLINE> jinja_cfg . save_config ( <STRING> , lb , <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ) <NEWLINE> r_t . assert_called_once_with ( lb , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ) <NEWLINE> replace . assert_called_once_with ( <STRING> , <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def getInterestingBuildSteps ( self , builder_name , build ) : <NEWLINE> <INDENT> if ( not self . good_revision_steps or <NEWLINE> <INDENT> ( builder_name in self . good_revision_steps and <NEWLINE> <INDENT> not self . good_revision_steps [ builder_name ] ) ) : <NEWLINE> if self . use_getname : <NEWLINE> <DEDENT> return [ step . getName ( ) for step in build . getSteps ( ) ] <NEWLINE> else : <NEWLINE> return [ step . getText ( ) [ 0 ] for step in build . getSteps ( ) ] <NEWLINE> <DEDENT> return self . good_revision_steps [ builder_name ] <NEWLINE> <DEDENT>
def check_store_validity ( user_stores_controller , user_identifier , store_id ) : <NEWLINE> <INDENT> for i in range ( 0 , 15 ) : <NEWLINE> <INDENT> connected_store = user_stores_controller . user_stores_get_single_store ( user_identifier , store_id ) ; <NEWLINE> if ( connected_store is not None and ( connected_store . result . scrape_status == <STRING> or connected_store . result . scrape_status == <STRING> or connected_store . result . scrape_status == <STRING> ) ) : <NEWLINE> <INDENT> if ( connected_store . result . credentials_status == <STRING> ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> time . sleep ( 3 ) <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
def test_effective_message ( self update ) : <NEWLINE> <INDENT> eff_message = update . effective_message <NEWLINE> if not ( update . inline_query is not None <NEWLINE> <INDENT> or update . chosen_inline_result is not None <NEWLINE> or ( update . callback_query is not None <NEWLINE> <INDENT> and update . callback_query . message is None ) <NEWLINE> <DEDENT> or update . shipping_query is not None <NEWLINE> or update . pre_checkout_query is not None ) : <NEWLINE> assert eff_message . message_id == message . message_id <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> assert eff_message is None <NEWLINE> <DEDENT> <DEDENT>
def _read_fmt_chunk ( self , chunk ) : <NEWLINE> <INDENT> wFormatTag , self . _nchannels , self . _framerate , dwAvgBytesPerSec , wBlockAlign = struct . unpack ( <STRING> , chunk . read ( 14 ) ) <NEWLINE> if wFormatTag == WAVE_FORMAT_PCM : <NEWLINE> <INDENT> sampwidth = struct . unpack ( <STRING> , chunk . read ( 2 ) ) [ 0 ] <NEWLINE> self . _sampwidth = ( sampwidth + 7 ) // 8 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Error , <STRING> % ( wFormatTag , ) <NEWLINE> <DEDENT> self . _framesize = self . _nchannels * self . _sampwidth <NEWLINE> self . _comptype = <STRING> <NEWLINE> self . _compname = <STRING> <NEWLINE> <DEDENT>
def convert ( value ) : <NEWLINE> <INDENT> if value . startswith ( <STRING> ) : <NEWLINE> return value . strip ( <STRING> ) <NEWLINE> if not value : <NEWLINE> value = <STRING> <NEWLINE> return float ( value ) <NEWLINE> <DEDENT>
def testFlagMatrixNotFound ( self ) : <NEWLINE> <INDENT> self . mock_flags . benchmarks = [ <STRING> ] <NEWLINE> self . mock_flags . flag_matrix = <STRING> <NEWLINE> with patch ( <STRING> , <NEWLINE> <INDENT> return_value = yaml . load ( USER_CONFIG ) ) : <NEWLINE> with self . assertRaises ( benchmark_sets . FlagMatrixNotFoundException ) : <NEWLINE> benchmark_sets . GetBenchmarksFromFlags ( ) <NEWLINE> <DEDENT> <DEDENT>
def update_properties ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for value in self . _node . get_values ( <NEWLINE> <INDENT> class_id = zwave . const . COMMAND_CLASS_SWITCH_MULTILEVEL ) . values ( ) : <NEWLINE> if value . command_class == zwave . const . COMMAND_CLASS_SWITCH_MULTILEVEL and value . label == <STRING> : <NEWLINE> self . _current_position = value . data <NEWLINE> <DEDENT> <DEDENT>
import serial <NEWLINE> ser = serial . Serial ( <STRING> , 9600 ) <NEWLINE> while ( 1 ) <NEWLINE> <INDENT> a = ser . printline ( ) <NEWLINE> b = a . split ( ) [ 0 ] <NEWLINE> print ( b ) <NEWLINE> print ( type ( b ) ) <NEWLINE> <DEDENT>
class qspn_chunk : <NEWLINE> <INDENT> def __init__ ( self , link_id , rem_ ) : <NEWLINE> self . linkid = link_id <NEWLINE> <INDENT> self . rem = rem_ <NEWLINE> def print_qspn_ch ( self ) : <NEWLINE> print ( <STRING> , self . linkid ) <NEWLINE> print ( <STRING> , ) <NEWLINE> self . rem . print_rem ( ) <NEWLINE> <DEDENT> <DEDENT>
def get_absolute_url ( self ) : <NEWLINE> <INDENT> return <STRING> % ( <NEWLINE> <INDENT> settings . SERVER_URL , <NEWLINE> reverse ( <STRING> , args = [ self . pk ] ) <NEWLINE> <DEDENT> <DEDENT>
def delete ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> headers , data = self . _requester . requestJsonAndCheck ( <NEWLINE> <INDENT> <STRING> <NEWLINE> self . __customUrl <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def match_string ( list_string , mapping , substring_len ) : <NEWLINE> <INDENT> matches = [ ] <NEWLINE> for i in range ( min ( substring_len , len ( list_string ) ) ) ) : <NEWLINE> <INDENT> for j in range ( len ( list_string ) - i ) : <NEWLINE> <INDENT> substr = <STRING> . join ( list_string [ j : ( j + i + 1 ) ] ) <NEWLINE> if substr in mapping : <NEWLINE> <INDENT> matches . append ( substr ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return matches <NEWLINE> <DEDENT>
def get ( dictionary , key ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return dictionary . get ( key ) <NEWLINE> <DEDENT> except TypeError as e : <NEWLINE> <INDENT> logger . error ( <NEWLINE> <INDENT> <STRING> , dictionary , key e ) <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT> <DEDENT>
from numpy import empty , array , save <NEWLINE> N = 14645083 <NEWLINE> D = empty ( ( 7 , N ) ) <NEWLINE> f = open ( <STRING> ) <NEWLINE> i = 0 <NEWLINE> for line in f : <NEWLINE> <INDENT> if line . startswith ( <STRING> ) : continue <NEWLINE> D [ : , i ] = array ( [ float ( x ) for x in line . split ( ) ] ) <NEWLINE> i += 1 <NEWLINE> if i % 100000 == 0 : <NEWLINE> <INDENT> print <STRING> % ( 100. * i / N ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> save ( <STRING> , D ) <NEWLINE> print ( <STRING> ) <NEWLINE>
<INDENT> Eq ( qd [ 7 ] , xy_rates [ q8d ] ) ] <NEWLINE>
def cmp_gauged ( xs , ys , gauges ) : <NEWLINE> <INDENT> for gauge in gauges : <NEWLINE> gx = sum_gauge ( gauge , xs ) <NEWLINE> gy = sum_gauge ( gauge , ys ) <NEWLINE> c = cmp ( gx , gy ) <NEWLINE> if c : <NEWLINE> <INDENT> return c <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT>
import subprocess <NEWLINE> import requests <NEWLINE> <STRING> <NEWLINE> f = open ( <STRING> , <STRING> ) <NEWLINE> t = open ( <STRING> , <STRING> ) <NEWLINE> l = f . read ( ) . splitlines ( ) <NEWLINE> for each in l : <NEWLINE> <INDENT> try : <NEWLINE> r = requests . get ( each ) <NEWLINE> if ( r . status_code == 200 ) : <NEWLINE> <INDENT> print ( r . url ) <NEWLINE> t . write ( r . url + <STRING> ) <NEWLINE> except : <NEWLINE> <DEDENT> pass <NEWLINE> <DEDENT> t . close ( ) <NEWLINE>
def __getattr__ ( self , name ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> index = name . rfind ( <STRING> ) <NEWLINE> id , lang = name [ : index ] , name [ index + 1 : ] <NEWLINE> property = self . _local_properties [ id ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> raise AttributeError , <STRING> % ( self . __class__ . __name__ , name ) <NEWLINE> <DEDENT> return self . getLocalAttribute ( id , lang ) <NEWLINE> <DEDENT>
from { { cookiecutter . package_name } } . cli import main <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def predict ( self , face ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . isTrained : <NEWLINE> <INDENT> face4d = face . reshape ( [ 1 , self . image_size , self . image_size , 1 ] ) <NEWLINE> prediction = self . session . run ( self . output , feed_dict = { self . x : face4d , self . keep_prob : 1.0 } ) logging . info ( <STRING> + str ( prediction ) ) <NEWLINE> return prediction <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>
def password_wrapper ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return ( os . environ . get ( <STRING> ) , os . environ . get ( <STRING> ) or ( get_input ( <STRING> ) , getpass ( <STRING> ) ) <NEWLINE> <DEDENT>
def _recursion ( object ) : <NEWLINE> <INDENT> return ( <STRING> <NEWLINE> <INDENT> % ( _type ( object ) . __name__ , _id ( object ) ) <NEWLINE> <DEDENT> <DEDENT>
def __repr__ ( self ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> for ( k , v ) in sorted ( self . varmap . items ( ) , key = lambda ( k , v ) : v ) : <NEWLINE> <INDENT> s += <STRING> % ( v , k ) <NEWLINE> <DEDENT> s += <STRING> % ( len ( self . varmap ) , len ( self . clsset ) ) <NEWLINE> for c in self . clsset : <NEWLINE> <INDENT> for v in c : s += str ( v ) + <STRING> <NEWLINE> s += <STRING> <NEWLINE> <DEDENT> return s <NEWLINE> <DEDENT>
def _check_missing ( output ) : <NEWLINE> <INDENT> for i , line in enumerate ( output . split ( <STRING> ) ) : <NEWLINE> <INDENT> for msg in ( <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> ) : <NEWLINE> if msg in line . lower ( ) : <NEWLINE> raise BuildError ( <STRING> . join ( output . split ( <STRING> ) [ i : ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def _construct ( cls , kwargs ) : <NEWLINE> <INDENT> params = { } <NEWLINE> for attr in ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> try : <NEWLINE> params [ attr ] = kwargs . pop ( attr ) <NEWLINE> except KeyError : <NEWLINE> pass <NEWLINE> <DEDENT> return cls . _make ( ** params ) <NEWLINE> <DEDENT>
def __iter__ ( self ) : <NEWLINE> <INDENT> for row in range ( self . num_rows ) : <NEWLINE> <INDENT> for col in range ( self . num_cols ) : <NEWLINE> <INDENT> if row , col in self : <NEWLINE> <INDENT> yield self [ row , col ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def run_gui ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> main_gui = Proximate_GUI ( ) <NEWLINE> for modulename in [ <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <STRING> ] : <NEWLINE> module = __import__ ( modulename ) <NEWLINE> try : <NEWLINE> module . init_ui ( main_gui ) <NEWLINE> except TypeError : <NEWLINE> die ( <STRING> % ( modulename ) ) <NEWLINE> <DEDENT> proximatestate . load_external_plugins ( ui = main_gui ) <NEWLINE> main_gui . run ( ) <NEWLINE> <DEDENT>
def select ( self query ) : <NEWLINE> <INDENT> self . execute ( query ) <NEWLINE> return self . fetchall ( ) <NEWLINE> <DEDENT>
( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def test_ordering ( self ) : <NEWLINE> <INDENT> with original_warnings . catch_warnings ( record = True , <NEWLINE> <INDENT> module = self . module ) as w : <NEWLINE> self . module . resetwarnings ( ) <NEWLINE> self . module . filterwarnings ( <STRING> , category = UserWarning ) <NEWLINE> self . module . filterwarnings ( <STRING> , category = UserWarning , <NEWLINE> <INDENT> append = True ) <NEWLINE> del w [ : ] <NEWLINE> try : <NEWLINE> <DEDENT> self . module . warn ( <STRING> , UserWarning ) <NEWLINE> except UserWarning : <NEWLINE> self . fail ( <STRING> ) <NEWLINE> self . assertEqual ( len ( w ) , 0 ) <NEWLINE> <DEDENT> <DEDENT>
def retranslateUi ( self , DockWidget ) : <NEWLINE> <INDENT> DockWidget . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . textEdit . setHtml ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def create_gs_file ( cls , file_name , csv ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> bucket_name = app_identity . get_default_gcs_bucket_name ( ) <NEWLINE> bucket = <STRING> + bucket_name <NEWLINE> filename = bucket + <STRING> + file_name <NEWLINE> write_retry_params = gcs . RetryParams ( backoff_factor = 1.1 ) <NEWLINE> gcs_file = gcs . open ( filename , <NEWLINE> <INDENT> <STRING> , <NEWLINE> , <NEWLINE> content_type = <STRING> , <NEWLINE> retry_params = write_retry_params ) <NEWLINE> <DEDENT> gcs_file . write ( csv ) <NEWLINE> gcs_file . close ( ) <NEWLINE> <DEDENT>
def work_around_knc_module_bug ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . knc : <NEWLINE> unload_knc_proc = subprocess . Popen ( <NEWLINE> <INDENT> [ <STRING> , <STRING> , <STRING> , <STRING> ] , <NEWLINE> stdout = subprocess . PIPE <NEWLINE> ) <NEWLINE> stdout , stderr = unload_knc_proc . communicate ( ) <NEWLINE> exec stdout <NEWLINE> <DEDENT> <DEDENT>
def find_page ( xml , index_line , page_number ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for prtpage in takewhile ( lambda p : p . sourceline < index_line , <NEWLINE> <INDENT> xml . xpath ( <STRING> ) ) : <NEWLINE> if prtpage . get ( <STRING> ) : <NEWLINE> page_number = int ( prtpage . get ( <STRING> ) ) <NEWLINE> <DEDENT> return page_number <NEWLINE> <DEDENT>
def getProducts ( Id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> property_parameters = { <STRING> : Id [ <STRING> ] } <NEWLINE> product_result = getResult ( <STRING> , property_parameters ) <NEWLINE> product_items = product_result [ <STRING> ] [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT>
class HouseCategorySelector ( object ) : <NEWLINE> <INDENT> def selectDice ( self , dices ) : <NEWLINE> <INDENT> mergedResult = TwoKinds ( dices , 3 , 2 ) <NEWLINE> <INDENT> return mergedResult <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def find ( self , typ ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> t = self . _o . find_object ( typ ) <NEWLINE> if t is not None : <NEWLINE> <INDENT> return VLCObject ( t . info ( ) [ <STRING> ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def help_download ( self ) : <NEWLINE> <INDENT> print ( _ ( <STRING> ) <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> print <NEWLINE> print ( _ ( <STRING> ) ) <NEWLINE> <DEDENT>
def retranslateUi ( self , create_new_project ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> create_new_project . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . newp_p1_title . setText ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . newp_projectname_label . setText ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . newp_add_server_title . setText ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . newp_p2_add_server_description . setText ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def loadCode ( self ) : <NEWLINE> <INDENT> if len ( self . getBody ( ) ) : <NEWLINE> <INDENT> exec self . getBody ( ) <NEWLINE> if vars ( ) . has_key ( self . getType ( ) ) : <NEWLINE> <INDENT> self . main_class_obj = vars ( ) [ self . getType ( ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise TypeError ( <STRING> + self . getType ( ) + <STRING> + self . getOrigin ( ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> raise TypeError ( <STRING> + self . getType ( ) + <STRING> ) <NEWLINE> <DEDENT> return self . main_class_obj <NEWLINE> <DEDENT>
def deleteRelation ( request , meetingob ) : <NEWLINE> <INDENT> if request . method == <STRING> : <NEWLINE> <INDENT> relation_ajax_id = request . GET [ <STRING> ] <NEWLINE> <DEDENT> relation = Relation . objects . filter ( id = relation_ajax_id ) <NEWLINE> if relation : <NEWLINE> relation . delete ( ) <NEWLINE> j = System . objects . get ( id = meetingob ) ; <NEWLINE> t = get_template ( <STRING> ) <NEWLINE> html = t . render ( Context ( { <STRING> : j } ) ) <NEWLINE> return HttpResponse ( html ) <NEWLINE> <DEDENT>
def _update_vm_widget_states ( self ) : <NEWLINE> <INDENT> page = self . widget ( <STRING> ) . get_current_page ( ) <NEWLINE> if self . vm . is_runable ( ) : <NEWLINE> <INDENT> self . _show_vm_status_unavailable ( ) <NEWLINE> <DEDENT> elif ( page == _CONSOLE_PAGE_UNAVAILABLE or <NEWLINE> <INDENT> page == _CONSOLE_PAGE_VIEWER ) : <NEWLINE> if self . _viewer and self . _viewer . console_is_open ( ) : <NEWLINE> <INDENT> self . _activate_viewer_page ( ) <NEWLINE> else : <NEWLINE> self . _init_viewer ( ) <NEWLINE> <DEDENT> <DEDENT> self . _refresh_widget_states ( ) <NEWLINE> <DEDENT>
def runPackedApp ( pathname ) : <NEWLINE> <INDENT> runner = AppRunner ( ) <NEWLINE> runner . gotWindow = True <NEWLINE> try : <NEWLINE> <INDENT> runner . setP3DFilename ( pathname , tokens = [ ] , argv = [ ] , <NEWLINE> <INDENT> instanceId = 0 , interactiveConsole = False ) <NEWLINE> <DEDENT> <DEDENT> except ArgumentError , e : <NEWLINE> <INDENT> print ( e . args [ 0 ] ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
def _recall_at_threshold ( labels , predictions , weights , threshold , name = None ) : <NEWLINE> <INDENT> with ops . name_scope ( <NEWLINE> <INDENT> name , <STRING> % threshold , <NEWLINE> ( predictions , labels , weights , threshold ) ) as scope : <NEWLINE> precision_tensor , update_op = metrics_lib . recall_at_thresholds ( <NEWLINE> <INDENT> labels = labels , predictions = predictions , thresholds = ( threshold , ) , <NEWLINE> weights = weights , name = scope ) <NEWLINE> return array_ops . squeeze ( precision_tensor ) , array_ops . squeeze ( update_op ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def tearDown ( self ) <NEWLINE> <INDENT> logging . info ( <STRING> ) <NEWLINE> self . _remote_inspector_client . Stop ( ) <NEWLINE> logging . info ( <STRING> ) <NEWLINE> perf . BasePerfTest . tearDown ( self ) <NEWLINE> <DEDENT>
( <NEWLINE> <INDENT> preauthtoken = response . headers [ <STRING> ] , <NEWLINE> preauthurl = response . headers [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT>
class ResourceExtension ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , collection , controller , parent = None , <NEWLINE> <INDENT> collection_actions = None , member_actions = None , <NEWLINE> custom_routes_fn = None ) : <NEWLINE> if not collection_actions : <NEWLINE> collection_actions = { } <NEWLINE> if not member_actions : <NEWLINE> member_actions = { } <NEWLINE> self . collection = collection <NEWLINE> self . controller = controller <NEWLINE> self . parent = parent <NEWLINE> self . collection_actions = collection_actions <NEWLINE> self . member_actions = member_actions <NEWLINE> self . custom_routes_fn = custom_routes_fn <NEWLINE> <DEDENT> <DEDENT>
def list_instance_notes ( self ) : <NEWLINE> <INDENT> instance_notes = [ ] <NEWLINE> for vs in self . _conn . Msvm_VirtualSystemSettingData ( <NEWLINE> <INDENT> [ <STRING> , <STRING> ] , <NEWLINE> SettingType = self . _VIRTUAL_SYSTEM_CURRENT_SETTINGS ) : <NEWLINE> if vs . Notes is not None : <NEWLINE> instance_notes . append ( <NEWLINE> <INDENT> ( vs . ElementName , [ v for v in vs . Notes . split ( <STRING> ) if v ] ) ) <NEWLINE> <DEDENT> <DEDENT> return instance_notes <NEWLINE> <DEDENT>
def documents ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> data = [ ] <NEWLINE> obj = getattr ( self . obj , self . header ) <NEWLINE> if ( hasattr ( obj , <STRING> ) and <NEWLINE> <INDENT> hasattr ( obj . RegistrosDocumento , <STRING> ) ) : <NEWLINE> for d in obj . RegistrosDocumento . RegistroDoc : <NEWLINE> data . append ( C1 . RegistroDoc ( d ) ) <NEWLINE> <DEDENT> return data <NEWLINE> <DEDENT>
def _checkParameterValuesBeforeExecuting ( self ) : <NEWLINE> <INDENT> for param in self . parameters : <NEWLINE> <INDENT> if isinstance ( param , ( ParameterRaster , ParameterVector , <NEWLINE> <INDENT> ParameterMultipleInput ) ) : <NEWLINE> if param . value : <NEWLINE> if isinstance ( param , ParameterMultipleInput ) : <NEWLINE> inputlayers = param . value . split ( <STRING> ) <NEWLINE> else : <NEWLINE> inputlayers = [ param . value ] <NEWLINE> for inputlayer in inputlayers : <NEWLINE> obj = dataobjects . getObject ( inputlayer ) <NEWLINE> if obj is None : <NEWLINE> return <STRING> + param . value <NEWLINE> <DEDENT> <DEDENT> return self . checkParameterValuesBeforeExecuting ( ) <NEWLINE> <DEDENT>
class DatasetKFold ( DatasetCV ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , dataset , n_folds = 3 , shuffle = False , random_state = None , <NEWLINE> <INDENT> ** kwargs ) : <NEWLINE> n = dataset . X . shape [ 0 ] <NEWLINE> cv = KFold ( n , n_folds = n_folds , shuffle = shuffle , <NEWLINE> <INDENT> random_state = random_state ) <NEWLINE> super ( DatasetKFold , self ) . __init__ ( dataset , cv , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def _get_exception_log_path ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> app = sys . argv [ 0 ] . split ( <STRING> ) [ - 1 ] <NEWLINE> for exception_log in [ <STRING> % app , <NEWLINE> <INDENT> <STRING> % app , <NEWLINE> <STRING> % app ] : <NEWLINE> if os . access ( path . dirname ( exception_log ) , os . W_OK ) : <NEWLINE> return exception_log <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>
def _async ( self , name , params ) : <NEWLINE> <INDENT> task_ref = create_task ( name ) <NEWLINE> task = _db_content [ <STRING> ] [ task_ref ] <NEWLINE> func = name [ len ( <STRING> ) : ] <NEWLINE> try : <NEWLINE> <INDENT> task [ <STRING> ] = self . xenapi_request ( func , params [ 1 : ] ) <NEWLINE> task [ <STRING> ] = <STRING> <NEWLINE> <DEDENT> except Failure , exc : <NEWLINE> <INDENT> task [ <STRING> ] = exc . details <NEWLINE> task [ <STRING> ] = <STRING> <NEWLINE> <DEDENT> task [ <STRING> ] = datetime . datetime . now ( ) <NEWLINE> return task_ref <NEWLINE> <DEDENT>
def get_Y ( params , kd , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> alpha , A = params <NEWLINE> if kd . ndim == 1 : <NEWLINE> Y = ( kd ** alpha ) * ( ( A * n ) ** ( 1 - alpha ) ) <NEWLINE> elif kd . ndim == 2 : <NEWLINE> Y = ( kd ** alpha ) * ( np . einsum ( <STRING> , A , n ) ** ( 1 - alpha ) ) <NEWLINE> return Y <NEWLINE> <DEDENT>
def AListDir ( path ) : <NEWLINE> <INDENT> fd = os . Open ( localPath ( path ) ) <NEWLINE> with defer fd . Close ( ) : <NEWLINE> <INDENT> vec = fd . Readdir ( - 1 ) <NEWLINE> z = [ ( i . Name ( ) , i . IsDir ( ) , i . Size ( ) , i . ModTime ( ) . Unix ( ) ) for i in vec ] <NEWLINE> return z <NEWLINE> <DEDENT> <DEDENT>
def kill_ie ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return render_template ( <STRING> , blog_name = Setting . get_setting ( <STRING> , <STRING> ) <NEWLINE> <DEDENT>
( <NEWLINE> if updated_items < 1 : <NEWLINE> <INDENT> return jsonify ( error = <STRING> ) , 400 <NEWLINE> <DEDENT> return jsonify ( status = <STRING> ) <NEWLINE> <DEDENT> except TypeError as err : <NEWLINE> <INDENT> logging . error ( err ) <NEWLINE> abort ( 400 ) <NEWLINE> <DEDENT> except BadRequest as err : <NEWLINE> <INDENT> logging . error ( err ) <NEWLINE> abort ( 400 ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT>
def maximize ( points : [ ] Point ) -> Point : <NEWLINE> <INDENT> nxt = points [ 0 ] <NEWLINE> slice = points [ 1 : ] <NEWLINE> for p in slice : <NEWLINE> <INDENT> nxt = nxt . maximize ( p ) <NEWLINE> <DEDENT> return nxt <NEWLINE> <DEDENT>
def test_ping ( request ) : <NEWLINE> <INDENT> hostname = request . GET . get ( <STRING> ) <NEWLINE> <INDENT> target = request . GET . get ( <STRING> ) <NEWLINE> <DEDENT> ping_reply = [ ] <NEWLINE> return HttpResponse ( <STRING> ) <NEWLINE> <DEDENT>
class AnalyseSCFTask ( AnalyseOptimizersTask ) : <NEWLINE> <INDENT> def __init__ ( self , taskname , runs , <NEWLINE> <INDENT> labels = None , tag = None , steps = 100 , precision = 3 , tunit = <STRING> ) : <NEWLINE> <STRING> <NEWLINE> AnalyseOptimizersTask . __init__ ( self , taskname , runs , <NEWLINE> <INDENT> labels , tag , steps , precision , tunit ) <NEWLINE> self . key_summary = <STRING> <NEWLINE> self . key_plot = <STRING> <NEWLINE> self . plot_label = <STRING> <NEWLINE> self . plot_xlabel = <STRING> <NEWLINE> self . plot_ylabel = self . key_plot <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class tiempo ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , id_registro , fecha_hora_entrada ) : <NEWLINE> <INDENT> self . id_registro = int ( id_registro ) <NEWLINE> self . fecha_hora_entrada = fecha_hora_entrada <NEWLINE> <DEDENT> def obten_entradas ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . usuario is None : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> if self . usuario is <STRING> : <NEWLINE> <INDENT> entradas = db_sql . session . query ( Registro ) . filter and_ ( <NEWLINE> <INDENT> Registro . fecha_hora_entrada <= <STRING> , <NEWLINE> Registro . fecha_hora_entrada >= <STRING> ) <NEWLINE> <DEDENT> return entradas <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def grammar_parse_query ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> grammarQuery = raw_input ( <STRING> ) <NEWLINE> if grammarQuery . lower ( ) == <STRING> : <NEWLINE> <DEDENT> return True <NEWLINE> break <NEWLINE> elif grammarQuery . lower ( ) == <STRING> : <NEWLINE> return False <NEWLINE> break <NEWLINE> <DEDENT>
class ConnectionUserAndKey ( ConnectionKey ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> user_id = None <NEWLINE> def __init__ ( self , user_id , key , secure = True , host = None , port = None , <NEWLINE> <INDENT> url = None , timeout = None , proxy_url = None , <NEWLINE> backoff = None , retry_delay = None ) : <NEWLINE> super ( ConnectionUserAndKey , self ) . __init__ ( key , secure = secure , <NEWLINE> <INDENT> host = host , port = port , <NEWLINE> url = url , timeout = timeout , <NEWLINE> backoff = backoff , <NEWLINE> retry_delay = retry_delay , <NEWLINE> proxy_url = proxy_url ) <NEWLINE> self . user_id = user_id <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class BernoulliWithSigmoidProbs ( Bernoulli ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , <NEWLINE> <INDENT> logits = None , <NEWLINE> dtype = dtypes . int32 , <NEWLINE> validate_args = False , <NEWLINE> allow_nan_stats = True , <NEWLINE> name = <STRING> ) : <NEWLINE> parameters = locals ( ) <NEWLINE> with ops . name_scope ( name ) : <NEWLINE> super ( BernoulliWithSigmoidProbs , self ) . __init__ ( <NEWLINE> probs = nn . sigmoid ( logits , name = <STRING> ) , <NEWLINE> dtype = dtype , <NEWLINE> validate_args = validate_args , <NEWLINE> allow_nan_stats = allow_nan_stats , <NEWLINE> name = name ) <NEWLINE> self . _parameters = parameters <NEWLINE> <DEDENT> <DEDENT>
def test_get_token ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( auth , <STRING> , return_value = <STRING> <NEWLINE> <INDENT> ) as get_token : <NEWLINE> response = self . app . post ( <STRING> , <NEWLINE> <INDENT> data = { <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> } ) <NEWLINE> self . assertEqual ( response . status_code , 200 ) <NEWLINE> self . assertEqual ( json . loads ( response . data ) , <NEWLINE> { <STRING> : <STRING> } ) <NEWLINE> get_token . assert_called_with ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
class ForkingWSGIServer ( ForkingMixIn , BaseWSGIServer ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> multiprocess = True <NEWLINE> def __init__ ( self , host , port , app , processes = 40 , handler = None , <NEWLINE> <INDENT> passthrough_errors = False , ssl_context = None ) : <NEWLINE> BaseWSGIServer . __init__ ( self , host , port , app , handler , <NEWLINE> <INDENT> passthrough_errors , ssl_context ) <NEWLINE> self . max_children = processes <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def make_pipeline ( ) : <NEWLINE> <INDENT> pipeline = [ <NEWLINE> <INDENT> { <STRING> : { <STRING> : { <STRING> : 1 } } } , <NEWLINE> { <STRING> : <STRING> } , <NEWLINE> { <STRING> : { <STRING> : { <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> } , <NEWLINE> <STRING> : { <STRING> : <STRING> } } } , <NEWLINE> <DEDENT> { <STRING> : { <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : { <STRING> : <STRING> } } } <NEWLINE> <DEDENT> <DEDENT> return pipeline <NEWLINE> <DEDENT>
def visit_address ( self , node ) : <NEWLINE> <INDENT> raise NotImplementedError , node . astext ( ) <NEWLINE> self . visit_docinfo_item ( node , <STRING> , meta = None ) <NEWLINE> <DEDENT>
def iter_nbhs ( board , ( row , col ) ) : <NEWLINE> <INDENT> for dx , dy in NBCOORD : <NEWLINE> <INDENT> nbx , nby = row + dx , col + dy <NEWLINE> if 0 <= nbx < board . side and 0 <= nby < board . side : <NEWLINE> <INDENT> yield nbx , nby <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def formatRequire ( name , flags , evr ) : <NEWLINE> <INDENT> s = name <NEWLINE> if flags : <NEWLINE> <INDENT> if flags & ( rpm . RPMSENSE_LESS | rpm . RPMSENSE_GREATER | <NEWLINE> <INDENT> rpm . RPMSENSE_EQUAL ) : <NEWLINE> s = s + <STRING> <NEWLINE> if flags & rpm . RPMSENSE_LESS : <NEWLINE> s = s + <STRING> <NEWLINE> if flags & rpm . RPMSENSE_GREATER : <NEWLINE> s = s + <STRING> <NEWLINE> if flags & rpm . RPMSENSE_EQUAL : <NEWLINE> s = s + <STRING> <NEWLINE> s = <STRING> % ( s , versionToString ( evr ) ) <NEWLINE> <DEDENT> <DEDENT> return s <NEWLINE> <DEDENT>
class AutoRestRFC1123DateTimeTestServiceConfiguration ( Configuration ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( <NEWLINE> <INDENT> self , base_url = None ) : <NEWLINE> if not base_url : <NEWLINE> base_url = <STRING> <NEWLINE> super ( AutoRestRFC1123DateTimeTestServiceConfiguration , self ) . __init__ ( base_url ) <NEWLINE> self . add_user_agent ( <STRING> . format ( VERSION ) ) <NEWLINE> <DEDENT> <DEDENT>
def test_docker_image_create_vm ( admin_client , docker_context ) : <NEWLINE> <INDENT> uuid = TEST_IMAGE_UUID <NEWLINE> container = admin_client . create_container ( name = <STRING> , <NEWLINE> <INDENT> imageUuid = uuid , <NEWLINE> startOnCreate = False ) <NEWLINE> <DEDENT> container = wait_success ( admin_client , container ) <NEWLINE> assert container . state == <STRING> <NEWLINE> admin_client . delete ( container ) <NEWLINE> try : <NEWLINE> <INDENT> admin_client . create_virtual_machine ( name = <STRING> , <NEWLINE> <INDENT> imageUuid = uuid ) <NEWLINE> <DEDENT> <DEDENT> except ApiError , e : <NEWLINE> <INDENT> assert e . error . code == <STRING> <NEWLINE> <DEDENT> <DEDENT>
def printTreeInorder ( tree ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if tree == None : return <NEWLINE> print ( <STRING> , <NEWLINE> printTreeInorder ( tree . left ) <NEWLINE> print ( <STRING> , tree . cargo , <STRING> , ) <NEWLINE> printTreeInorder ( tree . right ) <NEWLINE> <DEDENT>
def preview_clickHandler ( self , x , y ) : <NEWLINE> <INDENT> d . selections . append ( PlacementClick ( x , y ) <NEWLINE> if len ( d . selections ) == 3 : <NEWLINE> <INDENT> return <STRING> % findUnusedObjectName ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def close ( self ) : <NEWLINE> <INDENT> logging . debug ( <STRING> ) <NEWLINE> for func in [ self . proc . stdin . close , self . proc . stdout . close , <NEWLINE> <INDENT> self . proc . wait ] : <NEWLINE> try : <NEWLINE> func ( ) <NEWLINE> except OSError : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>
def load_messages ( ) : <NEWLINE> <INDENT> for filename in listdir ( <STRING> ) : <NEWLINE> <INDENT> with open ( path . join ( <STRING> , filename ) as fp : <NEWLINE> <INDENT> messages . append ( yaml . load ( fp . read ( ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class EDNS0TLV ( Packet ) : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> fields_desc = [ ShortEnumField ( <STRING> , 0 , { 0 : <STRING> , 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> } ) , <NEWLINE> <INDENT> FieldLenField ( <STRING> , None , <STRING> , fmt = <STRING> ) , <NEWLINE> StrLenField ( <STRING> , <STRING> , length_from = lambda pkt : pkt . optlen ) ] <NEWLINE> <DEDENT> def extract_padding ( self , p ) : <NEWLINE> return <STRING> , p <NEWLINE> <DEDENT>
def checkGetCodePathsFrom ( self , vw , fva , cbva ) : <NEWLINE> <INDENT> graph = viv_graph . buildFunctionGraph ( vw , fva ) <NEWLINE> paths = [ path for path in viv_graph . getCodePathsFrom ( graph , cbva ) ] <NEWLINE> self . codepathsfrom = paths <NEWLINE> self . assertGreater ( len ( self . codepaths ) , 150 ) <NEWLINE> paths = [ path for path in graph . getHierPathsFrom , ( ( cbva , ) ) ] <NEWLINE> self . hierpathsfrom = paths <NEWLINE> self . assertGreater ( len ( self . codepaths ) , len ( self . hierpathsfrom ) ) <NEWLINE> <DEDENT>
def test_proxy_with_xframe_options ( ) : <NEWLINE> <INDENT> with CleanupEtcdFolders ( <NEWLINE> <INDENT> [ <STRING> , <NEWLINE> <INDENT> <STRING> ] ) : <NEWLINE> with MockHttpServer ( handler = XFrameOptionsHttpHandler ) as node1 : <NEWLINE> <DEDENT> _add_node ( <STRING> , <STRING> , node1 ) <NEWLINE> _add_location ( <STRING> , <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> sleep ( PROXY_REFRESH_TIME ) <NEWLINE> for protocol in [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> resp = _request_proxy ( <STRING> , <NEWLINE> <INDENT> protocol = protocol ) <NEWLINE> <DEDENT> assert_equals ( resp . status_code , 200 ) <NEWLINE> assert_equals ( resp . headers [ <STRING> ] , <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def ip_search ( search ) : <NEWLINE> <INDENT> global title <NEWLINE> db = MySQLdb . connect ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> cursor = db . cursor ( ) <NEWLINE> if search : <NEWLINE> <INDENT> sql = <STRING> % search <NEWLINE> if cursor . execute ( sql ) == 0 : <NEWLINE> <INDENT> sql = <STRING> <NEWLINE> title = <STRING> <NEWLINE> else : <NEWLINE> title = <STRING> % ( search ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> sql = <STRING> <NEWLINE> title = <STRING> <NEWLINE> <DEDENT> cursor . execute ( sql ) <NEWLINE> all = cursor . fetchall ( ) <NEWLINE> db . close ( ) <NEWLINE> return all <NEWLINE> <DEDENT>
def communicate ( self , in_line ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> err = [ ] <NEWLINE> output = <STRING> <NEWLINE> logging . info ( <STRING> + in_line + <STRING> ) <NEWLINE> if in_line in self . source_hash : <NEWLINE> logging . info ( <STRING> + in_line + <STRING> ) <NEWLINE> output = self . target_list [ self . source_hash [ in_line ] ] <NEWLINE> else : <NEWLINE> logging . info ( <STRING> + in_line + <STRING> ) <NEWLINE> return output , err <NEWLINE> <DEDENT>
def is_alarm_deleted ( alarm_id ) : <NEWLINE> <INDENT> conn = g_dbPool . connection ( ) <NEWLINE> cur = conn . cursor ( MySQLdb . cursors . DictCursor ) <NEWLINE> try : <NEWLINE> <INDENT> cur . execute ( <STRING> , ( alarm_id , ) ) <NEWLINE> rows = cur . fetchall ( ) <NEWLINE> if ( len ( rows ) < 1 ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> except MySQLdb . Error , e : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> cur . close ( ) <NEWLINE> <DEDENT> <DEDENT>
def categorias ( ) : <NEWLINE> <INDENT> addDir ( <STRING> , <STRING> , 7 , <STRING> ) <NEWLINE> addDir ( <STRING> , <STRING> , 12 , <STRING> ) <NEWLINE> <INDENT> addDir ( <STRING> , <STRING> , 5 , <STRING> ) <NEWLINE> addDir ( <STRING> , <STRING> , 13 , <STRING> ) <NEWLINE> addDir ( <STRING> , url_base + <STRING> , 4 , <STRING> ) <NEWLINE> addDir ( <STRING> , url_base + <STRING> , 4 , <STRING> ) <NEWLINE> <DEDENT> addDir ( <STRING> , url_base + <STRING> , 4 , <STRING> ) <NEWLINE> <DEDENT>
def EnsurePageCacheTemperature ( page , browser , previous_page = None ) : <NEWLINE> <INDENT> temperature = page . cache_temperature <NEWLINE> logging . info ( <STRING> , temperature ) <NEWLINE> for c in [ AnyCacheManipulator , ColdCacheManipulator , WarmCacheManipulator , <NEWLINE> <INDENT> HotCacheManipulator ] : <NEWLINE> if temperature == c . TEMPERATURE : <NEWLINE> c . PrepareCache ( page , browser , previous_page ) <NEWLINE> return <NEWLINE> <DEDENT> raise NotImplementedError ( <STRING> % temperature ) <NEWLINE> <DEDENT>
def cmos_checksum ( rtc ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for i in range ( 0x10 , 0x2e ) : <NEWLINE> sum = sum + nvram_read ( rtc , i ) <NEWLINE> nvram_write ( rtc , 0x2e , ( sum >> 8 ) & 0xff ) <NEWLINE> nvram_write ( rtc , 0x2f , sum & 0xff ) <NEWLINE> <DEDENT>
def equals ( self , other ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . is_ ( other ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if ( not hasattr ( other , <STRING> ) or <NEWLINE> <INDENT> other . inferred_type != <STRING> ) : <NEWLINE> try : <NEWLINE> other = TimedeltaIndex ( other ) <NEWLINE> except : <NEWLINE> return False <NEWLINE> <DEDENT> return np . array_equal ( self . asi8 , other . asi8 ) <NEWLINE> <DEDENT>
def get_tests ( self , ext ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> specs = glob . glob ( os . path . join ( self . path_to_test_specs , ext + <STRING> ) ) <NEWLINE> if specs : <NEWLINE> <INDENT> specs = specs [ 0 : 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> specs = glob . glob ( os . path . join ( self . path_to_test_specs , ext ) <NEWLINE> <DEDENT> return specs <NEWLINE> <DEDENT>
def updateDigIfaceControl ( self , a0 ) : <NEWLINE> <INDENT> sender = self . sender ( ) <NEWLINE> state = a0 <NEWLINE> if a0 > 0 : <NEWLINE> <INDENT> state += 1 <NEWLINE> <DEDENT> log . debug ( <STRING> % ( <NEWLINE> <INDENT> self . DigIfaceControls [ sender ] [ 0 ] , state ) ) <NEWLINE> self . hw . setDiscrete ( self . DigIfaceControls [ sender ] [ 0 ] , state ) <NEWLINE> <DEDENT> <DEDENT>
def uniqidgen ( ilist ) : <NEWLINE> <INDENT> sha512h = hashlib . new ( <STRING> ) <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> for i in ilist : <NEWLINE> <INDENT> sha512h . update ( str ( i ) ) <NEWLINE> <DEDENT> return sha512h . hexdigest ( ) <NEWLINE> <DEDENT>
class ITest ( unittest . TestCase ) : <NEWLINE> <INDENT> def test_hello_word_get ( self ) : <NEWLINE> <INDENT> target = uri ( <STRING> ) <NEWLINE> response = request ( target ) <NEWLINE> assert_that ( response . status_code , is_ ( 200 ) <NEWLINE> <DEDENT> <DEDENT>
def mock_treat_devices_added ( self , details , port , func_name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with mock . patch . object ( self . agent . plugin_rpc , <STRING> , <NEWLINE> <INDENT> return_value = details ) : <NEWLINE> with mock . patch . object ( self . agent . int_br , <STRING> , <NEWLINE> <INDENT> return_value = port ) : <NEWLINE> with mock . patch . object ( self . agent , func_name ) as func : <NEWLINE> self . assertFalse ( self . agent . treat_devices_added ( [ { } ] ) ) <NEWLINE> <DEDENT> <DEDENT> return func . called <NEWLINE> <DEDENT>
def test_invaliddict ( self ) : <NEWLINE> <INDENT> for i in [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> <NEWLINE> <STRING> ] : <NEWLINE> self . assertRaises ( ValueError , plistlib . readPlistFromBytes , <NEWLINE> <INDENT> ( <STRING> % i ) . encode ( ) ) <NEWLINE> self . assertRaises ( ValueError , plistlib . readPlistFromBytes , <NEWLINE> ( <STRING> % i ) . encode ( ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_connection ( self ) : <NEWLINE> <INDENT> if self . __connection__ is None : <NEWLINE> <INDENT> raise ConnectionlessObjectError , self <NEWLINE> <DEDENT> return self . __connection__ <NEWLINE> <DEDENT>
def with_hook ( ) : <NEWLINE> <INDENT> hook = FileFinder . path_hook ( ( MyLoader , [ <STRING> ] ) ) <NEWLINE> sys . path_hooks . insert ( 0 hook ) <NEWLINE> sys . path_importer_cache . clear ( ) <NEWLINE> invalidate_caches ( ) <NEWLINE> try : <NEWLINE> <INDENT> yield <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> sys . path_hooks . remove ( hook ) <NEWLINE> <DEDENT> <DEDENT>
def assertHasattr ( self , obj , attr , ignore ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if attr in ignore : return <NEWLINE> if not hasattr ( obj , attr ) : print <STRING> , attr <NEWLINE> self . failUnless ( hasattr ( obj , attr ) , <NEWLINE> <INDENT> <STRING> % ( obj , attr ) ) <NEWLINE> <DEDENT> <DEDENT>
def main ( argv ) : <NEWLINE> <INDENT> flag . Parse ( ) <NEWLINE> say port <NEWLINE> say <STRING> % int ( port ) <NEWLINE> <DEDENT>
def update ( inp bot = None ) : <NEWLINE> <INDENT> repo = Repo ( ) <NEWLINE> git = repo . git <NEWLINE> try : <NEWLINE> <INDENT> pull = git . pull ( ) <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> <INDENT> return e <NEWLINE> <DEDENT> if <STRING> in pull : <NEWLINE> <INDENT> return web . haste ( pull ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return pull <NEWLINE> <DEDENT> <DEDENT>
def authorize ( self ) : <NEWLINE> <INDENT> logging . info ( <STRING> % ( self , ) ) <NEWLINE> assert ( self . token ) <NEWLINE> tdata = self . request ( parameters = { <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> } ) <NEWLINE> self . token = oauth . OAuthToken . from_string ( tdata ) <NEWLINE> <DEDENT> <DEDENT>
def aesctr_crypt ( key1 , key2 , data ) : <NEWLINE> <INDENT> key1 = SHA256HMAC ( key1 , data ) <NEWLINE> if len ( key1 ) == 32 and len ( key2 ) == 16 : <NEWLINE> crypto = AES . new ( key1 , AES . MODE_CTR , counter = lambda : key2 ) <NEWLINE> encrypted = crypto . encrypt ( data ) <NEWLINE> return encrypted <NEWLINE> else : <NEWLINE> return <STRING> <NEWLINE> <DEDENT>
def do_times ( self , line , user_called = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> task_times = { } <NEWLINE> print_out = <STRING> <NEWLINE> for task in self . _tasks . values ( ) : <NEWLINE> <INDENT> task_times [ task . name ] = self . _format_timers ( task ) <NEWLINE> <DEDENT> for task , details in sorted ( task_times . items ( ) , <NEWLINE> <INDENT> key = lambda x : x [ 1 ] ) : <NEWLINE> for detail in details : <NEWLINE> print_out += detail + <STRING> <NEWLINE> print_out += <STRING> <NEWLINE> <DEDENT> if user_called : <NEWLINE> <INDENT> print ( print_out ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return print_out <NEWLINE> <DEDENT> <DEDENT>
def _get_tracking_refs ( self , cr , uid , picking , context = None ) : <NEWLINE> <INDENT> tracking_refs = [ ] <NEWLINE> for pack in self . _get_packages_from_picking ( <NEWLINE> <INDENT> self , cr , uid , picking , context = context ) : <NEWLINE> if pack . parcel_tracking : <NEWLINE> tracking_refs . append ( pack . parcel_tracking ) <NEWLINE> <DEDENT> return tracking_refs <NEWLINE> <DEDENT>
def __setitem__ ( self , k , v ) : <NEWLINE> <INDENT> if ( isinstance ( v , dict ) and v [ <STRING> ] == <STRING> and <NEWLINE> <INDENT> self . host_filter in get_ip_addresses ( v [ <STRING> ] ) ) : <NEWLINE> v [ <STRING> ] = v [ <STRING> ] . format ( name = k , <NEWLINE> <INDENT> bind = self . host_filter , <NEWLINE> port = v [ <STRING> ] ) <NEWLINE> self . queue . put_nowait ( ( <STRING> , ( k , v ) ) ) <NEWLINE> self . active_or_queued . add ( k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def checkJobAdded ( self , jobId ) : <NEWLINE> <INDENT> t0 = self . stubDir + <STRING> % jobId <NEWLINE> print ( <STRING> % t0 ) <NEWLINE> if os . path . exists ( t0 ) : print <STRING> <NEWLINE> else : print <STRING> <NEWLINE> return os . path . exists ( t0 ) <NEWLINE> <DEDENT>
def track_list_to_string ( self , track_list ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> result = <STRING> <NEWLINE> if track_list : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> for track in track_list : <NEWLINE> result += track . name + <STRING> <NEWLINE> result = result [ : len ( result ) - 2 ] <NEWLINE> <DEDENT> return result + <STRING> <NEWLINE> <DEDENT>
s = <STRING> <NEWLINE> x = 0 <NEWLINE> for i in range ( 0 , len ( s ) : <NEWLINE> <INDENT> p = 1 <NEWLINE> for n in s [ i : i + 5 ] : <NEWLINE> <INDENT> p *= int ( n ) <NEWLINE> <DEDENT> if p > x : <NEWLINE> <INDENT> x = p <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
class JsGameBench ( multi_page_benchmark . MultiPageBenchmark ) : <NEWLINE> <INDENT> def MeasurePage ( self , _ , tab , results ) : <NEWLINE> <INDENT> tab . runtime . Execute ( <STRING> ) <NEWLINE> js_is_done = <STRING> <NEWLINE> def _IsDone ( ) : <NEWLINE> <INDENT> return bool ( tab . runtime . Evaluate ( js_is_done ) ) <NEWLINE> <DEDENT> util . WaitFor ( _IsDone , 1200 ) <NEWLINE> js_get_results = <STRING> <NEWLINE> result = int ( tab . runtime . Evaluate ( js_get_results ) <NEWLINE> results . Add ( <STRING> , <STRING> , result ) <NEWLINE> <DEDENT> <DEDENT>
import ConfigParser <NEWLINE> config = ConfigParser . ConfigParser ( ) <NEWLINE> config . read ( <STRING> ) <NEWLINE> top_k_results = int ( config . get ( <STRING> , <STRING> ) ) <NEWLINE> data_set_limit = int ( config . get ( <STRING> , <STRING> ) ) ) <NEWLINE> fast_search = int ( config . get ( <STRING> , <STRING> ) ) <NEWLINE>
def set_freq ( self , target_freq ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> r = self . u . tune ( 0 , self . subdev , target_freq ) <NEWLINE> if r : <NEWLINE> <INDENT> self . myform [ <STRING> ] . set_value ( target_freq ) <NEWLINE> if self . show_debug_info : <NEWLINE> <INDENT> self . myform [ <STRING> ] . set_value ( r . baseband_freq ) <NEWLINE> self . myform [ <STRING> ] . set_value ( r . dxc_freq ) <NEWLINE> if not self . options . waterfall and not self . options . oscilloscope : <NEWLINE> self . scope . win . set_baseband_freq ( target_freq ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>
def import_submodules ( module ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> submodules = { } <NEWLINE> for loader , name , ispkg in pkgutil . iter_modules ( module . __path__ , <NEWLINE> <INDENT> module . __name__ + <STRING> ) : <NEWLINE> try : <NEWLINE> submodule = import_module ( name ) <NEWLINE> except ImportError as e : <NEWLINE> logging . warning ( <STRING> % name ) <NEWLINE> logging . exception ( e ) <NEWLINE> else : <NEWLINE> parent , child = name . rsplit ( <STRING> , 1 ) <NEWLINE> submodules [ child ] = submodule <NEWLINE> <DEDENT> return submodules <NEWLINE> <DEDENT>
def wordsplit ( line ) : <NEWLINE> <INDENT> list = [ ] <NEWLINE> word = <STRING> <NEWLINE> for c in line : <NEWLINE> if c . isspace ( ) : <NEWLINE> <INDENT> if len ( word ) > 0 : <NEWLINE> <DEDENT> list . append ( word ) <NEWLINE> <INDENT> word = <STRING> <NEWLINE> else : <NEWLINE> word += c <NEWLINE> <DEDENT> if len ( word ) > 0 : <NEWLINE> list . append ( word ) <NEWLINE> return list <NEWLINE> <DEDENT>
( <STRING> , <NEWLINE> for n in names : <NEWLINE> <INDENT> if name == n [ : l ] : <NEWLINE> <INDENT> if base : print <STRING> % ( base , n ) , <NEWLINE> else : print <STRING> % n , <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def letMove ( ) : <NEWLINE> <INDENT> if mode == <STRING> : <NEWLINE> vImposed = [ 0 , - 1 , 0 ] <NEWLINE> if O . iter < 25 and O . iter > 14 : <NEWLINE> <INDENT> vImposed = [ 0 , 1 , 0 ] <NEWLINE> <DEDENT> if mode == <STRING> : <NEWLINE> vImposed = [ 1 , 0 , 0 ] <NEWLINE> upperSphere . state . vel = vImposed <NEWLINE> upperSphere . state . pos = upperSphere . state . pos + upperSphere . state . vel * O . dt <NEWLINE> <DEDENT>
def headers ( self ) : <NEWLINE> <INDENT> headers = DataTablesHeader ( <NEWLINE> <INDENT> DataTablesColumn ( <STRING> , span = 3 ) , <NEWLINE> DataTablesColumn ( <STRING> , span = 2 ) , <NEWLINE> DataTablesColumn ( <STRING> , span = 2 ) , <NEWLINE> DataTablesColumn ( <STRING> , span = 2 ) , <NEWLINE> DataTablesColumn ( <STRING> , span = 2 ) , <NEWLINE> DataTablesColumn ( <STRING> , span = 3 , sort_type = DTSortType . NUMERIC ) <NEWLINE> <DEDENT> ) <NEWLINE> headers . custom_sort = [ [ 1 , <STRING> ] <NEWLINE> return headers <NEWLINE> <DEDENT>
__author__ = <STRING> <NEWLINE> import csv <NEWLINE> import pprint <NEWLINE> import json <NEWLINE> import urllib2 <NEWLINE> import sys <NEWLINE> import pandas as pd <NEWLINE> <STRING> <NEWLINE> if sys . argv [ 1 ] == <STRING> : <NEWLINE> <INDENT> URL = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> URL = <STRING> <NEWLINE> <DEDENT> def createDataFrame ( URL ) <NEWLINE> <INDENT> response = json . loads ( urllib2 . urlopen ( URL ) . read ( ) ) <NEWLINE> df = pd . DataFrame ( response [ <STRING> ] ) <NEWLINE> <DEDENT>
def triangle_wave ( ) : <NEWLINE> <INDENT> scope = m3t . M3Scope2 ( xwidth = 100 , yrange = None ) <NEWLINE> des = [ ] <NEWLINE> cc = 1.0 <NEWLINE> scale = 5000 <NEWLINE> for i in range ( 10 ) : <NEWLINE> des . append ( cc ) <NEWLINE> cc = cc * - 1.0 <NEWLINE> print ( <STRING> ) <NEWLINE> raw_input ( ) <NEWLINE> for ii in range ( len ( des ) ) : <NEWLINE> print ( ii , <STRING> , des [ ii ] ) <NEWLINE> ramp_to_torque ( des [ ii ] * scale , scope ) <NEWLINE> <DEDENT>
def test_requires_non_coroutine ( self ) : <NEWLINE> <INDENT> with unittest . mock . patch ( <NEWLINE> <INDENT> <STRING> ) as iscoroutinefunction : <NEWLINE> iscoroutinefunction . return_value = True <NEWLINE> with self . assertRaisesRegex ( <NEWLINE> <INDENT> TypeError , <NEWLINE> <STRING> ) : <NEWLINE> <DEDENT> self . decorator ( unittest . mock . sentinel . cb ) <NEWLINE> <DEDENT> iscoroutinefunction . assert_called_with ( <NEWLINE> <INDENT> unittest . mock . sentinel . cb , <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
class FakeCiscoFCSanLookupService ( object ) : <NEWLINE> <INDENT> def get_device_mapping_from_network ( self , <NEWLINE> <INDENT> initiator_wwn_list , <NEWLINE> target_wwn_list ) : <NEWLINE> device_map = { } <NEWLINE> initiators = [ ] <NEWLINE> targets = [ ] <NEWLINE> for i in initiator_wwn_list : <NEWLINE> if ( i in _initiator_ns_map [ _fabric_wwn ] ) : <NEWLINE> initiators . append ( i ) <NEWLINE> for t in target_wwn_list : <NEWLINE> if ( t in _target_ns_map [ _fabric_wwn ] ) : <NEWLINE> targets . append ( t ) <NEWLINE> device_map [ _fabric_wwn ] = { <NEWLINE> <STRING> : initiators , <NEWLINE> <STRING> : targets } <NEWLINE> return device_map <NEWLINE> <DEDENT> <DEDENT>
( <STRING> % ( bname , lineno , <NEWLINE> <INDENT> linecache . getline ( filename , lineno ) ) , <NEWLINE> <DEDENT> <DEDENT> return self . localtrace <NEWLINE> <DEDENT>
def proposition_consistent ( formula , atom ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> ) <NEWLINE> if formula . is_proposition ( ) and ( <NEWLINE> <INDENT> formula . get_values ( ) in formula . get_proposition_rules ( ) . keys ( ) ) : <NEWLINE> no_consistent_propositions = formula . get_consistent_propositions ( ) <NEWLINE> for no_consistent_proposition in no_consistent_propositions : <NEWLINE> if is_in_atom ( no_consistent_proposition , atom ) : <NEWLINE> print ( <STRING> , no_consistent_proposition ) <NEWLINE> return False <NEWLINE> print ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
def createNoiseSpectrum ( numin = 700. , numax = 1800. , nchan = 100. , sigma = 0.01 , freq = False ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> len ( freq ) <NEWLINE> nu = freq <NEWLINE> <DEDENT> except TypeError : <NEWLINE> <INDENT> nu = createFrequency ( numin , numax , nchan ) <NEWLINE> <INDENT> sig = sigma * np . random . standard_normal ( nu . shape ) <NEWLINE> return nu , sig <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test ( ) : <NEWLINE> <INDENT> import doctest , sys <NEWLINE> <INDENT> sys . path . insert ( 1 , <STRING> ) <NEWLINE> sys . path . insert ( 1 , <STRING> ) <NEWLINE> <DEDENT> doctest . testmod ( sys . modules [ __name__ ] ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def tstamp ( task ) : <NEWLINE> <INDENT> return <STRING> . format ( <NEWLINE> <INDENT> escape ( str ( task . tstamp ) ) , escape ( naturaldate ( task . tstamp ) ) ) , <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def completeStage ( id ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> con = mdb . connect ( DB_SERVER , DB_USER , DB_PASSWORD , DB_NAME ) ; <NEWLINE> cur = con . cursor ( mdb . cursors . DictCursor ) <NEWLINE> cur . execute ( <STRING> + str ( id ) ) <NEWLINE> cur . close ( ) <NEWLINE> con . close ( ) <NEWLINE> <DEDENT> <DEDENT>
def _generate_metadata_args ( self , metadata ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> if metadata : <NEWLINE> <INDENT> for k , v in sorted ( metadata . iteritems ( ) , key = lambda ( k , _ ) : k ) : <NEWLINE> <INDENT> field = self . _get_metadata_field ( k ) <NEWLINE> param = ( field ) if v is None else ( <STRING> % ( field , v ) ) <NEWLINE> result += [ <STRING> , param ] <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <DEDENT>
def convlon ( coord ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if coord < 0 : <NEWLINE> return <STRING> + convcoord ( - coord ) <NEWLINE> else : <NEWLINE> return <STRING> + convcoord ( coord ) <NEWLINE> <DEDENT>
def next ( self ) : <NEWLINE> <INDENT> if self . index [ 1 ] >= self . n <NEWLINE> <INDENT> raise StopIteration <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if self . index [ 1 ] >= self . m : <NEWLINE> <INDENT> self . index [ 0 ] += 1 <NEWLINE> self . index [ 1 ] = 0 <NEWLINE> <DEDENT> return self . data [ self . index [ 0 ] , self . index [ 1 ] ] <NEWLINE> <DEDENT> <DEDENT>
def getDeviceModel ( ip ) : <NEWLINE> <INDENT> output = commands . getstatusoutput ( <STRING> % ( ip , ids . currentdevice [ <STRING> ] ) ) <NEWLINE> outputlist = output [ 1 ] . split ( <STRING> ) <NEWLINE> for line in outputlist : <NEWLINE> if <STRING> in line : <NEWLINE> <INDENT> modeldevice = parser . OutputToString ( line ) <NEWLINE> if len ( modeldevice ) > 5 : <NEWLINE> <INDENT> return modeldevice <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def fetch ( ) : <NEWLINE> <INDENT> with lcd ( os . path . join ( os . path . dirname ( os . path . dirname ( __file__ ) ) , <STRING> , <NEWLINE> <INDENT> <STRING> ) ) : <NEWLINE> with cd ( env . run_at ) : <NEWLINE> get ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class MyCheckBox : <NEWLINE> <INDENT> def __init__ ( self , <NEWLINE> <INDENT> PlaceWidget , <NEWLINE> PlaceLayout , <NEWLINE> StringToShow , <NEWLINE> LogicalToSet ) : <NEWLINE> self . CheckBox = QtGui . QCheckBox ( StringToShow , PlaceWidget ) <NEWLINE> PlaceLayout . addWidget ( self . CheckBox ) <NEWLINE> if LogicalToSet : <NEWLINE> self . CheckBox . setCheckState ( QtCore . Qt . Checked ) <NEWLINE> <DEDENT> def checkStateSet ( self ) : <NEWLINE> <INDENT> return ( self . CheckBox . checkStateSet ( ) ) <NEWLINE> <DEDENT> <DEDENT>
def test_raises_if_rank_is_not_integer_dynamic ( self ) : <NEWLINE> <INDENT> with self . test_session ( ) : <NEWLINE> <INDENT> tensor = tf . constant ( [ 1 , 2 ] , dtype = tf . float32 , name = <STRING> ) <NEWLINE> rank_tensor = tf . placeholder ( tf . float32 , name = <STRING> ) <NEWLINE> with self . assertRaisesRegexp ( TypeError , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> with tf . control_dependencies ( [ tf . assert_rank ( tensor , rank_tensor ) ] ) : <NEWLINE> tf . identity ( tensor ) . eval ( feed_dict = { rank_tensor : .5 } ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def print_hierarchy ( model , out = sys . stdout , show_ports = False , max_depth = - 1 , size = 20 ) : <NEWLINE> <INDENT> print ( <STRING> + string_size ( getattr ( model , <STRING> ) , 10 ) + <STRING> <NEWLINE> <INDENT> + string_size ( model . class_name , 10 ) , file = out ) <NEWLINE> <DEDENT> print_hierarchy_helper ( model , out , show_ports , <STRING> , 0 , max_depth , size <NEWLINE> <DEDENT>
class GrabFiles : <NEWLINE> <INDENT> def setdirectory ( self , value ) : self . data = value <NEWLINE> def display ( self ) : print self . data <NEWLINE> def searchdirectory ( self , search_term ) : <NEWLINE> <INDENT> files = getDirectoryFiles ( self . data , search_term ) <NEWLINE> if len ( files ) < 1 : print <STRING> <NEWLINE> return files <NEWLINE> <DEDENT> def returndirectory ( self ) : <NEWLINE> <INDENT> dir_list = getAllDirectoryFiles ( self . data ) <NEWLINE> return dir_list <NEWLINE> <DEDENT> <DEDENT>
def test_create_custom_variable ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> var = IneqSys . Variable ( <STRING> , lower = 5 , upper = 10 ) <NEWLINE> self . assertEquals ( var . lower , 5 ) <NEWLINE> self . assertEquals ( var . upper , 10 ) <NEWLINE> self . assertEquals ( var . upper , var . _candidate ) <NEWLINE> self . assertEquals ( var . _status , _VariableStatus . valid ) <NEWLINE> <DEDENT> <DEDENT>
def getAnotationOfString ( string_txt , suffix ) : <NEWLINE> <INDENT> anotationRegex = constructAnotationRegex ( suffix ) <NEWLINE> anotationString = <STRING> <NEWLINE> try : <NEWLINE> <INDENT> anotationMatch = re . search ( anotationRegex , unicode ( string_txt ) ) <NEWLINE> if anotationMatch : <NEWLINE> match = re . search ( AnotationRegexPrefix , anotationMatch . group ( 0 ) ) <NEWLINE> if match : <NEWLINE> <INDENT> anotationString = match . group ( 0 ) <NEWLINE> <DEDENT> <DEDENT> except Exception as e : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( e ) <NEWLINE> <DEDENT> return anotationString <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import sys <NEWLINE> import numpy as np <NEWLINE> import os <NEWLINE> from os . path import dirname <NEWLINE> import argparse <NEWLINE> ANTENNAFIELDDIR = dirname ( __file__ ) + <STRING> <NEWLINE> COMMENT_CHAR = <STRING> <NEWLINE> def _getAntennaFieldFile ( stationName , antenna_field_dir = ANTENNAFIELDDIR , <NEWLINE> <INDENT> AFfileNameType = 2 ) : <NEWLINE> if AFfileNameType == 2 : <NEWLINE> basename = stationName + <STRING> + <STRING> + <STRING> <NEWLINE> else : <NEWLINE> basename = <STRING> + stationName + <STRING> <NEWLINE> filepath = antenna_field_dir + <STRING> + basename <NEWLINE> return filepath <NEWLINE> <DEDENT>
( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>
def __add__ ( self , other ) : <NEWLINE> <INDENT> if self . rows != other . rows or self . cols != other . cols : <NEWLINE> <INDENT> raise ValueError , <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = Matrix . zero ( self . rows , self . cols ) <NEWLINE> for i in range ( self . rows ) : <NEWLINE> <INDENT> for j in range ( self . cols ) : <NEWLINE> <INDENT> res . value [ i ] [ j ] = self . value [ i ] [ j ] ^ other . value [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <DEDENT> <DEDENT>
def test_claim_bucket ( self ) : <NEWLINE> <INDENT> a = self . o . claim_bucket ( ) <NEWLINE> self . assertTrue ( self . o . exists ( a ) <NEWLINE> <DEDENT>
def rename ( self , src , dst ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . refresh_dircache ( dirname ( src ) , dirname ( dst ) ) <NEWLINE> self . ftp . rename ( _encode ( src ) , _encode ( dst ) ) <NEWLINE> <DEDENT> except error_perm , exception : <NEWLINE> <INDENT> code , message = str ( exception ) . split ( <STRING> , 1 ) <NEWLINE> if code == <STRING> : <NEWLINE> <INDENT> if not self . exists ( dirname ( dst ) ) : <NEWLINE> <INDENT> raise ParentDirectoryMissingError ( dst ) <NEWLINE> <DEDENT> <DEDENT> raise <NEWLINE> <DEDENT> except error_reply : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
import pygame <NEWLINE> pygame . joystick . init ( ) <NEWLINE> pygame . display . init ( ) <NEWLINE> j = pygame . joystick . Joystick ( 0 ) <NEWLINE> j . init ( ) <NEWLINE> if j . get_init ( ) == 1 : print <STRING> <NEWLINE> while 1 : <NEWLINE> <INDENT> for e in event . get ( ) : <NEWLINE> <INDENT> if e . type != QUIT : <NEWLINE> <INDENT> print ( <STRING> % ( event . event_name ( e . type ) , e . dict ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def write_duplicate_questions_validation_file ( self ) : <NEWLINE> <INDENT> with codecs . open ( self . VALIDATION_FILE , <STRING> , <NEWLINE> <INDENT> <STRING> ) as dupe_val_file : <NEWLINE> dupe_val_file . write ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> dupe_val_file . write ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> dupe_val_file . write ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def getresult ( self ) : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> print ( <STRING> % self . _basicurl ) <NEWLINE> <INDENT> print ( <STRING> % self . _stattime ) <NEWLINE> print ( <STRING> % self . _endtime ) <NEWLINE> print ( <STRING> % self . _basictime ) <NEWLINE> <DEDENT> print ( <STRING> % self . _senMAXurl ) <NEWLINE> print ( <STRING> % self . _sencodusetime ) <NEWLINE> print ( <STRING> % self . _totusetime ) <NEWLINE> print ( <STRING> % self . _toturl ) <NEWLINE> print ( <STRING> * 20 ) <NEWLINE> <DEDENT>
class parseThread ( Thread ) : <NEWLINE> <INDENT> def __init__ ( self , tip ) : <NEWLINE> self . testip = tip <NEWLINE> super ( parseThread , self ) . __init__ ( ) <NEWLINE> self . stoprequest = Event ( ) <NEWLINE> def run ( self ) : <NEWLINE> try : <NEWLINE> <INDENT> callParse ( self . testip ) <NEWLINE> <DEDENT> except Exception : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <DEDENT> def stahp ( self , timeout = None ) : <NEWLINE> global pParse <NEWLINE> pParse = 1 <NEWLINE> <DEDENT>
def load_module ( self , module ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> n_mod = self . __load_module_by_name ( module [ <STRING> ] ) <NEWLINE> n_mod [ <STRING> ] . start ( ) <NEWLINE> self . loaded_modules . append ( n_mod ) <NEWLINE> return True <NEWLINE> <DEDENT> except Exception , ex : <NEWLINE> <INDENT> syslog . syslog ( syslog . LOG_ERR , <STRING> + module [ <STRING> ] + <STRING> % str ( ex ) ) <NEWLINE> return False <NEWLINE> <DEDENT> <DEDENT>
def makeEntity ( ( name , num , description ) ) : <NEWLINE> <INDENT> e = Entity ( name , num , description ) <NEWLINE> __by_number [ types . IntType ( num ) ] = e <NEWLINE> globals ( ) [ name ] = e <NEWLINE> <DEDENT>
def request ( self , method , url , settings = None ) : <NEWLINE> <INDENT> if settings is None : <NEWLINE> <INDENT> settings = { } <NEWLINE> <DEDENT> if <STRING> not in settings : <NEWLINE> <INDENT> settings [ <STRING> ] = conf . REQUEST_TIMEOUT <NEWLINE> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> response = self . _Session . request ( method , url , ** settings ) <NEWLINE> return response <NEWLINE> <DEDENT> except requests . Timeout : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>
def schaffer ( individual ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return sum ( ( x ** 2 + x1 ** 2 ) ** 0.25 * ( ( sin ( 50 * ( x ** 2 + x1 ** 2 ) ** 0.1 ) ) ** 2 + 1.0 ) <NEWLINE> <DEDENT>
def start ( self , interval , now = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> assert not self . running , ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> if interval < 0 : <NEWLINE> <INDENT> raise ValueError , <STRING> <NEWLINE> <DEDENT> self . running = True <NEWLINE> d = self . deferred = defer . Deferred ( ) <NEWLINE> self . starttime = self . _seconds ( ) <NEWLINE> self . count = 0 <NEWLINE> self . interval = interval <NEWLINE> if now : <NEWLINE> <INDENT> self ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . _reschedule ( ) <NEWLINE> <DEDENT> return d <NEWLINE> <DEDENT>
def __init__ ( self ) : <NEWLINE> <INDENT> self . registers = { } <NEWLINE> for register in registers <NEWLINE> <INDENT> self . registers [ register ] = [ ] <NEWLINE> <DEDENT> self . addresses = { } <NEWLINE> <DEDENT>
def format_element ( bfo , param1 , param2 = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> unloadable element <NEWLINE> return <STRING> <NEWLINE> <DEDENT>
def map_action ( entry name ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> bact = entry . bact <NEWLINE> bactsig = entry . bactsig <NEWLINE> <DEDENT> except AttributeError : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> return <STRING> % ( bactsig , bact ) <NEWLINE> <DEDENT>
self . description = <STRING> <NEWLINE> p1 = pmpkg ( <STRING> ) <NEWLINE> p1 . files = [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ] <NEWLINE> <DEDENT> p2 = pmpkg ( <STRING> ) <NEWLINE> p2 . files = [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ] <NEWLINE> <DEDENT> for p in p1 , p2 : <NEWLINE> <INDENT> self . addpkg ( p ) <NEWLINE> <DEDENT> self . args = <STRING> % <STRING> . join ( [ p . filename ( ) for p in p1 , p2 ] ) <NEWLINE> self . addrule ( <STRING> ) <NEWLINE> self . addrule ( <STRING> ) <NEWLINE> self . addrule ( <STRING> ) <NEWLINE>
def create_mashup_dict ( image_meta ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def get_items ( ) : <NEWLINE> <INDENT> for key , value in six . iteritems ( image_meta ) : <NEWLINE> <INDENT> if isinstance ( value , dict ) : <NEWLINE> <INDENT> for subkey , subvalue in six . iteritems ( <NEWLINE> <INDENT> create_mashup_dict ( value ) ) : <NEWLINE> if subkey not in image_meta : <NEWLINE> yield subkey , subvalue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> yield key , value <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dict ( get_items ( ) ) <NEWLINE> <DEDENT>
def detect_encoding ( ) : <NEWLINE> <INDENT> import locale <NEWLINE> try : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> locale . setlocale ( locale . LC_ALL , <STRING> ) <NEWLINE> <DEDENT> except locale . Error : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> return locale . getlocale ( ) [ 1 ] or <STRING> <NEWLINE> <DEDENT> except ValueError , e : <NEWLINE> <INDENT> if e . args and e . args [ 0 ] . startswith ( <STRING> ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def load_tiles ( tiles ) : <NEWLINE> <INDENT> data = [ ] <NEWLINE> for t in tiles : <NEWLINE> t = t . replace ( <STRING> , <STRING> ) <NEWLINE> <INDENT> f = hdf . File ( data_dir + <STRING> + t + <STRING> , <STRING> ) <NEWLINE> dset = f [ f . keys ( ) [ 0 ] ] <NEWLINE> data . append ( dset ) <NEWLINE> <DEDENT> return data <NEWLINE> <DEDENT>
def teardown_module ( module ) : <NEWLINE> <INDENT> try : <NEWLINE> except AttributeError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> try : <NEWLINE> except AttributeError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
def print_user ( self , i , user ) : <NEWLINE> <INDENT> checked = <STRING> if user . name in self . sel_users else <STRING> <NEWLINE> print ( <STRING> % ( self . BOLD , i , self . NC , checked , ) <NEWLINE> <INDENT> self . BOLD , user . name , self . NC , <NEWLINE> user . realname , user . email ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> decoder = Decoder ( KEYCONF ) <NEWLINE> <INDENT> decoder . start_utt ( ) <NEWLINE> while True : <NEWLINE> <INDENT> l , buf = INPUT . read ( ) <NEWLINE> if l : <NEWLINE> <INDENT> decoder . process_raw ( buf , False , False ) <NEWLINE> <DEDENT> if decoder . hyp ( ) != None : <NEWLINE> <INDENT> decoder . end_utt ( ) <NEWLINE> result = decode_audio ( ) <NEWLINE> switch ( result ) <NEWLINE> decoder . start_utt ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def onMountpointAdded ( mountpoint ) : <NEWLINE> <INDENT> global searchPaths <NEWLINE> try : <NEWLINE> <INDENT> path = os . path . join ( mountpoint , <STRING> ) + <STRING> <NEWLINE> if os . path . isdir ( path ) and path not in searchPaths : <NEWLINE> <INDENT> for fn in os . listdir ( path ) : <NEWLINE> <INDENT> if fn . endswith ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> , path ) <NEWLINE> searchPaths . append ( path ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> except Exception , ex : <NEWLINE> <INDENT> print ( <STRING> % mountpoint , ex ) <NEWLINE> <DEDENT> <DEDENT>
def send_unsent ( self ) : <NEWLINE> <INDENT> sent_count = 0 <NEWLINE> for unsent in Sendable . objects . filter ( <NEWLINE> <INDENT> sent_date__isnull = True ) . filter ( send_failed = False ) : <NEWLINE> if unsent . send_email ( ) : <NEWLINE> sent_count += 1 <NEWLINE> <DEDENT> return sent_count <NEWLINE> <DEDENT>
def simplify_section_result ( section_result ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> section_yielded_result = section_result [ 0 ] <NEWLINE> results_for_section = [ ] <NEWLINE> for value in chain ( section_result [ 1 ] . values ( ) , <NEWLINE> <INDENT> section_result [ 2 ] . values ( ) ) : <NEWLINE> if value is None : <NEWLINE> continue <NEWLINE> for result in value : <NEWLINE> results_for_section . append ( result ) <NEWLINE> <DEDENT> section_yielded_unfixed_results = len ( results_for_section ) > 0 <NEWLINE> return ( section_yielded_result , <NEWLINE> <INDENT> section_yielded_unfixed_results , <NEWLINE> results_for_section ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , parent ) : <NEWLINE> <INDENT> MainGui . MipFrame . __init__ ( self , parent ) <NEWLINE> <INDENT> self . m_textCtrlSmoothUrl . SetValue ( <STRING> ) <NEWLINE> <DEDENT> self . mipproxy = MipProxy ( frame = self , function = self . OnMipProxy ) <NEWLINE> <INDENT> self . m_textCtrlProxyUrl . SetValue ( <STRING> ) <NEWLINE> self . m_textCtrlMipPort . SetValue ( str ( MipProxy . PORT ) ) <NEWLINE> self . m_checkBoxOnlyLocalConnections . SetValue ( True ) <NEWLINE> self . m_checkBoxBrowserCaching . SetValue ( True ) <NEWLINE> <DEDENT> <DEDENT>
def stat ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> retval = self . _shortcmd ( <STRING> ) <NEWLINE> rets = retval . split ( ) <NEWLINE> if self . _debugging : print <STRING> , repr ( rets ) <NEWLINE> numMessages = int ( rets [ 1 ] ) <NEWLINE> sizeMessages = int ( rets [ 2 ] ) <NEWLINE> return ( numMessages , sizeMessages ) <NEWLINE> <DEDENT>
def evaluate ( line , time , backrefs ) : <NEWLINE> <INDENT> code = backrefs [ 1 ] . strip ( ) <NEWLINE> print ( code ) <NEWLINE> if len ( code ) == 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> exec code <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
def _format_mem ( mem ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return <STRING> . format ( <NEWLINE> <INDENT> mem = <STRING> . join ( <STRING> . format ( i = i v = v ) <NEWLINE> <INDENT> for i , v in enumerate ( mem ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import unittest <NEWLINE> from StringIO import StringIO <NEWLINE> import os , random , tempfile <NEWLINE> from franklin . statistics import ( CachedArray , histogram , create_distribution , <NEWLINE> <INDENT> draw_boxplot , draw_histogram <NEWLINE> draw_stacked_columns , IntsStats ) <NEWLINE> <DEDENT> import franklin <NEWLINE> TEST_DATA_DIR = os . path . join ( os . path . split ( franklin . __path__ [ 0 ] ) [ 0 ] , <STRING> ) <NEWLINE>
def get_spamhaus_active_entries ( ) <NEWLINE> <INDENT> <STRING> <NEWLINE> return _retrieve_entries ( True ) <NEWLINE> <DEDENT>
def create_firewall ( self , apply_list , firewall ) : <NEWLINE> <INDENT> LOG . debug ( _ ( <STRING> ) , <NEWLINE> <INDENT> { <STRING> : firewall [ <STRING> ] } ) <NEWLINE> return self . update_firewall ( apply_list , firewall ) <NEWLINE> <DEDENT> <DEDENT>
def set_flag ( self , pointer , flag_number , value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if CHECK_ALLOCATED and not self . _bf . get_flag ( pointer , ALLOCATED ) : <NEWLINE> <INDENT> raise StorageAllocatorException ( <STRING> ) <NEWLINE> <DEDENT> if flag_number < RESERVED_FLAGS : <NEWLINE> <INDENT> raise StorageAllocatorException ( <NEWLINE> <INDENT> <STRING> . format ( flag_number ) <NEWLINE> <DEDENT> <DEDENT> self . _bf . set_flag ( pointer , flag_number , value ) <NEWLINE> <DEDENT>
def test_wrappers ( self ) : <NEWLINE> <INDENT> self . o . ind = 4 <NEWLINE> self . n . ind = 5 <NEWLINE> self . assertEqual ( 6 . __index__ ( ) , 6 ) <NEWLINE> self . assertEqual ( - 7 . __index__ ( ) , - 7 ) <NEWLINE> self . assertEqual ( self . o . __index__ ( ) , 4 ) <NEWLINE> self . assertEqual ( self . n . __index__ ( ) , 5 ) <NEWLINE> self . assertEqual ( True . __index__ ( ) , 1 ) <NEWLINE> self . assertEqual ( False . __index__ ( ) , 0 ) <NEWLINE> <DEDENT>
def lowerhorizontal ( self , direction = 0 ) : <NEWLINE> <INDENT> self . power = 0.4 <NEWLINE> dy = <STRING> <NEWLINE> if direction == 0 : <NEWLINE> <INDENT> dx = <STRING> <NEWLINE> <INDENT> self . ll ( ) <NEWLINE> else : <NEWLINE> dx = <STRING> <NEWLINE> self . lr ( ) <NEWLINE> self . laser ( dx , dy ) <NEWLINE> self . command = <STRING> <NEWLINE> if direction == 0 : <NEWLINE> dx = <STRING> <NEWLINE> self . lr ( ) <NEWLINE> else : <NEWLINE> dx = <STRING> <NEWLINE> self . ll ( ) <NEWLINE> self . laser ( dx , dy ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class Chip_PIC18F2321dip28 ( microchip8_18f2221family ) : <NEWLINE> <INDENT> hasEEPROM = True <NEWLINE> <INDENT> writeBufferSize = 8 <NEWLINE> eraseBufferSize = 64 <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> microchip8_18f2221family . __init__ ( self , <NEWLINE> <DEDENT> chipPackage = <STRING> , <NEWLINE> chipPinVCC = 20 , <NEWLINE> chipPinsVPP = 1 , <NEWLINE> chipPinGND = 19 , <NEWLINE> signature = <STRING> , <NEWLINE> flashPageSize = 0x2000 , <NEWLINE> flashPages = 1 , <NEWLINE> eepromPageSize = 0x100 , <NEWLINE> eepromPages = 1 , <NEWLINE> fuseBytes = 14 <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT>
def promote_read_replica ( self , instance_name , ** params ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> result = self . connection . promote_read_replica ( instance_name , ** params ) [ <STRING> ] [ <STRING> ] [ <STRING> ] <NEWLINE> return RDS2DBInstance ( result ) <NEWLINE> <DEDENT> except boto . exception . BotoServerError , e : <NEWLINE> <INDENT> raise RDSException ( e ) <NEWLINE> <DEDENT> <DEDENT>
def page ( self ) : <NEWLINE> <INDENT> warnings . warn ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> DontUsePageAttributeWarning ) <NEWLINE> <DEDENT> return self . placeholder . page if self . placeholder_id else None <NEWLINE> <DEDENT>
def setvalue ( self , text ) : <NEWLINE> <INDENT> list = string . split ( text , <STRING> ) <NEWLINE> if len ( list ) != 3 : <NEWLINE> raise ValueError , <STRING> + text <NEWLINE> self . _hour = string . atoi ( list [ 0 ] ) <NEWLINE> self . _minute = string . atoi ( list [ 1 ] ) <NEWLINE> self . _second = string . atoi ( list [ 2 ] ) <NEWLINE> self . _setHMS ( ) <NEWLINE> <DEDENT>
def Intersect_Grid_Square ( gpos , ( a , b ) ) : <NEWLINE> <INDENT> ( x , y ) = gpos <NEWLINE> x -= 0.5 <NEWLINE> y -= 0.5 <NEWLINE> for ( c , d ) in [ ( ( x , y ) , ( x + 1 , y + 1 ) ) , ( ( x + 1 , y ) , ( x , y + 1 ) ) ] : <NEWLINE> <INDENT> if ( intersect . Intersect ( ( a , b ) , ( c , d ) ) != None ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>
categories = [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ] <NEWLINE> <DEDENT> microcode = <STRING> <NEWLINE> for category in categories : <NEWLINE> <INDENT> exec <STRING> % category <NEWLINE> microcode += cat . microcode <NEWLINE> <DEDENT>
def testSuccessfulUnaryRequestUnaryResponse ( self ) : <NEWLINE> <INDENT> for ( group , method ) , test_messages_sequence in ( <NEWLINE> <INDENT> self . _digest . unary_unary_messages_sequences . iteritems ( ) ) : <NEWLINE> for test_messages in test_messages_sequence : <NEWLINE> request = test_messages . request ( ) <NEWLINE> response , call = self . _invoker . blocking ( group , method ) ( <NEWLINE> <INDENT> request , test_constants . LONG_TIMEOUT , with_call = True ) <NEWLINE> <DEDENT> test_messages . verify ( request , response , self ) <NEWLINE> <DEDENT> <DEDENT>
( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>
def update ( climate_data , sched_data ) : <NEWLINE> <INDENT> counter = 0 <NEWLINE> for line in climate_data : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> if ( counter < 8761 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> sys . stdout . write ( climate_data [ 0 ] ) <NEWLINE> for i in range ( 1 , counter ) : <NEWLINE> if ( float ( sched_data [ i - 1 ] ) > 0.0 ) : <NEWLINE> <INDENT> sys . stdout . write ( climate_data [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
def assert_web_ui_redaction ( self , query_id , unredacted_value , redacted_value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> impala_service = self . create_impala_service ( ) <NEWLINE> for page in ( <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> ) : <NEWLINE> for response_format in ( <STRING> , <STRING> ) : <NEWLINE> url = page + <STRING> + query_id + <STRING> + response_format <NEWLINE> results = self . grep_file ( impala_service . open_debug_webpage ( url ) , unredacted_value ) <NEWLINE> assert not results , <STRING> % ( url , unredacted_value ) <NEWLINE> <DEDENT> self . assert_web_ui_contains ( query_id , redacted_value ) <NEWLINE> <DEDENT>
def test_empty_path_hooks ( self ) : <NEWLINE> <INDENT> path_entry = <STRING> <NEWLINE> with util . import_state ( path_importer_cache = { } , path_hooks = [ ] , <NEWLINE> <INDENT> path = [ path_entry ] ) : <NEWLINE> with warnings . catch_warnings ( record = True ) as w : <NEWLINE> warnings . simplefilter ( <STRING> ) <NEWLINE> self . assertIsNone ( self . machinery . PathFinder . find_module ( <STRING> ) ) <NEWLINE> self . assertIsNone ( sys . path_importer_cache [ path_entry ] ) <NEWLINE> self . assertEqual ( len ( w ) , 1 ) <NEWLINE> self . assertTrue ( issubclass ( w [ - 1 ] . category , ImportWarning ) ) <NEWLINE> <DEDENT> <DEDENT>
class Ui_DialogAskDelete ( object ) : <NEWLINE> <INDENT> def setupUi ( self , DialogAskDelete ) : <NEWLINE> <INDENT> DialogAskDelete . setObjectName ( <STRING> ) <NEWLINE> DialogAskDelete . resize ( 400 , 108 ) <NEWLINE> icon = QtGui . QIcon ( ) <NEWLINE> icon . addPixmap ( QtGui . QPixmap ( <STRING> ) , QtGui . QIcon . Normal , QtGui . QIcon . Off ) <NEWLINE> DialogAskDelete . setWindowIcon ( icon ) <NEWLINE> DialogAskDelete . setStyleSheet ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
def getAnswer ( self , key ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> return self . db [ <STRING> ] . find ( { <STRING> : key } ) if key is not None else self . db [ <STRING> ] . find ( ) <NEWLINE> <DEDENT> <DEDENT>
class Error ( Exception ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , msg ) : <NEWLINE> <INDENT> self . msg = msg <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> print ( <STRING> , self . msg ) <NEWLINE> <DEDENT>
def get_share_code_json ( share_code ) : <NEWLINE> <INDENT> assert re . match ( <STRING> , share_code ) <NEWLINE> url = <STRING> + share_code <NEWLINE> try : <NEWLINE> <INDENT> d = urllib2 . urlopen ( url ) <NEWLINE> <DEDENT> except urllib2 . HTTPError , e : <NEWLINE> <INDENT> if e . code == 404 : <NEWLINE> <INDENT> print ( <STRING> . format ( u = url ) ) <NEWLINE> raise <NEWLINE> <DEDENT> <DEDENT> j = d . read ( ) <NEWLINE> d . close ( ) <NEWLINE> return j <NEWLINE> <DEDENT>
def checkCourse ( Run , Org , Number ) : <NEWLINE> <INDENT> if len ( Run + Org + Number ) > 64 : <NEWLINE> return <STRING> <NEWLINE> else : <NEWLINE> return Run + Org + Number <NEWLINE> <DEDENT>
def set_ssl_validation ( self , options ) : <NEWLINE> <INDENT> if self . _config . get ( <STRING> , False ) : <NEWLINE> <INDENT> options [ <STRING> ] = False <NEWLINE> <DEDENT> elif Platform . is_windows ( ) : <NEWLINE> <INDENT> options [ <STRING> ] = os . path . realpath ( os . path . join ( <NEWLINE> <INDENT> os . path . dirname ( os . path . realpath ( __file__ ) , <NEWLINE> os . pardir , os . pardir , <NEWLINE> <STRING> <NEWLINE> <DEDENT> ) ) <NEWLINE> <DEDENT> <DEDENT>
def zoom ( self , scale , ( mx , my ) ) : <NEWLINE> <INDENT> worldPos = self . unprojectAtHeight ( self . width ( ) / 2 , self . height ( ) / 2 , 0 ) <NEWLINE> if scale != self . scale : <NEWLINE> <INDENT> self . scale = scale <NEWLINE> newWorldPos = self . unprojectAtHeight ( self . width ( ) / 2 , self . height ( ) / 2 , 0 ) <NEWLINE> delta = newWorldPos - worldPos <NEWLINE> self . centerPoint = self . centerPoint - delta <NEWLINE> <DEDENT> <DEDENT>
def check_preconditions ( cls ) : <NEWLINE> <INDENT> super ( TestNetworkAdvancedServerOps , cls ) . check_preconditions ( ) <NEWLINE> if not ( CONF . network . tenant_networks_reachable <NEWLINE> <INDENT> or CONF . network . public_network_id ) : <NEWLINE> msg = ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> cls . enabled = False <NEWLINE> raise cls . skipException ( msg ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def whichlevel ( n ) : <NEWLINE> <INDENT> for i in range ( len ( mlevel ) ) : <NEWLINE> <INDENT> if mlevel [ i ] <= n <= mlevel [ i + 1 ] : <NEWLINE> return i + 1 <NEWLINE> <DEDENT> <DEDENT>
( <STRING> % ( mean , sigma , <NEWLINE> <INDENT> numpy . mean ( rmsd_increments ) , numpy . std ( rmsd_increments ) , <NEWLINE> acc_mean_and_avg [ 0 ] , acc_mean_and_avg [ 1 ] ) , v1 , v2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def is_running ( service ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with settings ( hide ( <STRING> , <STRING> , <STRING> , <STRING> ) , <NEWLINE> <INDENT> warn_only = True ) : <NEWLINE> if using_systemd ( ) : <NEWLINE> return systemd . is_running ( service ) <NEWLINE> else : <NEWLINE> if distrib_family ( ) != <STRING> : <NEWLINE> test_upstart = run_as_root ( <STRING> % <NEWLINE> <INDENT> service ) <NEWLINE> status = _service ( service , <STRING> ) <NEWLINE> if test_upstart . succeeded : <NEWLINE> return <STRING> in status <NEWLINE> else : <NEWLINE> return status . succeeded <NEWLINE> else : <NEWLINE> status = _service ( service , <STRING> ) <NEWLINE> return <STRING> in status <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def dgettext ( domain , message ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> t = translation ( domain , _localedirs . get ( domain , None ) <NEWLINE> <INDENT> codeset = _localecodesets . get ( domain ) ) <NEWLINE> <DEDENT> <DEDENT> except IOError : <NEWLINE> <INDENT> return message <NEWLINE> <DEDENT> return t . gettext ( message ) <NEWLINE> <DEDENT>
def line_format ( ( filename , lineno , content ) ) : <NEWLINE> <INDENT> global current_file , current_line <NEWLINE> if current_file != filename or current_line + 10 < lineno : <NEWLINE> <INDENT> info = <STRING> + str ( lineno ) + <STRING> + relpath ( filename ) + <STRING> <NEWLINE> current_file = filename <NEWLINE> current_line = lineno <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> info = <STRING> <NEWLINE> <DEDENT> newlines = <STRING> <NEWLINE> while current_line < lineno : <NEWLINE> <INDENT> newlines += <STRING> <NEWLINE> current_line += 1 <NEWLINE> <DEDENT> return info + newlines + content + <STRING> <NEWLINE> <DEDENT>
def _delete_floating_ip ( self , server , fip ) : <NEWLINE> <INDENT> with logging . ExceptionLogger ( <NEWLINE> <INDENT> LOG , _ ( <STRING> ) % fip [ <STRING> ] ) : <NEWLINE> if self . check_ip_address ( fip [ <STRING> ] ) ( server ) : <NEWLINE> self . _dissociate_floating_ip ( server , fip [ <STRING> ] ) <NEWLINE> network_wrapper . wrap ( self . clients ) . delete_floating_ip ( fip [ <STRING> ] , <NEWLINE> <INDENT> wait = True ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def create_topology ( controllers , options ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> exec <STRING> % options . topology <NEWLINE> topology = eval ( <STRING> % options . topology ) <NEWLINE> return topology <NEWLINE> <DEDENT>
def __init__ ( self , x , y , ( confDict , key ) ) : <NEWLINE> <INDENT> Positionable . __init__ ( self , x , y ) <NEWLINE> self . confDict = confDict <NEWLINE> self . key = key <NEWLINE> self . leds = [ LED ( 0 , ( 1 - i ) * Positionable . scaleFactor * LED . ledLedSpacing , LED . blue ) for i in range ( LedLine . nbLeds ) ] <NEWLINE> <DEDENT>
def doSetTilt ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> self . proxy . setTilt ( self . ui . sbTilt . value ( ) ) <NEWLINE> self . ui . lcdTilt . display ( self . ui . sbTilt . value ( ) ) <NEWLINE> except Ice . Exception : <NEWLINE> traceback . print_exc ( ) <NEWLINE> <DEDENT>
class LocalDeleteFolder ( BaseOperation ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def _run ( self ) : <NEWLINE> <INDENT> shutil . rmtree ( str ( self . local ) <NEWLINE> DatabaseDeleteFolder ( self . _context ) . run ( ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from psycopg2 import connect <NEWLINE> from psycopg2 . extras import RealDictCursor <NEWLINE> if len ( sys . argv ) < 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> connection = connect ( database = <STRING> , cursor_factory = RealDictCursor ) <NEWLINE> cursor = connection . cursor ( ) <NEWLINE> cursor . execute ( <STRING> , ( sys . argv [ 1 : ] , ) ) <NEWLINE> cursor . execute ( <STRING> , ( sys . argv [ 1 : ] , ) <NEWLINE> connection . commit ( ) <NEWLINE>
def init ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> init_string = <STRING> <NEWLINE> init_downld = <STRING> <NEWLINE> init_parsef = <STRING> <NEWLINE> print ( colored ( init_string , <STRING> ) ) <NEWLINE> print ( colored ( init_downld , <STRING> ) ) <NEWLINE> print ( colored ( init_parsef , <STRING> ) ) <NEWLINE> count = 0 <NEWLINE> with open ( <STRING> , <STRING> ) as f : <NEWLINE> for line in f : <NEWLINE> <INDENT> if count < 1 : <NEWLINE> <DEDENT> url_timings = line <NEWLINE> <INDENT> url_tasks = line <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> download_files ( url_timings , list_timings ) <NEWLINE> download_files ( url_tasks , list_tasks ) <NEWLINE> return <NEWLINE> <DEDENT>
def test_split_version ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with patch ( <STRING> , <NEWLINE> <INDENT> _SplitClientConnection ) : <NEWLINE> with ( yield from self . connect ( ) ) as conn : <NEWLINE> pass <NEWLINE> yield from conn . wait_closed ( ) <NEWLINE> <DEDENT> <DEDENT>
class MetadataSystem ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> self . GetSystemID = None <NEWLINE> self . GetSystemDescription = None <NEWLINE> self . GetComments = None <NEWLINE> self . GetTimeZoneOffset = None <NEWLINE> self . GetMetadataID = None <NEWLINE> self . GetResourceVersion = None <NEWLINE> self . GetResourceDate = None <NEWLINE> self . GetForeignKeyVersion = None <NEWLINE> self . GetForeignKeyDate = None <NEWLINE> self . GetFilterVersion = None <NEWLINE> self . GetFilterDate = None <NEWLINE> <DEDENT>
def setContentType ( request , response ) : <NEWLINE> <INDENT> if request [ <STRING> ] == <STRING> : <NEWLINE> response . setContentType ( <STRING> ) <NEWLINE> elif request [ <STRING> ] == <STRING> : <NEWLINE> response . setContentType ( <STRING> ) <NEWLINE> else : <NEWLINE> response . setContentType ( <STRING> ) <NEWLINE> <DEDENT>
def TargetProgram ( env , target , source , install_dir = None ) : <NEWLINE> <INDENT> if env [ <STRING> ] != <STRING> : <NEWLINE> env . Program ( target , source ) <NEWLINE> env . TargetInstall ( target , install_dir ) <NEWLINE> <DEDENT>
def configureSubApplications ( configProperties ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> internalApps = configProperties . getProperty ( <STRING> ) <NEWLINE> if not internalApps is None : <NEWLINE> <DEDENT> log . info ( <STRING> ) <NEWLINE> internalAppsList = internalApps . split ( <STRING> ) <NEWLINE> for internalApp in internalAppsList : <NEWLINE> <INDENT> internalAppName = configProperties . getProperty ( <STRING> + internalApp + <STRING> ) <NEWLINE> internalAppSubdeployments = configProperties . getProperty ( <STRING> + internalApp + <STRING> ) <NEWLINE> if not internalAppSubdeployments is None : <NEWLINE> <INDENT> __configureInternalAppSubdeployments ( internalApp , internalAppName , internalAppSubdeployments , configProperties ) <NEWLINE> <DEDENT> <DEDENT> except Exception , error : <NEWLINE> <INDENT> log . error ( str ( error ) ) <NEWLINE> <DEDENT> <DEDENT>
def login ( self , environ , req , username = None , password = None , ** kw ) : <NEWLINE> <INDENT> if self . _auth . login ( environ , username , password ) <NEWLINE> <INDENT> return self . register ( environ , REG_KEY + <STRING> + <STRING> , username ) <NEWLINE> <DEDENT> raise HTTPUnauthorized ( <STRING> ) <NEWLINE> <DEDENT>
def _resolve_name ( self , import_setting ) : <NEWLINE> <INDENT> name = import_setting . name <NEWLINE> try : <NEWLINE> <INDENT> name = self . variables . replace_string ( name ) <NEWLINE> <DEDENT> except DataError , err : <NEWLINE> <INDENT> self . _raise_replacing_vars_failed ( import_setting , err ) <NEWLINE> <DEDENT> return self . _get_path ( name , import_setting . directory , import_setting . type ) <NEWLINE> <DEDENT>
def actor_after_save ( sender , instance , created , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if created : <NEWLINE> pass <NEWLINE> <DEDENT>
def stop_instance ( self , instance_id ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . _con . stop_instances ( instance_id ) <NEWLINE> return True <NEWLINE> <DEDENT> except boto . exception . EC2ResponseError , e : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT>
def add_adjunto ( self , boton ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> utils . ui . dialogo_adjuntar ( <STRING> , <NEWLINE> <INDENT> self . resultado , <NEWLINE> , <NEWLINE> self . wids [ <STRING> ] ) <NEWLINE> <DEDENT> self . rellenar_adjuntos ( ) <NEWLINE> <DEDENT>
def check_year ( year ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if len ( year ) == 4 : <NEWLINE> <INDENT> return datetime . datetime . strptime ( year , <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return datetime . datetime . strptime ( year , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except ValueError : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return datetime . datetime . strptime ( year , <STRING> ) ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return year . is_digit ( ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def testTarifaHorariodif ( self ) : <NEWLINE> <INDENT> precios = Tarifa ( 1 , 2 ) <NEWLINE> tiempoDeTrabajo = [ datetime ( 2016 , 4 , 22 , 23 , 0 , 0 ) , datetime ( 2016 , 4 , 23 , 0 , 10 , 0 ) ] <NEWLINE> pago = calcularPrecio ( precios , tiempoDeTrabajo ) <NEWLINE> assert ( ( pago == 5.0 , <STRING> ) <NEWLINE> <DEDENT>
def setBackground ( self , imagesrc , * largs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> self . gauge . source = imagesrc <NEWLINE> <DEDENT> <DEDENT>
def info ( title ) : <NEWLINE> <INDENT> logger . debug ( title ) <NEWLINE> logger . debug ( <STRING> ) <NEWLINE> if hasattr ( os , <STRING> ) : <NEWLINE> <INDENT> logger . debug ( <STRING> , os . getppid ( ) ) <NEWLINE> <DEDENT> logger . debug ( <STRING> , os . getpid ( ) ) ) <NEWLINE> <DEDENT>
def _verify_signature_if_needed ( self , checksum ) : <NEWLINE> <INDENT> if ( signature_utils . should_verify_signature ( <NEWLINE> <INDENT> self . image . extra_properties ) ) : <NEWLINE> result = signature_utils . verify_signature ( <NEWLINE> self . context , checksum , self . image . extra_properties ) <NEWLINE> if result : <NEWLINE> LOG . info ( _LI ( <STRING> ) , <NEWLINE> <INDENT> self . image . image_id ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def GetMemoryModules ( client_id , token ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> installer_urns = [ ] <NEWLINE> for aff4_path in config_lib . CONFIG . Get ( <NEWLINE> <INDENT> <STRING> , context = GetClientContext ( client_id , token ) ) : <NEWLINE> logging . debug ( <STRING> , <NEWLINE> <INDENT> aff4_path , client_id ) <NEWLINE> if GetDriverFromURN ( aff4_path , token ) : <NEWLINE> <DEDENT> logging . debug ( <STRING> , aff4_path ) <NEWLINE> installer_urns . append ( aff4_path ) <NEWLINE> else : <NEWLINE> logging . debug ( <STRING> , aff4_path ) <NEWLINE> <DEDENT> if not installer_urns : <NEWLINE> <INDENT> raise IOError ( <STRING> ) <NEWLINE> <DEDENT> return installer_urns <NEWLINE> <DEDENT>
def get_userkindargrepr ( self , kind ) : <NEWLINE> <INDENT> if kind . fam is self . d . family : <NEWLINE> if kind . arg is self . mod . UniSet . Nothing : <NEWLINE> d = <STRING> <NEWLINE> else : <NEWLINE> d = self . d . ownerclassifier . get_userkindargrepr ( kind . arg ) <NEWLINE> return <STRING> % d <NEWLINE> else : <NEWLINE> return kind . fam . classifier . get_userkindargrepr ( kind ) <NEWLINE> <DEDENT>
def test_main ( verbose = None ) : <NEWLINE> <INDENT> import sys <NEWLINE> from test import test_support <NEWLINE> test_classes = ( TestTranforms , ) <NEWLINE> with test_support . _check_py3k_warnings ( <NEWLINE> <INDENT> ( <STRING> , SyntaxWarning ) ) : <NEWLINE> test_support . run_unittest ( * test_classes ) <NEWLINE> if verbose and hasattr ( sys , <STRING> ) : <NEWLINE> import gc <NEWLINE> counts = [ None ] * 5 <NEWLINE> for i in xrange ( len ( counts ) ) : <NEWLINE> <INDENT> test_support . run_unittest ( * test_classes ) <NEWLINE> gc . collect ( ) <NEWLINE> counts [ i ] = sys . gettotalrefcount ( ) <NEWLINE> <DEDENT> print ( counts ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self ) : <NEWLINE> <INDENT> generic . TorrentProvider . __init__ ( self <STRING> ) <NEWLINE> self . supportsBacklog = True <NEWLINE> self . cache = BTNCache ( self ) <NEWLINE> self . url = <STRING> <NEWLINE> <DEDENT>
def test_count_reads_ahead ( self ) : <NEWLINE> <INDENT> paginator = Paginator ( TestUser . objects . all ( ) . order_by ( <STRING> ) , 1 , readahead = 2 ) <NEWLINE> paginator . page ( 1 ) <NEWLINE> self . assertEqual ( 3 paginator . count ) <NEWLINE> paginator . page ( 3 ) <NEWLINE> self . assertEqual ( 4 , paginator . count ) <NEWLINE> <DEDENT>
def _PrintRevisionInfo ( self , cl , info , depot = None ) : <NEWLINE> <INDENT> commit_link = self . _GetViewVCLinkFromDepotAndHash ( cl , depot ) <NEWLINE> if commit_link : <NEWLINE> <INDENT> commit_link = <STRING> % commit_link <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> commit_link = ( <STRING> % info [ <STRING> ] ) <NEWLINE> <DEDENT> print ( RESULTS_REVISION_INFO % { <NEWLINE> <INDENT> <STRING> : info [ <STRING> ] , <NEWLINE> <STRING> : info [ <STRING> ] , <NEWLINE> <STRING> : commit_link , <NEWLINE> <STRING> : cl , <NEWLINE> <STRING> : info [ <STRING> ] <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>
( _ ( <STRING> <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import unittest <NEWLINE> from test . test_support import run_unittest <NEWLINE> from distutils . command . bdist_wininst import bdist_wininst <NEWLINE> from distutils . tests import support <NEWLINE> class BuildWinInstTestCase ( support . TempdirManager , <NEWLINE> <INDENT> support . LoggingSilencer , <NEWLINE> unittest . TestCase ) : <NEWLINE> def test_get_exe_bytes ( self ) : <NEWLINE> pkg_pth , dist = self . create_dist ( ) <NEWLINE> cmd = bdist_wininst ( dist ) <NEWLINE> cmd . ensure_finalized ( ) <NEWLINE> exe_file = cmd . get_exe_bytes ( ) <NEWLINE> self . assertTrue ( len ( exe_file ) > 10 ) <NEWLINE> <DEDENT>
def _loadBlt ( window ) : <NEWLINE> <INDENT> if _haveBlt is None : <NEWLINE> if window is None : <NEWLINE> <INDENT> window = Tkinter . _default_root <NEWLINE> if window is None : <NEWLINE> <INDENT> window = Tkinter . Tk ( ) <NEWLINE> _checkForBlt ( window ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def releaseLocks ( self ) : <NEWLINE> <INDENT> if self . locks : <NEWLINE> <INDENT> log . msg ( <STRING> % ( self , self . locks ) ) ) <NEWLINE> <DEDENT> for lock , access in self . locks : <NEWLINE> <INDENT> if lock . isOwner ( self , access ) : <NEWLINE> <INDENT> lock . release ( self , access ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> assert self . stopped <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def gaussianK ( x , y , median ) : <NEWLINE> <INDENT> d = len ( x ) <NEWLINE> for d in len ( x ) : <NEWLINE> c = 2 * ( ( 1.5 * median ) ** 2 ) <NEWLINE> val = ( x - y ) ** 2 / ( 2 * variance ) <NEWLINE> return math . exp ( val ) <NEWLINE> <DEDENT>
def exit_clean ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if path . isfile ( <STRING> ) or path . isfile ( <STRING> ) : <NEWLINE> <INDENT> print ( OPTION + <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> choice = raw_input ( <STRING> % INPUT ) <NEWLINE> if choice in CHOICES_YES : <NEWLINE> system ( <STRING> ) <NEWLINE> <DEDENT> if c . IS_MON : <NEWLINE> <INDENT> c . set_iface ( <STRING> ) <NEWLINE> system ( <STRING> ) <NEWLINE> system ( <STRING> ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT>
def getCoverArtMeta ( releaseId ) : <NEWLINE> <INDENT> method = <STRING> <NEWLINE> url = <STRING> + releaseId <NEWLINE> data = <STRING> <NEWLINE> req = mb . _MusicbrainzHttpRequest ( method , url , , data ) <NEWLINE> handlers = [ compat . HTTPHandler ( ) ] <NEWLINE> opener = compat . build_opener ( * handlers ) <NEWLINE> _log . info ( <STRING> + url ) <NEWLINE> resp = mb . _safe_read ( opener , req , <STRING> ) <NEWLINE> return json . loads ( resp ) <NEWLINE> <DEDENT>
def _takeRowsRange ( self , selectionrange ) : <NEWLINE> <INDENT> parent = self . _parentitem ( selectionrange ) <NEWLINE> rows = [ ] <NEWLINE> for row in range ( selectionrange . bottom ( ) , <NEWLINE> <INDENT> selectionrange . top ( ) - 1 , - 1 ) : <NEWLINE> if not self . isLayer ( parent . child ( row ) ) : <NEWLINE> break <NEWLINE> items = parent . takeRow ( row ) <NEWLINE> rows . insert ( 0 , items ) <NEWLINE> <DEDENT> return rows <NEWLINE> <DEDENT>
def go ( x , z , cnt ) : <NEWLINE> <INDENT> twist = Twist ( ) <NEWLINE> twist . linear . x = x <NEWLINE> twist . angular . z = z <NEWLINE> for i in range ( cnt ) : <NEWLINE> p . publish ( twist ) <NEWLINE> rospy . sleep ( 0.1 ) <NEWLINE> <DEDENT>
def __init__ ( self , editor_area , parent = None , tabwidget = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> super ( EditorAreaWidget , self ) . __init__ ( parent = parent ) <NEWLINE> self . editor_area = editor_area <NEWLINE> if not tabwidget : <NEWLINE> <INDENT> tabwidget = DraggableTabWidget ( editor_area = self . editor_area <NEWLINE> <INDENT> parent = self ) <NEWLINE> <DEDENT> <DEDENT> self . addWidget ( tabwidget ) <NEWLINE> tabwidget . show ( ) <NEWLINE> self . leftchild = None <NEWLINE> self . rightchild = None <NEWLINE> <DEDENT>
def _fix_module_doctest ( module ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> module . __test__ = { } <NEWLINE> for name in dir ( module ) : <NEWLINE> <INDENT> value = getattr ( module , name ) <NEWLINE> if ( inspect . isbuiltin ( value ) and isinstance ( value . __doc__ , str ) and <NEWLINE> <INDENT> _from_module ( module , value ) : <NEWLINE> module . __test__ [ name ] = value . __doc__ <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def prepareSelectionList ( self ) : <NEWLINE> <INDENT> id = self . options . ids [ - 1 ] <NEWLINE> self . patterns = { id : self . selected [ id ] } <NEWLINE> if self . options . duplicate : <NEWLINE> self . patterns = self . duplicateNodes ( self . patterns ) <NEWLINE> self . expandGroupsUnlinkClones ( self . patterns , True , True ) <NEWLINE> self . objectsToPaths ( self . patterns ) <NEWLINE> del self . selected [ id ] <NEWLINE> self . skeletons = self . selected <NEWLINE> self . expandGroupsUnlinkClones ( self . skeletons , True , False ) <NEWLINE> self . objectsToPaths ( self . skeletons ) <NEWLINE> <DEDENT>
def handle_exception ( self , exc ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if isinstance ( exc , ( exceptions . NotAuthenticated , <NEWLINE> <INDENT> exceptions . AuthenticationFailed ) ) : <NEWLINE> auth_header = self . get_authenticate_header ( self . request ) <NEWLINE> if auth_header : <NEWLINE> exc . auth_header = auth_header <NEWLINE> else : <NEWLINE> exc . status_code = status . HTTP_403_FORBIDDEN <NEWLINE> <DEDENT> exception_handler = self . settings . EXCEPTION_HANDLER <NEWLINE> context = self . get_exception_handler_context ( ) <NEWLINE> response = exception_handler ( exc , context ) <NEWLINE> if response is None : <NEWLINE> <INDENT> self . raise_uncaught_exception ( exc ) <NEWLINE> <DEDENT> response . exception = True <NEWLINE> return response <NEWLINE> <DEDENT>
def test_clp_repo_option ( ) : <NEWLINE> <INDENT> with parser_pair ( ) as ( builder , parser ) <NEWLINE> <INDENT> configure_clp_pex_resolution ( parser , builder ) <NEWLINE> assert len ( builder . _fetchers ) == 1 <NEWLINE> options , _ = parser . parse_args ( args = [ <STRING> , <STRING> ] ) <NEWLINE> assert len ( builder . _fetchers ) == 2 <NEWLINE> assert builder . _fetchers == options . repos <NEWLINE> <DEDENT> <DEDENT>
def get_except ( self , func , * args , ** kw ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> func ( * args , ** kw ) <NEWLINE> <DEDENT> except Exception , detail : <NEWLINE> <INDENT> return detail . __class__ , str ( detail ) <NEWLINE> <DEDENT> <DEDENT>
( <STRING> , accura <NEWLINE> <DEDENT> <DEDENT>
def do_query ( uri ) : <NEWLINE> <INDENT> t1 = time . time ( ) <NEWLINE> try : <NEWLINE> <INDENT> for line in urllib . urlopen ( uri ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> print ( <STRING> % ( uri , time . time ( ) - t1 ) ) ) <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> <INDENT> print ( <STRING> % ( uri , str ( e ) ) ) <NEWLINE> <DEDENT> <DEDENT>
def has_group ( self , cr , uid , group_ext_id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> assert group_ext_id and <STRING> in group_ext_id , <STRING> <NEWLINE> module , ext_id = group_ext_id . split ( <STRING> ) <NEWLINE> cr . execute ( <STRING> , <NEWLINE> <INDENT> ( uid , module , ext_id ) <NEWLINE> <DEDENT> return bool ( cr . fetchone ( ) ) <NEWLINE> <DEDENT>
def safeClickTab ( tab ) : <NEWLINE> <INDENT> for bar in [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ] : <NEWLINE> try : <NEWLINE> clickOnTab ( bar , tab , 1000 ) <NEWLINE> return True <NEWLINE> except : <NEWLINE> pass <NEWLINE> <DEDENT> test . fatal ( <STRING> % tab ) <NEWLINE> return False <NEWLINE> <DEDENT>
def restoreAtomicBackup ( self ) : <NEWLINE> <INDENT> logging . info ( <STRING> ) <NEWLINE> for confFilePath , content in self . _backups . iteritems ( ) : <NEWLINE> <INDENT> if content is None : <NEWLINE> <INDENT> utils . rmFile ( confFilePath ) <NEWLINE> logging . debug ( <STRING> <NEWLINE> <INDENT> confFilePath ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> with open ( confFilePath , <STRING> ) as confFile : <NEWLINE> <INDENT> confFile . write ( content ) <NEWLINE> <DEDENT> <DEDENT> logging . info ( <STRING> , confFilePath ) <NEWLINE> <DEDENT> <DEDENT>
class ExpertDispatchForm ( forms . Form ) : <NEWLINE> <INDENT> insitute_choice_list = [ ] <NEWLINE> insitute_list = InsituteCategory . objects . all ( ) <NEWLINE> for object in insitute_list : <NEWLINE> <INDENT> insitute_choice_list . append ( ( object . id , object . get_category_display ( ) ) ) <NEWLINE> <DEDENT> insitute_tuple = tuple ( insitute_choice_list ) <NEWLINE> expert_password = forms . CharField ( max_length = 20 , required = False , <NEWLINE> widget = forms . TextInput ( attrs = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import argparse <NEWLINE> import collections <NEWLINE> import csv <NEWLINE> import json <NEWLINE> import re <NEWLINE> import sys <NEWLINE> import snooker <NEWLINE> def gpcrdbalignment2snookeralignment_mapping ( gpositions , <NEWLINE> <INDENT> gprcdb2snookeralignment , <NEWLINE> ) : <NEWLINE> c2l = { } <NEWLINE> for cpos , gpos in enumerate ( gpositions ) : <NEWLINE> if gpos in gprcdb2snookeralignment : <NEWLINE> c2l [ cpos ] = gprcdb2snookeralignment [ gpos ] <NEWLINE> return c2l <NEWLINE> <DEDENT>
class AnonymousHospitalRequestHandler ( BaseHandler ) : <NEWLINE> <INDENT> allowed_methods = ( <STRING> , ) <NEWLINE> model = HmsRequest <NEWLINE> def read ( self , request , hospital_request_id = None ) : <NEWLINE> if ( hospital_request_id ) : <NEWLINE> <INDENT> return HmsRequest . objects . get ( pk = hospital_request_id ) <NEWLINE> else : <NEWLINE> return HmsRequest . objects . all ( ) <NEWLINE> <DEDENT> <DEDENT>
class SocketHandler ( websocket . WebSocketHandler ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def open ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self not in cl : <NEWLINE> <INDENT> cl . append ( self ) <NEWLINE> <DEDENT> <DEDENT> def on_close ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self in cl : <NEWLINE> <INDENT> cl . remove ( self ) <NEWLINE> def push ( self , message ) : <NEWLINE> <DEDENT> <DEDENT> print ( message ) <NEWLINE> self . write_message ( message ) <NEWLINE> <DEDENT>
def launch ( self c ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . controllers . append ( c ) <NEWLINE> self . inmap . append ( None ) <NEWLINE> self . outmap . append ( None ) <NEWLINE> return len ( self . controllers ) - 1 <NEWLINE> <DEDENT>
def getValueCount ( csvReader ) : <NEWLINE> <INDENT> valueCount = 0 <NEWLINE> for row in csvReader : <NEWLINE> <INDENT> if row [ 0 ] . startswith ( <STRING> ) : <NEWLINE> <DEDENT> continue <NEWLINE> <INDENT> valueCount = len ( row ) <NEWLINE> return valueCount <NEWLINE> <DEDENT> <DEDENT>
from __future__ import with_statement <NEWLINE> import unittest <NEWLINE> from flask import Flask , Response <NEWLINE> from flask_principal import Principal , Permission , Denial , RoleNeed , PermissionDenied , identity_changed , Identity , identity_loaded <NEWLINE> anon_permission = Permission ( ) <NEWLINE> admin_permission = Permission ( RoleNeed ( <STRING> ) ) <NEWLINE> admin_or_editor = Permission ( RoleNeed ( <STRING> ) , RoleNeed ( <STRING> ) <NEWLINE> editor_permission = Permission ( RoleNeed ( <STRING> ) ) <NEWLINE> admin_denied = Denial ( RoleNeed ( <STRING> ) ) <NEWLINE>
def not_android_version ( self , android_version_name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( self . device . Configuration . OS . Kind == ANDROID and <NEWLINE> <INDENT> StrictVersion ( self . device . Configuration . OS . Name ) <= <NEWLINE> StrictVersion ( android_version_name ) ) : <NEWLINE> call_site = traceback . format_list ( traceback . extract_stack ( limit = 2 ) ) <NEWLINE> self . warnings . append ( <NEWLINE> <STRING> + call_site [ <NEWLINE> <INDENT> 0 ] ) <NEWLINE> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT>
def runNtrajectory ( self , ( x , y ) , repeat ) : <NEWLINE> <INDENT> costAll , trajTimeAll = np . zeros ( repeat ) , np . zeros ( repeat ) <NEWLINE> for i in range ( repeat ) : <NEWLINE> <INDENT> costAll [ i ] , trajTimeAll [ i ] = self . runOneTrajectoryOpti ( x , y ) <NEWLINE> <DEDENT> meanCost = np . mean ( costAll ) <NEWLINE> meanTrajTime = np . mean ( trajTimeAll ) <NEWLINE> self . costStore . append ( [ x , y , meanCost ] ) <NEWLINE> self . trajTimeStore . append ( [ x , y , meanTrajTime ] ) <NEWLINE> return meanCost , meanTrajTime <NEWLINE> <DEDENT>
def __init__ ( self , ** kw ) : <NEWLINE> <INDENT> for name , value in kw . items ( ) : <NEWLINE> <INDENT> if not hasattr ( self , name ) : <NEWLINE> <INDENT> raise TypeError ( <NEWLINE> <INDENT> <STRING> % ( name , value ) <NEWLINE> <DEDENT> <DEDENT> setattr ( self , name , value ) <NEWLINE> <DEDENT> if self . inline_style is None and <STRING> not in kw : <NEWLINE> <INDENT> self . inline_style = self . style <NEWLINE> <DEDENT> <DEDENT>
( <STRING> <NEWLINE> <DEDENT>
def register_user ( self , user ) : <NEWLINE> <INDENT> if self . registration_open ( ) : <NEWLINE> <INDENT> registration = EventUserRegistration ( event = self , user = user ) <NEWLINE> registration . save ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise ValidationError ( _ ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> . format ( user = user , event = self <NEWLINE> <INDENT> end = self . registration_end_time ) <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def plot_densities ( ( X , Y , Zs ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> heights = np . linspace ( 0 , np . max ( Zs ) , 7 ) <NEWLINE> for ci in range ( Zs . shape [ - 1 ] ) : <NEWLINE> <INDENT> Z = Zs [ : , : , ci ] <NEWLINE> cs = plt . contour ( X , Y , Z , heights , linewidths = .3 , colors = <STRING> ) <NEWLINE> plt . clabel ( cs , fontsize = 6 ) <NEWLINE> <DEDENT> <DEDENT>
def _OnTimelineEvent ( self , event_info ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> elapsed_time = int ( round ( time . time ( ) - self . _test_start_time ) <NEWLINE> if event_info [ <STRING> ] == <STRING> : <NEWLINE> <INDENT> self . _events_to_output . append ( { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : elapsed_time , <NEWLINE> <STRING> : <NEWLINE> <INDENT> { <STRING> : event_info [ <STRING> ] [ <STRING> ] } , <NEWLINE> <DEDENT> <DEDENT> } ) <NEWLINE> <DEDENT> <DEDENT>
def _readResponseBody ( self , response , contentType ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> processor = self . bodyProcessors [ contentType ] <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> raise RuntimeError ( <STRING> . format ( contentType ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = readBody ( response ) <NEWLINE> if processor is not None : <NEWLINE> <INDENT> d . addCallback ( processor ) <NEWLINE> <DEDENT> return d <NEWLINE> <DEDENT> <DEDENT>
def __print_var ( self , key , val ) : <NEWLINE> <INDENT> if ( self . args . get ( <STRING> ) or <NEWLINE> <INDENT> ( not self . args . get ( <STRING> ) and <NEWLINE> <INDENT> os . getenv ( <STRING> , <STRING> ) . endswith ( <STRING> ) ) ) : <NEWLINE> if val : <NEWLINE> <DEDENT> fmt = <STRING> <NEWLINE> else : <NEWLINE> fmt = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if val : <NEWLINE> <INDENT> fmt = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fmt = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( fmt . format ( key = key , val = val ) ) <NEWLINE> <DEDENT>
import logging <NEWLINE> from rest_framework import serializers <NEWLINE> from { { cookiecutter . project_slug } } . users . models import User <NEWLINE> logger = logging . getLogger ( __name__ ) <NEWLINE>
def get_service_vm_status ( self , vm_id ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> status = self . _nclient . servers . get ( vm_id ) . status <NEWLINE> <DEDENT> except ( nova_exc . UnsupportedVersion , nova_exc . CommandError , <NEWLINE> <INDENT> nova_exc . AuthorizationFailure , nova_exc . NoUniqueMatch , <NEWLINE> nova_exc . AuthSystemNotFound , nova_exc . NoTokenLookupException , <NEWLINE> nova_exc . EndpointNotFound , nova_exc . AmbiguousEndpoints , <NEWLINE> nova_exc . ConnectionRefused , nova_exc . ClientException , <NEWLINE> Exception ) as e : <NEWLINE> LOG . error ( _ ( <STRING> <NEWLINE> <INDENT> <STRING> ) , { <STRING> : vm_id , <STRING> : e } ) <NEWLINE> status = c_constants . SVM_ERROR <NEWLINE> <DEDENT> <DEDENT> return status <NEWLINE> <DEDENT>
def decode_dict ( x , cursor ) : <NEWLINE> <INDENT> r , cursor = { } , cursor + 1 <NEWLINE> while x [ cursor : cursor + 1 ] != CHR_TERM : <NEWLINE> <INDENT> k , cursor = decode_func [ x [ cursor : cursor + 1 ] ] ] ( x , cursor ) <NEWLINE> r [ k ] , cursor = decode_func [ x [ cursor : cursor + 1 ] ] ( x , cursor ) <NEWLINE> <DEDENT> return r , cursor + 1 <NEWLINE> <DEDENT>
for x in range ( input ( ) ) : <NEWLINE> <INDENT> n = int ( input ( ) ) - 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> n += 1 ; <NEWLINE> if str ( n ) == str ( n ) [ : : - 1 ] and all ( n % i for i in range ( 2 , n ** 0.5 + 1 , 1 ) ) : <NEWLINE> <INDENT> print n <NEWLINE> <DEDENT> <DEDENT> <DEDENT> 127 <NEWLINE> 24.4 <NEWLINE>
def URL ( url_obj ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> url_list = [ ] <NEWLINE> url_sort = [ ] <NEWLINE> if type ( url_obj ) == str : <NEWLINE> <INDENT> url_obj = url_obj . split ( ) <NEWLINE> <DEDENT> for obj in url_obj : <NEWLINE> <INDENT> matches = re . findall ( <STRING> , obj ) <NEWLINE> if matches : <NEWLINE> <INDENT> if matches [ 0 ] not in url_list : <NEWLINE> <INDENT> url_list . append ( matches [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for url in sorted ( url_list ) : <NEWLINE> <INDENT> url_sort . append ( url [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def __repr__ ( self ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> for flist , fname in ( ( self . fields_IN , <STRING> ) , <NEWLINE> <INDENT> ( self . fields_OUT , <STRING> ) , <NEWLINE> ( self . fields_INOUT , <STRING> ) ) : <NEWLINE> if not flist : <NEWLINE> continue <NEWLINE> ret . append ( fname ) <NEWLINE> for field in flist : <NEWLINE> ret . append ( <STRING> % ( field . name , str ( field . dataType ) ) ) <NEWLINE> ret . append ( <STRING> ) <NEWLINE> <DEDENT> if not ret : <NEWLINE> <INDENT> ret = [ <STRING> ] <NEWLINE> <DEDENT> return <STRING> . join ( ret ) <NEWLINE> <DEDENT>
def loadURL ( self ) : <NEWLINE> <INDENT> bHasUUID = AISUtil . hasUUID ( self . __settings ) <NEWLINE> if False == bHasUUID : <NEWLINE> print ( <STRING> ) <NEWLINE> uuidCreateReq = APUUIDCreateRequest . APUUIDCreateRequest ( self . __settings ) <NEWLINE> uuidDict = uuidCreateReq . loadURL ( True ) <NEWLINE> for key , val in uuidDict . items ( ) : <NEWLINE> <INDENT> print ( <STRING> + key + <STRING> + val ) <NEWLINE> return uuidDict <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> self . openSession ( ) <NEWLINE> self . prepareQueryURL ( ) <NEWLINE> return super ( APAccountLoader , self ) . loadURL ( ) <NEWLINE> <DEDENT> <DEDENT>
def _init ( self ) : <NEWLINE> <INDENT> self . environment . setdefault ( <NEWLINE> <INDENT> constants . SysEnv . COMMAND_PATH <NEWLINE> constants . Defaults . COMMAND_SEARCH_PATH <NEWLINE> <DEDENT> ) <NEWLINE> self . context . registerCommand ( command = self ) <NEWLINE> <DEDENT>
def _get_destination_directory_list_for_webdav_server ( self , start_date ) : <NEWLINE> <INDENT> directory_list = [ ] <NEWLINE> for param in [ settings . GA_DIAGNOSIS_DESTINATION_ROOT_PATH , str ( start_date . year ) , <NEWLINE> <INDENT> <STRING> . format ( start_date . month ) , <NEWLINE> <STRING> . format ( start_date . day ) ] : <NEWLINE> directory_list . append ( param ) <NEWLINE> if not self . webdav . exists ( os . path . join ( * directory_list ) ) : <NEWLINE> self . webdav . mkdir ( os . path . join ( * directory_list ) ) <NEWLINE> <DEDENT> return directory_list <NEWLINE> <DEDENT>
def test_config_for_dot_name_domain ( self ) : <NEWLINE> <INDENT> domain_config_filename = os . path . join ( self . tmp_dir , <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> with open ( domain_config_filename , <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> self . addCleanup ( os . remove , domain_config_filename ) <NEWLINE> with mock . patch . object ( identity . DomainConfigs , <NEWLINE> <INDENT> <STRING> ) as mock_load_config : <NEWLINE> domain_config = identity . DomainConfigs ( ) <NEWLINE> fake_assignment_api = None <NEWLINE> fake_standard_driver = None <NEWLINE> domain_config . setup_domain_drivers ( fake_standard_driver , <NEWLINE> <INDENT> fake_assignment_api ) <NEWLINE> mock_load_config . assert_called_once_with ( fake_assignment_api , <NEWLINE> <INDENT> [ domain_config_filename ] , <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import re <NEWLINE> from django . db . models import Q <NEWLINE> from public_project . models import Page <NEWLINE> def normalize_query ( query_string , <NEWLINE> <INDENT> findterms = re . compile ( <STRING> ) . findall , <NEWLINE> normspace = re . compile ( <STRING> ) . sub ) : <NEWLINE> <STRING> <NEWLINE> return [ normspace ( <STRING> , ( t [ 0 ] or t [ 1 ] ) . strip ( ) ) ) for t in findterms ( query_string ) ] <NEWLINE> <DEDENT>
<INDENT> R = self . _find ( path = path , value = value } ) <NEWLINE>
from suds . client import Client <NEWLINE> client = Client ( <STRING> ) <NEWLINE> sid = client . service . api_login ( argv [ 1 ] , argv [ 2 ] ) <NEWLINE> if ( sid == <STRING> ) <NEWLINE> <INDENT> die ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> + sid + <STRING> ) <NEWLINE> result = client . service . api_getTicketList ( ) <NEWLINE> print ( result ) <NEWLINE>
import GBDT <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> handle = GBDT . load ( <STRING> ) <NEWLINE> s = <STRING> + <STRING> . join ( map ( lambda ( i , v ) : <STRING> % ( i + 1 , v ) , enumerate ( [ i for i in range ( 20 ) ] ) ) ) <NEWLINE> score = GBDT . predict ( handle , s ) <NEWLINE> print ( <STRING> % score ) <NEWLINE> leaves = GBDT . tree_features ( handle , s ) <NEWLINE> print ( leaves ) <NEWLINE> <DEDENT>
def _do_request ( self , method , values ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> url = <STRING> % ( self . url_prefix , method , self . lang , self . api_key , values ) <NEWLINE> try : <NEWLINE> <INDENT> meta = requests . get ( url ) . json ( ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> if meta == <STRING> : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return meta <NEWLINE> <DEDENT> <DEDENT>
def create_playlist_url ( self , channel ) : <NEWLINE> <INDENT> token = self . create_playlist_token ( channel ) <NEWLINE> if token : <NEWLINE> <INDENT> return self . url ( HLS_PLAYLIST_PATH , channel , quote ( token ) <NEWLINE> <DEDENT> <DEDENT>
( _ ( <NEWLINE> <STRING> <NEWLINE> ) % { <NEWLINE> <STRING> : tstring , <NEWLINE> <STRING> : self . __curfile , <NEWLINE> <STRING> : self . __lineno <NEWLINE> } <NEWLINE> self . __state = self . __waiting <NEWLINE> <DEDENT> <DEDENT>
class GladeDelegate ( BaseView , BaseController ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , gladefile = None , toplevel_name = None , domain = None , <NEWLINE> <INDENT> delete_handler = None , keyactions = None ) : <NEWLINE> <STRING> <NEWLINE> BaseView . __init__ ( self , <NEWLINE> <INDENT> gladefile = gladefile , <NEWLINE> toplevel_name = toplevel_name , <NEWLINE> domain = domain , <NEWLINE> delete_handler = delete_handler ) <NEWLINE> BaseController . __init__ ( self , view = self , keyactions = keyactions ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def setSparseFeatWeight ( self , name , val ) : <NEWLINE> <INDENT> if name in self . sparseFeaturesMap : <NEWLINE> id = self . sparseFeaturesMap [ name ] <NEWLINE> self . sparseFeatures [ id ] = val <NEWLINE> return id <NEWLINE> else : <NEWLINE> self . sparseFeatures . append ( val ) <NEWLINE> self . sparseSigma . append ( 0 ) <NEWLINE> self . sparseFeaturesMap [ name ] = len ( self . sparseFeatures ) - 1 <NEWLINE> return len ( self . sparseFeatures ) - 1 <NEWLINE> <DEDENT>
def info ( self ) : <NEWLINE> <INDENT> vars = [ x [ 12 : ] for x in dir ( cv2 . cv ) if <STRING> in x ] <NEWLINE> ret = { } <NEWLINE> for p in vars : <NEWLINE> <INDENT> cmd = <STRING> + p + <STRING> + p + <STRING> <NEWLINE> exec cmd <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT>
def _getSummary ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> summaries = [ ] <NEWLINE> for stat in ( <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> num = len ( getattr ( self , stat ) ) <NEWLINE> if num : <NEWLINE> summaries . append ( <STRING> % ( stat , num ) ) <NEWLINE> <DEDENT> if self . successes : <NEWLINE> <INDENT> summaries . append ( <STRING> % ( self . successes , ) ) <NEWLINE> <DEDENT> summary = ( summaries and <STRING> + <STRING> . join ( summaries ) + <STRING> ) or <STRING> <NEWLINE> return summary <NEWLINE> <DEDENT>
def var2mean ( self , RasterValues ) : <NEWLINE> <INDENT> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> meanvar , stdVar = radar_f90 . var2mean ( RasterValues , <NEWLINE> <INDENT> self . elements , self . elements [ 0 , - 1 ] , <NEWLINE> radar_f90 . ncols , <NEWLINE> radar_f90 . nrows , <NEWLINE> self . elements . shape [ 1 ] ) <NEWLINE> <DEDENT> return meanvar , stdVar <NEWLINE> <DEDENT>
print ( <STRING> } BASE ) <NEWLINE>
def _test_RuntimeError ( self ) : <NEWLINE> <INDENT> e1 = RuntimeError <NEWLINE> def fn ( ) : <NEWLINE> <INDENT> RuntimeError = bool <NEWLINE> try : <NEWLINE> <INDENT> a = dict ( a = 1 , b = 2 , c = 3 ) <NEWLINE> for k , v in a . iteritems ( ) : <NEWLINE> <INDENT> a [ <STRING> % k ] = v <NEWLINE> <DEDENT> <DEDENT> except e1 , e : <NEWLINE> <INDENT> self . assertTrue ( isinstance ( e , e1 ) ) <NEWLINE> self . assertFalse ( isinstance ( e , RuntimeError ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . fail ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> fn ( ) <NEWLINE> <DEDENT>
def create_userpreference ( sender , instance , created , ** kwargs ) : <NEWLINE> <INDENT> if created : <NEWLINE> UserPreference . objects . get_or_create ( user = instance ) <NEWLINE> <DEDENT>
class PRecord : <NEWLINE> <INDENT> def __init__ ( self , attr = 0 , id = 0 , category = 0 , raw = <STRING> ) : <NEWLINE> self . raw = raw <NEWLINE> self . id = id <NEWLINE> self . attr = attr <NEWLINE> self . category = category <NEWLINE> def __cmp__ ( self , obj ) : <NEWLINE> if type ( obj ) == type ( 0 ) : <NEWLINE> <INDENT> return cmp ( self . id , obj ) <NEWLINE> else : <NEWLINE> return cmp ( self . id , obj . id ) <NEWLINE> <DEDENT> def __hash__ ( self ) : <NEWLINE> return self . id <NEWLINE> <DEDENT>
def save_image ( img , quality , format , ContentType , Key , Bucket ) : <NEWLINE> <INDENT> Metadata = { <STRING> : str ( img . size [ 0 ] ) , <STRING> , str ( img . size [ 1 ] ) , <STRING> : img . format , <STRING> : img . mode } <NEWLINE> object = s3 . Object ( Bucket , Key ) <NEWLINE> image_buffer = BytesIO ( ) <NEWLINE> img . save ( image_buffer , quality = quality , format = format ) <NEWLINE> res = object . put ( Body = image_buffer . getvalue ( ) , ContentType = ContentType , Metadata = Metadata ) <NEWLINE> return res <NEWLINE> <DEDENT>
def log_control_err ( err_string ) : <NEWLINE> <INDENT> target = open ( log_file , <STRING> ) <NEWLINE> target . write ( str ( datetime . datetime . now ( ) ) + <STRING> + err_string + <STRING> ) <NEWLINE> <INDENT> target . close ( ) <NEWLINE> <DEDENT> error_list . append ( err_string ) <NEWLINE> <DEDENT>
def test_set_boot_device_persistent_true ( self , get_ilo_object_mock ) : <NEWLINE> <INDENT> ilo_mock = get_ilo_object_mock . return_value <NEWLINE> with task_manager . acquire ( self . context , self . node . uuid , <NEWLINE> <INDENT> shared = False ) as task : <NEWLINE> task . driver . management . set_boot_device ( task , boot_devices . PXE , <NEWLINE> <INDENT> True ) <NEWLINE> get_ilo_object_mock . assert_called_once_with ( task . node ) <NEWLINE> ilo_mock . update_persistent_boot . assert_called_once_with ( <NEWLINE> [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>
def get_authenticated_service ( args ) : <NEWLINE> <INDENT> flow = flow_from_clientsecrets ( CLIENT_SECRETS_FILE <NEWLINE> <INDENT> scope = YOUTUBE_UPLOAD_SCOPE , <NEWLINE> message = MISSING_CLIENT_SECRETS_MESSAGE ) <NEWLINE> <DEDENT> storage = Storage ( <STRING> % sys . argv [ 0 ] ) <NEWLINE> credentials = storage . get ( ) <NEWLINE> if credentials is None or credentials . invalid : <NEWLINE> <INDENT> credentials = run_flow ( flow , storage , args ) <NEWLINE> <DEDENT> return build ( YOUTUBE_API_SERVICE_NAME , YOUTUBE_API_VERSION , <NEWLINE> <INDENT> http = credentials . authorize ( httplib2 . Http ( ) ) ) <NEWLINE> <DEDENT> <DEDENT>
def fetch_template ( self , template_id ) : <NEWLINE> <INDENT> self . template = self . connection . call ( <STRING> , <NEWLINE> <INDENT> { <STRING> : int ( template_id ) } ) <NEWLINE> <DEDENT> self . attributes = self . connection . call ( <STRING> <NEWLINE> <INDENT> { <STRING> : int ( template_id ) } ) <NEWLINE> <DEDENT> for a in self . attributes : <NEWLINE> <INDENT> self . attr_name_map [ a . name ] = a <NEWLINE> <DEDENT> <DEDENT>
def check_for_sms_sent_file ( NOTIFICATION_ELASPED_TIME_HOURS , reservoir_level ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> last_touched_in_secs_since_epoch = subprocess . Popen ( [ <STRING> , <STRING> , <STRING> , <STRING> ] , stdout = subprocess . PIPE ) . communicate ( ) [ 0 ] <NEWLINE> now_in_secs_since_epoch = subprocess . Popen ( [ <STRING> ] , stdout = subprocess . PIPE ) . communicate ( ) [ 0 ] <NEWLINE> elapsed_secs = now_in_secs_since_epoch - last_touched_in_secs_since_epoch <NEWLINE> if elapsed_secs >= ( NOTIFICATION_ELASPED_TIME_HOURS * 3600 ) : <NEWLINE> <INDENT> send_reservoir_sms ( reservoir_level ) <NEWLINE> update_reservoir_sent_file <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> send_reservoir_sms ( reservoir_level ) <NEWLINE> update_reservoir_sent_file <NEWLINE> <DEDENT> <DEDENT>
def can_merge ( self ) : <NEWLINE> <INDENT> if self . basename != <STRING> : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> required_version = <STRING> <NEWLINE> if is_outdated_version ( <NEWLINE> <INDENT> self . _versions [ self . basename ] , required_version ) : <NEWLINE> warning = ( <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> ) % ( <NEWLINE> <INDENT> self . basename , self . basename , required_version ) <NEWLINE> if self . _downloader : <NEWLINE> <DEDENT> <DEDENT> self . _downloader . report_warning ( warning ) <NEWLINE> return False <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT>
def _validate_one_email ( request , cleaned_data , email , errors ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if cleaned_data [ email ] : <NEWLINE> <INDENT> user = player_mgr . get_user_by_email ( cleaned_data [ email ] . lower ( ) ) ) <NEWLINE> if user == None or user == request . user : <NEWLINE> <INDENT> errors [ email ] = ErrorList ( [ <STRING> ] ) <NEWLINE> del cleaned_data [ email ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_create_fails_if_configuration_is_not_provided ( self ) : <NEWLINE> <INDENT> r = Runner ( options = { } ) <NEWLINE> with mock . patch . multiple ( <STRING> , <NEWLINE> <INDENT> abort = self . abort ) : <NEWLINE> with self . assertRaises ( AbortException ) : <NEWLINE> r . main ( [ <STRING> ] ) <NEWLINE> self . abort . assert_any_call ( FailureMessages . NEED_API_KEY ) <NEWLINE> <DEDENT> <DEDENT>
def check_process ( process ) : <NEWLINE> <INDENT> import re <NEWLINE> import subprocess <NEWLINE> returnprocess = False <NEWLINE> s = subprocess . Popen ( [ <STRING> , <STRING> ] , stdout = subprocess . PIPE ) <NEWLINE> for x in s . stdout : <NEWLINE> <INDENT> if re . search ( process , x ) : <NEWLINE> <INDENT> returnprocess = True <NEWLINE> if retornoprocesso == False : <NEWLINE> print ( <STRING> ) <NEWLINE> if retornoprocesso == True : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def drawTickMarks ( self ) : <NEWLINE> <INDENT> canvas = self . components . canvas <NEWLINE> x = self . tickXBase <NEWLINE> while x < canvas . size [ 0 ] : <NEWLINE> <INDENT> canvas . drawLine ( ( x , canvas . size [ 1 ] - 1 ) , ( x , canvas . size [ 1 ] - 10 ) <NEWLINE> x += self . tickWidth <NEWLINE> <DEDENT> <DEDENT>
def on_welcome ( self , c , e ) : <NEWLINE> <INDENT> self . connection . privmsg ( <STRING> , <NEWLINE> <INDENT> <STRING> <NEWLINE> % ( site . language ( ) , site . family . name , str ( ver ) ) <NEWLINE> <DEDENT> <DEDENT>
( g , f , <STRING> , 31000 <NEWLINE> <DEDENT> <DEDENT>
def test_random ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for i in range ( 40 ) : <NEWLINE> <INDENT> moves = [ ] <NEWLINE> for i in range ( random . randint ( 3 , 50 ) : <NEWLINE> <INDENT> moves . append ( random . choice ( opts ) ) <NEWLINE> <DEDENT> assert street_fighter_selection ( fighters , ( 0 , 0 ) , moves ) == my_street_fighter_selection ( fighters , ( 0 , 0 ) , moves ) <NEWLINE> <DEDENT> <DEDENT>
def event_room_message ( bot , ( message , room , nick ) ) : <NEWLINE> <INDENT> text = message . getBody ( ) <NEWLINE> if message . getType ( ) == <STRING> and text and nick in bot . roster [ room ] : <NEWLINE> <INDENT> addseen ( bot , room , nick , bot . roster [ room ] [ nick ] [ ROSTER_JID ] , <STRING> , text ) <NEWLINE> <DEDENT> <DEDENT>
def ConfigSectionMap ( section ) : <NEWLINE> <INDENT> dict1 = { } <NEWLINE> options = Config . options ( section ) <NEWLINE> for option in options : <NEWLINE> try : <NEWLINE> dict1 [ option ] = Config . get ( section , option ) <NEWLINE> if dict1 [ option ] == - 1 : <NEWLINE> <INDENT> DebugPrint ( <STRING> % option ) <NEWLINE> except : <NEWLINE> <DEDENT> print ( <STRING> % option ) <NEWLINE> dict1 [ option ] = None <NEWLINE> return dict1 <NEWLINE> <DEDENT>
( self . nickname != self . factory . nickname : <NEWLINE> <INDENT> log . msg ( <STRING> <STRING> . format ( self , nickname ) ) <NEWLINE> <DEDENT> self . join ( self . factory . channel ) <NEWLINE> <DEDENT> def joined ( self , channel ) : <NEWLINE> <INDENT> log . msg ( <STRING> . format ( nick = self . nickname , channel = self . factory . channel , ) ) <NEWLINE> <DEDENT> <DEDENT>
def calcNearestNeighbours ( prefs , n = 10 ) : <NEWLINE> <INDENT> neighbours = { } <NEWLINE> c = 0 <NEWLINE> for item in prefs : <NEWLINE> <INDENT> c += 1 <NEWLINE> if c % 100 == 0 : print <STRING> % ( c , len ( prefs ) ) <NEWLINE> scoreAndItem = topMatches ( prefs , item , n = n , similarity = sim_distance ) <NEWLINE> neighbours [ item ] = scoreAndItem <NEWLINE> <DEDENT> return neighbours <NEWLINE> <DEDENT>
def Flush ( self , loops = 50 , wait = False , allow_blocking = False ) : <NEWLINE> <INDENT> while ( loops != 0 and <NEWLINE> <INDENT> len ( self . write_blocked ) > 0 and <NEWLINE> self . Send ( [ ] , try_flush = True , activity = False , <NEWLINE> <INDENT> allow_blocking = allow_blocking ) ) : <NEWLINE> if wait and len ( self . write_blocked ) > 0 : <NEWLINE> time . sleep ( 0.1 ) <NEWLINE> logging . LogDebug ( <STRING> ) <NEWLINE> loops -= 1 <NEWLINE> <DEDENT> <DEDENT> if self . write_blocked : return False <NEWLINE> return True <NEWLINE> <DEDENT>
def test_disallowed_relativities ( self ) : <NEWLINE> <INDENT> for relativity in DISALLOWED_RELATIVITIES : <NEWLINE> <INDENT> for following_lines in [ [ ] , [ <STRING> ] ] : <NEWLINE> <INDENT> with self . subTest ( relativity = str ( relativity ) , <NEWLINE> <INDENT> following_lines = repr ( following_lines ) ) : <NEWLINE> option_conf = conf_rel_any ( relativity ) <NEWLINE> source = remaining_source ( <STRING> . format ( rel_opt = option_conf . option_string ) , <NEWLINE> <INDENT> [ <STRING> ] + following_lines ) <NEWLINE> with self . assertRaises ( SingleInstructionInvalidArgumentException ) : <NEWLINE> _just_parse ( source ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def __init__ ( self , activity ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> assert ( IActivity . providedBy ( activity ) ) <NEWLINE> <DEDENT> except AssertionError : <NEWLINE> <INDENT> raise ActivityRuntimeError , <STRING> <NEWLINE> <DEDENT> self . activity = activity <NEWLINE> self . token_pool = TokenPool ( ) <NEWLINE> <DEDENT>
def fetch ( self , filename , forceBundle = False , conjunct = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> filename = os . path . realpath ( filename ) <NEWLINE> if not self . isConnected ( ) : <NEWLINE> return filename , False <NEWLINE> try : <NEWLINE> if forceBundle or self . _isBundleFile ( filename ) : <NEWLINE> f , r = self . _fetchBundle ( filename , conjunct ) <NEWLINE> else : <NEWLINE> f , r = self . _fetchFile ( filename ) <NEWLINE> return f , ( r == 0 ) <NEWLINE> except Exception , e : <NEWLINE> error ( <STRING> % str ( e ) ) <NEWLINE> return filename , False <NEWLINE> <DEDENT>
def test_float__format__locale ( self ) : <NEWLINE> <INDENT> for i in range ( - 10 , 10 ) <NEWLINE> <INDENT> x = 1234567890.0 * ( 10.0 ** i ) <NEWLINE> self . assertEqual ( locale . format ( <STRING> , x , grouping = True ) , format ( x , <STRING> ) ) <NEWLINE> self . assertEqual ( locale . format ( <STRING> , x , grouping = True ) , format ( x , <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT>
def test_get_property_success ( self ) : <NEWLINE> <INDENT> value = <STRING> <NEWLINE> with patch ( <STRING> <NEWLINE> <INDENT> <STRING> , <NEWLINE> return_value = Response ( Response . StatusCode . OK , value ) <NEWLINE> ) as m_get_object : <NEWLINE> self . result = self . target . get_property ( ) <NEWLINE> self . assertEqual ( m_get_object . call_count , 1 ) <NEWLINE> self . assertEqual ( m_get_object . call_args [ 0 ] [ 0 ] , <NEWLINE> <INDENT> RemoteObjectInterface . PROPETY_PATH ) <NEWLINE> self . assertNotEqual ( self . result , None ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
( show . replace ( <STRING> , <STRING> ) . title ( ) , int ( season ) , int ( episode ) , <STRING> . join ( subteams ) . upper ( ) <NEWLINE> <DEDENT> <DEDENT>
def client_opened ( self ) : <NEWLINE> <INDENT> piw . client . client_opened ( self ) <NEWLINE> if self . __sink : <NEWLINE> <INDENT> piw . client . set_sink ( self , self . __sink ) <NEWLINE> <DEDENT> if self . __initial : <NEWLINE> <INDENT> piw . client . client_data ( self , self . get_data ( ) ) ) <NEWLINE> <DEDENT> <DEDENT>
def cleardb ( host , dbname , user , password ) : <NEWLINE> <INDENT> ConnectionString = <STRING> + dbname + <STRING> + user + <STRING> + host + <STRING> + password <NEWLINE> try : <NEWLINE> conn = psycopg2 . connect ( ConnectionString ) <NEWLINE> except : <NEWLINE> print ( <STRING> ) <NEWLINE> <INDENT> print ( ConnectionString ) <NEWLINE> return 0 <NEWLINE> cur = conn . cursor ( ) <NEWLINE> sql = <STRING> <NEWLINE> cur . execute ( sql ) <NEWLINE> conn . commit ( ) <NEWLINE> <DEDENT> <DEDENT>
class Solution ( object ) : <NEWLINE> <INDENT> def arrayPairSum ( self , nums ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return sum ( sorted ( nums ) [ : : 2 ) <NEWLINE> <DEDENT> <DEDENT>
def getIntersectDropController ( self , x , y ) : <NEWLINE> <INDENT> Location location = CoordinateLocation ( x , y ) <NEWLINE> for int i = sortedCandidates . length - 1 ; i >= 0 ; i - - : <NEWLINE> <INDENT> Candidate candidate = sortedCandidates [ i ] <NEWLINE> Area targetArea = candidate . getTargetArea ( ) <NEWLINE> if targetArea . intersects ( location ) : <NEWLINE> <INDENT> return candidate . getDropController ( ) <NEWLINE> <DEDENT> <DEDENT> return None <NEWLINE> <DEDENT>
def _invoke ( self , event ) : <NEWLINE> <INDENT> cmd = self [ <STRING> ] <NEWLINE> if callable ( cmd ) : <NEWLINE> cmd ( ) <NEWLINE> <DEDENT>
def testCleanupExceptionContextException ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> was_raised = False <NEWLINE> tempdir_obj = osutils . TempDir ( prefix = self . PREFIX ) <NEWLINE> with mock . patch . object ( osutils , <STRING> , <NEWLINE> <INDENT> side_effect = TempDirTests . HelperException ) : <NEWLINE> try : <NEWLINE> with tempdir_obj as td : <NEWLINE> tempdir = td <NEWLINE> raise TempDirTests . HelperExceptionInner ( ) <NEWLINE> except TempDirTests . HelperExceptionInner : <NEWLINE> was_raised = True <NEWLINE> <DEDENT> self . assertTrue ( was_raised ) <NEWLINE> self . assertIsNone ( tempdir_obj . tempdir ) <NEWLINE> os . rmdir ( tempdir ) <NEWLINE> <DEDENT>
def GET ( url ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> print ( <STRING> % url ) <NEWLINE> req = urllib2 . Request ( url ) <NEWLINE> <INDENT> req . add_header ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> response = urllib2 . urlopen ( req ) <NEWLINE> http = response . read ( ) <NEWLINE> response . close ( ) <NEWLINE> return http <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> showMessage ( <STRING> , url ) <NEWLINE> return None <NEWLINE> <DEDENT> <DEDENT>
def test_sandbox_provider_docker_container ( ) : <NEWLINE> <INDENT> sandbox = DefaultSandboxProvider ( ) . from_assigned_task ( <NEWLINE> <INDENT> AssignedTask ( task = TaskConfig ( container = Container ( docker = DockerContainer ( ) ) ) ) ) ) <NEWLINE> <DEDENT> assert sandbox . _user is None <NEWLINE> <DEDENT>
def getwelcome ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . debugging : print <STRING> , repr ( self . welcome ) <NEWLINE> return self . welcome <NEWLINE> <DEDENT>
def buffer2file ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . current_file is not None and self . buffer <NEWLINE> <INDENT> self . current_file . add_block_data ( self . buffered_block_length , self . buffer ) <NEWLINE> self . buffer = [ ] <NEWLINE> self . buffered_block_length = 0 <NEWLINE> <DEDENT> <DEDENT>
def test_scheme_config_error ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with self . assertRaises ( exc . ConfigurationError ) : <NEWLINE> <INDENT> ArcGIS ( <NEWLINE> <INDENT> username = <STRING> , <NEWLINE> password = <STRING> <NEWLINE> referer = <STRING> , <NEWLINE> scheme = <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> <DEDENT>
class CourseGrade ( models . Model ) : <NEWLINE> <INDENT> gp_id = models . CharField ( max_length = 50 ) <NEWLINE> <INDENT> course_code = models . CharField ( max_length = 20 ) <NEWLINE> <DEDENT> personid = models . ForeignKey ( Personinformation , unique = False ) <NEWLINE> sessionid = models . ForeignKey ( Academic_session , unique = False ) <NEWLINE> <DEDENT>
def vacuum ( api , q = False ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if not q : print api . deleteAndVacuum ( ) <NEWLINE> else : api . deleteAndVacuum ( ) <NEWLINE> return <NEWLINE> <DEDENT> except Exception as e : sys . stderr . write ( <STRING> % str ( e ) ) ; sys . exit ( 13 ) <NEWLINE> <DEDENT>
def write ( self bytes ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def wsgiWrite ( started ) : <NEWLINE> <INDENT> if not started : <NEWLINE> <INDENT> self . _sendResponseHeaders ( ) <NEWLINE> <DEDENT> self . request . write ( bytes ) <NEWLINE> <DEDENT> self . reactor . callFromThread ( wsgiWrite , self . started ) <NEWLINE> self . started = True <NEWLINE> <DEDENT>
class Fault ( Error ) : <NEWLINE> <INDENT> def __init__ ( this , faultCode , faultString , ** extra ) : <NEWLINE> this . faultCode = faultCode <NEWLINE> this . faultString = faultString <NEWLINE> def __repr__ ( this ) : <NEWLINE> return ( <NEWLINE> <INDENT> <STRING> % <NEWLINE> ( this . faultCode , repr ( this . faultString ) ) <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT>
class AndConnect ( Connecter ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def match ( self , entry ) : <NEWLINE> ret = ( self . left . match ( entry ) and <NEWLINE> self . right . match ( entry ) ) <NEWLINE> if self . neg : <NEWLINE> <INDENT> ret = not ret <NEWLINE> return ret <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> return <STRING> % ( str ( self . left ) , str ( self . right ) ) <NEWLINE> <DEDENT>
def execute ( code ) : <NEWLINE> <INDENT> exec code <NEWLINE> return value <NEWLINE> <DEDENT>
def _declare_rpc_exchange ( self , exchange , timeout ) : <NEWLINE> <INDENT> with ( self . _pika_engine . connection_without_confirmation_pool <NEWLINE> <INDENT> . acquire ( timeout = timeout ) ) as conn : <NEWLINE> try : <NEWLINE> self . _pika_engine . declare_exchange_by_channel ( <NEWLINE> <INDENT> conn . channel , <NEWLINE> self . _pika_engine . get_rpc_exchange_name ( <NEWLINE> <INDENT> exchange <NEWLINE> <DEDENT> ) , <STRING> , False <NEWLINE> <DEDENT> ) <NEWLINE> except pika_pool . Timeout as e : <NEWLINE> raise exceptions . MessagingTimeout ( <NEWLINE> <INDENT> <STRING> . format ( <NEWLINE> <INDENT> str ( e ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> <DEDENT>
class Datetime ( Validator ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , datetime_format ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> super ( Datetime , self ) . __init__ ( ) <NEWLINE> self . _format = datetime_format <NEWLINE> <DEDENT> def validate ( self , value , data ) : <NEWLINE> <INDENT> import datetime <NEWLINE> try : <NEWLINE> <INDENT> datetime . datetime . strptime ( value , self . _format ) <NEWLINE> <DEDENT> except ValueError , exc : <NEWLINE> <INDENT> error = <STRING> % ( self . _format , str ( exc ) ) <NEWLINE> self . put_msg ( error ) <NEWLINE> return False <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT> <DEDENT>
def runScreen ( self , arg ) : <NEWLINE> <INDENT> if arg [ 0 ] != <STRING> : <NEWLINE> <INDENT> exec <STRING> + arg [ 0 ] + <STRING> <NEWLINE> <DEDENT> self . openDialog ( * eval ( arg [ 1 ] ) ) <NEWLINE> <DEDENT>
def test_Tokens ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> f_tmpl = TMPLTemplate . TMPLTemplate ( self . __test_filename ) <NEWLINE> f_tmpl . init ( TMPLTemplate . __version__ , [ ] , [ <STRING> ] , { } ) <NEWLINE> self . assertEquals ( f_tmpl . _tokens , [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT>
class Generator ( object ) : <NEWLINE> <INDENT> def __init__ ( self , cmakeName , buildDir = <STRING> , sourceDir = <STRING> , binDir = <STRING> ) : <NEWLINE> <INDENT> self . cmakeName = cmakeName <NEWLINE> <INDENT> self . buildDir = buildDir <NEWLINE> <DEDENT> self . sourceDir = sourceDir <NEWLINE> self . binDir = binDir <NEWLINE> <DEDENT> def getBuildDir ( self , target ) : <NEWLINE> <INDENT> return self . buildDir <NEWLINE> <DEDENT> def getBinDir ( self , target = <STRING> ) : <NEWLINE> <INDENT> return self . binDir <NEWLINE> <DEDENT> def getSourceDir ( self ) : <NEWLINE> <INDENT> return self . sourceDir <NEWLINE> <DEDENT> <DEDENT>
class FakeClientParserWithReactor ( PluginBase ) : <NEWLINE> <INDENT> def parseStreamClient ( self , * a , ** kw ) <NEWLINE> <INDENT> return StreamClient ( self , a , kw ) <NEWLINE> <DEDENT> <DEDENT>
def _get_storage_url ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> storage_url = self . store . _get_endpoint ( self . context ) <NEWLINE> if self . image : <NEWLINE> <INDENT> storage_url = storage_url . replace ( self . context . tenant , self . image [ <STRING> ] ) <NEWLINE> <DEDENT> return storage_url <NEWLINE> <DEDENT> except ( exceptions . BadStoreConfiguration , <NEWLINE> <INDENT> ks_exceptions . EndpointNotFound ) as e : <NEWLINE> LOG . debug ( <STRING> <NEWLINE> <INDENT> <STRING> , e ) <NEWLINE> return self . location . swift_url <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def main ( tree , n , out , seed ) : <NEWLINE> <INDENT> random . seed ( seed ) <NEWLINE> with open ( out , <STRING> ) as tfh : <NEWLINE> <INDENT> for tree in iter_trees ( tree ) : <NEWLINE> <INDENT> subtree = scaled_subsample ( t , n , seed = random . random ( ) <NEWLINE> print ( subtree , file = tfh ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_temperature_conversion ( self ) <NEWLINE> <INDENT> original_C = 25.5 <NEWLINE> f = misc_utils . celsius_to_fahrenheit ( original_C ) <NEWLINE> back_to_C = misc_utils . fahrenheit_to_celsius ( f ) <NEWLINE> assert ( str ( original_C ) == str ( back_to_C ) ) <NEWLINE> original_F = 93.2 <NEWLINE> c = misc_utils . fahrenheit_to_celsius ( original_F ) <NEWLINE> back_to_F = misc_utils . celsius_to_fahrenheit ( c ) <NEWLINE> assert ( original_F == back_to_F ) <NEWLINE> <DEDENT>
def status ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> pf = file ( self . pidfile , <STRING> ) <NEWLINE> pid = int ( pf . read ( ) . strip ( ) ) <NEWLINE> pf . close ( ) <NEWLINE> <DEDENT> except IOError : <NEWLINE> <INDENT> pid = None <NEWLINE> <DEDENT> if not pid : <NEWLINE> <INDENT> message = <STRING> <NEWLINE> <INDENT> log . message ( message , log . INFO ) <NEWLINE> <DEDENT> print ( message ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> message = <STRING> + str ( pid ) <NEWLINE> <INDENT> log . message ( message , log . INFO ) <NEWLINE> <DEDENT> print ( message ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT>
def get_row_data ( entry , remove_from_triage ) : <NEWLINE> <INDENT> dict = { } <NEWLINE> for key in entry . custom : <NEWLINE> <INDENT> if key == TRIAGE_PORTAL_KEY <NEWLINE> <INDENT> if remove_from_triage == <STRING> : <NEWLINE> <INDENT> dict [ key ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dict [ key ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif key == MSK_AUTOMATION_PORTAL_KEY : <NEWLINE> <INDENT> dict [ key ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dict [ key ] = entry . custom [ key ] . text <NEWLINE> <DEDENT> <DEDENT> return dict <NEWLINE> <DEDENT>
def visit_exdefs ( self , node ) : <NEWLINE> <INDENT> self . symplace = { } <NEWLINE> for ch in node . children : <NEWLINE> <INDENT> syms = [ x . strip ( ) for x in ch . arg . split ( <STRING> ) ] <NEWLINE> for sym in syms : <NEWLINE> self . symplace [ sym ] = ch . tag <NEWLINE> <DEDENT> <DEDENT>
def fib ( n ) : <NEWLINE> <INDENT> if n < 1 : raise ValueError , <STRING> <NEWLINE> else : <NEWLINE> <INDENT> return fib ( n - 1 ) + fib ( n - 2 ) <NEWLINE> <DEDENT> <DEDENT>
class FeatureCompleteFundamentalRule ( FeatureSingleEdgeFundamentalRule ) : <NEWLINE> <INDENT> def _apply_incomplete ( self , chart , grammar , left_edge ) : <NEWLINE> <INDENT> fr = self . _fundamental_rule <NEWLINE> end = left_edge . end ( ) <NEWLINE> for right_edge in chart . select ( start = end , end = end , <NEWLINE> <INDENT> is_complete = True , <NEWLINE> lhs = left_edge . next ( ) ) : <NEWLINE> for new_edge in fr . apply_iter ( chart , grammar , left_edge , right_edge ) : <NEWLINE> yield new_edge <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def delete_file_from_rbd ( ssh_ip , file_path ) : <NEWLINE> <INDENT> with settings ( host_string = ssh_ip , <NEWLINE> <INDENT> connection_attempts = env . connection_attempts ) : <NEWLINE> with utils . forward_agent ( env . key_filename ) : <NEWLINE> run ( <STRING> % file_path ) <NEWLINE> <DEDENT> <DEDENT>
def _get_socket ( self , port , host , timeout ) : <NEWLINE> <INDENT> if self . debuglevel > 0 : print <STRING> , ( host , port ) <NEWLINE> return socket . create_connection ( ( port , host ) , timeout ) <NEWLINE> <DEDENT>
( <STRING> . format ( fname ) <NEWLINE> traceback . print_exc ( ) <NEWLINE> print ( 80 * <STRING> ) <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> sys . stdout = self . stdout <NEWLINE> os . chdir ( cwd ) <NEWLINE> ncol = gc . collect ( ) <NEWLINE> if self . print_output and ( ncol > 0 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( ncol ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def p_bullet ( p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if len ( p ) == 3 : <NEWLINE> if p [ 2 ] . startswith ( <STRING> ) : <NEWLINE> <INDENT> p [ 0 ] = <STRING> + p [ 1 ] + p [ 2 ] [ len ( <STRING> ) : ] + <STRING> <NEWLINE> else : <NEWLINE> p [ 0 ] = <STRING> + p [ 1 ] + <STRING> + p [ 2 ] + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> p [ 0 ] = <STRING> + p [ 1 ] + <STRING> + p [ 3 ] + <STRING> <NEWLINE> parser_verbose ( p ) <NEWLINE> <DEDENT>
def configure_random ( self , num_orgs , seed = None ) : <NEWLINE> <INDENT> if not seed : <NEWLINE> <INDENT> seed = random . randrange ( 0 , 65536 ) <NEWLINE> <DEDENT> self . random = random . Random ( seed ) <NEWLINE> from temba . utils import models <NEWLINE> models . uuid4 = lambda : uuid . UUID ( int = self . random . getrandbits ( 128 ) <NEWLINE> self . org_bias = math . log ( 1.0 / num_orgs , 0.5 ) <NEWLINE> return seed <NEWLINE> <DEDENT>
def test_port_vif_non_admin ( self ) : <NEWLINE> <INDENT> with self . network ( set_context = True , <NEWLINE> <INDENT> tenant_id = <STRING> ) as net1 : <NEWLINE> with self . subnet ( network = net1 ) as subnet1 : <NEWLINE> host_arg = { portbindings . HOST_ID : self . hostname } <NEWLINE> try : <NEWLINE> with self . port ( subnet = subnet1 , <NEWLINE> <INDENT> expected_res_status = 403 , <NEWLINE> arg_list = ( portbindings . HOST_ID , ) , <NEWLINE> set_context = True , <NEWLINE> tenant_id = <STRING> , <NEWLINE> ** host_arg ) : <NEWLINE> pass <NEWLINE> except exc . HTTPClientError : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def install_except_hook ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def log_exception ( exc_type , exc_value , exc_traceback ) : <NEWLINE> <INDENT> if not issubclass ( exc_type , KeyboardInterrupt ) : <NEWLINE> <INDENT> log . critical ( <STRING> , exc_info = ( exc_type , exc_value <NEWLINE> <INDENT> exc_traceback ) ) <NEWLINE> <DEDENT> <DEDENT> sys . __excepthook__ ( exc_type , exc_value , exc_traceback ) <NEWLINE> <DEDENT> sys . excepthook = log_exception <NEWLINE> <DEDENT>
def spacesForWin32HeapSegment ( segment ) : <NEWLINE> <INDENT> spaces = [ ] <NEWLINE> for chunk in segment . getChunks ( ) : <NEWLINE> <INDENT> if chunk . isBusy ( ) : <NEWLINE> <INDENT> color = ( 0xff , 0 , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> color = ( 0 , 0xff , 0 ) <NEWLINE> <DEDENT> spaces . append ( ( chunk . address , len ( chunk ) , color , <STRING> ) <NEWLINE> <DEDENT> return spaces <NEWLINE> <DEDENT>
def printUploads ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . uploads != [ ] : <NEWLINE> sys . stderr . write ( <STRING> ) <NEWLINE> for up in self . uploads : <NEWLINE> <INDENT> print ( up ) <NEWLINE> <DEDENT> <DEDENT>
def run_test5 ( self ) : <NEWLINE> <INDENT> dpid = datapathid . from_host ( 1 ) <NEWLINE> port = 1 <NEWLINE> if ( self . debug ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> self . bs . remove_name_for_location ( dpid , port , <STRING> , Name . LOCATION ) <NEWLINE> self . next_fn = self . run_test6 <NEWLINE> self . wait_count = 1 <NEWLINE> <DEDENT>
def translate ( in_fp , out_fp ) : <NEWLINE> <INDENT> with open ( in_fp , <STRING> ) as tgrep2 : <NEWLINE> with open ( out_fp , <STRING> ) as penn : <NEWLINE> <INDENT> for line in tgrep2 : <NEWLINE> <INDENT> penn . write ( re . sub ( <STRING> , <STRING> , line ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def invalidate_tables ( self , database , tables ) : <NEWLINE> <INDENT> handle = None <NEWLINE> for table in tables : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> hql = <STRING> % ( database , table , ) <NEWLINE> query = hql_query ( hql , database , query_type = QUERY_TYPES [ 1 ] ) <NEWLINE> handle = self . execute_and_wait ( query , timeout_sec = 10.0 ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> LOG . warn ( <STRING> % smart_str ( e ) ) <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> if handle : <NEWLINE> <INDENT> self . close ( handle ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def getReviewStateTitle ( self ) : <NEWLINE> <INDENT> reviewState = self . getReviewState ( ) <NEWLINE> reviewStateTitle = self . portal_workflow . getTitleForStateOnType ( reviewState , <STRING> ) <NEWLINE> <INDENT> return reviewStateTitle <NEWLINE> <DEDENT> <DEDENT>
def format_dict ( data , markup ) : <NEWLINE> <INDENT> parser = Parser ( markup . lower ( ) <NEWLINE> formatted_data = parser . dump ( data ) <NEWLINE> if markup == <STRING> : <NEWLINE> <INDENT> formatted_data = <STRING> . join ( [ <STRING> , formatted_data ] ) <NEWLINE> <DEDENT> return formatted_data <NEWLINE> <DEDENT>
( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>
class PoiAttributes ( models . Model ) : <NEWLINE> <INDENT> name = models . CharField ( max_length = 60 ) <NEWLINE> category = models . CharField ( max_length = 60 ) <NEWLINE> url = models . CharField ( max_length = 60 ) <NEWLINE> openHours = ListField ( EmbeddedModelField ( <STRING> ) ) <NEWLINE> fee = ListField ( EmbeddedModelField ( <STRING> ) ) <NEWLINE> tags = ListField ( models . CharField ( max_length = 60 ) <NEWLINE> coords = ListField ( models . DecimalField ( ) ) <NEWLINE> city = EmbeddedModelField ( <STRING> ) <NEWLINE> <DEDENT>
def check_dependencies ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> ) <NEWLINE> for cmd , url in [ ( <STRING> , <STRING> ) , <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) ] : <NEWLINE> try : <NEWLINE> retcode = subprocess . call ( [ cmd , <STRING> ] , stdout = subprocess . PIPE , stderr = subprocess . STDOUT ) <NEWLINE> except OSError : <NEWLINE> retcode = 127 <NEWLINE> if retcode == 127 : <NEWLINE> raise OSError ( <STRING> % ( cmd , url ) ) <NEWLINE> else : <NEWLINE> print ( <STRING> % cmd ) <NEWLINE> <DEDENT> <DEDENT>
def WriteFile ( platform , hFile , lpBuffer , nNumberOfBytesToWrite , lpNumberOfBytesWritten , lpOverlapped ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> logger . info ( <STRING> % ( <NEWLINE> toStr ( platform , hFile ) , <NEWLINE> toStr ( platform , lpBuffer ) , <NEWLINE> toStr ( platform , nNumberOfBytesToWrite ) , <NEWLINE> toStr ( platform , lpNumberOfBytesWritten ) , <NEWLINE> toStr ( platform , lpOverlapped ) ) <NEWLINE> <DEDENT>
def setup_control_rack ( self , track ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . remove_control_rack ( ) <NEWLINE> for dev in track . devices : <NEWLINE> <INDENT> dev_name = self . _parent . get_name ( dev . name ) <NEWLINE> if dev . class_name . endswith ( <STRING> ) and dev_name . startswith ( <STRING> ) : <NEWLINE> self . _control_rack = dev <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
def get_model_class ( table_name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> classmap = dict ( ( m . _meta . db_table , m ) for m in models . get_models ( ) <NEWLINE> if table_name in classmap : <NEWLINE> <INDENT> return classmap [ table_name ] <NEWLINE> <DEDENT> <DEDENT>
def load_matrix ( self , termList , period ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> matrix = SymmetricMatrix ( termList ) <NEWLINE> try : <NEWLINE> <INDENT> generator = self . storage . selectCorpusGraphPreprocess ( period , <STRING> ) <NEWLINE> while 1 : <NEWLINE> <INDENT> ngi , row = generator . next ( ) <NEWLINE> for ngj in row . iterkeys ( ) : <NEWLINE> <INDENT> matrix . set ( ngi , ngj , value = row [ ngj ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except StopIteration , si : <NEWLINE> <INDENT> return matrix <NEWLINE> <DEDENT> <DEDENT>
def http_daemon_thread ( self ) : <NEWLINE> <INDENT> logger . info ( <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> self . http_daemon . run ( ) <NEWLINE> <DEDENT> except Exception , exp : <NEWLINE> <INDENT> logger . error ( <STRING> , str ( exp ) ) <NEWLINE> output = cStringIO . StringIO ( ) <NEWLINE> traceback . print_exc ( file = output ) <NEWLINE> logger . error ( <STRING> , output . getvalue ( ) ) <NEWLINE> output . close ( ) <NEWLINE> self . do_stop ( ) <NEWLINE> os . _exit ( 2 ) <NEWLINE> <DEDENT> <DEDENT>
( not any ( ( s . name == <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def get_ttype ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . D . has_key ( <STRING> ) : <NEWLINE> <INDENT> return self . D [ <STRING> ] <NEWLINE> <INDENT> else : <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT> <DEDENT>
class LTRect ( LTPolygon ) : <NEWLINE> <INDENT> def __init__ ( self , linewidth , ( x0 , y0 , x1 , y1 ) ) : <NEWLINE> <INDENT> LTPolygon . __init__ ( self , linewidth , [ ( x0 , y0 ) , ( x1 , y0 ) , ( x1 , y1 ) , ( x0 , y1 ) ] ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT>
def read ( self , size = None ) : <NEWLINE> <INDENT> if size is None : <NEWLINE> <INDENT> size = self . len - self . pos <NEWLINE> <DEDENT> if size + self . pos > self . len : <NEWLINE> <INDENT> size = self . len - self . pos <NEWLINE> <DEDENT> txt = self . fh . read ( size ) <NEWLINE> self . pos += len ( txt ) <NEWLINE> if self . debug : <NEWLINE> <INDENT> print <STRING> % ( size , self . pos , repr ( txt ) ) <NEWLINE> <DEDENT> return txt <NEWLINE> <DEDENT>
def _get_command_doc_notes ( cmd ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( cmd . maxsplit is not None or cmd . no_cmd_split or <NEWLINE> <INDENT> cmd . no_replace_variables and cmd . name != <STRING> ) : <NEWLINE> yield <STRING> <NEWLINE> yield <STRING> <NEWLINE> if cmd . maxsplit is not None : <NEWLINE> yield ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> if cmd . no_cmd_split : <NEWLINE> <DEDENT> yield ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> if cmd . no_replace_variables and cmd . name != <STRING> : <NEWLINE> <DEDENT> yield <STRING> <NEWLINE> <DEDENT> <DEDENT>
def _fill_corners ( self , _model ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> positions = list ( ) <NEWLINE> for polygon_model in _model : <NEWLINE> <INDENT> for point in polygon_model : <NEWLINE> <INDENT> if positions . count ( point ) == 0 : <NEWLINE> <INDENT> positions . append ( point ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for position in positions : <NEWLINE> <INDENT> self . corners . append ( corner . Corner ( self . _get_random_id ( ) , position ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self ) : <NEWLINE> <INDENT> Sensor . __init__ ( self ) <NEWLINE> <INDENT> self . __value = 0.0 <NEWLINE> self . __prev_value = 0.0 <NEWLINE> self . __velocity = 0.0 <NEWLINE> self . __init_value = 0.0 <NEWLINE> self . __time = 0.0 <NEWLINE> def on ( self ) : <NEWLINE> <DEDENT> self . __run = True <NEWLINE> <INDENT> threading . Thread ( target = self . __update ) . start ( ) <NEWLINE> def off ( self ) : <NEWLINE> <DEDENT> self . __run = False <NEWLINE> <DEDENT>
class SQLScalar ( WikiMacroBase ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def render_macro ( self , req , name , content ) : <NEWLINE> <INDENT> db = self . env . get_db_cnx ( ) <NEWLINE> cursor = db . cursor ( ) <NEWLINE> cursor . execute ( content ) <NEWLINE> value = <STRING> <NEWLINE> for row in cursor : <NEWLINE> value = unicode ( row [ 0 ] ) <NEWLINE> break <NEWLINE> out = StringIO ( ) <NEWLINE> print ( <STRING> % value ) <NEWLINE> add_stylesheet ( req , <STRING> ) <NEWLINE> return Markup ( out . getvalue ( ) ) <NEWLINE> <DEDENT> <DEDENT>
def parse_snap ( self , response ) : <NEWLINE> <INDENT> item = response . meta [ <STRING> ] <NEWLINE> item [ <STRING> ] = json . loads ( response . body . decode ( <STRING> ) ) [ <STRING> ] <NEWLINE> LINE_URL = self . LINE_URLAPI . format ( item [ <STRING> ] ) <NEWLINE> <INDENT> return scrapy . Request ( LINE_URL , callback = self . parse_line , meta = { <STRING> : item } ) <NEWLINE> <DEDENT> <DEDENT>
def _adjust_pad_volume ( self , pads , action_arg ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for pad in pads : <NEWLINE> <INDENT> if pad . chains : <NEWLINE> self . _parent . do_parameter_adjustment ( pad . chains [ 0 ] . mixer_device . volume , action_arg ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self ) : <NEWLINE> <INDENT> self . pub = rospy . Publisher ( <STRING> , Vector3 , queue_size = 10 ) <NEWLINE> <INDENT> rospy . init_node ( <STRING> , anonymous = True ) <NEWLINE> self . jsdev = joystick_read . connect ( joyname ) <NEWLINE> self . x = 0 <NEWLINE> self . y = 0 <NEWLINE> self . z = 0 <NEWLINE> self . k = 25 <NEWLINE> <DEDENT> <DEDENT>
