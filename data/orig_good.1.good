from distutils . core import setup <NEWLINE> __version__ = <STRING> <NEWLINE> setup ( name = <STRING> , <NEWLINE> <INDENT> version = __version__ , <NEWLINE> description = <STRING> , <NEWLINE> author = <STRING> , <NEWLINE> license = <STRING> , <NEWLINE> url = <STRING> , <NEWLINE> download_url = <STRING> , <NEWLINE> ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import itertools , struct <NEWLINE> import dpkt <NEWLINE>
def parse_title ( lines ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> TITLE_PREFIX = <STRING> <NEWLINE> book_title = None <NEWLINE> if lines [ 0 ] . startswith ( TITLE_PREFIX ) : <NEWLINE> <INDENT> book_title = lines . pop ( 0 ) [ len ( TITLE_PREFIX ) : ] . strip ( ) <NEWLINE> <DEDENT> return book_title <NEWLINE> <DEDENT>
def printer5 ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( x ) <NEWLINE> <DEDENT>
class StatusType ( SurrogatePK , Model ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> __tablename__ = <STRING> <NEWLINE> name = Column ( db . String ( 10 ) , nullable = False ) <NEWLINE> status = Column ( db . String ( 80 ) , nullable = False ) <NEWLINE> def __init__ ( self , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> db . Model . __init__ ( self , ** kwargs ) <NEWLINE> <DEDENT> def __repr__ ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return <STRING> . format ( name = self . name ) <NEWLINE> <DEDENT> <DEDENT>
def binary ( request , name ) : <NEWLINE> <INDENT> binary = get_object_or_404 ( Binary , name = name ) <NEWLINE> versions = binary . generated_binaries . values_list ( <NEWLINE> <INDENT> <STRING> , flat = True , <NEWLINE> <DEDENT> ) . order_by ( <STRING> ) . distinct ( ) <NEWLINE> return render ( request , <STRING> , { <NEWLINE> <INDENT> <STRING> : binary , <NEWLINE> <STRING> : versions , <NEWLINE> <DEDENT> } ) <NEWLINE> <DEDENT>
def _fetch_url_data ( self , url , username , password , verify ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> auth = ( username , password ) <NEWLINE> url = <STRING> % ( url , STATS_URL ) <NEWLINE> self . log . debug ( <STRING> % url ) <NEWLINE> response = requests . get ( url , auth = auth , headers = headers ( self . agentConfig ) , verify = verify , timeout = self . default_integration_http_timeout ) <NEWLINE> response . raise_for_status ( ) <NEWLINE> return response . content . splitlines ( ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import string <NEWLINE> try : <NEWLINE> <INDENT> from secrets import choice <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> from random import choice <NEWLINE> <DEDENT>
import unittest <NEWLINE> import os <NEWLINE> import time <NEWLINE> import librepo <NEWLINE> from tests . base import TestCase , TEST_DATA <NEWLINE> REPO_YUM_01_PATH = TEST_DATA + <STRING> <NEWLINE>
def array2d ( X , dtype = None , order = None , copy = False , force_all_finite = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> X_2d = np . asarray ( np . atleast_2d ( X ) , dtype = dtype , order = order ) <NEWLINE> if force_all_finite : <NEWLINE> <INDENT> _assert_all_finite ( X_2d ) <NEWLINE> <DEDENT> if X is X_2d and copy : <NEWLINE> <INDENT> X_2d = _safe_copy ( X_2d ) <NEWLINE> <DEDENT> return X_2d <NEWLINE> <DEDENT>
import os <NEWLINE> import unittest <NEWLINE> from byro . rms import RMS <NEWLINE>
def drawpaths ( self , f , paths ) : <NEWLINE> <INDENT> for path in paths : <NEWLINE> <INDENT> self . drawPolyline ( f , path [ : - 1 ] , strokeColor = path [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
class GenericTest ( unittest . TestCase ) : <NEWLINE> <INDENT> def setUp ( self ) : <NEWLINE> <INDENT> self . parser = argparse . ArgumentParser ( ) <NEWLINE> self . sub_parsers = self . parser . add_subparsers ( ) <NEWLINE> pass <NEWLINE> <DEDENT> def test_illegal ( self ) : <NEWLINE> <INDENT> with self . assertRaises ( SystemExit ) : <NEWLINE> <INDENT> self . parser . parse_args ( [ <STRING> ] ) <NEWLINE> pass <NEWLINE> <DEDENT> pass <NEWLINE> <DEDENT> pass <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import ctypes <NEWLINE> import OpenGL <NEWLINE> from OpenGL . arrays . arraydatatype import * <NEWLINE> from OpenGL . arrays import formathandler <NEWLINE>
import pygame <NEWLINE> from guilib import get_default <NEWLINE> from Lib . Point import Point <NEWLINE>
import os <NEWLINE> from mako . template import Template <NEWLINE> from mako . lookup import TemplateLookup <NEWLINE>
def _ResizeFile ( self , file_path , file_size ) : <NEWLINE> <INDENT> logging . debug ( <STRING> , file_path , file_size ) <NEWLINE> with open ( file_path , <STRING> ) as disk_file : <NEWLINE> <INDENT> disk_file . truncate ( file_size ) <NEWLINE> <DEDENT> <DEDENT>
def submit_history_entry ( user_id , exercise_id , sets , reps , weight , exercise_date ) : <NEWLINE> <INDENT> entry_to_add = RepExercisesHistory ( <NEWLINE> <INDENT> user_id = user_id , <NEWLINE> exercise_id = exercise_id , <NEWLINE> sets = sets , <NEWLINE> reps = reps , <NEWLINE> weight = weight , <NEWLINE> date = exercise_date <NEWLINE> <DEDENT> ) <NEWLINE> RepExercisesHistoryService . add_entry_to_db ( entry_to_add ) <NEWLINE> return entry_to_add <NEWLINE> <DEDENT>
import eg <NEWLINE> eg . RegisterPlugin ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> author = <STRING> , <NEWLINE> guid = <STRING> , <NEWLINE> version = <STRING> , <NEWLINE> canMultiLoad = True , <NEWLINE> description = <STRING> , <NEWLINE> <DEDENT> ) <NEWLINE>
import sys <NEWLINE> reload ( sys ) <NEWLINE> sys . setdefaultencoding ( <STRING> ) <NEWLINE> from io import open <NEWLINE> from tqdm import tqdm <NEWLINE> import requests <NEWLINE> from itertools import chain <NEWLINE> import json <NEWLINE> from nltk import sent_tokenize <NEWLINE> import string <NEWLINE> import re <NEWLINE> import unicodedata <NEWLINE> UNK = <STRING> <NEWLINE> START = <STRING> <NEWLINE> END = <STRING> <NEWLINE> PAD = <STRING> <NEWLINE>
def Args ( parser ) : <NEWLINE> <INDENT> parser . add_argument ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> metavar = <STRING> , <NEWLINE> nargs = <STRING> , <NEWLINE> default = [ ] , <NEWLINE> completion_resource = <STRING> , <NEWLINE> help = ( <STRING> <NEWLINE> <INDENT> <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> regexp = parser . add_argument ( <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> help = <STRING> ) <NEWLINE> <DEDENT> regexp . detailed_help = <STRING> <NEWLINE> <DEDENT>
def testLinkedPointsPairEdgesFloatResult ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . _runTest ( ids = [ 1 , 2 ] , edges = [ 2 , 1 ] , weights = [ [ 1 , 1 ] , [ 2 , 2 ] ] , <NEWLINE> <INDENT> starts = [ 1 , 5 ] , expAverage = 1.5 ) <NEWLINE> <DEDENT> <DEDENT>
import argparse , json , logging , logging . config , os <NEWLINE> import telebot <NEWLINE> import config <NEWLINE> import version <NEWLINE> import plugins <NEWLINE> API_TOKEN = <STRING> <NEWLINE> logger = logging . getLogger ( ) <NEWLINE>
from __future__ import absolute_import <NEWLINE> from . dnn import DNN <NEWLINE> from . generator import SequenceGenerator <NEWLINE>
import os , schedule , time , PyPDF2 , re <NEWLINE> tmp = <STRING> <NEWLINE> pdf_folder = <STRING> <NEWLINE> txt_folder = <STRING> <NEWLINE> count = [ ] <NEWLINE>
import sys <NEWLINE> from servers . SAP import SAPserver <NEWLINE> server = SAPserver ( ) <NEWLINE> genomeID = <STRING> <NEWLINE> sys . stderr . write ( <STRING> + str ( genomeID ) + <STRING> ) <NEWLINE> prots = server . all_proteins ( { <STRING> : genomeID } ) <NEWLINE> print ( <STRING> + str ( len ( prots ) ) ) <NEWLINE>
class User ( models . Model ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> user_id = models . CharField ( max_length = 22 , primary_key = True ) <NEWLINE> majorcode = models . CharField ( max_length = 15 ) <NEWLINE> minorcode = models . CharField ( max_length = 15 ) <NEWLINE> def __unicode__ ( self ) : <NEWLINE> <INDENT> return self . user_id <NEWLINE> <DEDENT> <DEDENT>
class FakePlugin ( object ) : <NEWLINE> <INDENT> def loadTestsFromModule ( self , event ) : <NEWLINE> <INDENT> event . fake = True <NEWLINE> <DEDENT> def loadTestsFromNames ( self , event ) : <NEWLINE> <INDENT> event . fake = True <NEWLINE> <DEDENT> <DEDENT>
from telemetry . web_perf . metrics import single_event <NEWLINE> EVENT_NAME = <STRING> <NEWLINE> METRIC_NAME = <STRING> <NEWLINE>
def test_find ( ) : <NEWLINE> <INDENT> buf = CircularBuffer ( 32 ) <NEWLINE> buf . write ( <STRING> ) <NEWLINE> assert buf . find ( <STRING> ) == 4 <NEWLINE> assert buf . find ( <STRING> ) == - 1 <NEWLINE> assert buf . find ( <STRING> , 5 ) == 10 <NEWLINE> buf . clear ( ) <NEWLINE> buf . write ( <STRING> ) <NEWLINE> assert buf . find ( <STRING> ) == 4 <NEWLINE> assert buf . find ( <STRING> ) == - 1 <NEWLINE> assert buf . find ( <STRING> , 5 ) == 10 <NEWLINE> with raises ( ValueError ) : <NEWLINE> <INDENT> buf . find ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class SecurityRoot ( object ) : <NEWLINE> <INDENT> __acl__ = [ <NEWLINE> <INDENT> ( Allow , Authenticated , <STRING> ) , <NEWLINE> ( Allow , <STRING> , <STRING> ) , <NEWLINE> ( Allow , <STRING> , ALL_PERMISSIONS ) , <NEWLINE> DENY_ALL <NEWLINE> <DEDENT> ] <NEWLINE> def __init__ ( self , request ) : <NEWLINE> <INDENT> self . request = request <NEWLINE> <DEDENT> <DEDENT>
def upgrade ( ) : <NEWLINE> <INDENT> template_history_insert = <STRING> <NEWLINE> template_insert = <STRING> <NEWLINE> template_content = <STRING> <NEWLINE> template_name = <STRING> <NEWLINE> op . execute ( template_history_insert . format ( template_id , <NEWLINE> <INDENT> template_name , <NEWLINE> <STRING> , <NEWLINE> datetime . utcnow ( ) , template_content , <NEWLINE> service_id , <NEWLINE> template_name , user_id ) ) <NEWLINE> <DEDENT> op . execute ( template_insert . format ( template_id , <NEWLINE> <INDENT> template_name , <NEWLINE> <STRING> , <NEWLINE> datetime . utcnow ( ) , <NEWLINE> template_content , <NEWLINE> service_id , <NEWLINE> template_name , user_id ) ) <NEWLINE> <DEDENT> <DEDENT>
class MistTest ( Base ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> __tablename__ = <STRING> <NEWLINE> id = Column ( Integer , primary_key = True ) <NEWLINE> name = Column ( String , unique = True , index = True , nullable = False ) <NEWLINE> type = Column ( MistTestType . db_type ( ) , nullable = False ) <NEWLINE> def __repr__ ( self ) : <NEWLINE> <INDENT> return <STRING> . format ( <NEWLINE> <INDENT> id = self . id , <NEWLINE> type = self . type , <NEWLINE> name = self . name ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from distutils . core import setup <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> version = <STRING> , <NEWLINE> packages = [ <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> ] , <NEWLINE> <DEDENT> url = <STRING> , <NEWLINE> license = <STRING> , <NEWLINE> author = <STRING> , <NEWLINE> author_email = <STRING> , <NEWLINE> description = <STRING> <NEWLINE> <DEDENT> ) <NEWLINE>
<STRING> <NEWLINE> from __future__ import division , print_function , absolute_import <NEWLINE> __docformat__ = <STRING> <NEWLINE> __all__ = [ <STRING> , <STRING> ] <NEWLINE> from warnings import warn <NEWLINE> import numpy as np <NEWLINE> from scipy . lib . six import xrange , zip as izip <NEWLINE> from . _sparsetools import coo_tocsr , coo_todense , coo_matvec <NEWLINE> from . base import isspmatrix <NEWLINE> from . data import _data_matrix , _minmax_mixin <NEWLINE> from . sputils import ( upcast , upcast_char , to_native , isshape , getdtype , <NEWLINE> <INDENT> isintlike , get_index_dtype , downcast_intp_index , _compat_bincount ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from argparse import ArgumentParser <NEWLINE> import js2xml <NEWLINE>
def ChangeAlias ( exe , lib ) : <NEWLINE> <INDENT> cmd = qtPath + lib + <STRING> + lib + <STRING> + <STRING> + lib + <STRING> + lib + <STRING> + exe <NEWLINE> os . system ( <STRING> + cmd ) <NEWLINE> <DEDENT>
import os <NEWLINE> import sys <NEWLINE> possible_topdir = os . path . normpath ( os . path . join ( os . path . abspath ( __file__ ) , <NEWLINE> <INDENT> os . pardir , <NEWLINE> os . pardir , <NEWLINE> os . pardir ) ) <NEWLINE> <DEDENT> if os . path . exists ( os . path . join ( possible_topdir , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ) ) : <NEWLINE> sys . path . insert ( 0 , possible_topdir ) <NEWLINE> <DEDENT> from keystone . cmd import cli <NEWLINE> from keystone . common import environment <NEWLINE>
import uuid <NEWLINE> import json <NEWLINE> import subprocess as sp <NEWLINE> import os <NEWLINE> import time <NEWLINE> try : <NEWLINE> <INDENT> psi_location = os . environ [ <STRING> ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> raise KeyError ( <STRING> ) <NEWLINE> <DEDENT> psi_run = <STRING> + psi_location + <STRING> <NEWLINE>
def deploy_app ( self , app , stage , version ) : <NEWLINE> <INDENT> r = self . __session . put ( <NEWLINE> <INDENT> urljoin ( self . __api_uri , <STRING> . format ( app , stage , version ) ) , <NEWLINE> timeout = self . __timeout ) <NEWLINE> <DEDENT> r . raise_for_status ( ) <NEWLINE> <DEDENT>
def getHtml ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> htmlList = [ <STRING> ] <NEWLINE> htmlList = htmlList + font . getHtml ( self ) <NEWLINE> htmlList = htmlList + [ <STRING> ] <NEWLINE> return htmlList <NEWLINE> <DEDENT>
def createWriterDocument ( self ) : <NEWLINE> <INDENT> localContext = uno . getComponentContext ( ) <NEWLINE> resolver = localContext . ServiceManager . createInstanceWithContext ( <STRING> , localContext ) <NEWLINE> ctx = resolver . resolve ( <STRING> ) <NEWLINE> smgr = ctx . ServiceManager <NEWLINE> desktop = smgr . createInstanceWithContext ( <STRING> , ctx ) <NEWLINE> doc = desktop . getCurrentComponent ( ) <NEWLINE> if not hasattr ( doc , <STRING> ) : <NEWLINE> <INDENT> doc = desktop . loadComponentFromURL ( <STRING> , <STRING> , 0 , ( ) ) <NEWLINE> <DEDENT> return doc <NEWLINE> <DEDENT>
class superList ( list ) : <NEWLINE> <INDENT> def __sub__ ( self , b ) : <NEWLINE> <INDENT> a = self [ : ] <NEWLINE> b = b [ : ] <NEWLINE> while len ( b ) > 0 : <NEWLINE> <INDENT> element_b = b . pop ( ) <NEWLINE> if element_b in a : <NEWLINE> <INDENT> a . remove ( element_b ) <NEWLINE> <DEDENT> <DEDENT> return superList ( a ) <NEWLINE> <DEDENT> <DEDENT>
def __combine ( self , amnt_op , this_op , other ) : <NEWLINE> <INDENT> if isinstance ( other , _base_multiset ) : <NEWLINE> <INDENT> result = self . __class__ ( ) <NEWLINE> for element in chain ( self . __bag , other . __bag ) : <NEWLINE> <INDENT> amount = amnt_op ( self . count ( element ) , other . count ( element ) ) <NEWLINE> if amount > 0 : <NEWLINE> <INDENT> result . __bag [ element ] = amount <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <DEDENT> if isinstance ( other , Iterable ) : <NEWLINE> <INDENT> return this_op ( self , self . __class__ ( other ) ) <NEWLINE> <DEDENT> raise NotImplementedError ( ) <NEWLINE> <DEDENT>
def create_h_tunnel ( x1 , x2 , y ) : <NEWLINE> <INDENT> pts = [ ] <NEWLINE> for x in range ( min ( x1 , x2 ) , max ( x1 , x2 ) + 1 ) : <NEWLINE> <INDENT> pts . append ( Point ( x , y ) ) <NEWLINE> <DEDENT> return pts <NEWLINE> <DEDENT>
def temp_read ( pin_obj ) : <NEWLINE> <INDENT> if device_type == DEVICE_TYPE_MRAA : <NEWLINE> <INDENT> return pyupm_grove . GroveTemp ( pin_obj ) . value ( ) <NEWLINE> <DEDENT> elif device_type == DEVICE_TYPE_RPI : <NEWLINE> <INDENT> raise NotImplementedError <NEWLINE> <DEDENT> elif device_type == DEVICE_TYPE_GPI : <NEWLINE> <INDENT> return grovepi . temp ( pin_obj , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import unittest <NEWLINE> from itertools import chain <NEWLINE> from nineml . abstraction . dynamics import ( <NEWLINE> <INDENT> Dynamics , Regime , On , OutputEvent ) <NEWLINE> <DEDENT> from nineml . abstraction . ports import AnalogSendPort , AnalogReceivePort <NEWLINE> from nineml . abstraction . expressions import reserved_identifiers <NEWLINE>
class Client ( object ) : <NEWLINE> <INDENT> def get ( self , uri , ** kw ) : <NEWLINE> <INDENT> return self . request ( <STRING> , uri , ** kw ) <NEWLINE> <DEDENT> def post ( self , uri , ** kw ) : <NEWLINE> <INDENT> return self . request ( <STRING> , uri , ** kw ) <NEWLINE> <DEDENT> def head ( self , uri , ** kw ) : <NEWLINE> <INDENT> return self . request ( <STRING> , uri , ** kw ) <NEWLINE> <DEDENT> def put ( self , uri , ** kw ) : <NEWLINE> <INDENT> return self . request ( <STRING> , uri , ** kw ) <NEWLINE> <DEDENT> <DEDENT>
def test_vode ( self ) : <NEWLINE> <INDENT> for problem_cls in PROBLEMS : <NEWLINE> <INDENT> problem = problem_cls ( ) <NEWLINE> if problem . cmplx : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if not problem . stiff : <NEWLINE> <INDENT> self . _do_problem ( problem , <STRING> , <STRING> ) <NEWLINE> <DEDENT> self . _do_problem ( problem , <STRING> , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def test_linear_h ( ) : <NEWLINE> <INDENT> f = np . arange ( 9 ) . reshape ( ( 3 , 3 ) ) % 3 > 0 <NEWLINE> g = pymorph . patspec ( f , <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> srcPath = <STRING> <NEWLINE> binPath = <STRING> <NEWLINE> logPath = <STRING> <NEWLINE> shaderFormats = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ] <NEWLINE> <DEDENT> for format in shaderFormats : <NEWLINE> <INDENT> for shaderFile in glob . glob ( srcPath + format ) : <NEWLINE> <INDENT> shaderName = os . path . basename ( shaderFile ) <NEWLINE> os . system ( <STRING> . format ( <NEWLINE> <INDENT> srcPath + shaderName , <NEWLINE> binPath + shaderName + <STRING> , <NEWLINE> logPath + shaderName ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def test_internal_link_to_home_converted_to_index ( self ) : <NEWLINE> <INDENT> md_link = <STRING> <NEWLINE> doku_link = <STRING> <NEWLINE> self . assertEqual ( md_link , self . converter . convert ( doku_link ) ) <NEWLINE> <DEDENT>
class SrcClockDomain ( ClockDomain ) : <NEWLINE> <INDENT> type = <STRING> <NEWLINE> cxx_header = <STRING> <NEWLINE> clock = VectorParam . Clock ( <STRING> ) <NEWLINE> voltage_domain = Param . VoltageDomain ( <STRING> ) <NEWLINE> domain_id = Param . Int32 ( - 1 , <STRING> ) <NEWLINE> init_perf_level = Param . UInt32 ( 0 , <STRING> ) <NEWLINE> <DEDENT>
def GetOutputs ( cls ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for output_class in cls . _output_classes . itervalues ( ) : <NEWLINE> <INDENT> yield output_class . NAME , output_class . DESCRIPTION <NEWLINE> <DEDENT> <DEDENT>
from nose import with_setup <NEWLINE> from Panini import Pack <NEWLINE> import Panini <NEWLINE>
import logging <NEWLINE> import time <NEWLINE> from lib . orgproperty import OrgProperties <NEWLINE> from lib . orgformat import OrgFormat <NEWLINE> from lib . memacs import Memacs <NEWLINE>
def test_event_Parse_invalid ( self ) : <NEWLINE> <INDENT> e = mailpile . eventlog . Event . Parse ( <STRING> ) <NEWLINE> self . assertEqual ( e . __class__ , mailpile . eventlog . Event ) <NEWLINE> <DEDENT>
class IAsyncUtility ( Interface ) : <NEWLINE> <INDENT> async def initialize ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
def custom_exc ( shell , etype , evalue , tb , tb_offset = None ) : <NEWLINE> <INDENT> import traceback <NEWLINE> from p4 . interactive . excepthook import invoke_editor <NEWLINE> te = traceback . extract_tb ( tb ) <NEWLINE> shell . showtraceback ( ( etype , evalue , tb ) , tb_offset = tb_offset ) <NEWLINE> invoke_editor ( te ) <NEWLINE> <DEDENT>
def save_user_profile ( sender , instance , ** kwargs ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> instance . profile . save ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> Profile . objects . create ( user = instance ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> __version__ = <STRING> <NEWLINE> from . util import * <NEWLINE> from . obj import * <NEWLINE>
import numpy as np <NEWLINE> import pylab as pl <NEWLINE> import os , sys <NEWLINE> pl . rcParams [ <STRING> ] = 2 <NEWLINE> pl . rcParams [ <STRING> ] = 16 <NEWLINE> pl . rcParams [ <STRING> ] = 16 <NEWLINE> pl . rcParams [ <STRING> ] = 14 <NEWLINE> pl . rcParams [ <STRING> ] = 14 <NEWLINE> dataset = <STRING> <NEWLINE> if ( not os . path . isfile ( dataset ) ) : <NEWLINE> <INDENT> print ( <STRING> , dataset ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT>
class Class ( models . Model ) : <NEWLINE> <INDENT> name = models . CharField ( max_length = 4 , unique = True ) <NEWLINE> class Meta : <NEWLINE> <INDENT> verbose_name = <STRING> <NEWLINE> verbose_name_plural = <STRING> <NEWLINE> app_label = <STRING> <NEWLINE> <DEDENT> def __unicode__ ( self ) : <NEWLINE> <INDENT> return self . name <NEWLINE> <DEDENT> <DEDENT>
def test_greatest_common_divisor_zero ( self ) : <NEWLINE> <INDENT> actual = gcd . GreatestCommonDivisor . greatest_common_divisor ( 12 , 0 ) <NEWLINE> self . assertEqual ( 0 , actual ) <NEWLINE> actual = gcd . GreatestCommonDivisor . greatest_common_divisor ( 0 , 13 ) <NEWLINE> self . assertEqual ( 0 , actual ) <NEWLINE> actual = gcd . GreatestCommonDivisor . greatest_common_divisor ( - 5 , 13 ) <NEWLINE> self . assertEqual ( 0 , actual ) <NEWLINE> <DEDENT>
def close ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . state == <STRING> : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> self . decryptor = None <NEWLINE> self . source_fp = None <NEWLINE> self . state = <STRING> <NEWLINE> <DEDENT>
def authorize_landing ( self ) : <NEWLINE> <INDENT> if not self . available_runways : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> runway = self . available_runways . pop ( ) <NEWLINE> self . engaged_runways . append ( runway ) <NEWLINE> print ( <STRING> . format ( runway ) ) <NEWLINE> self . status ( ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT>
import antlr3 <NEWLINE> from CalculatorLexer import CalculatorLexer <NEWLINE> from CalculatorParser import CalculatorParser <NEWLINE> while True : <NEWLINE> <INDENT> expr = raw_input ( <STRING> ) <NEWLINE> if expr == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cStream = antlr3 . StringStream ( expr ) <NEWLINE> lexer = CalculatorLexer ( cStream ) <NEWLINE> tStream = antlr3 . CommonTokenStream ( lexer ) <NEWLINE> parser = CalculatorParser ( tStream ) <NEWLINE> result = parser . evaluate ( ) <NEWLINE> print ( result ) <NEWLINE> <DEDENT>
def __init__ ( self , name , email , password ) : <NEWLINE> <INDENT> self . name = name <NEWLINE> self . email = email <NEWLINE> self . password = password <NEWLINE> self . tasks = self . get_tasks ( ) <NEWLINE> <DEDENT>
import sets , os <NEWLINE> from galaxy import eggs <NEWLINE> from galaxy import jobs <NEWLINE> from galaxy . tools . parameters import DataToolParameter <NEWLINE>
from cx_Freeze import setup , Executable <NEWLINE> buildOptions = dict ( packages = [ <STRING> , <STRING> ] , excludes = [ ] ) <NEWLINE> executables = [ <NEWLINE> <INDENT> Executable ( <STRING> ) , <NEWLINE> Executable ( <STRING> ) <NEWLINE> <DEDENT> ] <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> version = <STRING> , <NEWLINE> author = <STRING> , <NEWLINE> author_email = <STRING> , <NEWLINE> packages = [ <STRING> , <STRING> ] , <NEWLINE> url = <STRING> , <NEWLINE> license = <STRING> , <NEWLINE> description = <STRING> , <NEWLINE> options = dict ( build_exe = buildOptions ) , <NEWLINE> executables = executables <NEWLINE> <DEDENT> ) <NEWLINE>
<STRING> <NEWLINE> from __future__ import absolute_import <NEWLINE> from . bounded import * <NEWLINE> from . gzippeddict import * <NEWLINE> from . node import * <NEWLINE>
def read_symbol_array ( path ) : <NEWLINE> <INDENT> with open ( path , <STRING> ) as f : <NEWLINE> <INDENT> return array . array ( <STRING> , map ( int , f . read ( ) . split ( ) ) ) <NEWLINE> <DEDENT> <DEDENT>
__author__ = <STRING> <NEWLINE> __copyright__ = <STRING> <NEWLINE> __credits__ = [ <STRING> ] <NEWLINE> __license__ = <STRING> <NEWLINE> __maintainer__ = <STRING> <NEWLINE> __email__ = <STRING> <NEWLINE> import os <NEWLINE> import sys <NEWLINE> import logging <NEWLINE> import tempfile <NEWLINE> from collections import defaultdict <NEWLINE> from comparem . aai_calculator import AAICalculator <NEWLINE> from biolib . common import concatenate_files , make_sure_path_exists <NEWLINE>
def test_show ( self ) : <NEWLINE> <INDENT> instance_id = 1 <NEWLINE> uuid = fakes . get_fake_uuid ( instance_id ) <NEWLINE> self . stubs . Set ( compute . api . API , <STRING> , <NEWLINE> <INDENT> fake_compute_get ( instance_id , uuid = uuid , <NEWLINE> <INDENT> vm_state = vm_states . ACTIVE ) ) <NEWLINE> <DEDENT> <DEDENT> res = self . _make_request ( self . base_url + <STRING> % uuid ) <NEWLINE> self . assertEqual ( res . status_int , 200 ) <NEWLINE> server = self . _get_server ( res . body ) <NEWLINE> addresses = self . _get_addresses ( server ) <NEWLINE> self . _check_addresses ( addresses , exists = True ) <NEWLINE> <DEDENT>
def getPartitionState ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . partitionState <NEWLINE> <DEDENT>
import csv <NEWLINE> from itertools import chain <NEWLINE> from collections import OrderedDict <NEWLINE> import random <NEWLINE>
def update ( self , screen , update_type , rects ) : <NEWLINE> <INDENT> screen . blit ( self . top_bar , ( 0 , 0 ) ) <NEWLINE> self . screen_objects . render ( screen ) <NEWLINE> update_all = ( update_type == BaseScreen . update_all ) <NEWLINE> self . list_view . render ( screen , update_all , rects ) <NEWLINE> <DEDENT>
class Detect ( object ) : <NEWLINE> <INDENT> def __init__ ( self , kp = None , desc = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . kp = kp <NEWLINE> self . desc = desc <NEWLINE> <DEDENT> <DEDENT>
class TabletProximityRec ( Structure ) : <NEWLINE> <INDENT> _fields_ = ( <NEWLINE> <INDENT> ( <STRING> , c_uint16 ) , <NEWLINE> ( <STRING> , c_uint16 ) , <NEWLINE> ( <STRING> , c_uint16 ) , <NEWLINE> ( <STRING> , c_uint16 ) , <NEWLINE> ( <STRING> , c_uint16 ) , <NEWLINE> ( <STRING> , c_uint16 ) , <NEWLINE> ( <STRING> , c_uint32 ) , <NEWLINE> ( <STRING> , c_uint64 ) , <NEWLINE> ( <STRING> , c_uint32 ) , <NEWLINE> ( <STRING> , c_uint8 ) , <NEWLINE> ( <STRING> , c_uint8 ) , <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
import mnist <NEWLINE> import numpy as np <NEWLINE> data = mnist . read ( <STRING> ) <NEWLINE> ( img , lab ) = next ( data ) <NEWLINE> ( img , lab ) = next ( data ) <NEWLINE> ( img , lab ) = next ( data ) <NEWLINE> mnist . show ( img ) <NEWLINE>
from __future__ import unicode_literals <NEWLINE> from django . apps import apps <NEWLINE> from django . conf import settings <NEWLINE> from django . utils . _os import safe_join <NEWLINE> from . globals import HACS_APP_NAME <NEWLINE> __author__ = <STRING> <NEWLINE> HACS_CACHE_SETTING_NAME = <STRING> <NEWLINE> HACS_FALLBACK_URLCONF = settings . ROOT_URLCONF <NEWLINE> HACS_GENERATED_URLCONF_DIR = safe_join ( apps . get_app_config ( HACS_APP_NAME ) . path , <STRING> ) <NEWLINE> HACS_SERIALIZED_ROUTING_DIR = None <NEWLINE> HACS_USER_OBJECT_QUERY_CALLABLE = <STRING> <NEWLINE> HACS_DEVELOPMENT_MODE = False <NEWLINE> HACS_AUTO_DISCOVER_URL_MODULE = [ <STRING> , ] <NEWLINE> HACS_AC_BYPASS = 0 <NEWLINE> HACS_ANONYMOUS_ROLE_NAME = <STRING> <NEWLINE> HACS_DEFAULT_STATE = <STRING> <NEWLINE> HACS_DEFAULT_STATES = ( <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> <NEWLINE> <DEDENT> ) <NEWLINE>
def _complete_python_while_typing ( self , document ) : <NEWLINE> <INDENT> char_before_cursor = document . char_before_cursor <NEWLINE> return document . text and ( <NEWLINE> <INDENT> char_before_cursor . isalnum ( ) or char_before_cursor in <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def constant ( val = 0.1 ) : <NEWLINE> <INDENT> p = Param ( val = val ) <NEWLINE> def _init ( shape , dtype ) : <NEWLINE> <INDENT> out = val * tf . ones ( shape , dtype = dtype ) <NEWLINE> out . for_print = <STRING> % p <NEWLINE> return out <NEWLINE> <DEDENT> return _init <NEWLINE> <DEDENT>
def get_wiki_syntax ( self ) : <NEWLINE> <INDENT> def revlink ( f , match , fullmatch ) : <NEWLINE> <INDENT> rev = match . split ( <STRING> , 1 ) [ 1 ] <NEWLINE> return self . _format_revision_link ( f , <STRING> , rev , rev , <NEWLINE> <INDENT> fullmatch ) <NEWLINE> <DEDENT> <DEDENT> yield ( <STRING> % ( <STRING> . join ( self . KEYWORDS ) , <NEWLINE> <INDENT> ChangesetModule . CHANGESET_ID ) , <NEWLINE> revlink ) <NEWLINE> <DEDENT> <DEDENT>
def setUp ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> Registry . create ( ) <NEWLINE> self . setup_application ( ) <NEWLINE> self . main_window = QtGui . QMainWindow ( ) <NEWLINE> Registry ( ) . register ( <STRING> , self . main_window ) <NEWLINE> self . form = ShortcutListForm ( ) <NEWLINE> <DEDENT>
def onPathmappingRemove ( self , button = None ) : <NEWLINE> <INDENT> builder = self . _builder <NEWLINE> treeviewPathmapping = builder . get_object ( <STRING> ) <NEWLINE> liststorePathmapping = builder . get_object ( <STRING> ) <NEWLINE> selection = treeviewPathmapping . get_selection ( ) <NEWLINE> store , selected_rows = selection . get_selected_rows ( ) <NEWLINE> for path in selected_rows : <NEWLINE> <INDENT> treeIter = liststorePathmapping . get_iter ( path ) <NEWLINE> localPath = liststorePathmapping . get_value ( treeIter , 0 ) <NEWLINE> remotePath = liststorePathmapping . get_value ( treeIter , 1 ) <NEWLINE> self . _path_mapping_manager . remove_path_mapping ( localPath , remotePath ) <NEWLINE> <DEDENT> <DEDENT>
class DNSForwardPolicy ( enum . Enum ) : <NEWLINE> <INDENT> ONLY = <STRING> <NEWLINE> FIRST = <STRING> <NEWLINE> <DEDENT>
def does_user_exist ( self , user_path , user_name , ** kwargs ) : <NEWLINE> <INDENT> node_path = <STRING> . format ( user_path . rstrip ( <STRING> ) , user_name . lstrip ( <STRING> ) ) <NEWLINE> return self . _does_node_exist ( node_path , <STRING> , ** kwargs ) <NEWLINE> <DEDENT>
from . import test_create_mgmtsystem <NEWLINE>
def environments_by_org ( self , orgId ) : <NEWLINE> <INDENT> path = <STRING> % orgId <NEWLINE> envs = self . server . GET ( path ) [ 1 ] <NEWLINE> return envs <NEWLINE> <DEDENT>
from django . conf . urls import patterns , include , url <NEWLINE> from django . contrib import admin <NEWLINE> urlpatterns = patterns ( <STRING> , <NEWLINE> <INDENT> url ( <STRING> , include ( admin . site . urls ) ) , <NEWLINE> url ( <STRING> , include ( <STRING> , namespace = <STRING> ) ) <NEWLINE> <DEDENT> ) <NEWLINE>
def cmd_quickbuffer ( data , buffer , command ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> match = QUICKBUFFER_REGEXP . match ( command ) <NEWLINE> if match : <NEWLINE> <INDENT> w . command ( buffer , <STRING> . format ( match . group ( 1 ) ) ) <NEWLINE> return w . WEECHAT_RC_OK_EAT <NEWLINE> <DEDENT> return w . WEECHAT_RC_OK <NEWLINE> <DEDENT>
<STRING> <NEWLINE> __author__ = <STRING> <NEWLINE> __copyright__ = <STRING> <NEWLINE> __credits__ = [ <STRING> ] <NEWLINE> __license__ = <STRING> <NEWLINE> __version__ = <STRING> <NEWLINE> __maintainer__ = <STRING> <NEWLINE> __email__ = <STRING> <NEWLINE> import numpy <NEWLINE> from os import remove <NEWLINE> from skbio . util import create_dir <NEWLINE> from unittest import TestCase , main <NEWLINE> from numpy . testing import assert_almost_equal <NEWLINE> from qiime . cluster_quality import clust_qual_ratio <NEWLINE>
def get_focusable_widget ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return ( True , self . _scale ) <NEWLINE> <DEDENT>
def get_filtered ( cls , service , filter_ ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> obj = systemglobal_auditnslogpolicy_binding ( ) <NEWLINE> option_ = options ( ) <NEWLINE> option_ . filter = filter_ <NEWLINE> response = obj . getfiltered ( service , option_ ) <NEWLINE> return response <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> <INDENT> raise e <NEWLINE> <DEDENT> <DEDENT>
def tearDown ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . symbolhandler . dump ( ) <NEWLINE> <DEDENT>
def test_bad_images_identified_in_sub_dirs ( self , imgdir ) : <NEWLINE> <INDENT> base = os . path . dirname ( str ( imgdir ) ) <NEWLINE> data = [ d for d in ImageVerifier . verify_gen ( base , [ <STRING> ] ) <NEWLINE> <INDENT> if d [ 0 ] . endswith ( <STRING> ) ] <NEWLINE> <DEDENT> assert len ( data [ 0 ] [ 1 ] ) == 5 <NEWLINE> <DEDENT>
def suite ( ) : <NEWLINE> <INDENT> suite = unittest . TestSuite ( ) <NEWLINE> suite . addTests ( TestDiGraph . suite ( ) ) <NEWLINE> suite . addTests ( TestHyGraph . suite ( ) ) <NEWLINE> suite . addTests ( TestParVec . suite ( ) ) <NEWLINE> suite . addTests ( TestSpParVec . suite ( ) ) <NEWLINE> return suite <NEWLINE> <DEDENT>
def test_descr ( ) : <NEWLINE> <INDENT> wtc = get_wtc ( ) <NEWLINE> eq_ ( wtc . get ( <STRING> ) . status_code , 200 ) <NEWLINE> <DEDENT>
class Tracklist ( BaseModel ) : <NEWLINE> <INDENT> mix = models . ForeignKey ( Mix , related_name = <STRING> ) <NEWLINE> index = models . SmallIntegerField ( ) <NEWLINE> timeindex = models . TimeField ( null = True ) <NEWLINE> description = models . CharField ( max_length = 255 ) <NEWLINE> artist = models . CharField ( max_length = 255 ) <NEWLINE> title = models . CharField ( max_length = 255 ) <NEWLINE> remixer = models . CharField ( max_length = 255 ) <NEWLINE> label = models . CharField ( max_length = 255 ) <NEWLINE> <DEDENT>
def send_log ( cls , type , in_data ) : <NEWLINE> <INDENT> data = json . dumps ( in_data , default = json_default , ensure_ascii = False ) <NEWLINE> message = <STRING> . format ( type , data ) <NEWLINE> with cls . socketLock : <NEWLINE> <INDENT> cls . socket . send ( message ) <NEWLINE> <DEDENT> <DEDENT>
def delete_pool_port ( context , backend_port ) : <NEWLINE> <INDENT> session = context . session <NEWLINE> with session . begin ( subtransactions = True ) : <NEWLINE> <INDENT> port = ( session . query ( nmodel . Port ) . filter_by ( <NEWLINE> <INDENT> id = backend_port [ <STRING> ] ) ) . first ( ) <NEWLINE> <DEDENT> if port : <NEWLINE> <INDENT> session . delete ( backend_port ) <NEWLINE> session . delete ( port ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def example ( request ) : <NEWLINE> <INDENT> context = { } <NEWLINE> if request . method == <STRING> : <NEWLINE> <INDENT> form = SimpleForm ( request . POST , request . FILES ) <NEWLINE> if form . is_valid ( ) : <NEWLINE> <INDENT> context [ <STRING> ] = <STRING> % ( <NEWLINE> <INDENT> form . cleaned_data [ <STRING> ] , <NEWLINE> form . cleaned_data [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> form = SimpleForm ( ) <NEWLINE> <DEDENT> context [ <STRING> ] = form <NEWLINE> return render_to_response ( <NEWLINE> <INDENT> <STRING> , context , context_instance = RequestContext ( request ) ) <NEWLINE> <DEDENT> <DEDENT>
import pygeoip <NEWLINE> import json <NEWLINE> import mixcoatl . utils <NEWLINE> import mixcoatl . resource <NEWLINE> import dcm_console_api <NEWLINE> from urlparse import urlparse <NEWLINE> config = dcm_console_api . APP_CONFIG <NEWLINE> uncamel = mixcoatl . utils . uncamel <NEWLINE> uncamel_keys = mixcoatl . utils . uncamel <NEWLINE> camelize = mixcoatl . utils . camelize <NEWLINE> camel_keys = mixcoatl . utils . camel_keys <NEWLINE>
def test_roster_item_with_roles ( ) : <NEWLINE> <INDENT> item = salt . roster_item ( cluster . head , roles = [ <STRING> , <STRING> ] , mine = False ) <NEWLINE> assert item == { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : 22 , <NEWLINE> <STRING> : True , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : { <STRING> : [ <STRING> , <STRING> ] } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>
import sys <NEWLINE> from com . l2scoria . gameserver . model . quest import State <NEWLINE> from com . l2scoria . gameserver . model . quest import QuestState <NEWLINE> from com . l2scoria . gameserver . model . quest . jython import QuestJython as JQuest <NEWLINE> qn = <STRING> <NEWLINE> TRADER_GALLADUCCI_ID = 30097 <NEWLINE> GALLADUCCIS_ORDER_DOCUMENT_ID_1 = 7563 <NEWLINE> GALLADUCCIS_ORDER_DOCUMENT_ID_2 = 7564 <NEWLINE> GALLADUCCIS_ORDER_DOCUMENT_ID_3 = 7565 <NEWLINE> MAGIC_TRADER_GENTLER_ID = 30094 <NEWLINE> MAGIC_SWORD_HILT_ID = 7568 <NEWLINE> JEWELER_SANDRA_ID = 30090 <NEWLINE> GEMSTONE_POWDER_ID = 7567 <NEWLINE> PRIEST_DUSTIN_ID = 30116 <NEWLINE> PURIFIED_MAGIC_NECKLACE_ID = 7566 <NEWLINE> MARK_OF_TRAVELER_ID = 7570 <NEWLINE> SCROLL_OF_ESCAPE_SPECIAL = 7557 <NEWLINE> ADENA_ID = 57 <NEWLINE> RACE = 3 <NEWLINE>
class URLTest ( TestCase ) : <NEWLINE> <INDENT> def test_u_bind ( self ) : <NEWLINE> <INDENT> response = self . client . get ( <STRING> ) <NEWLINE> self . assertContains ( response , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
__author__ = <STRING> <NEWLINE> __date__ = <STRING> <NEWLINE> import unittest <NEWLINE> from sitools2 . clients . gaia_client_medoc import * <NEWLINE> from datetime import datetime , timedelta <NEWLINE>
class Is666 ( object ) : <NEWLINE> <INDENT> def validate ( self , password , * args , ** kwargs ) : <NEWLINE> <INDENT> if password == <STRING> : <NEWLINE> <INDENT> raise ValidationError ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import optparse <NEWLINE> import os <NEWLINE> import re <NEWLINE> from docs_server_utils import SanitizeAPIName <NEWLINE>
<STRING> <NEWLINE> import sys <NEWLINE> import lxml . etree as le <NEWLINE>
class TestPortenseBienScript ( p3bot_testcase . P3BotTestCase ) : <NEWLINE> <INDENT> def setUp ( self ) : <NEWLINE> <INDENT> p3bot_testcase . P3BotTestCase . setUp ( self ) <NEWLINE> self . _script = scripts . portensebien . init ( self . bot ) <NEWLINE> <DEDENT> def test_basic ( self ) : <NEWLINE> <INDENT> self . assertEqual ( <STRING> , self . _script . execute ( <STRING> , <STRING> ) ) <NEWLINE> self . assertEqual ( <STRING> , self . _script . execute ( <STRING> , <STRING> ) ) <NEWLINE> self . assertEqual ( <STRING> , self . _script . execute ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from . all_the_things import THING1 <NEWLINE> __revision__ = None <NEWLINE> THING2 = <STRING> <NEWLINE> THING1_PLUS_THING2 = <STRING> % ( THING1 , THING2 ) <NEWLINE>
<STRING> <NEWLINE> from flask import Blueprint , render_template , abort <NEWLINE> from flaskrst . modules . blog import get_posts <NEWLINE>
import wx <NEWLINE> import os <NEWLINE> from printrun . utils import imagefile <NEWLINE> from . utils import make_autosize_button <NEWLINE>
<STRING> <NEWLINE> from __future__ import division , absolute_import , print_function <NEWLINE> import warnings <NEWLINE> import numpy as np <NEWLINE> import pandas as pd <NEWLINE> import os <NEWLINE> from scipy . signal import lfilter <NEWLINE> from statsmodels . tsa . statespace import ( sarimax , structural , varmax , <NEWLINE> <INDENT> dynamic_factor ) <NEWLINE> <DEDENT> from statsmodels . tsa . statespace . tools import compatibility_mode <NEWLINE> from numpy . testing import ( assert_allclose , assert_almost_equal , assert_equal , <NEWLINE> <INDENT> assert_raises ) <NEWLINE> <DEDENT>
def _get_name_and_abbr_set ( self , name ) : <NEWLINE> <INDENT> result_set = { name } <NEWLINE> result_set . update ( self . _name_abbr_dict . get ( name , { } ) ) <NEWLINE> return result_set <NEWLINE> <DEDENT>
def compare_poll ( request , diff ) : <NEWLINE> <INDENT> msgs = [ ] <NEWLINE> for f in ( diff . left , diff . right ) : <NEWLINE> <INDENT> m = Message ( <STRING> % f ) . get ( delete = True ) <NEWLINE> if m : <NEWLINE> <INDENT> msgs . append ( m ) <NEWLINE> <DEDENT> <DEDENT> return { <STRING> : diff . is_extracted ( ) , <STRING> : msgs } <NEWLINE> <DEDENT>
def makeNewSquare ( edge_size , offset_left , offset_top , color ) : <NEWLINE> <INDENT> new_square_string = <STRING> % ( edge_size , edge_size , offset_left , offset_top , color ) <NEWLINE> output_file . write ( new_square_string ) <NEWLINE> <DEDENT>
import binascii <NEWLINE> import base64 <NEWLINE> str = input ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> bin = binascii . unhexlify ( str ) ; <NEWLINE> print ( <STRING> , bin . decode ( <STRING> ) ) <NEWLINE> print ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> b64 = base64 . b64encode ( bin ) <NEWLINE> print ( <STRING> , b64 . decode ( <STRING> ) ) <NEWLINE>
class SQSBackend ( BrokerBackend ) : <NEWLINE> <INDENT> def __init__ ( self , aws_access_key_id , aws_secret_access_key ) : <NEWLINE> <INDENT> super ( SQSBackend , self ) . __init__ ( ) <NEWLINE> self . connection = SQSConnection ( aws_access_key_id , aws_secret_access_key ) <NEWLINE> <DEDENT> def _get_queues ( self , prefix = None ) : <NEWLINE> <INDENT> return self . connection . get_all_queues ( prefix ) <NEWLINE> <DEDENT> <DEDENT>
def table ( self , G ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . use_color_dp : <NEWLINE> <INDENT> self . tableobj = BVColorDPTable ( G , self . p , self . colors , <NEWLINE> <INDENT> reuse = self . table_hints [ <STRING> ] ) <NEWLINE> <DEDENT> return self . tableobj <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . uncolored_table ( G ) <NEWLINE> <DEDENT> <DEDENT>
def clear ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . _waiting . clear ( ) <NEWLINE> self . value = self . initial_value <NEWLINE> <DEDENT>
class res_partner ( osv . osv ) : <NEWLINE> <INDENT> _inherit = <STRING> <NEWLINE> _columns = { <NEWLINE> <INDENT> <STRING> : fields . date ( <STRING> ) , <NEWLINE> <STRING> : fields . selection ( [ ( <STRING> , <STRING> ) , ( <STRING> , <STRING> ) ] , <STRING> ) , <NEWLINE> <STRING> : fields . one2many ( <STRING> , <STRING> , <STRING> ) , <NEWLINE> <DEDENT> } <NEWLINE> _defaults = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>
def handle_compare_intent ( self , center_node , target_node ) : <NEWLINE> <INDENT> self . crawler . update_connector ( self . connector ) <NEWLINE> flag = is_this_that ( center_node , target_node , self . crawler ) <NEWLINE> self . speak ( <STRING> + center_node + <STRING> + target_node + <STRING> + str ( flag ) ) <NEWLINE> return True <NEWLINE> <DEDENT>
def __init__ ( self ) : <NEWLINE> <INDENT> super ( InstaSession , self ) . __init__ ( ) <NEWLINE> self . csrftoken = <STRING> <NEWLINE> self . login_status = False <NEWLINE> self . user_id = None <NEWLINE> self . user_login = None <NEWLINE> self . user_password = None <NEWLINE> self . last_response = None <NEWLINE> <DEDENT>
def test_idadb_ida_query_first_row_only ( self , idadb , idadf , df ) : <NEWLINE> <INDENT> query = <STRING> % idadf . name <NEWLINE> downloaded_df = idadb . ida_query ( query , first_row_only = True ) <NEWLINE> assert ( isinstance ( downloaded_df , tuple ) ) <NEWLINE> assert ( len ( downloaded_df ) == len ( df . loc [ 0 ] ) ) <NEWLINE> <DEDENT>
from kivy . uix . behaviors import ButtonBehavior <NEWLINE> from inspect import getmembers , ismethod <NEWLINE> from copy import copy <NEWLINE> import operator <NEWLINE>
<STRING> <NEWLINE> import os <NEWLINE> import sys <NEWLINE> import logging <NEWLINE> import re <NEWLINE> from opendxmc . materials . materials import Material <NEWLINE> from opendxmc . utils import find_all_files <NEWLINE> logger = logging . getLogger ( <STRING> ) <NEWLINE> MATERIAL_DATA_PATH = os . path . join ( os . path . dirname ( sys . argv [ 0 ] ) , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> ) <NEWLINE> <DEDENT> BASE_PATH = os . path . dirname ( os . path . dirname ( __file__ ) ) <NEWLINE> MATERIAL_DATA_PATH = os . path . join ( BASE_PATH , <NEWLINE> <INDENT> <STRING> , <STRING> ) <NEWLINE> <DEDENT>
class EB_pbdSLAP ( RPackage ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , * args , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> super ( EB_pbdSLAP , self ) . __init__ ( * args , ** kwargs ) <NEWLINE> self . configurevars . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class LoginResetForm_Locators_Base ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> locators = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import unittest <NEWLINE> from plaso . formatters import plist as plist_formatter <NEWLINE> from plaso . lib import event <NEWLINE> from plaso . parsers import plist <NEWLINE> from plaso . parsers . plist_plugins import softwareupdate <NEWLINE> from plaso . parsers . plist_plugins import test_lib <NEWLINE>
def get_full_path_to_file ( path_on_host , schedule_name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not path_on_host . endswith ( <STRING> ) : <NEWLINE> <INDENT> path_on_host += <STRING> <NEWLINE> <DEDENT> full_path = path_on_host + <STRING> . format ( schedule_name ) <NEWLINE> return full_path <NEWLINE> <DEDENT>
def main ( _ ) : <NEWLINE> <INDENT> mnist = input_data . read_data_sets ( FLAGS . datadir , one_hot = True ) <NEWLINE> prepare_samples ( mnist ) <NEWLINE> <DEDENT>
import six <NEWLINE> from collections import defaultdict <NEWLINE> from django . db import models <NEWLINE> from south . db import db <NEWLINE> from south . utils import datetime_utils as datetime <NEWLINE> from south . v2 import DataMigration <NEWLINE>
import unittest <NEWLINE> import numpy as np <NEWLINE> from AlphaLineupPuzzle import lineup_puzzle <NEWLINE> from AlphaLineupPuzzle . preprocessing import preprocessing <NEWLINE>
def draw ( self , surface ) : <NEWLINE> <INDENT> for button in self . buttons : <NEWLINE> <INDENT> button . draw ( surface ) <NEWLINE> <DEDENT> label = utils . TextWrapping ( ) . render_textrect ( self . credits_plain_text , self . credits_font , pygame . Rect ( ( 0 , 0 ) , ( constants . SCREEN_WIDTH , constants . SCREEN_HEIGHT - 150 ) ) , ( 255 , 255 , 255 ) ) <NEWLINE> x = 100 <NEWLINE> y = 40 <NEWLINE> surface . blit ( label , ( x , y ) ) <NEWLINE> <DEDENT>
def __init__ ( self ) : <NEWLINE> <INDENT> super ( Observer , self ) . __init__ ( ) <NEWLINE> self . last_update = - 101 <NEWLINE> <DEDENT>
def _pre_processing_x ( self , X ) : <NEWLINE> <INDENT> X = self . standardize ( X ) <NEWLINE> return X <NEWLINE> <DEDENT>
from setuptools import setup , find_packages <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> version = <STRING> , <NEWLINE> packages = find_packages ( ) , <NEWLINE> author = <STRING> , <NEWLINE> description = <STRING> , <NEWLINE> include_package_data = True , <NEWLINE> classifiers = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <DEDENT> ] , <NEWLINE> scripts = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> <NEWLINE> <DEDENT> ] , <NEWLINE> install_requires = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> <NEWLINE> <DEDENT> ] , <NEWLINE> license = <STRING> , <NEWLINE> <DEDENT> ) <NEWLINE>
import sys <NEWLINE> sys . path . append ( <STRING> ) <NEWLINE> from recon . wall import WallReader <NEWLINE> for file in sys . argv [ 1 : ] : <NEWLINE> <INDENT> with open ( file , <STRING> ) as fp : <NEWLINE> <INDENT> wall = WallReader ( fp , verbose = False ) <NEWLINE> wall . asJSON ( sys . stdout ) <NEWLINE> <DEDENT> <DEDENT>
def getArchive ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> subprocess . check_call ( [ <STRING> , tpchArchiveWeb ] , cwd = dataDir ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 2 ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT>
def get_keys ( client ) : <NEWLINE> <INDENT> keys = [ ] <NEWLINE> headers = [ <STRING> , <STRING> ] <NEWLINE> for key in client . get ( <STRING> . format ( client . _project ) ) : <NEWLINE> <INDENT> keys . append ( <NEWLINE> <INDENT> ( <NEWLINE> <INDENT> key [ <STRING> ] , <NEWLINE> key [ <STRING> ] <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> return columns ( headers , keys ) <NEWLINE> <DEDENT>
def digitalRead ( self , pin ) : <NEWLINE> <INDENT> GPIO . setmode ( GPIO . BCM ) <NEWLINE> GPIO . setup ( pin , GPIO . IN ) <NEWLINE> return GPIO . input ( pin ) <NEWLINE> <DEDENT>
def __init__ ( self , server , path ) : <NEWLINE> <INDENT> self . _path = path <NEWLINE> super ( JsonScript , self ) . __init__ ( server ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from random import shuffle <NEWLINE> from IPython . core . debugger import Tracer <NEWLINE>
def show_image ( self , pil_image ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> show_image = pil_image . resize ( ( self . width , self . height ) , <NEWLINE> <INDENT> resample = Image . ANTIALIAS ) <NEWLINE> <DEDENT> self . tk_image = ImageTk . PhotoImage ( show_image ) <NEWLINE> self . cv . create_image ( 0 , 0 , anchor = <STRING> , image = self . tk_image ) <NEWLINE> self . cv . pack ( fill = BOTH , expand = YES ) <NEWLINE> <DEDENT>
def diagnose_data ( cls ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> configuration_file = os . path . join ( os . path . dirname ( __file__ ) , <STRING> ) <NEWLINE> CC = CerebralCortex ( configuration_file , master = <STRING> , name = <STRING> , time_zone = <STRING> ) <NEWLINE> configuration = Configuration ( filepath = <STRING> ) . config <NEWLINE> stream_name = configuration [ <STRING> ] [ <STRING> ] <NEWLINE> cls . diagnose ( <STRING> , CC , configuration , stream_name ) <NEWLINE> <DEDENT>
class Migration ( migrations . Migration ) : <NEWLINE> <INDENT> dependencies = [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE> operations = [ <NEWLINE> <INDENT> migrations . RemoveField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> <DEDENT> ) , <NEWLINE> migrations . AddField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> field = models . ManyToManyField ( null = True , to = <STRING> , blank = True , verbose_name = <STRING> ) , <NEWLINE> <DEDENT> ) , <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT>
class TimeTicks ( univ . Integer ) : <NEWLINE> <INDENT> tagSet = univ . Integer . tagSet . tagImplicitly ( <NEWLINE> <INDENT> tag . Tag ( tag . tagClassApplication , tag . tagFormatSimple , 0x03 ) <NEWLINE> <DEDENT> ) <NEWLINE> subtypeSpec = univ . Integer . subtypeSpec + constraint . ValueRangeConstraint ( <NEWLINE> <INDENT> 0 , 4294967295 <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
__module_name__ = <STRING> <NEWLINE> __module_version__ = <STRING> <NEWLINE> __module_description__ = <STRING> <NEWLINE> __author__ = <STRING> <NEWLINE> import hexchat <NEWLINE>
def test_fit ( self ) : <NEWLINE> <INDENT> expected_avgs = [ 1 , 1 , 3 , 5 ] <NEWLINE> transformed_avgs = self . scaler . fit ( self . X , self . y ) . _avgs <NEWLINE> self . assertListEqual ( expected_avgs , transformed_avgs ) <NEWLINE> <DEDENT>
def __ToggleImage ( self , image ) : <NEWLINE> <INDENT> imagePath = image [ <STRING> ] + image [ <STRING> ] <NEWLINE> image [ <STRING> ] = not image [ <STRING> ] <NEWLINE> wxImage = self . __CheckOrUncheckImage ( imagePath , image [ <STRING> ] ) <NEWLINE> image [ <STRING> ] . SetBitmap ( wx . BitmapFromImage ( wxImage ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> success , msg = alarm_performance_test ( ) <NEWLINE> if not success : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( msg ) <NEWLINE> return 1 <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT>
from dal import autocomplete <NEWLINE> from django . conf . urls import url <NEWLINE> from . models import TModel <NEWLINE> urlpatterns = [ <NEWLINE> <INDENT> url ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> autocomplete . Select2QuerySetView . as_view ( model = TModel ) , <NEWLINE> name = <STRING> , <NEWLINE> <DEDENT> ) , <NEWLINE> <DEDENT> ] <NEWLINE>
def login ( db , login , password ) : <NEWLINE> <INDENT> res_users = odoo . registry ( db ) [ <STRING> ] <NEWLINE> return res_users . _login ( db , login , password ) <NEWLINE> <DEDENT>
def finvec ( word , xwords , xweights ) : <NEWLINE> <INDENT> for i in range ( len ( xwords ) ) : <NEWLINE> <INDENT> if xwords [ i ] == word : <NEWLINE> <INDENT> return xweights [ i ] <NEWLINE> <DEDENT> <DEDENT> return None <NEWLINE> <DEDENT>
def talker ( ) : <NEWLINE> <INDENT> pub = rospy . Publisher ( <STRING> , Float64MultiArray , queue_size = 10 ) <NEWLINE> rospy . init_node ( <STRING> , anonymous = True ) <NEWLINE> rate = rospy . Rate ( 10 ) <NEWLINE> f = Float64MultiArray ( ) <NEWLINE> f . data = [ 0.1 , 0 , 2 ] <NEWLINE> while not rospy . is_shutdown ( ) : <NEWLINE> <INDENT> hello_str = <STRING> % ( f . data [ 0 ] , f . data [ 1 ] ) <NEWLINE> rospy . loginfo ( hello_str ) <NEWLINE> pub . publish ( f ) <NEWLINE> rate . sleep ( ) <NEWLINE> <DEDENT> <DEDENT>
time = input ( <STRING> ) <NEWLINE> if time == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> time = input ( <STRING> ) <NEWLINE> <DEDENT> patience = input ( <STRING> ) <NEWLINE> foss = input ( <STRING> ) <NEWLINE> if foss == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def UserActTodo ( opts ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> emails , reviewers , owners = _MyUserInfo ( ) <NEWLINE> cls = FilteredQuery ( opts , <STRING> % <NEWLINE> <INDENT> ( <STRING> . join ( reviewers ) , <STRING> . join ( owners ) ) ) <NEWLINE> <DEDENT> cls = [ x for x in cls if not IsApprover ( x , emails ) ] <NEWLINE> lims = limits ( cls ) <NEWLINE> for cl in cls : <NEWLINE> <INDENT> PrintCl ( opts , cl , lims ) <NEWLINE> <DEDENT> <DEDENT>
def on_accelerator_focus_out ( self , entry , event ) : <NEWLINE> <INDENT> if self . current_node is not None : <NEWLINE> <INDENT> self . update_accelerator_label ( ) <NEWLINE> self . tool_changed ( self . current_node ) <NEWLINE> <DEDENT> <DEDENT>
class ContactForm ( ModelForm ) : <NEWLINE> <INDENT> class Meta : <NEWLINE> <INDENT> model = ContactMessage <NEWLINE> fields = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <DEDENT> <DEDENT>
def build_report ( template_dict ) : <NEWLINE> <INDENT> report_dir = os . path . abspath ( <STRING> ) <NEWLINE> jinja_env = jinja2 . Environment ( loader = jinja2 . FileSystemLoader ( report_dir ) ) <NEWLINE> template = jinja_env . get_template ( <STRING> ) <NEWLINE> report = template . render ( template_dict ) <NEWLINE> with open ( os . path . join ( report_dir , <STRING> ) , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( report ) <NEWLINE> <DEDENT> <DEDENT>
from __future__ import print_function , division <NEWLINE> from time_base import comparison_timer <NEWLINE> isreal_re = <STRING> <NEWLINE> isreal_try = <STRING> <NEWLINE> comparison_timer ( [ <STRING> , isreal_re ] , <NEWLINE> <INDENT> [ <STRING> , isreal_try ] , <NEWLINE> [ <STRING> , <STRING> ] ) <NEWLINE> <DEDENT>
def MergeFrom ( self , other ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> assert other is not self <NEWLINE> for ( type_id , item ) in other . items . items ( ) : <NEWLINE> <INDENT> if type_id in self . items : <NEWLINE> <INDENT> self . items [ type_id ] . MergeFrom ( item ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . items [ type_id ] = item . Copy ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from dbindexer . api import register_index <NEWLINE> from pirate_forum . models import View <NEWLINE> register_index ( View , { <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } ) <NEWLINE> <DEDENT>
def handle_int ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . stop ( False ) <NEWLINE> raise StopIteration <NEWLINE> <DEDENT>
def read_packet ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> pass <NEWLINE> <DEDENT>
def getCpuStat ( self ) : <NEWLINE> <INDENT> with open ( <STRING> ) as fd : <NEWLINE> <INDENT> cpustats = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> line = fd . readline ( ) <NEWLINE> if len ( line ) == 0 : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> if line [ 0 : 3 ] == <STRING> : <NEWLINE> <INDENT> cpustats . append ( line . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> return cpustats <NEWLINE> <DEDENT> <DEDENT>
def close ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . _serial_device . close ( ) <NEWLINE> <DEDENT>
import os <NEWLINE> import re <NEWLINE> import sys <NEWLINE> import subprocess <NEWLINE> path = os . path . join ( os . path . dirname ( os . path . realpath ( __file__ ) ) , <STRING> ) <NEWLINE> COMPILE_CMD = <STRING> . format ( path ) <NEWLINE> subprocess . Popen ( COMPILE_CMD , stdout = subprocess . PIPE , shell = True ) . wait ( ) <NEWLINE> RUN_CMD = <STRING> <NEWLINE>
def create_app ( ) : <NEWLINE> <INDENT> sentry . init_app ( app ) <NEWLINE> bootstrap = Bootstrap ( app ) <NEWLINE> moment = Moment ( app ) <NEWLINE> from app . views . login import auth as auth_blueprint <NEWLINE> app . register_blueprint ( auth_blueprint , url_prefix = <STRING> ) <NEWLINE> from app . views . wx import wx as wx_blueprint <NEWLINE> app . register_blueprint ( wx_blueprint , url_prefix = <STRING> ) <NEWLINE> from app . views . home import home as home_blueprint <NEWLINE> app . register_blueprint ( home_blueprint ) <NEWLINE> from app . views . errors import error as error_blueprint <NEWLINE> app . register_blueprint ( error_blueprint ) <NEWLINE> return app <NEWLINE> <DEDENT>
class StreamItem ( models . Model ) : <NEWLINE> <INDENT> stream = models . ForeignKey ( Stream , related_name = <STRING> ) <NEWLINE> pub_date = models . DateTimeField ( ) <NEWLINE> objects = InheritanceManager ( ) <NEWLINE> <DEDENT>
def page_no ( self ) : <NEWLINE> <INDENT> if self . placement : <NEWLINE> <INDENT> placement = json . loads ( self . placement ) <NEWLINE> if <STRING> in placement : <NEWLINE> <INDENT> return placement [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT> return None <NEWLINE> <DEDENT>
def df ( x ) : <NEWLINE> <INDENT> wing_param . set_thetaY ( x ) <NEWLINE> DLLM . set_direct_computed ( ) <NEWLINE> DLLM . run_post ( ) <NEWLINE> func_grad = DLLM . get_dpF_list_dpthetaY ( ) <NEWLINE> return func_grad <NEWLINE> <DEDENT>
def convert_np_audio_to_sample_blocks ( song_np , block_size ) : <NEWLINE> <INDENT> block_lists = [ ] <NEWLINE> total_samples = song_np . shape [ 0 ] <NEWLINE> print ( <STRING> , total_samples ) <NEWLINE> num_samples_so_far = 0 <NEWLINE> while ( num_samples_so_far < total_samples ) : <NEWLINE> <INDENT> block = song_np [ num_samples_so_far : num_samples_so_far + block_size ] <NEWLINE> <STRING> <NEWLINE> if ( block . shape [ 0 ] < block_size ) : <NEWLINE> <INDENT> padding = np . zeros ( ( block_size - block . shape [ 0 ] , ) ) <NEWLINE> block = np . concatenate ( ( block , padding ) ) <NEWLINE> <DEDENT> block_lists . append ( block ) <NEWLINE> num_samples_so_far += block_size <NEWLINE> <DEDENT> return block_lists <NEWLINE> <DEDENT>
def __validate_fields ( self , validation_function , validations ) : <NEWLINE> <INDENT> for v in validations : <NEWLINE> <INDENT> validation_function ( v , validations [ v ] ) <NEWLINE> <DEDENT> <DEDENT>
def rank_maximin ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> rank = dok_matrix ( ( self . nbDecision , self . nbDecision ) ) <NEWLINE> for i in range ( self . nbDecision ) : <NEWLINE> <INDENT> for j in range ( self . nbDecision ) : <NEWLINE> <INDENT> if self . scores [ j , 0 ] < self . scores [ i , 0 ] : <NEWLINE> <INDENT> rank [ i , j ] = 1 <NEWLINE> <DEDENT> elif self . scores [ i , 0 ] < self . scores [ j , 0 ] : <NEWLINE> <INDENT> rank [ j , i ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return rank <NEWLINE> <DEDENT>
import datetime <NEWLINE> import trainer . corpora as crp <NEWLINE> import trainer . features as ftr <NEWLINE> import trainer . classifier_test as cls <NEWLINE> NLTK = True <NEWLINE> SKLEARN = False <NEWLINE>
from app import app <NEWLINE> app . secret_key = <STRING> <NEWLINE> app . config [ <STRING> ] = True <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> app . run ( host = <STRING> , port = 5000 , debug = True ) <NEWLINE> <DEDENT>
class Test_236_Intermediate ( unittest . TestCase ) : <NEWLINE> <INDENT> def test_lowest_fibonacci_sequence ( self ) : <NEWLINE> <INDENT> self . assertEqual ( lowest_fibonacci_sequence ( 21 ) [ 1 ] , 1 ) <NEWLINE> self . assertEqual ( lowest_fibonacci_sequence ( 84 ) [ 1 ] , 4 ) <NEWLINE> self . assertEqual ( lowest_fibonacci_sequence ( 0 ) [ 1 ] , 0 ) <NEWLINE> self . assertEqual ( lowest_fibonacci_sequence ( 578 ) [ 1 ] , 17 ) <NEWLINE> self . assertEqual ( lowest_fibonacci_sequence ( 123456789 ) [ 1 ] , 41152263 ) <NEWLINE> self . assertEqual ( lowest_fibonacci_sequence ( 38695577906193299 ) [ 1 ] , 7 ) <NEWLINE> <DEDENT> <DEDENT>
def user_create ( request , user_id , email , password , tenant_id , enabled ) : <NEWLINE> <INDENT> return User ( keystoneclient ( request ) . users . create ( <NEWLINE> <INDENT> user_id , password , email , tenant_id , enabled ) ) <NEWLINE> <DEDENT> <DEDENT>
def detail_view ( request , voter_id = None , ** kw ) : <NEWLINE> <INDENT> context = kw <NEWLINE> site = request . session [ <STRING> ] <NEWLINE> context [ <STRING> ] = site <NEWLINE> detail = site . active_section . active_subsection . detail <NEWLINE> detail . render_pagination ( ) <NEWLINE> if detail . obj : <NEWLINE> <INDENT> context [ <STRING> ] = detail . obj . first_name + <STRING> + detail . obj . last_name <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> context [ <STRING> ] = <STRING> <NEWLINE> <DEDENT> return render_to_response ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> context , <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
class SchedulerContext ( base . BaseContext ) : <NEWLINE> <INDENT> def __init__ ( self , adminContext , config ) : <NEWLINE> <INDENT> base . BaseContext . __init__ ( self , adminContext ) <NEWLINE> self . config = config <NEWLINE> <DEDENT> def getAdminContext ( self ) : <NEWLINE> <INDENT> return self . parent <NEWLINE> <DEDENT> <DEDENT>
def setUp ( self ) : <NEWLINE> <INDENT> s = LazySettings ( settings_module = <STRING> ) <NEWLINE> app = get_application ( settings = s ) <NEWLINE> self . client = Client ( app , BaseResponse ) <NEWLINE> self . client . test_logout ( ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from . import actions <NEWLINE> from . jss_connection import JSSConnection <NEWLINE> from . import tools <NEWLINE> __version__ = <STRING> <NEWLINE>
class BooktypeGroupExist ( Exception ) : <NEWLINE> <INDENT> def __init__ ( self , group_name ) : <NEWLINE> <INDENT> self . group_name = group_name <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT>
class Result ( Receivable ) : <NEWLINE> <INDENT> def to_array ( self ) : <NEWLINE> <INDENT> return { } <NEWLINE> <DEDENT> pass <NEWLINE> <DEDENT>
class ValidationView ( APIView ) : <NEWLINE> <INDENT> permission_classes = ( IsAuthenticated , ) <NEWLINE> def post ( self , request , * args , ** kwargs ) : <NEWLINE> <INDENT> data = request . data <NEWLINE> request = ValidationRequest ( data ) <NEWLINE> return Response ( request . validateAndGetResponseData ( ) , 200 ) <NEWLINE> <DEDENT> <DEDENT>
def check_forward_ones ( self , x_data , use_cudnn = True ) : <NEWLINE> <INDENT> x = chainer . Variable ( x_data ) <NEWLINE> y = functions . spatial_pyramid_pooling_2d ( <NEWLINE> <INDENT> x , self . pyramid_height , self . pooling_class , use_cudnn = use_cudnn ) <NEWLINE> <DEDENT> y_data = cuda . to_cpu ( y . data ) <NEWLINE> self . assertEqual ( ( self . n , self . output_dim , 1 , 1 ) , y_data . shape ) <NEWLINE> gradient_check . assert_allclose ( y_data , numpy . ones_like ( y_data ) ) <NEWLINE> <DEDENT>
def approx_gradients ( function , argument_array , epsilon = 1e-6 ) : <NEWLINE> <INDENT> g = zeros ( argument_array . shape ) <NEWLINE> for i in range ( argument_array . size ) : <NEWLINE> <INDENT> a_plus = argument_array . copy ( ) <NEWLINE> a_plus . flat [ i ] += epsilon <NEWLINE> a_minus = argument_array . copy ( ) <NEWLINE> a_minus . flat [ i ] -= epsilon <NEWLINE> g . flat [ i ] = ( function ( a_plus ) - function ( a_minus ) ) / ( 2 * epsilon ) <NEWLINE> <DEDENT> return g <NEWLINE> <DEDENT>
class IPsecPolicy ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , name ) : <NEWLINE> <INDENT> self . name = name <NEWLINE> self . proposals = [ ] <NEWLINE> <DEDENT> <DEDENT>
def _trace_cons ( self , x ) : <NEWLINE> <INDENT> ax = pycppad . independent ( x ) <NEWLINE> ay = self . cons ( ax ) <NEWLINE> if not isinstance ( ay , np . ndarray ) : <NEWLINE> <INDENT> ay = np . array ( [ ay ] ) <NEWLINE> <DEDENT> self . _cppad_adfun_cons = pycppad . adfun ( ax , ay ) <NEWLINE> <DEDENT>
from __future__ import absolute_import <NEWLINE> import logging <NEWLINE> from geocoder . base import OneResult <NEWLINE> from geocoder . arcgis import ArcgisQuery <NEWLINE> from geocoder . location import Location <NEWLINE>
def test_set_availability_zone_compute_service ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> service = self . _create_service_with_topic ( <STRING> , self . host ) <NEWLINE> services = db . service_get_all ( self . context ) <NEWLINE> new_service = az . set_availability_zones ( self . context , services ) [ 0 ] <NEWLINE> self . assertEqual ( new_service [ <STRING> ] , <NEWLINE> <INDENT> self . default_az ) <NEWLINE> <DEDENT> self . _add_to_aggregate ( service , self . agg ) <NEWLINE> new_service = az . set_availability_zones ( self . context , services ) [ 0 ] <NEWLINE> self . assertEqual ( new_service [ <STRING> ] , <NEWLINE> <INDENT> self . availability_zone ) <NEWLINE> <DEDENT> self . _destroy_service ( service ) <NEWLINE> <DEDENT>
def remove_conference ( cls , key ) : <NEWLINE> <INDENT> if key in cls . observers : <NEWLINE> <INDENT> cls . observers [ key ] . stop ( ) <NEWLINE> del cls . observers [ key ] <NEWLINE> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT>
def get_coords ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . circ is not None : <NEWLINE> <INDENT> return self . circ . center , self . circ . radius <NEWLINE> <DEDENT> <DEDENT>
def is_registered ( chromosome ) : <NEWLINE> <INDENT> resultCursor = postgresConnHandle . cursor ( ) <NEWLINE> resultCursor . execute ( <STRING> . format ( chromosome ) ) <NEWLINE> if resultCursor . rowcount > 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
def test_to_python ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> column = columns . Map ( JsonTestColumn , JsonTestColumn ) <NEWLINE> val = { 1 : 2 , 3 : 4 , 5 : 6 } <NEWLINE> db_val = column . to_database ( val ) <NEWLINE> assert db_val . value == { json . dumps ( k ) : json . dumps ( v ) for k , v in val . items ( ) } <NEWLINE> py_val = column . to_python ( db_val . value ) <NEWLINE> assert py_val == val <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> fa ( <STRING> ) <NEWLINE> fl ( <STRING> ) <NEWLINE> <DEDENT>
def __str__ ( self ) : <NEWLINE> <INDENT> s = ( <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> % <NEWLINE> { <STRING> : self . type , <STRING> : self . geometry , <NEWLINE> <INDENT> <STRING> : self . checked , <STRING> : self . __fileSystem } ) <NEWLINE> <DEDENT> <DEDENT> return s <NEWLINE> <DEDENT>
def test_raises_original_error_when_no_label_available ( self , session ) : <NEWLINE> <INDENT> with pytest . raises ( ElementNotFound ) as excinfo : <NEWLINE> <INDENT> session . check ( <STRING> ) <NEWLINE> <DEDENT> assert <STRING> in str ( excinfo . value ) <NEWLINE> <DEDENT>
class ExampleModel ( models . Model ) : <NEWLINE> <INDENT> name = models . CharField ( max_length = 50 ) <NEWLINE> @ staticmethod <NEWLINE> def get_translated_string ( ) : <NEWLINE> <INDENT> return _ ( <STRING> ) <NEWLINE> <DEDENT> def __unicode__ ( self ) : <NEWLINE> <INDENT> return <STRING> % self . name <NEWLINE> <DEDENT> <DEDENT>
from storage import * <NEWLINE> from storageitu import * <NEWLINE> set_logger ( get_logfile_logger ( ) ) <NEWLINE> environment = Environment ( False ) <NEWLINE> storage = Storage ( environment ) <NEWLINE> storage . probe ( ) <NEWLINE> staging = storage . get_staging ( ) <NEWLINE> print ( staging ) <NEWLINE> partitionable = Partitionable . find_by_name ( staging , <STRING> ) <NEWLINE> partitionable . remove_descendants ( ) <NEWLINE> partitionable . create_partition_table ( PtType_IMPLICIT ) <NEWLINE> print ( staging ) <NEWLINE> commit ( storage ) <NEWLINE>
<STRING> <NEWLINE> import unirest <NEWLINE> from InformationMachineAPILib . APIHelper import APIHelper <NEWLINE> from InformationMachineAPILib . Configuration import Configuration <NEWLINE> from InformationMachineAPILib . APIException import APIException <NEWLINE> from InformationMachineAPILib . Models . GetAllStoresWrapper import GetAllStoresWrapper <NEWLINE> from InformationMachineAPILib . Models . ConnectStoreWrapper import ConnectStoreWrapper <NEWLINE> from InformationMachineAPILib . Models . ConnectStoreWrapper import ConnectStoreWrapper <NEWLINE> from InformationMachineAPILib . Models . GetSingleStoresWrapper import GetSingleStoresWrapper <NEWLINE> from InformationMachineAPILib . Models . UpdateStoreConnectionWrapper import UpdateStoreConnectionWrapper <NEWLINE> from InformationMachineAPILib . Models . DeleteSingleStoreWrapper import DeleteSingleStoreWrapper <NEWLINE>
class AclAdmin ( admin . ModelAdmin ) : <NEWLINE> <INDENT> search_fields = ( <STRING> , ) <NEWLINE> list_filter = ( <STRING> , <STRING> , ) <NEWLINE> ordering = ( <STRING> , ) <NEWLINE> list_display = ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> <DEDENT>
import logging <NEWLINE> from app import get_app <NEWLINE> logger = logging . getLogger ( __name__ ) <NEWLINE> celery = get_app ( ) . celery <NEWLINE>
def test_authorfactory ( session ) : <NEWLINE> <INDENT> author = AuthorFactory ( ) <NEWLINE> author . save ( ) <NEWLINE> assert isinstance ( author , Author ) <NEWLINE> assert author . id is not None <NEWLINE> assert author . name is not None <NEWLINE> assert author . givenname is not None <NEWLINE> assert author . familyname is not None <NEWLINE> assert author . url is not None <NEWLINE> assert author . email is not None <NEWLINE> author2 = AuthorFactory ( ) <NEWLINE> author2 . save ( ) <NEWLINE> assert author . id != author2 . id <NEWLINE> <DEDENT>
from threeML . classicMLE . joint_likelihood import JointLikelihood <NEWLINE> from threeML . bayesian . bayesian_analysis import BayesianAnalysis <NEWLINE> __all__ = [ ] <NEWLINE> try : <NEWLINE> <INDENT> import copyreg <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> import copy_reg as copyreg <NEWLINE> <DEDENT>
def _extract_brightcove_urls ( cls , webpage ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> url_m = re . search ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> webpage ) <NEWLINE> <DEDENT> if url_m : <NEWLINE> <INDENT> url = unescapeHTML ( url_m . group ( 1 ) ) <NEWLINE> if <STRING> in url or <STRING> in url : <NEWLINE> <INDENT> return [ url ] <NEWLINE> <DEDENT> <DEDENT> matches = re . findall ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> webpage ) <NEWLINE> <DEDENT> return list ( filter ( None , [ cls . _build_brighcove_url ( m ) for m in matches ] ) ) <NEWLINE> <DEDENT>
import wx <NEWLINE> color_codes = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> solarized = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <DEDENT> } <NEWLINE>
class report_lunchorder ( models . AbstractModel ) : <NEWLINE> <INDENT> _name = <STRING> <NEWLINE> _inherit = <STRING> <NEWLINE> _template = <STRING> <NEWLINE> _wrapped_report_class = folio_report <NEWLINE> <DEDENT>
from setuptools import setup <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> version = <STRING> , <NEWLINE> py_modules = [ <STRING> ] , <NEWLINE> install_requires = [ <STRING> ] , <NEWLINE> <DEDENT> ) <NEWLINE>
def create_client ( reactor , host , port ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> log . info ( <STRING> ) <NEWLINE> point = TCP4ClientEndpoint ( reactor , host , port ) <NEWLINE> nats_protocol = txnats . io . NatsProtocol ( <NEWLINE> <INDENT> verbose = False , <NEWLINE> on_connect = lambda np : np . sub ( <STRING> , <STRING> , on_msg = on_happy_msg ) ) <NEWLINE> <DEDENT> connecting = connectProtocol ( point , nats_protocol ) <NEWLINE> connecting . addErrback ( lambda np : log . info ( <STRING> , p = np ) ) <NEWLINE> connecting . addCallback ( lambda np : log . info ( <STRING> , p = np ) ) <NEWLINE> return connecting <NEWLINE> <DEDENT>
def _get_providers ( self ) : <NEWLINE> <INDENT> providers = super ( ProviderDumy , self ) . _get_providers ( ) <NEWLINE> providers . append ( [ <STRING> , <STRING> ] ) <NEWLINE> return providers <NEWLINE> <DEDENT>
def osbsapi ( func ) : <NEWLINE> <INDENT> @ wraps ( func ) <NEWLINE> def catch_exceptions ( * args , ** kwargs ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return func ( * args , ** kwargs ) <NEWLINE> <DEDENT> except OsbsException : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> except Exception as ex : <NEWLINE> <INDENT> raise OsbsException ( cause = ex , traceback = sys . exc_info ( ) [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> return catch_exceptions <NEWLINE> <DEDENT>
def upgrade ( migrate_engine ) : <NEWLINE> <INDENT> meta . bind = migrate_engine <NEWLINE> for table in ( instance_type_extra_specs_table , ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> table . create ( ) <NEWLINE> <DEDENT> except Exception : <NEWLINE> <INDENT> LOG . info ( repr ( table ) ) <NEWLINE> LOG . exception ( <STRING> ) <NEWLINE> raise <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def default_callback ( id ) : <NEWLINE> <INDENT> print ( <STRING> . format ( notifString [ id ] , id ) ) <NEWLINE> raw_input ( <STRING> ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import numpy <NEWLINE> import theano <NEWLINE> from pylearn2 . models . mlp import Linear <NEWLINE> from pylearn2 . models . mlp import Softmax <NEWLINE> from pylearn2 . models . mlp import MLP <NEWLINE> from pylearn2 . costs . cost import LpPenalty <NEWLINE>
def read_graph_from_file ( in_file ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> in_file = generate_file_path ( in_file ) <NEWLINE> with open ( in_file ) as in_file : <NEWLINE> <INDENT> graph = json . load ( in_file , encoding = <STRING> ) <NEWLINE> <DEDENT> return graph <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import pandas as pd <NEWLINE> import re <NEWLINE> from sklearn . cluster import MiniBatchKMeans <NEWLINE>
def _seek ( self , seek_to_func , args ) : <NEWLINE> <INDENT> if args is None : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> pos , duration = seek_to_func ( * args ) <NEWLINE> if duration <= 0 : <NEWLINE> <INDENT> logging . warning ( <STRING> , duration ) <NEWLINE> return None <NEWLINE> <DEDENT> self . seek_to ( pos / duration ) <NEWLINE> return True <NEWLINE> <DEDENT>
from sync import barrier <NEWLINE> from threading import Thread <NEWLINE> import time <NEWLINE> b = barrier ( 2 ) <NEWLINE>
class response ( BaseHTTPServer . BaseHTTPRequestHandler ) : <NEWLINE> <INDENT> def do_GET ( self ) : <NEWLINE> <INDENT> self . send_response ( 200 ) <NEWLINE> self . send_header ( <STRING> , <STRING> ) <NEWLINE> now = datetime . datetime . now ( ) <NEWLINE> headers = self . headers . headers <NEWLINE> html = <STRING> % ( now , headers ) <NEWLINE> self . wfile . write ( html ) <NEWLINE> <DEDENT> <DEDENT>
raise DeprecationWarning ( <STRING> ) <NEWLINE> from django . core . management import execute_manager <NEWLINE> try : <NEWLINE> <INDENT> import settings <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> import sys <NEWLINE> sys . stderr . write ( <STRING> % __file__ ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> execute_manager ( settings ) <NEWLINE> <DEDENT>
def __init__ ( self , address , port , timeout = 0 ) : <NEWLINE> <INDENT> self . address = address <NEWLINE> self . port = port <NEWLINE> self . timeout = timeout <NEWLINE> <DEDENT>
class Dog ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . name = <STRING> <NEWLINE> <DEDENT> def bark ( self ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT>
def validate_form ( ) : <NEWLINE> <INDENT> username = request . form [ <STRING> ] <NEWLINE> password = request . form [ <STRING> ] <NEWLINE> error = None <NEWLINE> if not username : <NEWLINE> <INDENT> error = json . dumps ( { <STRING> : <STRING> } ) <NEWLINE> <DEDENT> if not password : <NEWLINE> <INDENT> error = json . dumps ( { <STRING> : <STRING> } ) <NEWLINE> <DEDENT> return username , password , error <NEWLINE> <DEDENT>
class Perc98ServerTimeMetric ( BaseMetric ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> BaseMetric . __init__ ( self , <STRING> ) <NEWLINE> <DEDENT> def get_continious_query_body ( self ) : <NEWLINE> <INDENT> return <STRING> . format ( self . name , HTTP_SERVER_REQ_RESP_MEASUREMENT_NAME ) <NEWLINE> <DEDENT> def data_key ( self ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> def chart_type ( self ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> def unit_name ( self ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> def metric_title ( self ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> def get_data_points_query ( self , app = None ) : <NEWLINE> <INDENT> return self . get_basic_data_points_query ( app = app ) <NEWLINE> <DEDENT> <DEDENT>
from __future__ import print_function , division <NEWLINE> import matplotlib . pyplot as plt <NEWLINE> import numpy as np <NEWLINE> from stats2 import get_column <NEWLINE>
def read_sas ( sas_file_path , clean = False ) : <NEWLINE> <INDENT> from sas7bdat import SAS7BDAT <NEWLINE> data_frame = SAS7BDAT ( sas_file_path ) . to_data_frame ( ) <NEWLINE> return data_frame <NEWLINE> <DEDENT>
def init_commands ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for path in os . environ [ <STRING> ] . split ( <STRING> ) : <NEWLINE> <INDENT> binaries = os . listdir ( path ) <NEWLINE> kCommandList . append ( ( path , set ( binaries ) ) ) <NEWLINE> <DEDENT> <DEDENT>
def find_modtime ( the_file ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> head , ext = os . path . splitext ( the_file ) <NEWLINE> print ( <STRING> . format ( head ) ) <NEWLINE> the_date = datetime . datetime . fromtimestamp ( os . stat ( the_file ) [ stat . ST_MTIME ] ) <NEWLINE> local_tz = tzlocal . get_localzone ( ) <NEWLINE> the_date = local_tz . localize ( the_date ) <NEWLINE> the_date = the_date . astimezone ( pytz . utc ) <NEWLINE> head = head . split ( <STRING> ) [ - 1 ] <NEWLINE> return head , the_date <NEWLINE> <DEDENT>
import websocket <NEWLINE> websocket . enableTrace ( True ) <NEWLINE> ws = websocket . create_connection ( <STRING> ) <NEWLINE> msg = <STRING> <NEWLINE> print ( <STRING> % msg ) <NEWLINE> ws . send ( msg ) <NEWLINE> result = ws . recv ( ) <NEWLINE> print ( <STRING> % result ) <NEWLINE>
from django . contrib import admin <NEWLINE> from trivia . models import * <NEWLINE> admin . site . register ( Question ) <NEWLINE>
def __init__ ( self , input_file , halt_on_error = False ) : <NEWLINE> <INDENT> self . input_file = input_file <NEWLINE> self . lines = 0 <NEWLINE> self . halt_on_error = halt_on_error <NEWLINE> <DEDENT>
class TaskCancelled ( TaskMessage ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __unicode__ ( self ) : <NEWLINE> <INDENT> return <STRING> . format ( self ) <NEWLINE> <DEDENT> if py2 : <NEWLINE> <INDENT> __unicode__ = __str__ <NEWLINE> <DEDENT> <DEDENT>
def test_dbxref ( self ) : <NEWLINE> <INDENT> ref = Dbxref ( <STRING> ) <NEWLINE> assert ref . database == <STRING> <NEWLINE> assert ref . identifier == <STRING> <NEWLINE> ref = Dbxref ( <STRING> ) <NEWLINE> assert ref . database == <STRING> <NEWLINE> assert ref . identifier == <STRING> <NEWLINE> ref = Dbxref ( <STRING> , <STRING> ) <NEWLINE> assert ref . database == <STRING> <NEWLINE> assert ref . identifier == <STRING> <NEWLINE> s = repr ( ref ) <NEWLINE> s2 = str ( ref ) <NEWLINE> <DEDENT>
import logging <NEWLINE> import netaddr <NEWLINE> from django . core . urlresolvers import reverse <NEWLINE> from django . utils . translation import ugettext_lazy as _ <NEWLINE> from horizon import exceptions <NEWLINE> from horizon import forms <NEWLINE> from horizon import messages <NEWLINE> from horizon import workflows <NEWLINE> from horizon . utils import fields <NEWLINE> from openstack_dashboard import api <NEWLINE> from openstack_dashboard . api import raksha <NEWLINE> from openstack_dashboard . api import nova <NEWLINE> from openstack_dashboard . usage import quotas <NEWLINE> LOG = logging . getLogger ( __name__ ) <NEWLINE>
from gbpservice . contrib . nfp . config_orchestrator . common import ( <NEWLINE> <INDENT> topics as a_topics ) <NEWLINE> <DEDENT> from gbpservice . contrib . nfp . config_orchestrator . handlers . config import ( <NEWLINE> <INDENT> firewall as fw ) <NEWLINE> <DEDENT> from gbpservice . contrib . nfp . config_orchestrator . handlers . config import ( <NEWLINE> <INDENT> loadbalancerv2 as lbv2 ) <NEWLINE> <DEDENT> from gbpservice . contrib . nfp . config_orchestrator . handlers . config import vpn <NEWLINE> from gbpservice . contrib . nfp . config_orchestrator . handlers . notification import ( <NEWLINE> <INDENT> handler as notif_handler ) <NEWLINE> <DEDENT> from gbpservice . nfp . core . rpc import RpcAgent <NEWLINE> from oslo_config import cfg <NEWLINE>
def test_in_filter ( self ) : <NEWLINE> <INDENT> pks = [ ] <NEWLINE> for i in xrange ( 10 ) : <NEWLINE> <INDENT> pks . append ( RelatedModelA . objects . create ( <NEWLINE> <INDENT> data = random_string ( ) <NEWLINE> <DEDENT> ) . pk ) <NEWLINE> <DEDENT> qs = RelatedModelA . objects . filter ( pk__in = pks ) <NEWLINE> self . assertEqual ( len ( pks ) , len ( qs ) ) <NEWLINE> <DEDENT>
from __future__ import print_function <NEWLINE> from Hattrick . Web import HattrickWeb <NEWLINE> from Hattrick . Parsers import CHPPHolderParser <NEWLINE> import os <NEWLINE> import getpass <NEWLINE> import json <NEWLINE> try : <NEWLINE> <INDENT> input = raw_input <NEWLINE> <DEDENT> except NameError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
def update ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if len ( self . particles ) > self . maxparticles and self . level <= self . maxlevel : <NEWLINE> <INDENT> self . subdivide ( ) <NEWLINE> self . subdivide_particles ( ) <NEWLINE> for branch in self . branches : <NEWLINE> <INDENT> branch . update ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
def check_segment ( self , segment , agent = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> network_type = segment [ api . NETWORK_TYPE ] <NEWLINE> if network_type in self . supported_network_types : <NEWLINE> <INDENT> if agent : <NEWLINE> <INDENT> mappings = agent [ <STRING> ] . get ( <STRING> , { } ) <NEWLINE> LOG . debug ( <STRING> <NEWLINE> <INDENT> <STRING> , <NEWLINE> { <STRING> : segment , <STRING> : mappings } ) <NEWLINE> <DEDENT> return segment [ api . PHYSICAL_NETWORK ] in mappings <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
def gxx_modifier_aix ( conf ) : <NEWLINE> <INDENT> v = conf . env <NEWLINE> v [ <STRING> ] = [ <STRING> ] <NEWLINE> v [ <STRING> ] = [ <STRING> , <STRING> ] <NEWLINE> v [ <STRING> ] = <STRING> <NEWLINE> <DEDENT>
import errno <NEWLINE> import os <NEWLINE> import sys <NEWLINE> import tempfile <NEWLINE>
def _setup_parser_for_module ( subparsers , module , name ) : <NEWLINE> <INDENT> doc = module . __doc__ <NEWLINE> doc_subject = doc . splitlines ( ) [ 0 ] <NEWLINE> doc_epilog = <STRING> . join ( doc . splitlines ( ) [ 1 : ] ) <NEWLINE> parser = subparsers . add_parser ( <NEWLINE> <INDENT> name , <NEWLINE> formatter_class = argparse . RawDescriptionHelpFormatter , <NEWLINE> help = doc_subject , <NEWLINE> description = doc_subject , <NEWLINE> epilog = doc_epilog ) <NEWLINE> <DEDENT> module . setup_parser ( parser ) <NEWLINE> parser . set_defaults ( func = module . process_args ) <NEWLINE> <DEDENT>
def _reason_data ( alarm_ids ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return { <STRING> : <STRING> , <STRING> : alarm_ids } <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from . random_over_sampler import RandomOverSampler <NEWLINE> from . smote import SMOTE <NEWLINE> from . adasyn import ADASYN <NEWLINE> __all__ = [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ] <NEWLINE> <DEDENT>
def get_following_word ( sent , word ) : <NEWLINE> <INDENT> words = sent . split ( <STRING> ) <NEWLINE> for idx , w in enumerate ( words ) : <NEWLINE> <INDENT> if w == word : <NEWLINE> <INDENT> return words [ idx + 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class OpenIDForm ( Form ) : <NEWLINE> <INDENT> openid = StringField ( <STRING> , [ DataRequired ( ) ] ) <NEWLINE> submit = SubmitField ( <STRING> ) <NEWLINE> <DEDENT>
def cwtmorlet ( points , width ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> omega = 5.0 <NEWLINE> s = points / ( 2.0 * omega * width ) <NEWLINE> return wavelets . morlet ( points , omega , s , complete = True ) <NEWLINE> <DEDENT>
def negbinomPdf ( k , r , p ) : <NEWLINE> <INDENT> return exp ( gammaln ( r + k ) - gammaln ( k + 1 ) - gammaln ( r ) + <NEWLINE> <INDENT> r * log ( p ) + k * log ( 1 - p ) ) <NEWLINE> <DEDENT> <DEDENT>
class ManualUpload ( webapp2 . RequestHandler ) : <NEWLINE> <INDENT> def get ( self ) : <NEWLINE> <INDENT> self . response . headers [ <STRING> ] = <STRING> <NEWLINE> self . response . headers [ <STRING> ] = <STRING> <NEWLINE> def response ( ) : <NEWLINE> <INDENT> template = templater . get_template ( <STRING> ) <NEWLINE> return template . render ( { } ) <NEWLINE> <DEDENT> self . response . write ( <NEWLINE> <INDENT> memcache . get ( <STRING> , response ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from django . conf import settings <NEWLINE> from django . core . mail import EmailMultiAlternatives <NEWLINE> from django . core . urlresolvers import reverse_lazy , reverse <NEWLINE> from django . contrib . messages . views import SuccessMessageMixin <NEWLINE> from django . views . generic import FormView , TemplateView <NEWLINE> from contact_us . forms import ContactForm <NEWLINE>
def getParameterList ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> inputList = [ ] <NEWLINE> for name , n in zip ( self . _names , self . _inputs ) : <NEWLINE> <INDENT> inputList += [ <STRING> % ( name , i ) for i in range ( n ) ] <NEWLINE> <DEDENT> return inputList <NEWLINE> <DEDENT>
def _vision_api ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . _vision_api_internal is None : <NEWLINE> <INDENT> if self . _use_gax : <NEWLINE> <INDENT> self . _vision_api_internal = _GAPICVisionAPI ( self ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . _vision_api_internal = _HTTPVisionAPI ( self ) <NEWLINE> <DEDENT> <DEDENT> return self . _vision_api_internal <NEWLINE> <DEDENT>
class CLI ( harambe . cli . CLI ) : <NEWLINE> <INDENT> def __init__ ( self , command , click ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> @ command ( ) <NEWLINE> def setup ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> click . echo ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from django . conf . urls import url , include <NEWLINE> from django . contrib import admin <NEWLINE> from django . contrib . staticfiles . urls import staticfiles_urlpatterns <NEWLINE> urlpatterns = [ <NEWLINE> <INDENT> url ( <STRING> , admin . site . urls ) , <NEWLINE> url ( <STRING> , include ( <STRING> , namespace = <STRING> ) ) , <NEWLINE> url ( <STRING> , include ( <STRING> , namespace = <STRING> ) ) , <NEWLINE> url ( <STRING> , include ( <STRING> ) ) , <NEWLINE> <DEDENT> ] <NEWLINE> urlpatterns += staticfiles_urlpatterns ( ) <NEWLINE>
def upgrade ( ) : <NEWLINE> <INDENT> op . add_column ( <STRING> , sa . Column ( <STRING> , <NEWLINE> <INDENT> sa . Integer ( ) , nullable = True ) ) <NEWLINE> <DEDENT> <DEDENT>
def update ( self , current_position = - 1 , delta_position = - 1 ) : <NEWLINE> <INDENT> self . time_last = self . time_current <NEWLINE> self . time_current = datetime . datetime . now ( ) <NEWLINE> if current_position > - 1 : <NEWLINE> <INDENT> self . current_position = current_position <NEWLINE> <DEDENT> elif delta_position > - 1 : <NEWLINE> <INDENT> self . current_position += delta_position <NEWLINE> <DEDENT> self . display ( ) <NEWLINE> <DEDENT>
from __future__ import absolute_import <NEWLINE> import numpy as np <NEWLINE> from . . polyaffine import PolyAffine <NEWLINE> from . . affine import Affine <NEWLINE>
def FibonacciGenerator ( N ) : <NEWLINE> <INDENT> if N == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if N == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if N not in fib_memo : <NEWLINE> <INDENT> fib_memo [ N ] = FibonacciGenerator ( N - 1 ) + FibonacciGenerator ( N - 2 ) <NEWLINE> <DEDENT> return fib_memo [ N ] <NEWLINE> <DEDENT>
from setuptools import setup <NEWLINE> requires = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> ] <NEWLINE> <DEDENT> setup ( name = <STRING> , <NEWLINE> <INDENT> version = <STRING> , <NEWLINE> py_modules = [ <STRING> ] , <NEWLINE> install_requires = requires , <NEWLINE> setup_requires = [ <STRING> ] , <NEWLINE> packages = [ <STRING> ] , <NEWLINE> package_dir = { <STRING> : <STRING> } , <NEWLINE> ) <NEWLINE> <DEDENT>
def _main ( argv = [ ] ) : <NEWLINE> <INDENT> local_port = 0xDCAC <NEWLINE> if len ( argv ) >= 2 : <NEWLINE> <INDENT> local_port = int ( argv [ 1 ] ) <NEWLINE> <DEDENT> sock = socket ( AF_INET , SOCK_DGRAM ) <NEWLINE> sock . bind ( ( <STRING> , local_port ) ) <NEWLINE> while True : <NEWLINE> <INDENT> data = sock . recv ( 4096 ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( data ) <NEWLINE> <DEDENT> <DEDENT>
from zato . server . service import Service <NEWLINE> import os , urllib2 <NEWLINE> from time import sleep <NEWLINE> import socket <NEWLINE> os . environ [ <STRING> ] = <STRING> <NEWLINE> from ulakbus . models . hitap import AskerlikKayitlari <NEWLINE> H_USER = os . environ [ <STRING> ] <NEWLINE> H_PASS = os . environ [ <STRING> ] <NEWLINE>
<STRING> <NEWLINE> from django . conf . urls import url , include <NEWLINE> from django . contrib import admin <NEWLINE> from rest_framework_jwt . views import verify_jwt_token , refresh_jwt_token , obtain_jwt_token <NEWLINE> from zmessages import urls as zm_urls <NEWLINE> urlpatterns = [ <NEWLINE> <INDENT> url ( <STRING> , include ( zm_urls ) ) , <NEWLINE> url ( <STRING> , admin . site . urls ) , <NEWLINE> url ( <STRING> , obtain_jwt_token ) , <NEWLINE> url ( <STRING> , refresh_jwt_token ) , <NEWLINE> url ( <STRING> , verify_jwt_token ) , <NEWLINE> url ( <STRING> , include ( <STRING> , namespace = <STRING> ) ) <NEWLINE> <DEDENT> ] <NEWLINE>
def langinfo_from_doctype ( self , public_id = None , system_id = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . _li_from_doctype_public_id is None : <NEWLINE> <INDENT> self . _build_tables ( ) <NEWLINE> <DEDENT> if public_id is not None and public_id in self . _li_from_doctype_public_id : <NEWLINE> <INDENT> return self . _li_from_doctype_public_id [ public_id ] <NEWLINE> <DEDENT> if system_id is not None and system_id in self . _li_from_doctype_system_id : <NEWLINE> <INDENT> return self . _li_from_doctype_system_id [ system_id ] <NEWLINE> <DEDENT> <DEDENT>
from __future__ import unicode_literals <NEWLINE> from netmiko . avaya . avaya_vsp_ssh import AvayaVspSSH <NEWLINE> from netmiko . avaya . avaya_ers_ssh import AvayaErsSSH <NEWLINE> __all__ = [ <STRING> , <STRING> ] <NEWLINE>
import os <NEWLINE> from tempfile import mkstemp <NEWLINE> from circuits . web import Controller <NEWLINE> from . helpers import urlopen <NEWLINE>
def flatten_list ( x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if type ( x ) is not list : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> x_len = len ( x ) <NEWLINE> i = 0 <NEWLINE> while i < x_len : <NEWLINE> <INDENT> if type ( x [ i ] ) is list : <NEWLINE> <INDENT> x_len += len ( x [ i ] ) - 1 <NEWLINE> x [ i : i + 1 ] = x [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> return x <NEWLINE> <DEDENT>
class Router_5_3_10 ( HarnessCase ) : <NEWLINE> <INDENT> role = HarnessCase . ROLE_ROUTER <NEWLINE> case = <STRING> <NEWLINE> golden_devices_required = 4 <NEWLINE> def on_dialog ( self , dialog , title ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
from distutils . core import setup <NEWLINE> import dicts <NEWLINE> setup ( name = <STRING> , <NEWLINE> <INDENT> version = dicts . __version__ , <NEWLINE> description = <STRING> , <NEWLINE> long_description = open ( <STRING> ) . read ( ) , <NEWLINE> author = dicts . __author__ , <NEWLINE> author_email = dicts . __email__ , <NEWLINE> url = <STRING> , <NEWLINE> packages = [ <STRING> ] , <NEWLINE> license = <STRING> , <NEWLINE> classifiers = ( <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <DEDENT> ) , <NEWLINE> <DEDENT> ) <NEWLINE>
def __init__ ( self ) : <NEWLINE> <INDENT> target = messaging . Target ( topic = <STRING> , version = <STRING> , server = <STRING> ) <NEWLINE> self . central_dbapi = dbapi . DBAPI ( ) <NEWLINE> super ( CentralRPCAPI , self ) . __init__ ( <STRING> , target ) <NEWLINE> <DEDENT>
from mock import patch <NEWLINE> from pyramid import testing <NEWLINE> from parks . models import User <NEWLINE> from parks . tests . test_base import IntegrationTestBase <NEWLINE> from parks . views . profile import profile_user <NEWLINE>
from setuptools import setup <NEWLINE> description = <STRING> <NEWLINE> long_desc = open ( <STRING> ) . read ( ) <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> version = <STRING> , <NEWLINE> install_requires = [ ] , <NEWLINE> description = description , <NEWLINE> long_description = long_desc , <NEWLINE> author = <STRING> , <NEWLINE> maintainer = <STRING> , <NEWLINE> maintainer_email = <STRING> , <NEWLINE> packages = [ <STRING> ] , <NEWLINE> include_package_data = True , <NEWLINE> scripts = [ <STRING> , <STRING> ] , <NEWLINE> <DEDENT> ) <NEWLINE>
class CmdCamera : <NEWLINE> <INDENT> def __init__ ( self , connection ) : <NEWLINE> <INDENT> self . conn = connection <NEWLINE> <DEDENT> def setNormal ( self , * args ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . conn . send ( <STRING> , args ) <NEWLINE> <DEDENT> def setFixed ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . conn . send ( <STRING> ) <NEWLINE> <DEDENT> def setFollow ( self , * args ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . conn . send ( <STRING> , args ) <NEWLINE> <DEDENT> def setPos ( self , * args ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . conn . send ( <STRING> , args ) <NEWLINE> <DEDENT> <DEDENT>
def test_get_link_provider_not_found ( self ) : <NEWLINE> <INDENT> link = get_link ( <STRING> , <STRING> , PROVIDERS ) <NEWLINE> self . assertTrue ( link is None ) <NEWLINE> <DEDENT>
def folderitems ( self ) : <NEWLINE> <INDENT> items = BikaListingView . folderitems ( self ) <NEWLINE> for x in range ( len ( items ) ) : <NEWLINE> <INDENT> if not items [ x ] . has_key ( <STRING> ) : continue <NEWLINE> obj = items [ x ] [ <STRING> ] <NEWLINE> items [ x ] [ <STRING> ] [ <STRING> ] = <STRING> % ( items [ x ] [ <STRING> ] , items [ x ] [ <STRING> ] ) <NEWLINE> <DEDENT> return items <NEWLINE> <DEDENT>
def test_with_ndarray ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> rmg = RasterModelGrid ( 4 , 5 ) <NEWLINE> coords = ( np . array ( [ 0.1 , .2 ] ) , np . array ( [ 3.4 , 2.6 ] ) ) <NEWLINE> id = rfuncs . find_nearest_node ( rmg , coords ) <NEWLINE> assert_array_equal ( id , np . array ( [ 15 , 15 ] , dtype = int ) ) <NEWLINE> assert_is_instance ( id , np . ndarray ) <NEWLINE> <DEDENT>
import config <NEWLINE> APPNAME = <STRING> <NEWLINE> VERSION = <STRING> <NEWLINE> APPDESC = <STRING> <NEWLINE> AUTHOR = <STRING> <NEWLINE> EMAIL = <STRING> <NEWLINE> URL = <STRING> <NEWLINE> LICENSE = <STRING> <NEWLINE> LICENSE_DESC = <STRING> <NEWLINE> import os . path <NEWLINE> INSTALL_ROOT_DIR = <STRING> <NEWLINE> CONF_PATH = os . path . expanduser ( <STRING> ) <NEWLINE> WEB_SHARE_DIR = <STRING> <NEWLINE> DEBUG_LOG = os . path . expanduser ( <STRING> ) <NEWLINE>
class ProductCategory ( osv . osv ) : <NEWLINE> <INDENT> _inherit = <STRING> <NEWLINE> _columns = { <NEWLINE> <INDENT> <STRING> : fields . many2many ( <STRING> , <NEWLINE> <INDENT> id1 = <STRING> , id2 = <STRING> , <NEWLINE> string = <STRING> ) , <NEWLINE> <DEDENT> <DEDENT> } <NEWLINE> <DEDENT>
def shortest_vector ( self , delta ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> fractional = self . to_fractional ( delta ) <NEWLINE> fractional = np . floor ( fractional + 0.5 ) <NEWLINE> return delta - self . to_cartesian ( fractional ) <NEWLINE> <DEDENT>
def __init__ ( self ) : <NEWLINE> <INDENT> self . commentid = None <NEWLINE> self . parentid = None <NEWLINE> self . posted = None <NEWLINE> self . replies = None <NEWLINE> self . hidden = None <NEWLINE> self . body = None <NEWLINE> self . user = None <NEWLINE> <DEDENT>
def test_parenthesis ( ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> tokens = pythonlex ( s ) <NEWLINE> assert [ t . name for t in tokens ] == [ <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ] <NEWLINE> <DEDENT> <DEDENT>
def build_settings ( self , settings ) : <NEWLINE> <INDENT> settings . add_json_panel ( <STRING> , self . config , data = metaman_settings_base_json ) <NEWLINE> settings . add_json_panel ( <STRING> , self . config , data = metaman_settings_audio_json ) <NEWLINE> settings . add_json_panel ( <STRING> , self . config , data = metaman_settings_video_json ) <NEWLINE> settings . add_json_panel ( <STRING> , self . config , data = metaman_settings_library_json ) <NEWLINE> settings . add_json_panel ( <STRING> , self . config , data = metaman_settings_playback_json ) <NEWLINE> <DEDENT>
def manage ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> hookenv . _run_atstart ( ) <NEWLINE> try : <NEWLINE> <INDENT> hook_name = hookenv . hook_name ( ) <NEWLINE> if hook_name == <STRING> : <NEWLINE> <INDENT> self . stop_services ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . reconfigure_services ( ) <NEWLINE> self . provide_data ( ) <NEWLINE> <DEDENT> <DEDENT> except SystemExit as x : <NEWLINE> <INDENT> if x . code is None or x . code == 0 : <NEWLINE> <INDENT> hookenv . _run_atexit ( ) <NEWLINE> <DEDENT> <DEDENT> hookenv . _run_atexit ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> setup ( console = [ { <STRING> : <STRING> , <STRING> : [ ( 1 , <STRING> ) ] } ] , <NEWLINE> <INDENT> data_files = [ ( <STRING> , [ <STRING> , <STRING> , <STRING> ] ) ] , <NEWLINE> options = { <STRING> : { <STRING> : 1 , <STRING> : [ <STRING> ] , <STRING> : [ <STRING> ] , } } , <NEWLINE> zipfile = None , <NEWLINE> optimize = 2 , <NEWLINE> icon_resources = [ ( 1 , <STRING> ) ] , <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT>
from xml . etree import ElementTree as ET <NEWLINE> import os <NEWLINE> METADATA_ROOT_DIRECTORY = <STRING> <NEWLINE> MODSXMLNS = <STRING> <NEWLINE>
class Exit ( Exception ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , code = 0 ) : <NEWLINE> <INDENT> self . code = code <NEWLINE> <DEDENT> <DEDENT>
def addNewAsciiKey ( self , userId , asciiData ) : <NEWLINE> <INDENT> keyData = openpgpfile . parseAsciiArmorKey ( asciiData ) <NEWLINE> if not keyData : <NEWLINE> <INDENT> raise openpgpfile . IncompatibleKey ( <STRING> ) <NEWLINE> <DEDENT> self . addNewKey ( userId , keyData ) <NEWLINE> <DEDENT>
class GoogleMap ( Widget ) : <NEWLINE> <INDENT> templates = Dependency ( <STRING> ) <NEWLINE> def __init__ ( self , size ) : <NEWLINE> <INDENT> self . size = size <NEWLINE> <DEDENT> def __call__ ( self , context , center = ( 0 , 0 ) , markers = None ) : <NEWLINE> <INDENT> template = self . templates . get ( <STRING> ) <NEWLINE> return template . render ( { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : markers or [ ] , <NEWLINE> <STRING> : center <NEWLINE> <DEDENT> } ) <NEWLINE> <DEDENT> <DEDENT>
import shutil <NEWLINE> from django . contrib . admin . models import User <NEWLINE> from projects . models import Project <NEWLINE> from rtd_tests . utils import make_test_git <NEWLINE> from rtd_tests . base import RTDTestCase <NEWLINE>
def downgrade ( migrate_engine ) : <NEWLINE> <INDENT> meta = MetaData ( ) <NEWLINE> meta . bind = migrate_engine <NEWLINE> nodes = Table ( <STRING> , meta , autoload = True ) <NEWLINE> weight = Column ( <STRING> , Integer , nullable = False , default = 100 , <NEWLINE> <INDENT> server_default = <STRING> ) <NEWLINE> <DEDENT> nodes . drop_column ( weight ) <NEWLINE> <DEDENT>
import numpy <NEWLINE> from numpy . testing import assert_allclose <NEWLINE> from keras . layers import Dense , Embedding , Input <NEWLINE> from keras . models import Model , load_model <NEWLINE> from deep_qa . layers . attention import MatrixAttention <NEWLINE> from deep_qa . layers . wrappers import OutputMask <NEWLINE> from deep_qa . testing . test_case import DeepQaTestCase <NEWLINE>
def __init__ ( self ) : <NEWLINE> <INDENT> self . CHUNK = 2048 <NEWLINE> self . FORMAT = pyaudio . paInt16 <NEWLINE> self . CHANNELS = 1 <NEWLINE> self . RATE = 44100 <NEWLINE> self . THRESHOLD = 2100 <NEWLINE> self . SILENCE_LIMIT = 0.2 <NEWLINE> self . PREV_AUDIO = 0.5 <NEWLINE> self . GENERATED_FILE_NAME , self . NOTE_NAME = file_name_generator ( ) <NEWLINE> self . PATH = os . getcwd ( ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> __author__ = <STRING> <NEWLINE> from googleads import adwords <NEWLINE> AD_GROUP_ID = <STRING> <NEWLINE> CRITERION_ID = <STRING> <NEWLINE>
def dateToTimestamp ( datestring ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> t = time . strptime ( datestring + <STRING> , <STRING> ) <NEWLINE> return int ( calendar . timegm ( t ) ) <NEWLINE> <DEDENT>
def infer_net_from_xcorr ( S , dtmax , smooth = None ) : <NEWLINE> <INDENT> if smooth is not None : <NEWLINE> <INDENT> S = _moving_average ( S , window = smooth , axis = 0 ) <NEWLINE> <DEDENT> H = xcorr ( S , dtmax ) <NEWLINE> H_sum = np . sum ( np . abs ( H ) , axis = 2 ) <NEWLINE> return H_sum <NEWLINE> <DEDENT>
def __init__ ( self , point ) : <NEWLINE> <INDENT> self . _x = point [ 0 ] <NEWLINE> self . _y = point [ 1 ] <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from . . import ivi <NEWLINE> Mode = set ( [ <STRING> , <STRING> ] ) <NEWLINE>
