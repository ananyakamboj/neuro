def rsync_target ( self ) : <NEWLINE> <INDENT> fmt = self . fmt ( <STRING> ) <NEWLINE> if self . env . use_ssh_config : <NEWLINE> <INDENT> fmt = self . fmt ( <STRING> ) <NEWLINE> <DEDENT> if self . local_deployment : <NEWLINE> <INDENT> fmt = <STRING> <NEWLINE> <DEDENT> return fmt <NEWLINE> <DEDENT>
import blue_yellow_app . infrastructure . static_cache as static_cache <NEWLINE> import pyramid . renderers <NEWLINE> import pyramid . httpexceptions as exc <NEWLINE>
def system ( self , cmd ) : <NEWLINE> <INDENT> buf = pack ( <STRING> , RAP_SYSTEM , len ( str ( cmd ) ) ) <NEWLINE> self . fd . send ( buf ) <NEWLINE> self . fd . send ( cmd ) <NEWLINE> buf = self . fd . recv ( 5 ) <NEWLINE> ( c , l ) = unpack ( <STRING> , buf ) <NEWLINE> if c != RAP_SYSTEM | RAP_REPLY : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <STRING> <NEWLINE> <DEDENT> if l > 0 : <NEWLINE> <INDENT> buf = self . fd . recv ( l ) <NEWLINE> <DEDENT> return buf <NEWLINE> <DEDENT>
class TestSum ( unittest . TestCase ) : <NEWLINE> <INDENT> def test_sum ( self ) : <NEWLINE> <INDENT> self . assertEqual ( sum ( 1 , 2 ) , 3 ) <NEWLINE> <DEDENT> <DEDENT>
class ActorRef ( StdoutConnector ) : <NEWLINE> <INDENT> def __init__ ( self , path ) : <NEWLINE> <INDENT> self . path = path <NEWLINE> <DEDENT> def tell ( self , message ) : <NEWLINE> <INDENT> output = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : self . path , <NEWLINE> <STRING> : message <NEWLINE> <DEDENT> } <NEWLINE> self . write ( output ) <NEWLINE> <DEDENT> <DEDENT>
def reportValidity ( self ) : <NEWLINE> <INDENT> s_report = <STRING> . join ( [ self . __type_message , <NEWLINE> <INDENT> self . __value_message ] ) <NEWLINE> <DEDENT> return s_report <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from craftr . utils import path <NEWLINE> import os <NEWLINE> import sys <NEWLINE>
def assert_equal ( self , G , data = False ) : <NEWLINE> <INDENT> ( fd , fname ) = tempfile . mkstemp ( ) <NEWLINE> nx . write_yaml ( G , fname ) <NEWLINE> Gin = nx . read_yaml ( fname ) ; <NEWLINE> assert_equal ( sorted ( G . nodes ( ) ) , sorted ( Gin . nodes ( ) ) ) <NEWLINE> assert_equal ( G . edges ( data = data ) , Gin . edges ( data = data ) ) <NEWLINE> os . close ( fd ) <NEWLINE> os . unlink ( fname ) <NEWLINE> <DEDENT>
def calculateTip ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> total = float ( raw_input ( <STRING> ) ) <NEWLINE> rate = float ( raw_input ( <STRING> ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> tip = total * rate <NEWLINE> print ( <STRING> , tip ) <NEWLINE> return tip <NEWLINE> <DEDENT>
from twisted . spread import pb <NEWLINE> from twisted . internet import reactor <NEWLINE> from twisted . cred import credentials <NEWLINE>
def validate_review_groups ( form , field = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> groups = form . cleaned_data . get ( field , [ ] ) <NEWLINE> local_site = form . cleaned_data [ <STRING> ] <NEWLINE> for group in groups : <NEWLINE> <INDENT> if group . local_site != local_site : <NEWLINE> <INDENT> raise forms . ValidationError ( <NEWLINE> <INDENT> [ <STRING> % group . name ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return groups <NEWLINE> <DEDENT>
def decorate_A ( function ) : <NEWLINE> <INDENT> def wrap_function ( * args , ** kwargs ) : <NEWLINE> <INDENT> kwargs [ <STRING> ] = <STRING> <NEWLINE> return function ( * args , ** kwargs ) <NEWLINE> <DEDENT> return wrap_function <NEWLINE> <DEDENT>
def test_has_right_heading ( self ) : <NEWLINE> <INDENT> body = self . browser . find_element_by_tag_name ( <STRING> ) <NEWLINE> self . assertIn ( <STRING> , body . text ) <NEWLINE> <DEDENT>
class Severity ( object ) : <NEWLINE> <INDENT> low = 0 <NEWLINE> medium = 1 <NEWLINE> high = 2 <NEWLINE> critical = 3 <NEWLINE> <DEDENT>
def test_unicode_actor ( self ) : <NEWLINE> <INDENT> name = <STRING> . decode ( <STRING> ) <NEWLINE> assert len ( name ) == 9 <NEWLINE> special = Actor . _from_string ( <STRING> % name ) <NEWLINE> assert special . name == name <NEWLINE> assert isinstance ( special . name , unicode ) <NEWLINE> <DEDENT>
def __init__ ( self , max_width = 40 ) : <NEWLINE> <INDENT> self . _lines = [ ] <NEWLINE> self . _max_width = max_width <NEWLINE> <DEDENT>
def forwards ( self , orm ) : <NEWLINE> <INDENT> db . add_column ( <STRING> , <STRING> , <NEWLINE> <INDENT> self . gf ( <STRING> ) ( null = True , max_length = 200 , blank = True ) , <NEWLINE> keep_default = False ) <NEWLINE> <DEDENT> <DEDENT>
def main ( fragmentClass ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> s = Store ( ) <NEWLINE> start ( ) <NEWLINE> for i in xrange ( N_RENDERS ) : <NEWLINE> <INDENT> renderOnce ( fragmentClass ) <NEWLINE> <DEDENT> stop ( ) <NEWLINE> <DEDENT>
from __future__ import unicode_literals <NEWLINE> from django . db import migrations <NEWLINE> from django . conf import settings <NEWLINE> from corehq . sql_db . operations import RawSQLMigration , HqRunSQL <NEWLINE> migrator = RawSQLMigration ( ( <STRING> , <STRING> , <STRING> ) , { <NEWLINE> <INDENT> <STRING> : settings . PL_PROXY_CLUSTER_NAME <NEWLINE> <DEDENT> } ) <NEWLINE>
from setuptools import setup <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> version = <STRING> , <NEWLINE> license = <STRING> , <NEWLINE> author = <STRING> , <NEWLINE> description = <STRING> , <NEWLINE> install_requires = [ <STRING> ] , <NEWLINE> packages = [ <STRING> ] , <NEWLINE> tests_require = [ <STRING> ] , <NEWLINE> test_suite = <STRING> <NEWLINE> <DEDENT> ) <NEWLINE>
class NamespaceSerializer ( serializers . Serializer ) : <NEWLINE> <INDENT> id = serializers . CharField ( ) <NEWLINE> abbreviation = serializers . CharField ( ) <NEWLINE> name = serializers . CharField ( ) <NEWLINE> comment = serializers . CharField ( required = False ) <NEWLINE> schemaRef = serializers . CharField ( source = <STRING> ) <NEWLINE> def restore_object ( self , attrs , instance = None ) : <NEWLINE> <INDENT> return Namespace ( ** attrs ) <NEWLINE> <DEDENT> <DEDENT>
class MarkerType ( GrampsType ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> NONE = - 1 <NEWLINE> CUSTOM = 0 <NEWLINE> COMPLETE = 1 <NEWLINE> TODO_TYPE = 2 <NEWLINE> _CUSTOM = CUSTOM <NEWLINE> _DEFAULT = NONE <NEWLINE> _DATAMAP = [ <NEWLINE> <INDENT> ( NONE , <STRING> , <STRING> ) , <NEWLINE> ( CUSTOM , _ ( <STRING> ) , <STRING> ) , <NEWLINE> ( COMPLETE , _ ( <STRING> ) , <STRING> ) , <NEWLINE> ( TODO_TYPE , _ ( <STRING> ) , <STRING> ) , <NEWLINE> ] <NEWLINE> <DEDENT> def __init__ ( self , value = None ) : <NEWLINE> <INDENT> GrampsType . __init__ ( self , value ) <NEWLINE> <DEDENT> <DEDENT>
import os <NEWLINE> import sys <NEWLINE> import ConfigParser <NEWLINE> from utils import load_json <NEWLINE> from datetime import datetime <NEWLINE>
import math <NEWLINE> CircleArea = lambda r : math . pi * r * r <NEWLINE> print ( CircleArea ( 1 ) ) <NEWLINE>
<STRING> <NEWLINE> import re <NEWLINE> from flask . ext import wtf <NEWLINE> import wtforms <NEWLINE> from flask import g <NEWLINE> import IPy <NEWLINE> from mirrormanager2 . app import APP <NEWLINE> COUNTRY_REGEX = <STRING> <NEWLINE>
class Command ( BaseCommand ) : <NEWLINE> <INDENT> def handle ( self , * args , ** options ) : <NEWLINE> <INDENT> tweet = TweetAPI ( ) <NEWLINE> tweet . reply_mentions ( ) <NEWLINE> <DEDENT> <DEDENT>
class RandomLinkProviderTest ( unittest . TestCase ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def setUp ( self ) : <NEWLINE> <INDENT> self . provider = RandomLinkProvider ( ) <NEWLINE> <DEDENT> def testGetValue ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> value = self . provider . getValue ( ) <NEWLINE> self . assertTrue ( <STRING> in value ) <NEWLINE> <DEDENT> <DEDENT>
def show_user_message ( self , message , title = _ ( <STRING> ) ) : <NEWLINE> <INDENT> dialog = gtk . MessageDialog ( self . widgets . window1 , <NEWLINE> <INDENT> gtk . DIALOG_DESTROY_WITH_PARENT , <NEWLINE> gtk . MESSAGE_INFO , <NEWLINE> gtk . BUTTONS_OK ) <NEWLINE> <DEDENT> if title : <NEWLINE> <INDENT> dialog . set_title ( str ( title ) ) <NEWLINE> <DEDENT> dialog . set_markup ( message ) <NEWLINE> responce = dialog . run ( ) <NEWLINE> dialog . destroy ( ) <NEWLINE> return responce == gtk . RESPONSE_OK <NEWLINE> <DEDENT>
def grouping ( self , faceIds ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> body = { <STRING> : faceIds } <NEWLINE> return self . _invoke ( <STRING> , _groupingUrl , json = body , headers = { <STRING> : self . key } ) <NEWLINE> <DEDENT>
from portality . core import app <NEWLINE> import feedparser <NEWLINE> from portality . dao import DomainObject as DomainObject <NEWLINE> from copy import deepcopy <NEWLINE> from datetime import datetime <NEWLINE>
def f ( ) : <NEWLINE> <INDENT> global a <NEWLINE> a = a . upper ( ) <NEWLINE> <DEDENT>
def setup ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> global db , conn , session <NEWLINE> def ignore ( * args ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> push_exception_handler ( handler = ignore , reraise_exceptions = True ) <NEWLINE> db = sql . create_engine ( <STRING> ) <NEWLINE> metadata . bind = db <NEWLINE> metadata . create_all ( ) <NEWLINE> conn = db . connect ( ) <NEWLINE> session = orm . sessionmaker ( ) ( ) <NEWLINE> <DEDENT>
from django . contrib . sites . models import Site <NEWLINE> from django . db import models <NEWLINE> from django . utils . translation import ugettext as _ <NEWLINE> __author__ = <STRING> <NEWLINE>
from urllib . parse import urlencode <NEWLINE> from rest_framework import serializers <NEWLINE> from trackmap import trackmap <NEWLINE>
from __future__ import unicode_literals <NEWLINE> from django . db import models , migrations <NEWLINE> from decimal import Decimal <NEWLINE> import mezzanine . utils . models <NEWLINE> import mezzanine . core . fields <NEWLINE> import cartridge . shop . fields <NEWLINE> from mezzanine . conf import settings <NEWLINE>
class Migration ( migrations . Migration ) : <NEWLINE> <INDENT> dependencies = [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE> operations = [ <NEWLINE> <INDENT> migrations . AddField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> field = models . SmallIntegerField ( default = 0 , choices = [ ( 1 , <STRING> ) , ( 2 , <STRING> ) , ( 3 , <STRING> ) ] ) , <NEWLINE> preserve_default = False , <NEWLINE> <DEDENT> ) , <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT>
def test_get_text_expanded_deprecated ( self ) : <NEWLINE> <INDENT> text = self . page . get_expanded ( ) <NEWLINE> args = self . get_last_api_call_args ( ) <NEWLINE> assert args [ <STRING> ] == <STRING> <NEWLINE> <DEDENT>
import os <NEWLINE> import shutil <NEWLINE> from flask import render_template , redirect , request , url_for , flash , send_from_directory <NEWLINE> from flask_login import login_user , logout_user , login_required , current_user <NEWLINE> from . import log_analyzer <NEWLINE> from . . import db <NEWLINE> from . . models import * <NEWLINE> from . forms import * <NEWLINE> from . . FtpHelper import ftp_dl <NEWLINE> import time <NEWLINE> from . . import celery <NEWLINE> from config import Config <NEWLINE> from . . common_func import * <NEWLINE> from . . processLogcat import processLogcat <NEWLINE> import math <NEWLINE>
def __init__ ( self ) : <NEWLINE> <INDENT> super ( ColourSchemeChoice , self ) . __init__ ( ) <NEWLINE> self . _current = DARK_BACKGROUND <NEWLINE> previous = QSettings ( ) . value ( self . KEY ) <NEWLINE> if previous and previous in COLOURS : <NEWLINE> <INDENT> self . _current = COLOURS [ previous ] <NEWLINE> <DEDENT> <DEDENT>
import sqlparse <NEWLINE> from rsr . connections . backends . base import BaseDriver <NEWLINE> from rsr . schema import dbo <NEWLINE> from rsr . schema . base import BaseSchemaProvider <NEWLINE> try : <NEWLINE> <INDENT> import cx_Oracle <NEWLINE> <DEDENT> except ImportError as err : <NEWLINE> <INDENT> cx_Oracle = None <NEWLINE> <DEDENT>
from django . db import models <NEWLINE> MARK_CHOICES = ( <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ) <NEWLINE> TRAIN_CHOICES = ( <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ) <NEWLINE>
class Room ( object ) : <NEWLINE> <INDENT> def __init__ ( self , name , description ) : <NEWLINE> <INDENT> self . name = name <NEWLINE> self . description = description <NEWLINE> self . paths = { } <NEWLINE> <DEDENT> def go ( self , direction ) : <NEWLINE> <INDENT> return self . paths . get ( direction , None ) <NEWLINE> <DEDENT> def add_paths ( self , paths ) : <NEWLINE> <INDENT> self . paths . update ( paths ) <NEWLINE> return self <NEWLINE> <DEDENT> <DEDENT>
from django . conf . urls import url <NEWLINE> from . import views <NEWLINE> urlpatterns = [ <NEWLINE> <INDENT> url ( <STRING> , views . index , name = <STRING> ) , <NEWLINE> url ( <STRING> , views . schools ) , <NEWLINE> url ( <STRING> , views . teams ) , <NEWLINE> url ( <STRING> , views . team_details ) , <NEWLINE> <DEDENT> ] <NEWLINE>
class DnsRecordAdmin ( admin . ModelAdmin ) : <NEWLINE> <INDENT> search_fields = ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> list_filter = ( <STRING> , <STRING> ) <NEWLINE> list_display = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> <DEDENT>
def line ( self , x1 , y1 , x2 , y2 , pen = 1 , ** kwargs ) : <NEWLINE> <INDENT> l = sdxf . Line ( <NEWLINE> <INDENT> points = [ ( x1 , y1 ) , ( x2 , y2 ) ] , layer = pen , ** kwargs <NEWLINE> <DEDENT> ) <NEWLINE> self . dxf . append ( l ) <NEWLINE> return l <NEWLINE> <DEDENT>
def collided_with_level ( player_state , previous_position ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> player_state [ <STRING> ] = previous_position <NEWLINE> return player_state <NEWLINE> <DEDENT>
def playbook_basedir ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . _playbook_basedir <NEWLINE> <DEDENT>
def error ( self , text ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . to_cloud : <NEWLINE> <INDENT> self . safe_cloud_log_text ( text , severity = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . local_logger . error ( text ) <NEWLINE> <DEDENT> <DEDENT>
def load ( target ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> __import__ ( target ) <NEWLINE> Ice . updateModules ( ) <NEWLINE> <DEDENT>
def get_date ( row , key ) : <NEWLINE> <INDENT> if row [ key ] : <NEWLINE> <INDENT> return datetime . datetime . strptime ( row [ key ] , <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return datetime . datetime ( 1900 , 1 , 1 ) <NEWLINE> <DEDENT> <DEDENT>
def connect ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return BlockingConnection ( <NEWLINE> <INDENT> parameters = ConnectionParameters ( <NEWLINE> <INDENT> host = self . host , <NEWLINE> port = self . port , <NEWLINE> virtual_host = self . vhost , <NEWLINE> credentials = PlainCredentials ( <NEWLINE> <INDENT> username = self . user , <NEWLINE> password = self . passwd , <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def __len__ ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return len ( self . _dict_ ) <NEWLINE> <DEDENT>
def open ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> self . initialized = False <NEWLINE> <DEDENT>
def merge_reduce ( r , s ) : <NEWLINE> <INDENT> print ( r ) <NEWLINE> print ( s ) <NEWLINE> if r [ 1 ] >= s [ 0 ] : <NEWLINE> <INDENT> return [ r [ 0 ] , s [ 1 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return r , s <NEWLINE> <DEDENT> <DEDENT>
def test_connection ( port ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> sock = socket . create_connection ( ( <STRING> , port ) ) <NEWLINE> <DEDENT> except socket . error : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sock . close ( ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT>
def setup_celery_loader ( ) : <NEWLINE> <INDENT> os . environ . setdefault ( <STRING> , <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def _api_grid_image_edit ( self , method , url , body , headers ) : <NEWLINE> <INDENT> body = self . fixtures . load ( <STRING> ) <NEWLINE> return ( httplib . OK , body , { } , httplib . responses [ httplib . OK ] ) <NEWLINE> <DEDENT>
from gwt . ui . Image import ( <NEWLINE> <INDENT> ClickHandler , <NEWLINE> DOM , <NEWLINE> Event , <NEWLINE> Factory , <NEWLINE> Image , <NEWLINE> MouseHandler , <NEWLINE> Widget , <NEWLINE> prefetchImages , <NEWLINE> <DEDENT> ) <NEWLINE>
def num_cpus ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not hasattr ( os , <STRING> ) : <NEWLINE> <INDENT> raise RunTimeError ( <STRING> ) <NEWLINE> <DEDENT> return os . sysconf ( <STRING> ) <NEWLINE> <DEDENT>
def load_user ( user_id ) : <NEWLINE> <INDENT> user = db_user . get ( user_id ) <NEWLINE> if user : <NEWLINE> <INDENT> return User . from_dbrow ( user ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT>
def test_get_new_message_num ( self ) : <NEWLINE> <INDENT> recipient = users . create_user ( username = <STRING> , password = <STRING> ) <NEWLINE> epistle = self . create_epistle ( recipient = recipient ) <NEWLINE> result = epistle_queries . get_new_message_num ( recipient . id ) <NEWLINE> assert result == 1 <NEWLINE> <DEDENT>
def plot_cx3 ( hs , cx ) : <NEWLINE> <INDENT> ax = df2 . gca ( ) <NEWLINE> rchip = hs . get_chip ( cx ) <NEWLINE> ax . imshow ( rchip , interpolation = <STRING> ) <NEWLINE> df2 . plt . set_cmap ( <STRING> ) <NEWLINE> df2 . set_ticks ( [ ] , [ ] ) <NEWLINE> gname = hs . cx2_gname ( cx ) <NEWLINE> cid = hs . tables . cx2_cid [ cx ] <NEWLINE> ax . set_xlabel ( gname ) <NEWLINE> ax . set_title ( hs . cxstr ( cx ) ) <NEWLINE> <DEDENT>
def get_followers ( self , ** kwargs ) : <NEWLINE> <INDENT> _base_url = url_join ( self . base_url , self . user_id , <STRING> ) <NEWLINE> if len ( kwargs ) > 0 : <NEWLINE> <INDENT> _filters = urllib . urlencode ( kwargs ) <NEWLINE> _url = <STRING> % ( _base_url , self . auth_key , _filters ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> _url = <STRING> % ( _base_url , self . auth_key ) <NEWLINE> <DEDENT> return self . _parse_data ( self . _get_api_data ( _url ) [ <STRING> ] ) <NEWLINE> <DEDENT>
import sys , os <NEWLINE> import getopt <NEWLINE> import re <NEWLINE> import math <NEWLINE> import warnings <NEWLINE> from Bio import BiopythonExperimentalWarning <NEWLINE> warnings . simplefilter ( <STRING> , BiopythonExperimentalWarning ) <NEWLINE> from Bio . SeqRecord import SeqRecord <NEWLINE> from Bio import SearchIO <NEWLINE> from HMMPileUp import HMMPileUp , HMMSequence <NEWLINE>
def check_abort ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . abort ( ) : <NEWLINE> <INDENT> raise Abort <NEWLINE> <DEDENT> <DEDENT>
class TunelSSH ( ) : <NEWLINE> <INDENT> def __init__ ( self , ssh_address , ssh_port , ssh_username , ssh_password , remote_bind_address , remote_bind_port ) : <NEWLINE> <INDENT> self . server = SSHTunnelForwarder ( ssh_address = ( ssh_address , ssh_port ) , ssh_username = ssh_username , <NEWLINE> <INDENT> ssh_password = ssh_password , remote_bind_address = ( remote_bind_address , remote_bind_port ) ) <NEWLINE> <DEDENT> <DEDENT> def Iniciar ( self ) : <NEWLINE> <INDENT> self . server . start ( ) <NEWLINE> return self . server . local_bind_port <NEWLINE> <DEDENT> def Cerrar ( self ) : <NEWLINE> <INDENT> self . server . stop ( ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , ctx , rd ) : <NEWLINE> <INDENT> self . db , self . library_id , self . library_map , self . default_library = get_library_data ( ctx , rd ) <NEWLINE> self . ctx , self . rd = ctx , rd <NEWLINE> <DEDENT>
def tocke ( i ) : <NEWLINE> <INDENT> t = [ 25 , 20 , 15 , 12 , 10 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ] <NEWLINE> if i > len ( t ) - 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return t [ i ] <NEWLINE> <DEDENT>
def test_templates_avoiding_almost_identical_products ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for i in range ( 1 , dp . N_PROD_NONSENSE ) : <NEWLINE> <INDENT> target = <STRING> + str ( i ) <NEWLINE> templates = pttfidf . get_product_templates_tfidf ( self . session_context , [ target ] ) . get ( target , { } ) <NEWLINE> nose . tools . ok_ ( len ( templates ) > 0 , <NEWLINE> <INDENT> <STRING> + target ) <NEWLINE> <DEDENT> template_products = [ t [ 1 ] for t in templates ] <NEWLINE> way_too_similar = <STRING> + str ( i + 1 ) <NEWLINE> nose . tools . ok_ ( way_too_similar not in template_products , <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def __init__ ( self , institution = <STRING> ) : <NEWLINE> <INDENT> self . institution = institution <NEWLINE> self . sites = None <NEWLINE> self . site_manager = SiteManager ( ) <NEWLINE> <DEDENT>
def __init__ ( self , fps , seconds ) : <NEWLINE> <INDENT> self . fps = fps <NEWLINE> self . seconds = seconds <NEWLINE> self . length = self . secondsToFrames ( seconds ) <NEWLINE> self . buffer = deque ( [ ] , self . length ) <NEWLINE> <DEDENT>
def scipy_wrapper_gradient ( x , crit_func ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> assert ( isinstance ( x , np . ndarray ) ) <NEWLINE> assert ( np . all ( np . isfinite ( x ) ) ) <NEWLINE> assert ( x . dtype == <STRING> ) <NEWLINE> assert ( x . ndim == 1 ) <NEWLINE> grad = crit_func . evaluate ( x , <STRING> ) <NEWLINE> assert ( isinstance ( grad , np . ndarray ) ) <NEWLINE> assert ( np . all ( np . isfinite ( grad ) ) ) <NEWLINE> assert ( grad . dtype == <STRING> ) <NEWLINE> return grad <NEWLINE> <DEDENT>
def is_key_pressed_once ( self , key_code ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if sf . Keyboard . is_key_pressed ( key_code ) : <NEWLINE> <INDENT> if self . key_released . get ( key_code ) : <NEWLINE> <INDENT> self . key_released [ key_code ] = False <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> self . key_released [ key_code ] = True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
from setuptools import setup <NEWLINE> setup ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> version = <STRING> , <NEWLINE> description = <STRING> , <NEWLINE> url = <STRING> , <NEWLINE> author = <STRING> , <NEWLINE> license = <STRING> , <NEWLINE> packages = [ <STRING> ] , <NEWLINE> install_requires = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <DEDENT> ] , <NEWLINE> test_suite = <STRING> , <NEWLINE> tests_require = [ <STRING> ] , <NEWLINE> zip_safe = False , <NEWLINE> <DEDENT> ) <NEWLINE>
import time <NEWLINE> import threading <NEWLINE> import apigen <NEWLINE> __version__ = <STRING> <NEWLINE>
def save ( self , path , dir_name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> cookie_jar = os . path . join ( path , dir_name ) <NEWLINE> if not os . path . exists ( cookie_jar ) : <NEWLINE> <INDENT> os . mkdir ( dir_name ) <NEWLINE> for paths in self . cookie_paths : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> for filename in os . listdir ( paths ) : <NEWLINE> <INDENT> shutil . copy ( os . path . join ( paths , filename ) , cookie_jar ) <NEWLINE> <DEDENT> <DEDENT> except Exception : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
class TimeoutHTTPConnection ( httplib . HTTPConnection ) : <NEWLINE> <INDENT> def __init__ ( self , timeout_s , * args , ** kwargs ) : <NEWLINE> <INDENT> httplib . HTTPConnection . __init__ ( self , * args , ** kwargs ) <NEWLINE> self . timeout_s = timeout_s <NEWLINE> <DEDENT> def settimeout ( self , timeout_s ) : <NEWLINE> <INDENT> self . timeout_s = timeout_s <NEWLINE> self . sock . settimeout ( self . timeout_s ) <NEWLINE> <DEDENT> def connect ( self ) : <NEWLINE> <INDENT> httplib . HTTPConnection . connect ( self ) <NEWLINE> self . sock . settimeout ( self . timeout_s ) <NEWLINE> <DEDENT> <DEDENT>
class SubmissionHelpManager ( models . Manager ) : <NEWLINE> <INDENT> def get_active ( self ) : <NEWLINE> <INDENT> return self . filter ( status = self . model . PUBLISHED ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import time <NEWLINE> import numpy as np <NEWLINE> import snr_of_images <NEWLINE> import urllib <NEWLINE> import zlib <NEWLINE> from io import BytesIO <NEWLINE> import cv2 <NEWLINE> import h5py <NEWLINE> import os <NEWLINE> import matplotlib . pyplot as plt <NEWLINE> import json <NEWLINE> import requests <NEWLINE> from requests . packages . urllib3 . exceptions import InsecureRequestWarning <NEWLINE> sbem_skip = False <NEWLINE> atum_skip = False <NEWLINE> fbem_skip = False <NEWLINE> temca_skip = False <NEWLINE> OCP_server = <STRING> <NEWLINE> n_comp = 100 <NEWLINE>
def StoreFrom ( self , sender , authAddress = <STRING> ) : <NEWLINE> <INDENT> command = <STRING> % ( sender , authAddress ) <NEWLINE> self . stream . Write ( command ) <NEWLINE> r = self . stream . GetResponse ( ) <NEWLINE> if r . code != 1000 : <NEWLINE> <INDENT> raise bongo . BongoError ( r . message ) <NEWLINE> <DEDENT> return r <NEWLINE> <DEDENT>
def resttext ( text ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> overrides = { <NEWLINE> <INDENT> <STRING> : 3 , <NEWLINE> <STRING> : 5 , <NEWLINE> <DEDENT> } <NEWLINE> if RESTRICT_REST : <NEWLINE> <INDENT> return text <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> from docutils . core import publish_parts <NEWLINE> parts = publish_parts ( source = text , writer_name = <STRING> , <NEWLINE> <INDENT> settings_overrides = overrides ) <NEWLINE> <DEDENT> return mark_safe ( parts [ <STRING> ] ) <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> return text <NEWLINE> <DEDENT> except Exception as ex1 : <NEWLINE> <INDENT> logger . fatal ( repr ( ex1 ) ) <NEWLINE> return text <NEWLINE> <DEDENT> <DEDENT>
def onHide ( self , event ) : <NEWLINE> <INDENT> super ( ClothesTaskView , self ) . onHide ( event ) <NEWLINE> self . visualizeFaceMasks ( False ) <NEWLINE> <DEDENT>
def csv ( self , request ) : <NEWLINE> <INDENT> uuid = request . QUERY_PARAMS . get ( <STRING> , None ) <NEWLINE> if uuid is None : <NEWLINE> <INDENT> return response . NotFound ( ) <NEWLINE> <DEDENT> project = get_object_or_404 ( Project , issues_csv_uuid = uuid ) <NEWLINE> queryset = project . issues . all ( ) . order_by ( <STRING> ) <NEWLINE> data = services . issues_to_csv ( project , queryset ) <NEWLINE> csv_response = HttpResponse ( data . getvalue ( ) , content_type = <STRING> ) <NEWLINE> csv_response [ <STRING> ] = <STRING> <NEWLINE> return csv_response <NEWLINE> <DEDENT>
class CredentialsField ( models . Field ) : <NEWLINE> <INDENT> __metaclass__ = models . SubfieldBase <NEWLINE> def db_type ( self , connection = None ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> def to_python ( self , value ) : <NEWLINE> <INDENT> if not value : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> if isinstance ( value , oauth2client . client . Credentials ) : <NEWLINE> <INDENT> return value <NEWLINE> <DEDENT> return pickle . loads ( base64 . b64decode ( value ) ) <NEWLINE> <DEDENT> def get_db_prep_value ( self , value ) : <NEWLINE> <INDENT> return base64 . b64encode ( pickle . dumps ( value ) ) <NEWLINE> <DEDENT> <DEDENT>
def get_subcommands ( ) : <NEWLINE> <INDENT> if brkt_cli . crypto . cryptography_library_available : <NEWLINE> <INDENT> return [ MakeKeySubcommand ( ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> <DEDENT>
def on_postpone_clicked ( self , button ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . postpone_break ( ) <NEWLINE> <DEDENT>
class ReceiveMail ( RunnableLeaf ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> RunnableLeaf . __init__ ( self , name = _ ( <STRING> ) ) <NEWLINE> <DEDENT> def run ( self ) : <NEWLINE> <INDENT> utils . spawn_async ( [ <STRING> , <STRING> ] ) <NEWLINE> <DEDENT> def get_description ( self ) : <NEWLINE> <INDENT> return _ ( <STRING> ) <NEWLINE> <DEDENT> def get_icon_name ( self ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT>
def prompt ( desc , default = None ) : <NEWLINE> <INDENT> if default : <NEWLINE> <INDENT> desc = <STRING> % ( desc , default ) <NEWLINE> <DEDENT> return raw_input ( <STRING> % desc ) or default <NEWLINE> <DEDENT>
def split_input ( query_input ) : <NEWLINE> <INDENT> quotes_input = [ ] <NEWLINE> values = query_input . split ( <STRING> ) <NEWLINE> quotes_input = filter ( None , values ) <NEWLINE> spaced_input = [ ] <NEWLINE> data = [ ] <NEWLINE> for unit in quotes_input : <NEWLINE> <INDENT> new_unit = unit . split ( <STRING> ) <NEWLINE> if isinstance ( new_unit , list ) : <NEWLINE> <INDENT> new_unit = list ( filter ( None , new_unit ) ) <NEWLINE> data . append ( new_unit ) <NEWLINE> <DEDENT> elif new_unit != <STRING> : <NEWLINE> <INDENT> data . append ( new_unit ) <NEWLINE> <DEDENT> <DEDENT> spaced_input . append ( data ) <NEWLINE> return spaced_input <NEWLINE> <DEDENT>
def write ( x , y , z , a , outname ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> out = file ( outname + <STRING> , <STRING> ) <NEWLINE> out . writelines ( <STRING> ) <NEWLINE> out . writelines ( <STRING> . join ( str ( np . around ( s , decimals = 3 ) ) for s in [ x , y , z , a ] ) + <STRING> ) <NEWLINE> out . close ( ) <NEWLINE> <DEDENT>
import time <NEWLINE> import json <NEWLINE> import sys <NEWLINE> from os . path import join , dirname <NEWLINE> from cloudify import ctx <NEWLINE> ctx . download_resource ( <NEWLINE> <INDENT> join ( <STRING> , <STRING> ) , <NEWLINE> join ( dirname ( __file__ ) , <STRING> ) ) <NEWLINE> <DEDENT> import utils <NEWLINE> CONFIG_PATH = <STRING> <NEWLINE> INFLUX_SERVICE_NAME = <STRING> <NEWLINE> ctx_properties = utils . ctx_factory . create ( INFLUX_SERVICE_NAME ) <NEWLINE>
class Prob5_Part14 : <NEWLINE> <INDENT> <STRING> <NEWLINE> def check_attempt ( self , params ) : <NEWLINE> <INDENT> self . attempt = params [ <STRING> ] <NEWLINE> self . answer = params [ <STRING> ] <NEWLINE> self . att_tree = params [ <STRING> ] <NEWLINE> self . ans_tree = params [ <STRING> ] <NEWLINE> matches = find_matches ( params ) <NEWLINE> matching_node = [ m [ 0 ] for m in matches ] <NEWLINE> try : <NEWLINE> <INDENT> return <STRING> , <STRING> <NEWLINE> <DEDENT> except Exception : <NEWLINE> <INDENT> return <STRING> , <STRING> <NEWLINE> <DEDENT> <DEDENT> def get_problems ( self ) : <NEWLINE> <INDENT> self . problem_list = [ <STRING> ] <NEWLINE> return self . problem_list <NEWLINE> <DEDENT> <DEDENT>
import asyncio <NEWLINE> from argparse import Namespace <NEWLINE> from protocol . shadowsocks . client import ShadowsocksClientRelayProtocol <NEWLINE> from protocol . socks5 . header import Socks5AddrHeader <NEWLINE> from protocol . socks5 . socks5_server import SOCKS5ServerStreamProtocol <NEWLINE>
def __get_episode_links ( self , video , views , html ) : <NEWLINE> <INDENT> pattern = <STRING> <NEWLINE> hosters = [ ] <NEWLINE> for match in re . finditer ( pattern , html , re . DOTALL ) : <NEWLINE> <INDENT> q_str , fragment = match . groups ( ) <NEWLINE> hosters += self . __get_links ( video , views , fragment , q_str ) <NEWLINE> <DEDENT> return hosters <NEWLINE> <DEDENT>
import purchase_line_invoice <NEWLINE> import stock_partial_picking <NEWLINE>
def save ( self , commit = True ) : <NEWLINE> <INDENT> user = super ( UserEditProfile , self ) . save ( commit = False ) <NEWLINE> user . email = self . cleaned_data [ <STRING> ] <NEWLINE> if commit : <NEWLINE> <INDENT> user . save ( ) <NEWLINE> <DEDENT> return user <NEWLINE> <DEDENT>
from django . conf . urls import patterns , include , url <NEWLINE> from antxetamedia . projects . views import ( ProjectList , YearProjectList , <NEWLINE> <INDENT> ProjectDetail ) <NEWLINE> <DEDENT> urlpatterns = patterns ( <STRING> , <NEWLINE> <INDENT> url ( <STRING> , ProjectList . as_view ( ) , name = <STRING> ) , <NEWLINE> url ( <STRING> , YearProjectList . as_view ( ) , name = <STRING> ) , <NEWLINE> url ( <STRING> , ProjectDetail . as_view ( ) , name = <STRING> ) , <NEWLINE> ) <NEWLINE> <DEDENT>
def create_user ( self , email , date_of_birth , password = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not email : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> user = self . model ( <NEWLINE> <INDENT> email = MyUserManager . normalize_email ( email ) , <NEWLINE> date_of_birth = date_of_birth , <NEWLINE> <DEDENT> ) <NEWLINE> user . set_password ( password ) <NEWLINE> user . save ( using = self . _db ) <NEWLINE> return user <NEWLINE> <DEDENT>
def header ( self , cols , parent_row ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> out = [ ] <NEWLINE> for col in cols : <NEWLINE> <INDENT> if col == <STRING> : <NEWLINE> <INDENT> out . append ( self . name_for ( <STRING> , parent_row [ <STRING> ] ) ) <NEWLINE> <DEDENT> elif col == <STRING> : <NEWLINE> <INDENT> out . append ( self . name_for ( <STRING> , parent_row [ <STRING> ] ) ) <NEWLINE> <DEDENT> elif col == <STRING> : <NEWLINE> <INDENT> out . append ( self . name_for ( <STRING> , parent_row [ <STRING> ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> out . append ( col ) <NEWLINE> <DEDENT> <DEDENT> return out <NEWLINE> <DEDENT>
class Printer ( simplelist . Printer ) : <NEWLINE> <INDENT> def __init__ ( self , name , format = <STRING> , ** kwargs ) : <NEWLINE> <INDENT> super ( Printer , self ) . __init__ ( name , ** kwargs ) <NEWLINE> self . frmt = format <NEWLINE> <DEDENT> def __repr__ ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return <STRING> % ( __name__ , self . destfile , <NEWLINE> <INDENT> self . frmt ) <NEWLINE> <DEDENT> <DEDENT> def print_ ( self , host , till ) : <NEWLINE> <INDENT> self . outf . write ( self . frmt % { <STRING> : host , <STRING> : till } + self . nl ) <NEWLINE> <DEDENT> <DEDENT>
class c_InternalUseArea ( Structure ) : <NEWLINE> <INDENT> _fields_ = [ <NEWLINE> <INDENT> ( <STRING> , c_ubyte ) , <NEWLINE> ( <STRING> , c_int ) , <NEWLINE> ( <STRING> , c_char_p ) <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT>
import time , shutil <NEWLINE> import sys , os , string , re <NEWLINE> from dict4ini import DictIni <NEWLINE> from Karrigell_QuickForm import Karrigell_QuickForm <NEWLINE> qpath = <STRING> <NEWLINE> pubq = qpath + <STRING> <NEWLINE> cfgf = pubq <NEWLINE> tcode = time . strftime ( <STRING> , time . localtime ( ) ) <NEWLINE> tcode = time . strftime ( <STRING> , time . localtime ( ) ) <NEWLINE>
from distutils . core import setup <NEWLINE> description = open ( <STRING> ) . read ( ) <NEWLINE> setup ( name = <STRING> , <NEWLINE> <INDENT> version = <STRING> , <NEWLINE> description = <STRING> , <NEWLINE> author = <STRING> , <NEWLINE> author_email = <STRING> , <NEWLINE> url = <STRING> , <NEWLINE> packages = [ <STRING> ] , <NEWLINE> long_description = description <NEWLINE> ) <NEWLINE> <DEDENT>
from nova import db <NEWLINE> from nova import exception <NEWLINE> from nova import objects <NEWLINE> from nova . objects import base <NEWLINE> from nova . objects import fields <NEWLINE> from nova import utils <NEWLINE>
def transpile_setup ( self ) : <NEWLINE> <INDENT> self . add_opcodes ( <NEWLINE> <INDENT> JavaOpcodes . GETSTATIC ( <STRING> , <STRING> , <STRING> ) , <NEWLINE> JavaOpcodes . LDC_W ( self . module . descriptor ) , <NEWLINE> JavaOpcodes . NEW ( <STRING> ) , <NEWLINE> JavaOpcodes . DUP ( ) , <NEWLINE> JavaOpcodes . LDC_W ( self . module . class_name ) , <NEWLINE> JavaOpcodes . INVOKESTATIC ( <STRING> , <STRING> , <STRING> ) , <NEWLINE> JavaOpcodes . INVOKESPECIAL ( <STRING> , <STRING> , <STRING> ) , <NEWLINE> JavaOpcodes . INVOKEINTERFACE ( <STRING> , <STRING> , <STRING> ) , <NEWLINE> JavaOpcodes . POP ( ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import mock <NEWLINE> from cinder import test <NEWLINE> from cinder . tests . volume . drivers . netapp import fakes as na_fakes <NEWLINE> from cinder . volume . drivers . netapp . eseries import client as es_client <NEWLINE> from cinder . volume . drivers . netapp . eseries import iscsi as es_iscsi <NEWLINE> from cinder . volume . drivers . netapp import utils as na_utils <NEWLINE>
from opus_core . variables . variable import Variable <NEWLINE> from variable_functions import my_attribute_label <NEWLINE> from urbansim . functions import attribute_label <NEWLINE> from numpy import array <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> app = MouseDetails ( ) <NEWLINE> app . mainloop ( ) <NEWLINE> <DEDENT>
class Migration ( migrations . Migration ) : <NEWLINE> <INDENT> dependencies = [ <NEWLINE> ] <NEWLINE> operations = [ <NEWLINE> <INDENT> migrations . CreateModel ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> fields = [ <NEWLINE> <INDENT> ( <STRING> , models . AutoField ( serialize = False , auto_created = True , primary_key = True , verbose_name = <STRING> ) ) , <NEWLINE> ( <STRING> , models . CharField ( max_length = 32 , verbose_name = <STRING> ) ) , <NEWLINE> ( <STRING> , models . IntegerField ( verbose_name = <STRING> ) ) , <NEWLINE> <DEDENT> ] , <NEWLINE> <DEDENT> ) , <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT>
def __init__ ( self , * args , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> super ( ExpressionEngine , self ) . __init__ ( * args , ** kwargs ) <NEWLINE> self . _environment = Environment ( self ) <NEWLINE> self . _environment . filters . update ( builtin_filters ) <NEWLINE> self . _register_custom_filters ( ) <NEWLINE> self . _environment . filters [ <STRING> ] = self . _filter_mark_safe <NEWLINE> for name , function in self . _environment . filters . items ( ) : <NEWLINE> <INDENT> self . _environment . filters [ name ] = self . _wrap_jinja_filter ( function ) <NEWLINE> <DEDENT> self . _escape = None <NEWLINE> self . _safe_wrapper = None <NEWLINE> <DEDENT>
class Normalizer ( BaseEstimator , TransformerMixin ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , norm = <STRING> , copy = True ) : <NEWLINE> <INDENT> self . norm = norm <NEWLINE> self . copy = copy <NEWLINE> <DEDENT> def fit ( self , X , y = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self <NEWLINE> <DEDENT> def transform ( self , X , y = None , copy = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> copy = copy if copy is not None else self . copy <NEWLINE> return normalize ( X , norm = self . norm , axis = 1 , copy = copy ) <NEWLINE> <DEDENT> <DEDENT>
def simple_mpi_map ( run , args ) : <NEWLINE> <INDENT> print ( <STRING> , rank , <STRING> ) <NEWLINE> hypo_set = run ( * ( args [ rank ] ) ) <NEWLINE> global prefix <NEWLINE> dump ( hypo_set , open ( prefix + <STRING> + options . LANG + <STRING> % rank + suffix + <STRING> , <STRING> ) ) <NEWLINE> <DEDENT>
def test_patch_and_unpatch_method ( self ) : <NEWLINE> <INDENT> def _list ( * args ) : <NEWLINE> <INDENT> return list ( * args ) <NEWLINE> <DEDENT> monkeypatcher = MonkeyPatcher ( { _list : <STRING> } ) <NEWLINE> self . assertEqual ( len ( set ( [ 1 , 2 , 1 ] ) ) , 2 ) <NEWLINE> monkeypatcher . monkeypatch ( ) <NEWLINE> self . assertEqual ( len ( set ( [ 1 , 2 , 1 ] ) ) , 3 ) <NEWLINE> monkeypatcher . unpatch ( ) <NEWLINE> self . assertEqual ( len ( set ( [ 1 , 2 , 1 ] ) ) , 2 ) <NEWLINE> <DEDENT>
def test_popup_ascii ( ) : <NEWLINE> <INDENT> popup = Popup ( <STRING> ) <NEWLINE> _id = list ( popup . html . _children . keys ( ) ) [ 0 ] <NEWLINE> kw = dict ( id = _id , <NEWLINE> <INDENT> width = <STRING> , <NEWLINE> height = <STRING> , <NEWLINE> text = <STRING> ) <NEWLINE> <DEDENT> assert <STRING> . join ( popup . html . render ( ) . split ( ) ) == <STRING> . join ( tmpl ( ** kw ) . split ( ) ) <NEWLINE> <DEDENT>
def serialize ( self , include_obsolete = False , raw = False ) : <NEWLINE> <INDENT> return self . pipeline ( <NEWLINE> <INDENT> self . tostring ( include_obsolete = include_obsolete , raw = raw ) ) <NEWLINE> <DEDENT> <DEDENT>
def train ( ) : <NEWLINE> <INDENT> salary_result = { } <NEWLINE> train_feature , test_feature , train_id_list , test_id_list , train_tar_list = merge_feature ( feature_str ) <NEWLINE> target_list = np . array ( train_tar_list ) <NEWLINE> c_feature = train_feature . columns [ : ] <NEWLINE> clf1 = RandomForestClassifier ( n_estimators = 200 , min_samples_split = 9 ) <NEWLINE> clf1 . fit ( train_feature [ c_feature ] , target_list ) <NEWLINE> preds1 = clf1 . predict ( test_feature ) <NEWLINE> for j in range ( len ( preds1 ) ) : <NEWLINE> <INDENT> salary_result [ test_id_list [ j ] ] = preds1 [ j ] <NEWLINE> <DEDENT> return salary_result <NEWLINE> <DEDENT>
def do_if ( do_then , do_test , do_else ) : <NEWLINE> <INDENT> def branch ( dv , vv , stack ) : <NEWLINE> <INDENT> test_value = stack . pop ( ) <NEWLINE> if test_value : return 1 <NEWLINE> else : return 1 + len ( do_then ) + 1 <NEWLINE> <DEDENT> def goto ( dv , vv , stack ) : <NEWLINE> <INDENT> return 1 + len ( do_else ) <NEWLINE> <DEDENT> return do_test + ( branch , ) + do_then + ( goto , ) + do_else <NEWLINE> <DEDENT>
def cossin ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> n = self . norm2 ( ) <NEWLINE> if n == 0. : <NEWLINE> <INDENT> return 1. , 0. <NEWLINE> <DEDENT> n = n ** 0.5 <NEWLINE> p = GeometryPoint ( 1. , 0. ) <NEWLINE> cos = self . scalar ( p ) / n <NEWLINE> sin = self . product ( p ) / n <NEWLINE> return cos , sin <NEWLINE> <DEDENT>
from django import forms <NEWLINE> from djforms . core . models import STATE_CHOICES , BINARY_CHOICES <NEWLINE> from djforms . biology . genomics . models import PhageHunter <NEWLINE> from localflavor . us . forms import USPhoneNumberField , USZipCodeField <NEWLINE>
def testInfoBarDisappearByReload ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> creds = self . GetPrivateInfo ( ) [ <STRING> ] <NEWLINE> test_utils . GoogleAccountsLogin ( self , creds [ <STRING> ] , creds [ <STRING> ] ) <NEWLINE> self . PerformActionOnInfobar ( <NEWLINE> <INDENT> <STRING> , infobar_index = self . _GetIndexForSavePasswordInfobar ( ) ) <NEWLINE> <DEDENT> self . GetBrowserWindow ( 0 ) . GetTab ( 0 ) . Reload ( ) <NEWLINE> self . assertTrue ( self . WaitForInfobarCount ( 0 ) ) <NEWLINE> self . assertFalse ( self . GetBrowserInfo ( ) [ <STRING> ] [ 0 ] [ <STRING> ] [ 0 ] [ <STRING> ] ) <NEWLINE> <DEDENT>
def stop ( self ) : <NEWLINE> <INDENT> self . logger . info ( <STRING> ) <NEWLINE> delete_all_jobs ( self . cron ) <NEWLINE> <DEDENT>
def call_ad_extension ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . _ad_extension <NEWLINE> <DEDENT>
class ConfigOpenNebula : <NEWLINE> <INDENT> TEMPLATE_CONTEXT = <STRING> <NEWLINE> TEMPLATE_OTHER = <STRING> <NEWLINE> IMAGE_UNAME = <STRING> <NEWLINE> TTS_URL = <STRING> <NEWLINE> <DEDENT>
def angle ( self , value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . _angle = value <NEWLINE> <DEDENT>
def __build_cmd ( self , infname , outdir , threads ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> cmd = [ <STRING> , <NEWLINE> <INDENT> infname , <NEWLINE> <STRING> ] <NEWLINE> <DEDENT> self . _cmd = <STRING> . join ( cmd ) <NEWLINE> <DEDENT>
class BasecampOAuth2Adapter ( OAuth2Adapter ) : <NEWLINE> <INDENT> provider_id = BasecampProvider . id <NEWLINE> access_token_url = <STRING> <NEWLINE> authorize_url = <STRING> <NEWLINE> profile_url = <STRING> <NEWLINE> def complete_login ( self , request , app , token , ** kwargs ) : <NEWLINE> <INDENT> headers = { <STRING> : <STRING> . format ( token . token ) } <NEWLINE> resp = requests . get ( self . profile_url , headers = headers ) <NEWLINE> extra_data = resp . json ( ) <NEWLINE> return self . get_provider ( ) . sociallogin_from_response ( request , <NEWLINE> <INDENT> extra_data ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def normalize_latent ( self , log_p_y_given_x_unnorm ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> log_z = logsumexp ( log_p_y_given_x_unnorm , axis = 2 ) <NEWLINE> log_z = log_z . reshape ( ( self . n_hidden , - 1 , 1 ) ) <NEWLINE> return np . exp ( log_p_y_given_x_unnorm - log_z ) , log_z <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from __future__ import absolute_import , print_function <NEWLINE> from copy import deepcopy <NEWLINE> from helpers import publish_and_expunge <NEWLINE>
<STRING> <NEWLINE> from . . import app <NEWLINE> from . . import utils <NEWLINE> redis_obj = None <NEWLINE> url = app . config . get ( <STRING> ) <NEWLINE> if not url : <NEWLINE> <INDENT> url = app . config . get ( <STRING> ) <NEWLINE> app . logger . debug ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> app . logger . debug ( <STRING> ) <NEWLINE> <DEDENT> if not url : <NEWLINE> <INDENT> app . logger . warning ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> redis_obj = utils . configure_redis_from_url ( url ) <NEWLINE> if redis_obj is None : <NEWLINE> <INDENT> app . logger . warning ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def feet_to_meters ( feet ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return feet * 0.3048 <NEWLINE> <DEDENT>
class msvs6aTestCase ( msvsTestCase ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> registry = DummyRegistry ( regdata_6a + regdata_cv ) <NEWLINE> default_version = <STRING> <NEWLINE> highest_version = <STRING> <NEWLINE> number_of_versions = 1 <NEWLINE> install_locs = { <NEWLINE> <INDENT> <STRING> : { <STRING> : <STRING> , <STRING> : <STRING> } , <NEWLINE> <STRING> : { } , <NEWLINE> <STRING> : { } , <NEWLINE> <STRING> : { } , <NEWLINE> <STRING> : { } , <NEWLINE> <DEDENT> } <NEWLINE> default_install_loc = install_locs [ <STRING> ] <NEWLINE> <DEDENT>
def parse_args ( ) -> argparse . Namespace : <NEWLINE> <INDENT> <STRING> <NEWLINE> parser = argparse . ArgumentParser ( ) <NEWLINE> parser . add_argument ( <STRING> , help = <STRING> ) <NEWLINE> parser . add_argument ( <STRING> , <STRING> , action = <STRING> , help = <STRING> ) <NEWLINE> parser . add_argument ( <STRING> , <STRING> , action = <STRING> , help = <STRING> ) <NEWLINE> parser . add_argument ( <STRING> , <STRING> , action = <STRING> , help = <STRING> ) <NEWLINE> parser . add_argument ( <STRING> , <STRING> , nargs = <STRING> , help = <STRING> ) <NEWLINE> return parser . parse_args ( ) <NEWLINE> <DEDENT>
def get_file_compression ( file_name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not os . path . isfile ( file_name ) : <NEWLINE> <INDENT> raise GenestackException ( <STRING> <NEWLINE> <INDENT> <STRING> % file_name ) <NEWLINE> <DEDENT> <DEDENT> return _get_file_compression_unchecked ( file_name ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import MySQLdb as mdb <NEWLINE> from database import * <NEWLINE> from utils import * <NEWLINE> config = read_config_file ( get_absolute_path ( <STRING> ) ) <NEWLINE> con = get_mysql_con ( 0 , config , debug = False ) <NEWLINE> schema = read_config_file ( get_absolute_path ( <STRING> ) ) <NEWLINE> tables = schema . sections ( ) <NEWLINE> for table_name in tables : <NEWLINE> <INDENT> fields_dict = config_section_map ( schema , table_name ) <NEWLINE> create_table ( con , table_name , fields_dict , debug = True ) <NEWLINE> <DEDENT>
def check_handshake ( self , data ) : <NEWLINE> <INDENT> if data [ : 20 ] != BT_HEADER [ : 20 ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if data [ 28 : 48 ] != self . infohash : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if data [ 25 ] != 16 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT>
def __str__ ( self ) : <NEWLINE> <INDENT> r = self . powerline . render ( <NEWLINE> <INDENT> width = zsh . columns ( ) , <NEWLINE> side = self . side , <NEWLINE> segment_info = { <STRING> : self . args , <STRING> : environ } <NEWLINE> <DEDENT> ) <NEWLINE> if type ( r ) is not str : <NEWLINE> <INDENT> if type ( r ) is bytes : <NEWLINE> <INDENT> return r . decode ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return r . encode ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return r <NEWLINE> <DEDENT>
def exp ( math_func ) : <NEWLINE> <INDENT> if isinstance ( math_func , MathFunc ) : <NEWLINE> <INDENT> return math_func . op ( op = e ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return e ( math_func ) <NEWLINE> <DEDENT> <DEDENT>
def get_backend ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> backend_class = settings . ADYEN_BACKEND <NEWLINE> <DEDENT> except AttributeError : <NEWLINE> <INDENT> backend_class = <STRING> <NEWLINE> <DEDENT> return resolve ( backend_class ) ( ) <NEWLINE> <DEDENT>
def __init__ ( self , ** kwargs ) : <NEWLINE> <INDENT> print ( kwargs ) <NEWLINE> self . name = kwargs [ <STRING> ] <NEWLINE> self . dir = kwargs [ <STRING> ] <NEWLINE> self . only_the_test_simplesample = True <NEWLINE> <DEDENT>
import gtk <NEWLINE> ruta = <STRING> <NEWLINE>
def smoke_test_module ( ) : <NEWLINE> <INDENT> unpickable = lambda x : x <NEWLINE> assert not is_pickable ( unpickable ) <NEWLINE> assert is_pickable ( 1 ) <NEWLINE> <DEDENT>
class CommentAdmin ( TranslationAdmin ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> pass <NEWLINE> <DEDENT>
from __future__ import with_statement <NEWLINE> from alembic import context <NEWLINE> from sqlalchemy import engine_from_config , pool <NEWLINE> from logging . config import fileConfig <NEWLINE> config = context . config <NEWLINE> fileConfig ( config . config_file_name ) <NEWLINE> import perpetualfailure . db <NEWLINE> import perpetualfailure . news . models <NEWLINE> import perpetualfailure . knowledgebase . models <NEWLINE> import perpetualfailure . authn . user <NEWLINE> import temporals_web . gmod . models <NEWLINE> import temporals_web . auth <NEWLINE> target_metadata = perpetualfailure . db . Base . metadata <NEWLINE>
import requests <NEWLINE> import six . moves . http_client as http_client <NEWLINE> from st2actions . runners import pythonrunner <NEWLINE> __all__ = [ <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> ] <NEWLINE> BASE_URL = <STRING> <NEWLINE> MAX_PAGE_NUMBER = 100 <NEWLINE>
def get_authors ( pr ) : <NEWLINE> <INDENT> print ( <STRING> % pr [ <STRING> ] , file = sys . stderr ) <NEWLINE> h = make_auth_header ( ) <NEWLINE> r = requests . get ( pr [ <STRING> ] , headers = h ) <NEWLINE> r . raise_for_status ( ) <NEWLINE> commits = r . json ( ) <NEWLINE> authors = [ ] <NEWLINE> for commit in commits : <NEWLINE> <INDENT> author = commit [ <STRING> ] [ <STRING> ] <NEWLINE> authors . append ( <STRING> % ( author [ <STRING> ] , author [ <STRING> ] ) ) <NEWLINE> <DEDENT> return authors <NEWLINE> <DEDENT>
import re <NEWLINE> from threading import Lock <NEWLINE> import crash_utils <NEWLINE> REVIEW_URL_PATTERN = re . compile ( <STRING> ) <NEWLINE>
def date_decoder ( obj ) : <NEWLINE> <INDENT> if <STRING> in obj : <NEWLINE> <INDENT> if obj [ <STRING> ] == <STRING> : <NEWLINE> <INDENT> return datetime . fromtimestamp ( obj [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT> return obj <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import six <NEWLINE> import warnings <NEWLINE> coordname = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE>
def test_page_num_not_int_defaults_to_one ( self ) : <NEWLINE> <INDENT> request = Mock ( ) <NEWLINE> request . args = { <STRING> : <STRING> } <NEWLINE> request . cookies = { } <NEWLINE> user = Mock ( ) <NEWLINE> TASK_ID = 1 <NEWLINE> with self . app . app_context ( ) : <NEWLINE> <INDENT> result = self . vl . task ( request , user , TASK_ID ) <NEWLINE> <DEDENT> self . ll . get_task_data . assert_called_with ( TASK_ID , user , <NEWLINE> <INDENT> include_deleted = None , <NEWLINE> include_done = None , <NEWLINE> page_num = 1 , tasks_per_page = 20 ) <NEWLINE> <DEDENT> self . r . render_template . assert_called ( ) <NEWLINE> <DEDENT>
def delete ( self ) : <NEWLINE> <INDENT> headers , data = self . _requester . requestAndCheck ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> self . url , <NEWLINE> None , <NEWLINE> None <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def test_retrieve_activity ( self ) : <NEWLINE> <INDENT> response = self . client . get ( reverse ( <STRING> , kwargs = { <STRING> : 1 } ) , <NEWLINE> <INDENT> format = <STRING> ) <NEWLINE> <DEDENT> self . assertEqual ( response . status_code , status . HTTP_200_OK ) <NEWLINE> <DEDENT>
from pychron . core . ui . factory import toolkit_factory <NEWLINE> LaserStatusEditor = toolkit_factory ( <STRING> , <STRING> ) <NEWLINE>
def draw ( self , context ) : <NEWLINE> <INDENT> layout = self . layout <NEWLINE> obj = context . object <NEWLINE> layout . operator_menu_enum ( <STRING> , <STRING> ) <NEWLINE> modifiers = sorted ( obj . plasma_modifiers . modifiers , key = lambda x : x . display_order ) <NEWLINE> for i in modifiers : <NEWLINE> <INDENT> modLayout = self . _draw_modifier_template ( i ) <NEWLINE> if i . show_expanded : <NEWLINE> <INDENT> getattr ( modifier_draw , i . pl_id ) ( i , modLayout , context ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from django . conf import settings <NEWLINE> from django . db import models <NEWLINE> HOOK_EVENTS = getattr ( settings , <STRING> , None ) <NEWLINE> if HOOK_EVENTS is None : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> AUTH_USER_MODEL = getattr ( settings , <STRING> , <STRING> ) <NEWLINE>
def _overwrite_stream ( stream : Union [ BinaryIO , FileIO ] , start : int , end : int , data : bytes ) -> None : <NEWLINE> <INDENT> <STRING> <NEWLINE> old_seek = stream . tell ( ) <NEWLINE> stream . seek ( end ) <NEWLINE> previous_data = stream . read ( ) <NEWLINE> stream . seek ( start ) <NEWLINE> stream . truncate ( ) <NEWLINE> stream . write ( <STRING> . join ( [ data , previous_data ] ) ) <NEWLINE> stream . seek ( old_seek ) <NEWLINE> <DEDENT>
def mnemonics_salles ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return tuple ( s . mnemonic for s in self . salles . values ( ) ) <NEWLINE> <DEDENT>
def query ( self , u , v ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> lu = self . last [ u ] <NEWLINE> lv = self . last [ v ] <NEWLINE> if lu > lv : <NEWLINE> <INDENT> lu , lv = lv , lu <NEWLINE> <DEDENT> return self . rmq . range_min ( lu , lv + 1 ) [ 1 ] <NEWLINE> <DEDENT>
from __future__ import unicode_literals <NEWLINE> import os <NEWLINE> from werkzeug . test import Client <NEWLINE> from clastic import Application , render_basic , Response <NEWLINE> from clastic . middleware . cookie import SignedCookieMiddleware <NEWLINE> from clastic . tests . common import cookie_hello_world <NEWLINE> _CUR_DIR = os . path . dirname ( os . path . abspath ( __file__ ) ) <NEWLINE>
def tub_ts2 ( ) : <NEWLINE> <INDENT> tubts2 = GAL_Cursor . execute ( <STRING> ) . fetchall ( ) <NEWLINE> ts2 = tubts2 <NEWLINE> TUB_Cursor . execute ( <STRING> , ts2 ) <NEWLINE> <DEDENT>
def _event_unsubscribe ( self , packet , _qos , _dup , _retain ) : <NEWLINE> <INDENT> LOG . info ( <STRING> . format ( len ( packet ) , packet ) ) <NEWLINE> messageId = EncodeDecode . _decodeValue ( packet [ : 2 ] ) <NEWLINE> packet = packet [ 2 : ] <NEWLINE> topics = [ ] <NEWLINE> while len ( packet ) : <NEWLINE> <INDENT> topic = EncodeDecode . _decodeString ( packet ) <NEWLINE> packet = packet [ len ( topic ) + 2 : ] <NEWLINE> topics . append ( topic ) <NEWLINE> <DEDENT> LOG . info ( <STRING> . format ( topics ) ) <NEWLINE> self . unsubscribeReceived ( topics , messageId ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from ui . UserInterface import UserInterface <NEWLINE> from controller . HolidayController import HolidayController <NEWLINE> from repository . Repository import Repository <NEWLINE>
from marionette import SkipTest <NEWLINE> import os <NEWLINE> from firefox_puppeteer . api import appinfo <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> from subprocess import call <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> call ( <STRING> ) <NEWLINE> os . environ [ <STRING> ] = <STRING> <NEWLINE> from django . core . management import execute_from_command_line <NEWLINE> execute_from_command_line ( sys . argv ) <NEWLINE> <DEDENT>
class suite_holder : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . __suite = unittest . TestSuite ( ) ; <NEWLINE> <DEDENT> def get_suite ( self ) : <NEWLINE> <INDENT> return self . __suite ; <NEWLINE> <DEDENT> def run ( self ) : <NEWLINE> <INDENT> return unittest . TextTestRunner ( stream = sys . stdout , verbosity = 2 ) . run ( self . __suite ) ; <NEWLINE> <DEDENT> @ staticmethod <NEWLINE> def fill_suite ( test_suite ) : <NEWLINE> <INDENT> pass ; <NEWLINE> <DEDENT> <DEDENT>
import requests <NEWLINE> import urllib <NEWLINE> from pprint import pprint <NEWLINE> import random <NEWLINE> from bs4 import BeautifulSoup <NEWLINE> <STRING> <NEWLINE> COUNTRY = { <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> } <NEWLINE> <DEDENT> PROXY = { <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> } <NEWLINE> <DEDENT>
def next ( self , doc ) : <NEWLINE> <INDENT> ddoc_name , view_name = next ( self . view_sequence ) <NEWLINE> params = self . generate_params ( ** doc ) [ view_name ] <NEWLINE> params = dict ( self . params , ** params ) <NEWLINE> return ddoc_name , view_name , Query ( ** params ) <NEWLINE> <DEDENT>
def handle ( self , * args , ** options ) : <NEWLINE> <INDENT> self . api = self . get_api ( ) <NEWLINE> for profile in Profile . objects . all ( ) : <NEWLINE> <INDENT> self . save_user_timeline ( profile ) <NEWLINE> <DEDENT> <DEDENT>
def update_logging ( self , config ) : <NEWLINE> <INDENT> self . _config = config <NEWLINE> self . disable_file_logging ( ) <NEWLINE> self . _logger . setLevel ( logging . getLevelName ( config . get ( <STRING> , <NEWLINE> <INDENT> <STRING> ) ) ) <NEWLINE> <DEDENT> self . _fmlogger . setLevel ( logging . getLevelName ( config . get ( <STRING> , <NEWLINE> <INDENT> <STRING> ) ) ) <NEWLINE> <DEDENT> self . _iflogger . setLevel ( logging . getLevelName ( config . get ( <STRING> , <NEWLINE> <INDENT> <STRING> ) ) ) <NEWLINE> <DEDENT> if str2bool ( config . get ( <STRING> , <STRING> ) ) : <NEWLINE> <INDENT> self . enable_file_logging ( ) <NEWLINE> <DEDENT> <DEDENT>
def pairs ( hand ) : <NEWLINE> <INDENT> set_hand = set ( hand ) <NEWLINE> number_unique_cards = len ( set_hand ) <NEWLINE> pairs = count_pairs ( hand ) <NEWLINE> if number_unique_cards == 2 : <NEWLINE> <INDENT> if 4 in pairs : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif 3 and 2 in pairs : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> elif number_unique_cards == 3 : <NEWLINE> <INDENT> if 3 in pairs : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> elif number_unique_cards == 4 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT>
import json <NEWLINE> import os <NEWLINE> from operator import itemgetter , attrgetter <NEWLINE> import math <NEWLINE> import time <NEWLINE> a = [ 1 , 2 , 3 , 4 , 5 ] <NEWLINE> for i in range ( 0 , len ( a ) ) : <NEWLINE> <INDENT> a . pop ( ) <NEWLINE> print ( i ) <NEWLINE> <DEDENT>
def dead ( why ) : <NEWLINE> <INDENT> print ( why , <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT>
def is_dev ( ) : <NEWLINE> <INDENT> if os . environ [ <STRING> ] . find ( <STRING> ) != - 1 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT>
def sleep ( self ) : <NEWLINE> <INDENT> time . sleep ( 0.1 ) <NEWLINE> self . stop ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> data = load_svmlight_file ( <STRING> ) <NEWLINE> X_1 = data [ 0 ] . todense ( ) . tolist ( ) <NEWLINE> y_1 = map ( int , data [ 1 ] ) <NEWLINE> lables = [ ] <NEWLINE> for i in range ( 0 , len ( y_1 ) ) : <NEWLINE> <INDENT> lables = lables + [ [ y_1 [ i ] ] ] <NEWLINE> <DEDENT> print ( golub ( X_1 , lables ) ) <NEWLINE> <DEDENT>
def suite ( ) : <NEWLINE> <INDENT> suite = trytond . tests . test_tryton . suite ( ) <NEWLINE> suite . addTests ( unittest . TestLoader ( ) . loadTestsFromTestCase ( <NEWLINE> <INDENT> HealthLabTestCase ) ) <NEWLINE> <DEDENT> return suite <NEWLINE> <DEDENT>
class Command ( BaseCommand ) : <NEWLINE> <INDENT> help = <STRING> <NEWLINE> def handle ( self , * args , ** options ) : <NEWLINE> <INDENT> CachedGeodata . objects . all ( ) . filter ( expires__lte = time . time ( ) ) . delete ( ) <NEWLINE> <DEDENT> <DEDENT>
def setUpClass ( cls ) : <NEWLINE> <INDENT> for i in range ( 1 , TestConcurrency . NUM_SOURCE_FILES ) : <NEWLINE> <INDENT> shutil . copyfile ( <NEWLINE> <INDENT> os . path . join ( ASSETS_DIR , <STRING> , <STRING> ) , <NEWLINE> os . path . join ( ASSETS_DIR , <STRING> , <STRING> . format ( i + 1 ) ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> cls . sources = [ ] <NEWLINE> for i in range ( 1 , TestConcurrency . NUM_SOURCE_FILES + 1 ) : <NEWLINE> <INDENT> cls . sources . append ( os . path . join ( ASSETS_DIR , <STRING> , <STRING> . format ( i ) ) ) <NEWLINE> <DEDENT> <DEDENT>
def plus ( x , y ) : <NEWLINE> <INDENT> x += 4 <NEWLINE> y = 8 <NEWLINE> print ( <STRING> , x ) <NEWLINE> print ( <STRING> , y ) <NEWLINE> return <NEWLINE> <DEDENT>
def __init__ ( self , * args , ** kwargs ) : <NEWLINE> <INDENT> self . client = Http ( ) <NEWLINE> super ( OAuthBaseBackend , self ) . __init__ ( * args , ** kwargs ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import os <NEWLINE> import fcntl <NEWLINE> import time <NEWLINE> import select <NEWLINE> from subprocess import Popen , PIPE <NEWLINE>
from django . core . management . base import CommandError <NEWLINE> from barbados . barbadosdb import models , tests <NEWLINE> from django . conf import settings <NEWLINE> from django . db import transaction <NEWLINE> from django_docopt_command . command import DocOptCommand <NEWLINE>
from __future__ import print_function <NEWLINE> import numpy as np <NEWLINE> import scipy as sp <NEWLINE> from scipy import linalg , optimize , rand <NEWLINE> from . . base import BaseEstimator , RegressorMixin <NEWLINE> from . . metrics . pairwise import manhattan_distances <NEWLINE> from . . utils import check_random_state , check_array , check_X_y <NEWLINE> from . . utils . validation import check_is_fitted <NEWLINE> from . import regression_models as regression <NEWLINE> from . import correlation_models as correlation <NEWLINE> MACHINE_EPSILON = np . finfo ( np . double ) . eps <NEWLINE>
{ <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : [ <STRING> ] , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : [ <STRING> ] , <NEWLINE> <STRING> : { <NEWLINE> <INDENT> <STRING> : [ <STRING> , <STRING> ] , <NEWLINE> <DEDENT> } , <NEWLINE> <STRING> : [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <DEDENT> ] , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : True , <NEWLINE> <DEDENT> } <NEWLINE>
def test_01_03_website ( self ) : <NEWLINE> <INDENT> url = <STRING> <NEWLINE> we_updated = [ False ] <NEWLINE> def fn ( new_version , info , we_updated = we_updated ) : <NEWLINE> <INDENT> we_updated [ 0 ] = True <NEWLINE> <DEDENT> vc = cfu . VersionChecker ( url , 0 , fn , <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> vc . start ( ) <NEWLINE> vc . join ( ) <NEWLINE> self . assertTrue ( we_updated [ 0 ] ) <NEWLINE> <DEDENT>
from . import app <NEWLINE> from tornado . httpserver import HTTPServer <NEWLINE> from tornado . ioloop import IOLoop <NEWLINE> from tornado . wsgi import WSGIContainer <NEWLINE> from tornado . web import Application , RequestHandler , FallbackHandler <NEWLINE>
import time <NEWLINE> import unittest <NEWLINE> import ipv6 <NEWLINE> import node <NEWLINE> import mle <NEWLINE> import config <NEWLINE> import command <NEWLINE> LEADER = 1 <NEWLINE> DUT_ROUTER1 = 2 <NEWLINE> DUT_REED = 17 <NEWLINE>
from functools import wraps <NEWLINE> from flask import abort <NEWLINE> from flask_login import current_user <NEWLINE> from app . model import Permission <NEWLINE>
def resolve_path ( project_name , file_path , extends ) : <NEWLINE> <INDENT> dot_path = get_file_path_by_dot_path ( project_name , extends . lower ( ) ) <NEWLINE> if dot_path : <NEWLINE> <INDENT> return dot_path [ <STRING> ] <NEWLINE> <DEDENT> folder_mapping = get_folder_mapping ( project_name , file_path ) <NEWLINE> if folder_mapping : <NEWLINE> <INDENT> full_extends = folder_mapping + <STRING> + extends <NEWLINE> dot_path = get_file_path_by_dot_path ( project_name , full_extends . lower ( ) ) <NEWLINE> if dot_path : <NEWLINE> <INDENT> return dot_path [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT> return None <NEWLINE> <DEDENT>
class Vector2 : <NEWLINE> <INDENT> def __init__ ( self , x = 0 , y = 0 ) : <NEWLINE> <INDENT> self . x = x <NEWLINE> self . y = y <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> % ( self . x , self . y ) <NEWLINE> <DEDENT> <DEDENT>
from django . conf . urls import patterns , include , url <NEWLINE> import views <NEWLINE> urlpatterns = patterns ( <STRING> , <NEWLINE> <INDENT> url ( <STRING> , views . request_rent , name = <STRING> ) , <NEWLINE> url ( <STRING> , views . process_rent_request , name = <STRING> ) , <NEWLINE> url ( <STRING> , views . deliver_stock , name = <STRING> ) , <NEWLINE> url ( <STRING> , views . make_dummy_data , name = <STRING> ) , <NEWLINE> <DEDENT> ) <NEWLINE>
def __init__ ( self , api_version = <STRING> , host = None ) : <NEWLINE> <INDENT> super ( ApiMethod , self ) . __init__ ( ) <NEWLINE> if not host : <NEWLINE> <INDENT> host = <STRING> % api_version <NEWLINE> <DEDENT> self . host = host <NEWLINE> <DEDENT>
__revision__ = <STRING> <NEWLINE> <STRING> <NEWLINE> import TestSCons_time <NEWLINE> test = TestSCons_time . TestSCons_time ( ) <NEWLINE> test . write_fake_scons_py ( ) <NEWLINE> test . write_sample_project ( <STRING> ) <NEWLINE> test . write ( <STRING> , <STRING> % test . workpath ( <STRING> ) ) <NEWLINE> test . run ( arguments = <STRING> ) <NEWLINE> test . must_exist ( <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> test . must_exist ( <STRING> ) <NEWLINE> test . pass_test ( ) <NEWLINE>
def is_executable ( fpath ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return os . path . isfile ( fpath ) and os . access ( fpath , os . X_OK ) <NEWLINE> <DEDENT>
def test_create_rollout_multiple_revision_with_one_resolved ( self ) : <NEWLINE> <INDENT> expected_logs = <STRING> <NEWLINE> self . assert_execute_outputs ( CreateRollout ( ) , [ <STRING> , <STRING> ] , options = self . _default_options ( ) , expected_logs = expected_logs ) <NEWLINE> <DEDENT>
import sqlalchemy <NEWLINE> from sqlalchemy import create_engine <NEWLINE> from sqlalchemy . orm import sessionmaker <NEWLINE> import config as appConfig <NEWLINE> engine = create_engine ( appConfig . database + <STRING> + appConfig . db_user + <STRING> + appConfig . db_password + <STRING> + appConfig . db_host + <STRING> + appConfig . db_database_name ) <NEWLINE> Session = sessionmaker ( bind = engine ) <NEWLINE> session = Session ( ) <NEWLINE>
def write ( self , data ) : <NEWLINE> <INDENT> max_bytes_to_write = BLOB_SIZE - self . length - 1 <NEWLINE> done = False <NEWLINE> if max_bytes_to_write <= len ( data ) : <NEWLINE> <INDENT> num_bytes_to_write = max_bytes_to_write <NEWLINE> done = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num_bytes_to_write = len ( data ) <NEWLINE> <DEDENT> self . length += num_bytes_to_write <NEWLINE> data_to_write = data [ : num_bytes_to_write ] <NEWLINE> self . buff += data_to_write <NEWLINE> self . _write_buffer ( ) <NEWLINE> return done , num_bytes_to_write <NEWLINE> <DEDENT>
__author__ = <STRING> <NEWLINE> from HTMLParser import HTMLParser <NEWLINE> from Models . Url import Url <NEWLINE> import re <NEWLINE>
def _ascii_chars ( * args , to_chr ) : <NEWLINE> <INDENT> for cp in args : <NEWLINE> <INDENT> if isinstance ( cp , int ) : <NEWLINE> <INDENT> yield to_chr ( cp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> assert ( <NEWLINE> <INDENT> isinstance ( cp , collections . Iterable ) and <NEWLINE> len ( cp ) == 2 ) <NEWLINE> <DEDENT> yield from _ascii_range ( * cp , to_chr = to_chr ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def sign_complete ( request ) : <NEWLINE> <INDENT> user = None <NEWLINE> try : <NEWLINE> <INDENT> user = Account . objects . get ( id = request . session [ <STRING> ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> user = None <NEWLINE> <DEDENT> return render ( request , <STRING> , { <STRING> : user } ) <NEWLINE> <DEDENT>
class Tag ( models . Model ) : <NEWLINE> <INDENT> name = models . CharField ( max_length = 200 ) <NEWLINE> def __str__ ( self ) : <NEWLINE> <INDENT> return self . name <NEWLINE> <DEDENT> <DEDENT>
def test_has_html_view_bin_ext ( self ) : <NEWLINE> <INDENT> blob = M . repository . Blob ( MagicMock ( ) , <STRING> , <STRING> ) <NEWLINE> assert_equal ( blob . has_html_view , False ) <NEWLINE> <DEDENT>
def intercepted_function ( raise_error = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if raise_error is not None : <NEWLINE> <INDENT> raise raise_error <NEWLINE> <DEDENT> <DEDENT>
def hexToRaw ( hx ) : <NEWLINE> <INDENT> raw = binascii . unhexlify ( hx ) ; <NEWLINE> return raw ; <NEWLINE> <DEDENT>
def testUserRegisterEvent ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> app = TestApp ( application ) <NEWLINE> eventid = self . createPageCommitHelper ( app ) <NEWLINE> self . login ( LOGGED_IN_USER ) <NEWLINE> response = app . get ( <STRING> ) <NEWLINE> self . assertEqual ( <STRING> , response . status ) <NEWLINE> self . assertFalse ( TITLE in response ) <NEWLINE> self . userEventEntry ( app , eventid ) <NEWLINE> response = app . get ( <STRING> ) <NEWLINE> self . assertEqual ( <STRING> , response . status ) <NEWLINE> self . assertTrue ( TITLE in response ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import sys <NEWLINE> import logging <NEWLINE> import os <NEWLINE> import subprocess <NEWLINE> import urllib <NEWLINE> import click <NEWLINE> from treadmill import context <NEWLINE> from treadmill import cli <NEWLINE> from treadmill import restclient <NEWLINE> from treadmill . websocket import client as ws_client <NEWLINE> _LOGGER = logging . getLogger ( __name__ ) <NEWLINE> if sys . platform == <STRING> : <NEWLINE> <INDENT> _DEFAULT_SSH = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> _DEFAULT_SSH = <STRING> <NEWLINE> <DEDENT>
def fspath2url ( path ) : <NEWLINE> <INDENT> path = os . path . abspath ( path ) <NEWLINE> return <STRING> + urllib . pathname2url ( path ) <NEWLINE> <DEDENT>
def loadPlugins ( config = { } ) : <NEWLINE> <INDENT> import Lib . Applications <NEWLINE> import Lib . Tasks <NEWLINE> import Lib . Requirements <NEWLINE> <DEDENT>
<STRING> <NEWLINE> __author__ = <STRING> <NEWLINE> __copyright__ = <STRING> <NEWLINE> __license__ = <STRING> <NEWLINE> __version__ = <STRING> <NEWLINE> __maintainer__ = <STRING> <NEWLINE> __email__ = <STRING> <NEWLINE> __status__ = <STRING> <NEWLINE> import pyetree <NEWLINE> import pyetree_album <NEWLINE> import pyetree_artist <NEWLINE> import pyetree_collection <NEWLINE> import pyetree_cover <NEWLINE> import pyetree_genre <NEWLINE> import pyetree_user <NEWLINE>
class TestIserAdmDriver ( test_tgt . TestTgtAdmDriver ) : <NEWLINE> <INDENT> def setUp ( self ) : <NEWLINE> <INDENT> super ( TestIserAdmDriver , self ) . setUp ( ) <NEWLINE> self . configuration . iser_ip_address = <STRING> <NEWLINE> self . configuration . iser_target_prefix = <STRING> <NEWLINE> self . target = iser . ISERTgtAdm ( root_helper = utils . get_root_helper ( ) , <NEWLINE> <INDENT> configuration = self . configuration ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_results ( filename = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return manifest . get_manifest ( filename ) <NEWLINE> <DEDENT>
def referencable_models ( self ) : <NEWLINE> <INDENT> return res_request . referencable_models ( <NEWLINE> <INDENT> self , self . env . cr , self . env . uid , context = self . env . context ) <NEWLINE> <DEDENT> <DEDENT>
class MyClient ( pyuaf . client . Client ) : <NEWLINE> <INDENT> def __init__ ( self , settings ) : <NEWLINE> <INDENT> pyuaf . client . Client . __init__ ( self , settings ) <NEWLINE> self . noOfSuccessFullyReceivedNotifications = 0 <NEWLINE> self . lock = threading . Lock ( ) <NEWLINE> <DEDENT> def dataChangesReceived ( self , notifications ) : <NEWLINE> <INDENT> self . lock . acquire ( ) <NEWLINE> self . noOfSuccessFullyReceivedNotifications += len ( notifications ) <NEWLINE> self . lock . release ( ) <NEWLINE> <DEDENT> <DEDENT>
import os <NEWLINE> import subprocess <NEWLINE> import sys <NEWLINE> import time <NEWLINE> from lib import com_gps <NEWLINE> if not os . getuid ( ) == 0 : <NEWLINE> <INDENT> sys . exit ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> utc = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> gps = com_gps . GPS ( ) <NEWLINE> utc = gps . gettime ( ) <NEWLINE> if utc != <STRING> : <NEWLINE> <INDENT> print ( <STRING> + str ( utc ) ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> time . sleep ( 0.1 ) <NEWLINE> <DEDENT> <DEDENT> subprocess . call ( <STRING> + str ( utc ) + <STRING> , shell = True ) <NEWLINE>
from toscaparser . common . exception import ExceptionCollector <NEWLINE> from toscaparser . common . exception import MissingRequiredFieldError <NEWLINE> from toscaparser . common . exception import UnknownFieldError <NEWLINE> from toscaparser . common . exception import URLException <NEWLINE> from toscaparser . utils . gettextutils import _ <NEWLINE> import toscaparser . utils . urlutils <NEWLINE> SECTIONS = ( DESCRIPTION , URL , CREDENTIAL ) = ( <STRING> , <STRING> , <STRING> ) <NEWLINE>
<STRING> <NEWLINE> import psyco_full <NEWLINE> from bx . cookbook import doc_optparse <NEWLINE> from bx import interval_index_file <NEWLINE> import bx . wiggle <NEWLINE> import sys <NEWLINE> import os . path <NEWLINE> from bx . misc . seekbzip2 import SeekableBzip2File <NEWLINE>
import os . path <NEWLINE> import threading <NEWLINE> import time <NEWLINE> import traceback <NEWLINE> from mesos . interface . mesos_pb2 import TaskState <NEWLINE> from twitter . common import log <NEWLINE> from twitter . common . exceptions import ExceptionalThread <NEWLINE> from twitter . common . metrics import LambdaGauge <NEWLINE> from apache . aurora . common . http_signaler import HttpSignaler <NEWLINE> from . status_checker import StatusChecker , StatusCheckerProvider , StatusResult <NEWLINE> from . task_info import mesos_task_instance_from_assigned_task , resolve_ports <NEWLINE>
def option_processor ( a_list ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> processed_dictionary = collections . OrderedDict ( ) <NEWLINE> for a_pair in a_list : <NEWLINE> <INDENT> option_title = get_option_title ( a_pair [ 1 ] ) <NEWLINE> if option_title [ : 5 ] == <STRING> : <NEWLINE> <INDENT> option_title = option_title [ 6 : ] <NEWLINE> <DEDENT> help_message = a_pair [ 0 ] . lstrip ( <STRING> ) <NEWLINE> option_flag = <STRING> % get_clean_bool_option ( a_pair [ 1 ] ) <NEWLINE> processed_dictionary [ option_title ] = [ option_flag , help_message ] <NEWLINE> <DEDENT> return processed_dictionary <NEWLINE> <DEDENT>
def linuxicerik ( request , altbaslik ) : <NEWLINE> <INDENT> icerikler = icerik . objects . get ( altbaslik = altbaslik ) <NEWLINE> return render_to_response ( <STRING> , locals ( ) , content_type = RequestContext ( request ) ) <NEWLINE> <DEDENT>
import itertools as itools <NEWLINE> import unittest <NEWLINE> from . import data <NEWLINE> from . . import engine <NEWLINE> from . . import events <NEWLINE> from . . import sequences <NEWLINE> from . . import streams <NEWLINE>
def pop ( self ) : <NEWLINE> <INDENT> maxi = 0 <NEWLINE> for i in range ( 1 , len ( self . items ) ) : <NEWLINE> <INDENT> if self . items [ i ] < self . items [ maxi ] : <NEWLINE> <INDENT> maxi = i <NEWLINE> <DEDENT> <DEDENT> item = self . items [ maxi ] <NEWLINE> self . items [ maxi : maxi + 1 ] = [ ] <NEWLINE> return item <NEWLINE> <DEDENT>
class UuidField ( Field ) : <NEWLINE> <INDENT> def display ( self , header ) : <NEWLINE> <INDENT> value = self . _get_value ( header ) <NEWLINE> if self . mnemonic : <NEWLINE> <INDENT> return <STRING> % tuple ( [ ord ( x ) for x in value ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> . join ( [ hex ( ord ( x ) ) for x in value ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from __future__ import print_function <NEWLINE> import timeit <NEWLINE> import platform <NEWLINE> import sys <NEWLINE> import collections <NEWLINE> import numpy <NEWLINE>
class Output ( object ) : <NEWLINE> <INDENT> def __init__ ( self , braille = True , speech = True ) : <NEWLINE> <INDENT> self . braille = braille <NEWLINE> self . speech = speech <NEWLINE> self . braille_output = b . brailler . Brailler ( ) <NEWLINE> self . speech_output = s . speaker . Speaker ( ) <NEWLINE> <DEDENT> def output ( self , text ) : <NEWLINE> <INDENT> if self . braille : <NEWLINE> <INDENT> self . braille_output . braille ( text ) <NEWLINE> <DEDENT> if self . speech : <NEWLINE> <INDENT> self . speech_output . say ( text , interrupt = True ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import dbus <NEWLINE> from twisted . words . xish import xpath , domish <NEWLINE> from servicetest import EventPattern <NEWLINE> from gabbletest import exec_test , sync_stream <NEWLINE> from caps_helper import caps_contain , receive_presence_and_ask_caps , FIXED_CAPS , JINGLE_CAPS , VARIABLE_CAPS , check_caps , disco_caps <NEWLINE> import constants as cs <NEWLINE> import ns <NEWLINE>
def contacts ( self , exclude_inactive = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> contacts = self . _send_request ( <NEWLINE> <INDENT> ContactHelper . URL_CONTACTS_LIST , <NEWLINE> <STRING> , <NEWLINE> <DEDENT> ) [ <STRING> ] <NEWLINE> return contacts if not exclude_inactive else Helper . _filter_inactive ( contacts ) <NEWLINE> <DEDENT>
from django . conf . urls import url <NEWLINE> from spark . courses import views <NEWLINE> urlpatterns = [ <NEWLINE> <INDENT> url ( <STRING> , views . classes , name = <STRING> ) , <NEWLINE> url ( <STRING> , views . classe_detail , name = <STRING> ) , <NEWLINE> url ( <STRING> , views . subscribe , name = <STRING> ) , <NEWLINE> url ( <STRING> , views . lecture , name = <STRING> ) , <NEWLINE> url ( <STRING> , views . lecture_detail , name = <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE>
from gaia2 import cvar <NEWLINE> from gaia2 . classification import ClassificationTaskManager <NEWLINE> import os , os . path <NEWLINE> import sys <NEWLINE> import logging <NEWLINE> from optparse import OptionParser <NEWLINE> debugLevel = logging . INFO <NEWLINE>
from random import choice <NEWLINE> from scrapy import signals <NEWLINE> from scrapy . exceptions import NotConfigured <NEWLINE>
def _resolve_model ( future_model , ** kwargs ) : <NEWLINE> <INDENT> future_model . poll ( ) <NEWLINE> return h2o . get_model ( future_model . job . dest_key ) <NEWLINE> <DEDENT>
def registerRtis ( ) : <NEWLINE> <INDENT> registry = RtiRegistry ( ) <NEWLINE> if <STRING> in sys . argv : <NEWLINE> <INDENT> registry . deleteSettings ( ) <NEWLINE> <DEDENT> registry . loadOrInitSettings ( ) <NEWLINE> registry . registerRti ( <STRING> , <STRING> , extensions = [ <STRING> ] , <NEWLINE> <INDENT> pythonPath = SCRIPT_DIR ) <NEWLINE> <DEDENT> registry . registerRti ( <STRING> , <STRING> , extensions = [ <STRING> ] ) <NEWLINE> registry . saveSettings ( ) <NEWLINE> <DEDENT>
class Follow ( db . Model ) : <NEWLINE> <INDENT> __tablename__ = <STRING> <NEWLINE> follower_id = db . Column ( db . Integer , db . ForeignKey ( <STRING> ) , <NEWLINE> <INDENT> primary_key = True ) <NEWLINE> <DEDENT> followed_id = db . Column ( db . Integer , db . ForeignKey ( <STRING> ) , <NEWLINE> <INDENT> primary_key = True ) <NEWLINE> <DEDENT> timestamp = db . Column ( db . DateTime , default = datetime . now ) <NEWLINE> <DEDENT>
def chassis_reset ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . _chassis_reset <NEWLINE> <DEDENT>
class MeridionalPatch ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> assert False <NEWLINE> <DEDENT> def __call__ ( self , m , s ) : <NEWLINE> <INDENT> assert False <NEWLINE> <DEDENT> <DEDENT>
from django . core . paginator import Paginator , PageNotAnInteger , EmptyPage <NEWLINE> from django . http import Http404 <NEWLINE> from django . shortcuts import render <NEWLINE> from django . conf import settings <NEWLINE> from blogs . models import Blog , Category <NEWLINE>
class ICategoryMetadataFossil ( IFossil ) : <NEWLINE> <INDENT> def getId ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def getName ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def getLocator ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> getLocator . convert = Conversion . url ( urlHandlers . UHCategoryDisplay ) <NEWLINE> getLocator . name = <STRING> <NEWLINE> <DEDENT>
def render ( self ) : <NEWLINE> <INDENT> self . render_start ( ) <NEWLINE> self . render_contents ( ) <NEWLINE> self . render_stop ( ) <NEWLINE> <DEDENT>
def test_compress ( ) : <NEWLINE> <INDENT> data = <STRING> <NEWLINE> assert compress . decompress ( compress . compress ( data ) ) == data <NEWLINE> <DEDENT>
def get_device_number ( mountpoint ) : <NEWLINE> <INDENT> device_number = mountpoint_to_number ( mountpoint ) <NEWLINE> if device_number < 0 : <NEWLINE> <INDENT> raise StorageError ( _ ( <STRING> ) % <NEWLINE> <INDENT> mountpoint ) <NEWLINE> <DEDENT> <DEDENT> return device_number <NEWLINE> <DEDENT>
class Vorlage ( models . Model ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> token = models . SlugField ( <NEWLINE> <INDENT> unique = True , <NEWLINE> null = False , <NEWLINE> blank = False , <NEWLINE> help_text = <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> text = models . TextField ( <NEWLINE> <INDENT> null = False , <NEWLINE> blank = True , <NEWLINE> default = <STRING> , <NEWLINE> help_text = <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> class Meta : <NEWLINE> <INDENT> verbose_name = <STRING> <NEWLINE> verbose_name_plural = <STRING> <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return self . token <NEWLINE> <DEDENT> <DEDENT>
def owls_python_version_check ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> python_version = version_info [ 0 : 2 ] <NEWLINE> supported_python_versions = ( <NEWLINE> <INDENT> ( 2 , 7 ) , <NEWLINE> ( 3 , 3 ) , <NEWLINE> ( 3 , 4 ) , <NEWLINE> <DEDENT> ) <NEWLINE> if python_version not in supported_python_versions : <NEWLINE> <INDENT> exit ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from __future__ import print_function <NEWLINE> import argparse <NEWLINE> VERBOSE = False <NEWLINE>
def can_configure ( self , cluster ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> pass <NEWLINE> <DEDENT>
def _make_path ( path ) : <NEWLINE> <INDENT> if path is None : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> return path <NEWLINE> <DEDENT>
from vumi . transports . vumi_bridge . vumi_bridge import GoConversationTransport <NEWLINE> __all__ = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <DEDENT> ] <NEWLINE>
class GalleryItemInline ( admin . StackedInline ) : <NEWLINE> <INDENT> model = GalleryItem <NEWLINE> extra = 0 <NEWLINE> sortable_field_name = <STRING> <NEWLINE> <DEDENT>
def container_style ( request ) : <NEWLINE> <INDENT> classname = <STRING> <NEWLINE> if getattr ( settings , <STRING> , False ) : <NEWLINE> <INDENT> classname += <STRING> <NEWLINE> <DEDENT> return { <STRING> : classname } <NEWLINE> <DEDENT>
import os <NEWLINE> import netifaces <NEWLINE> import re <NEWLINE> import logging <NEWLINE> from mss . agent . managers . translation import TranslationManager <NEWLINE> _ = TranslationManager ( ) . translate <NEWLINE>
class Boolean ( Base ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def matches ( self ) : <NEWLINE> <INDENT> return self . actual is True <NEWLINE> <DEDENT> @ property <NEWLINE> def explanation ( self ) : <NEWLINE> <INDENT> return Explanation ( self . actual , self . is_negative , <STRING> , negative_action = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class HttpGetError ( urllib2 . HTTPError ) : <NEWLINE> <INDENT> def __init__ ( self , url , code , msg , hdrs , fp ) : <NEWLINE> <INDENT> self . url = url <NEWLINE> self . code = code <NEWLINE> self . msg = msg <NEWLINE> self . hdrs = hdrs <NEWLINE> self . fp = fp <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> % ( self . url , self . msg , self . code ) <NEWLINE> <DEDENT> <DEDENT>
class FeedbackService ( object ) : <NEWLINE> <INDENT> FEEDBACK_URL = os . environ . get ( <STRING> ) <NEWLINE> def __init__ ( self , leap_session ) : <NEWLINE> <INDENT> self . leap_session = leap_session <NEWLINE> <DEDENT> def open_ticket ( self , feedback ) : <NEWLINE> <INDENT> account_mail = self . leap_session . account_email ( ) <NEWLINE> data = { <NEWLINE> <INDENT> <STRING> : feedback , <NEWLINE> <STRING> : <STRING> . format ( account_mail ) , <NEWLINE> <STRING> : account_mail , <NEWLINE> <STRING> : account_mail <NEWLINE> <DEDENT> } <NEWLINE> return requests . post ( self . FEEDBACK_URL , data = data , verify = False ) <NEWLINE> <DEDENT> <DEDENT>
from __future__ import print_function <NEWLINE> import random <NEWLINE> from time import time <NEWLINE> from uuid import uuid4 <NEWLINE> from zerograph import Graph , Batch <NEWLINE> graph = None <NEWLINE>
class WebSocketTimeoutException ( WebSocketException ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> pass <NEWLINE> <DEDENT>
import main <NEWLINE> main . main ( ) <NEWLINE> import os <NEWLINE> os . _exit ( 0 ) <NEWLINE>
from ggrc import db <NEWLINE> from ggrc . models import CustomAttributeDefinition <NEWLINE> from ggrc . utils import underscore_from_camelcase <NEWLINE>
class Migration ( migrations . Migration ) : <NEWLINE> <INDENT> dependencies = [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE> operations = [ <NEWLINE> <INDENT> migrations . AddField ( <NEWLINE> <INDENT> model_name = <STRING> , <NEWLINE> name = <STRING> , <NEWLINE> field = models . CharField ( default = 0 , max_length = 1 ) , <NEWLINE> preserve_default = False , <NEWLINE> <DEDENT> ) , <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT>
def saveIrrigationData ( self , p_json ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> l_json = json_tools . decode_json_unicode ( p_json ) <NEWLINE> l_ix = int ( l_json [ <STRING> ] ) <NEWLINE> _l_system = l_json [ <STRING> ] <NEWLINE> try : <NEWLINE> <INDENT> l_obj = self . m_pyhouse_obj . House . Irrigation [ l_ix ] <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> l_obj = IrrigationData ( ) <NEWLINE> l_obj . DynDns = { } <NEWLINE> <DEDENT> l_obj . Name = l_json [ <STRING> ] <NEWLINE> l_obj . Key = 0 <NEWLINE> l_obj . Active = True <NEWLINE> self . m_pyhouse_obj . House . Irrigation [ l_ix ] = l_obj <NEWLINE> <DEDENT>
def open ( self , path , * args , ** kwargs ) : <NEWLINE> <INDENT> f = functools . partial ( path . open , * args , ** kwargs ) <NEWLINE> return ( yield from self . loop . run_in_executor ( None , f ) ) <NEWLINE> <DEDENT>
def update_parser_varname ( new_varname , code ) : <NEWLINE> <INDENT> lines = filter ( lambda x : x != <STRING> , code ) <NEWLINE> argparse_code = dropwhile ( lambda line : <STRING> in line , lines ) <NEWLINE> old_argparser_varname , _ = split_line ( argparse_code . next ( ) ) <NEWLINE> updated_code = [ line . replace ( old_argparser_varname , new_varname ) <NEWLINE> <INDENT> for line in lines ] <NEWLINE> <DEDENT> return updated_code <NEWLINE> <DEDENT>
def setup_platform ( hass , config , add_devices , discovery_info = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> value_template = config . get ( CONF_VALUE_TEMPLATE ) <NEWLINE> if value_template is not None : <NEWLINE> <INDENT> value_template . hass = hass <NEWLINE> <DEDENT> add_devices ( [ MqttBinarySensor ( <NEWLINE> <INDENT> hass , <NEWLINE> config . get ( CONF_NAME ) , <NEWLINE> config . get ( CONF_STATE_TOPIC ) , <NEWLINE> config . get ( CONF_SENSOR_CLASS ) , <NEWLINE> config . get ( CONF_QOS ) , <NEWLINE> config . get ( CONF_PAYLOAD_ON ) , <NEWLINE> config . get ( CONF_PAYLOAD_OFF ) , <NEWLINE> value_template <NEWLINE> <DEDENT> ) ] ) <NEWLINE> <DEDENT>
from typing import Dict , List , Any , Optional , Callable , Union <NEWLINE> from Modules . Utils . DAL . Common . Dtos import metadataSrv <NEWLINE> from Modules . Utils . DAL . Common . Entities . dataContext import DataContext <NEWLINE> from Modules . Utils . DAL . Common import utils as dalUtils <NEWLINE> from Modules . Utils . DAL . Common . Entities . DataViews . dataViewLocalDto import DataViewLocalDto <NEWLINE>
import codecs <NEWLINE> import sys <NEWLINE> import re <NEWLINE> import conllutil3 as cu <NEWLINE> code = sys . argv [ 1 ] <NEWLINE> comment = <STRING> + code <NEWLINE> print ( comment , file = sys . stderr ) <NEWLINE> counter = 1 <NEWLINE> for comm , sent in cu . read_conllu ( sys . stdin ) : <NEWLINE> <INDENT> if comment in comm : <NEWLINE> <INDENT> cu . plain_print ( sys . stdout , comm , sent ) <NEWLINE> counter += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , counter , sep = <STRING> , file = sys . stderr ) <NEWLINE>
def draw ( self , surface ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> super ( MessageScreen , self ) . draw ( surface ) <NEWLINE> item_size = None <NEWLINE> container_size = None <NEWLINE> n = container_size [ self . orientation ] / item_size [ self . orientation ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> item_surface = get_item_surface ( item_size ) <NEWLINE> self . renderer ( None , item_surface ) <NEWLINE> <DEDENT> <DEDENT>
import angr <NEWLINE> p = angr . Project ( <STRING> ) ; <NEWLINE> init_state = p . factory . entry_state ( args = [ <STRING> , angr . StringSpec ( sym_length = 3 , nonnull = True ) ] , add_options = { <STRING> } ) <NEWLINE> pg = p . factory . path_group ( init_state , immutable = False ) <NEWLINE> pg . explore ( ) <NEWLINE> print ( pg ) <NEWLINE>
class Live ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> pool = None <NEWLINE> def getURL ( self , url , headers ) : <NEWLINE> <INDENT> if Live . pool is None : <NEWLINE> <INDENT> Live . pool = get_con_pool ( <NEWLINE> <INDENT> settings . RESTCLIENTS_HFS_HOST , <NEWLINE> settings . RESTCLIENTS_HFS_KEY_FILE , <NEWLINE> settings . RESTCLIENTS_HFS_CERT_FILE , <NEWLINE> max_pool_size = HFS_MAX_POOL_SIZE , <NEWLINE> socket_timeout = HFS_SOCKET_TIMEOUT ) <NEWLINE> <DEDENT> <DEDENT> return get_live_url ( Live . pool , <NEWLINE> <INDENT> <STRING> , <NEWLINE> settings . RESTCLIENTS_HFS_HOST , <NEWLINE> url , <NEWLINE> headers = headers , <NEWLINE> service_name = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def testStandardParameters ( self ) : <NEWLINE> <INDENT> s = IECoreGL . Shader . constant ( ) <NEWLINE> self . assertEqual ( s . csParameter ( ) , s . uniformParameter ( <STRING> ) ) <NEWLINE> <DEDENT>
def eval_clear_score ( self , clearflag ) : <NEWLINE> <INDENT> if len ( self . line_list ) > 1 or self . line_list [ 0 ] > 0 : <NEWLINE> <INDENT> self . lines_cleared += sum ( self . line_list ) <NEWLINE> self . last_score = self . predict_score ( clearflag ) <NEWLINE> self . score += self . last_score <NEWLINE> self . combo_ctr += 1 <NEWLINE> self . current_combo = self . combo_factor ** self . combo_ctr <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . combo_ctr = 0 <NEWLINE> self . current_combo = 1.0 <NEWLINE> <DEDENT> <DEDENT>
def _handle_label ( self ) : <NEWLINE> <INDENT> x = self . _src [ self . _index ] <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> label = self . _read_quoted_label ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> label = self . _read_unquoted_label ( ) <NEWLINE> <DEDENT> if self . prev_token not in [ NewickTokenType . OPEN , NewickTokenType . CLOSE , NewickTokenType . COMMA ] : <NEWLINE> <INDENT> m = <STRING> . format ( label ) <NEWLINE> self . _raise_unexpected ( m ) <NEWLINE> <DEDENT> self . prev_token = NewickTokenType . LABEL <NEWLINE> return label <NEWLINE> <DEDENT>
<STRING> <NEWLINE> <STRING> <NEWLINE> from pycmbs . diagnostic import PatternCorrelation <NEWLINE> from pycmbs . data import Data <NEWLINE> import numpy as np <NEWLINE> import matplotlib . pyplot as plt <NEWLINE> plt . close ( <STRING> ) <NEWLINE> fname = <STRING> <NEWLINE> x = Data ( fname , <STRING> , read = True ) <NEWLINE> xc = x . get_climatology ( return_object = True ) <NEWLINE> yc = xc . copy ( ) <NEWLINE> yc . data = yc . data * np . random . random ( yc . shape ) * 10. <NEWLINE> PC = PatternCorrelation ( xc , yc ) <NEWLINE> PC . plot ( ) <NEWLINE> plt . show ( ) <NEWLINE>
class GroupQuerySet ( models . query . QuerySet ) : <NEWLINE> <INDENT> def member ( self , user , service = None , depth = None ) : <NEWLINE> <INDENT> if depth is None : <NEWLINE> <INDENT> depth = settings . GROUP_RECURSION_DEPTH <NEWLINE> <DEDENT> expr = Q ( users = user , service = service ) <NEWLINE> kwarg = <STRING> <NEWLINE> for i in range ( depth ) : <NEWLINE> <INDENT> kwarg = <STRING> % kwarg <NEWLINE> expr |= models . Q ( ** { kwarg : user , <STRING> : service } ) <NEWLINE> <DEDENT> return self . filter ( expr ) . distinct ( ) <NEWLINE> <DEDENT> <DEDENT>
def validate ( tax_number ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> verify_vat ( tax_number ) <NEWLINE> return <STRING> <NEWLINE> <DEDENT> except VatCannotIdentifyValidationError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from dswimg import * <NEWLINE> from dswimgproc import * <NEWLINE> r = np . random . random ( ( 50 , 80 ) ) <NEWLINE> ppnoise ( r ) <NEWLINE> ppnoise ( r * 100 ) <NEWLINE> h = ( r [ : , 1 : ] + r [ : , : - 1 ] ) / 2 <NEWLINE> ppnoise ( h ) <NEWLINE> v = ( r [ : , 1 : ] + r [ : , : - 1 ] ) / 2 <NEWLINE> ppnoise ( v ) <NEWLINE>
def test_output_urls ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . BundleClass . urls_to_fake = [ <STRING> , <STRING> ] <NEWLINE> assert self . render_template ( <STRING> ) == <STRING> <NEWLINE> <DEDENT>
def relerr ( expected , actual ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return abs ( ( actual - expected ) / expected ) <NEWLINE> <DEDENT>
import cProfile <NEWLINE> import pstats <NEWLINE> import os . path <NEWLINE> from palm . linalg import ScipyMatrixExponential , ScipyMatrixExponential2 , QitMatrixExponential , StubExponential <NEWLINE> from palm . blink_factory import SingleDarkBlinkFactory <NEWLINE> from palm . blink_parameter_set import SingleDarkParameterSet <NEWLINE> from palm . likelihood_judge import LikelihoodJudge <NEWLINE> from palm . backward_likelihood import BackwardPredictor <NEWLINE> from palm . blink_target_data import BlinkTargetData <NEWLINE> from palm . scipy_optimizer import ScipyOptimizer <NEWLINE> from palm . score_function import ScoreFunction <NEWLINE>
def strip_tags ( html ) : <NEWLINE> <INDENT> stripper = MLStripper ( ) <NEWLINE> stripper . feed ( html ) <NEWLINE> return stripper . get_data ( ) <NEWLINE> <DEDENT>
def model_to_dict ( instance , exclude , include_not_editable ) : <NEWLINE> <INDENT> data = { } <NEWLINE> for f in instance_fields ( instance ) : <NEWLINE> <INDENT> if f . name in exclude : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if not getattr ( f , <STRING> , False ) and not include_not_editable : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> data [ f . name ] = f . value_from_object ( instance ) <NEWLINE> <DEDENT> return data <NEWLINE> <DEDENT>
import sys <NEWLINE> import re <NEWLINE> import os <NEWLINE> import zipfile <NEWLINE> import zlib <NEWLINE> import urllib <NEWLINE> import shutil <NEWLINE> import mechanize <NEWLINE> import json <NEWLINE> import argparse <NEWLINE>
from flask_truss . factory import create_celery_app <NEWLINE> celery_instance = create_celery_app ( ) <NEWLINE>
def _make_json_serializable ( x ) : <NEWLINE> <INDENT> if isinstance ( x , np . ndarray ) : <NEWLINE> <INDENT> return x . tolist ( ) <NEWLINE> <DEDENT> elif isinstance ( x , dict ) : <NEWLINE> <INDENT> return { key : _make_json_serializable ( value ) <NEWLINE> <INDENT> for key , value in x . items ( ) } <NEWLINE> <DEDENT> <DEDENT> elif isinstance ( x , list ) : <NEWLINE> <INDENT> return [ _make_json_serializable ( value ) for value in x ] <NEWLINE> <DEDENT> return x <NEWLINE> <DEDENT>
def render_factcheck ( ) : <NEWLINE> <INDENT> parsed_factcheck = parse_factcheck ( ) <NEWLINE> generate_views ( [ <STRING> , <STRING> , <STRING> ] , <NEWLINE> <INDENT> parsed_factcheck ) <NEWLINE> <DEDENT> <DEDENT>
def get_mobility ( e_field , temperature , is_electron ) : <NEWLINE> <INDENT> if is_electron : <NEWLINE> <INDENT> v_m = 1.53e9 * temperature ** ( - 0.87 ) <NEWLINE> E_c = 1.01 * temperature ** 1.55 <NEWLINE> beta = 2.57e-2 * temperature ** 0.66 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v_m = 1.62e8 * temperature ** ( - 0.52 ) <NEWLINE> E_c = 1.24 * temperature ** 1.68 <NEWLINE> beta = 0.46 * temperature ** 0.17 <NEWLINE> <DEDENT> mu = v_m / E_c / ( 1. + ( np . abs ( e_field ) / E_c ) ** beta ) ** ( 1. / beta ) <NEWLINE> return mu <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from . Image import * <NEWLINE> from . NumericalGradient import * <NEWLINE> from . MNIST import * <NEWLINE> __all__ = [ <STRING> , <STRING> , <STRING> ] <NEWLINE>
def get_request_redis_id ( acquisition_req ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return <STRING> . format ( acquisition_req . orgUUID , acquisition_req . id ) <NEWLINE> <DEDENT>
from collective . elephantvocabulary . vocabulary import VocabularyFactory <NEWLINE> from collective . elephantvocabulary . hidden import WrapperHidden <NEWLINE> from collective . elephantvocabulary . visible import WrapperVisible <NEWLINE> from collective . elephantvocabulary . base import WrapperBase <NEWLINE> def wrap_vocabulary ( vocab , <NEWLINE> <INDENT> visible_terms = None , <NEWLINE> visible_terms_from_registry = None , <NEWLINE> hidden_terms = None , <NEWLINE> hidden_terms_from_registry = None , <NEWLINE> wrapper_class = WrapperBase ) : <NEWLINE> return VocabularyFactory ( <NEWLINE> vocab , <NEWLINE> visible_terms = visible_terms , <NEWLINE> visible_terms_from_registry = visible_terms_from_registry , <NEWLINE> hidden_terms = hidden_terms , <NEWLINE> hidden_terms_from_registry = hidden_terms_from_registry , <NEWLINE> wrapper_class = WrapperBase , <NEWLINE> ) <NEWLINE> <DEDENT> __all__ = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE>
def create_reduction_tree ( oresult , parent ) : <NEWLINE> <INDENT> ptask = DataProcessingTask ( ) <NEWLINE> ptask . host = <STRING> <NEWLINE> ptask . state = 0 <NEWLINE> ptask . parent = parent <NEWLINE> ptask . creation_time = datetime . utcnow ( ) <NEWLINE> ptask . method = <STRING> % oresult . label <NEWLINE> for child in oresult . children : <NEWLINE> <INDENT> create_reduction_tree ( child , ptask ) <NEWLINE> <DEDENT> return ptask <NEWLINE> <DEDENT>
def to_latex ( self , filepath = None ) : <NEWLINE> <INDENT> t0 = time . time ( ) <NEWLINE> self . logfile . write_log ( message1b ) <NEWLINE> doc = describe2latex ( self . study_info , self . stats ) <NEWLINE> if filepath is None : <NEWLINE> <INDENT> return doc <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> with open ( filepath , <STRING> ) as myfile : <NEWLINE> <INDENT> myfile . write ( doc ) <NEWLINE> <DEDENT> myfile . close ( ) <NEWLINE> <DEDENT> self . logfile . write_log ( message2 % ( time . time ( ) - t0 ) ) <NEWLINE> self . logfile . write_log ( message_close ) <NEWLINE> <DEDENT>
def t1_new_full ( in_val ) : <NEWLINE> <INDENT> foo = T1 ( ) <NEWLINE> foo . num = in_val <NEWLINE> return pointer ( foo ) <NEWLINE> <DEDENT>
import os <NEWLINE> import sys <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> filename = os . path . join ( os . path . dirname ( sys . executable ) , <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> import subprocess <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> if os . system ( filename ) != 0 : <NEWLINE> <INDENT> raise RuntimeError ( <STRING> % filename ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> subprocess . check_call ( [ filename ] ) <NEWLINE> <DEDENT> <DEDENT>
class index : <NEWLINE> <INDENT> def GET ( self ) : <NEWLINE> <INDENT> form = myform ( ) <NEWLINE> return <STRING> + form . render ( ) + <STRING> <NEWLINE> <DEDENT> def POST ( self ) : <NEWLINE> <INDENT> form = myform ( ) <NEWLINE> if not form . validates ( ) : <NEWLINE> <INDENT> return <STRING> + form . render ( ) + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> + form [ <STRING> ] . value + <STRING> ; <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def getLastSecond ( countBySecond ) : <NEWLINE> <INDENT> lastSecond = 0 <NEWLINE> for second in countBySecond . keys ( ) : <NEWLINE> <INDENT> if second > lastSecond : <NEWLINE> <INDENT> lastSecond = second <NEWLINE> <DEDENT> <DEDENT> return lastSecond <NEWLINE> <DEDENT>
def from_CSV ( files , usecols = None ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return mm . util . load . from_CSV ( files , usecols = usecols ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> return mm . util . load . from_ASCII ( files , usecols = usecols ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from argparse import ArgumentParser <NEWLINE> from collections import Counter <NEWLINE> import matplotlib . pyplot as plt <NEWLINE> from lib . graph import HypRG <NEWLINE>
class MiembroViewSet ( viewsets . ModelViewSet ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> queryset = Miembro . objects . all ( ) . order_by ( <STRING> ) <NEWLINE> serializer_class = MiembroSerializer <NEWLINE> <DEDENT>
def DigitFibonacci ( ) : <NEWLINE> <INDENT> fib1 = 0 <NEWLINE> fib2 = 1 <NEWLINE> temp = 0 <NEWLINE> found = False <NEWLINE> fibCounter = 1 <NEWLINE> while ( found == False ) : <NEWLINE> <INDENT> fibStr = str ( fib2 ) <NEWLINE> fibCheck = len ( fibStr ) <NEWLINE> if ( fibCheck >= 1000 ) : <NEWLINE> <INDENT> found = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = fib2 <NEWLINE> fib2 = fib2 + fib1 <NEWLINE> fib1 = temp <NEWLINE> fibCounter += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> % fib2 ) <NEWLINE> print ( <STRING> % fibCounter ) <NEWLINE> <DEDENT>
import base64 <NEWLINE> import time <NEWLINE> from openerp . osv import orm , fields <NEWLINE> from openerp . tools . translate import _ <NEWLINE> from openerp . tools import DEFAULT_SERVER_DATE_FORMAT <NEWLINE> from unidecode import unidecode <NEWLINE>
def grades_sum ( lst ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for i in lst : <NEWLINE> <INDENT> res += i <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT>
def _compare2 ( a , b ) : <NEWLINE> <INDENT> p = Turn . _compare ( a , b ) <NEWLINE> if p == 0 : <NEWLINE> <INDENT> alist = a . foes . all ( ) <NEWLINE> blist = b . foes . all ( ) <NEWLINE> i = len ( alist ) - 1 <NEWLINE> q = Turn . _compare ( alist [ i ] , blist [ i ] ) <NEWLINE> while q == 0 and i > 0 : <NEWLINE> <INDENT> i -= 1 <NEWLINE> q = Turn . _compare ( alist [ i ] , blist [ i ] ) <NEWLINE> <DEDENT> return q <NEWLINE> <DEDENT> return p <NEWLINE> <DEDENT>
def Zvalue_to_pvalue ( Zvalue , mode = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> mode = 2. if mode == <STRING> else 1. <NEWLINE> pvalue = scipy . special . erfc ( Zvalue / math . sqrt ( 2. ) ) / mode <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> return pvalue <NEWLINE> <DEDENT>
def mouseDoubleClickEvent ( self , mouseEvent ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> pass <NEWLINE> <DEDENT>
def DoCoProcessing ( datadescription ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> global coprocessor <NEWLINE> coprocessor . UpdateProducers ( datadescription ) <NEWLINE> coprocessor . WriteData ( datadescription ) ; <NEWLINE> coprocessor . WriteImages ( datadescription , rescale_lookuptable = False ) <NEWLINE> coprocessor . DoLiveVisualization ( datadescription , <STRING> , 22222 ) <NEWLINE> <DEDENT>
def finalize ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . _hisfile . close ( ) <NEWLINE> self . _trajectory . close ( ) <NEWLINE> <DEDENT>
