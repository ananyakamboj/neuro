def TranslateHealthCheck ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> health_check = self . app_engine_web_xml . health_check <NEWLINE> if not health_check : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> statements = [ <STRING> ] <NEWLINE> for attr in ( <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> ) : <NEWLINE> value = getattr ( health_check , attr , None ) <NEWLINE> if value is not None : <NEWLINE> statements . append ( <STRING> % ( attr , value ) ) <NEWLINE> <DEDENT> return statements <NEWLINE> <DEDENT>
( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>
def HasRenderingStats ( process ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not process : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for event in process . IterAllSlicesOfName ( <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> if <STRING> in event . args and event . args [ <STRING> ] [ <STRING> ] == 1 : <NEWLINE> return True <NEWLINE> <DEDENT> for event in process . IterAllSlicesOfName ( <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> if <STRING> in event . args and event . args [ <STRING> ] [ <STRING> ] == 1 : <NEWLINE> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
class ExportTestBase ( TestBase ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def assert_blacklisted_properties_removed ( self , original_model , exported ) : <NEWLINE> <INDENT> for prop in original_model . _get_export_blacklist ( ) : <NEWLINE> <INDENT> self . assertFalse ( hasattr ( exported , prop . name ) ) ) <NEWLINE> <DEDENT> <DEDENT> def transform ( self , value ) : <NEWLINE> <INDENT> return <STRING> + value <NEWLINE> <DEDENT> <DEDENT>
class Migration ( migrations . Migration ) : <NEWLINE> <INDENT> dependencies = [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ] <NEWLINE> operations = [ <NEWLINE> <INDENT> migrations . RunPython ( partial ( switch_host_to_tag , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> <STRING> ) , <NEWLINE> <DEDENT> migrations . RunPython ( partial ( switch_host_to_tag , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> <STRING> ) ) , <NEWLINE> <DEDENT> <DEDENT> ] <NEWLINE> <DEDENT>
def shutdown ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <INDENT> if self . _video_proxy . isRecording ( ) == True : <NEWLINE> print ( <STRING> ) <NEWLINE> videoInfo = self . _video_proxy . stopRecording ( ) <NEWLINE> self . _is_recording = False <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> self . _al_motion_proxy . closeHand ( <STRING> ) ; <NEWLINE> self . _al_motion_proxy . closeHand ( <STRING> ) ; <NEWLINE> print ( <STRING> ) <NEWLINE> self . _al_motion_proxy . rest ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
def test_create_metering_label_shared ( self ) : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> description = <STRING> <NEWLINE> shared = True <NEWLINE> keys = [ ( <STRING> , name , ) , ( <STRING> , description ) , <NEWLINE> <INDENT> ( <STRING> , shared ) ] <NEWLINE> <DEDENT> with self . metering_label ( name , description , <NEWLINE> <INDENT> shared = shared ) as metering_label : <NEWLINE> for k , v , in keys : <NEWLINE> self . assertEqual ( metering_label [ <STRING> ] [ k ] , v ) <NEWLINE> <DEDENT> <DEDENT>
def postimport ( self ) : <NEWLINE> <INDENT> for rb in RelatedBill . objects . filter ( <NEWLINE> <INDENT> bill__legislative_session__jurisdiction_id = self . jurisdiction_id , <NEWLINE> related_bill = None ) : <NEWLINE> candidates = list ( Bill . objects . filter ( <NEWLINE> legislative_session__identifier = rb . legislative_session , <NEWLINE> legislative_session__jurisdiction_id = self . jurisdiction_id , <NEWLINE> identifier = rb . identifier ) <NEWLINE> ) <NEWLINE> if len ( candidates ) == 1 : <NEWLINE> rb . related_bill = candidates [ 0 ] <NEWLINE> rb . save ( ) <NEWLINE> elif len ( candidates ) > 1 : <NEWLINE> raise PupaInternalError ( <STRING> . format ( rb ) ) <NEWLINE> <DEDENT> <DEDENT>
def get_bugcheck_callbacks ( self ) : <NEWLINE> <INDENT> resolver = self . session . address_resolver <NEWLINE> for list_head_name , type in [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <NEWLINE> <INDENT> <STRING> ) ] : <NEWLINE> list_head = resolver . get_constant_object ( <NEWLINE> <DEDENT> list_head_name , <STRING> ) <NEWLINE> for record in list_head . list_of_type ( type , <STRING> ) : <NEWLINE> function = record . CallbackRoutine <NEWLINE> yield ( list_head_name , <NEWLINE> <INDENT> record , <NEWLINE> function , <NEWLINE> utils . FormattedAddress ( resolver , function ) , <NEWLINE> record . Component ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def cur_tok_val ( self ) : <NEWLINE> <INDENT> if self . _idx == len ( self . _alltoks ) <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> return self . _alltoks [ self . _idx ] [ <STRING> ] <NEWLINE> <DEDENT>
def test_get_by_host_and_binary ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( self . dbapi , <NEWLINE> <INDENT> <STRING> , <NEWLINE> autospec = True ) as mock_get_magnum_service : <NEWLINE> mock_get_magnum_service . return_value = self . fake_magnum_service <NEWLINE> ms = objects . MagnumService . get_by_host_and_binary ( self . context , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ) <NEWLINE> mock_get_magnum_service . assert_called_once_with ( <STRING> , <NEWLINE> <STRING> ) <NEWLINE> self . assertEqual ( self . context , ms . _context ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def changeCT ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> from viewCT import * <NEWLINE> self . ct = getCTI ( self . interior ( ) <NEWLINE> self . ctable = 1 <NEWLINE> self . drawsurf2 ( ) <NEWLINE> self . ctable = 0 <NEWLINE> self . drawImage ( ) <NEWLINE> <DEDENT>
def exec_command ( self , command ) : <NEWLINE> <INDENT> to_exec = command % self . ssl_dictionary <NEWLINE> LOG . info ( to_exec ) <NEWLINE> subprocess . check_call ( to_exec . rsplit ( <STRING> ) <NEWLINE> <DEDENT>
def executeDeferred ( func , * args , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import maya . utils <NEWLINE> import maya . OpenMaya <NEWLINE> if maya . OpenMaya . MGlobal . mayaState ( ) == maya . OpenMaya . MGlobal . kInteractive : <NEWLINE> <INDENT> maya . utils . executeDeferred ( func , * args , ** kwargs ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if isinstance ( func , basestring ) : <NEWLINE> <INDENT> if args or kwargs : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> exec func <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> func ( * args , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def testAgendaUnauthorized ( self ) : <NEWLINE> <INDENT> res = self . client . get ( reverse ( <STRING> , kwargs = { <STRING> self . agenda_3 . id } ) ) <NEWLINE> self . assertEqual ( res . status_code , 403 ) <NEWLINE> <DEDENT>
def __in_box ( self , coordinates , box_corner , seg_len ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> in_box_coords = [ ] <NEWLINE> for xy in coordinates : <NEWLINE> in_box_coords . append ( ( <NEWLINE> <INDENT> box_corner [ 0 ] + seg_len * xy [ 0 ] , <NEWLINE> box_corner [ 1 ] + seg_len * xy [ 1 ] <NEWLINE> ) ) <NEWLINE> return in_box_coords <NEWLINE> <DEDENT> <DEDENT>
( <STRING> , { <NEWLINE> <INDENT> <STRING> : request , <NEWLINE> <STRING> : speaker , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : actions [ 0 : ] , <NEWLINE> <STRING> : actions_url_prefix , <NEWLINE> <STRING> : range ( 2006 , datetime . datetime . now ( ) . year + 1 ) , <NEWLINE> <DEDENT> } , <NEWLINE> context_instance = RequestContext ( request ) <NEWLINE> <DEDENT>
import datetime <NEWLINE> from django . db import models <NEWLINE> from django . db . models import Q <NEWLINE> from django . utils . translation import ugettext_lazy as _ <NEWLINE> from django . template import loader , Context <NEWLINE> from django . template . defaultfilters import slugify <NEWLINE> from django . core import urlresolvers <NEWLINE> from django . conf import settings <NEWLINE> from django . utils import translation <NEWLINE> try : <NEWLINE> <INDENT> from django . db . models . fields . related_descriptors import ReverseOneToOneDescriptor <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> from django . db . models . fields . related import SingleRelatedObjectDescriptor as ReverseOneToOneDescriptor <NEWLINE> <DEDENT>
def get_instance ( self , class_name , key ) : <NEWLINE> <INDENT> c = self . get_class ( class_name ) <NEWLINE> key_instance = self . new_instance_from_class ( c ) <NEWLINE> for k , v in key . items ( ) : <NEWLINE> <INDENT> key_instance . _instance [ six . text_type ( k ) ] = v <NEWLINE> <DEDENT> with self . _session . get_instance ( <NEWLINE> <INDENT> self . _ns , key_instance . _instance ) as op : <NEWLINE> instance = op . get_next_instance ( ) <NEWLINE> if instance : <NEWLINE> return _Instance ( self , instance . clone ( ) ) <NEWLINE> <DEDENT> <DEDENT>
def usage ( ) : <NEWLINE> <INDENT> print ( <STRING> , argv [ <NEWLINE> <INDENT> 0 ] , <STRING> <STRING> <STRING> <STRING> <NEWLINE> <DEDENT> <DEDENT>
def forEachLoopMaxInteger ( max ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> <INDENT> for n in xrange ( 0 , max ) : <NEWLINE> foo = n / 17 <NEWLINE> sum = sum + n <NEWLINE> <DEDENT> return sum <NEWLINE> <DEDENT>
def test_simple ( self ) : <NEWLINE> <INDENT> response = self . client . get ( reverse ( <STRING> ) <NEWLINE> self . assertEqual ( response . status_code , 200 ) <NEWLINE> self . assertTemplateUsed ( response , <STRING> ) <NEWLINE> self . assertTemplateUsed ( response , <STRING> ) <NEWLINE> <DEDENT>
def event_callback ( self , event_type , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> log . debug ( <STRING> ) <NEWLINE> self . _event_publisher . publish_event ( <NEWLINE> <INDENT> event_type = event_type , <NEWLINE> origin_type = self . ORIGIN_TYPE <NEWLINE> origin = self . resource_id , <NEWLINE> ** kwargs <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def retranslateUi ( self , HgQueuesListDialog ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> HgQueuesListDialog . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> HgQueuesListDialog . setWhatsThis ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def _format_tag_patterns ( self , pattern ) : <NEWLINE> <INDENT> for search , replace in [ ( <STRING> , <STRING> ) , ( <STRING> , <STRING> ) , ( <STRING> , <STRING> ) , <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , ( <STRING> , <STRING> ) ] : <NEWLINE> if search in pattern : <NEWLINE> pattern = pattern . replace ( search , replace ) <NEWLINE> <DEDENT> while <STRING> in pattern : <NEWLINE> <INDENT> pattern = pattern . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> return pattern <NEWLINE> <DEDENT>
def test_compilers ( ) : <NEWLINE> <INDENT> for module in ( <STRING> , <STRING> ) : <NEWLINE> <INDENT> for test , np , expected_output in [ ( <STRING> , 1 , <STRING> ) , <NEWLINE> <INDENT> ( <STRING> , 128 , <STRING> ) ] : <NEWLINE> for ext , compiler in [ ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) ] : <NEWLINE> source = test + <STRING> + ext <NEWLINE> target = test + <STRING> + ext + <STRING> <NEWLINE> yield check_build_and_verify , module , compiler , source , target , np , expected_output <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def _loginSucceeded ( self , ( interface , avatar , logout ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> class ResourceWrapper ( proxyForInterface ( IResource , <STRING> ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def getChildWithDefault ( self , name , request ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return ResourceWrapper ( self . resource . getChildWithDefault ( name , request ) ) <NEWLINE> <DEDENT> def render ( self , request ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> request . notifyFinish ( ) . addCallback ( lambda ign : logout ( ) ) <NEWLINE> return super ( ResourceWrapper , self ) . render ( request ) <NEWLINE> <DEDENT> <DEDENT> return ResourceWrapper ( avatar ) <NEWLINE> <DEDENT>
def test_add_column ( ) : <NEWLINE> <INDENT> setupClass ( EventTester ) <NEWLINE> watcher = make_listen ( events . AddColumnSignal ) <NEWLINE> events . summarize_events_by_sender ( ) <NEWLINE> class NewEventTester ( EventTester ) : <NEWLINE> <INDENT> name2 = StringCol ( ) <NEWLINE> <DEDENT> expect = ( <NEWLINE> <INDENT> NewEventTester , None , <NEWLINE> <STRING> , NewEventTester . sqlmeta . columnDefinitions [ <STRING> ] , <NEWLINE> False , [ ] ) <NEWLINE> <DEDENT> print ( zip ( watcher . log [ 1 ] , expect ) <NEWLINE> assert watcher . log [ 1 ] == expect <NEWLINE> <DEDENT>
def createRaidLevelMenu ( self , levels , reqlevel ) : <NEWLINE> <INDENT> levelcombo = gtk . combo_box_new_text ( ) <NEWLINE> defindex = 0 <NEWLINE> if mdraidlib . RAID1 in levels : <NEWLINE> <INDENT> defindex = levels . index ( mdraidlib . RAID1 ) <NEWLINE> i = 0 <NEWLINE> for lev in levels : <NEWLINE> levelcombo . append_text ( <STRING> % lev ) <NEWLINE> if reqlevel is not None and lev == reqlevel : <NEWLINE> defindex = i <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> levelcombo . set_active ( defindex ) <NEWLINE> levelcombo . connect ( <STRING> , self . raidlevelchangeCB ) <NEWLINE> return levelcombo <NEWLINE> <DEDENT>
def _create_player_logic_blocks ( self , player , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> player . uvars [ <STRING> ] = set ( ) <NEWLINE> if <STRING> in self . machine . config : <NEWLINE> <INDENT> self . _create_logic_blocks ( config = self . machine . config [ <STRING> ] <NEWLINE> <INDENT> player = player , <NEWLINE> enable = False ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def updateSerial ( ) : <NEWLINE> <INDENT> global alpha1 <NEWLINE> global alpha2 <NEWLINE> global ser <NEWLINE> try : <NEWLINE> msg = NMEA ( <STRING> , alpha1 , <STRING> ) <NEWLINE> print ( <STRING> + msg ) <NEWLINE> ser . write ( msg ) <NEWLINE> <INDENT> msg = NMEA ( <STRING> , alpha2 , <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> + msg ) <NEWLINE> ser . write ( msg ) <NEWLINE> except Exception , e : <NEWLINE> <INDENT> print ( <STRING> + str ( e ) ) <NEWLINE> <DEDENT> <DEDENT>
def te_extraction_tup ( args , input = None ) : <NEWLINE> <INDENT> if extract . __file__ . endswith ( <STRING> ) : yield extract . __file__ [ : - 1 ] <NEWLINE> else : yield extract . __file__ <NEWLINE> for x in ( <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> val = getattr ( args , x ) <NEWLINE> if val is not None : <NEWLINE> yield <STRING> . format ( x . replace ( <STRING> , <STRING> ) , val ) <NEWLINE> <DEDENT> yield <STRING> if input is None else input <NEWLINE> <DEDENT>
def _filter_link ( self , link , seen ) <NEWLINE> <INDENT> url = link . url <NEWLINE> if self . url_filterf ( link ) : <NEWLINE> <INDENT> if url not in seen : <NEWLINE> <INDENT> seen . add ( url ) <NEWLINE> request = Request ( url ) <NEWLINE> if link . text : <NEWLINE> <INDENT> request . meta [ <STRING> ] = link . text <NEWLINE> <DEDENT> return request <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def retranslateUi ( self , Form ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> Form . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . label_7 . setText ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . label_4 . setText ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . label_5 . setText ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . Max_val . setHtml ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def Warn ( self , msg ) : <NEWLINE> <INDENT> if GetOption ( <STRING> ) : <NEWLINE> <INDENT> print <STRING> % msg <NEWLINE> <DEDENT> self . warns . append ( msg ) <NEWLINE> <DEDENT>
def swap ( self ) : <NEWLINE> <INDENT> tmp = self . __class__ ( map ( lambda ( x , y ) : ( y , x ) , self . items ( ) ) ) <NEWLINE> self . list , self . dict = tmp . list , tmp . dict <NEWLINE> <DEDENT>
( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
def setUp ( self ) : <NEWLINE> <INDENT> self . driver = webdriver . PhantomJS ( ) <NEWLINE> self . driver . implicitly_wait ( 30 ) <NEWLINE> self . base_url = os . environ [ <STRING> ] <NEWLINE> if <STRING> not in self . base_url : <NEWLINE> self . base_url = <STRING> + self . base_url <NEWLINE> if self . base_url [ - 1 ] != <STRING> : <NEWLINE> <INDENT> self . base_url += <STRING> <NEWLINE> <DEDENT> self . verificationErrors = [ ] <NEWLINE> self . accept_next_alert = True <NEWLINE> <DEDENT>
import sys <NEWLINE> import logging <NEWLINE> from avocado . utils import process <NEWLINE> try <NEWLINE> <INDENT> from avocado . core . plugin_interfaces import CLICmd <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> from avocado . plugins . base import CLICmd <NEWLINE> <DEDENT> from virttest import bootstrap <NEWLINE> from virttest import defaults <NEWLINE> from virttest . standalone_test import SUPPORTED_TEST_TYPES <NEWLINE>
def derived_sequence ( self , u , coding = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> D = { } <NEWLINE> it = ( D . setdefault ( w , len ( D ) for w in self . return_words_iterator ( u ) ) <NEWLINE> W = InfiniteWords ( alphabet = NN ) <NEWLINE> w = W ( it , datatype = <STRING> ) <NEWLINE> if coding : <NEWLINE> <INDENT> return w , D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return w <NEWLINE> <DEDENT> <DEDENT>
def form_id ( self , record ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> form_id = self . env [ <STRING> ] . search ( [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> ( <STRING> , <STRING> , record [ <STRING> ] . strip ( ) , <NEWLINE> ( <STRING> , <STRING> , record [ <STRING> ] . strip ( ) . title ( ) ) , <NEWLINE> <DEDENT> ] , <NEWLINE> <INDENT> limit = 1 , <NEWLINE> <DEDENT> ) <NEWLINE> if form_id : <NEWLINE> <INDENT> return { <STRING> : form_id . id } <NEWLINE> <DEDENT> <DEDENT>
def getSetTags ( ) : <NEWLINE> <INDENT> lmodules = loader . loader ( ) . modules <NEWLINE> setags = set ( ) <NEWLINE> for mod in lmodules : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> setags . add ( lmodules [ mod ] . tags ) <NEWLINE> <DEDENT> except AttributeError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> setags . remove ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except KeyError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> return setags <NEWLINE> <DEDENT>
def getresponse ( self ) : <NEWLINE> <INDENT> class FakeResponse ( object ) : <NEWLINE> <INDENT> def __init__ ( self , ( code , body , headers ) ) : <NEWLINE> <INDENT> self . body = six . StringIO ( body ) <NEWLINE> self . headers = headers <NEWLINE> self . status = code <NEWLINE> <DEDENT> def read ( self , count = 1000000 ) : <NEWLINE> <INDENT> return self . body . read ( count ) <NEWLINE> <DEDENT> def getheaders ( self ) : <NEWLINE> <INDENT> return self . headers <NEWLINE> <DEDENT> <DEDENT> return FakeResponse ( self . reqs [ self . last_req ] ) <NEWLINE> <DEDENT>
def close_file_descriptor_if_open ( fd ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> os . close ( fd ) <NEWLINE> <DEDENT> except OSError , exc : <NEWLINE> <INDENT> if exc . errno == errno . EBADF : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> error = DaemonOSEnvironmentError ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> % vars ( ) ) <NEWLINE> <DEDENT> raise error <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def check ( self , ** kwargs ) : <NEWLINE> <INDENT> errors = super ( AutoCleanField , self ) . check ( ** kwargs ) <NEWLINE> errors . extend ( self . _check_depends_on_field ( ) ) ) <NEWLINE> return errors <NEWLINE> <DEDENT>
def NewPush ( args ) : <NEWLINE> <INDENT> lo , re = BigDirs ( ) <NEWLINE> for k , v in sorted ( lo . items ( ) ) : <NEWLINE> <INDENT> mtime , size = v <NEWLINE> v2 = re . get ( k ) <NEWLINE> if v2 == v : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> say <STRING> , k , mtime , size , v2 <NEWLINE> jname = J ( DIR . X , BUND . X , k ) <NEWLINE> client . RWriteFile ( BUND . X , k , ioutil . ReadFile ( jname ) , mtime = mtime , pw = PW . X ) <NEWLINE> <DEDENT> <DEDENT>
class Track ( models . Model ) : <NEWLINE> <INDENT> title = models . CharField ( max_length = 255 ) <NEWLINE> order = models . PositiveIntegerField ( ) <NEWLINE> track_file = models . FileField ( upload_to = <STRING> ) <NEWLINE> album = models . ForeignKey ( Album ) <NEWLINE> artist = models . ForeignKey ( Artist ) <NEWLINE> def get_absolute_url ( self ) : <NEWLINE> return <STRING> % self . title <NEWLINE> def player ( self ) : <NEWLINE> <INDENT> return <STRING> % self . track_file . url <NEWLINE> <DEDENT> player . allow_tags = True <NEWLINE> player . admin_order_field = <STRING> <NEWLINE> def __unicode__ ( self ) : <NEWLINE> <INDENT> return self . title <NEWLINE> <DEDENT> <DEDENT>
def proxyarp_host_unload ( cls ) : <NEWLINE> <INDENT> index = 1 <NEWLINE> for host , _ in cls . hosts_list : <NEWLINE> <INDENT> iface = cls . port_map [ index ] <NEWLINE> index += 1 <NEWLINE> config_cmds = ( <STRING> . format ( iface ) , ) <NEWLINE> for cmd in config_cmds : <NEWLINE> log_test . info ( <STRING> % cmd ) <NEWLINE> <INDENT> os . system ( cmd ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def _get_info_by_testcase ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> tests_by_testcase = { } <NEWLINE> for tests in ( self . successes , self . failures , self . errors , <NEWLINE> <INDENT> self . skipped ) : <NEWLINE> for test_info in tests : <NEWLINE> if isinstance ( test_info , tuple ) : <NEWLINE> test_info = test_info [ 0 ] <NEWLINE> testcase_name = test_info . test_name <NEWLINE> if testcase_name not in tests_by_testcase : <NEWLINE> tests_by_testcase [ testcase_name ] = [ ] <NEWLINE> tests_by_testcase [ testcase_name ] . append ( test_info ) <NEWLINE> <DEDENT> return tests_by_testcase <NEWLINE> <DEDENT>
class Translation ( Transform ) : <NEWLINE> <INDENT> def __init__ ( self , dx , dy ) : <NEWLINE> <INDENT> Transform . __init__ ( self ) <NEWLINE> <INDENT> self . trans_matrix = [ [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] , [ dx , dy , 1 ] ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def runAction ( ) : <NEWLINE> <INDENT> form = cgi . FieldStorage ( ) <NEWLINE> if ( form . has_key ( <STRING> ) and form . has_key ( <STRING> ) and form . has_key ( <STRING> ) ) : <NEWLINE> <INDENT> generate_form ( form [ <STRING> ] . value , form [ <STRING> ] . value , form [ <STRING> ] . value ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( formatXml ( <STRING> , <STRING> + str ( form . list ) . strip ( <STRING> ) , <NEWLINE> <INDENT> <STRING> + str ( form . __len__ ( ) ) ) ; <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class RequestMockBuilder ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , responses ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . responses = responses <NEWLINE> <DEDENT> def __call__ ( self , http , postproc , uri , method = <STRING> , body = None , <NEWLINE> <INDENT> headers = None , methodId = None ) : <NEWLINE> <STRING> <NEWLINE> if methodId in self . responses : <NEWLINE> resp , content = self . responses [ methodId ] <NEWLINE> return HttpRequestMock ( resp , content , postproc ) <NEWLINE> else : <NEWLINE> model = JsonModel ( False ) <NEWLINE> return HttpRequestMock ( None , <STRING> , model . response ) <NEWLINE> <DEDENT> <DEDENT>
def getusers ( request ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> online_users = get_users ( ) <NEWLINE> except Exception : <NEWLINE> online_users = None <NEWLINE> data = json . dumps ( online_users ) <NEWLINE> response = HttpResponse ( ) <NEWLINE> response [ <STRING> ] = <STRING> <NEWLINE> response . write ( data ) <NEWLINE> return response <NEWLINE> <DEDENT>
def get ( self , qname , qtype ) : <NEWLINE> <INDENT> print ( <STRING> % len ( self . cache ) ) <NEWLINE> <INDENT> value = self . cache . pop ( qname + <STRING> + qtype ) <NEWLINE> self . cache [ qname + <STRING> + qtype ] = value <NEWLINE> return self . cache [ qname + <STRING> + qtype ] <NEWLINE> <DEDENT> <DEDENT>
def finalize ( self , result ) : <NEWLINE> <INDENT> self . html . append ( <STRING> ) <NEWLINE> self . html . append ( <STRING> % <NEWLINE> <INDENT> ( result . testsRun , result . testsRun != 1 and <STRING> <NEWLINE> <DEDENT> <DEDENT>
class PositionData : <NEWLINE> <INDENT> def __init__ ( self , position_str ) : <NEWLINE> self . chr , interval = string . split ( position_str , <STRING> ) <NEWLINE> self . start , self . end = string . split ( interval , <STRING> ) <NEWLINE> def Chr ( self ) : return self . chr <NEWLINE> def Start ( self ) : return int ( self . start ) <NEWLINE> def End ( self ) : return int ( self . end ) <NEWLINE> <DEDENT>
def localInit ( self ) : <NEWLINE> <INDENT> ControlledSer . localInit ( self ) <NEWLINE> ( self . _just_born , self . _just_dead ) = ( True , False ) <NEWLINE> self . __start = man . now <NEWLINE> if self not in Bullet . __IN_FLIGHT : <NEWLINE> Bullet . __IN_FLIGHT . add ( self ) <NEWLINE> if ( len ( self . __class__ . __IN_FLIGHT ) % 25 == 0 ) : <NEWLINE> print ( <STRING> + str ( len ( self . __class__ . __IN_FLIGHT ) ) ) <NEWLINE> <DEDENT>
def __fetch_from_log ( self ) : <NEWLINE> <INDENT> logger . info ( <STRING> <NEWLINE> <INDENT> self . uri , self . gitpath ) <NEWLINE> <DEDENT> return self . parse_git_log_from_file ( self . gitpath ) <NEWLINE> <DEDENT>
def rebalance ( self , * args ) : <NEWLINE> <INDENT> clusters = self . cluster_spec . clusters <NEWLINE> initial_nodes = self . test_config . cluster . initial_nodes <NEWLINE> failed_nodes = self . rebalance_settings . failed_nodes <NEWLINE> for ( _ , servers ) , initial_nodes in zip ( clusters , <NEWLINE> <INDENT> initial_nodes ) : <NEWLINE> master = servers [ 0 ] <NEWLINE> failed = servers [ initial_nodes - failed_nodes : initial_nodes ] <NEWLINE> for node in failed : <NEWLINE> self . rest . graceful_fail_over ( master , node ) <NEWLINE> self . monitor_progress ( master ) <NEWLINE> <DEDENT> <DEDENT>
def getOutlineCrvFromSun ( geometry sunVector ) : <NEWLINE> <INDENT> planeFromSun = rc . Geometry . Plane ( rc . Geometry . Point3d . Origin , sunVector ) <NEWLINE> outlineCrvFromSun = [ ] <NEWLINE> polylines = geometry . GetOutlines ( planeFromSun ) <NEWLINE> [ outlineCrvFromSun . append ( pl . ToNurbsCurve ( ) ) for pl in polylines ] <NEWLINE> return outlineCrvFromSun <NEWLINE> <DEDENT>
def exportReport ( reportFile , lines ) : <NEWLINE> <INDENT> f = open ( reportFile , <STRING> ) <NEWLINE> for line in lines : <NEWLINE> f . write ( <STRING> % ( line ) ) <NEWLINE> f . close ( ) <NEWLINE> <DEDENT>
def usage ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( sys . argv [ 0 ] , <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
def set_type ( self , bounds_type ) : <NEWLINE> <INDENT> if not bounds_type in ( Bounds . TYPE_RELATIVE_MARGIN , <NEWLINE> <INDENT> Bounds . TYPE_FIXED_MARGIN , Bounds . TYPE_CUSTOM ) : <NEWLINE> raise ValueError , <STRING> + <STRING> + <STRING> % repr ( bounds_type ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . bounds_type = bounds_type <NEWLINE> <DEDENT> <DEDENT>
def print_cache ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> ) <NEWLINE> for block in self . cache : <NEWLINE> <INDENT> print ( <STRING> , <NEWLINE> for word in block : <NEWLINE> <INDENT> if word == - 1 or word == [ ] : <NEWLINE> <INDENT> output = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> output = word <NEWLINE> <DEDENT> print ( <STRING> % ( str ( output ) ) , ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from bs4 import BeautifulSoup <NEWLINE> from datetime import date <NEWLINE> import os . path as path <NEWLINE> import sys <NEWLINE> _SRC = path . join ( path . dirname ( path . abspath ( __file__ ) ) , <STRING> , <STRING> ) <NEWLINE> _COMPILE_JS = path . join ( <NEWLINE> <INDENT> _SRC , <STRING> , <STRING> , <STRING> ) <NEWLINE> <DEDENT> _POLYMERS = [ <STRING> % p for p in <STRING> , <STRING> , <STRING> ] <NEWLINE> _COMPILED_RESOURCES_TEMPLATE = <STRING> . strip ( ) <NEWLINE>
def done_configuring ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> global autoStartTimer <NEWLINE> print ( <STRING> ) <NEWLINE> if autoStartTimer is not None : <NEWLINE> autoStartTimer . update ( ) <NEWLINE> return <NEWLINE> <DEDENT>
def test_get_app_workdir ( self ) : <NEWLINE> <INDENT> workdir = utils . get_app_working_dir ( ) <NEWLINE> self . assertTrue ( os . access ( os . path . dirname ( workdir ) , os . W_OK ) ) ) <NEWLINE> <DEDENT>
def lightsOn ( ) : <NEWLINE> <INDENT> if lights != <STRING> : <NEWLINE> global lights <NEWLINE> <INDENT> os . system ( <STRING> ) <NEWLINE> lights = <STRING> <NEWLINE> pickle . dump ( lights , open ( <STRING> , <STRING> ) ) <NEWLINE> os . system ( <STRING> <STRING> <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def getParseCriteriaForUrl ( self , urlid ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> criteria = [ ] <NEWLINE> try : <NEWLINE> logging . debug ( <STRING> % urlid ) <NEWLINE> <INDENT> UrlSearchObjs = self . getSearchesforUrl ( urlid ) <NEWLINE> logging . debug ( <STRING> ) <NEWLINE> for s in UrlSearchObjs : <NEWLINE> logging . debug ( <STRING> % s . searchid ) <NEWLINE> <INDENT> criteria . append ( self . getParseCriteriaForSearch ( s . searchid ) ) <NEWLINE> logging . debug ( <STRING> ) <NEWLINE> <DEDENT> return criteria <NEWLINE> <DEDENT> except : raise <NEWLINE> <DEDENT>
def insistJavaClass ( c ) : <NEWLINE> <INDENT> jc = getJavaClass ( c ) <NEWLINE> if jc is None and isinstance ( c , StringType ) : <NEWLINE> <INDENT> jc = getJavaClass ( <STRING> + c ) <NEWLINE> <DEDENT> if jc is None : <NEWLINE> <INDENT> raise ValueError , <STRING> + c <NEWLINE> <DEDENT> return jc <NEWLINE> <DEDENT>
def getStoredAlarm ( self ) : <NEWLINE> <INDENT> alarmValue = <STRING> <NEWLINE> if os . path . isfile ( AlarmFile ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> alarmValue = self . execCommand ( <STRING> + AlarmFile ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> alarmValue = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> log . message ( <STRING> + AlarmFile , log . ERROR ) <NEWLINE> <DEDENT> return alarmValue <NEWLINE> <INDENT> def storeAlarm ( self , alarmString ) : <NEWLINE> <DEDENT> self . execCommand ( <STRING> + alarmString + <STRING> + AlarmFile ) <NEWLINE> return <NEWLINE> <DEDENT>
class SplashFormRequest ( SplashRequest , FormRequest ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , url = None , callback = None , method = None , formdata = None , <NEWLINE> <INDENT> body = None , ** kwargs ) : <NEWLINE> if formdata : <NEWLINE> FormRequest . __init__ ( <NEWLINE> self , url = url , method = method , formdata = formdata ) <NEWLINE> url , method , body = self . url , self . method , self . body <NEWLINE> SplashRequest . __init__ ( <NEWLINE> self , url = url , callback = callback , method = method , body = body , <NEWLINE> ** kwargs ) <NEWLINE> <DEDENT> <DEDENT>
def remove_registry_conf ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> with _winreg . OpenKey ( _winreg . HKEY_LOCAL_MACHINE , <NEWLINE> <INDENT> WINDOWS_REG_PATH , 0 , _winreg . KEY_WRITE ) as reg_key : <NEWLINE> for attribute in config_attributes : <NEWLINE> try : <NEWLINE> _winreg . DeleteValue ( reg_key , attribute ) <NEWLINE> except Exception as e : <NEWLINE> log . error ( <STRING> , attribute , str ( e ) ) <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT> except Exception : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
def get_minimum_path_nii ( fname ) : <NEWLINE> <INDENT> from msct_image import Image <NEWLINE> data = Image ( fname ) <NEWLINE> vesselness_data = data . data <NEWLINE> raw_orient = data . change_orientation ( ) <NEWLINE> result , J1 , J2 = get_minimum_path ( data . data invert = 1 ) <NEWLINE> data . data = result <NEWLINE> data . change_orientation ( raw_orient ) <NEWLINE> data . file_name += <STRING> <NEWLINE> data . save ( ) <NEWLINE> <DEDENT>
def _auth_cb ( self , creds , ( passwordcb , passwordcreds ) ) : <NEWLINE> <INDENT> for cred in creds : <NEWLINE> <INDENT> if cred [ 0 ] not in passwordcreds : <NEWLINE> <INDENT> raise RuntimeError ( <STRING> <NEWLINE> <INDENT> <STRING> % ( cred [ 0 ] , passwordcreds ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return passwordcb ( creds ) <NEWLINE> <DEDENT>
def isVisible ( self , face ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> normal = face [ 0 ] . normalAt ( 0 , 0 ) <NEWLINE> if DEBUG : print <STRING> , normal , <STRING> , self . wp . axis , <STRING> , math . degrees ( normal . getAngle ( self . wp . axis ) ) <NEWLINE> if normal . getAngle ( self . wp . axis ) < math . pi / 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
def testRawError ( self ) : <NEWLINE> <INDENT> with DoStubHttp ( 400 , <STRING> , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> with self . assertRaises ( ee . ee_exception . EEException ) as cm : <NEWLINE> ee . data . send_ ( <STRING> , { } , opt_raw = True ) <NEWLINE> self . assertEqual ( <STRING> , cm . exception . message ) <NEWLINE> <DEDENT> <DEDENT>
import wiringpi <NEWLINE> import time <NEWLINE> PIN = 18 <NEWLINE> wiringpi . wiringPiSetupGpio ( ) <NEWLINE> wiringpi . pinMode ( PIN , wiringpi . INPUT ) <NEWLINE> wiringpi . pullUpDnControl ( PIN , wiringpi . PUD_UP ) <NEWLINE> pulses = 0 <NEWLINE> amount = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if wiringpi . digitalRead ( PIN ) == 0 : <NEWLINE> <INDENT> pulses = pulses + 1 <NEWLINE> if pulses == 4 : <NEWLINE> pulses = 0 <NEWLINE> amount = amount + 1 <NEWLINE> print ( <STRING> + str ( amount ) ) <NEWLINE> <DEDENT> time . sleep ( .01 ) <NEWLINE> <DEDENT>
class OracleNoSQLTestCase_Neo4J_where ( unittest . TestCase ) : <NEWLINE> <INDENT> def runTest ( self ) : <NEWLINE> <INDENT> results = Neo4j on connOracleRDFNoSQL <STRING> <NEWLINE> assert sorted ( results ) == [ ( <STRING> , ) , ( <STRING> , ) , ( <STRING> , ) , ( <STRING> , ) , ( <STRING> , ) , ( <STRING> , ) ] , <STRING> <NEWLINE> <DEDENT> <DEDENT>
def finalize_options ( self ) : <NEWLINE> <INDENT> install . finalize_options ( self ) <NEWLINE> for optname in ( <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> ) : <NEWLINE> optvalue = getattr ( self , <STRING> . format ( optname ) ) <NEWLINE> if not optvalue : <NEWLINE> raise RuntimeError ( <NEWLINE> <STRING> . format ( <NEWLINE> optname . replace ( <STRING> , <STRING> ) <NEWLINE> ) <NEWLINE> ) <NEWLINE> setattr ( self . distribution , <STRING> . format ( optname ) , optvalue ) <NEWLINE> <DEDENT> <DEDENT>
def __isKtServerOnTakenPort ( dbElem , killSwitchPath , pretest = False ) : <NEWLINE> <INDENT> if __isKtServerReorganizing ( dbElem ) or __isKtServerRunning ( dbElem , <NEWLINE> <INDENT> killSwitchPath ) : <NEWLINE> logPath = __getLogPath ( dbElem ) <NEWLINE> pidList = __scrapePids ( [ logPath ] ) <NEWLINE> if pretest is False : <NEWLINE> thresh = 1 <NEWLINE> else : <NEWLINE> thresh = 0 <NEWLINE> if len ( pidList ) > thresh : <NEWLINE> raise RuntimeError ( <STRING> % <NEWLINE> logPath ) <NEWLINE> pidList = __scrapePids ( [ <STRING> % dbElem . getDbPort ( ) ] ) <NEWLINE> if len ( pidList ) > thresh : <NEWLINE> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
def set_temperature ( self , temperature ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for value in self . _node . get_values ( <NEWLINE> <INDENT> class_id = COMMAND_CLASS_THERMOSTAT_SETPOINT ) . values ( ) : <NEWLINE> if value . command_class != 67 : <NEWLINE> continue <NEWLINE> if self . _zxt_120 : <NEWLINE> self . _target_temperature = temperature <NEWLINE> if ZXT_120_SET_TEMP . get ( self . _current_operation ) != value . index : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> value . data = int ( round ( temperature , 0 ) ) <NEWLINE> else : <NEWLINE> value . data = int ( temperature ) <NEWLINE> <DEDENT> <DEDENT>
def test_client_retries_on_retry_after ( box_client , mock_box , retry_code , should_apply ) : <NEWLINE> <INDENT> should_apply , expected_num_requests = should_apply <NEWLINE> mock_box . get_folder_info . add_chaos ( error ( retry_code , headers = { RETRY_AFTER_HEADER : 1 } ) should_apply ) <NEWLINE> box_client . folder ( 0 ) . get ( ) <NEWLINE> assert len ( mock_box . requests ) == expected_num_requests <NEWLINE> <DEDENT>
def two ( ) : <NEWLINE> <INDENT> for arg in sys . argv [ 1 : ] : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> f = open ( arg , <STRING> ) <NEWLINE> <DEDENT> except IOError : <NEWLINE> <INDENT> print ( <STRING> , arg ) <NEWLINE> else : <NEWLINE> print ( arg , <STRING> , len ( f . readlines ( ) ) , <STRING> ) <NEWLINE> f . close ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def __contains__ ( self , value ) : <NEWLINE> <INDENT> if ( hasattr ( value , <STRING> ) and hasattr ( value , <STRING> ) <NEWLINE> <INDENT> and hasattr ( value , <STRING> ) ) : <NEWLINE> if self . _attribute : <NEWLINE> return value . url in [ elto [ self . _attribute ] <NEWLINE> <INDENT> for elto in self . _list ] <NEWLINE> else : <NEWLINE> <DEDENT> return value . url in self . _list <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
def sendImage ( self , jid , path , caption = None , onSuccess = None , onFailure = None ) : <NEWLINE> <INDENT> entity = RequestUploadIqProtocolEntity ( RequestUploadIqProtocolEntity . MEDIA_TYPE_IMAGE , filePath = path ) <NEWLINE> successFn = lambda successEntity , originalEntity : self . onRequestUploadResult ( jid , path , successEntity , originalEntity , caption , onSuccess , onFailure ) <NEWLINE> <INDENT> errorFn = lambda errorEntity , originalEntity : self . onRequestUploadError ( jid , path , errorEntity , originalEntity ) <NEWLINE> self . sendIq ( entity , successFn , errorFn ) <NEWLINE> <DEDENT> <DEDENT>
class IndexView ( views . APIView ) : <NEWLINE> <INDENT> template_name = <STRING> <NEWLINE> def get_data ( self , request , context , * args , ** kwargs ) : <NEWLINE> vm1 = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> vm2 = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> context [ <STRING> ] = [ vm1 , vm2 ] <NEWLINE> <INDENT> return context <NEWLINE> <DEDENT> <DEDENT>
def testAccessAttributeNotExposedByWrapper ( self ) : <NEWLINE> <INDENT> manager = self . manager <NEWLINE> with manager . acquireResource ( <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> resourceManager . LockType . exclusive ) as resource : <NEWLINE> try : <NEWLINE> resource . THERE_IS_NO_WAY_I_EXIST <NEWLINE> except AttributeError : <NEWLINE> return <NEWLINE> except Exception as ex : <NEWLINE> self . fail ( <STRING> <NEWLINE> <INDENT> <STRING> , <NEWLINE> ex . __class__ . __name__ ) <NEWLINE> <DEDENT> <DEDENT> self . fail ( <STRING> ) <NEWLINE> <DEDENT>
def scanwifi_actionfn ( self , eventObj = None ) : <NEWLINE> <INDENT> print ( os . system ( <STRING> ) <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT>
def _has_run_received ( self ) : <NEWLINE> <INDENT> debug ( 1 , <STRING> ) <NEWLINE> if len ( self . ifacedirty ) : <NEWLINE> <INDENT> for name in self . ifacedirty . keys ( ) : <NEWLINE> if self . devuuid [ name ] : <NEWLINE> <INDENT> self . check_and_save ( name , self . devuuid [ name ] ) <NEWLINE> <DEDENT> self . ifacedirty = { } <NEWLINE> <DEDENT> <DEDENT>
def retrieve ( self , url , name ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> handle = urllib2 . urlopen ( url ) <NEWLINE> <INDENT> CHUNK = 16384 <NEWLINE> <DEDENT> with open ( name , <STRING> ) as fp : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> chunk = handle . read ( CHUNK ) <NEWLINE> if not chunk : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> fp . write ( chunk ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> traceback . print_exc ( ) <NEWLINE> <DEDENT> <DEDENT>
def pick_best_methods ( stochastic ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> max_competence = 0 <NEWLINE> best_candidates = set ( [ ] ) <NEWLINE> for method in StepMethodRegistry : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> competence = method . competence ( stochastic ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> competence = 0 <NEWLINE> <DEDENT> if competence > max_competence : <NEWLINE> <INDENT> best_candidates = set ( [ method ] ) <NEWLINE> max_competence = competence <NEWLINE> <DEDENT> elif competence == max_competence : <NEWLINE> <INDENT> best_candidates . add ( method ) <NEWLINE> <DEDENT> <DEDENT> if max_competence <= 0 : <NEWLINE> <INDENT> raise ValueError , <STRING> % stochastic . __name__ <NEWLINE> <DEDENT> return best_candidates <NEWLINE> <DEDENT>
def retranslateUi ( self , MainWindow ) : <NEWLINE> <INDENT> MainWindow . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . textEdit_help . setHtml ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
def open_h2 ( fname , lists ) : <NEWLINE> <INDENT> f = open ( fname , <STRING> ) <NEWLINE> write_license ( f ) <NEWLINE> d = nz_fname ( fname ) . replace ( <STRING> , <STRING> ) . upper ( ) <NEWLINE> f . write ( <STRING> % ( d , d ) ) <NEWLINE> for i in lists : <NEWLINE> <INDENT> f . write ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
def encodeAllRecords ( self , records = None , toBeAdded = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if records is None : <NEWLINE> <INDENT> records = self . getAllRecords ( ) <NEWLINE> <DEDENT> if self . verbosity > 0 : print <STRING> , len ( records ) , <STRING> <NEWLINE> encodings = [ self . encodeRecord ( record , toBeAdded ) for record in records ] <NEWLINE> return encodings <NEWLINE> <DEDENT>
def __init__ ( self ) : <NEWLINE> <INDENT> BasePlugin . __init__ ( self ) <NEWLINE> try : <NEWLINE> print ( self . kbase [ <STRING> ] ) <NEWLINE> self . regex = re . compile ( self . kbase [ <STRING> ] [ 0 ] , re . MULTILINE | re . DOTALL ) <NEWLINE> except Exception , e : <NEWLINE> raise FuzzExceptPluginBadParams ( <STRING> ) <NEWLINE> <DEDENT>
def odb ( odbcmd , odbkey , val ) : <NEWLINE> <INDENT> if odbcmd == <STRING> : <NEWLINE> <INDENT> command = <STRING> + odbkey + <STRING> <NEWLINE> print ( command ) <NEWLINE> <DEDENT> elif odbcmd == <STRING> : <NEWLINE> <INDENT> command = <STRING> + odbkey + <STRING> + val + <STRING> <NEWLINE> <INDENT> elif odbcmd == <STRING> : <NEWLINE> <DEDENT> command = <STRING> + odbkey + <STRING> <NEWLINE> <DEDENT> p = Popen ( command , shell = True , stdout = PIPE , stderr = PIPE ) <NEWLINE> stdout , stderr = p . communicate ( ) <NEWLINE> print ( stderr ) <NEWLINE> return stdout <NEWLINE> <DEDENT>
def cairo_disable_antialias ( cr ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> antialias = cr . get_antialias ( ) <NEWLINE> cr . set_antialias ( cairo . ANTIALIAS_NONE ) <NEWLINE> try : <NEWLINE> <INDENT> yield <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> print ( <STRING> % e ) <NEWLINE> traceback . print_exc ( file = sys . stdout ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cr . set_antialias ( antialias ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , server = <STRING> , port = 5434 ) <NEWLINE> <INDENT> self . __server = server <NEWLINE> self . __port = port <NEWLINE> <DEDENT>
def CmdLineFindIndex ( tag ) : <NEWLINE> <INDENT> for i in range ( len ( sys . argv ) ) <NEWLINE> <INDENT> if sys . argv [ i ] == tag : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT> return - 1 <NEWLINE> <DEDENT>
class Serializer ( PythonSerializer ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def end_serialization ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . options . pop ( <STRING> , None ) <NEWLINE> simplejson . dump ( self . objects , self . stream , cls = DjangoJSONEncoder , <NEWLINE> <INDENT> ** self . options ) <NEWLINE> <DEDENT> <DEDENT> def getvalue ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if callable ( getattr ( self . stream , <STRING> , None ) : <NEWLINE> <INDENT> return self . stream . getvalue ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class cambioClave ( forms . Form ) : <NEWLINE> <INDENT> claveV = forms . CharField ( widget = forms . PasswordInput ( ) ) <NEWLINE> clave = forms . CharField ( widget = forms . PasswordInput ( ) <NEWLINE> claveO = forms . CharField ( widget = forms . PasswordInput ( ) ) <NEWLINE> <DEDENT>
def to_json_dict ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> json_dict = { } <NEWLINE> ffn = self . prefix + <STRING> <NEWLINE> apply_sed = ffn in self . data and self . data [ ffn ] <NEWLINE> json_dict [ ffn ] = apply_sed <NEWLINE> if apply_sed : <NEWLINE> <INDENT> for fn in [ <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> ] : <NEWLINE> ffn = self . prefix + <STRING> + fn <NEWLINE> val = self . data . get ( ffn ) <NEWLINE> if val is not None : <NEWLINE> json_dict [ ffn ] = val <NEWLINE> <DEDENT> <DEDENT> return json_dict <NEWLINE> <DEDENT>
( label , xy = ( 1 - tup [ 1 ] [ 0 ] / 100.0 , tup [ 1 ] [ 1 ] / 100.0 ) , textcoords = <STRING> , ha = <STRING> , va = <STRING> , <NEWLINE> <DEDENT> fig . savefig ( imgFile ) <NEWLINE> <DEDENT>
def connect ( host , port , user , password , source , expression ) : <NEWLINE> <INDENT> with manager . connect ( <NEWLINE> <INDENT> host = host , port = port , <NEWLINE> username = user , password = password <NEWLINE> ) as m : <NEWLINE> assert ( <STRING> in m . server_capabilities ) <NEWLINE> c = m . get_config ( source , filter = ( <STRING> , expression ) ) . data_xml <NEWLINE> with open ( <STRING> % host , <STRING> ) as f : <NEWLINE> f . write ( c ) <NEWLINE> <DEDENT> <DEDENT>
def remove_adjacent ( nums ) : <NEWLINE> <INDENT> lst = [ ] <NEWLINE> if len ( nums ) == 0 : <NEWLINE> return lst <NEWLINE> lst . append ( nums [ 0 ] ) <NEWLINE> for num in nums [ 1 : ] : <NEWLINE> <INDENT> if lst [ - 1 ] != num : <NEWLINE> <INDENT> lst . append ( num ) <NEWLINE> <DEDENT> <DEDENT> return lst <NEWLINE> <DEDENT>
def _block_piece ( self , index , df ) : <NEWLINE> <INDENT> self . blocking_pieces [ index ] = df <NEWLINE> df . addCallback ( lambda x : self . blocking_pieces . pop ( index ) <NEWLINE> return df <NEWLINE> <DEDENT>
def _GetWin32ProcessInfo ( self , func , pid ) : <NEWLINE> <INDENT> mask = ( win32con . PROCESS_QUERY_INFORMATION | <NEWLINE> <INDENT> win32con . PROCESS_VM_READ ) <NEWLINE> <DEDENT> handle = None <NEWLINE> try : <NEWLINE> <INDENT> handle = win32api . OpenProcess ( mask , False , pid ) <NEWLINE> return func ( handle ) <NEWLINE> <DEDENT> except pywintypes . error , e : <NEWLINE> <INDENT> errcode = e [ 0 ] <NEWLINE> if errcode == 87 : <NEWLINE> <INDENT> raise exceptions . ProcessGoneException ( ) <NEWLINE> <DEDENT> raise <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> if handle : <NEWLINE> <INDENT> win32api . CloseHandle ( handle ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_create_route_no_cidr_raises ( self ) : <NEWLINE> <INDENT> subnet = dict ( id = 2 , ip_policy = [ ] , cidr = <STRING> ) <NEWLINE> create_route = dict ( id = 1 , gateway = <STRING> , <NEWLINE> <INDENT> subnet_id = subnet [ <STRING> ] ) <NEWLINE> <DEDENT> with self . _stubs ( create_route = create_route , find_routes = [ ] , <NEWLINE> <INDENT> subnet = subnet ) : <NEWLINE> with self . assertRaises ( <NEWLINE> exceptions . BadRequest ) : <NEWLINE> self . plugin . create_route ( self . context , <NEWLINE> <INDENT> dict ( route = create_route ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def bytes ( self ) : <NEWLINE> <INDENT> URL_extension_count = 0 <NEWLINE> for url in self . URL_extensions : <NEWLINE> <INDENT> URL_extension_count = URL_extension_count + 1 <NEWLINE> <DEDENT> fmt = <STRING> % len ( self . URL_base ) <NEWLINE> result = pack ( fmt , <NEWLINE> <INDENT> self . protocol_id , <NEWLINE> self . transport_protocol_label , <NEWLINE> <DEDENT> len ( self . URL_base ) , <NEWLINE> self . URL_base , <NEWLINE> URL_extension_count <NEWLINE> <INDENT> ) <NEWLINE> <DEDENT> for url in self . URL_extensions : <NEWLINE> <INDENT> result = result + pack ( <NEWLINE> <INDENT> <STRING> % len ( url ) , <NEWLINE> len ( url ) , <NEWLINE> url , <NEWLINE> ) <NEWLINE> return result <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def checkBC ( self ) : <NEWLINE> <INDENT> xtemp = self . x . copy ( ) <NEWLINE> if self . RW . domain . typ == <STRING> and self . BCtyp in [ 0 , 1 ] : <NEWLINE> self . x = self . BCs [ 0 ] . hit ( self . xold , self . x ) <NEWLINE> else : <NEWLINE> for i , BC in enumerate ( self . BCs ) : <NEWLINE> self . x = BC . hit ( self . xold , self . x ) <NEWLINE> if not ( self . x == xtemp ) . all ( ) : <NEWLINE> break <NEWLINE> return self . x <NEWLINE> <DEDENT>
def timeGetBlocksGrid ( ) : <NEWLINE> <INDENT> x , y , z = numpy . mgrid [ <NEWLINE> <INDENT> box . minx : box . maxx , <NEWLINE> box . miny : box . maxy , <NEWLINE> box . minz : box . maxz , <NEWLINE> <DEDENT> ] <NEWLINE> x , y , z = [ numpy . ravel ( a ) for a in x , y , z ] <NEWLINE> result = dim . getBlocks ( x , y , z , return_Data = True ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> if len ( sys . argv ) > 4 : <NEWLINE> sd = len ( sys . argv ) <NEWLINE> print ( <STRING> , sd ) <NEWLINE> else : <NEWLINE> f = len ( sys . argv ) <NEWLINE> print ( <STRING> , f ) <NEWLINE> if len ( sys . argv ) >= 2 : <NEWLINE> <INDENT> name = sys . argv [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> <DEDENT> print ( <STRING> , name ) <NEWLINE> <DEDENT>
class MockSuite ( _Mock ) : <NEWLINE> <INDENT> def __init__ ( self , name , mediumname = None , longname = None , visible = True , <NEWLINE> <INDENT> suites = [ ] , tests = [ ] ) : <NEWLINE> _Mock . __init__ ( self , name , mediumname , longname , visible ) <NEWLINE> for suite in suites : <NEWLINE> suite . parent = self <NEWLINE> self . suites = suites <NEWLINE> for test in tests : <NEWLINE> test . parent = self <NEWLINE> self . tests = tests <NEWLINE> <DEDENT> <DEDENT>
def __setattr__ ( self , key , value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( key == <STRING> ) : <NEWLINE> <INDENT> return self . set_id ( value ) <NEWLINE> <DEDENT> if ( key . startswith ( <STRING> ) : <NEWLINE> <INDENT> _dict = object . __getattribute__ ( self , <STRING> ) <NEWLINE> _dict [ key ] = value <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self [ key ] = value <NEWLINE> <DEDENT> <DEDENT>
def ListBookmarks ( conn ) : <NEWLINE> <INDENT> val = conn . execute ( <STRING> ) . fetchall ( ) <NEWLINE> if len ( val ) == 0 : print bcolors . WARNING + <STRING> + bcolors . ENDC <NEWLINE> for Row in val : <NEWLINE> <INDENT> print ( bcolors . OKBLUE + Row [ 3 ] + bcolors . OKGREEN + <STRING> + Row [ 2 ] + bcolors . ENDC ) <NEWLINE> <DEDENT> <DEDENT>
def test_on_settings_changed ( self ) : <NEWLINE> <INDENT> body = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> event_type = <STRING> <NEWLINE> with patch ( <STRING> <NEWLINE> <INDENT> <STRING> , <NEWLINE> ) as m_publish_event_async : <NEWLINE> self . result = self . target . on_settings_changed ( <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ) <NEWLINE> m_publish_event_async . assert_called_one_with ( event_type , <NEWLINE> body ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def run_sossrv ( target , ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if target != <STRING> and prog != <STRING> : <NEWLINE> cmd_run = [ <STRING> , <STRING> , listen_port ] <NEWLINE> elif prog == <STRING> : <NEWLINE> cmd_run = [ <STRING> , <STRING> , <STRING> % listen_ip ] <NEWLINE> else : <NEWLINE> cmd_run = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> print ( cmd_run ) <NEWLINE> time . sleep ( 10 ) <NEWLINE> ret = os . fork ( ) <NEWLINE> if ret == 0 : <NEWLINE> run_and_redirect ( cmd_run , os . environ [ <STRING> ] + <STRING> ) <NEWLINE> time . sleep ( 20 ) <NEWLINE> return ret <NEWLINE> <DEDENT>
def nr7 ( _sec , _media , _desv ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quince = np . array ( [ ] ) <NEWLINE> for i in range ( len ( _sec ) ) : <NEWLINE> if ( ( _sec [ i ] > _media - _desv ) & ( _sec [ i ] < _media + _desv ) ) : quince = np . append ( quince , i ) <NEWLINE> consec = np . array_split ( quince , np . where ( np . diff ( quince ) != 1 ) [ 0 ] + 1 ) <NEWLINE> imp_nr ( consec , _sec , 15 ) <NEWLINE> <DEDENT>
class TestExtractBadArchive ( unittest . TestCase ) : <NEWLINE> <INDENT> def verifyFailed ( self , ( exitcode , stdout , stderr ) ) : <NEWLINE> <INDENT> self . assertEqual ( exitcode , 1 ) <NEWLINE> self . assertTrue ( <STRING> in stderr ) <NEWLINE> <DEDENT> def test_extract_missing_file ( self ) : <NEWLINE> <INDENT> self . verifyFailed ( run ( [ <STRING> , <STRING> ] ) ) ; <NEWLINE> <DEDENT> <DEDENT>
def get_option_order ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . option_order is None : <NEWLINE> <INDENT> raise RuntimeError , <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . option_order <NEWLINE> <DEDENT> <DEDENT>
def add_interpretation ( self , interp : Interpretation ) -> None <NEWLINE> <INDENT> <STRING> <NEWLINE> assert interp . name not in self . interpretations_byname , <STRING> <NEWLINE> self . interpretations . append ( interp ) <NEWLINE> self . interpretations_byname [ interp . name ] = interp <NEWLINE> <DEDENT>
def setUp ( self ) : <NEWLINE> <INDENT> super ( TestFirewallAgentApi , self ) . setUp ( ) <NEWLINE> self . api = fwaas_plugin . FirewallAgentApi ( <STRING> , <STRING> ) <NEWLINE> self . mock_fanoutcast = mock . patch . object ( self . api <NEWLINE> <INDENT> <STRING> ) . start ( ) <NEWLINE> <DEDENT> self . mock_msg = mock . patch . object ( self . api , <STRING> ) . start ( ) <NEWLINE> <DEDENT>
def layer1 ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> data = defaultdict ( lambda : defaultdict ( dict ) ) <NEWLINE> processed = False <NEWLINE> for item in [ <NEWLINE> <INDENT> Query ( self . snmp_object ) <NEWLINE> for Query in get_queries ( <STRING> ) ] : <NEWLINE> if item . supported ( ) : <NEWLINE> processed = True <NEWLINE> data = _add_layer1 ( item , data ) <NEWLINE> <DEDENT> if processed is True : <NEWLINE> <INDENT> return data <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT>
def drag ( self , ( x0 , y0 ) , ( x1 , y1 ) , duration = 0.5 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> log . debug ( <STRING> , ( x0 , y0 ) , ( x1 , y1 ) ) <NEWLINE> <DEDENT>
def test_hardware_updates_does_nothing_when_exit_status_is_not_zero ( self ) : <NEWLINE> <INDENT> logger = self . useFixture ( FakeLogger ( ) <NEWLINE> update_hardware_details ( factory . make_node ( ) , <STRING> , exit_status = 1 ) <NEWLINE> self . assertEqual ( <STRING> , logger . output ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> a = [ ] int ( 1 , 2 , 3 ) <NEWLINE> print ( a ) <NEWLINE> assert a [ 0 ] == 1 <NEWLINE> assert len ( a ) == 3 <NEWLINE> a . append ( 4 ) <NEWLINE> assert len ( a ) == 4 <NEWLINE> test_pass_array_as_arg ( a ) <NEWLINE> assert len ( a ) == 5 <NEWLINE> b = [ 2 ] int ( 100 , 200 ) <NEWLINE> assert b [ 0 ] == 100 <NEWLINE> assert b [ 1 ] == 200 <NEWLINE> <DEDENT>
import sys <NEWLINE> BaseModuleStr = <STRING> ) <NEWLINE> DecorationModule = BaseModule <NEWLINE>
def test_start ( self ) : <NEWLINE> <INDENT> test_interval = 120 <NEWLINE> cfg . CONF . set_override ( <STRING> , <NEWLINE> <INDENT> test_interval , <NEWLINE> group = <STRING> ) <NEWLINE> <DEDENT> with mock . patch ( <STRING> , <NEWLINE> <INDENT> return_value = self . api_client ) : <NEWLINE> self . singleton . start ( ) <NEWLINE> expected = [ <NEWLINE> mock . call ( test_interval , <NEWLINE> <INDENT> self . singleton . _evaluate_assigned_alarms , <NEWLINE> 0 ) , <NEWLINE> mock . call ( 604800 , mock . ANY ) , <NEWLINE> ] <NEWLINE> actual = self . singleton . tg . add_timer . call_args_list <NEWLINE> self . assertEqual ( expected , actual ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_raw_data ( self , endpoint ) : <NEWLINE> <INDENT> req = urllib2 . urlopen ( urlparse . urljoin ( self . base_url , endpoint ) ) <NEWLINE> <INDENT> res = req . read ( ) <NEWLINE> req . close ( ) <NEWLINE> data = json . loads ( res ) <NEWLINE> return data <NEWLINE> <DEDENT> <DEDENT>
def _unlock ( self , req , id , body ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> context = req . environ [ <STRING> ] <NEWLINE> authorize ( context , <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> instance = self . compute_api . get ( context , id , want_objects = True ) <NEWLINE> self . compute_api . unlock ( context , instance ) <NEWLINE> <DEDENT> except exception . InstanceNotFound as e : <NEWLINE> <INDENT> raise exc . HTTPNotFound ( explanation = e . format_message ( ) <NEWLINE> <DEDENT> return webob . Response ( status_int = 202 ) <NEWLINE> <DEDENT>
def run_server_cmds ( self ) : <NEWLINE> <INDENT> self . server = Oneline_V2_CommandLine_Server ( ) <NEWLINE> for i in self . server_cmds : <NEWLINE> self . process_cmd ( self . server , i ) <NEWLINE> <DEDENT>
def test_help ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for command in ( <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ) : <NEWLINE> with mock . patch ( <STRING> ) as client_mock : <NEWLINE> self . shell ( command ) <NEWLINE> self . assertFalse ( client_mock . called ) <NEWLINE> <DEDENT> <DEDENT>
def move_right ( i , pos , car ) : <NEWLINE> <INDENT> free_col = car . length + i <NEWLINE> if free_col < dimension : <NEWLINE> mk_transition ( car . base , free_col , i , i + 1 , pos ) <NEWLINE> <DEDENT>
def next_tasks ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> LOG . debug ( <STRING> ) <NEWLINE> for task in self . tasks : <NEWLINE> <INDENT> LOG . debug ( <STRING> , task ) <NEWLINE> for mf in list ( self . dbapi . get_medias_by ( self . torrent . torrent_id , <NEWLINE> <INDENT> missing = False , <NEWLINE> skipped = False ) ) : <NEWLINE> LOG . debug ( <STRING> , mf ) <NEWLINE> if task . is_actionable ( mf ) : <NEWLINE> LOG . debug ( <STRING> , mf ) <NEWLINE> yield task ( mf ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def _onCharsetError ( self ) : <NEWLINE> <INDENT> self . newDialog . statusNotificationLabel . setText ( QApplication . translate ( <STRING> , <STRING> ) ) <NEWLINE> self . newDialog . charsetDropDown . addItems ( CharsetList . charsetList ) <NEWLINE> self . newDialog . charsetDropDown . setCurrentIndex ( CharsetList . charsetList . index ( <STRING> ) <NEWLINE> self . _showCharsetWidget ( ) <NEWLINE> <DEDENT>
def haptrans ( ( e , d ) ) : <NEWLINE> <INDENT> if e [ 0 ] == d [ 1 ] : <NEWLINE> <INDENT> return float ( e [ 3 ] [ <STRING> ] ) / float ( sum ( T [ 0 ] . node [ e [ 0 ] ] [ <STRING> ] . itervalues ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0.0 <NEWLINE> <DEDENT> <DEDENT>
class AutoRestParameterFlatteningConfiguration ( Configuration ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( <NEWLINE> <INDENT> self , base_url = None , filepath = None ) : <NEWLINE> if not base_url : <NEWLINE> base_url = <STRING> <NEWLINE> super ( AutoRestParameterFlatteningConfiguration , self ) . __init__ ( base_url , filepath ) <NEWLINE> self . add_user_agent ( <STRING> . format ( VERSION ) ) <NEWLINE> <DEDENT> <DEDENT>
def load_image ( filename , cache = 1 ) : <NEWLINE> <INDENT> if type ( filename ) == StringType : <NEWLINE> image = get_cached ( filename ) <NEWLINE> if image : <NEWLINE> <INDENT> return image <NEWLINE> <DEDENT> image = PIL . Image . open ( filename ) <NEWLINE> if type ( filename ) != StringType : <NEWLINE> filename = <STRING> <NEWLINE> return ImageData ( image , filename = filename , cache = cache ) <NEWLINE> <DEDENT>
def __init__ ( self ) <NEWLINE> <INDENT> self . steppableTemplatesDict = { } <NEWLINE> self . initSteppableTemplates ( ) <NEWLINE> <DEDENT>
def upload_pypi ( ) : <NEWLINE> <INDENT> import os <NEWLINE> file = <STRING> <NEWLINE> try : <NEWLINE> <INDENT> with open ( os . path . abspath ( os . path . expanduser ( file ) ) ) as f <NEWLINE> <INDENT> password = f . read ( ) <NEWLINE> <DEDENT> <DEDENT> except FileNotFoundError : <NEWLINE> <INDENT> password = None <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> if not password : <NEWLINE> <INDENT> raise Exception ( <STRING> + file ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> run ( <STRING> + password ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def _heard ( self , line ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> % ( self . heard_fg , self . heard_bg ) , <NEWLINE> print ( <STRING> % line . rjust ( self . ui_width ) , ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
def openFile ( self , metainfo ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . file_pointer = open ( metainfo . info [ <STRING> ] , <STRING> ) <NEWLINE> while True : <NEWLINE> <INDENT> self . data_buffer = self . file_pointer . read ( self . piece_size ) <NEWLINE> if len ( self . data_buffer ) < self . piece_size : <NEWLINE> break <NEWLINE> hash_obj = hashlib . sha1 ( ) <NEWLINE> hash_obj . update ( self . data_buffer ) <NEWLINE> temp_piece = hash_obj . digest ( ) <NEWLINE> if temp_piece == self . piece_hash [ self . piece_index ] : <NEWLINE> <INDENT> self . piece_index += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def GetFileSystemTypeIndicators ( cls , path_spec , resolver_context = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( cls . _file_system_remainder_list is None or <NEWLINE> <INDENT> cls . _file_system_store is None ) : <NEWLINE> specification_store , remainder_list = cls . _GetSpecificationStore ( <NEWLINE> <INDENT> definitions . FORMAT_CATEGORY_FILE_SYSTEM ) <NEWLINE> cls . _file_system_remainder_list = remainder_list <NEWLINE> cls . _file_system_store = specification_store <NEWLINE> <DEDENT> <DEDENT> if cls . _file_system_scanner is None : <NEWLINE> <INDENT> cls . _file_system_scanner = cls . _GetSignatureScanner ( <NEWLINE> <INDENT> cls . _file_system_store ) <NEWLINE> <DEDENT> <DEDENT> return cls . _GetTypeIndicators ( <NEWLINE> <INDENT> cls . _file_system_scanner , cls . _file_system_store , <NEWLINE> cls . _file_system_remainder_list , path_spec , <NEWLINE> resolver_context = resolver_context ) <NEWLINE> <DEDENT> <DEDENT>
def display ( uri , response ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( { uri : list ( response . headers . getRawHeaders ( <NEWLINE> <INDENT> <STRING> , [ ] ) ) } <NEWLINE> <DEDENT> <DEDENT>
def listen ( self , namespace ) : <NEWLINE> <INDENT> res = sniff ( lfilter = lambda ( packet ) : IPv6 in packet , <NEWLINE> <INDENT> prn = lambda ( packet ) : self . callback ( packet , namespace ) , <NEWLINE> stop_filter = self . stopfilter , <NEWLINE> store = 0 ) <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT>
def process_data_events ( self , to_tuple = False , auto_decode = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not self . consumer_callback : <NEWLINE> <INDENT> raise AMQPChannelError ( <STRING> ) <NEWLINE> <DEDENT> for message in self . build_inbound_messages ( break_on_empty = True , <NEWLINE> <INDENT> to_tuple = to_tuple , <NEWLINE> auto_decode = auto_decode ) : <NEWLINE> if self . _die . value != 0 : <NEWLINE> return <NEWLINE> if to_tuple : <NEWLINE> self . consumer_callback ( * message ) <NEWLINE> continue <NEWLINE> self . consumer_callback ( message ) <NEWLINE> <DEDENT> sleep ( IDLE_WAIT ) <NEWLINE> <DEDENT>
( <STRING> , <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> print ( <STRING> + str ( B [ i ] [ j ] ) , ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def test_config_check_success ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> proc = test_base . TimeoutRunner ( [ <NEWLINE> <INDENT> self . binary , <NEWLINE> <STRING> , <NEWLINE> <STRING> % ( self . dbpath ) , <NEWLINE> <STRING> % test_base . SCRIPT_DIR <NEWLINE> <DEDENT> <DEDENT>
def download ( url , filename , to_dir ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> new_file = os . path . join ( to_dir , filename ) <NEWLINE> try : <NEWLINE> <INDENT> conn = PLOTEXTRACTOR_OPENER . open ( url ) <NEWLINE> response = conn . read ( ) <NEWLINE> conn . close ( ) <NEWLINE> new_file_fd = open ( new_file , <STRING> ) <NEWLINE> new_file_fd . write ( response ) <NEWLINE> new_file_fd . close ( ) <NEWLINE> write_message ( <STRING> + new_file ) <NEWLINE> return True <NEWLINE> <DEDENT> except ( IOError , urllib2 . URLError ) , e : <NEWLINE> <INDENT> write_message ( <STRING> % ( url , str ( e ) ) ) <NEWLINE> return False <NEWLINE> <DEDENT> <DEDENT>
def _shutdown ( self , * args , ** kwargs ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> os . remove ( deluge . configmanager . get_config_dir ( <STRING> ) ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> log . exception ( e ) <NEWLINE> log . error ( <STRING> ) <NEWLINE> <DEDENT> component . shutdown ( ) <NEWLINE> try : <NEWLINE> <INDENT> reactor . stop ( ) <NEWLINE> <DEDENT> except twisted . internet . error . ReactorNotRunning : <NEWLINE> <INDENT> log . debug ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def getLiveMergeSupport ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for flag in ( <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ) : <NEWLINE> if not hasattr ( libvirt , flag ) : <NEWLINE> logging . debug ( <STRING> , flag ) <NEWLINE> return False <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT>
class Flag1 ( smach . State ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> smach . State . __init__ ( self , outcomes = [ <STRING> , <STRING> ] ) <NEWLINE> <DEDENT> def execute ( self , userdata ) : <NEWLINE> global receivedflag1 <NEWLINE> receivedflag1 = 0 <NEWLINE> rospy . sleep ( 0.05 ) <NEWLINE> rospy . Subscriber ( <STRING> , Int8 , callback1 ) <NEWLINE> if receivedflag1 == 1 : <NEWLINE> return <STRING> <NEWLINE> <INDENT> else : <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <DEDENT>
def indirectTrust ( sn , userA , userB ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> length = 1 <NEWLINE> while length < maxLength : <NEWLINE> path = sn . getSimplePath ( userA , userB , 3 ) <NEWLINE> print ( path ) <NEWLINE> for a in path : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
def detach ( self , sr_uuid ) : <NEWLINE> <INDENT> if self . _checkmount ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> util . SMlog ( <STRING> ) <NEWLINE> cleanup . abort ( self . uuid ) <NEWLINE> os . chdir ( SR . MOUNT_BASE ) <NEWLINE> util . pread ( [ <STRING> , self . path ] ) <NEWLINE> os . rmdir ( self . path ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> raise xs_errors . XenError ( <STRING> , opterr = str ( e ) ) <NEWLINE> <DEDENT> <DEDENT> self . attached = False <NEWLINE> <DEDENT>
def zip_annotations ( procedure , default = UNDEFINED ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if default is not UNDEFINED : <NEWLINE> ann = annotations ( procedure ) <NEWLINE> return ( ( n , ann . get ( n , default ) ) for n in annotatable_names ( procedure ) ) <NEWLINE> else : <NEWLINE> ann = annotations ( procedure ) <NEWLINE> return ( <NEWLINE> <INDENT> ( n , ann [ n ] ) <NEWLINE> for n in annotatable_names ( procedure ) <NEWLINE> if n in ann <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT>
class TestChannelModelCreator ( SingleSlopeChannelModelCreator ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> SingleSlopeChannelModelCreator . __init__ ( self , <STRING> , <STRING> ) <NEWLINE> <DEDENT>
def test_curricula_for_term ( self ) : <NEWLINE> <INDENT> with self . settings ( <NEWLINE> <INDENT> RESTCLIENTS_SWS_DAO_CLASS = <STRING> , <NEWLINE> RESTCLIENTS_PWS_DAO_CLASS = <STRING> ) : <NEWLINE> term = Term ( quarter = <STRING> , year = 2013 ) <NEWLINE> curricula = get_curricula_by_term ( term ) <NEWLINE> self . assertEquals ( len ( curricula ) , 423 ) <NEWLINE> self . assertRaises ( DataFailureException , <NEWLINE> <INDENT> get_curricula_by_term , <NEWLINE> Term ( quarter = <STRING> , year = 2012 ) ) <NEWLINE> self . assertRaises ( DataFailureException , <NEWLINE> get_curricula_by_term , <NEWLINE> Term ( quarter = <STRING> , year = 2012 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def setup ( self ) : <NEWLINE> <INDENT> self . bug_id = 1221569 <NEWLINE> self . bug_description = <STRING> <NEWLINE> file_path = os . path . dirname ( os . path . abspath ( __file__ ) + <STRING> <NEWLINE> with open ( file_path ) as f : <NEWLINE> <INDENT> self . config = Config ( f ) <NEWLINE> <DEDENT> <DEDENT>
class WebLocParser ( QCoreApplication ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> super ( QCoreApplication , self ) . __init__ ( sys . argv ) <NEWLINE> self . reset ( ) <NEWLINE> <DEDENT> def parseAndOpen ( self , fileName ) : <NEWLINE> <INDENT> try : <NEWLINE> plist = plistlib . readPlist ( fileName ) <NEWLINE> if <STRING> in plist : <NEWLINE> <INDENT> KToolInvocation . invokeBrowser ( plist [ <STRING> ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> sys . stderr . write ( <STRING> % fileName ) <NEWLINE> <DEDENT> <DEDENT> def reset ( self ) : <NEWLINE> pass <NEWLINE> <DEDENT>
def thumbnails ( self ) : <NEWLINE> <INDENT> _thumbnails = { } <NEWLINE> for name , opts in Image . DEFAULT_THUMBNAILS . items ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> opts . update ( { <STRING> : self . subject_location } ) <NEWLINE> thumb = self . file . get_thumbnail ( opts ) <NEWLINE> _thumbnails [ name ] = thumb . url <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> if filer_settings . FILER_ENABLE_LOGGING : <NEWLINE> <INDENT> logger . error ( <STRING> , e ) <NEWLINE> <DEDENT> if filer_settings . FILER_DEBUG : <NEWLINE> <INDENT> raise e <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return _thumbnails <NEWLINE> <DEDENT>
def AutoReload ( self , event ) : <NEWLINE> <INDENT> reload = os . listdir ( Variables . playonlinux_rep + <STRING> ) <NEWLINE> if ( reload != self . oldreload ) : <NEWLINE> self . Reload ( self ) <NEWLINE> self . oldreload = reload <NEWLINE> reloadimg = os . listdir ( Variables . playonlinux_rep + <STRING> ) <NEWLINE> if ( reloadimg != self . oldimg ) : <NEWLINE> self . Reload ( self ) <NEWLINE> self . oldimg = reloadimg <NEWLINE> <DEDENT>
def get_ijv ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> from cellprofiler . utilities . hdf5_dict import HDF5ObjectSet <NEWLINE> sparse = self . __segmented . get_sparse ( ) <NEWLINE> return np . column_stack ( <NEWLINE> <INDENT> [ sparse [ axis ] for axis in <NEWLINE> <INDENT> HDF5ObjectSet . AXIS_Y , HDF5ObjectSet . AXIS_X , <NEWLINE> HDF5ObjectSet . AXIS_LABELS ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
( <STRING> , <NEWLINE> print ( <STRING> . format ( l , err , acc ) ) <NEWLINE> <DEDENT> <DEDENT>
def nnz_obs_names ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> nz_names = [ ] <NEWLINE> for w , n in zip ( self . observation_data . weight , <NEWLINE> <INDENT> self . observation_data . obsnme ) : <NEWLINE> if w > 0.0 : <NEWLINE> nz_names . append ( n ) <NEWLINE> <DEDENT> return nz_names <NEWLINE> <DEDENT>
class MyApplication ( Gtk . Application ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> Gtk . Application . __init__ ( self ) <NEWLINE> def do_activate ( self ) : <NEWLINE> try : <NEWLINE> <INDENT> win = MyWindow ( self ) <NEWLINE> if not win . failed : <NEWLINE> <DEDENT> win . show_all ( ) <NEWLINE> except : <NEWLINE> <INDENT> traceback . print_exc ( ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> else : <NEWLINE> if win . failed : <NEWLINE> <DEDENT> sys . exit ( 1 ) <NEWLINE> def do_startup ( self ) : <NEWLINE> <INDENT> Gtk . Application . do_startup ( self ) <NEWLINE> <DEDENT> <DEDENT>
def dependency_loop ( loops , t , target ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if t . sname == target : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if not target in loops : <NEWLINE> <INDENT> loops [ target ] = set ( ) <NEWLINE> <DEDENT> if not t . sname in loops [ target ] <NEWLINE> <INDENT> loops [ target ] . add ( t . sname ) <NEWLINE> <DEDENT> <DEDENT>
def saveConnections ( self ) : <NEWLINE> <INDENT> self . connections . extend ( self . tempconnections ) <NEWLINE> <INDENT> self . tempconnections = [ ] <NEWLINE> def discardChanges ( self ) : <NEWLINE> <DEDENT> self . tempconnections = [ ] <NEWLINE> <DEDENT>
def test_bad_argument ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> zen . generating . barabasi_albert ( 10 , 3 , blah = 10 ) <NEWLINE> self . fail ( <STRING> ) <NEWLINE> <DEDENT> except zen . ZenException , e : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
class ApiError ( Exception ) : <NEWLINE> <INDENT> def __init__ ( self , method , route , status_code , server_message ) : <NEWLINE> <INDENT> message = <STRING> . format ( ** locals ( ) <NEWLINE> super ( ApiError , self ) . __init__ ( message ) <NEWLINE> <DEDENT> <DEDENT>
def putline ( self , line ) : <NEWLINE> <INDENT> line = line + CRLF <NEWLINE> if self . debugging > 1 : print <STRING> , self . sanitize ( line ) <NEWLINE> self . sock . sendall ( line ) <NEWLINE> <DEDENT>
def __init__ ( self , ( sizeX , sizeY ) , kmlFile , cacheUrl , zoomlevel ) : <NEWLINE> <INDENT> TileLoader . __init__ ( self , ( sizeX , sizeY ) , cacheUrl ) <NEWLINE> self . zoomLevel = zoomlevel <NEWLINE> self . kmlFile = kmlFile <NEWLINE> self . kmlPoints = { } <NEWLINE> self . kmlShapes = { } <NEWLINE> self . initKML ( ) <NEWLINE> <DEDENT>
try : <NEWLINE> <INDENT> from socket import AF_INET6 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> AF_INET6 = None <NEWLINE> <DEDENT> from pysnmp_tornado . carrier . tornado . dgram . base import DgramSocketTransport import DgramSocketTransport <NEWLINE> domainName = snmpUDP6Domain = ( 1 , 3 , 6 , 1 , 2 , 1 , 100 , 1 , 2 ) <NEWLINE>
def printMe ( self ) : <NEWLINE> <INDENT> for cell in self . cell_list : <NEWLINE> cell . printMe ( ) <NEWLINE> <DEDENT>
def __init__ ( self , session ) : <NEWLINE> <INDENT> Screen . __init__ ( self , session ) <NEWLINE> self . skinName = <STRING> <NEWLINE> <INDENT> title = <STRING> <NEWLINE> self . setTitle ( title ) <NEWLINE> self [ <STRING> ] = MenuList ( [ ] ) <NEWLINE> <DEDENT> self [ <STRING> ] = Label ( ) <NEWLINE> <INDENT> self [ <STRING> ] = ActionMap ( [ <STRING> ] , { <STRING> : self . okClicked , <STRING> : self . close } , - 1 ) <NEWLINE> txt = _ ( <STRING> ) <NEWLINE> self [ <STRING> ] . setText ( txt ) <NEWLINE> self . onShown . append ( self . startSession ) <NEWLINE> <DEDENT> <DEDENT>
def test_emulate_secs_left_unknown ( self ) : <NEWLINE> <INDENT> with mock . patch ( <STRING> , <NEWLINE> <INDENT> return_value = ( 0 , 0 , 0 , - 1 ) ) as m : <NEWLINE> self . assertEqual ( psutil . sensors_battery ( ) . secsleft , <NEWLINE> <INDENT> psutil . POWER_TIME_UNKNOWN ) <NEWLINE> assert m . called <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def process_token ( t ) : <NEWLINE> <INDENT> with open ( t , <STRING> ) as fin : <NEWLINE> <INDENT> for line in fin : <NEWLINE> <INDENT> tokens = line . split ( ) <NEWLINE> for token in tokens : <NEWLINE> <INDENT> parts = token . split ( <STRING> ) <NEWLINE> word = <STRING> . join ( parts [ : - 1 ] ) <NEWLINE> pos = parts [ - 1 ] <NEWLINE> print ( <STRING> % ( word , pos ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class DvdPlayer ( object ) : <NEWLINE> <INDENT> def on ( self ) : print <STRING> <NEWLINE> def off ( self ) : print <STRING> <NEWLINE> def play ( self ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
def event_kicked ( bot , ( presence , room , nick , actor , reason ) ) : <NEWLINE> <INDENT> actor = actor and <STRING> % ( actor ) or <STRING> <NEWLINE> reason = reason and <STRING> % ( reason ) or <STRING> <NEWLINE> bot . writelog ( room + <STRING> , <STRING> % ( nick , actor , reason ) ) <NEWLINE> <STRING> <NEWLINE> <DEDENT>
from ete_dev import Tree <NEWLINE> t = Tree ( <STRING> , format = 1 ) <NEWLINE> print ( t . write ( format = 100 ) ) ) <NEWLINE> t . write ( format = 100 , outfile = <STRING> ) <NEWLINE>
def test_argument_order ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> exec <STRING> <NEWLINE> self . fail ( <STRING> ) <NEWLINE> <DEDENT> except SyntaxError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
def loadPendingSubs ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if os . path . isfile ( self . filename ) : <NEWLINE> <INDENT> subfile = open ( self . filename ) <NEWLINE> while True : <NEWLINE> line = subfile . readline ( ) <NEWLINE> if not line : <NEWLINE> break <NEWLINE> parts = line . split ( <STRING> ) <NEWLINE> self . subpending . append ( [ parts [ 0 ] , int ( parts [ 1 ] ) , int ( parts [ 2 ] ) ] ) <NEWLINE> subfile . close ( ) <NEWLINE> <DEDENT> <DEDENT>
def test_skip_no_such_backend ( self ) : <NEWLINE> <INDENT> class FakeDatabaseOpportunisticFixture ( <NEWLINE> <INDENT> test_fixtures . OpportunisticDbFixture ) : <NEWLINE> DRIVER = <STRING> <NEWLINE> <DEDENT> class SomeTest ( test_fixtures . OpportunisticDBTestMixin , <NEWLINE> <INDENT> oslo_test_base . BaseTestCase ) : <NEWLINE> FIXTURE = FakeDatabaseOpportunisticFixture <NEWLINE> def runTest ( self ) : <NEWLINE> pass <NEWLINE> <DEDENT> st = SomeTest ( ) <NEWLINE> ex = self . assertRaises ( <NEWLINE> <INDENT> self . skipException , <NEWLINE> st . setUp <NEWLINE> <DEDENT> ) <NEWLINE> self . assertEqual ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> str ( ex ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def check_version ( self ) : <NEWLINE> <INDENT> if not self . available : <NEWLINE> <INDENT> raise FFmpegPostProcessorError ( <STRING> ) <NEWLINE> <DEDENT> required_version = <STRING> if self . basename == <STRING> else <STRING> <NEWLINE> if is_outdated_version ( <NEWLINE> <INDENT> self . _versions [ self . basename ] , required_version ) : <NEWLINE> warning = <STRING> % ( <NEWLINE> self . basename , self . basename , required_version ) <NEWLINE> if self . _downloader : <NEWLINE> self . _downloader . report_warning ( warning ) <NEWLINE> <DEDENT> <DEDENT>
import os <NEWLINE> virtenv = os . environ [ <STRING> ] + <STRING> <NEWLINE> virtualenv = os . path . join ( virtenv , <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> execfile ( virtualenv , dict ( __file__ = virtualenv ) ) ) <NEWLINE> <DEDENT> except IOError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
def mkcert_selfsigned ( id_xmpp , webid ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> req , pk = mkreq_client ( id_xmpp , webid ) <NEWLINE> cert = mkcert_defaults ( req ) <NEWLINE> ext = X509 . new_extension ( <STRING> , <STRING> % ( webid , ID_ON_XMPPADDR_OID , id_xmpp ) ) <NEWLINE> ext . set_critical ( 0 ) <NEWLINE> cert . add_ext ( ext ) <NEWLINE> cert . sign ( pk , <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> if DEBUG : <NEWLINE> <INDENT> print cert . as_pem ( ) <NEWLINE> <DEDENT> return cert , pk <NEWLINE> <DEDENT>
def home ( ) : <NEWLINE> <INDENT> if current_user . is_authenticated : <NEWLINE> <INDENT> return redirect ( url_for ( <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> return redirect ( url_for ( <STRING> ) ) <NEWLINE> <DEDENT>
def check_tree ( t ) : <NEWLINE> <INDENT> for node in t . traverse ( ) : <NEWLINE> <INDENT> if node . name == <STRING> : <NEWLINE> <INDENT> print ( node . name , node . dist ) <NEWLINE> if node . name == <STRING> : <NEWLINE> print ( node . name , node . dist ) <NEWLINE> if node . name == <STRING> : <NEWLINE> print ( node . name , node . dist ) <NEWLINE> if <STRING> in node . name : <NEWLINE> print ( node . name , node . dist ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def module_detail ( request , group_id , _id ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> group_id = ObjectId ( group_id ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> group_name , group_id = get_group_name_id ( group_id ) <NEWLINE> <DEDENT> course_node = node_collection . one ( { <STRING> : ObjectId ( _id ) } ) <NEWLINE> if course_node . _type == <STRING> : <NEWLINE> return module ( request , group_id , _id ) <NEWLINE> return render_to_response ( <STRING> , <NEWLINE> <INDENT> { <STRING> : course_node , <NEWLINE> <INDENT> <STRING> : app . _id , <NEWLINE> <STRING> : group_id , <NEWLINE> <STRING> : group_id <NEWLINE> <DEDENT> } , <NEWLINE> context_instance = RequestContext ( request ) <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT>
def test ( ) : <NEWLINE> <INDENT> g = Generator ( pi , ( ) ) <NEWLINE> g . kill ( ) <NEWLINE> g = Generator ( pi , ( ) ) <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> print g . get ( ) , <NEWLINE> <DEDENT> print <NEWLINE> h = g . clone ( ) <NEWLINE> g . kill ( ) <NEWLINE> while 1 : <NEWLINE> <INDENT> print ( h . get ( ) , ) <NEWLINE> sys . stdout . flush ( ) <NEWLINE> <DEDENT> <DEDENT>
def run ( self ) : <NEWLINE> <INDENT> if not self . distribution . dist_files : <NEWLINE> <INDENT> raise DistutilsOptionError ( <STRING> ) <NEWLINE> <DEDENT> for command , pyversion , filename in self . distribution . dist_files <NEWLINE> <INDENT> self . upload_file ( command , pyversion , filename ) <NEWLINE> <DEDENT> <DEDENT>
class VelocityVerletOnGroupLocal ( MDIntegratorLocal , integrator_VelocityVerletOnGroup ) : <NEWLINE> <INDENT> def __init__ ( self , system , group ) : <NEWLINE> if not ( pmi . _PMIComm and pmi . _PMIComm . isActive ( ) ) or pmi . _MPIcomm . rank in pmi . _PMIComm . getMPIcpugroup ( ) : <NEWLINE> <INDENT> cxxinit ( self , integrator_VelocityVerletOnGroup , system , group ) <NEWLINE> <DEDENT> <DEDENT>
def LoadAndVerifyJson ( raw , verify_fn ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> data = LoadJson ( raw ) <NEWLINE> <DEDENT> except Exception , err : <NEWLINE> <INDENT> raise errors . ParseError ( <STRING> % err ) <NEWLINE> <DEDENT> if not verify_fn ( data ) : <NEWLINE> <INDENT> raise errors . ParseError ( <STRING> % <NEWLINE> <INDENT> verify_fn ) <NEWLINE> <DEDENT> <DEDENT> return data <NEWLINE> <DEDENT>
def handle_file_complete ( self , old_field_name , counters ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for i , handler in enumerate ( self . _upload_handlers ) : <NEWLINE> <INDENT> file_obj = handler . file_complete ( counters [ i ] ) <NEWLINE> if file_obj : <NEWLINE> <INDENT> self . _files . appendlist ( force_unicode ( old_field_name , <NEWLINE> <INDENT> self . _encoding , <NEWLINE> errors = <STRING> ) <NEWLINE> file_obj ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_checkout ( _client , _repo , _local_test_dir ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> _client . checkout ( _repo , _local_test_dir ) <NEWLINE> <DEDENT> except pysvn . _pysvn . ClientError , error : <NEWLINE> <INDENT> print ( error ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
def test_terminate_connection_no_decorator ( self , utils_mock ) : <NEWLINE> <INDENT> utils_mock . return_value = True <NEWLINE> with mock . patch . object ( fc_zone_manager . ZoneManager , <NEWLINE> <INDENT> <STRING> ) as remove_zone_mock : <NEWLINE> with mock . patch . object ( conf . Configuration , <STRING> ) as mock_safe_get : <NEWLINE> mock_safe_get . return_value = <STRING> <NEWLINE> self . driver . no_zone_terminate_connection ( None , None ) <NEWLINE> remove_zone_mock . assert_not_called ( ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> input = HEADERFILES <NEWLINE> output = SHORT + <STRING> <NEWLINE> defsoutput = TOOLBOXDIR + LONG + <STRING> <NEWLINE> scanner = MyScanner ( input , output , defsoutput ) <NEWLINE> scanner . scan ( ) <NEWLINE> scanner . close ( ) <NEWLINE> scanner . gentypetest ( SHORT + <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> execfile ( defsoutput , { } , { } ) <NEWLINE> print ( <STRING> ) <NEWLINE> exec <STRING> + SHORT + <STRING> <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
plt . savefig ( fileref + str ( graphprogram ) + str ( tag ) + <STRING> , dpi = 300 ) ) <NEWLINE>
class Ufunc ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , nin , nout , identity , docstring , <NEWLINE> <INDENT> * type_descriptions ) : <NEWLINE> self . nin = nin <NEWLINE> self . nout = nout <NEWLINE> if identity is None : <NEWLINE> identity = None_ <NEWLINE> self . identity = identity <NEWLINE> self . docstring = docstring <NEWLINE> self . type_descriptions = [ ] <NEWLINE> for td in type_descriptions : <NEWLINE> self . type_descriptions . extend ( td ) <NEWLINE> for td in self . type_descriptions : <NEWLINE> td . finish_signature ( self . nin , self . nout ) <NEWLINE> <DEDENT> <DEDENT>
def setUp ( self ) : <NEWLINE> <INDENT> Database ( ) . clean ( ) <NEWLINE> <INDENT> self . b = Backport ( ) <NEWLINE> self . b . pkg = <STRING> <NEWLINE> self . b . dist = <STRING> <NEWLINE> <DEDENT> <DEDENT>
def setup_app ( name , config = <STRING> ) : <NEWLINE> <INDENT> app = Flask ( name ) <NEWLINE> app . config [ <STRING> ] = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : 27017 <NEWLINE> <DEDENT> <DEDENT>
def test_token_no_data ( self ) : <NEWLINE> <INDENT> with self . settings ( SOCIAL_AUTH_FACEBOOK_SECRET = <STRING> ) : <NEWLINE> <INDENT> with mock . patch ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> [ <STRING> ] ) : <NEWLINE> with httmock . HTTMock ( facebook_me_mock ) : <NEWLINE> response = self . client . post ( self . token_url , <NEWLINE> <INDENT> token = self . user_token ) <NEWLINE> <DEDENT> self . assertEqual ( response . status_code , status . HTTP_400_BAD_REQUEST ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def retranslateUi ( self , HgNewProjectOptionsDialog ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> HgNewProjectOptionsDialog . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> HgNewProjectOptionsDialog . setWhatsThis ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def connectionMade ( self , instance ) : <NEWLINE> <INDENT> self . instance = instance <NEWLINE> if pipeline_debug : print <STRING> % str ( instance . peer ) <NEWLINE> while self . anyQueries ( ) : <NEWLINE> <INDENT> self . instance . sendQuery ( ) <NEWLINE> <DEDENT> <DEDENT>
def _checkcrc ( self ) : <NEWLINE> <INDENT> filecrc = struct . unpack ( <STRING> , self . ifp . read ( 2 ) ) [ 0 ] & 0xffff <NEWLINE> self . crc = self . crc & 0xffff <NEWLINE> if filecrc != self . crc : <NEWLINE> <INDENT> raise Error , <STRING> % ( self . crc , filecrc ) <NEWLINE> <DEDENT> self . crc = 0 <NEWLINE> <DEDENT>
class SSHCommandResult ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( <NEWLINE> <INDENT> self , stdout = None , stderr = None , return_code = 0 , output_format = None ) : <NEWLINE> self . stdout = stdout <NEWLINE> self . stderr = stderr <NEWLINE> self . return_code = return_code <NEWLINE> self . output_format = output_format <NEWLINE> if output_format and self . return_code == 0 : <NEWLINE> if output_format == <STRING> : <NEWLINE> <INDENT> self . stdout = hammer . parse_csv ( stdout ) if stdout else { } <NEWLINE> <DEDENT> if output_format == <STRING> : <NEWLINE> <INDENT> self . stdout = json . loads ( stdout ) if stdout else None <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def breathe ( color ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> millis = int ( round ( time . time ( ) * 1000 ) ) <NEWLINE> brightness = ( math . exp ( math . sin ( millis / 2000.0 * math . pi ) ) - 0.36787944 ) * 108.0 ; <NEWLINE> for i in range ( 0 , numPixels ) : <NEWLINE> <INDENT> strip . setPixelColor ( i , scale ( color , brightness ) ) <NEWLINE> <DEDENT> strip . show ( ) <NEWLINE> <INDENT> time . sleep ( 0.02 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def sniff ( self , sample , delimiters = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> quotechar , doublequote , delimiter , skipinitialspace = self . _guess_quote_and_delimiter ( sample , delimiters ) <NEWLINE> if not delimiter : <NEWLINE> <INDENT> delimiter , skipinitialspace = self . _guess_delimiter ( sample , <NEWLINE> <INDENT> delimiters ) <NEWLINE> <DEDENT> <DEDENT> if not delimiter : <NEWLINE> <INDENT> raise Error , <STRING> <NEWLINE> <DEDENT> class dialect ( Dialect ) : <NEWLINE> <INDENT> _name = <STRING> <NEWLINE> lineterminator = <STRING> <NEWLINE> quoting = QUOTE_MINIMAL <NEWLINE> <DEDENT> dialect . doublequote = doublequote <NEWLINE> dialect . delimiter = delimiter <NEWLINE> dialect . quotechar = quotechar or <STRING> <NEWLINE> dialect . skipinitialspace = skipinitialspace <NEWLINE> return dialect <NEWLINE> <DEDENT>
def performable_embed ( hostname , page_id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return mark_safe ( EMBED_CODE % { <NEWLINE> <INDENT> <STRING> : hostname , <NEWLINE> <STRING> : page_id , <NEWLINE> , <NEWLINE> <DEDENT> } ) <NEWLINE> <DEDENT>
from visualape import INCLUDE_JAVASCRIPT , INCLUDE_P5 <NEWLINE> print ( INCLUDE_P5 ) <NEWLINE> print ( INCLUDE_JAVASCRIPT . format ( <STRING> ) <NEWLINE> print ( INCLUDE_JAVASCRIPT . format ( <STRING> ) ) <NEWLINE> print ( INCLUDE_JAVASCRIPT . format ( <STRING> ) ) <NEWLINE>
def maskToString ( self num_of_bits = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> t_str , k = <STRING> , 0 <NEWLINE> num = self . funmask <NEWLINE> while num > 0 : <NEWLINE> <INDENT> if num & 1 == 1 : <NEWLINE> <INDENT> t_str = t_str + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t_str = t_str + <STRING> <NEWLINE> <DEDENT> num >>= 1 <NEWLINE> k += 1 <NEWLINE> <DEDENT> if num_of_bits != None and num_of_bits > k : <NEWLINE> <INDENT> t_str += <STRING> * ( num_of_bits - k ) <NEWLINE> <DEDENT> return t_str <NEWLINE> <DEDENT>
def __init__ ( self , * args , ** kwargs ) : <NEWLINE> <INDENT> if wx . GetApp ( ) is None : <NEWLINE> <INDENT> self . app = wx . App ( False ) <NEWLINE> <DEDENT> self . args = False <NEWLINE> if kwargs . has_key ( <STRING> ) : <NEWLINE> <INDENT> self . args = kwargs [ <STRING> ] <NEWLINE> del kwargs [ <STRING> ] <NEWLINE> dotfile = None <NEWLINE> <DEDENT> if <STRING> in kwargs : <NEWLINE> dotfile = kwargs [ <STRING> ] <NEWLINE> del kwargs [ <STRING> ] <NEWLINE> OptionParser . __init__ ( self , * args , ** kwargs ) <NEWLINE> self . dotfile = self . find_dotfile ( dotfile ) <NEWLINE> <DEDENT>
def get_mathjax_header ( https = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if CFG_MATHJAX_HOSTING . lower ( ) == <STRING> : <NEWLINE> <INDENT> if https : <NEWLINE> <INDENT> mathjax_path = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mathjax_path = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> mathjax_path = <STRING> <NEWLINE> <DEDENT> return <STRING> % { <NEWLINE> <STRING> : mathjax_path <NEWLINE> <DEDENT>
def __init__ ( self , publisher , source_id , app_id = <STRING> ) : <NEWLINE> <INDENT> self . API_URL = <STRING> <NEWLINE> self . NS = Namespace ( <STRING> ) <NEWLINE> self . DC = Namespace ( <STRING> ) <NEWLINE> <INDENT> self . http = httplib2 . Http ( ) <NEWLINE> self . publisher = publisher <NEWLINE> self . app_id = app_id <NEWLINE> self . source_id = source_id <NEWLINE> self . last_change = 0 <NEWLINE> <DEDENT> <DEDENT>
def rename_models ( cr , model_spec ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for ( old , new ) in model_spec : <NEWLINE> <INDENT> logger . info ( <STRING> <NEWLINE> <INDENT> old , new ) <NEWLINE> <DEDENT> cr . execute ( <STRING> <NEWLINE> <INDENT> <STRING> , ( new , old , ) ) <NEWLINE> <DEDENT> cr . execute ( <STRING> <NEWLINE> <INDENT> <STRING> , ( new , old , ) ) <NEWLINE> <DEDENT> cr . execute ( <STRING> <NEWLINE> <INDENT> <STRING> , ( new , old , ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def load_embeddings ( file_name ) : <NEWLINE> <INDENT> with codecs . open ( file_name , <STRING> , <STRING> ) as f_in : <NEWLINE> <INDENT> vocabulary , wv = zip ( * [ line . strip ( ) . split ( <STRING> , 1 ) for line in <NEWLINE> <DEDENT> <DEDENT>
def save ( universe ) : <NEWLINE> <INDENT> stamp = re . sub ( <STRING> , <STRING> , str ( datetime . datetime . now ( ) ) ) [ : - 7 ] <NEWLINE> f = codecs . open ( <STRING> . format ( stamp ) , <STRING> , encoding = <STRING> ) <NEWLINE> fn = codecs . open ( <STRING> , <STRING> , encoding = <STRING> ) <NEWLINE> nx . write_graphml ( universe , f ) <NEWLINE> nx . write_graphml ( universe , fn ) <NEWLINE> print ( <STRING> . format ( f ) <NEWLINE> <DEDENT>
def get_secret_by_name ( name , lsakey ) : <NEWLINE> <INDENT> global xp <NEWLINE> r = regkey ( <STRING> % name ) <NEWLINE> if not r . is_present ( ) : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> enc_secret = r . get_value ( <STRING> ) <NEWLINE> if xp : <NEWLINE> encryptedSecretSize = unpack ( <STRING> , enc_secret [ : 4 ] ) [ 0 ] <NEWLINE> offset = len ( enc_secret ) - encryptedSecretSize <NEWLINE> secret = decrypt_secret ( enc_secret [ offset : ] , lsakey ) <NEWLINE> return decrypt_secret ( enc_secret [ 0xC : ] , lsakey ) <NEWLINE> else : <NEWLINE> return decrypt_lsa2 ( enc_secret , lsakey ) <NEWLINE> <DEDENT>
def remove_label ( self , to_remove ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if to_remove not in self . labels : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> labels = self . labels <NEWLINE> labels . remove ( to_remove ) <NEWLINE> with codecs . open ( os . path . join ( self . path , self . LABEL_FILE ) , <STRING> , <NEWLINE> <INDENT> encoding = <STRING> ) as file_desc : <NEWLINE> for label in labels : <NEWLINE> file_desc . write ( <STRING> % ( label . name , <NEWLINE> <INDENT> label . get_color_str ( ) ) ) <NEWLINE> <DEDENT> <DEDENT> self . drop_cache ( ) <NEWLINE> <DEDENT>
def doBackup ( self ) : <NEWLINE> <INDENT> self . getLocalDirectoryList ( ) <NEWLINE> <INDENT> self . getRemoteDirectoryList ( ) <NEWLINE> <DEDENT> f = open ( PATH + <STRING> , <STRING> ) <NEWLINE> <INDENT> directories = f . read ( ) . split ( <STRING> ) <NEWLINE> <DEDENT> del directories [ 0 : 2 ] <NEWLINE> <INDENT> f . close ( ) <NEWLINE> for dir in directories : <NEWLINE> self . syncDirectory ( dir ) <NEWLINE> <DEDENT> <DEDENT>
import smbus <NEWLINE> import time <NEWLINE> from ctypes import c_short <NEWLINE> DEVICE = 0x77 uses 0 <NEWLINE> bus = smbus . SMBus ( 1 ) <NEWLINE>
class Ui_MainWindow ( object ) : <NEWLINE> <INDENT> def setupUi ( self , MainWindow ) : <NEWLINE> <INDENT> MainWindow . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> MainWindow . resize ( 804 , 628 ) <NEWLINE> MainWindow . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
def _checkpath ( self , path ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if not util . ioretry ( lambda : util . pathexists ( path ) ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT> except util . CommandException , inst : <NEWLINE> <INDENT> raise xs_errors . XenError ( <STRING> , opterr = <STRING> % path ) <NEWLINE> <DEDENT> <DEDENT>
def prog_grab ( code ) : <NEWLINE> <INDENT> kod = code . lower ( ) <NEWLINE> req = urllib2 . Request ( <STRING> + kod ) <NEWLINE> r = urllib2 . urlopen ( req ) <NEWLINE> radky = r . readlines ( ) <NEWLINE> <INDENT> program = <STRING> <NEWLINE> <DEDENT> for x in radky : <NEWLINE> <INDENT> if x . find ( <STRING> ) != - 1 : <NEWLINE> <INDENT> if re . search ( <STRING> , x ) : <NEWLINE> <INDENT> program += <STRING> + re . sub ( <STRING> , <STRING> , x ) . replace ( <STRING> , <STRING> ) <NEWLINE> <INDENT> return program <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def KeypadCallback ( self , data ) : <NEWLINE> <INDENT> if data == ( 0 , 0 , 0 , 0 , , 0 , 0 , 0 , 0 ) : <NEWLINE> <INDENT> self . EndLastEvent ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . TriggerEnduringEvent ( KEYPAD_CODES [ data ] ) <NEWLINE> <DEDENT> <DEDENT>
def hypernym_distances ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> retval = dict ( ) <NEWLINE> for ( synset , dist ) in reduce ( <NEWLINE> <INDENT> set . union , <NEWLINE> [ [ ( synset , idx ) for ( idx , synset ) in enumerate ( reversed ( path ) ) ] <NEWLINE> <INDENT> for path in self . hypernym_paths ] , <NEWLINE> <DEDENT> set ( ) ) : <NEWLINE> if synset not in retval or dist < retval [ synset ] : <NEWLINE> retval [ synset ] = dist <NEWLINE> <DEDENT> return set ( retval . items ( ) ) <NEWLINE> <DEDENT>
def start ( self ) : <NEWLINE> <INDENT> for g , f in dict ( gen = <STRING> , gentcp = <STRING> , genmcast = <STRING> ) . items ( ) : <NEWLINE> <INDENT> exec <STRING> % ( g , g , f , g ) <NEWLINE> <DEDENT> return self <NEWLINE> <DEDENT>
import distutils <NEWLINE> from distutils . core import setup , Extension <NEWLINE> import distutils . dep_util <NEWLINE> import os , string <NEWLINE> def fortran_extension ( module_name , c_files , fortran_files , library_dirs , <NEWLINE> <INDENT> libraries ) : <NEWLINE> fcompiler = f90_compiler ( ) <NEWLINE> library_name = module_name + <STRING> <NEWLINE> fcompiler . build_library ( library_name , fortran_files ) <NEWLINE> libraries . append ( library_name ) <NEWLINE> ext = Extension ( module_name , c_files , <NEWLINE> <INDENT> library_dirs = library_dirs_list , <NEWLINE> libraries = libraries_list ) <NEWLINE> return ext <NEWLINE> <DEDENT> <DEDENT>
def get_encryption ( cell ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> enc = <STRING> <NEWLINE> if matching_line ( cell , <STRING> ) == <STRING> : <NEWLINE> <INDENT> enc = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for line in cell : <NEWLINE> <INDENT> matching = match ( line , <STRING> ) <NEWLINE> if matching is not None : <NEWLINE> <DEDENT> <DEDENT> wpa = re . search ( <STRING> , matching ) <NEWLINE> <INDENT> if wpa is not None : <NEWLINE> <INDENT> enc = wpa . group ( 0 ) <NEWLINE> if enc == <STRING> : <NEWLINE> enc = <STRING> <NEWLINE> <DEDENT> <DEDENT> return enc <NEWLINE> <DEDENT>
def get_fs_type ( self , drive_num ) : <NEWLINE> <INDENT> volume = self . get_device_with_udi ( drive_num ) <NEWLINE> <INDENT> return volume . GetProperty ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def uisetup ( ui ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> entry = extensions . wrapcommand ( commands . table , <STRING> , pullrebase ) <NEWLINE> entry [ 1 ] . append ( ( <STRING> , <STRING> , None , <NEWLINE> <INDENT> _ ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT>
def write_heading ( self , heading ) : <NEWLINE> <INDENT> print ( <STRING> % { <NEWLINE> <INDENT> <STRING> : heading . m_level , <NEWLINE> <STRING> : heading . m_text } <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import os <NEWLINE> from django . core . wsgi import get_wsgi_application <NEWLINE> from dj static import Cling <NEWLINE> os . environ . setdefault ( <STRING> , <STRING> ) <NEWLINE> application = Cling ( get_wsgi_application ( ) ) <NEWLINE>
def _select_pattern ( self , event ) : <NEWLINE> <INDENT> for pattern in self . _context . hook_client_patterns_list ( <NEWLINE> <INDENT> patterns . patterns_list ) : <NEWLINE> if pattern . accept_answer ( event ) : <NEWLINE> return pattern <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>
def when_i_fill_in_the_new_values_for_the_indicator ( step ) : <NEWLINE> <INDENT> world . form_data = { <STRING> : world . survey . id , <NEWLINE> <INDENT> <STRING> : world . batch_1 . id , <NEWLINE> , <NEWLINE> <STRING> : world . indicator_1 . module . id , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> } <NEWLINE> <DEDENT> world . page . fill_valid_values ( world . form_data ) <NEWLINE> <DEDENT>
def run ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> now = time . time ( ) <NEWLINE> for wallet in self . device_manager ( ) . paired_wallets ( ) : <NEWLINE> <INDENT> if ( isinstance ( wallet , self . wallet_class ) <NEWLINE> <INDENT> and hasattr ( wallet , <STRING> ) <NEWLINE> and now > wallet . last_operation + wallet . session_timeout ) : <NEWLINE> client = self . get_client ( wallet , force_pair = False ) <NEWLINE> if client : <NEWLINE> client . clear_session ( ) <NEWLINE> wallet . last_operation = self . prevent_timeout <NEWLINE> wallet . timeout ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def connect ( self , server = <STRING> , port = 6379 db = 6 ) : <NEWLINE> <INDENT> self . redis = redis . Redis ( server , port , db ) <NEWLINE> self . __is_connected__ = True <NEWLINE> <DEDENT>
def scatter ( self , * args , ** properties ) : <NEWLINE> <INDENT> markeredgecolor = properties . pop ( <STRING> , <STRING> ) <NEWLINE> markersize = properties . pop ( <STRING> , 6 ) <NEWLINE> _properties = { <STRING> : <STRING> , <STRING> : markersize , <STRING> : 0 , <NEWLINE> <INDENT> <STRING> : <STRING> , <STRING> : markeredgecolor , <STRING> : 2 <NEWLINE> } <NEWLINE> _properties . update ( ** properties ) <NEWLINE> self . plot ( * args , ** _properties ) <NEWLINE> <DEDENT> <DEDENT>
def display_image ( window_name , img , reduction = 2 , text = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> reduction = constrain ( reduction , 1.2 , 6 ) <NEWLINE> newx , newy = int ( img . shape [ 1 ] / reduction ) , int ( img . shape [ 0 ] / reduction ) <NEWLINE> newimg = cv2 . resize ( img , ( newx , newy ) ) <NEWLINE> if text != <STRING> : <NEWLINE> display_shadow_text ( newimg , 20 , 25 , text ) <NEWLINE> cv2 . imshow ( window_name , newimg ) <NEWLINE> <DEDENT>
def test_delete_all_ports ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( self . br , <STRING> , <NEWLINE> <INDENT> return_value = [ <STRING> ] ) as get_port : <NEWLINE> with mock . patch . object ( self . br , <STRING> ) as delete_port : <NEWLINE> self . br . delete_ports ( all_ports = True ) <NEWLINE> <DEDENT> get_port . assert_called_once_with ( ) <NEWLINE> delete_port . assert_called_once_with ( <STRING> ) <NEWLINE> <DEDENT>
class _CSMSchemaFieldString ( _CSMSchemaField ) : <NEWLINE> <INDENT> def __init__ ( self , ptr , name = None ) : <NEWLINE> _CSMSchemaField . __init__ ( self , ptr , name ) <NEWLINE> length = libCSM . csm_schema_field_get_string_length ( self . ptr ) <NEWLINE> if length : <NEWLINE> <INDENT> self . length = length <NEWLINE> <DEDENT> <DEDENT>
class ChartsApplication ( WApplication ) : <NEWLINE> <INDENT> def __init__ ( self , env ) : <NEWLINE> <INDENT> WApplication . __init__ ( self , env ) <NEWLINE> <INDENT> self . setTitle ( WString ( <STRING> ) ) ; <NEWLINE> <INDENT> self . setCssTheme ( <STRING> ) ; <NEWLINE> <DEDENT> self . messageResourceBundle ( ) . use ( <STRING> ) ; <NEWLINE> self . root ( ) . setPadding ( WLength ( 10 ) ) ; <NEWLINE> self . root ( ) . resize ( WLength . Auto , WLength . Auto ) ; <NEWLINE> ChartsExample ( self . root ( ) ) ; <NEWLINE> self . useStyleSheet ( WLink ( <STRING> ) ) ; <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_pc ( self , ( n , vcount ) , tag = None ) : <NEWLINE> <INDENT> pc_env = self . get_node_pc_env ( ( n , vcount ) , tag = tag ) <NEWLINE> if pc_env == None : <NEWLINE> <INDENT> trace ( <STRING> % ( ( n , vcount ) , tag ) ) <NEWLINE> return false_term <NEWLINE> <DEDENT> ( pc , env ) = pc_env <NEWLINE> return to_smt_expr ( pc , env , self . solv ) <NEWLINE> <DEDENT>
import sublime <NEWLINE> import json <NEWLINE> st_version = int ( sublime . version ( ) <NEWLINE>
class TestTemplateLoader ( loader . BaseLoader ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> is_usable = True <NEWLINE> def __init__ ( self , templates_dict ) : <NEWLINE> <INDENT> self . templates_dict = templates_dict <NEWLINE> <DEDENT> def load_template_source ( self , template_name , template_dirs = None , <NEWLINE> <INDENT> skip_template = None ) : <NEWLINE> try : <NEWLINE> return ( self . templates_dict [ template_name ] , <NEWLINE> <STRING> % template_name ) <NEWLINE> except KeyError : <NEWLINE> raise TemplateDoesNotExist ( template_name ) <NEWLINE> <DEDENT> <DEDENT>
def setTempo ( self , t ) : <NEWLINE> <INDENT> if ( Config . DEBUG > 3 ) : <NEWLINE> <INDENT> print <STRING> % ( t , 60.0 / ( Config . TICKS_PER_BEAT * t ) ) <NEWLINE> <DEDENT> sc_setTickDuration ( 60.0 / ( Config . TICKS_PER_BEAT * t ) ) <NEWLINE> <DEDENT>
def OnEnter ( self , x , y , d ) : <NEWLINE> <INDENT> if self . debug : <NEWLINE> <INDENT> print <STRING> % ( x , y , d ) <NEWLINE> <DEDENT> return d <NEWLINE> <DEDENT>
class RunLengthAdapter ( Adapter ) : <NEWLINE> <INDENT> def _encode ( self , obj ) : <NEWLINE> <INDENT> return len ( obj ) , obj [ 0 ] <NEWLINE> <DEDENT> def _decode ( self , ( length , value ) ) : <NEWLINE> <INDENT> return [ value ] * length <NEWLINE> <DEDENT> <DEDENT>
gd = GridDescriptor ( N_c , ( a , a , a ) , comm = comm ) ) <NEWLINE>
def test_invalid_metaclass ( self ) : <NEWLINE> <INDENT> module = astroid . parse ( <STRING> ) <NEWLINE> for class_obj , metaclass_name in ( ( <STRING> , <STRING> ) , <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) ) : <NEWLINE> classdef = module [ class_obj ] <NEWLINE> message = Message ( <STRING> , node = classdef , args = ( metaclass_name , ) ) <NEWLINE> with self . assertAddsMessages ( message ) : <NEWLINE> self . checker . visit_classdef ( classdef ) <NEWLINE> <DEDENT> <DEDENT>
def temporal_relation ( self , map ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . is_time_absolute ( ) and map . is_time_absolute ( ) : <NEWLINE> <INDENT> return self . absolute_time . temporal_relation ( map . absolute_time ) <NEWLINE> <INDENT> if self . is_time_relative ( ) and map . is_time_relative ( ) : <NEWLINE> <DEDENT> return self . relative_time . temporal_relation ( map . relative_time ) <NEWLINE> return None <NEWLINE> <DEDENT> <DEDENT>
def get_individual_info ( p_filename , p_info ) : <NEWLINE> <INDENT> info = None <NEWLINE> with open ( p_filename , <STRING> ) as f : <NEWLINE> <INDENT> for line in f : <NEWLINE> columns = line . split ( ) <NEWLINE> <INDENT> if columns [ 0 ] == p_info : <NEWLINE> <INDENT> info = columns [ 2 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return info <NEWLINE> <DEDENT>
def pad ( string , length ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if len ( string ) <= length : <NEWLINE> <INDENT> return string + <STRING> * ( length - len ( string ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return string [ : length - 3 ] + <STRING> <NEWLINE> <DEDENT> <DEDENT>
def test_cannot_see_forms_without_permission ( self ) : <NEWLINE> <INDENT> self . client . login ( username = <STRING> , password = <STRING> ) <NEWLINE> response = self . client . get ( reverse ( <STRING> ) <NEWLINE> self . assertFalse ( self . form_page in response . context [ <STRING> ] ) <NEWLINE> <DEDENT>
def pytest_configure ( config ) : <NEWLINE> <INDENT> from django . conf import settings <NEWLINE> <INDENT> settings . INSTALLED_APPS = filter ( lambda s : s != <STRING> , settings . INSTALLED_APPS ) <NEWLINE> <DEDENT> <DEDENT>
def retranslateUi ( self , dlgAlarmistGreeter ) : <NEWLINE> <INDENT> dlgAlarmistGreeter . setWindowTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . btnMoreoptions . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . btnContinue . setToolTip ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . btnContinue . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . radSpoofYes . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . radSpoofNo . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label_3 . setToolTip ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def render ( self , cur_time ) : <NEWLINE> <INDENT> if cur_time > ( self . last_update <NEWLINE> <INDENT> + datetime . timedelta ( minutes = self . REFRESH_TIME_MINUTES ) ) : <NEWLINE> try : <NEWLINE> self . forecast = forecastio . load_forecast ( self . api_key , <NEWLINE> <INDENT> self . lat , <NEWLINE> self . lon ) <NEWLINE> except : <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> self . last_update = cur_time <NEWLINE> <DEDENT> self . renderForecast ( ) <NEWLINE> <DEDENT>
def simulateTreeConstruction ( self , t ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> self . dbg . createNode ( t ) <NEWLINE> for i in range ( self . adaptor . getChildCount ( t ) ) : <NEWLINE> <INDENT> child = self . adaptor . getChild ( t , i ) <NEWLINE> self . simulateTreeConstruction ( child ) <NEWLINE> self . dbg . addChild ( t , child ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
( QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def is_arbiter_required ( tags = { } , debug = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if debug : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> slave_tags = tags [ <STRING> ] <NEWLINE> for slave in slave_tags : <NEWLINE> <INDENT> if debug : <NEWLINE> <INDENT> print <STRING> + str ( slave ) <NEWLINE> <DEDENT> if ( <STRING> in slave_tags [ slave ] ) : <NEWLINE> <INDENT> if ( len ( slave_tags [ slave ] [ <STRING> ] ) > 0 ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>
def _get_new_ticket_values ( self , req ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> values = { } <NEWLINE> for field in TicketSystem ( self . env ) . get_ticket_fields ( ) : <NEWLINE> <INDENT> name = field [ <STRING> ] <NEWLINE> if name not in ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> ) and field [ <STRING> ] != <STRING> : <NEWLINE> value = req . args . get ( <STRING> + name ) <NEWLINE> if value is not None : <NEWLINE> values [ name ] = self . _parse_field_value ( req , field , value ) <NEWLINE> <DEDENT> <DEDENT> return values <NEWLINE> <DEDENT>
def stop ( self ) : <NEWLINE> <INDENT> def cb ( ) : <NEWLINE> <INDENT> self . parent . back ( ) <NEWLINE> if self . view : <NEWLINE> self . view . hide ( cb ) <NEWLINE> <DEDENT> <DEDENT>
def _print_tagged_ner ( tagged_sents ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for sent in tagged_sents : <NEWLINE> <INDENT> for tok , tag in sent : <NEWLINE> <INDENT> print ( tok [ 0 ] + <STRING> + tag <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
def __get__ ( self , instance , instance_type = None ) : <NEWLINE> <INDENT> if instance is None : <NEWLINE> <INDENT> raise AttributeError , <STRING> % self . related . opts . object_name <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> return getattr ( instance , self . cache_name ) <NEWLINE> <DEDENT> except AttributeError : <NEWLINE> <INDENT> params = { <STRING> % self . related . field . name : instance . _get_pk_val ( ) } <NEWLINE> rel_obj = self . related . model . _default_manager . get ( ** params ) <NEWLINE> setattr ( instance , self . cache_name , rel_obj ) <NEWLINE> return rel_obj <NEWLINE> <DEDENT> <DEDENT>
def control_get_light_cb ( self , control , err , vals ) : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <INDENT> % ( control . get_name ( ) , str ( err ) , vals ) ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT>
def inject_default_directories ( request ) : <NEWLINE> <INDENT> parent_dir = os . path . dirname ( __file__ ) <NEWLINE> orca . add_injectable ( <STRING> , os . path . join ( parent_dir , <STRING> ) ) <NEWLINE> orca . add_injectable ( <STRING> , os . path . join ( parent_dir , <STRING> ) <NEWLINE> orca . add_injectable ( <STRING> , os . path . join ( parent_dir , <STRING> ) ) <NEWLINE> request . addfinalizer ( orca . clear_cache ) <NEWLINE> <DEDENT>
class MyProtocol ( protocol . DatagramProtocol ) : <NEWLINE> <INDENT> def __init__ ( self , expecting ) : <NEWLINE> <INDENT> self . expecting = list ( expecting ) <NEWLINE> <DEDENT> def datagramReceived ( self , data , ( host , port ) ) : <NEWLINE> <INDENT> assert self . expecting , <STRING> <NEWLINE> expectData , expectHost , expectPort = self . expecting . pop ( 0 ) <NEWLINE> assert expectData == data , <STRING> % ( expectData , data ) <NEWLINE> assert expectHost == host , <STRING> % ( expectHost , host ) <NEWLINE> assert expectPort == port , <STRING> % ( expectPort , expectPort , port , port ) <NEWLINE> <DEDENT> <DEDENT>
def checkBookAvailability ( bookTitle ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> url_title = bookiSlugify ( bookTitle [ : 100 ] ) <NEWLINE> if url_title == <STRING> : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> book = models . Book . objects . get ( Q ( title = bookTitle ) | Q ( url_title = url_title ) ) ) <NEWLINE> <DEDENT> except models . Book . DoesNotExist : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
def latinquote ( s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> l = [ ] <NEWLINE> for i in s : <NEWLINE> if ord ( i ) >= 160 : l . append ( <STRING> % ord ( i ) ) <NEWLINE> else : l . append ( i ) <NEWLINE> return string . join ( l , <STRING> ) <NEWLINE> <DEDENT>
class CCGenerator ( object ) : <NEWLINE> <INDENT> def __init__ ( self , type_generator , cpp_namespace ) : <NEWLINE> <INDENT> self . _type_generator = type_generator <NEWLINE> self . _cpp_namespace = cpp_namespace <NEWLINE> <DEDENT> def Generate ( self , namespace ) : <NEWLINE> <INDENT> return _Generator ( namespace <NEWLINE> <INDENT> self . _type_generator , <NEWLINE> self . _cpp_namespace ) . Generate ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class QStrictCustomBus ( QSparseBus ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , bus_item , addr_spec , busid , bus_type = None , aobject = None , <NEWLINE> <INDENT> atype = None , first_port = None ) : <NEWLINE> super ( QStrictCustomBus , self ) . __init__ ( bus_item , addr_spec , busid , <NEWLINE> <INDENT> bus_type , aobject , atype ) <NEWLINE> if first_port : <NEWLINE> self . first_port = first_port <NEWLINE> <DEDENT> <DEDENT> def _update_device_props ( self , device , addr ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . _set_device_props ( device , addr ) <NEWLINE> <DEDENT> <DEDENT>
def rta_uint16 ( self , rta , value = None ) : <NEWLINE> <INDENT> data = RTA_DATA ( rta ) <NEWLINE> if value : <NEWLINE> <INDENT> c_uint16 . from_address ( data ) . value = value <NEWLINE> rta . rta_len = RTA_LENGTH ( sizeof ( c_uint16 ) ) <NEWLINE> return rta . rta_len <NEWLINE> else : <NEWLINE> return c_uint16 . from_address ( data ) . value <NEWLINE> <DEDENT> <DEDENT>
def _init_station_with_retries ( self ) : <NEWLINE> <INDENT> for cnt in xrange ( self . max_tries ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . _init_station ( ) <NEWLINE> return <NEWLINE> <DEDENT> except ( serial . serialutil . SerialException , WeeWxIOError ) , e : <NEWLINE> <INDENT> logerr ( <STRING> % <NEWLINE> <INDENT> ( cnt + 1 , self . max_tries , e ) ) <NEWLINE> <DEDENT> logdbg ( <STRING> % self . retry_wait ) <NEWLINE> time . sleep ( self . retry_wait ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> raise RetriesExceeded ( <STRING> % self . max_tries ) <NEWLINE> <DEDENT> <DEDENT>
def make_illegal_xml_regex ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> re_xml_illegal = <STRING> <NEWLINE> re_xml_illegal += <STRING> <NEWLINE> re_xml_illegal += <STRING> % ( unichr ( 0xd800 ) , unichr ( 0xdbff ) , unichr ( 0xdc00 ) , unichr ( 0xdfff ) <NEWLINE> <INDENT> unichr ( 0xd800 ) , unichr ( 0xdbff ) , unichr ( 0xdc00 ) , unichr ( 0xdfff ) , <NEWLINE> unichr ( 0xd800 ) , unichr ( 0xdbff ) , unichr ( 0xdc00 ) , unichr ( 0xdfff ) ) <NEWLINE> <DEDENT> return re . compile ( re_xml_illegal ) <NEWLINE> <DEDENT>
class NbspValue ( Value ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> self . value = <STRING> <NEWLINE> <DEDENT>
def convert_image_to_ascii ( image , new_width = 100 ) : <NEWLINE> <INDENT> image = scale_image ( image , new_width ) <NEWLINE> image = convert_to_grayscale ( image ) <NEWLINE> pixels_to_chars = map_pixels_to_ascii_chars ( image ) <NEWLINE> len_pixels_to_chars = len ( pixels_to_chars ) <NEWLINE> image_ascii = [ pixels_to_chars [ index index + new_width ] for index in <NEWLINE> <INDENT> xrange ( 0 , len_pixels_to_chars , new_width ) ] <NEWLINE> <DEDENT> return <STRING> . join ( image_ascii ) <NEWLINE> <DEDENT>
class NoRedirectHandler ( urllib2 . HTTPRedirectHandler ) : <NEWLINE> <INDENT> def http_error_302 ( self , req , fp , code , msg , headers ) : <NEWLINE> <INDENT> infourl = urllib . addinfourl ( fp , headers , req . get_full_url ( ) <NEWLINE> infourl . status = code <NEWLINE> infourl . code = code <NEWLINE> return infourl <NEWLINE> <DEDENT> http_error_300 = http_error_302 <NEWLINE> http_error_301 = http_error_302 <NEWLINE> http_error_303 = http_error_302 <NEWLINE> http_error_307 = http_error_302 <NEWLINE> <DEDENT>
def getRequestInfo ( self , url ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> request = requests . get ( self . getServiceURL ( url ) , headers = self . _headers , verify = False ) <NEWLINE> if request . ok : <NEWLINE> <INDENT> return request . json ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> log . logger . error ( <STRING> + url + <STRING> + request . content ) <NEWLINE> raise RequestError ( url + <STRING> + request . content ) <NEWLINE> <DEDENT> <DEDENT> except requests . exceptions . ConnectionError , e : <NEWLINE> <INDENT> raise CServerConnectionError ( ) <NEWLINE> <DEDENT> <DEDENT>
def backup_volume ( self , context , backup , backup_service ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> volume = self . db . volume_get ( context , backup [ <STRING> ] ) <NEWLINE> with RBDVolumeProxy ( self , volume [ <STRING> ] , <NEWLINE> <INDENT> self . configuration . rbd_pool ) as rbd_image : <NEWLINE> rbd_meta = RBDImageMetadata ( rbd_image , self . configuration . rbd_pool , <NEWLINE> <INDENT> self . configuration . rbd_user , <NEWLINE> self . configuration . rbd_ceph_conf ) <NEWLINE> rbd_fd = RBDImageIOWrapper ( rbd_meta ) <NEWLINE> backup_service . backup ( backup , rbd_fd ) <NEWLINE> <DEDENT> <DEDENT> LOG . debug ( <STRING> ) <NEWLINE> <DEDENT>
def _parse_website_config ( self , ( response , xml_bytes ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> root = XML ( xml_bytes ) <NEWLINE> index_suffix = root . findtext ( <STRING> ) <NEWLINE> error_key = root . findtext ( <STRING> ) <NEWLINE> return WebsiteConfiguration ( index_suffix , error_key ) <NEWLINE> <DEDENT>
def save_screenshot_img ( self , input_path , out_path , box ) <NEWLINE> <INDENT> from PIL import Image <NEWLINE> img = Image . open ( input_path ) <NEWLINE> area = img . crop ( box ) <NEWLINE> area . save ( out_path , <STRING> ) <NEWLINE> pass <NEWLINE> <DEDENT>
def getFilename ( url ) : <NEWLINE> <INDENT> truncatedUrl = url . replace ( siteBase , <STRING> ) <NEWLINE> if truncatedUrl : <NEWLINE> return dirlocation + truncatedUrl <NEWLINE> else : <NEWLINE> return dirlocation + <STRING> <NEWLINE> <DEDENT>
class Condition public : <NEWLINE> <INDENT> Condition ( ) { <NEWLINE> virtual ~ Condition ( ) { <NEWLINE> virtual bool check ( Flow * f ) = 0 <NEWLINE> virtual std . string to_string ( ) = 0 <NEWLINE> <DEDENT>
def stochpick ( elems , prop_func = ( lambda x : x ) , sum = 0 ) : <NEWLINE> <INDENT> if sum == 0 : sum = general_sum ( elems , prop_func ) <NEWLINE> randnum = random . uniform ( 0 , sum ) <NEWLINE> running_sum = 0 <NEWLINE> for elem in elems : <NEWLINE> running_sum += prop_func ( elem ) <NEWLINE> if running_sum >= randnum : return elem <NEWLINE> <DEDENT>
def dump ( self ) : <NEWLINE> <INDENT> for i in range ( self . NO_ROWS ) : <NEWLINE> <INDENT> print ( <STRING> % i , <NEWLINE> if self . arr [ i ] == None : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( self . NO_COLS ) : <NEWLINE> <INDENT> print ( self . arr [ i ] [ j ] , ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def openAddonSettings ( addonId , id1 = None , id2 = None ) : <NEWLINE> <INDENT> xbmc . executebuiltin ( <STRING> % addonId ) <NEWLINE> if id1 != None : <NEWLINE> <INDENT> xbmc . executebuiltin ( <STRING> % ( id1 + 200 ) ) <NEWLINE> <DEDENT> if id2 != None : <NEWLINE> <INDENT> xbmc . executebuiltin ( <STRING> % ( id2 + 100 ) ) ) <NEWLINE> <DEDENT> <DEDENT>
class JyDTDHandlerWrapper ( javasax . DTDHandler ) : <NEWLINE> <INDENT> def __init__ ( self , dtdHandler ) : <NEWLINE> self . _handler = dtdHandler <NEWLINE> def notationDecl ( self , name , publicId , systemId ) : <NEWLINE> self . _handler . notationDecl ( name , publicId , systemId ) <NEWLINE> def unparsedEntityDecl ( self , name , publicId , systemId , notationName ) : <NEWLINE> self . _handler . unparsedEntityDecl ( name , publicId , systemId , notationName ) <NEWLINE> <DEDENT>
from bachutil import * <NEWLINE> import initbach <NEWLINE> from Bach import * <NEWLINE> from PyQt4 . QtCore import * <NEWLINE> import os <NEWLINE> import sha <NEWLINE> assets = BachAsset . select ( <STRING> ) <NEWLINE> print ( <STRING> % assets . size ( ) ) <NEWLINE> for asset in assets : <NEWLINE> <INDENT> path = asset . path ( ) <NEWLINE> asset . setHash ( assetHash ( path ) ) <NEWLINE> asset . commit ( ) <NEWLINE> try : print <STRING> % ( asset . hash ( ) , path ) <NEWLINE> except UnicodeDecodeError : pass <NEWLINE> <DEDENT>
def get ( self , request , ** kwargs ) : <NEWLINE> <INDENT> success = None <NEWLINE> try : <NEWLINE> <INDENT> success = kwargs [ <STRING> ] <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> return render ( request , self . template_name <NEWLINE> <INDENT> { <NEWLINE> <INDENT> <STRING> : True , <NEWLINE> <STRING> : True , <NEWLINE> <STRING> : Plugin . all ( owner = request . user ) , <NEWLINE> <STRING> : request , <NEWLINE> <STRING> : True , <NEWLINE> <STRING> : success <NEWLINE> <DEDENT> } ) <NEWLINE> <DEDENT> <DEDENT>
def showarray ( a , fmt = <STRING> ) : <NEWLINE> <INDENT> a = np . uint8 ( np . clip ( a , 0 , 255 ) ) <NEWLINE> f = StringIO ( ) <NEWLINE> PIL . Image . fromarray ( a ) . save ( f , fmt ) <NEWLINE> display ( Image ( data = f . getvalue ( ) ) <NEWLINE> <DEDENT>
def test_send_request_message_response_None ( self ) : <NEWLINE> <INDENT> with patch ( <STRING> + <NEWLINE> <INDENT> <STRING> + <NEWLINE> <STRING> ) as q_get : <NEWLINE> self . value01 = ObjectProperty ( <STRING> , <STRING> ) <NEWLINE> q_get . return_value = None <NEWLINE> self . target . dispatcher . get_source_dispatcher_id = Mock ( <NEWLINE> return_value = <STRING> ) <NEWLINE> try : <NEWLINE> self . result = self . target . send_request_message ( self . value01 ) <NEWLINE> except : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>
def supportedDatabases ( ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> for name , module in _supportedDatabases . items ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> exec <STRING> % module <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . append ( name ) <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <DEDENT>
class Forex ( Contract ) : <NEWLINE> <INDENT> def __init__ ( self , pair = <STRING> , exchange = <STRING> , <NEWLINE> <INDENT> symbol = <STRING> , currency = <STRING> , ** kwargs ) : <NEWLINE> if pair : <NEWLINE> assert len ( pair ) == 6 <NEWLINE> symbol = symbol or pair [ : 3 ] <NEWLINE> currency = currency or pair [ 3 : ] <NEWLINE> Contract . __init__ ( self , secType = <STRING> , symbol = symbol , <NEWLINE> <INDENT> exchange = exchange , currency = currency , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def retranslateUi ( self , NameFormatDialog ) : <NEWLINE> <INDENT> NameFormatDialog . setWindowTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . groupBox . setTitle ( QtGui . QApplication . translate ( <STRING> , <STRING> , None , QtGui . QApplication . UnicodeUTF8 ) ) <NEWLINE> self . textBrowser . setHtml ( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def overlaps ( self , other ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . network_intrep == None : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if isinstance ( other , ipaddr ) : <NEWLINE> <INDENT> if other . intrep == None : <NEWLINE> return 0 <NEWLINE> return ( self . mask . intrep & other . intrep ) == self . network_intrep <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if other . network_intrep == None : <NEWLINE> return 0 <NEWLINE> mask = self . mask . intrep & other . mask . intrep <NEWLINE> return ( mask & self . ip . intrep ) == ( mask & other . ip . intrep ) <NEWLINE> <DEDENT> <DEDENT>
class SingleCertHttpsProxyServer ( HttpProxyServer ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , http_archive_fetch , custom_handlers , rules , <NEWLINE> <INDENT> https_root_ca_cert_path , ** kwargs ) : <NEWLINE> HttpProxyServer . __init__ ( self , http_archive_fetch , custom_handlers , rules , <NEWLINE> <INDENT> is_ssl = True , protocol = <STRING> , ** kwargs ) <NEWLINE> self . socket = ssl . wrap_socket ( <NEWLINE> self . socket , certfile = https_root_ca_cert_path , server_side = True , <NEWLINE> do_handshake_on_connect = False ) <NEWLINE> <DEDENT> <DEDENT> def handle_error ( self , request , client_address ) : <NEWLINE> <INDENT> _HandleSSLCertificateError ( ) <NEWLINE> <DEDENT> <DEDENT>
def get ( self , iuid ) : <NEWLINE> <INDENT> reference = self . get_entry ( iuid ) <NEWLINE> if reference is None : <NEWLINE> <INDENT> raise tornado . web . HTTPError ( 404 ) <NEWLINE> <DEDENT> self . render ( <STRING> , <NEWLINE> <INDENT> reference = reference , <NEWLINE> source = self . get_source ( reference ) <NEWLINE> target = self . get_target ( reference ) , <NEWLINE> notes = self . get_notes ( reference ) , <NEWLINE> xrefs = self . get_xrefs ( reference ) ) <NEWLINE> <DEDENT> <DEDENT>
def explained_variance ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> var_error = np . var ( self . error ) <NEWLINE> var_actual = np . var ( map ( lambda ( p , a ) : a , self . predicted_actual ) ) <NEWLINE> return 1 - float ( var_error / var_actual ) <NEWLINE> <DEDENT>
def hexToSalt ( s ) : <NEWLINE> <INDENT> def chunkify ( s ) : <NEWLINE> <INDENT> rest = s <NEWLINE> while rest : <NEWLINE> <INDENT> chunk , rest = rest [ : 2 ] , rest [ 2 : ] <NEWLINE> yield chunk <NEWLINE> <DEDENT> <DEDENT> return <STRING> . join ( chr ( int ( i , 16 ) for i in chunkify ( s ) ) <NEWLINE> <DEDENT>
def addShapes ( self , shapes , color = ( 0.9 , 0.9 , 0.9 , 1.0 ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if DEBUG : print <STRING> , len ( shapes ) , <STRING> <NEWLINE> for s in shapes : <NEWLINE> <INDENT> if s . Faces : <NEWLINE> <INDENT> self . shapes . append ( [ s , color ] ) <NEWLINE> for f in s . Faces : <NEWLINE> <INDENT> self . faces . append ( [ f , color ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> self . resetFlags ( ) <NEWLINE> <DEDENT>
def requestDelete ( self , task = None ) : <NEWLINE> <INDENT> DistributedPetAI . notify . info ( <STRING> % ( self . doId , self . ownerId ) ) <NEWLINE> if self . hasRequestedDelete ( ) : <NEWLINE> <INDENT> DistributedPetAI . notify . info ( <STRING> % ( self . doId , self . ownerId ) <NEWLINE> return <NEWLINE> <DEDENT> self . setHasRequestedDelete ( True ) <NEWLINE> self . b_setLastSeenTimestamp ( self . getCurEpochTimestamp ( ) ) <NEWLINE> DistributedSmoothNodeAI . DistributedSmoothNodeAI . requestDelete ( self ) <NEWLINE> <DEDENT>
def jassign ( old , new , base_env = { } ) : <NEWLINE> <INDENT> res = new <NEWLINE> for vs in jeevesState . pathenv . conditions : <NEWLINE> <INDENT> ( var , val ) = ( vs . var , vs . val ) <NEWLINE> if var . name not in base_env : <NEWLINE> if val : <NEWLINE> <DEDENT> res = Facet ( var , res , old ) <NEWLINE> <INDENT> else : <NEWLINE> <INDENT> res = Facet ( var , old , res ) <NEWLINE> <DEDENT> <DEDENT> if isinstance ( res , FExpr ) : <NEWLINE> <INDENT> return res . partialEval ( { } , True ) <NEWLINE> <DEDENT> else : <NEWLINE> return res <NEWLINE> <DEDENT>
def __init__ ( self , d , dl ) : <NEWLINE> <INDENT> self . doc , self . doclist = d , dl <NEWLINE> <INDENT> def test_data ( self ) : pass <NEWLINE> <DEDENT> <DEDENT>
def remove_debug_info ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> re_expr = <STRING> <NEWLINE> for rule in self . get_all_result_rules ( ) : <NEWLINE> <INDENT> for check_import in self . filter_grandchildren ( rule , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ) : <NEWLINE> if check_import . text is not None : <NEWLINE> new_check = [ ] <NEWLINE> for check in check_import . text . split ( <STRING> ) : <NEWLINE> matched = re . match ( re_expr , check ) <NEWLINE> if not matched : <NEWLINE> new_check . append ( check ) <NEWLINE> check_import . text = <STRING> . join ( new_check ) <NEWLINE> <DEDENT> <DEDENT> self . write_xml ( ) <NEWLINE> <DEDENT>
class next : <NEWLINE> <INDENT> def GET ( self , num ) : <NEWLINE> <INDENT> number = int ( num ) <NEWLINE> todos = db . select ( <STRING> , limit = 20 , offset = 20 * number ) <NEWLINE> number = number + 1 <NEWLINE> <INDENT> return render . next ( todos , number ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_type ( column ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> a = set ( map ( type , column ) ) <NEWLINE> types = [ int , float , str ] <NEWLINE> i = max ( map ( lambda ( t , n ) : ( t in a ) * ( n + 1 ) , zip ( types , range ( len ( types ) ) ) ) ) <NEWLINE> return types [ i - 1 ] <NEWLINE> <DEDENT>
def subjects ( request ) : <NEWLINE> <INDENT> return { <NEWLINE> <STRING> : Subject . objects . all ( ) <NEWLINE> <DEDENT>
class Bucket : <NEWLINE> <INDENT> def __init__ ( self , bucket , conn = None ) : <NEWLINE> <INDENT> self . conn = conn if conn else Connection ( ) <NEWLINE> self . bucket = bucket <NEWLINE> <DEDENT> _s = <STRING> <NEWLINE> for _m in ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> exec _s % ( _m , _m ) <NEWLINE> <DEDENT> _s = <STRING> <NEWLINE> for _m in ( <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> ) : <NEWLINE> exec _s % ( _m , _m ) <NEWLINE> <DEDENT> del _m , _s <NEWLINE> <DEDENT>
( { <STRING> : self . analyzer . name ( ) , <NEWLINE> <INDENT> <STRING> : self . analyzer . id ( ) , <NEWLINE> <STRING> : self . analyzer . unit ( ) , <NEWLINE> <STRING> : str ( self . analyzer . value ) } <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def setUp ( self ) : <NEWLINE> <INDENT> from featchat . agents . connection import connection_agent <NEWLINE> config = connection_agent . ConnectionAgentConfiguration ( <NEWLINE> <INDENT> doc_id = <STRING> <NEWLINE> connections_limit = 2 ) <NEWLINE> <DEDENT> featchat . initial_data ( config ) <NEWLINE> self . override_config ( <STRING> , config ) <NEWLINE> return common . SimulationTest . setUp ( self ) <NEWLINE> <DEDENT>
def url_for_page ( page = None , query = None ) <NEWLINE> <INDENT> args = request . args . to_dict ( flat = False ) <NEWLINE> if page : <NEWLINE> <INDENT> args [ <STRING> ] = page <NEWLINE> <DEDENT> if query : <NEWLINE> <INDENT> args [ <STRING> ] = query <NEWLINE> <DEDENT> return url_for ( request . endpoint , ** args ) <NEWLINE> <DEDENT>
def getenv ( s ) : <NEWLINE> <INDENT> if os . environ . has_key ( s ) : <NEWLINE> return os . environ [ s ] <NEWLINE> return None <NEWLINE> <DEDENT>
import datetime <NEWLINE> from . . models import ProjectEvent , Project <NEWLINE> def create_project_event ( project : Project , text , <NEWLINE> <INDENT> data_json : dict = None , event_type : str = None ) -> ProjectEvent : <NEWLINE> event = ProjectEvent ( project = project , human_text = text ) <NEWLINE> event . created_on = datetime . datetime . utcnow ( ) <NEWLINE> if data_json : <NEWLINE> event . optional_data_json = data_json <NEWLINE> if event_type : <NEWLINE> event . optional_event_type = event_type <NEWLINE> return event <NEWLINE> <DEDENT>
def backup_config ( self , destination = <STRING> ) : <NEWLINE> <INDENT> if path . isfile ( path . join ( self . location , <STRING> ) : <NEWLINE> <INDENT> shutil . copy2 ( path . join ( self . location , <STRING> ) , <NEWLINE> <INDENT> path . join ( self . location , destination ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def isHome ( sSiteName , sFunction ) : <NEWLINE> <INDENT> if ( sSiteName == <STRING> ) : <NEWLINE> <INDENT> oHome = cHome ( ) <NEWLINE> exec <STRING> + sFunction + <STRING> <NEWLINE> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
def role_get ( self , context , auth = None ) : <NEWLINE> <INDENT> aws_access_key_id = context [ <STRING> ] [ <STRING> ] [ <STRING> ] [ <STRING> ] <NEWLINE> aws_access_secret_key = context [ <STRING> ] [ <STRING> ] [ <STRING> ] [ <STRING> ] <NEWLINE> role_name = context [ <STRING> ] [ <STRING> ] [ <STRING> ] [ <STRING> ] <NEWLINE> <INDENT> response = aws_sip . role_get ( aws_access_key_id , aws_access_secret_key , role_name ) <NEWLINE> <DEDENT> print ( <STRING> , response ) <NEWLINE> print ( <STRING> ) <NEWLINE> <INDENT> return response <NEWLINE> <DEDENT> <DEDENT>
def test_set_boot_device_ok ( self , get_ilo_object_mock ) : <NEWLINE> <INDENT> ilo_object_mock = get_ilo_object_mock . return_value <NEWLINE> with task_manager . acquire ( self . context , self . node . uuid , <NEWLINE> <INDENT> shared = False ) as task : <NEWLINE> task . driver . management . set_boot_device ( task , boot_devices . CDROM , <NEWLINE> <INDENT> False ) <NEWLINE> get_ilo_object_mock . assert_called_once_with ( task . node ) <NEWLINE> ilo_object_mock . set_one_time_boot . assert_called_once_with ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def retranslateUi ( self , MainWindow ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> MainWindow . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . tabWidget . setTabText ( self . tabWidget . indexOf ( self . widget ) , _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . textBrowser_4 . setHtml ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def GetRecentAlbums ( self , limit = 5 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . logger . debug ( <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> xbmc = Server ( self . url ( <STRING> , True ) ) <NEWLINE> properties = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> limits = { <STRING> : 0 , <STRING> : int ( limit ) } <NEWLINE> return xbmc . AudioLibrary . GetRecentlyAddedAlbums ( properties = properties , limits = limits ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> self . logger . exception ( e ) <NEWLINE> self . logger . error ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT>
def _init_service ( self , ** kw ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> from . . core import services as SM <NEWLINE> self . services = SM . get_service_manager ( ) <NEWLINE> self . services . register_service ( <NEWLINE> <INDENT> tools . choose_str ( kw . get ( <STRING> ) , <STRING> ) , <NEWLINE> self <NEWLINE> <DEDENT> ) <NEWLINE> <INDENT> <STRING> , <NEWLINE> self , <NEWLINE> silent_mode = True , <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def diff ( self ) : <NEWLINE> <INDENT> d1 = self . _initial <NEWLINE> d2 = self . _dict <NEWLINE> diffs = [ ( k , ( v , d2 [ k ] ) for k , v in d1 . items ( ) if self . fields_differ ( v , d2 [ k ] ) ] <NEWLINE> return dict ( diffs ) <NEWLINE> <DEDENT>
def new_view ( request , * args , ** kwargs ) : <NEWLINE> <INDENT> user = get_user ( request ) <NEWLINE> if user . is_authenticated ( ) : <NEWLINE> <INDENT> return view ( request , * args , ** kwargs ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> url = <STRING> format ( settings . LOGIN_URL , <NEWLINE> <INDENT> request . path ) <NEWLINE> <DEDENT> return redirect ( url ) <NEWLINE> <DEDENT> return new_view <NEWLINE> <DEDENT>
def __run_adb_cmd ( self , cmd ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> args = [ <STRING> ] <NEWLINE> args . extend ( cmd ) <NEWLINE> process = subprocess . Popen ( args , stdin = subprocess . PIPE , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) <NEWLINE> ret = process . communicate ( ) <NEWLINE> return ret <NEWLINE> <DEDENT> except Exception , ex : <NEWLINE> <INDENT> print ( ret ) <NEWLINE> raise Exception ( ex ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> entities = [ ] <NEWLINE> fin = open ( sys . argv [ 1 ] ) <NEWLINE> <INDENT> for line in fin . readlines ( ) : <NEWLINE> <INDENT> if ( len ( line . strip ( ) ) > 0 and ( line [ 0 ] != <STRING> ) ) : <NEWLINE> entities . append ( line . strip ( ) ) <NEWLINE> <DEDENT> <DEDENT> fin . close ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> for entity in entities : <NEWLINE> <INDENT> print ( <STRING> + entity + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def _FindNthChildNamed ( self , node , name , n = 1 ) : <NEWLINE> <INDENT> for i , child in enumerate ( <NEWLINE> <INDENT> py3compat . ifilter ( lambda c : pytree_utils . NodeName ( c ) == name , <NEWLINE> <INDENT> node . pre_order ( ) ) ) : <NEWLINE> if i == n - 1 : <NEWLINE> <DEDENT> return child <NEWLINE> <DEDENT> raise RuntimeError ( <STRING> . format ( n ) ) <NEWLINE> <DEDENT>
def save ( self , * args , ** kwargs ) : <NEWLINE> <INDENT> if not self . pk : <NEWLINE> <INDENT> self . amount = self . points_table [ self . ttype ] <NEWLINE> <INDENT> super ( Transaction , self ) . save ( * args , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class Foo : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> self . i = 10 <NEWLINE> self . j = 20 <NEWLINE> <DEDENT>
def train ( self , episode_len , episode_nbr , behavior = <STRING> ) : <NEWLINE> <INDENT> tau = 0.001 <NEWLINE> speedup = 0.1 <NEWLINE> self . pos_log = [ ] <NEWLINE> for j in range ( episode_nbr ) : <NEWLINE> <INDENT> self . run_episode ( episode_len , tau , behavior , <STRING> ) <NEWLINE> if ( j + 1 ) % 100 == 0 : print <STRING> % ( j + 1 ) <NEWLINE> <DEDENT> self . run_episode ( episode_len , tau , behavior , <STRING> ) <NEWLINE> show ( behavior + <STRING> , self . pos_log , tau / speedup ) <NEWLINE> <DEDENT>
def OnComplete ( self , event ) : <NEWLINE> <INDENT> num = self . todo_list . GetItemCount ( ) <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> if i == 0 : pass <NEWLINE> if self . todo_list . IsChecked ( i ) : <NEWLINE> qry = <STRING> % ( self . todo_list . GetItem ( i , 7 ) . GetText ( ) ) <NEWLINE> EMR_utilities . updateData ( qry ) <NEWLINE> self . todo_list . DeleteItem ( i ) <NEWLINE> <DEDENT> <DEDENT>
from hyperv . neutron . ml2 import mech_hyperv <NEWLINE> from neutron . common import constants <NEWLINE> from neutron . extensions import portbindings <NEWLINE> from neutron . plugins . ml2 . drivers import mech_agent <NEWLINE> class HypervMechanismDriver ( mech_hyperv . HypervMechanismDriver , <NEWLINE> <INDENT> mech_agent . SimpleAgentMechanismDriverBase ) : <NEWLINE> <STRING> <NEWLINE> def __init__ ( self ) : <NEWLINE> super ( HypervMechanismDriver , self ) . __init__ ( <NEWLINE> constants . AGENT_TYPE_HYPERV , <NEWLINE> portbindings . VIF_TYPE_HYPERV , <NEWLINE> { portbindings . CAP_PORT_FILTER : False } ) <NEWLINE> <DEDENT>
def create_cost_fun ( self ) : <NEWLINE> <INDENT> what_to_predict = self . input_mat [ : , 1 : ] <NEWLINE> for_how_long = self . for_how_long - 1 <NEWLINE> starting_when = T . zeros_like ( self . for_how_long ) <NEWLINE> self . lstm_cost = masked_loss ( self . lstm_predictions , <NEWLINE> <INDENT> what_to_predict , <NEWLINE> for_how_long , <NEWLINE> starting_when ) . sum ( ) <NEWLINE> <DEDENT> self . final_cost = masked_loss ( self . final_predictions <NEWLINE> <INDENT> what_to_predict , <NEWLINE> for_how_long , <NEWLINE> starting_when ) . sum ( ) <NEWLINE> <DEDENT> <DEDENT>
def Thread7214 ( MSG_Tuple , SenderInfo ) : <NEWLINE> <INDENT> MSG = dict ( map ( None , MSG_Tuple ) ) <NEWLINE> <INDENT> SensorData = ReadTransducerBlockDataFromMultipleChannelsOfATIM ( MSG [ <STRING> ] , MSG [ <STRING> ] , MSG [ <STRING> ] , MSG [ <STRING> ] , MSG [ <STRING> ] , MSG [ <STRING> ] ) <NEWLINE> response = MSG [ <STRING> ] + <STRING> + MSG [ <STRING> ] + <STRING> + MSG [ <STRING> ] + <STRING> + MSG [ <STRING> ] + <STRING> + str ( SensorData [ <STRING> ] ) <NEWLINE> xmpp_send ( str ( SenderInfo [ 1 ] ) , response ) <NEWLINE> <DEDENT> <DEDENT>
def _parse_opcode ( self , opcode ) : <NEWLINE> <INDENT> nibbles = opcode . split ( <STRING> ) <NEWLINE> opcode_size = len ( nibbles ) <NEWLINE> opcode_string = <STRING> . join ( nibbles ) <NEWLINE> printopcode_string ) <NEWLINE> <DEDENT>
class EmailFeedSettingManager ( models . Manager ) : <NEWLINE> <INDENT> def filter_subscribers ( <NEWLINE> <INDENT> self , <NEWLINE> potential_subscribers = None , <NEWLINE> feed_type = None , <NEWLINE> frequency = None <NEWLINE> ) : <NEWLINE> <STRING> <NEWLINE> matching_feeds = self . filter ( <NEWLINE> <INDENT> feed_type = feed_type , <NEWLINE> frequency = frequency <NEWLINE> ) <NEWLINE> if potential_subscribers is not None : <NEWLINE> matching_feeds = matching_feeds . filter ( <NEWLINE> subscriber__in = potential_subscribers <NEWLINE> <DEDENT> ) <NEWLINE> subscriber_set = set ( ) <NEWLINE> for feed in matching_feeds : <NEWLINE> subscriber_set . add ( feed . subscriber ) <NEWLINE> return subscriber_set <NEWLINE> <DEDENT> <DEDENT>
def _listing_iter ( self , account_name , lcontainer , lprefix , env ) : <NEWLINE> <INDENT> for page in self . _listing_pages_iter ( account_name , <NEWLINE> <INDENT> lcontainer , lprefix , env ) : <NEWLINE> for item in page : <NEWLINE> yield item <NEWLINE> <DEDENT> <DEDENT>
def getstat ( xax , yax ) : <NEWLINE> <INDENT> cdf = np . cumsum ( yax ) <NEWLINE> <INDENT> ppf = interp1d ( cdf , xax ) <NEWLINE> p16 , med , p84 = ppf ( [ 0.16 , 0.50 , 0.84 ] ) <NEWLINE> emed1 = med - p16 <NEWLINE> emed2 = p84 - med <NEWLINE> return med , emed2 , emed1 <NEWLINE> <DEDENT> <DEDENT>
def __initiate_values ( self ) : <NEWLINE> <INDENT> self . __override_table_final = <STRING> <NEWLINE> self . __state = <STRING> <NEWLINE> self . __override_list = [ ] <NEWLINE> self . __state_dict = { <NEWLINE> <INDENT> <STRING> : self . __default_func <NEWLINE> <STRING> : self . __override_func , <NEWLINE> <STRING> : self . __after_bracket_func , <NEWLINE> <DEDENT> } <NEWLINE> self . __override_dict = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>
( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>
class HTTPS ( HTTP ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> _connection_class = HTTPSConnection <NEWLINE> def __init__ ( self , host = <STRING> , port = None , key_file = None , cert_file = None , <NEWLINE> <INDENT> strict = None ) : <NEWLINE> if key_file is not None or cert_file is not None : <NEWLINE> raise NotImplementedError ( <NEWLINE> <STRING> ) <NEWLINE> if port == 0 : <NEWLINE> port = None <NEWLINE> self . _setup ( self . _connection_class ( host , port , key_file , <NEWLINE> <INDENT> cert_file , strict ) ) <NEWLINE> self . key_file = key_file <NEWLINE> self . cert_file = cert_file <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def file_len ( self , fname ) : <NEWLINE> <INDENT> with open ( fname ) as f : <NEWLINE> <INDENT> i = 0 <NEWLINE> <INDENT> for i , l in enumerate ( f ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if i == 0 : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return i + 1 <NEWLINE> <DEDENT> <DEDENT>
def logout ( request ) : <NEWLINE> <INDENT> auth . logout ( request ) <NEWLINE> return render_to_response ( <NEWLINE> <INDENT> <STRING> <NEWLINE> { } , <NEWLINE> RequestContext ( request ) ) <NEWLINE> <DEDENT> <DEDENT>
def cleanUpFit ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for ws_name in ( <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> <STRING> ) : <NEWLINE> try : <NEWLINE> DeleteWorkspace ( ws_name ) <NEWLINE> except : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>
def UploadFiles ( ) : <NEWLINE> <INDENT> command = ( [ rclone copy / gdrive / googledrive : gdrive / ] ) <NEWLINE> result = subprocess . Popen ( command ) <NEWLINE> result . communicate ( ) <NEWLINE> <STRING> <NEWLINE> <DEDENT>
def test_wrapUnWrapPrecision ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for p in range ( 5 , 13 ) : <NEWLINE> <INDENT> for i in range ( 1000 ) : <NEWLINE> <INDENT> self . _wrapUnWrap ( p ) <NEWLINE> <DEDENT> <DEDENT> with self . assertRaisesRegex ( <NEWLINE> <INDENT> FontMathWarning , <NEWLINE> <STRING> ) : <NEWLINE> for p in range ( 14 , 16 ) : <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> self . _wrapUnWrap ( p ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def validate_item_type_for_reorder ( self ) : <NEWLINE> <INDENT> if self . doc . re_order_level or len ( self . doclist . get ( { <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> } ) ) : <NEWLINE> if not self . doc . is_purchase_item : <NEWLINE> webnotes . msgprint ( _ ( <STRING> ) , <NEWLINE> <INDENT> raise_exception = 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def change ( self , socket = None , flags = 0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> if not socket : <NEWLINE> <INDENT> socket = netlink . lookup_socket ( netlink . NETLINK_ROUTE ) <NEWLINE> <DEDENT> <DEDENT> if not self . _orig : <NEWLINE> <INDENT> raise NetlinkError ( <STRING> ) <NEWLINE> <INDENT> ret = capi . rtnl_link_change ( socket . _sock , self . _orig , self . _rtnl_link , flags ) <NEWLINE> <INDENT> if ret < 0 : <NEWLINE> <INDENT> raise netlink . KernelError ( ret ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
class Ui_MainWindow ( QtGui . QMainWindow ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> QtGui . QWidget . __init__ ( self ) <NEWLINE> self . setupUi ( self ) <NEWLINE> <DEDENT> def setupUi ( self , MainWindow ) : <NEWLINE> <INDENT> MainWindow . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> MainWindow . resize ( 1160 , 600 ) <NEWLINE> MainWindow . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
def info ( self , path = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> tile = IOTile ( path ) <NEWLINE> info = { <NEWLINE> <INDENT> <STRING> : not tile . release <NEWLINE> <STRING> : tile . dependencies <NEWLINE> <DEDENT> } <NEWLINE> return info <NEWLINE> <DEDENT>
def implements ( * abc ) : <NEWLINE> <INDENT> def decorator ( cls ) : <NEWLINE> implement ( cls , * abc ) <NEWLINE> return cls <NEWLINE> return decorator <NEWLINE> <DEDENT>
def prepareAddress ( self ) : <NEWLINE> <INDENT> host , port = self . addr <NEWLINE> if iocpdebug . debug : <NEWLINE> <INDENT> print ( <STRING> % ( host , port ) ) <NEWLINE> <DEDENT> if isinstance ( port , types . StringTypes ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> port = socket . getservbyname ( port , <STRING> ) <NEWLINE> <DEDENT> except socket . error , e : <NEWLINE> <INDENT> raise error . ServiceNameUnknownError ( string = str ( e ) ) <NEWLINE> <DEDENT> <DEDENT> self . addr = ( host , port ) <NEWLINE> <DEDENT>
def reset ( ) : <NEWLINE> <INDENT> global com_vel <NEWLINE> global com_acc <NEWLINE> global vels <NEWLINE> global accs <NEWLINE> global a_s <NEWLINE> global path <NEWLINE> com_vel = [ 0. , 0. , 0. ] <NEWLINE> com_acc = [ 0. , 0. , 0. ] <NEWLINE> clean_path ( ) ; <NEWLINE> vels = [ ] <NEWLINE> accs = [ ] <NEWLINE> path = [ ] <NEWLINE> a_s = [ ] <NEWLINE> for i , config in enumerate ( configs ) : <NEWLINE> fullBody . setConfigAtState ( i , config ) <NEWLINE> <DEDENT>
def __init__ ( self , parent , hhid = 0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> QDialog . __init__ ( self ) <NEWLINE> self . setupUi ( self ) <NEWLINE> self . parent = parent <NEWLINE> self . stlitem = <STRING> <NEWLINE> self . stlmodelprice = 0 <NEWLINE> self . stlprice = 0 <NEWLINE> self . connector = ReportsSettingsManager ( ) <NEWLINE> myReferenceVal = QDoubleValidator ( 0 , 100000000 , 2 , self . txtIncomeDefaultValues ) <NEWLINE> <INDENT> self . txtIncomeDefaultValues . setValidator ( myReferenceVal ) <NEWLINE> <DEDENT> self . getPorjects ( ) <NEWLINE> self . insertDietHeader ( ) <NEWLINE> self . insertStandardOfLivingHeader ( ) <NEWLINE> self . insertIncomeSourcesHeader ( ) <NEWLINE> <DEDENT>
def is_skipped_function ( name ) : <NEWLINE> <INDENT> for fun in skipped_functions : <NEWLINE> <INDENT> if fun == name : <NEWLINE> return 1 <NEWLINE> <DEDENT> if string . find ( name , <STRING> ) != - 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT>
class Ward ( AgglomerativeClustering ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> linkage = <STRING> <NEWLINE> def __init__ ( self , n_clusters = 2 , memory = Memory ( cachedir = None , verbose = 0 ) , <NEWLINE> <INDENT> connectivity = None , n_components = None , <NEWLINE> compute_full_tree = <STRING> , pooling_func = np . mean ) : <NEWLINE> warnings . warn ( <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> , DeprecationWarning ) <NEWLINE> self . n_clusters = n_clusters <NEWLINE> self . memory = memory <NEWLINE> self . n_components = n_components <NEWLINE> self . connectivity = connectivity <NEWLINE> self . compute_full_tree = compute_full_tree <NEWLINE> self . affinity = <STRING> <NEWLINE> self . pooling_func = pooling_func <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class SFlowSetting ( base . BaseV30 ) : <NEWLINE> <INDENT> url_prefix = <STRING> <NEWLINE> def create ( self , max_header , source_ip_use_mgmt , <NEWLINE> <INDENT> packet_sampling_rate , counter_polling_interval , ** kwargs ) : <NEWLINE> params = { <NEWLINE> <STRING> : { <NEWLINE> <INDENT> <STRING> : counter_polling_interval <NEWLINE> } <NEWLINE> } <NEWLINE> return self . _post ( self . url_prefix , params , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT> def get ( self ) : <NEWLINE> <INDENT> return self . _get ( self . url_prefix ) <NEWLINE> <DEDENT> <DEDENT>
def InitializeDevice ( devNum ) : <NEWLINE> <INDENT> base_dir = <STRING> <NEWLINE> device_folder = glob . glob ( base_dir + <STRING> ) [ sensors ] <NEWLINE> <INDENT> device_file = device_folder + <STRING> <NEWLINE> <DEDENT> return device_file <NEWLINE> <DEDENT>
class DocumentScripts ( plugins . Action ) : <NEWLINE> <INDENT> def setUpApplication ( self , app ) : <NEWLINE> <INDENT> modNames = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for modName in modNames : <NEWLINE> <INDENT> importCommand = <STRING> + modName <NEWLINE> exec importCommand <NEWLINE> module = eval ( modName ) <NEWLINE> names = dir ( module ) <NEWLINE> for name in names : <NEWLINE> <INDENT> scriptName = modName + <STRING> + name <NEWLINE> try : <NEWLINE> <INDENT> docString = getattr ( eval ( scriptName ) , <STRING> ) <NEWLINE> print ( scriptName + <STRING> + docString ) <NEWLINE> <DEDENT> except AttributeError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def getQ ( acteur ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> page = pywikibot . Page ( site , acteur ) <NEWLINE> if page . isRedirectPage ( ) : <NEWLINE> <INDENT> return getQ ( page . getRedirectTarget ( ) . title ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> data = pywikibot . ItemPage . fromPage ( page ) <NEWLINE> return data . getID ( ) <NEWLINE> <DEDENT> <DEDENT> except pywikibot . NoPage : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> , sys . exc_info ( ) [ 0 ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def greetUser ( self , name = None ) : <NEWLINE> <INDENT> if name : <NEWLINE> <INDENT> if trunk in local_zips : <NEWLINE> <INDENT> return <STRING> % name <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> return <STRING> % name <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if name is None : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def remove ( args ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> exec_results = EnvironmentManager ( args ) . remove ( ) <NEWLINE> print_playbook_results ( exec_results ) <NEWLINE> try : <NEWLINE> <INDENT> if exec_results [ <STRING> ] . statuscode == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> display ( <STRING> . format ( args . env_name ) , <NEWLINE> <INDENT> color = <STRING> , stderr = False ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except KeyError , e : <NEWLINE> <INDENT> raise ExecutionError ( <STRING> . format ( args . env_name ) ) <NEWLINE> <DEDENT> <DEDENT>
def generateRecords ( self , records ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . verbosity > 0 : <NEWLINE> <INDENT> print <STRING> , len ( records ) , <STRING> <NEWLINE> <DEDENT> for record in records : <NEWLINE> <INDENT> self . generateRecord ( record ) <NEWLINE> <DEDENT> <DEDENT>
def ehelp ( name , imports ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> locls = { } <NEWLINE> if imports : <NEWLINE> try : exec imports in locls <NEWLINE> except : pass <NEWLINE> try : help ( eval ( name , globals ( ) , locls ) ) <NEWLINE> except : help ( name ) <NEWLINE> <DEDENT>
def noDoubleKeys ( self , keylist , key ) : <NEWLINE> <INDENT> if keylist == [ ] : <NEWLINE> <INDENT> return key <NEWLINE> <DEDENT> if key == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> for x in keylist : <NEWLINE> <INDENT> if x == key : <NEWLINE> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return key <NEWLINE> <DEDENT> <DEDENT>
class ParseError ( Exception ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , message : str ) : <NEWLINE> <INDENT> self . message = message <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return self . message <NEWLINE> <DEDENT> def __repr__ ( self ) : <NEWLINE> <INDENT> return <STRING> . format ( repr ( self . message ) ) ) <NEWLINE> <DEDENT> <DEDENT>
def executeCommand ( cmdLine ) : <NEWLINE> <INDENT> writeOutput ( cmdLine ) <NEWLINE> startTime = time . time ( ) <NEWLINE> <INDENT> writeOutput ( commands . getoutput ( cmdLine ) ) <NEWLINE> <DEDENT> writeOutput ( <STRING> % ( time . time ( ) - startTime ) ) <NEWLINE> <DEDENT>
def cleanup ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> for root , dirs , files in walk_storage ( <NEWLINE> <INDENT> self . dest , storage = private_storage ) : <NEWLINE> for fname in files : <NEWLINE> private_storage . delete ( os . path . join ( root , fname ) ) <NEWLINE> <DEDENT> <DEDENT> except OSError as e : <NEWLINE> <INDENT> if e . errno == 2 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> raise <NEWLINE> <DEDENT> <DEDENT>
def deser_uint256 ( f ) : <NEWLINE> <INDENT> r = 0 l <NEWLINE> for i in xrange ( 8 ) : <NEWLINE> <INDENT> t = struct . unpack ( <STRING> , f . read ( 4 ) ) [ 0 ] <NEWLINE> r += t << ( i * 32 ) <NEWLINE> <DEDENT> return r <NEWLINE> <DEDENT>
def get_uid ( user_name ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return pwd . getpwnam ( user_name ) [ 2 ] <NEWLINE> <DEDENT> except KeyError , exp : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT>
def load_y ( y_path ) : <NEWLINE> <INDENT> file = open ( y_path , <STRING> ) <NEWLINE> y_ = np . array ( <NEWLINE> <INDENT> [ elem for elem in [ <NEWLINE> <INDENT> row . replace ( <STRING> , <STRING> ) . strip ( ) . split ( <STRING> ) for row in file <NEWLINE> ] , <NEWLINE> <DEDENT> dtype = np . int32 <NEWLINE> <DEDENT> ) <NEWLINE> file . close ( ) <NEWLINE> return y_ - 1 <NEWLINE> <DEDENT>
def _setup_logging ( env ) <NEWLINE> <INDENT> env . logger = logging . getLogger ( <STRING> ) <NEWLINE> env . logger . setLevel ( logging . DEBUG ) <NEWLINE> ch = logging . StreamHandler ( ) <NEWLINE> ch . setLevel ( logging . DEBUG ) <NEWLINE> ch . setFormatter ( ColorFormatter ( ) ) <NEWLINE> env . logger . addHandler ( ch ) <NEWLINE> <DEDENT>
def fetch_money ( self , count , passwd ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> totalfee = count + count * self . feerate <NEWLINE> check_result = self . _pay_check ( totalfee , passwd ) <NEWLINE> if check_result == errorcode . NO_ERROR : <NEWLINE> <INDENT> self . card_pay ( count , 3 , common . create_serialno ( ) <NEWLINE> self . card_pay ( count * self . feerate , 4 , common . create_serialno ( ) ) <NEWLINE> return errorcode . NO_ERROR <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return check_result <NEWLINE> <DEDENT> <DEDENT>
def element_space ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with FailCounter ( <NEWLINE> <INDENT> test_name = <STRING> , <NEWLINE> logger = self . log ) as counter : <NEWLINE> for [ n_x , x ] in samples ( self . space ) : <NEWLINE> if x . space != self . space : <NEWLINE> <INDENT> counter . fail ( <STRING> . format ( n_x ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def sw_enter_active ( self , sw ) : <NEWLINE> <INDENT> return True <NEWLINE> <INDENT> def format_time ( self , time ) : <NEWLINE> <INDENT> hrs = int ( time / 3600 ) <NEWLINE> mins = int ( ( time - ( hrs * 3600 ) ) / 60 ) <NEWLINE> secs = int ( time - ( mins * 60 ) ) <NEWLINE> if hrs > 0 : <NEWLINE> <INDENT> return str ( hrs ) + <STRING> + str ( mins ) + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return str ( mins ) + <STRING> + str ( secs ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def flatten ( l ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for el in l : <NEWLINE> <INDENT> if isinstance ( el , collections . Iterable ) and not isinstance ( el , <NEWLINE> <INDENT> basestring ) : <NEWLINE> for sub in flatten ( el ) : <NEWLINE> yield sub <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> yield el <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def enumerate_dictioary ( ) : <NEWLINE> <INDENT> x = { 1 : <STRING> , 2 , <STRING> } <NEWLINE> for count , key in enumerate ( x ) : <NEWLINE> <INDENT> print ( <STRING> . format ( count , key , x [ key ] ) <NEWLINE> <DEDENT> <DEDENT>
class AuthnQuery ( Request ) : <NEWLINE> <INDENT> msgtype = <STRING> <NEWLINE> def __init__ ( self , sec_context , receiver_addrs , attribute_converters , <NEWLINE> <INDENT> timeslack = 0 ) : <NEWLINE> Request . __init__ ( self , sec_context , receiver_addrs , <NEWLINE> <INDENT> attribute_converters , timeslack ) <NEWLINE> self . signature_check = self . sec . correctly_signed_authn_query <NEWLINE> <DEDENT> <DEDENT> def attributes ( self ) : <NEWLINE> <INDENT> return to_local ( self . attribute_converters , self . message ) <NEWLINE> <DEDENT> <DEDENT>
def readCommand ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> cmd = raw_input ( <STRING> ) <NEWLINE> if cmd is None or not <STRING> in cmd : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> command_string = cmd . split ( <STRING> ) <NEWLINE> src = command_string [ 0 ] <NEWLINE> dst = command_string [ 1 ] <NEWLINE> src_coordinates = ConvertToIndex ( src ) <NEWLINE> dst_coordinates = ConvertToIndex ( dst ) <NEWLINE> return src_coordinates , dst_coordinates <NEWLINE> <DEDENT> <DEDENT>
def intersect ( self , other ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> out = [ ] <NEWLINE> z = 0 <NEWLINE> for p , d in heapq . merge ( zip ( self . data , itertools . cycle ( ( + 1 , - 1 ) ) ) , <NEWLINE> <INDENT> zip ( other . data , itertools . cycle ( ( + 1 , - 1 ) ) ) ) : <NEWLINE> if ( z == 1 and d == 1 ) or ( z == 2 and d == - 1 ) : <NEWLINE> out . append ( p ) <NEWLINE> z += d <NEWLINE> <DEDENT> return RangeSet ( data = out ) <NEWLINE> <DEDENT>
def acc_get_authorized_emails ( name_action , ** arguments ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> roles = acc_find_possible_roles ( name_action , always_add_superadmin = False , ** arguments ) <NEWLINE> authorized_emails = acc_get_roles_emails ( roles ) <NEWLINE> for id_role in roles : <NEWLINE> <INDENT> firerole = load_role_definition ( id_role ) <NEWLINE> authorized_emails = authorized_emails . union ( acc_firerole_extract_emails ( firerole ) ) ) <NEWLINE> <DEDENT> return authorized_emails <NEWLINE> <DEDENT>
def Update ( self ) : <NEWLINE> <INDENT> if self . current_is_plugin ( ) : <NEWLINE> <INDENT> object = self . current_object ( ) <NEWLINE> for var in self . vars : <NEWLINE> var ( getattr ( object , capwords ( var . name ) ) ( ) ) <NEWLINE> <DEDENT> <DEDENT>
def test_login_by_token ( self ) : <NEWLINE> <INDENT> resp = self . client . get ( reverse ( <STRING> ) ) <NEWLINE> with patch ( <STRING> <NEWLINE> <INDENT> <STRING> ) as requests_mock : <NEWLINE> mocks = [ self . get_mocked_response ( ) . json ( ) ] <NEWLINE> requests_mock . get . return_value . json = lambda : mocks . pop ( ) <NEWLINE> resp = self . client . post ( reverse ( <STRING> ) , <NEWLINE> <INDENT> data = { <STRING> : <STRING> } ) <NEWLINE> self . assertRedirects ( resp , <STRING> , <NEWLINE> fetch_redirect_response = False ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def all_permutations ( seq ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> <INDENT> if len ( seq ) <= 1 : <NEWLINE> <INDENT> yield seq <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for perm in all_permutations ( seq [ 1 : ] ) : <NEWLINE> <INDENT> for i in range ( len ( perm ) + 1 ) : <NEWLINE> <INDENT> yield perm [ : i ] + seq [ 0 : 1 ] + perm [ i : ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def report ( ) : <NEWLINE> <INDENT> dataset_id = request . args . get ( <STRING> , None ) <NEWLINE> if not dataset_id : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> dataset = Dataset . by_id ( dataset_id ) <NEWLINE> if not dataset : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> lr = LoadReport ( dataset ) <NEWLINE> return Response ( lr . get_output ( ) <NEWLINE> <INDENT> mimetype = <STRING> , <NEWLINE> headers = { <STRING> : <STRING> % dataset . name } ) <NEWLINE> <DEDENT> <DEDENT>
( <STRING> <NEWLINE> <DEDENT> <DEDENT>
def test_bad_modules ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for name_base in [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> ] : <NEWLINE> with self . subTest ( name_base ) : <NEWLINE> name = self . name + <STRING> + name_base <NEWLINE> with self . assertRaises ( SystemError ) : <NEWLINE> <INDENT> self . load_module_by_name ( name ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> if os . path . isdir ( target ) : <NEWLINE> <INDENT> dir_listing = os . listdir ( target ) <NEWLINE> for item in dir_listing : <NEWLINE> <INDENT> print ( <STRING> + item ) <NEWLINE> <DEDENT> backups_listing = sorted ( filter ( is_a_backup , dir_listing ) , <NEWLINE> <INDENT> reverse = True ) <NEWLINE> <DEDENT> for item in backups_listing : <NEWLINE> <INDENT> rename ( item ) <NEWLINE> ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def doTest ( self , num , default = <STRING> ) : <NEWLINE> <INDENT> file = mkpath ( <STRING> % num ) <NEWLINE> <INDENT> psql . runfile ( file , default ) <NEWLINE> <DEDENT> self . checkResult ( file ) <NEWLINE> <DEDENT>
def __init__ ( self , cm_host , cm_cluster_name , username , password ) : <NEWLINE> <INDENT> self . cm_api = ApiResource ( cm_host , username = username , password = password ) <NEWLINE> self . hosts = dict ( ) <NEWLINE> self . services = list ( ) <NEWLINE> self . cluster = self . cm_api . get_cluster ( cm_cluster_name ) <NEWLINE> if self . cluster is None : <NEWLINE> <INDENT> raise RuntimeError , <STRING> % cm_cluster_name <NEWLINE> <DEDENT> self . __load_hosts ( ) <NEWLINE> self . __impala_service = ImpalaService ( self ) <NEWLINE> <DEDENT>
def build ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . process_tree = [ ] <NEWLINE> for proc in self . process_list : <NEWLINE> <INDENT> if not proc . parent : <NEWLINE> <INDENT> self . process_tree . append ( proc ) <NEWLINE> else : <NEWLINE> proc . parent . child_list . append ( proc ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def addAtomtoHisto ( self , atom , addvalue ) : <NEWLINE> <INDENT> distance = atom [ 4 ] <NEWLINE> value = int ( self . histobins * ( float ( distance ) - float ( self . histomin ) ) / ( float ( self . histomax - self . histomin ) ) ) <NEWLINE> if value < len ( self . histo ) : <NEWLINE> <INDENT> self . histo [ value ] += addvalue <NEWLINE> self . count [ value ] += 1 <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> print ( value ) <NEWLINE> print ( distance ) <NEWLINE> <DEDENT> <DEDENT>
def retranslateUi2 ( self , Wizard ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> Wizard . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . textBrowser_2 . setHtml ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def _check_for_duplicate_rules ( self , context , security_group_rules ) : <NEWLINE> <INDENT> for i in security_group_rules : <NEWLINE> <INDENT> found_self = False <NEWLINE> for j in security_group_rules : <NEWLINE> <INDENT> if self . _rules_equal ( i [ <STRING> ] , <NEWLINE> <INDENT> j [ <STRING> ] ) : <NEWLINE> if found_self : <NEWLINE> raise ext_sg . DuplicateSecurityGroupRuleInPost ( rule = i ) <NEWLINE> found_self = True <NEWLINE> <DEDENT> <DEDENT> self . _check_for_duplicate_rules_in_db ( context , i ) <NEWLINE> <DEDENT> <DEDENT>
class HistogramSampled4dRGBA ( HistogramRGB ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> name = <STRING> <NEWLINE> description = __doc__ <NEWLINE> def get ( self , image ) : <NEWLINE> <INDENT> b = [ 0 , 64 , 128 , 192 , 255 ] <NEWLINE> r , g , b , a = HistogramRGB . get ( self , image , bins = b ) <NEWLINE> result = [ h [ 0 ] for h in r , g , b , a ] <NEWLINE> if self . mass_normed : <NEWLINE> <INDENT> nb_pixels = image . width * image . height * 1.0 <NEWLINE> result = [ h / nb_pixels for h in result ] <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT> <DEDENT>
def course_config_advanced_page ( request , org , course , name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> location = get_location_and_verify_access ( request , org , course , name ) <NEWLINE> course_module = modulestore ( ) . get_item ( location ) <NEWLINE> return render_to_response ( <STRING> , { <NEWLINE> <INDENT> <STRING> : course_module , <NEWLINE> <STRING> : location , <NEWLINE> <STRING> : json . dumps ( CourseMetadata . fetch ( location ) ) ) , <NEWLINE> <DEDENT> } ) <NEWLINE> <DEDENT>
def processTable ( tName ) : <NEWLINE> <INDENT> global cursor <NEWLINE> colNames = getColumns ( tName ) <NEWLINE> cursor . execute ( <STRING> + tName ) <NEWLINE> result = cursor . fetchall ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> for r in result : <NEWLINE> <INDENT> print ( <STRING> , <NEWLINE> for index , c in enumerate ( r ) : <NEWLINE> <INDENT> print ( colNames [ index ] , ) <NEWLINE> print ( <STRING> + unicode ( c ) + <STRING> , ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def KLabelFold ( labels , n_folds = 3 , shuffle = False , random_state = None ) : <NEWLINE> <INDENT> kfold = KFold ( labels . nunique ( ) , n_folds = n_folds , shuffle = shuffle , random_state = random_state ) <NEWLINE> unique_labels = labels . unique ( ) <NEWLINE> return PredefinedSplit ( pd . concat ( map ( lambda ( i , x ) : labels . isin ( x ) * i , <NEWLINE> <INDENT> enumerate ( [ unique_labels [ mask [ 1 ] ] for mask in kfold ] ) <NEWLINE> ) , axis = 1 ) . sum ( axis = 1 ) ) <NEWLINE> <DEDENT> <DEDENT>
def _WaitForThermalThrottlingIfNeeded ( platform ) : <NEWLINE> <INDENT> if not platform . CanMonitorThermalThrottling ( ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> thermal_throttling_retry = 0 <NEWLINE> while ( platform . IsThermallyThrottled ( ) and <NEWLINE> <INDENT> thermal_throttling_retry < 3 ) : <NEWLINE> logging . warning ( <STRING> , <NEWLINE> <INDENT> thermal_throttling_retry ) <NEWLINE> thermal_throttling_retry += 1 <NEWLINE> time . sleep ( thermal_throttling_retry * 2 ) <NEWLINE> <DEDENT> <DEDENT> if thermal_throttling_retry and platform . IsThermallyThrottled ( ) : <NEWLINE> <INDENT> logging . warning ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test20_bad_response_codes ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for ( path , code ) in [ ( <STRING> , 400 ) , <NEWLINE> <INDENT> ( <STRING> , 400 ) , <NEWLINE> ( <STRING> , 400 ) , <NEWLINE> ( <STRING> , 400 ) ] : <NEWLINE> got_code = None <NEWLINE> try : <NEWLINE> IIIFRequest ( api_version = <STRING> ) . split_url ( path ) <NEWLINE> except IIIFError as e : <NEWLINE> got_code = e . code <NEWLINE> self . assertEqual ( got_code , code , <NEWLINE> <STRING> % <NEWLINE> ( str ( got_code ) , code , path ) ) <NEWLINE> <DEDENT> <DEDENT>
def _reordered_platform ( value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if value == <STRING> or value == <STRING> : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for prefix in ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> ) : <NEWLINE> if value . startswith ( prefix ) : <NEWLINE> return False <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT>
def read_inventory ( self , f , revision_id = None ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return self . _unpack_inventory ( self . _read_element ( f ) , <NEWLINE> <INDENT> revision_id = None ) <NEWLINE> <DEDENT> <DEDENT> finally : <NEWLINE> <INDENT> f . close ( ) <NEWLINE> <DEDENT> <DEDENT> except ParseError , e : <NEWLINE> <INDENT> raise errors . UnexpectedInventoryFormat ( e ) <NEWLINE> <DEDENT> <DEDENT>
def leftOuterJoin ( self , other , left_keys = None , right_keys = None ) : <NEWLINE> <INDENT> o = other . indexBy ( right_keys ) . collectAsMap ( ) <NEWLINE> r = self . indexBy ( left_keys ) . map ( lambda ( k , v ) : ( k , ( v , o . get ( k ) ) ) ) <NEWLINE> r . mem += ( sys . getsizeof ( o ) * 10 ) >> 20 <NEWLINE> return r <NEWLINE> <DEDENT>
def test34 ( self ) : <NEWLINE> <INDENT> H = MutNodeSet <NEWLINE> e1 = [ ] <NEWLINE> class X ( H ) : <NEWLINE> <INDENT> def extend ( self , y ) : <NEWLINE> for e in y : <NEWLINE> <INDENT> self . append ( e ) <NEWLINE> <DEDENT> <DEDENT> s = X ( ) <NEWLINE> assert e1 not in s <NEWLINE> s . extend ( [ e1 ] ) <NEWLINE> assert e1 in s <NEWLINE> <DEDENT>
def generate_modes ( ) : <NEWLINE> <INDENT> for align_desc , align in [ ( <STRING> , pango . ALIGN_LEFT ) , <NEWLINE> <INDENT> ( <STRING> , pango . ALIGN_CENTER ) , ( <STRING> , pango . ALIGN_RIGHT ) ] : <NEWLINE> for extent_desc , extentindex in [ ( <STRING> , 1 ) , ( <STRING> , 0 ) ] : <NEWLINE> for name in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> if name == <STRING> and extent_desc == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> desc = <STRING> % ( align_desc , extent_desc , name ) <NEWLINE> yield extentindex , name , align , desc <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def __init__ ( self ) : <NEWLINE> <INDENT> oparser = OptionParser ( ) <NEWLINE> oparser . add_option ( <STRING> , <STRING> , dest = <STRING> <NEWLINE> <INDENT> help = <STRING> ) <NEWLINE> <DEDENT> ( self . opts , self . args ) = oparser . parse_args ( ) <NEWLINE> if not self . opts . dir : <NEWLINE> <INDENT> oparser . print_help ( ) <NEWLINE> sys . exit ( - 1 ) <NEWLINE> <DEDENT> self . loc = 0 <NEWLINE> self . checkFiles ( ) <NEWLINE> <DEDENT>
def __getMovieTitle ( sHtmlContent ) : <NEWLINE> <INDENT> sPattern = <STRING> <NEWLINE> oParser = cParser ( ) <NEWLINE> aResult = oParser . parse ( sHtmlContent , sPattern ) <NEWLINE> if ( aResult [ 0 ] == True ) : <NEWLINE> return str ( aResult [ 1 ] [ 0 ] ) . strip ( ) <NEWLINE> return False <NEWLINE> <DEDENT>
def _item_key_to_dict ( self , key ) : <NEWLINE> <INDENT> if utils . is_dict_like ( key ) : <NEWLINE> <INDENT> return key <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> key = indexing . expanded_indexer ( key , self . ndim ) <NEWLINE> return dict ( zip ( self . dims , key ) <NEWLINE> <DEDENT> <DEDENT>
def parse_DL ( self , indent ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> while self . parse_DI_helper ( indent ) : i = i + 1 <NEWLINE> if i == 0 : <NEWLINE> <INDENT> print <STRING> , sys . exit ( 1 ) <NEWLINE> <DEDENT> self . reduce ( DL , i , indent ) <NEWLINE> <DEDENT>
class MyModel ( gtkmvc3 . Model ) : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> age = 0 <NEWLINE> __observables__ = ( <STRING> , <STRING> ) <NEWLINE> def show ( self ) : print <STRING> , self . name , <STRING> , self . age <NEWLINE> pass <NEWLINE> <DEDENT>
def signal_handler ( signal , frame ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> if gaugeSocket : <NEWLINE> print ( <STRING> ) <NEWLINE> gaugeSocket . send ( str ( <STRING> ) ) <NEWLINE> gaugeSocket . close ( ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT>
def member_functioneelbeheerder_group ( user ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> functioneelbeheerder_groups = user . user_group_memberships . filter ( <NEWLINE> name__contains = <STRING> ) <NEWLINE> if functioneelbeheerder_groups . exists ( ) : <NEWLINE> return True <NEWLINE> return False <NEWLINE> <DEDENT>
class CppFileTest ( unittest2 . TestCase ) : <NEWLINE> <INDENT> def test ( self ) : <NEWLINE> comment_counter = __test_extension__ ( <STRING> , <STRING> ) <NEWLINE> self . assertEqual ( comment_counter , 25 ) <NEWLINE> <DEDENT>
class Address ( Base ) : <NEWLINE> <INDENT> __tablename__ = <STRING> <NEWLINE> id = Column ( Integer , primary_key = True ) <NEWLINE> email = Column ( String ( 60 ) ) <NEWLINE> worker_id = Column ( Integer , ForeignKey ( <STRING> ) <NEWLINE> user = relationship ( <STRING> , back_populates = <STRING> ) <NEWLINE> <DEDENT>
( _ ( <STRING> <NEWLINE> <DEDENT>
def matrix_multiply ( A , B ) : <NEWLINE> <INDENT> C = [ [ 0 ] * len ( B [ 0 ] ) for i in range ( len ( A ) ] <NEWLINE> for i in range ( A ) : <NEWLINE> <INDENT> for j in range ( len ( B [ 0 ] ) : <NEWLINE> <INDENT> for k in range ( len ( A ) ) : <NEWLINE> <INDENT> C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def splitChars ( s ) : <NEWLINE> <INDENT> temp = [ s [ i ] for i in range ( 0 , len ( s ) ) ] <NEWLINE> try : <NEWLINE> idx = temp . index ( <STRING> ) <NEWLINE> temp [ idx ] = <STRING> <NEWLINE> except : <NEWLINE> pass <NEWLINE> return temp <NEWLINE> <DEDENT>
def do_set ( self , line ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> if JmxCmd . jmxClient : <NEWLINE> <INDENT> JmxCmd . setArgs = line . split ( <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> if len ( JmxCmd . setArgs ) < 2 : <NEWLINE> <INDENT> raise SetAttributeError <NEWLINE> <DEDENT> JmxCmd . jmxClient . set ( JmxCmd . setArgs [ 0 ] , JmxCmd . setArgs [ 1 ] ) <NEWLINE> <DEDENT> except SetAttributeError : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def make_runtime_storage ( data , * generators ) : <NEWLINE> <INDENT> _add_generated_records ( data , * generators ) <NEWLINE> runtime_storage_inst = TestStorage ( data ) <NEWLINE> setattr ( web . app , <STRING> , None ) <NEWLINE> with mock . patch ( <STRING> <NEWLINE> <INDENT> <STRING> ) as get_runtime_storage_mock : <NEWLINE> get_runtime_storage_mock . return_value = runtime_storage_inst <NEWLINE> try : <NEWLINE> yield runtime_storage_inst <NEWLINE> finally : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>
def _absurl ( self url ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if len ( self . _incstack ) == 0 : <NEWLINE> <INDENT> return url <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return urlparse . urljoin ( self . geturl ( ) , url ) <NEWLINE> <DEDENT> <DEDENT>
dbh . execute ( <STRING> <STRING> <STRING> <NEWLINE> <INDENT> reference , ) ) <NEWLINE>
def run_rdfcat ( x , file ) : <NEWLINE> <INDENT> cmd = <STRING> + file + <STRING> <NEWLINE> output = Popen ( cmd , stderr = PIPE , shell = True ) <NEWLINE> errorCounter = 0 <NEWLINE> for line in output . stderr : <NEWLINE> <INDENT> if <STRING> in line : <NEWLINE> errorCounter = errorCounter + 1 <NEWLINE> <DEDENT> print ( <STRING> + str ( x ) + <STRING> + file + <STRING> + str ( errorCounter ) ) <NEWLINE> <DEDENT>
def cifarnet_arg_scope ( weight_decay = 0.004 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with slim . arg_scope ( <NEWLINE> <INDENT> [ slim . conv2d ] , <NEWLINE> weights_initializer = tf . truncated_normal_initializer ( stddev = 5e-2 ) , <NEWLINE> activation_fn = tf . nn . relu ) : <NEWLINE> with slim . arg_scope ( <NEWLINE> <INDENT> [ slim . fully_connected ] , <NEWLINE> biases_initializer = tf . constant_initializer ( 0.1 ) , <NEWLINE> weights_initializer = trunc_normal ( 0.04 ) , <NEWLINE> weights_regularizer = slim . l2_regularizer ( weight_decay ) , <NEWLINE> activation_fn = tf . nn . relu ) as sc : <NEWLINE> <DEDENT> return sc <NEWLINE> <DEDENT> <DEDENT>
def children ( cls , source = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> source = source or cls <NEWLINE> result = source . __subclasses__ ( ) <NEWLINE> for child in result : <NEWLINE> <INDENT> result . extend ( cls . children ( source = child ) <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT>
def set_freq ( self , target_freq ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> r = self . u . set_center_freq ( target_freq ) <NEWLINE> if r : <NEWLINE> <INDENT> self . myform [ <STRING> ] . set_value ( target_freq ) <NEWLINE> if self . show_debug_info : <NEWLINE> <INDENT> self . myform [ <STRING> ] . set_value ( r . baseband_freq ) <NEWLINE> self . myform [ <STRING> ] . set_value ( r . dxc_freq ) <NEWLINE> if not self . options . oscilloscope : <NEWLINE> self . scope . set_baseband_freq ( target_freq ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>
def install_exceptions ( module ) : <NEWLINE> <INDENT> for exception in ( Error , Warning , DatabaseError , InternalError , <NEWLINE> <INDENT> OperationalError , ProgrammingError , IntegrityError , <NEWLINE> DataError , NotSupportedError , InterfaceError ) : <NEWLINE> module_exception = getattr ( module , exception . __name__ , None ) <NEWLINE> if module_exception is not None : <NEWLINE> try : <NEWLINE> module_exception . __bases__ += ( exception , ) <NEWLINE> except TypeError : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>
def get ( self , key ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return self . __getProxy ( ) . get ( self . __convertKey ( key ) ) <NEWLINE> <DEDENT> except redis . exceptions . ConnectionError , e : <NEWLINE> <INDENT> return self . __getProxy ( ) . get ( self . __convertKey ( key ) ) <NEWLINE> <DEDENT> <DEDENT>
def testShowNoProduct ( self ) : <NEWLINE> <INDENT> handle = self . handle <NEWLINE> mock . mockMethod ( handle . facade . rbuilder . getImages ) <NEWLINE> mock . mockMethod ( handle . Images . _getProductStage ) <NEWLINE> handle . Images . _getProductStage . _mock . raiseErrorOnAccess ( <NEWLINE> <INDENT> errors . MissingProductStoreError ( path = <STRING> ) <NEWLINE> <DEDENT> self . assertRaises ( errors . MissingProductStoreError , <NEWLINE> <INDENT> handle . Images . delete , 10 ) <NEWLINE> <DEDENT> handle . facade . rbuilder . getImages . _mock . assertNotCalled ( ) <NEWLINE> <DEDENT>
def test_getargspec_sublistofone ( self ) : <NEWLINE> <INDENT> with check_py3k_warnings ( <NEWLINE> <INDENT> ( <STRING> , SyntaxWarning ) , <NEWLINE> ( <STRING> , SyntaxWarning ) ) : <NEWLINE> exec <STRING> <NEWLINE> self . assertArgSpecEquals ( sublistOfOne , [ [ <STRING> ] ] ) <NEWLINE> exec <STRING> <NEWLINE> self . assertArgSpecEquals ( fakeSublistOfOne , [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT>
def projectID ( con , project ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> cursor = con . cursor ( ) <NEWLINE> query = <STRING> <NEWLINE> cursor . execute ( query , ( project , ) ) ) <NEWLINE> rows = cursor . fetchall ( ) <NEWLINE> id = 0 <NEWLINE> for row in rows : <NEWLINE> <INDENT> id = int ( row [ 0 ] ) <NEWLINE> <DEDENT> return id <NEWLINE> <DEDENT>
def gamma11_B_910 ( f ) : <NEWLINE> <INDENT> if f != 5 : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> return np . array ( [ [ <NEWLINE> - ( ( 8 ) / ( 9 ) ) , 0 <NEWLINE> <DEDENT>
def _log_etree_elem ( elem , level = logging . DEBUG ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if log . getEffectiveLevel ( ) <= level : <NEWLINE> <INDENT> log . debug ( ET . tostring ( elem ) <NEWLINE> <DEDENT> <DEDENT>
def ramp_down ( self , temperature ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> + str ( temperature ) + <STRING> ) <NEWLINE> self . set_temp ( temperature ) <NEWLINE> time . sleep ( 0.1 ) <NEWLINE> current_temp = self . get_temp ( ) <NEWLINE> time . sleep ( 0.1 ) <NEWLINE> while current_temp != temperature : <NEWLINE> current_temp = self . get_temp ( ) <NEWLINE> <DEDENT>
def handle_noargs ( self , ** options ) : <NEWLINE> <INDENT> self . set_options ( ** options ) <NEWLINE> if ( isinstance ( self . storage , FileSystemStorage ) and <NEWLINE> <INDENT> self . storage . location ) : <NEWLINE> destination_path = self . storage . location <NEWLINE> destination_display = <STRING> % destination_path <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> destination_path = None <NEWLINE> destination_display = <STRING> <NEWLINE> <DEDENT> if self . clear : <NEWLINE> <INDENT> clear_display = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> clear_display = <STRING> <NEWLINE> <DEDENT> if self . interactive : <NEWLINE> <INDENT> confirm = input ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
def check_docstring_missing ( self , definition , docstring ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( not docstring and definition . is_public or <NEWLINE> <INDENT> docstring and is_blank ( eval ( docstring ) ) ) : <NEWLINE> codes = { Module : <STRING> , Class : <STRING> , NestedClass : <STRING> , <NEWLINE> <INDENT> Method : <STRING> , Function : <STRING> , NestedFunction : <STRING> } <NEWLINE> return Error ( <STRING> % codes [ type ( definition ) ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def propagate_queries ( settings , db , requests_session ) : <NEWLINE> <INDENT> entity_statuses = settings [ <STRING> ] [ <STRING> ] <NEWLINE> dbc = db . execute ( <STRING> ) <NEWLINE> for r in dbc . fetchall ( ) : <NEWLINE> <INDENT> db . execute ( <STRING> % ( <NEWLINE> <DEDENT> r [ <STRING> ] <NEWLINE> <DEDENT>
def got_addr ( self , ( host , port ) , services , timestamp ) : <NEWLINE> <INDENT> if ( host , port ) in self . addr_store : <NEWLINE> <INDENT> old_services , old_first_seen , old_last_seen = self . addr_store [ host , port ] <NEWLINE> self . addr_store [ host , port ] = services , old_first_seen , max ( old_last_seen , timestamp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( self . addr_store ) < 10000 : <NEWLINE> <INDENT> self . addr_store [ host , port ] = services , timestamp , timestamp <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def convert ( self , ( r , g , b ) ) : <NEWLINE> <INDENT> i = self . inxsearch ( r , g , b ) <NEWLINE> return self . colormap [ i , : 3 ] <NEWLINE> <DEDENT>
def getlanguage ( self , sCode ) : <NEWLINE> <INDENT> if ( self . __bIsDharma ) : <NEWLINE> <INDENT> return self . __aLanguage ( sCode ) . encode ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> return xbmc . getLocalizedString ( sCode ) . encode ( <STRING> ) <NEWLINE> except : <NEWLINE> return <STRING> <NEWLINE> <DEDENT> <DEDENT>
def merge ( self , other ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> other . qualify ( ) <NEWLINE> for n in ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> if getattr ( self , n ) is not None : <NEWLINE> continue <NEWLINE> v = getattr ( other , n ) <NEWLINE> if v is None : <NEWLINE> continue <NEWLINE> setattr ( self , n , v ) <NEWLINE> <DEDENT> <DEDENT>
def save ( self ) : <NEWLINE> <INDENT> oConfig = CNBConfig . getInstance ( ) <NEWLINE> sFile = oConfig . get ( <STRING> , <STRING> ) + self . TRIVIA_SAVE_FILE <NEWLINE> aObj = { <STRING> : self . curQtId , <STRING> : self . startDateTime , <STRING> : self . beginDateTime , <STRING> : self . qtDateTime , <STRING> : self . autoSave , <NEWLINE> self . log . info ( <STRING> + sFile ) <NEWLINE> pickle . dump ( aObj , open ( sFile , <STRING> ) ) <NEWLINE> return <STRING> <NEWLINE> <DEDENT>
def GypNotSet ( cls flag ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return functools . partial ( cls . _GypNotSet , flag ) <NEWLINE> <DEDENT>
def __init__ ( self , uiApplication ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> rlapp = [ app for app in uiApplication . LoadedApplications <NEWLINE> <INDENT> if app . GetType ( ) . Namespace == <STRING> <NEWLINE> and app . GetType ( ) . Name == <STRING> ] [ 0 ] <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> self . RevitLookup = None <NEWLINE> return <NEWLINE> <DEDENT> clr . AddReference ( rlapp . GetType ( ) . Assembly ) <NEWLINE> import RevitLookup <NEWLINE> self . RevitLookup = RevitLookup <NEWLINE> self . RevitLookup . Snoop . CollectorExts . CollectorExt . m_app = uiApplication <NEWLINE> self . revit = uiApplication <NEWLINE> <DEDENT>
def collect_bears_by_aspects ( aspects , kinds ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> all_bears = get_all_bears ( ) <NEWLINE> bears_found = tuple ( [ ] for i in range ( len ( kinds ) ) ) <NEWLINE> for aspect in aspects . get_leaf_aspects ( ) : <NEWLINE> <INDENT> for bear in all_bears : <NEWLINE> <INDENT> if ( aspect in bear . aspects [ <STRING> ] or <NEWLINE> <INDENT> aspect in bear . aspects [ <STRING> ] ) : <NEWLINE> index = kinds . index ( _get_kind ( bear ) ) <NEWLINE> if bear not in bears_found [ index ] : <NEWLINE> bears_found [ index ] . append ( bear ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return bears_found <NEWLINE> <DEDENT>
def ligand_validation_metrics_gui_list_wrapper ( stats_list ) : <NEWLINE> <INDENT> ls = ligand_stats ( ) <NEWLINE> for metric in stats_list : <NEWLINE> metric_name = metric [ 0 ] <NEWLINE> percentile = metric [ 1 ] <NEWLINE> value = metric [ 2 ] <NEWLINE> ls . add_metric ( metric_name , percentile , value ) <NEWLINE> ligand_validation_metrics_gui ( ls ) <NEWLINE> <DEDENT>
def test_ac_linear_constraints ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . opf . dc = False <NEWLINE> om = self . opf . _construct_opf_model ( self . case ) <NEWLINE> A , l , u = om . linear_constraints ( ) <NEWLINE> self . assertEqual ( A , None ) <NEWLINE> self . assertEqual ( l . shape , ( 0 , ) <NEWLINE> self . assertEqual ( u . shape , ( 0 , ) ) <NEWLINE> <DEDENT>
def centre_blit ( screen , img , ( cx , cy ) , angle = 0 ) : <NEWLINE> <INDENT> img1 = img <NEWLINE> if angle != 0 : <NEWLINE> <INDENT> img1 = pygame . transform . rotate ( img , - angle ) <NEWLINE> <DEDENT> rect = img1 . get_rect ( ) <NEWLINE> screen . blit ( img1 , ( cx - rect . width / 2 , cy - rect . height / 2 ) ) <NEWLINE> <DEDENT>
( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
class JSONStringDownload ( StringDownload , WorkerAPICompatMixin ) : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> def __init__ ( self , o , workerdest = None , <NEWLINE> <INDENT> slavedest = None , <NEWLINE> ** buildstep_kwargs ) : <NEWLINE> if slavedest is not None : <NEWLINE> reportDeprecatedWorkerNameUsage ( <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> assert workerdest is None <NEWLINE> workerdest = slavedest <NEWLINE> if workerdest is None : <NEWLINE> raise TypeError ( <STRING> ) <NEWLINE> if <STRING> in buildstep_kwargs : <NEWLINE> del buildstep_kwargs [ <STRING> ] <NEWLINE> s = json . dumps ( o ) <NEWLINE> StringDownload . __init__ ( <NEWLINE> self , s = s , workerdest = workerdest , ** buildstep_kwargs ) <NEWLINE> <DEDENT> <DEDENT>
class Logger ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , <NEWLINE> <INDENT> name = __name__ , <NEWLINE> logfile = <STRING> ) : <NEWLINE> <STRING> <NEWLINE> if hasattr ( Logger , <STRING> ) : <NEWLINE> self . logger = Logger . logger <NEWLINE> self . logger . debug ( <STRING> ) <NEWLINE> return <NEWLINE> formatstr = <STRING> <STRING> <NEWLINE> logging . basicConfig ( <NEWLINE> level = logging . DEBUG , <NEWLINE> format = formatstr , <NEWLINE> datefmt = <STRING> , <NEWLINE> filename = logfile , <NEWLINE> filemode = <STRING> ) <NEWLINE> self . logger = logging . getLogger ( name ) <NEWLINE> Logger . logger = self . logger <NEWLINE> <DEDENT> <DEDENT>
def makeFileToSort ( fileName , lines = 10 , maxLineLength = 10 ) : <NEWLINE> <INDENT> fileHandle = open ( fileName , <STRING> ) <NEWLINE> for line in xrange ( lines ) : <NEWLINE> <INDENT> fileHandle . write ( getRandomLine ( maxLineLength ) ) ) <NEWLINE> <DEDENT> fileHandle . close ( ) <NEWLINE> <DEDENT>
( <STRING> , <NEWLINE> for x in args : <NEWLINE> <INDENT> print ( x , ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> usage ( ) ; <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> usage ( ) <NEWLINE> <DEDENT> <DEDENT>
def _RunJUnitTests ( args ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> runner_factory , tests = junit_setup . Setup ( args ) <NEWLINE> results , exit_code = junit_dispatcher . RunTests ( tests , runner_factory ) <NEWLINE> report_results . LogFull ( <NEWLINE> <INDENT> results = results <NEWLINE> test_type = <STRING> , <NEWLINE> test_package = args . test_suite ) <NEWLINE> <DEDENT> if args . json_results_file : <NEWLINE> <INDENT> json_results . GenerateJsonResultsFile ( results , args . json_results_file ) <NEWLINE> <DEDENT> return exit_code <NEWLINE> <DEDENT>
def initialize ( self ) : <NEWLINE> <INDENT> NormalTUISpoke . initialize ( self ) <NEWLINE> for f in [ <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> ] : <NEWLINE> try : <NEWLINE> os . symlink ( <STRING> + f , <STRING> + f ) <NEWLINE> except OSError : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>
def encode_sentence_batch ( self , sentence_array ) : <NEWLINE> <INDENT> vectors_array = [ ] <NEWLINE> for sentence in sentence_array : <NEWLINE> vectors_array . append ( self . encode_sentence ( sentence ) ) <NEWLINE> return vectors_array <NEWLINE> <DEDENT>
def retranslateUi ( self , Dialog ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> Dialog . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . label . setText ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
from django . template import RequestContext <NEWLINE> from django . shortcuts import render_to_response <NEWLINE> from django . http import HttpResponse <NEWLINE> from analytics . models VitalsAnalytics <NEWLINE> from analytics . models PatientAnalytic <NEWLINE>
( self . _fmt % { <NEWLINE> <INDENT> <STRING> : part . get_content_type ( ) , <NEWLINE> <STRING> : part . get_content_maintype ( ) , <NEWLINE> <STRING> : part . get_content_subtype ( ) , <NEWLINE> <STRING> : part . get_filename ( <STRING> ) , <NEWLINE> <STRING> : part . get ( <STRING> , <NEWLINE> <INDENT> <STRING> ) , <NEWLINE> <DEDENT> <STRING> : part . get ( <STRING> , <NEWLINE> <INDENT> <STRING> ) , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def saveAnimationVideo ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> filename = <STRING> . format ( <NEWLINE> <INDENT> self . shot , <NEWLINE> np . int ( self . tmin * 1e3 ) <NEWLINE> <DEDENT> writer = animation . FFMpegWriter ( fps = 30 , <NEWLINE> <INDENT> bitrate = 1e5 ) <NEWLINE> <DEDENT> self . animation . save ( filename , writer = writer ) <NEWLINE> <DEDENT>
def languageChange ( self ) : <NEWLINE> <INDENT> self . setCaption ( self . __tr ( <STRING> ) ) <NEWLINE> self . CancelButton . setText ( self . __tr ( <STRING> ) ) <NEWLINE> self . ContinueButton . setText ( self . __tr ( <STRING> ) ) <NEWLINE> self . buttonGroup . setTitle ( QString . null ) <NEWLINE> self . textLabel2_2 . setText ( self . __tr ( <STRING> <NEWLINE> <DEDENT>
def on_post_save ( self , view ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if check_linting ( <NEWLINE> <INDENT> view , NOT_SCRATCH | LINTING_ENABLED , code = self . lang . lower ( ) ) : <NEWLINE> if self . lang in view . settings ( ) . get ( <STRING> ) : <NEWLINE> if get_settings ( <NEWLINE> <INDENT> view , <STRING> , False ) : <NEWLINE> self . run_linter ( view , self . _show_errors_list ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . run_linter ( view ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> self . _erase_marks_if_no_linting ( view ) <NEWLINE> <DEDENT> <DEDENT>
class Test_GUI ( TestCase ) : <NEWLINE> <INDENT> def basic_run_test ( self : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
def _wd ( obj , filename , dirname , comment = <STRING> ) : <NEWLINE> <INDENT> if obj : <NEWLINE> <INDENT> import os . path <NEWLINE> if os . path . isdir ( dirname ) : <NEWLINE> <INDENT> if os . path . exists ( os . path . join ( filename , dirname ) : <NEWLINE> <INDENT> raise OSError ( <STRING> ) <NEWLINE> <DEDENT> with open ( os . path . join ( dirname , filename ) , <STRING> ) as f : <NEWLINE> <INDENT> write_hlines ( f ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> raise TypeError ( <STRING> ) <NEWLINE> <DEDENT>
def test_offset_commit ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with self . _get_simple_consumer ( <NEWLINE> <INDENT> consumer_group = <STRING> ) as consumer : <NEWLINE> [ consumer . consume ( ) for _ in xrange ( 100 ) ] <NEWLINE> offsets_committed = self . _currently_held_offsets ( consumer ) <NEWLINE> consumer . commit_offsets ( ) <NEWLINE> offsets_fetched = dict ( ( r [ 0 ] , r [ 1 ] . offset ) <NEWLINE> <INDENT> for r in consumer . fetch_offsets ( ) ) <NEWLINE> self . assertEquals ( offsets_fetched , offsets_committed ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def perform ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> with MySQLdb . connect ( db = <STRING> , user = <STRING> , host = <STRING> , <NEWLINE> <INDENT> cursorclass = SSDictCursor ) as cursor : <NEWLINE> cursor . execute ( str ( self ) ) <NEWLINE> for row in cursor : <NEWLINE> yield row <NEWLINE> <DEDENT> <DEDENT> except MySQLdb . OperationalError as err : <NEWLINE> <INDENT> if <STRING> in str ( err ) : <NEWLINE> <INDENT> self . ssh_tunnel_usage ( ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_slack_post_message_failed_cached ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with mock . patch . object ( slack_notifier . SlackNotifier , <NEWLINE> <INDENT> <STRING> , <NEWLINE> [ <STRING> ] ) : <NEWLINE> response_list = [ RequestsResponse ( 200 , <STRING> , <NEWLINE> <INDENT> { <STRING> : <STRING> } ) ] <NEWLINE> mock_method , result = self . _notify ( response_list ) <NEWLINE> self . assertFalse ( result ) <NEWLINE> mock_method . assert_called_once ( ) <NEWLINE> self . _validate_post_args ( mock_method . call_args_list [ 0 ] [ 1 ] , <STRING> ) <NEWLINE> self . assertEqual ( [ <STRING> ] , <NEWLINE> slack_notifier . SlackNotifier . _raw_data_url_caches ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def index ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return [ { <NEWLINE> <INDENT> <STRING> : name <NEWLINE> <STRING> : plugin . url_for ( slug ) <NEWLINE> <DEDENT> } for slug , name in api . get_path ( <STRING> ) ] <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> <INDENT> plugin . log . error ( e , exc_info = 1 ) <NEWLINE> plugin . notify ( plugin . get_string ( 32003 ) % e . message ) <NEWLINE> <DEDENT> <DEDENT>
def get_bin_size_data ( file ) : <NEWLINE> <INDENT> data = <STRING> <NEWLINE> try : <NEWLINE> <INDENT> data = subprocess . check_output ( [ <STRING> , <STRING> , <STRING> , file ] , stderr = subprocess . STDOUT ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> data = e . output <NEWLINE> <DEDENT> res = re . split ( <STRING> , data . split ( <STRING> ) [ - 2 ] ) <NEWLINE> if len ( res [ 0 ] . strip ( ) ) == 0 : <NEWLINE> <INDENT> return res [ 1 : - 3 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return res [ : - 3 ] <NEWLINE> <DEDENT> <DEDENT>
def test00 ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> tag = Tag ( 77 , 13 , 4 , 5 , 90 , True ) <NEWLINE> self . assertCoincide ( tag . originAt ( 3 ) , Vector ( 77 , 13 , 3 ) <NEWLINE> <DEDENT>
def putline ( self , line ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> line = line + CRLF <NEWLINE> if self . debugging > 1 : print <STRING> , repr ( line ) <NEWLINE> self . sock . sendall ( line ) <NEWLINE> <DEDENT>
def populateComboBox ( self ) : <NEWLINE> <INDENT> servers = [ ] <NEWLINE> servers . append ( <STRING> ) <NEWLINE> <INDENT> servers . append ( <STRING> ) <NEWLINE> <DEDENT> self . connectionDialogui . comboBoxPredef . addItems ( servers ) <NEWLINE> <DEDENT>
def start ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> DEBUG = GLOBAL_DEBUG and True <NEWLINE> if DEBUG : print <STRING> <NEWLINE> self . state [ <STRING> ] = False <NEWLINE> self . state [ <STRING> ] = randint ( 0 , 0xFFFFFFFF ) <NEWLINE> self . state [ <STRING> ] = [ <STRING> ] * SZ_SCRATCH <NEWLINE> self . state [ <STRING> ] = open ( os . path . join ( os . path . dirname ( os . path . realpath ( __file__ ) ) , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> ) , <STRING> ) . read ( ) <NEWLINE> <DEDENT> <DEDENT>
class NetworkManagementClientConfiguration ( AzureConfiguration ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( <NEWLINE> <INDENT> self , credentials , subscription_id , base_url = None ) : <NEWLINE> if credentials is None : <NEWLINE> raise ValueError ( <STRING> ) <NEWLINE> if subscription_id is None : <NEWLINE> raise ValueError ( <STRING> ) <NEWLINE> if not base_url : <NEWLINE> base_url = <STRING> <NEWLINE> super ( NetworkManagementClientConfiguration , self ) . __init__ ( base_url ) <NEWLINE> self . add_user_agent ( <STRING> . format ( VERSION ) ) <NEWLINE> self . add_user_agent ( <STRING> ) <NEWLINE> self . credentials = credentials <NEWLINE> self . subscription_id = subscription_id <NEWLINE> <DEDENT> <DEDENT>
def feed_data ( self , data , size ) : <NEWLINE> <INDENT> has_waiter = self . _waiter is not None and not self . _waiter . cancelled ( ) <NEWLINE> super ( ) . feed_data ( data , size ) <NEWLINE> if ( not self . _stream . paused and <NEWLINE> <INDENT> not has_waiter and self . _size > self . _limit ) : <NEWLINE> try : <NEWLINE> self . _stream . transport . pause_reading ( ) <NEWLINE> except ( AttributeError , NotImplementedError ) : <NEWLINE> pass <NEWLINE> else : <NEWLINE> self . _stream . paused = True <NEWLINE> <DEDENT> <DEDENT>
class Clade ( BaseTree . Clade ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , branch_length = 1.0 , name = None , clades = None , <NEWLINE> <INDENT> confidence = None , comment = None , ** kwargs ) : <NEWLINE> BaseTree . Clade . __init__ ( self , branch_length = branch_length , <NEWLINE> <INDENT> name = name , clades = clades , confidence = confidence ) <NEWLINE> self . comment = comment <NEWLINE> for key , value in kwargs . items ( ) : <NEWLINE> setattr ( self , key , value ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
( c . join ( [ str ( a [ x ] ) , str ( b [ x ] ) , str ( c [ x ] ) , str ( d [ x ] ) ] + <STRING> ) <NEWLINE> <DEDENT> for x in range ( 1000 ) : <NEWLINE> <INDENT> print ( iplist [ x ] ) <NEWLINE> <DEDENT>
def get_va_id_from_recid_and_nameid ( bibrec , authornamesid ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> va_ids = set ( ) <NEWLINE> for possible_va_id in [ row [ <STRING> ] for row in dat . VIRTUALAUTHORS <NEWLINE> <INDENT> if row [ <STRING> ] == authornamesid ] : <NEWLINE> for va_id in [ row [ <STRING> ] for row in dat . VIRTUALAUTHOR_DATA <NEWLINE> if ( ( row [ <STRING> ] == possible_va_id ) and <NEWLINE> ( row [ <STRING> ] == <STRING> ) and <NEWLINE> ( row [ <STRING> ] == bibrec ) ) ] : <NEWLINE> va_ids . add ( va_id ) <NEWLINE> <DEDENT> return list ( va_ids ) <NEWLINE> <DEDENT>
def test_with_short_kwargs ( self ) : <NEWLINE> <INDENT> with self . _args_test ( [ 0 , 1 , 2 ] , [ 0 , 1 , 8 ] , <NEWLINE> <INDENT> i = [ 0 , 1 ] , i2 = [ 0 , 1 , 4 ] ) as dummy : <NEWLINE> for i in range ( 2 ) : <NEWLINE> dummy . do_step ( 1 , i , i * i , i = i , i2 = i * i ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , APP_PUBLIC_KEY , APP_PRIVATE_KEY ) : <NEWLINE> <INDENT> if isinstance ( APP_PUBLIC_KEY , basestring ) : <NEWLINE> <INDENT> public_key_long = long ( APP_PUBLIC_KEY , 16 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> public_key_long = APP_PUBLIC_KEY <NEWLINE> <DEDENT> if isinstance ( APP_PRIVATE_KEY , basestring ) : <NEWLINE> <INDENT> private_key_long = long ( APP_PRIVATE_KEY , 16 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> private_key_long = APP_PRIVATE_KEY <NEWLINE> <DEDENT> rsa_n_bit_length = 2048 <NEWLINE> self . em = ( rsa_n_bit_length + 7 ) / 8 <NEWLINE> exponent = 65537 l <NEWLINE> self . private_key = RSA . construct ( ( public_key_long , exponent , private_key_long ) ) <NEWLINE> <DEDENT>
( <STRING> <NEWLINE> <DEDENT>
def testForceGPU ( self ) : <NEWLINE> <INDENT> with self . assertRaisesRegexp ( errors . InvalidArgumentError , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> with self . test_session ( force_gpu = True ) : <NEWLINE> x = [ True ] <NEWLINE> y = [ 15 ] <NEWLINE> logging_ops . Assert ( x , y ) . run ( ) <NEWLINE> <DEDENT> <DEDENT>
def test_del_components_success ( self ) : <NEWLINE> <INDENT> with patch ( <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> ) as m_del_object : <NEWLINE> self . result = self . target . del_components ( <STRING> ) <NEWLINE> self . assertEqual ( m_del_object . call_count , 1 ) <NEWLINE> m_del_object . assert_any_call ( SystemManagerInterface . <NEWLINE> <INDENT> COMP_PATH % <STRING> ) <NEWLINE> self . assertNotEqual ( self . result , None ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def docs ( ) : <NEWLINE> <INDENT> sort_docs = <STRING> . join ( sorted ( [ <STRING> . join ( ( <STRING> + k + <STRING> , v ) for k , v in hmserv . sort_docs . items ( ) ] ) ) <NEWLINE> base_url = <STRING> + request . host <NEWLINE> page = <STRING> . format ( prov_url = base_url + ext_path + <STRING> , <NEWLINE> <INDENT> explore_url = base_url + ext_path + <STRING> , <NEWLINE> sort_docs = sort_docs ) <NEWLINE> <DEDENT> return page <NEWLINE> <DEDENT>
def validate ( data ) : <NEWLINE> <INDENT> data = data . lower ( ) <NEWLINE> print ( data ) <NEWLINE> if data . startswith ( <STRING> ) : <NEWLINE> <INDENT> cmd_type = <STRING> <NEWLINE> <INDENT> return bool ( insertValidator . match ( data ) ) <NEWLINE> <DEDENT> <DEDENT> if data . startswith ( <STRING> ) : <NEWLINE> <INDENT> cmd_type = <STRING> <NEWLINE> <INDENT> return bool ( selectValidator . match ( data ) ) <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>
def getNamed ( type , name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for t in ptextures [ type ] : <NEWLINE> if t . getName ( ) == name : <NEWLINE> <INDENT> return t <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>
def _GetDebugInfoPostbuilds ( self , configname , output , output_binary , quiet ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . configname = configname <NEWLINE> result = [ ] <NEWLINE> if ( self . _Test ( <STRING> , <STRING> , default = <STRING> ) and <NEWLINE> <INDENT> self . _Test ( <NEWLINE> <INDENT> <STRING> , <STRING> , default = <STRING> ) and <NEWLINE> <DEDENT> self . spec [ <STRING> ] != <STRING> ) : <NEWLINE> if not quiet : <NEWLINE> result . append ( <STRING> % self . spec [ <STRING> ] ) <NEWLINE> result . append ( <STRING> % ( output_binary , output + <STRING> ) ) <NEWLINE> <DEDENT> self . configname = None <NEWLINE> return result <NEWLINE> <DEDENT>
class AutoRestParameterFlatteningConfiguration ( Configuration ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( <NEWLINE> <INDENT> self , base_url = None ) : <NEWLINE> if not base_url : <NEWLINE> base_url = <STRING> <NEWLINE> super ( AutoRestParameterFlatteningConfiguration , self ) . __init__ ( base_url ) <NEWLINE> self . add_user_agent ( <STRING> . format ( VERSION ) ) <NEWLINE> <DEDENT> <DEDENT>
class TestMl2BulkToggleWithoutBulkless ( Ml2PluginV2TestCase ) : <NEWLINE> <INDENT> _mechanism_drivers = [ <STRING> , <STRING> ] <NEWLINE> def test_bulk_enabled_with_bulk_drivers ( self ) <NEWLINE> <INDENT> self . assertFalse ( self . _skip_native_bulk ) <NEWLINE> <DEDENT> <DEDENT>
def _map_trans ( ( ds , img , ylo , yhi ) ) : <NEWLINE> <INDENT> print ( <STRING> , os . getpid ( ) ) <NEWLINE> return ds . _computeTransformation ( img , ylo , yhi ) <NEWLINE> <DEDENT>
def init_1wire ( ) : <NEWLINE> <INDENT> cmd = <STRING> <NEWLINE> for outline in os . popen ( cmd ) . readlines ( ) <NEWLINE> <INDENT> outline = outline [ : - 1 ] ; <NEWLINE> print ( outline ) <NEWLINE> <DEDENT> <DEDENT>
def htmlBalloonTallyRow ( party , who ) : <NEWLINE> <INDENT> candidate = reader . candidates [ <STRING> ] [ party ] [ who [ <STRING> ] ] <NEWLINE> return <STRING> % ( <NEWLINE> formatNumber ( who [ <STRING> ] ) , <NEWLINE> candidate [ <STRING> ] , <NEWLINE> iconBaseUrl + who [ <STRING> ] + <STRING> , <NEWLINE> candidate [ <STRING> ] <NEWLINE> <DEDENT>
def analyzeHTMLText ( doc , resource , p , section , id ) : <NEWLINE> <INDENT> words = 0 <NEWLINE> try : <NEWLINE> content = p . content <NEWLINE> words = words + addStringHTML ( content , resource , id , section , 5 ) <NEWLINE> except : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> return words <NEWLINE> <DEDENT>
def setup_frame_w_accel_label ( txt , target_widget = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> l = gtk . Label ( txt ) <NEWLINE> l . set_use_underline ( True ) <NEWLINE> f = gtk . Frame ( ) <NEWLINE> f . set_label_widget ( l ) ; l . show ( ) <NEWLINE> if target_widget : <NEWLINE> l . set_mnemonic_widget ( target_widget ) <NEWLINE> return f <NEWLINE> <DEDENT>
def deploy ( ) : <NEWLINE> <INDENT> with lcd ( <STRING> ) <NEWLINE> <INDENT> local ( <STRING> ) <NEWLINE> local ( <STRING> ) <NEWLINE> local ( <STRING> ) <NEWLINE> local ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class AutoRestSwaggerBATServiceConfiguration ( Configuration ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( <NEWLINE> <INDENT> self , base_url = None ) : <NEWLINE> if not base_url : <NEWLINE> base_url = <STRING> <NEWLINE> super ( AutoRestSwaggerBATServiceConfiguration , self ) . __init__ ( base_url ) <NEWLINE> self . add_user_agent ( <STRING> . format ( VERSION ) ) <NEWLINE> <DEDENT> <DEDENT>
def usermgt_sendmail ( to_users , key ) : <NEWLINE> <INDENT> send_mail ( <STRING> , <STRING> % ( DOMAIN_NAME , key ) <NEWLINE> <INDENT> EMAIL_HOST_USER , to_users ) <NEWLINE> <DEDENT> thread . exit_thread ( ) <NEWLINE> <DEDENT>
def IsSupported ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( self . operating_system == OperatingSystem . CYGWIN and <NEWLINE> <INDENT> self . architecture == Architecture . x86_64 ) : <NEWLINE> sys . stderr . write ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT>
class GroupMember ( db . Model ) : <NEWLINE> <INDENT> name = db . StringProperty ( ) <NEWLINE> group = db . StringProperty ( ) <NEWLINE> def todict ( s , d ) : <NEWLINE> d [ <STRING> ] = s . name <NEWLINE> d [ <STRING> ] = s . group <NEWLINE> <DEDENT>
def check_command_line_args ( ) : <NEWLINE> <INDENT> if len ( sys . argv ) < 3 : <NEWLINE> print_usage_and_exit ( ) <NEWLINE> if not os . path . isfile ( sys . argv [ 1 ] ) : <NEWLINE> <INDENT> print_err ( <STRING> + sys . argv [ 1 ] + <STRING> ) <NEWLINE> print_usage_and_exit ( ) <NEWLINE> <DEDENT> if not is_number ( sys . argv [ 2 ] ) : <NEWLINE> <INDENT> print_err ( <STRING> + sys . argv [ 2 ] + <STRING> ) <NEWLINE> print_usage_and_exit ( ) <NEWLINE> <DEDENT> return sys . argv [ 1 ] , float ( sys . argv [ 2 ] ) <NEWLINE> <DEDENT>
def __setstate__ ( self , ( subject , items ) ) : <NEWLINE> <INDENT> self . clear ( ) <NEWLINE> self . update ( dict ( items ) ) <NEWLINE> self . subject = mkRef ( subject ) <NEWLINE> <DEDENT>
def judge ( self , ( share_count , weights_list , total_weight , total_donation_weight ) , ( max_shares , desired_weight ) ) : <NEWLINE> <INDENT> if share_count > max_shares or total_weight > desired_weight : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif share_count == max_shares or total_weight == desired_weight : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT>
def mult_matrix ( ( a1 , b1 , c1 , d1 , e1 , f1 ) , ( a0 , b0 , c0 , d0 , e0 , f0 ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return ( a0 * a1 + c0 * b1 , b0 * a1 + d0 * b1 , <NEWLINE> <INDENT> a0 * c1 + c0 * d1 , b0 * c1 + d0 * d1 , <NEWLINE> a0 * e1 + c0 * f1 + e0 , b0 * e1 + d0 * f1 + f0 ) <NEWLINE> <DEDENT> <DEDENT>
def pinEntered ( self , result4 ) : <NEWLINE> <INDENT> if result4 is None : <NEWLINE> <INDENT> self . closeProtectedScreen ( ) <NEWLINE> <DEDENT> elif not result4 : <NEWLINE> <INDENT> self . session . openWithCallback ( self . close ( ) , MessageBox , _ ( <STRING> ) , MessageBox . TYPE_ERROR , timeout = 3 ) <NEWLINE> <INDENT> else : <NEWLINE> <INDENT> self . checkNetworkState ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def VerifyEditablePaths ( cls , paths ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for doc in appdata . documents : <NEWLINE> <INDENT> for p in doc . paths : <NEWLINE> <INDENT> if p in paths : <NEWLINE> <INDENT> Notify ( cls . msg_cantedit . format ( p ) <NEWLINE> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT>
def initialize ( self , test_path = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . nfail = 0 <NEWLINE> os . system ( <STRING> ) <NEWLINE> ret_val = subprocess . Popen ( [ <STRING> , <STRING> ] , cwd = <STRING> % ( test_path ) ) <NEWLINE> ret_val . communicate ( ) <NEWLINE> if ret_val . returncode != 0 : <NEWLINE> self . nfail += 1 <NEWLINE> logging . info ( <STRING> ) <NEWLINE> <DEDENT>
def calculate_rmsd_for_atoms ( self , at1 , at2 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> rmsd_mat = at1 - at2 <NEWLINE> rmsd_mat = rmsd_mat ** 2 <NEWLINE> return rmsd_mat <NEWLINE> <DEDENT> <DEDENT>
class complex ( multicast ) : <NEWLINE> <INDENT> def send ( self , data ) : <NEWLINE> import pickle <NEWLINE> multicast . send ( self , pickle . dumps ( data ) ) <NEWLINE> def recvfrom ( self , size ) : <NEWLINE> d , sender = multicast . recvfrom ( self , size ) <NEWLINE> try : <NEWLINE> <INDENT> import pickle <NEWLINE> return pickle . loads ( d ) , sender <NEWLINE> except : <NEWLINE> return d , sender <NEWLINE> <DEDENT> <DEDENT>
class CreateAndDeleteStack ( utils . HeatScenario ) : <NEWLINE> <INDENT> def run ( self , template_path , parameters = None , <NEWLINE> <INDENT> files = None , environment = None ) : <NEWLINE> <STRING> <NEWLINE> stack = self . _create_stack ( template_path , parameters , <NEWLINE> <INDENT> files , environment ) <NEWLINE> self . _delete_stack ( stack ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def _give_missions ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> world = self . game . world <NEWLINE> missions = create_missions ( world ) <NEWLINE> random . shuffle ( missions ) <NEWLINE> for p in world . players . itervalues ( ) : <NEWLINE> p . mission = missions . pop ( ) <NEWLINE> <DEDENT>
def can_bind ( host , port ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) <NEWLINE> s . bind ( ( host , port ) <NEWLINE> s . close ( ) <NEWLINE> <DEDENT> except socket . error : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT>
def get_timezone ( name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not _tzdict . has_key ( name ) : <NEWLINE> raise ValueError , <STRING> % repr ( name ) <NEWLINE> return _tzdict [ name ] <NEWLINE> <DEDENT>
def is_server_enabled ( server ) <NEWLINE> <INDENT> server = scrapertools . find_single_match ( server , <STRING> ) <NEWLINE> return server in ENABLED_SERVERS <NEWLINE> <DEDENT>
def recalc ( self ) : <NEWLINE> <INDENT> n = 0 <NEWLINE> for i in range ( self . total ) : <NEWLINE> if self . buttons [ i ] . GetValue ( ) : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> self . value = n <NEWLINE> if headerdata . options . debug : <NEWLINE> print ( self . value ) <NEWLINE> <DEDENT>
def test__check_for_duplicate_rules_in_db_does_not_drop_protocol ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( self . mixin , <STRING> , <NEWLINE> <INDENT> return_value = [ mock . Mock ( ) ] ) : <NEWLINE> context = mock . Mock ( ) <NEWLINE> rule_dict = { <NEWLINE> <STRING> : { <STRING> : None , <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> } <NEWLINE> } <NEWLINE> self . mixin . _check_for_duplicate_rules_in_db ( context , rule_dict ) <NEWLINE> <DEDENT> <DEDENT> self . assertIn ( <STRING> , rule_dict [ <STRING> ] ) <NEWLINE> <DEDENT>
import asyncio <NEWLINE> import datetime <NEWLINE> import jwe <NEWLINE> import jwt <NEWLINE> import aiohttp <NEWLINE> from waterbutler . core import auth <NEWLINE> from waterbutler . core import exceptions <NEWLINE> from waterbutler . auth . osf import settings <NEWLINE> JWE_KEY = jwe . kdf ( settings . JWE_SECRET . encode ( ) , settings . JWE_SALT . encode ( ) <NEWLINE>
def run ( self ) : <NEWLINE> <INDENT> if ( self . cursor ) : <NEWLINE> <INDENT> from util import cursor_wait <NEWLINE> cursor_wait ( self . cfg , True ) <NEWLINE> <DEDENT> self . cond . acquire ( ) <NEWLINE> self . run_func ( ) <NEWLINE> <INDENT> self . cond . notify ( ) <NEWLINE> self . cond . release ( ) <NEWLINE> <DEDENT> if ( self . cursor ) : <NEWLINE> <INDENT> cursor_wait ( self . cfg , False ) <NEWLINE> <DEDENT> <DEDENT>
class iterator_product ( itertools . product ) : <NEWLINE> <INDENT> text = <STRING> <NEWLINE> def __init__ ( self , * i ) : <NEWLINE> itertools . product . __init__ ( self , * i ) <NEWLINE> self . __count = reduce ( lambda x , y : x * y . count ( ) , i [ 1 : ] , i [ 0 ] . count ( ) ) <NEWLINE> def count ( self ) : <NEWLINE> return self . __count <NEWLINE> <DEDENT>
def main ( backend ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> health = subprocess . check_output ( <STRING> + backend + <STRING> , shell = True ) <NEWLINE> health = set ( health . split ( <STRING> ) ) <NEWLINE> if <STRING> in health : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif <STRING> in health <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def __create_start_up_script_if_not_exist ( self ) : <NEWLINE> <INDENT> if not os . path . exists ( self . start_up_file_name ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> os . makedirs ( os . path . dirname ( self . start_up_file_name ) ) <NEWLINE> <INDENT> return self . __create_default_start_up_script_and_save_to_disk ( ) <NEWLINE> <DEDENT> <DEDENT> except OSError as exc : <NEWLINE> <INDENT> if exc . errno == errno . EEXIST : <NEWLINE> <INDENT> return self . __create_default_start_up_script_and_save_to_disk ( ) <NEWLINE> <DEDENT> if exc . errno != errno . EEXIST : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return self . __load_start_up_script_from_disk ( ) <NEWLINE> <DEDENT> <DEDENT>
import constants <NEWLINE> import sys , urllib , os . path <NEWLINE> def reporthook ( * a ) : print a <NEWLINE> for url in constants . defines . _REGISTRY_DATA : <NEWLINE> <INDENT> i = url . rfind ( <STRING> ) <NEWLINE> file = os . path . join ( constants . defines . _DATA_DIR , url [ i + 1 : ] ) <NEWLINE> print ( url , <STRING> , file ) <NEWLINE> urllib . urlretrieve ( url , file , reporthook ) <NEWLINE> <DEDENT>
def test_client_socket_timeout ( self ) : <NEWLINE> <INDENT> self . flags ( client_socket_timeout = 5 ) <NEWLINE> with mock . patch . object ( eventlet , <NEWLINE> <INDENT> <STRING> ) as mock_spawn : <NEWLINE> server = patron . wsgi . Server ( <STRING> , None , <NEWLINE> <INDENT> host = <STRING> , port = 0 ) <NEWLINE> server . start ( ) <NEWLINE> _ , kwargs = mock_spawn . call_args <NEWLINE> self . assertEqual ( CONF . client_socket_timeout , <NEWLINE> kwargs [ <STRING> ] ) <NEWLINE> server . stop ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def mousePressEvent ( self , e ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> button = config . get ( <STRING> , <STRING> ) <NEWLINE> if ( e . button ( ) == Qt . RightButton and button == <STRING> or <NEWLINE> <INDENT> e . button ( ) == Qt . MiddleButton and button == <STRING> ) : <NEWLINE> idx = self . tabAt ( e . pos ( ) ) <NEWLINE> if idx != - 1 : <NEWLINE> e . accept ( ) <NEWLINE> self . tabCloseRequested . emit ( idx ) <NEWLINE> return <NEWLINE> <DEDENT> super ( ) . mousePressEvent ( e ) <NEWLINE> <DEDENT>
def validate_type ( ( t , v ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if v == <STRING> : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if t in [ datetime . datetime , datetime . date , datetime . time ] : <NEWLINE> <INDENT> if <STRING> == v : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> try : <NEWLINE> <INDENT> if t in [ int , float ] : <NEWLINE> <INDENT> t ( v ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT>
def config ( ) : <NEWLINE> <INDENT> conf = base . BaseConfig ( <STRING> , <STRING> , analysis = <STRING> ) <NEWLINE> conf [ <STRING> ] = <STRING> <NEWLINE> conf = base . expand ( conf , [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> if socket . gethostname ( ) . startswith ( <STRING> ) : <NEWLINE> conf [ <STRING> ] = <STRING> <NEWLINE> return conf <NEWLINE> <DEDENT>
def _check_process_resources ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> resource_data = resource . getrusage ( resource . RUSAGE_SELF ) <NEWLINE> if resource_data . ru_maxrss < ( <NEWLINE> <INDENT> settings . DIE_ON_RESIDENT_SET_SIZE_MB * 1024 ) : <NEWLINE> if self . _dirty : <NEWLINE> logger . info ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> settings . ON_WORKER_SHUTDOWN ( ) <NEWLINE> self . _on_exceeding_memory_limit ( resource_data . ru_maxrss ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT>
def includeme ( config ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> settings = config . registry . settings <NEWLINE> for option in ( <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> key = <STRING> % option <NEWLINE> if key in settings : <NEWLINE> settings [ key ] = config . maybe_dotted ( settings [ key ] ) <NEWLINE> <DEDENT> session_factory = session_factory_from_settings ( settings ) <NEWLINE> config . set_session_factory ( session_factory ) <NEWLINE> <DEDENT>
def _xray_marker_closed ( self , obj ) : <NEWLINE> <INDENT> marker = obj <NEWLINE> for xray_line , line_markers in reversed ( list ( <NEWLINE> <INDENT> self . _xray_markers . items ( ) ) ) : <NEWLINE> if marker in line_markers : <NEWLINE> line_markers . remove ( marker ) <NEWLINE> if not line_markers : <NEWLINE> self . _xray_markers . pop ( xray_line ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , port ) : <NEWLINE> <INDENT> if MultiHTTPServer . __single : <NEWLINE> <INDENT> raise RuntimeError , <STRING> <NEWLINE> <DEDENT> MultiHTTPServer . __single = self <NEWLINE> self . port = port <NEWLINE> BaseHTTPServer . HTTPServer . __init__ ( self , ( <STRING> , self . port ) , SimpleServer ) <NEWLINE> self . daemon_threads = True <NEWLINE> self . allow_reuse_address = True <NEWLINE> self . lock = RLock ( ) <NEWLINE> self . urlpath2streaminfo = { } <NEWLINE> self . mappers = [ ] <NEWLINE> self . errorcallback = None <NEWLINE> self . statuscallback = None <NEWLINE> <DEDENT>
def info ( self , path ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for p in utils . paths_from_path_patterns ( [ path ] , <NEWLINE> <INDENT> dirs = <STRING> , <NEWLINE> recursive = False , <NEWLINE> on_error = <STRING> ) : <NEWLINE> for dir , id in self . _local_photo_dirs_and_ids_from_target ( p ) : <NEWLINE> log . debug ( <STRING> , id ) <NEWLINE> info = self . api . photos_getInfo ( photo_id = id ) <NEWLINE> xpprint ( info ) <NEWLINE> <DEDENT> <DEDENT>
def ziip ( tozip ) : <NEWLINE> <INDENT> filenames = os . listdir ( os . path . abspath ( tozip ) ) <NEWLINE> cmd = <STRING> <NEWLINE> for filename in filenames : <NEWLINE> <INDENT> cmd = cmd + filename + <STRING> <NEWLINE> <DEDENT> print ( <STRING> , cmd ) <NEWLINE> filenames = os . listdir ( os . path . abspath ( tozip ) ) <NEWLINE> for filename in filenames : <NEWLINE> <INDENT> print ( os . path . abspath ( filename ) ) ) <NEWLINE> <DEDENT> output = commands . getoutput ( cmd ) <NEWLINE> <DEDENT>
class Share ( models . Model ) : <NEWLINE> <INDENT> share = models . CharField ( max_length = 30 , unique = True ) <NEWLINE> read = models . ManyToManyField ( SambaUser , blank = True , limit_choices_to = { <STRING> : False } , related_name = <STRING> ) <NEWLINE> write = models . ManyToManyField ( SambaUser , limit_choices_to = { <STRING> : False } , related_name = <STRING> ) <NEWLINE> old_shares = models . CharField ( max_length = 200 , default = <STRING> , editable = False , null = True , blank = True ) <NEWLINE> def __str__ ( self ) : <NEWLINE> return self . share <NEWLINE> <DEDENT>
def get_check ( check_id ) : <NEWLINE> <INDENT> package = s2t_check <NEWLINE> prefix = package . __name__ + <STRING> <NEWLINE> for importer , modname , ispkg in pkgutil . iter_modules ( package . __path__ , <NEWLINE> <INDENT> prefix ) : <NEWLINE> module = __import__ ( modname , fromlist = <STRING> ) <NEWLINE> chk = module . factory ( check_id ) <NEWLINE> if chk : <NEWLINE> return chk <NEWLINE> <DEDENT> return aa_check . factory ( check_id ) <NEWLINE> <DEDENT>
def twitter_datestring_to_datetime_utc ( twitter_datestring ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> time_tuple = email_utils_parsedate_tz ( twitter_datestring . strip ( ) ) ) <NEWLINE> dt = datetime ( * time_tuple [ : 6 ] ) <NEWLINE> return dt - timedelta ( seconds = time_tuple [ - 1 ] ) <NEWLINE> <DEDENT>
def setUp ( self ) : <NEWLINE> <INDENT> self . plugin = DocPlugin ( ) <NEWLINE> self . plugin . set_site ( FakeSite ( ) ) ) <NEWLINE> try : <NEWLINE> <INDENT> f = docutils . parsers . rst . roles . role ( <STRING> , None , None , None ) [ 0 ] <NEWLINE> f . site = FakeSite ( ) <NEWLINE> <DEDENT> except AttributeError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> return super ( DocTestCase , self ) . setUp ( ) <NEWLINE> <DEDENT>
( <STRING> <NEWLINE> <DEDENT> <DEDENT>
def __boundary_term ( graph , label_image , ( boundary_term_args ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> dic = TestCut . __get_mapping ( ) <NEWLINE> for key , value in dic . iteritems ( ) : <NEWLINE> <INDENT> dic [ key ] = ( value , value ) <NEWLINE> <DEDENT> return dic <NEWLINE> <DEDENT>
def test_network_create_with_bad_vlan_transparent_attr ( self ) : <NEWLINE> <INDENT> vlantrans = { <STRING> : <STRING> } <NEWLINE> with testlib_api . ExpectedException ( <NEWLINE> <INDENT> web_exc . HTTPClientError ) as ctx_manager : <NEWLINE> with self . network ( name = <STRING> , ** vlantrans ) : <NEWLINE> pass <NEWLINE> <DEDENT> self . assertEqual ( web_exc . HTTPClientError . code , <NEWLINE> <INDENT> ctx_manager . exception . code ) <NEWLINE> <DEDENT> <DEDENT>
class NoneLengthHint ( object ) : <NEWLINE> <INDENT> def __iter__ ( self ) : <NEWLINE> <INDENT> return iter ( range ( 10 ) <NEWLINE> <DEDENT> def __length_hint__ ( self ) : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <DEDENT> <DEDENT>
def setUp ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
def zero ( self ) : <NEWLINE> <INDENT> self . title = <STRING> <NEWLINE> self . artist = <STRING> <NEWLINE> self . album = <STRING> <NEWLINE> self . year = <STRING> <NEWLINE> self . comment = <STRING> <NEWLINE> <INDENT> self . track = None <NEWLINE> <DEDENT> self . genre = 255 <NEWLINE> <INDENT> self . setup_dict ( ) <NEWLINE> <DEDENT> <DEDENT>
def send ( self , name = None ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if name is None : <NEWLINE> <INDENT> name = self . EOF <NEWLINE> <DEDENT> name += os . linesep <NEWLINE> bytes = self . socket . send ( name ) <NEWLINE> print ( <STRING> % ( name , bytes , len ( name ) ) <NEWLINE> return True <NEWLINE> <DEDENT> except socket . error : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
def group_members ( self , groupname ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> request = self . send_request ( <STRING> % <NEWLINE> <INDENT> quote ( groupname ) , auth = True ) <NEWLINE> <DEDENT> return [ Munch ( username = user [ 0 ] , <NEWLINE> <INDENT> role_type = user [ 3 ] ) for user in request [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT>
def getstuff ( ) : <NEWLINE> <INDENT> banner = raw_input ( <STRING> ) <NEWLINE> host = raw_input ( <STRING> ) <NEWLINE> while True or hp != null : <NEWLINE> try : <NEWLINE> <INDENT> port = int ( raw_input ( <STRING> ) ) <NEWLINE> <DEDENT> except TypeError : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( port < 1 ) or ( port > 65535 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( banner , host , port ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_call ( self ) : <NEWLINE> <INDENT> req = mock . Mock ( ) <NEWLINE> with mock . patch . object ( self . handler , <NEWLINE> <INDENT> <STRING> ) as get_ids : <NEWLINE> get_ids . return_value = ( <STRING> , <STRING> ) <NEWLINE> with mock . patch . object ( self . handler , <STRING> ) as proxy : <NEWLINE> proxy . return_value = <STRING> <NEWLINE> retval = self . handler ( req ) <NEWLINE> self . assertEqual ( retval , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def clear ( self ) : <NEWLINE> <INDENT> LOG . debug ( _ ( <STRING> ) ) <NEWLINE> with self . conn_pool . connection ( ) as conn : <NEWLINE> <INDENT> for table in [ self . ALARM_TABLE , <NEWLINE> <INDENT> self . ALARM_HISTORY_TABLE ] : <NEWLINE> try : <NEWLINE> conn . disable_table ( table ) <NEWLINE> except Exception : <NEWLINE> LOG . debug ( _ ( <STRING> ) ) <NEWLINE> try : <NEWLINE> conn . delete_table ( table ) <NEWLINE> except Exception : <NEWLINE> LOG . debug ( _ ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class CertificateConnection ( Connection ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , cert_file , secure = True , host = None , port = None , url = None , <NEWLINE> <INDENT> proxy_url = None , timeout = None , backoff = None , retry_delay = None ) : <NEWLINE> <STRING> <NEWLINE> super ( CertificateConnection , self ) . __init__ ( secure = secure , host = host , <NEWLINE> <INDENT> port = port , url = url , <NEWLINE> timeout = timeout , <NEWLINE> backoff = backoff , <NEWLINE> retry_delay = retry_delay , <NEWLINE> proxy_url = proxy_url ) <NEWLINE> self . cert_file = cert_file <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def validate ( self ) : <NEWLINE> <INDENT> res = super ( SaharaClusterTemplate , self ) . validate ( ) <NEWLINE> if res : <NEWLINE> <INDENT> return res <NEWLINE> <DEDENT> if ( self . is_using_neutron ( ) and <NEWLINE> <INDENT> not self . properties [ self . MANAGEMENT_NETWORK ] ) : <NEWLINE> msg = _ ( <STRING> <NEWLINE> <INDENT> ) % self . MANAGEMENT_NETWORK <NEWLINE> raise exception . StackValidationFailed ( message = msg ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def request_email_change ( self , new_email ) : <NEWLINE> <INDENT> self . assert_account_live ( ) <NEWLINE> self . assert_email_unique ( new_email ) <NEWLINE> Session . add ( ChangeAccountEmail ( self , new_email ) <NEWLINE> self . send_email_change_mail ( ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from launchConfigureParser import verbose <NEWLINE> if verbose ( ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> import GEOM <NEWLINE>
import re <NEWLINE> import sys <NEWLINE> css = re . sub ( <STRING> , <STRING> , <STRING> . join ( sys . stdin ) <NEWLINE> hex_colors = ( <NEWLINE> <INDENT> hex_color . group ( 0 ) <NEWLINE> for value in re . finditer ( <STRING> , css ) <NEWLINE> for hex_color in re . finditer ( <STRING> , value . group ( 0 ) , re . I ) <NEWLINE> <DEDENT> ) <NEWLINE> print ( sep = <STRING> , * hex_colors ) <NEWLINE>
def debug ( msg ) : <NEWLINE> <INDENT> if DEBUG : <NEWLINE> print ( msg ) <NEWLINE> <DEDENT>
def HTTP_GET_rjson ( self , resourceURL , Timeout_Dur = 90 , error_log = <STRING> , debug = 0 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if debug == 1 : print <STRING> + str ( resourceURL ) + <STRING> <NEWLINE> HTTP_Response = requests . Session ( ) <NEWLINE> HTTP_Response = requests . request ( <STRING> , str ( resourceURL ) , timeout = Timeout_Dur , verify = False ) <NEWLINE> HTTP_ResponseRAW = HTTP_Response . json ( ) <NEWLINE> if debug == 1 : <NEWLINE> <INDENT> print <STRING> + str ( HTTP_ResponseRAW ) + <STRING> <NEWLINE> <DEDENT> return HTTP_ResponseRAW <NEWLINE> <DEDENT> except OSError : <NEWLINE> <INDENT> return <STRING> + sys . exc_info ( ) [ 0 ] <NEWLINE> <DEDENT> <DEDENT>
def _get_message_data ( self , msg_data ) : <NEWLINE> <INDENT> if ( not msg_data or <NEWLINE> <INDENT> ( <STRING> not in msg_data and <STRING> not in msg_data ) or <NEWLINE> <STRING> not in msg_data or <NEWLINE> msg_data [ <STRING> ] . get ( <STRING> ) not in self . allowed_chat_ids ) : <NEWLINE> _LOGGER . error ( <STRING> , <NEWLINE> <INDENT> msg_data ) <NEWLINE> return None <NEWLINE> <DEDENT> <DEDENT> return { <NEWLINE> <INDENT> ATTR_USER_ID : msg_data [ <STRING> ] [ <STRING> ] , <NEWLINE> ATTR_FROM_FIRST : msg_data [ <STRING> ] [ <STRING> ] , <NEWLINE> ATTR_FROM_LAST : msg_data [ <STRING> ] [ <STRING> ] <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>
def __init__ ( self , parent , id ) : <NEWLINE> <INDENT> self . winWidth , self . winHeight = wx . DisplaySize ( ) <NEWLINE> wx . Frame . __init__ ( self , parent , id , <STRING> ) <NEWLINE> <INDENT> style = self . GetWindowStyle ( ) <NEWLINE> <DEDENT> self . SetWindowStyle ( style | wx . STAY_ON_TOP ) <NEWLINE> self . parent = parent <NEWLINE> self . Maximize ( True ) <NEWLINE> self . Center ( True ) <NEWLINE> self . MakeModal ( True ) <NEWLINE> self . initializeParameters ( ) <NEWLINE> self . createGui ( ) <NEWLINE> self . createBindings ( ) <NEWLINE> self . initializeTimer ( ) <NEWLINE> <DEDENT>
def find ( self , sensornum ) : <NEWLINE> <INDENT> history = self . findwithoutcreating ( sensornum ) <NEWLINE> if history != None : <NEWLINE> <INDENT> return history <NEWLINE> <INDENT> history = SensorHistory ( sensornum ) <NEWLINE> self . sensorhistories . append ( history ) <NEWLINE> return history <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_direction ( ( x1 , y1 ) , ( x2 , y2 ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> d = <STRING> <NEWLINE> if y1 < y2 : <NEWLINE> <INDENT> d += <STRING> <NEWLINE> <DEDENT> elif y1 > y2 : <NEWLINE> <INDENT> d += <STRING> <NEWLINE> <DEDENT> if x1 < x2 : <NEWLINE> <INDENT> d += <STRING> <NEWLINE> <DEDENT> elif x1 > x2 : <NEWLINE> <INDENT> d += <STRING> <NEWLINE> <DEDENT> if d == <STRING> : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return Direction ( d ) <NEWLINE> <DEDENT> <DEDENT>
def _handle_head ( self , path , node , upper = 1024 * 1024 ) : <NEWLINE> <INDENT> data = <STRING> <NEWLINE> for load in self . _client . _read_file ( path , node , tail_only = False , <NEWLINE> <INDENT> check_crc = False ) : <NEWLINE> data += load <NEWLINE> if ( len ( data ) > upper ) : <NEWLINE> return data <NEWLINE> <DEDENT> return data <NEWLINE> <DEDENT>
def test_ToRawUri ( self ) : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> epc = self . _gsrn96 . encode ( self . _companyPrefix , 0 , self . _serviceReference , self . _filter , 0 ) <NEWLINE> print ( epc . toEPCRawUri ( ) ) <NEWLINE> print ( <STRING> <NEWLINE> print ( <STRING> <NEWLINE> <DEDENT>
def test_check_for_setup_error_version ( self ) : <NEWLINE> <INDENT> drv = self . _driver <NEWLINE> drv . _client = api . NaServer ( <STRING> ) <NEWLINE> self . assertRaises ( exception . VolumeBackendAPIException <NEWLINE> <INDENT> drv . check_for_setup_error ) <NEWLINE> <DEDENT> drv . _client . set_api_version ( 1 , 8 ) <NEWLINE> self . assertRaises ( exception . VolumeBackendAPIException , <NEWLINE> <INDENT> drv . check_for_setup_error ) <NEWLINE> <DEDENT> <DEDENT>
class ContributionsByDateTestCase ( TestCase ) : <NEWLINE> <INDENT> def test_unicode_method ( self ) : <NEWLINE> <INDENT> today = datetime . date . today ( ) <NEWLINE> obj = models . ContributionsByDate ( date = today , amount = 20.00 , <NEWLINE> <INDENT> total = 1 ) <NEWLINE> <DEDENT> self . assertEqual ( <STRING> . format ( <NEWLINE> <INDENT> date = today ) , str ( obj ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_apt_compile_and_run ( self , strategy ) : <NEWLINE> <INDENT> with self . do_test_compile ( <STRING> , <NEWLINE> <INDENT> strategy , <NEWLINE> expected_files = [ <STRING> , <NEWLINE> <INDENT> <STRING> ] ) as found : <NEWLINE> self . assertTrue ( <NEWLINE> self . get_only ( found , <STRING> ) . endswith ( <NEWLINE> <STRING> ) ) <NEWLINE> with open ( self . get_only ( found , <STRING> ) ) as fp : <NEWLINE> self . assertIn ( <STRING> , fp . read ( ) . splitlines ( ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def parse_implicit_document_start ( self ) : <NEWLINE> <INDENT> if not self . check_token ( DirectiveToken , DocumentStartToken , <NEWLINE> <INDENT> StreamEndToken ) : <NEWLINE> self . tag_handles = self . DEFAULT_TAGS <NEWLINE> token = self . peek_token ( ) <NEWLINE> start_mark = end_mark = token . start_mark <NEWLINE> event = DocumentStartEvent ( start_mark , end_mark , <NEWLINE> <INDENT> explicit = False ) <NEWLINE> self . states . append ( self . parse_document_end ) <NEWLINE> self . state = self . parse_block_node <NEWLINE> return event <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return self . parse_document_start ( ) <NEWLINE> <DEDENT> <DEDENT>
class FakeBrcdFCSanLookupService ( object ) : <NEWLINE> <INDENT> def get_device_mapping_from_network ( self , <NEWLINE> <INDENT> initiator_wwn_list , <NEWLINE> target_wwn_list ) : <NEWLINE> device_map = { } <NEWLINE> initiators = [ ] <NEWLINE> targets = [ ] <NEWLINE> for i in initiator_wwn_list : <NEWLINE> if ( i in _initiator_ns_map [ _fabric_wwn ] ) : <NEWLINE> initiators . append ( i ) <NEWLINE> for t in target_wwn_list : <NEWLINE> if ( t in _target_ns_map [ _fabric_wwn ] ) : <NEWLINE> targets . append ( t ) <NEWLINE> device_map [ _fabric_wwn ] = { <NEWLINE> <STRING> : initiators , <NEWLINE> <STRING> : targets } <NEWLINE> return device_map <NEWLINE> <DEDENT> <DEDENT>
def tearDownClass ( cls ) : <NEWLINE> <INDENT> if cls . ctx is not None : <NEWLINE> <INDENT> for group in [ cls . ctx . web_security_group , <NEWLINE> <INDENT> cls . ctx . nat_security_group , <NEWLINE> cls . ctx . db_security_group ] : <NEWLINE> if not group : <NEWLINE> continue <NEWLINE> try : <NEWLINE> cls . _revoke_security_group_linked_rules ( group ) <NEWLINE> except Exception : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT> super ( VPC_Scenario , cls ) . tearDownClass ( ) <NEWLINE> <DEDENT>
class tracer_chunk : <NEWLINE> <INDENT> def __init__ ( self , nid , pkt_type , link_id , rem_ , ndp_ ) : <NEWLINE> <INDENT> self . nid = nid <NEWLINE> self . ndp = ndp_ <NEWLINE> <INDENT> self . chunktype = pkt_type <NEWLINE> <DEDENT> if pkt_type == <STRING> : <NEWLINE> <INDENT> self . chunk = qspn_chunk ( link_id , rem_ ) <NEWLINE> <DEDENT> <DEDENT> def print_chuncks ( self ) : <NEWLINE> <INDENT> print ( <STRING> , self . nid ) <NEWLINE> print ( <STRING> , self . chunktype ) <NEWLINE> if self . chunktype == <STRING> : <NEWLINE> <INDENT> self . chunk . print_qspn_ch ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_list_view ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> response = self . client . get ( <NEWLINE> <INDENT> reverse ( <STRING> ) <NEWLINE> <DEDENT> self . assertEqual ( response . status_code , 200 ) <NEWLINE> <DEDENT>
def Init_LCA_Scores ( vertex , node_dict ) : <NEWLINE> <INDENT> for tnode in node_dict : <NEWLINE> <INDENT> vertex . lca_scores [ tnode . name ] = node . maxInt <NEWLINE> <DEDENT> for kid_branches in vertex . child_branches : <NEWLINE> <INDENT> for kid_nodes in kid_branches . ends : <NEWLINE> if kid_nodes is not vertex : <NEWLINE> <INDENT> kid_nodes . Init_LCA_Scores ( node_dict ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def show_frame ( self , ( frame , lineno ) ) : <NEWLINE> <INDENT> self . frame = frame <NEWLINE> self . show_variables ( ) <NEWLINE> <DEDENT>
def extract_lines ( filename ) : <NEWLINE> <INDENT> file = open ( filename <STRING> ) <NEWLINE> objs = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> nextobj = re . sub ( <STRING> , <STRING> , file . readline ( ) ) <NEWLINE> if nextobj == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> objs += [ nextobj ] <NEWLINE> <DEDENT> <DEDENT> return ( objs ) <NEWLINE> <DEDENT>
def testVariableWithRegularizerColocate ( self ) : <NEWLINE> <INDENT> with self . test_session ( ) : <NEWLINE> <INDENT> with tf . variable_scope ( <STRING> ) : <NEWLINE> <INDENT> a = tf . contrib . framework . variable ( <STRING> , [ ] , device = <STRING> <NEWLINE> <INDENT> regularizer = tf . nn . l2_loss ) <NEWLINE> <DEDENT> <DEDENT> loss = tf . get_collection ( tf . GraphKeys . REGULARIZATION_LOSSES ) [ 0 ] <NEWLINE> self . assertDeviceEqual ( loss . device , a . device ) <NEWLINE> <DEDENT> <DEDENT>
class MockGlobalConfig ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . _config_info = { } <NEWLINE> <DEDENT> def set_config_value ( self , section , key , value ) : <NEWLINE> <INDENT> self . _config_info [ ( section , key ) ] = value <NEWLINE> <DEDENT> def get_config_value ( self , section , key , type = str , <NEWLINE> <INDENT> default = None , allow_blank = False ) : <NEWLINE> identifier = ( section , key ) <NEWLINE> if identifier not in self . _config_info : <NEWLINE> return default <NEWLINE> return self . _config_info [ identifier ] <NEWLINE> <DEDENT> <DEDENT>
Fib ( ) <NEWLINE> <INDENT> a , b = b , a + b <NEWLINE> str ( a ) <NEWLINE> <DEDENT> if len ( a ) > 1000 <NEWLINE> print ( a ) <NEWLINE>
( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT> <DEDENT>
def send_batch ( self , inserts ) : <NEWLINE> <INDENT> self . session . execute ( <STRING> + <STRING> . join ( inserts ) + <STRING> ) <NEWLINE> <INDENT> log . info ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def assertIn ( self , target , source ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if source not in target : <NEWLINE> <INDENT> message = <STRING> % ( repr ( source ) , repr ( target ) <NEWLINE> raise AssertionError ( message . encode ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT>
def get_identity ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return GetIdentity ( * self . ipcon . send_request ( self , BrickletIndustrialAnalogOut . FUNCTION_GET_IDENTITY , ( ) , <STRING> , <STRING> ) <NEWLINE> <DEDENT>
def join ( path , * args ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> path = _tostr ( path , <STRING> ) <NEWLINE> f = File ( path ) <NEWLINE> for a in args : <NEWLINE> <INDENT> a = _tostr ( a , <STRING> ) <NEWLINE> g = File ( a ) <NEWLINE> if g . isAbsolute ( ) or len ( f . getPath ( ) ) == 0 : <NEWLINE> f = g <NEWLINE> else : <NEWLINE> f = File ( f , a ) <NEWLINE> <DEDENT> return f . getPath ( ) <NEWLINE> <DEDENT>
class Ui_Dialog ( object ) : <NEWLINE> <INDENT> def setupUi ( self , Dialog ) : <NEWLINE> <INDENT> Dialog . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> Dialog . resize ( 652 , 628 ) <NEWLINE> Dialog . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
def tpValues_ ( self ) : <NEWLINE> <INDENT> r = [ ] <NEWLINE> tname = self . __name__ <NEWLINE> for d in self . _c . columns ( tname ) <NEWLINE> <INDENT> b = ColumnBrowser ( ) <NEWLINE> b . _d = d <NEWLINE> try : b . icon = field_icons [ d [ <STRING> ] ] <NEWLINE> except : pass <NEWLINE> b . TABLE_NAME = tname <NEWLINE> r . append ( b ) <NEWLINE> <DEDENT> return r <NEWLINE> <DEDENT>
def quadraticFormulaOne ( a , b , c ) : <NEWLINE> <INDENT> quad = ( - b + squareRoot ( ( b ** 2 - 4 * a * c ) ) ) / 2 a <NEWLINE> return quad <NEWLINE> <DEDENT>
def map_sync_outputs ( self , instance , res ) : <NEWLINE> <INDENT> instance_id = res [ 0 ] [ <STRING> ] [ <STRING> ] <NEWLINE> <INDENT> instance_uuid = res [ 0 ] [ <STRING> ] <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> hostname = res [ 0 ] [ <STRING> ] [ <STRING> ] <NEWLINE> ip = socket . gethostbyname ( hostname ) <NEWLINE> instance . ip = ip <NEWLINE> except : <NEWLINE> pass <NEWLINE> instance . instance_id = instance_id <NEWLINE> instance . instance_uuid = instance_uuid <NEWLINE> instance . instance_name = self . instance_name <NEWLINE> instance . save ( ) <NEWLINE> <DEDENT> <DEDENT>
class Model : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . loadVocabulary ( ) <NEWLINE> view = View ( ) <NEWLINE> view . set_start_game_callback ( ) <NEWLINE> <DEDENT> def loadVocabulary ( self ) : <NEWLINE> self . vocabulary = Utils ( ) <NEWLINE> self . vocabulary . openFile ( ) <NEWLINE> def searchWords ( self ) : <NEWLINE> pass <NEWLINE> def comparison ( self ) : <NEWLINE> pass <NEWLINE> <DEDENT>
def upgrade ( migrate_engine ) : <NEWLINE> <INDENT> metadata . bind = migrate_engine <NEWLINE> print ( __doc__ ) <NEWLINE> metadata . reflect ( ) <NEWLINE> if migrate_engine . name != <STRING> : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for ( table , column ) in BLOB_COLUMNS : <NEWLINE> <INDENT> cmd = <STRING> % ( table , column ) <NEWLINE> try : <NEWLINE> <INDENT> migrate_engine . execute ( cmd ) <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> <INDENT> print ( <STRING> % ( table , column ) <NEWLINE> print ( str ( e ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import grpc <NEWLINE> from grpc . beta import implementations <NEWLINE> def not_really_secure_channel ( <NEWLINE> <INDENT> host , port , channel_credentials , server_host_override ) : <NEWLINE> <STRING> <NEWLINE> target = <STRING> % ( host , port ) <NEWLINE> channel = grpc . secure_channel ( <NEWLINE> <INDENT> target , channel_credentials , <NEWLINE> ( ( <STRING> , server_host_override , ) , ) ) <NEWLINE> return implementations . Channel ( channel ) <NEWLINE> <DEDENT> <DEDENT>
class Capacitor ( Device ) : <NEWLINE> <INDENT> __name__ = <STRING> <NEWLINE> __type__ = <STRING> <NEWLINE> __indent__ = <STRING> <NEWLINE> def __init__ ( self , name = <STRING> , nodes = ( <STRING> , <STRING> ) , c = 1e-12 , ** parameters ) : <NEWLINE> Device . __init__ ( self , name = name , nodes = nodes , model = <STRING> , c = c , ** parameters ) <NEWLINE> <DEDENT>
def __init__ ( self , reader , scripts , zero_based = False ) : <NEWLINE> <INDENT> super ( ScriptCSVReader , self ) . __init__ ( ) <NEWLINE> self . zero_based = zero_based <NEWLINE> self . reader = reader <NEWLINE> self . scripts = scripts <NEWLINE> self . compiled_scripts = map ( lambda ( i , script ) : ( script [ 0 ] , compile ( script [ 1 ] , <STRING> % i , <STRING> ) ) , <NEWLINE> <INDENT> enumerate ( self . scripts ) ) <NEWLINE> <DEDENT> self . column_names = reader . next ( ) <NEWLINE> <DEDENT>
def retranslateUi ( self , Tab ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> Tab . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . btn_loadImage . setText ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . ckbox_scrollMode . setText ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . btn_encrypt . setText ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . btn_decrypt . setText ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . btn_encryptEmb . setText ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from plaso . formatters import interface <NEWLINE> from plaso . formatters import manager <NEWLINE> class OfficeMRUWindowsRegistryEventFormatter ( <NEWLINE> <INDENT> interface . ConditionalEventFormatter ) : <NEWLINE> <STRING> <NEWLINE> DATA_TYPE = <STRING> <NEWLINE> FORMAT_STRING_PIECES = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ] <NEWLINE> FORMAT_STRING_SHORT_PIECES = [ <NEWLINE> <STRING> ] <NEWLINE> SOURCE_LONG = <STRING> <NEWLINE> SOURCE_SHORT = <STRING> <NEWLINE> <DEDENT> <DEDENT> manager . FormattersManager . RegisterFormatter ( <NEWLINE> <INDENT> OfficeMRUWindowsRegistryEventFormatter ) <NEWLINE> <DEDENT>
def create_voucher ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> voucher = Voucher . objects . create ( <NEWLINE> <INDENT> name = <STRING> , <NEWLINE> code = <STRING> <NEWLINE> start_date = datetime . date . today ( ) , <NEWLINE> end_date = datetime . date . today ( ) + datetime . timedelta ( days = 12 ) ) <NEWLINE> <DEDENT> voucher . offers . add ( create_offer ( offer_type = <STRING> ) ) <NEWLINE> return voucher <NEWLINE> <DEDENT>
def last_modified ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> return datetime . datetime . now ( ) - self . latest_action . timestamp <NEWLINE> <DEDENT> <DEDENT>
def _change_server ( self ) : <NEWLINE> <INDENT> if ( self . login_info [ <STRING> ] and <NEWLINE> <INDENT> self . login_info [ <STRING> ] ) : <NEWLINE> controller_ip = ( self . login_info [ <STRING> ] <NEWLINE> <INDENT> if self . login_info [ <STRING> ] in self . url <NEWLINE> else self . login_info [ <STRING> ] ) <NEWLINE> self . url = <STRING> + controller_ip + <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def RegServerFunc ( target , source , env ) : <NEWLINE> <INDENT> if env . has_key ( <STRING> ) and env [ <STRING> ] : <NEWLINE> <INDENT> ret = regServerAction ( [ target [ 0 ] ] , [ source [ 0 ] ] , env ) <NEWLINE> if ret : <NEWLINE> <INDENT> raise SCons . Errors . UserError , <STRING> % target [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> % target [ 0 ] ) <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT>
class USAddress ( raw_ipo . USAddress ) : <NEWLINE> <INDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return six . u ( <STRING> ) % ( self . name ( ) , self . street ( ) , , self . city ( ) , self . state ( ) , self . zip ( ) ) <NEWLINE> <DEDENT> pass <NEWLINE> <DEDENT>
def PuntajeCasillero ( self , ( x , y ) , Equipo ) : <NEWLINE> <INDENT> if Equipo == EQUIPONEGRO : <NEWLINE> <INDENT> if y < 4 : <NEWLINE> <INDENT> return 7 <NEWLINE> <DEDENT> elif y == 7 : <NEWLINE> <INDENT> return 10 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 6 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if y > 4 : <NEWLINE> <INDENT> return 7 <NEWLINE> <DEDENT> elif y == 0 : <NEWLINE> <INDENT> return 10 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def read_static_uplink ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . node_list is None or self . node_uplink_list is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for node , port in zip ( self . node_list . split ( <STRING> ) , <NEWLINE> <INDENT> self . node_uplink_list . split ( <STRING> ) ) : <NEWLINE> if node . strip ( ) == self . host_name : <NEWLINE> self . static_uplink = True <NEWLINE> self . static_uplink_port = port . strip ( ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT>
def emcToolStartChange ( self ) : <NEWLINE> <INDENT> if debug ( ) : print <STRING> , <STRING> if self . startchange_pins else <STRING> <NEWLINE> if self . startchange_pins : <NEWLINE> <INDENT> self . hal [ <STRING> ] = 1 <NEWLINE> self . io . status = self . wait_for_named_pin ( 1 , <STRING> , self . start_change_acked ) <NEWLINE> return 0 <NEWLINE> <DEDENT> self . io . status = emctask . RCS_STATUS . RCS_DONE <NEWLINE> return 0 <NEWLINE> <DEDENT>
def set_TEST ( self , level = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . invertTEST : <NEWLINE> <INDENT> level = not level <NEWLINE> <DEDENT> if self . testOnTX : <NEWLINE> <INDENT> self . serial . setBreak ( level ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if self . swapResetTest : <NEWLINE> GPIO . output ( 18 , level ) <NEWLINE> else : <NEWLINE> GPIO . output ( 17 , level ) <NEWLINE> <DEDENT> time . sleep ( self . control_delay ) <NEWLINE> <DEDENT>
class GoogleFinanceFT ( bFeed ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , name , column = <STRING> , <NEWLINE> <INDENT> start = <STRING> , end = <STRING> ) : <NEWLINE> super ( GoogleFinanceFT , self ) . __init__ ( ) <NEWLINE> source = PyDataDataReaderST ( <STRING> , name , column = column , <NEWLINE> <INDENT> start = start , end = end ) <NEWLINE> self . sourcing = source . as_dict <NEWLINE> self . _set_stype ( source ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def getSpec ( self ) : <NEWLINE> <INDENT> return dict ( type = self . name , <NEWLINE> <INDENT> of = self . of . getSpec ( ) <NEWLINE> <DEDENT> <DEDENT>
def test_requests_context_retries_read_timeout_retries_exhausted ( ) : <NEWLINE> <INDENT> with mock . patch . object ( <NEWLINE> <INDENT> requests . packages . urllib3 . connectionpool . HTTPConnectionPool , <NEWLINE> <STRING> ) as mock_make_request : <NEWLINE> url , mock_make_request . side_effect = timeout_side_effect ( <NEWLINE> <INDENT> timeout_error = requests . packages . urllib3 . exceptions . ReadTimeoutError , <NEWLINE> num_timeouts = 3 ) <NEWLINE> env = Variables ( environ = { <STRING> : <STRING> } ) <NEWLINE> context = RequestsContext ( verify = False , env = env ) <NEWLINE> with pytest . raises ( Context . Error ) : <NEWLINE> <DEDENT> context . read ( Link . wrap ( url ) ) <NEWLINE> <DEDENT> <DEDENT>
def find_keyboard_device ( ) : <NEWLINE> <INDENT> for bus in usb . busses ( ) : <NEWLINE> <INDENT> for device in bus . devices : <NEWLINE> print ( device ) <NEWLINE> <INDENT> if device . idVendor == USB_VENDOR and device . idProduct == USB_PRODUCT or device . idProduct == USB_OTHER_PRODUCT : <NEWLINE> <INDENT> return device <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def getTaskFromId ( self , tid ) : <NEWLINE> <INDENT> if tid == <STRING> <NEWLINE> <INDENT> if self . lastTaskId is None : <NEWLINE> <INDENT> raise YokadiException ( <STRING> ) <NEWLINE> <DEDENT> tid = self . lastTaskId <NEWLINE> <DEDENT> task = dbutils . getTaskFromId ( tid ) <NEWLINE> if tid != <STRING> : <NEWLINE> <INDENT> self . lastTaskId = task . id <NEWLINE> <DEDENT> return task <NEWLINE> <DEDENT>
