def tearDown ( self ) : <NEWLINE> <INDENT> for d in [ <STRING> , <NEWLINE> <INDENT> <STRING> ] : <NEWLINE> try : <NEWLINE> shutil . rmtree ( os . path . join ( self . aptroot , d ) ) <NEWLINE> except IOError : <NEWLINE> pass <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> os . remove ( os . path . join ( self . aptroot , <STRING> ) ) <NEWLINE> <DEDENT> except OSError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
def debug_shell ( ) : <NEWLINE> <INDENT> traceback . print_exception ( * sys . exc_info ( ) ) <NEWLINE> <INDENT> import code <NEWLINE> code . interact ( <STRING> , local = locals ( ) ) <NEWLINE> sys . exit ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
class Solution ( object ) : <NEWLINE> <INDENT> def isPalindrome ( self , x ) : <NEWLINE> <STRING> <NEWLINE> z = str ( x ) [ : : - 1 ] <NEWLINE> return True if z == str ( x ) else False <NEWLINE> <DEDENT>
def tran_func ( a , xshift , yshift , xmag , ymag , xrot , yrot ) <NEWLINE> <INDENT> xtran = ymag * a [ 0 ] * cos ( yrot * pi / 180.0 ) - xmag * a [ 1 ] * sin ( xrot * pi / 180 ) - yshift <NEWLINE> ytran = ymag * a [ 0 ] * sin ( yrot * pi / 180.0 ) + xmag * a [ 1 ] * cos ( xrot * pi / 180 ) - xshift <NEWLINE> return xtran , ytran <NEWLINE> <DEDENT>
def retranslateUi ( self , sits_viewer ) : <NEWLINE> <INDENT> sits_viewer . setWindowTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . txtFeedback . setHtml ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def get_total_coverage ( fpvals , col_num , step , out_val ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> total_coverage = 0 <NEWLINE> for key , chrom_iter in groupby ( bediter ( fpvals , col_num ) , <NEWLINE> <INDENT> itemgetter ( <STRING> ) ) : <NEWLINE> bases = set ( [ ] ) <NEWLINE> for feat in chrom_iter : <NEWLINE> s , e = feat [ <STRING> ] , feat [ <STRING> ] <NEWLINE> if s == e : e += 1 <NEWLINE> bases . update ( range ( s , e ) ) <NEWLINE> total_coverage += len ( bases ) <NEWLINE> <DEDENT> out_val . value = total_coverage <NEWLINE> <DEDENT>
def getDevices ( self ) : <NEWLINE> <INDENT> if DEBUG : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> self . __send ( <STRING> , checkok = False ) <NEWLINE> try : <NEWLINE> <INDENT> self . __checkOk ( ) <NEWLINE> <DEDENT> except RuntimeError , ex : <NEWLINE> <INDENT> print ( <STRING> , ex ) <NEWLINE> return None <NEWLINE> <DEDENT> devices = [ ] <NEWLINE> for line in self . __receive ( ) . splitlines ( ) : <NEWLINE> <INDENT> devices . append ( Device . factory ( line ) ) <NEWLINE> <DEDENT> self . socket = AdbClient . connect ( self . hostname , self . port , self . timeout ) <NEWLINE> return devices <NEWLINE> <DEDENT>
def processXmlQuerySync ( rspec , url = None ) : <NEWLINE> <INDENT> if threading . currentThread ( ) . callBackURL : <NEWLINE> <INDENT> url = threading . currentThread ( ) . callBackURL <NEWLINE> <INDENT> if not rspec . query . provisioning == None : <NEWLINE> <INDENT> status = SyncThread . startMethodAndJoin ( ProvisioningDispatcher . processProvisioning , rspec . query . provisioning , url ) <NEWLINE> return status <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def ping ( self , serviceLocator , nonce , nanoseconds ) : <NEWLINE> <INDENT> result = ctypes . c_uint64 ( ) ; <NEWLINE> s = so . rc_ping ( self . client , serviceLocator , nonce , nanoseconds , <NEWLINE> <INDENT> ctypes . byref ( result ) ) ) <NEWLINE> <DEDENT> self . handle_error ( s ) <NEWLINE> return result <NEWLINE> <DEDENT>
def getMessageData_api ( id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> try : <NEWLINE> if id in messages : <NEWLINE> return messages [ id ] <NEWLINE> else : <NEWLINE> res = [ ] <NEWLINE> nr = group . Query ( Vsync . Group . ALL , 4 , id , Vsync . EOLMarker ( ) , res ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( res ) <NEWLINE> for ele in res : <NEWLINE> <INDENT> if ele != <STRING> : <NEWLINE> <INDENT> return ele <NEWLINE> return <STRING> <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def draw_label_in_box ( ctx , color , label , x , y , w , maxx ) : <NEWLINE> <INDENT> label_w = ctx . text_extents ( label ) [ 2 ] <NEWLINE> label_x = x + w / 2 - label_w / 2 <NEWLINE> <INDENT> if label_w + 10 > w : <NEWLINE> <INDENT> label_x = x + w + 5 <NEWLINE> <DEDENT> if label_x + label_w > maxx : <NEWLINE> <INDENT> label_x = x - label_w - 5 <NEWLINE> <DEDENT> <DEDENT> draw_text ( ctx , label , color , label_x , y ) <NEWLINE> <DEDENT>
def help_flag ( self ) : <NEWLINE> <INDENT> print ( _ ( <STRING> ) <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> print <NEWLINE> print ( _ ( <STRING> ) ) <NEWLINE> <DEDENT>
def test_nonadmin_cannot_set_subjects ( self ) : <NEWLINE> <INDENT> initial_subjects = self . preprint . subjects <NEWLINE> with assert_raises ( PermissionsError ) : <NEWLINE> <INDENT> self . preprint . set_subjects ( [ [ SubjectFactory ( ) . _id ] ] ] , auth = Auth ( self . write_contrib ) , save = True ) <NEWLINE> <DEDENT> self . preprint . reload ( ) <NEWLINE> assert_equal ( initial_subjects , self . preprint . subjects ) <NEWLINE> <DEDENT>
def findCenter ( self , side = - 1 ) : <NEWLINE> <INDENT> self . WriteThenStore ( <STRING> . format ( side ) <NEWLINE> done = <STRING> <NEWLINE> while done != <STRING> : <NEWLINE> <INDENT> done = self . status ( ) <NEWLINE> print ( <STRING> . format ( done ) ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def test_get_component_manager_arg_comp_mgr_id_success ( self ) : <NEWLINE> <INDENT> value = <STRING> <NEWLINE> with patch ( <STRING> <NEWLINE> <INDENT> <STRING> , <NEWLINE> return_value = Response ( Response . StatusCode . OK , <NEWLINE> <INDENT> value ) <NEWLINE> <DEDENT> ) as m_get_object : <NEWLINE> self . result = self . target . get_component_manager ( <STRING> ) <NEWLINE> self . assertEqual ( m_get_object . call_count , 1 ) <NEWLINE> m_get_object . assert_any_call ( SystemManagerInterface . <NEWLINE> <INDENT> COMP_MNG_PATH % <STRING> ) <NEWLINE> self . assertNotEqual ( self . result , None ) <NEWLINE> self . assertEqual ( self . result , value ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class ImapProxyClient ( object ) : <NEWLINE> <INDENT> def __init__ ( self , uid , pwd , imap_server_address ) : <NEWLINE> <INDENT> if ALLVERBOSE or VERBOSE : <NEWLINE> <INDENT> print <STRING> % ( uid , pwd , imap_server_address ) <NEWLINE> <DEDENT> self . uid = uid <NEWLINE> self . pwd = pwd <NEWLINE> self . imap_server_address = imap_server_address <NEWLINE> self . mailboxCache = { } <NEWLINE> self . connectecd = False <NEWLINE> self . selected = None <NEWLINE> self . subscribed = [ ] <NEWLINE> self . factory = None <NEWLINE> self . protocol = None <NEWLINE> <DEDENT> <DEDENT>
def latest_tweets ( request ) : <NEWLINE> <INDENT> tweets = cache . get ( <STRING> ) <NEWLINE> if tweets : <NEWLINE> <INDENT> return { <STRING> : tweets } <NEWLINE> <DEDENT> tweets = twitter . Api ( ) . GetUserTimeline ( settings . TWITTER_USER ) [ 0 : 3 ] <NEWLINE> for tweet in tweets : <NEWLINE> tweet . date = datetime . strptime ( tweet . created_at , <STRING> ) <NEWLINE> cache . set ( <STRING> , tweets , settings . TWITTER_TIMEOUT ) <NEWLINE> return { <STRING> : tweets } <NEWLINE> <DEDENT>
import plugin_mgr <NEWLINE> plugins = plugin_mgr . importPlugins ( folder = <STRING> ) <NEWLINE> for ( name , ns , plugin ) in plugins : <NEWLINE> <INDENT> print ( <STRING> . format ( plugin . var ) ) <NEWLINE> print ( <STRING> . format ( name ) ) ) <NEWLINE> for p , v in plugin . __dict__ . items ( ) : <NEWLINE> <INDENT> if not p . startswith ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> . format ( p , v ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_search_users_with_text_match ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> cassette_name = self . cassette_name ( <STRING> ) <NEWLINE> with self . recorder . use_cassette ( cassette_name , <NEWLINE> <INDENT> match_requests_on = self . match_on ) : <NEWLINE> users = self . gh . search_users ( <STRING> , <NEWLINE> <INDENT> text_match = True ) <NEWLINE> user_result = next ( users ) <NEWLINE> assert isinstance ( user_result , <NEWLINE> github3 . search . UserSearchResult ) <NEWLINE> <DEDENT> <DEDENT> assert isinstance ( users , github3 . structs . SearchIterator ) <NEWLINE> assert len ( user_result . text_matches ) > 0 <NEWLINE> <DEDENT>
def cmp ( ( obj1 , obj2 ) ) : <NEWLINE> <INDENT> if obj1 . is_immutable_constant ( ) and obj2 . is_immutable_constant ( ) : <NEWLINE> <INDENT> return immutablevalue ( cmp ( obj1 . const , obj2 . const ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return SomeInteger ( ) <NEWLINE> <DEDENT> <DEDENT>
from paddle . proto . DataConfig_pb2 import DataConfig <NEWLINE> g_config = None <NEWLINE> def SimpleData ( <NEWLINE> <INDENT> files = None , <NEWLINE> feat_dim = None , <NEWLINE> context_len = None , <NEWLINE> buffer_capacity = None ) : <NEWLINE> data_config = DataConfig ( ) <NEWLINE> data_config . type = <STRING> <NEWLINE> data_config . files = files <NEWLINE> data_config . feat_dim = feat_dim <NEWLINE> if context_len is not None : <NEWLINE> data_config . context_len = context_len <NEWLINE> if buffer_capacity : <NEWLINE> data_config . buffer_capacity = buffer_capacity <NEWLINE> return data_config <NEWLINE> <DEDENT>
def running_set ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . collector_set . filter ( open_date__lte = date . today ( ) . order_by ( <STRING> ) [ : 5 ] <NEWLINE> <DEDENT>
def print_applicant ( applicant ) : <NEWLINE> <INDENT> if not applicant . submission_info . doc_reviewed_complete : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if applicant . education . uses_gat_score : <NEWLINE> <INDENT> print ( <STRING> % ( <NEWLINE> <INDENT> applicant . personal_info . national_id , <NEWLINE> applicant . education . gpax , <NEWLINE> <STRING> . join ( [ str ( s ) for s <NEWLINE> <INDENT> in extract_gatpat_scores ( applicant . education ) ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> % ( <NEWLINE> <INDENT> applicant . personal_info . national_id , <NEWLINE> applicant . education . gpax , <NEWLINE> applicant . education . anet ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def boot2 ( self , yesno ) : <NEWLINE> <INDENT> if yesno : <NEWLINE> system ( <STRING> ) <NEWLINE> system ( <STRING> ) <NEWLINE> else : <NEWLINE> system ( <STRING> ) <NEWLINE> self . session . open ( MessageBox , _ ( <STRING> ) , MessageBox . TYPE_INFO ) <NEWLINE> <DEDENT>
def suite ( ) : <NEWLINE> <INDENT> suite = trytond . tests . test_tryton . suite ( ) <NEWLINE> suite . addTests ( unittest . TestLoader ( ) . loadTestsFromTestCase ( <NEWLINE> <INDENT> AccountBankTestCase ) ) <NEWLINE> <DEDENT> suite . addTests ( doctest . DocFileSuite ( <STRING> , <NEWLINE> <INDENT> tearDown = doctest_teardown , encoding = <STRING> , <NEWLINE> checker = doctest_checker , <NEWLINE> optionflags = doctest . REPORT_ONLY_FIRST_FAILURE ) <NEWLINE> <DEDENT> return suite <NEWLINE> <DEDENT>
def conllesp ( ) : <NEWLINE> <INDENT> from nltk . corpus import conll2002 <NEWLINE> de = <STRING> <NEWLINE> DE = re . compile ( de , re . VERBOSE ) <NEWLINE> print <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> * 45 ) <NEWLINE> rels = [ rel for doc in conll2002 . chunked_sents ( <STRING> ) <NEWLINE> <INDENT> for rel in extract_rels ( <STRING> , <STRING> , doc , corpus = <STRING> , pattern = DE ) ] <NEWLINE> <DEDENT> for r in rels [ : 10 ] : print show_clause ( r , relsym = <STRING> ) <NEWLINE> print <NEWLINE> <DEDENT>
def find_username_git ( self ) : <NEWLINE> <INDENT> if os == win32 : <NEWLINE> <INDENT> return find_username_git_windows ( ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> return find_username_git_unix ( ) <NEWLINE> <DEDENT> <DEDENT>
def flags ( self , index ) : <NEWLINE> <INDENT> node = self . getNode ( index ) <NEWLINE> if np . any ( node . vals != 0 ) <NEWLINE> <INDENT> return Qt . ItemIsEnabled | Qt . ItemIsSelectable | Qt . ItemIsUserCheckable <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return Qt . ItemIsSelectable <NEWLINE> <DEDENT> <DEDENT>
def _import_bears ( file_path , kinds ) : <NEWLINE> <INDENT> for bear_list in iimport_objects ( file_path , <NEWLINE> <INDENT> names = <STRING> , <NEWLINE> types = list ) : <NEWLINE> for bear_class in bear_list : <NEWLINE> for valid_bear_class in _yield_if_right_kind ( bear_class , kinds ) : <NEWLINE> yield valid_bear_class <NEWLINE> <DEDENT> for bear_class in iimport_objects ( file_path , <NEWLINE> <INDENT> attributes = <STRING> , <NEWLINE> local = True ) : <NEWLINE> for valid_bear_class in _yield_if_right_kind ( bear_class , kinds ) : <NEWLINE> yield valid_bear_class <NEWLINE> <DEDENT> <DEDENT>
def returnFanState ( ) : <NEWLINE> <INDENT> try : <NEWLINE> f = open ( <STRING> , <STRING> ) <NEWLINE> tempString = f . read ( ) <NEWLINE> <INDENT> f . close ( ) <NEWLINE> fanstate = int ( tempString ) <NEWLINE> except IOError as e : <NEWLINE> fanstate = 0 <NEWLINE> return fanstate <NEWLINE> <DEDENT> <DEDENT>
class IndexPageHandler ( webapp2 . RequestHandler ) : <NEWLINE> <INDENT> def get ( self , base_url = None ) : <NEWLINE> self . response . out . write ( <STRING> ) <NEWLINE> self . response . out . write ( <STRING> ) <NEWLINE> self . response . out . write ( <STRING> ) <NEWLINE> self . response . out . write ( <STRING> ) <NEWLINE> <DEDENT>
class ArgumentTypeException ( ArgumentException ) : <NEWLINE> <INDENT> def __init__ ( self , except_type , actual_value , <NEWLINE> <INDENT> * args , ** kwargs ) : <NEWLINE> if not isinstance ( except_type , type ) : <NEWLINE> raise ArgumentTypeException ( type , except_type ) <NEWLINE> actual_type = <STRING> if actual_value is None else type ( actual_value ) . __name__ <NEWLINE> fmtext = <STRING> <NEWLINE> fmtext += <STRING> <NEWLINE> fmtext = <STRING> + <STRING> <NEWLINE> super ( ) . __init__ ( fmtext , <NEWLINE> <INDENT> parameter_name = kwargs . get ( <STRING> , <STRING> ) , <NEWLINE> except_type = except_type . __name__ , <NEWLINE> actual_type = actual_type , <NEWLINE> * args , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
( Rect <NEWLINE> bgcolor_ = osg . Vec4 ( ) <NEWLINE> rect_ = Rect ( ) <NEWLINE> caption_ = str ( ) <NEWLINE> <DEDENT>
def _bOR ( left , right ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if timing : print <STRING> , time ( ) <NEWLINE> out = left . cloneMerged ( ) <NEWLINE> out . addFeatures ( FeatureUtils . mergeContiguous ( right ) ) <NEWLINE> out . mergeContiguous ( ) <NEWLINE> if timing : <NEWLINE> <INDENT> print <STRING> , time ( ) <NEWLINE> <DEDENT> return out <NEWLINE> <DEDENT>
import json <NEWLINE> import math <NEWLINE> import pyflowgo . flowgo_state <NEWLINE> import pyflowgo . base . flowgo_base_crust_temperature_model <NEWLINE> class FlowGoCrustTemperatureModelHR2001 ( pyflowgo . base . flowgo_base_crust_temperature_model . <NEWLINE> <INDENT> FlowGoBaseCrustTemperatureModel ) : <NEWLINE> <STRING> <NEWLINE> _crust_temperature = 425 + 273.15 <NEWLINE> def read_initial_condition_from_json_file ( self , filename ) : <NEWLINE> with open ( filename ) as data_file : <NEWLINE> data = json . load ( data_file ) <NEWLINE> self . _crust_temperature = float ( data [ <STRING> ] [ <STRING> ] ) <NEWLINE> def compute_crust_temperature ( self , state ) : <NEWLINE> crust_temperature = 0. <NEWLINE> core_temperature = state . get_core_temperature ( ) <NEWLINE> self . _crust_temperature = core_temperature - 712.0 <NEWLINE> return self . _crust_temperature <NEWLINE> <DEDENT>
def printColLabels ( board ) : <NEWLINE> <INDENT> ( rows , cols ) = ( len ( board ) , len ( board [ 0 ] ) ) <NEWLINE> print ( <STRING> , ) <NEWLINE> for col in xrange ( cols ) : print chr ( ord ( <STRING> ) + col ) , <NEWLINE> print <NEWLINE> <DEDENT>
def getNetName ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for ( so_fam , addr ) in [ <NEWLINE> <INDENT> ( socket . AF_INET , <STRING> ) , <NEWLINE> ( socket . AF_INET6 , <STRING> ) ] : <NEWLINE> try : <NEWLINE> s = socket . socket ( so_fam , socket . SOCK_DGRAM ) <NEWLINE> s . connect ( ( addr , 0 ) ) <NEWLINE> return s . getsockname ( ) [ 0 ] <NEWLINE> except socket . error : <NEWLINE> pass <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <DEDENT>
def testMutableHashTableIsLocal ( self ) : <NEWLINE> <INDENT> with ops . device ( <NEWLINE> <INDENT> estimator . _get_replica_device_setter ( run_config . RunConfig ( ) ) ) : <NEWLINE> default_val = constant_op . constant ( [ - 1 , - 1 ] , dtypes . int64 ) <NEWLINE> table = lookup . MutableHashTable ( dtypes . string , dtypes . int64 , <NEWLINE> <INDENT> default_val ) <NEWLINE> input_string = constant_op . constant ( [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> output = table . lookup ( input_string ) <NEWLINE> <DEDENT> <DEDENT> self . assertDeviceEqual ( <STRING> , table . _table_ref . device ) <NEWLINE> self . assertDeviceEqual ( <STRING> , output . device ) <NEWLINE> <DEDENT>
def _extract_info ( self , webpage ) : <NEWLINE> <INDENT> info_json = self . _search_regex ( <NEWLINE> <INDENT> <STRING> <NEWLINE> webpage , <STRING> ) <NEWLINE> <DEDENT> return json . loads ( info_json ) <NEWLINE> <DEDENT>
def open_write_stream ( self , relpath , , mode = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . put_bytes ( relpath , <STRING> , mode ) <NEWLINE> result = AppendBasedFileStream ( self , relpath ) <NEWLINE> _file_streams [ self . abspath ( relpath ) ] = result <NEWLINE> return result <NEWLINE> <DEDENT>
<STRING> <NEWLINE> with pointers : <NEWLINE> <INDENT> def make_array ( ) -> [ ] int : <NEWLINE> <INDENT> arr = new ( [ ] int ( 1 , 2 , 3 , 4 ) ) <NEWLINE> return arr <NEWLINE> <DEDENT> def test_array ( arr : [ ] int ) : <NEWLINE> <INDENT> print ( arr [ 0 ] ) <NEWLINE> print ( arr [ 1 ] ) <NEWLINE> print ( arr [ 2 ] ) <NEWLINE> print ( arr [ 3 ] ) <NEWLINE> <DEDENT> def main ( ) : <NEWLINE> <INDENT> a = make_array ( ) <NEWLINE> print ( <STRING> , len ( a ) ) <NEWLINE> test_array ( a ) <NEWLINE> <DEDENT> <DEDENT>
def _openConfig ( namespace ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if namespace [ <STRING> ] is not None : <NEWLINE> <INDENT> os . environ [ <STRING> ] = namespace [ <STRING> ] . name <NEWLINE> return namespace [ <STRING> ] <NEWLINE> <DEDENT> if <STRING> in os . environ : <NEWLINE> <INDENT> return open ( os . environ [ <STRING> ] ) <NEWLINE> <DEDENT> for path in [ appdirs . user_config_dir ( <STRING> ) , <NEWLINE> <INDENT> <STRING> ] : <NEWLINE> if os . path . isfile ( path ) : <NEWLINE> return open ( path , <STRING> ) <NEWLINE> <DEDENT> raise FileNotFoundError ( <STRING> ) <NEWLINE> <DEDENT>
class TicketChangeEvent ( NotificationEvent ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , category , target , time , author , comment = None , <NEWLINE> <INDENT> changes = None , attachment = None ) : <NEWLINE> super ( TicketChangeEvent , self ) . __init__ ( <STRING> , category , target , <NEWLINE> <INDENT> time , author ) <NEWLINE> self . comment = comment <NEWLINE> if changes is None and time is not None : <NEWLINE> changes = target . get_change ( cdate = time ) <NEWLINE> self . changes = changes or { } <NEWLINE> self . attachment = attachment <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_create_ip_policy_network_ip_policy_already_exists ( self ) : <NEWLINE> <INDENT> with self . _stubs ( None , net = dict ( id = 1 , ip_policy = dict ( id = 2 ) , <NEWLINE> <INDENT> subnets = [ dict ( id = 1 , <NEWLINE> <INDENT> cidr = <STRING> ) ] ) ) : <NEWLINE> with self . assertRaises ( quark_exceptions . IPPolicyAlreadyExists ) : <NEWLINE> self . plugin . create_ip_policy ( self . context , dict ( <NEWLINE> ip_policy = dict ( network_ids = [ 1 ] , <NEWLINE> exclude = [ <STRING> ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_argument_handling ( self ) : <NEWLINE> <INDENT> self . assertRaises ( SyntaxError , eval , <STRING> ) <NEWLINE> self . assertRaises ( SyntaxError , eval , <STRING> ) <NEWLINE> self . assertRaises ( SyntaxError , eval , <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> exec <STRING> <NEWLINE> self . fail ( <STRING> ) <NEWLINE> <DEDENT> except SyntaxError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> exec <STRING> <NEWLINE> self . fail ( <STRING> ) <NEWLINE> <DEDENT> except SyntaxError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> exec <STRING> <NEWLINE> self . fail ( <STRING> ) <NEWLINE> <DEDENT> except SyntaxError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
def writeArray1 ( ar , name ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> counter = 0 <NEWLINE> for x in ar : <NEWLINE> <INDENT> s += <STRING> % ( name , counter , x ) <NEWLINE> counter += 1 <NEWLINE> <INDENT> return s <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_slave ( self , name ) : <NEWLINE> <INDENT> if self . dbg : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> index = self . get_slave_index ( name ) <NEWLINE> return self . slaves [ index ] <NEWLINE> <DEDENT>
def __init__ ( self , pidfile , stdin = <STRING> , stdout = <STRING> , stderr = <STRING> ) <NEWLINE> <INDENT> self . stdin = stdin <NEWLINE> self . stdout = stdout <NEWLINE> self . stderr = stderr <NEWLINE> self . pidfile = pidfile <NEWLINE> <DEDENT>
import os <NEWLINE> import sys <NEWLINE> ROOT_DIR = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) <NEWLINE> sys . path . append ( ROOT_DIR ) <NEWLINE>
def setUp ( self ) : <NEWLINE> <INDENT> super ( CodeTracerMainTest , self ) . setUp ( ) <NEWLINE> self . maxDiff = None <NEWLINE> for module_name in ( <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ) : <NEWLINE> if module_name in sys . modules : <NEWLINE> del sys . modules [ module_name ] <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import sys <NEWLINE> import traceback <NEWLINE> from types import TracebackType <NEWLINE> from jinja2 . utils import CodeType , missing , internal_code <NEWLINE> from jinja2 . exceptions import TemplateSyntaxError <NEWLINE> try : <NEWLINE> <INDENT> from __pypy__ import tproxy <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> tproxy = None <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> exec <STRING> <NEWLINE> <DEDENT> except SyntaxError : <NEWLINE> <INDENT> raise_helper = <STRING> <NEWLINE> <DEDENT> except TypeError : <NEWLINE> <INDENT> raise_helper = <STRING> <NEWLINE> <DEDENT>
def __iter__ ( self ) : <NEWLINE> <INDENT> if not self . _nrbits : <NEWLINE> <INDENT> raise TypeError , <STRING> <NEWLINE> <DEDENT> return iter ( [ self [ i ] for i in range ( self . _nrbits - 1 , - 1 , - 1 ) ] ) <NEWLINE> <DEDENT>
def delete_sleep ( request , sleep_id ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> sl = Sleep . objects . get ( sl_id = sleep_id ) <NEWLINE> <DEDENT> sl . delete ( ) <NEWLINE> except ObjectDoesNotExist : <NEWLINE> <INDENT> return HttpResponse ( ujson . dumps ( { <STRING> : <STRING> } ) , <NEWLINE> <INDENT> content_type = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return HttpResponse ( ujson . dumps ( { <STRING> : <STRING> } ) , <NEWLINE> <INDENT> content_type = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def _execute_sql ( cursor , command ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> cursor . execute ( command ) <NEWLINE> <DEDENT> except MySQLdb . MySQLError , e : <NEWLINE> <INDENT> e . args += ( command , ) <NEWLINE> raise e <NEWLINE> <DEDENT> <DEDENT>
def get_ping_logs ( hostname , target ) : <NEWLINE> <INDENT> slave_active = slave . objects . get ( slave_hostname = hostname ) <NEWLINE> <INDENT> try : <NEWLINE> content = urllib2 . urlopen ( <STRING> + slave_active + <STRING> + target ) . read ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> content = <STRING> <NEWLINE> pass <NEWLINE> <INDENT> return content <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class JsonResponse ( HttpResponse ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , data , encoder = DjangoJSONEncoder , safe = True , <NEWLINE> <INDENT> json_dumps_params = None , ** kwargs ) : <NEWLINE> if safe and not isinstance ( data , dict ) : <NEWLINE> raise TypeError ( <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> ) <NEWLINE> if json_dumps_params is None : <NEWLINE> json_dumps_params = { } <NEWLINE> kwargs . setdefault ( <STRING> , <STRING> ) <NEWLINE> data = json . dumps ( data , cls = encoder , ** json_dumps_params ) <NEWLINE> super ( ) . __init__ ( content = data , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT>
def valid_index ( self , i , j ) : <NEWLINE> <INDENT> def is_valid ( idx ) : <NEWLINE> <INDENT> return isinstance ( idx , ( int , Integer , Symbol , Expr ) <NEWLINE> <DEDENT> return ( is_valid ( i ) and is_valid ( j ) and <NEWLINE> <INDENT> ( 0 <= i ) != False and ( i < self . rows ) != False and <NEWLINE> ( 0 <= j ) != False and ( j < self . cols ) != False ) <NEWLINE> <DEDENT> <DEDENT>
def show_mat ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for m in self . mat : <NEWLINE> <INDENT> print ( <STRING> , <NEWLINE> for c in m : <NEWLINE> <INDENT> print ( c , ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import logging <NEWLINE> from telemetry . page import shared_page_state <NEWLINE> class DiagonalScrollingSupportedSharedState ( <NEWLINE> <INDENT> shared_page_state . SharedDesktopPageState ) : <NEWLINE> def CanRunOnBrowser ( self , browser_info ) : <NEWLINE> if not browser_info . HasDiagonalScrollingSupport ( ) : <NEWLINE> <INDENT> logging . warning ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT>
def _convert_date ( self , d ) : <NEWLINE> <INDENT> for s in ( <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> <DEDENT> <STRING> , <STRING> , ) : <NEWLINE> try : <NEWLINE> return datetime . datetime . strptime ( d , s ) <NEWLINE> except ValueError : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>
( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>
def preamble ( ) : <NEWLINE> <INDENT> if ( metric ) : <NEWLINE> <INDENT> print ( <STRING> % ( feed ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> % ( feed ) ) ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> pen_up ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
def get_tbres ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . D . has_key ( <STRING> ) : <NEWLINE> <INDENT> return self . D [ <STRING> ] <NEWLINE> <INDENT> else : <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT> <DEDENT>
def load_queue_file ( filename ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> loaded_lines = [ [ <STRING> ] ] <NEWLINE> with open ( filename ) as f : <NEWLINE> <INDENT> lines = f . readlines ( ) <NEWLINE> <DEDENT> j = 0 <NEWLINE> for i in range ( 0 , len ( lines ) ) : <NEWLINE> <INDENT> loaded_lines [ j ] . append ( lines [ i ] ) <NEWLINE> <INDENT> if lines [ i ] == <STRING> : <NEWLINE> <INDENT> loaded_lines . append ( [ ] ) <NEWLINE> j += 1 <NEWLINE> return loaded_lines <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
class People ( models . Model ) : <NEWLINE> <INDENT> name = models . CharField ( max_length = 30 ) <NEWLINE> age = models . IntegerField ( ) <NEWLINE> def __unicode__ ( self ) : <NEWLINE> return self . name <NEWLINE> <DEDENT>
( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def parse_itrf_ascii_to_xyz_and_labels ( tabledata ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> tbl = ascii . read ( tabledata <NEWLINE> <INDENT> names = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) ) <NEWLINE> <DEDENT> xyz = hstack_table_columns_as_ndarray ( tbl . columns [ : 3 ] ) * u . m <NEWLINE> labels = tbl [ <STRING> ] . data <NEWLINE> return xyz , labels <NEWLINE> <DEDENT>
def create_new_waypoint ( self , widget , ( x , y ) ) : <NEWLINE> <INDENT> wp = Waypoint ( ) <NEWLINE> wp . name = <STRING> <NEWLINE> wp . set_coordinates ( self . xy_to_coordinates ( x , y ) ) <NEWLINE> self . _session . wpList . append ( self . _session . get_manual_list_iter ( ) , ( wp , ) ) <NEWLINE> <DEDENT>
def mapping_items ( mapping ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if type ( mapping ) is dict : <NEWLINE> <INDENT> return iter ( sorted ( iteritems ( mapping ) ) ) ) <NEWLINE> <DEDENT> return iteritems ( mapping ) <NEWLINE> <DEDENT>
from openpyxl import load_workbook <NEWLINE> from pprint import pprint <NEWLINE> wb = load_workbook ( filename = <STRING> ) <NEWLINE> ws = wb [ <STRING> ] <NEWLINE> names = { } <NEWLINE> for rdx , row in enumerate ( ws . rows ) : <NEWLINE> <INDENT> if rdx > 1 : <NEWLINE> <INDENT> if row [ 2 ] . value is not None : <NEWLINE> <INDENT> exec <STRING> + row [ 2 ] . value <NEWLINE> for p in tmp : <NEWLINE> <INDENT> names . setdefault ( p , 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> pprint ( names . keys ( ) ) <NEWLINE>
def get_instance ( cls ) : <NEWLINE> <INDENT> if cls . _instance is None : <NEWLINE> <INDENT> service_plugins = manager . NeutronManager . get_service_plugins ( ) <NEWLINE> cls . _instance = cls ( get_extensions_path ( service_plugins ) <NEWLINE> <INDENT> service_plugins ) <NEWLINE> <DEDENT> <DEDENT> return cls . _instance <NEWLINE> <DEDENT>
def get_basic_type ( type_ ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> while ( type_ . code == gdb . TYPE_CODE_REF or <NEWLINE> <INDENT> type_ . code == gdb . TYPE_CODE_TYPEDEF ) : <NEWLINE> if type_ . code == gdb . TYPE_CODE_REF : <NEWLINE> <INDENT> type_ = type_ . target ( ) <NEWLINE> else : <NEWLINE> type_ = type_ . strip_typedefs ( ) <NEWLINE> <DEDENT> <DEDENT> return type_ . unqualified ( ) <NEWLINE> <DEDENT>
def retranslateUi ( self , Preferences ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> Preferences . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . dimensionsLabel1 . setText ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def open_tag_with_atr ( self , tag , atr , atrval ) : <NEWLINE> <INDENT> for elem in self . _openelems : <NEWLINE> <INDENT> if ( self . elem_has_tag_and_atr ( elem , tag , atr , atrval ) ) : <NEWLINE> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
def getDataSender ( self , dstServer ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> name = self . getDataSenderClassName ( dstServer . getProtocol ( ) <NEWLINE> module = importlib . import_module ( <STRING> + name , <STRING> ) <NEWLINE> dataSenderClassObject = getattr ( module , name ) <NEWLINE> dataSender = dataSenderClassObject ( dstServer ) <NEWLINE> return dataSender <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , logfile = <STRING> ) : <NEWLINE> <INDENT> self . logfile = None <NEWLINE> if not os . path . exists ( logfile ) and os . path . exists ( os . path . dirname ( logfile ) : <NEWLINE> <INDENT> self . logfile = open ( logfile , <STRING> ) <NEWLINE> self . logfile . close ( ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> self . logfile = open ( logfile , <STRING> ) <NEWLINE> <DEDENT> except IOError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
def get_module ( cmd , sub ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> exec <STRING> % ( cmd , sub , sub ) <NEWLINE> <DEDENT> except ( ImportError , SyntaxError ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return m <NEWLINE> <DEDENT> <DEDENT>
def Update ( ) : <NEWLINE> <INDENT> Log . Debug ( <STRING> ) <NEWLINE> flux_zip = HTTP . Request ( <STRING> ) <NEWLINE> flux_zip . load ( ) <NEWLINE> fp = StringIO ( flux_zip . content ) <NEWLINE> zfile = zipfile . ZipFile ( fp , <STRING> ) <NEWLINE> catalogs = [ json_file for json_file in zfile . namelist ( ) if not json_file . startswith ( <STRING> ) ] <NEWLINE> for json in catalogs : <NEWLINE> Log . Debug ( <STRING> % json ) <NEWLINE> Data . Save ( json , zfile . read ( json ) ) <NEWLINE> return MessageContainer ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def value_letters ( letter ) : <NEWLINE> <INDENT> letter = str ( letter ) <NEWLINE> alphabet = list ( string . ascii_uppercase ) <NEWLINE> value = 0 <NEWLINE> for i in range ( 0 , len ( alphabet ) : <NEWLINE> <INDENT> if letter == alphabet [ i ] : <NEWLINE> <INDENT> value = ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> return value <NEWLINE> <DEDENT>
def test_detach_vm_disk ( self ) : <NEWLINE> <INDENT> self . _lookup_vm ( ) <NEWLINE> mock_disk = self . _prepare_mock_disk ( ) <NEWLINE> with mock . patch . object ( self . _vmutils , <NEWLINE> <INDENT> <STRING> ) as mock_rm_virt_res : <NEWLINE> self . _vmutils . detach_vm_disk ( self . _FAKE_VM_NAME , <NEWLINE> <INDENT> self . _FAKE_HOST_RESOURCE ) <NEWLINE> mock_rm_virt_res . assert_called_with ( mock_disk , self . _FAKE_VM_PATH ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test ( ) : <NEWLINE> <INDENT> phash = helpers . Phash ( plot ( ) <NEWLINE> assert phash . phash == <STRING> , phash . get_details ( ) <NEWLINE> return <NEWLINE> <DEDENT>
def make_connection ( connection , state ) : <NEWLINE> <INDENT> pre_skID , m = connection <NEWLINE> for post_skID , synapses in m . iteritems ( ) : <NEWLINE> <INDENT> for source in ( ( <STRING> % ( pre_skID , post_skID ) , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> % len ( synapses ) ) , <NEWLINE> make_connection_entries ( pre_skID , post_skID , synapses , state ) , <NEWLINE> ( <STRING> , <STRING> ) ) : <NEWLINE> for line in source : <NEWLINE> yield line <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_empty_file ( tmpdir ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> gjtk . cli . main ( argv = [ str ( tmpdir . join ( <STRING> ) ] ) <NEWLINE> <DEDENT>
def _small ( self , attr , field , n ) : <NEWLINE> <INDENT> array = self . _asarray ( attr , field ) <NEWLINE> try : <NEWLINE> <INDENT> n -= 1 <NEWLINE> while ( n ) : <NEWLINE> <INDENT> array . remove ( min ( array ) ) <NEWLINE> n -= 1 <NEWLINE> <DEDENT> return min ( array ) <NEWLINE> <DEDENT> except ValueError , e : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT>
def previous ( self , widget ) : <NEWLINE> <INDENT> self . player . do_previous ( ) <NEWLINE> def quit ( self , widget ) : <NEWLINE> self . shell . quit ( ) <NEWLINE> <DEDENT>
class Auth ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def authenticate ( self , user , passwd ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> , user , <STRING> , passwd ) <NEWLINE> return True <NEWLINE> try : <NEWLINE> <INDENT> return True if self . app . authenticate_account ( user , passwd ) else False <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> print ( e ) <NEWLINE> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
print ( <STRING> ) , self . fields ) <NEWLINE>
def parse ( json , key ) : <NEWLINE> <INDENT> value = None <NEWLINE> try : <NEWLINE> <INDENT> value = json [ key ] <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> raise e <NEWLINE> <DEDENT> return value <NEWLINE> <DEDENT>
def SetIsHidden ( self , is_hidden ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if is_hidden not in [ 0 , 1 ] : <NEWLINE> <INDENT> raise MessageTranslationError , <STRING> <NEWLINE> <DEDENT> self . __is_hidden = is_hidden <NEWLINE> <DEDENT>
( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
from scipy . interpolate import interp1d <NEWLINE> import numpy as np <NEWLINE> import pandas as pd <NEWLINE> import sys , os <NEWLINE> here = os . path . dirname ( os . path . abspath ( __file__ ) <NEWLINE>
def build_icmp ( self ) : <NEWLINE> <INDENT> pkt = IP ( src = self . gateway , dst = self . target ) / ICMP ( type = 5 , code = 1 , , gw = get_if_addr ( self . interface ) ) / IP ( src = self . target , dst = self . gateway ) / UDP ( ) <NEWLINE> return pkt <NEWLINE> <DEDENT>
sayi = int ( input ( <STRING> ) ) <NEWLINE> bolundu = 0 <NEWLINE> for i in range ( 2 , ( sayi // 2 ) : <NEWLINE> <INDENT> if sayi % i == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> bolundu += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( bolundu == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def Error ( self , msg ) : <NEWLINE> <INDENT> if GetOption ( <STRING> ) : print <STRING> % msg <NEWLINE> self . errors . append ( msg ) <NEWLINE> <DEDENT>
def _get_object ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return Object . new_from_sha ( self . repo , hex_to_bin ( self . dereference_recursive ( self . repo , self . path ) ) <NEWLINE> <DEDENT>
def JudgeSuperior ( self , context ) <NEWLINE> <INDENT> self . status_superior = self . status_baseline <NEWLINE> return self . status_superior <NEWLINE> <DEDENT>
def __len__ ( self ) : <NEWLINE> <INDENT> value = self . value ( ) <NEWLINE> if not hasattr ( value , <STRING> ) : <NEWLINE> <INDENT> raise TypeError ( <STRING> % str ( value ) <NEWLINE> <DEDENT> return len ( value ) <NEWLINE> <DEDENT>
def list_inventories ( self ) : <NEWLINE> <INDENT> data = [ ] <NEWLINE> r = requests . get ( self . tower_url + <STRING> , auth = self . tower_credentials , verify = self . ssl_verify ) <NEWLINE> inventories = r . json ( ) <NEWLINE> for inventory in inventories [ <STRING> ] : <NEWLINE> data . append ( <STRING> . format ( inventory [ <STRING> ] , inventory [ <STRING> ] ) ) <NEWLINE> return <STRING> . join ( data ) <NEWLINE> <DEDENT>
def sense_RG ( self , channel_id , user_id ) : <NEWLINE> <INDENT> txtRG = <STRING> <NEWLINE> txtEff = <STRING> <NEWLINE> <INDENT> if user_id == <STRING> : <NEWLINE> <INDENT> printflag = ( randint ( 0 , 6 ) ) <NEWLINE> if printflag == 3 : <NEWLINE> self . clients . send_user_typing_pause ( channel_id ) <NEWLINE> self . send_message ( channel_id , txtRG ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def __init__ ( self , indices_or_sections , axis ) : <NEWLINE> <INDENT> if not isinstance ( <NEWLINE> <INDENT> indices_or_sections , <NEWLINE> six . integer_types + ( collections . Iterable , ) ) : <NEWLINE> raise TypeError ( <STRING> ) <NEWLINE> <DEDENT> if ( chainer . is_debug ( ) and <NEWLINE> <INDENT> isinstance ( indices_or_sections , collections . Iterable ) ) : <NEWLINE> for p , n in six . moves . zip ( <NEWLINE> <INDENT> indices_or_sections , indices_or_sections [ 1 : ] ) : <NEWLINE> <DEDENT> if p > n : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> self . indices_or_sections = indices_or_sections <NEWLINE> self . axis = axis <NEWLINE> <DEDENT>
def test_reset_source_initeration ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with ( repack <NEWLINE> <INDENT> . integer ( ) <NEWLINE> . iterator ( <NEWLINE> <INDENT> iter ( [ <STRING> , <STRING> , <STRING> ] ) ) ) as iterator : <NEWLINE> iterator . send ( iter ( [ <STRING> , <STRING> , <STRING> ] ) ) <NEWLINE> r = [ ] <NEWLINE> for v in iterator : <NEWLINE> <DEDENT> r . append ( v ) <NEWLINE> if v == 11 : <NEWLINE> <INDENT> iterator . send ( iter ( [ 22 , 33 ] ) ) <NEWLINE> <DEDENT> <DEDENT> self . assertSequenceEqual ( [ 11 , 22 , 33 ] , r ) <NEWLINE> <DEDENT>
def test_no_notification_notify_nova_on_port_data_changes_false ( self ) : <NEWLINE> <INDENT> cfg . CONF . set_override ( <STRING> , False ) <NEWLINE> with mock . patch . object ( self . nova_notifier , <NEWLINE> <INDENT> <STRING> ) as send_events : <NEWLINE> self . nova_notifier . send_network_change ( <STRING> , <NEWLINE> <INDENT> { } , { } ) <NEWLINE> self . assertFalse ( send_events . called , False ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def precompile_exceptions ( exceptions , use_regex , flags ) : <NEWLINE> <INDENT> if not exceptions : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for exceptionCategory in [ <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> if exceptionCategory in exceptions : <NEWLINE> patterns = exceptions [ exceptionCategory ] <NEWLINE> if not use_regex : <NEWLINE> <INDENT> patterns = [ re . escape ( pattern ) for pattern in patterns ] <NEWLINE> <DEDENT> patterns = [ re . compile ( pattern , flags ) for pattern in patterns ] <NEWLINE> exceptions [ exceptionCategory ] = patterns <NEWLINE> <DEDENT> <DEDENT>
def containers_index ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if request . args . get ( <STRING> ) == <STRING> : <NEWLINE> output = docker ( <STRING> ) <NEWLINE> else : <NEWLINE> output = docker ( <STRING> , <STRING> ) <NEWLINE> resp = json . dumps ( docker_ps_to_array ( output ) ) <NEWLINE> return Response ( response = resp , mimetype = <STRING> ) <NEWLINE> <DEDENT>
class CanvasA1 ( Canvas ) : <NEWLINE> <INDENT> def __init__ ( self , filename , <NEWLINE> <INDENT> pagesize = None , <NEWLINE> bottomup = 1 , <NEWLINE> pageCompression = None , <NEWLINE> encoding = None , <NEWLINE> invariant = None , <NEWLINE> verbosity = 0 ) : <NEWLINE> Canvas . __init__ ( self , filename , pagesize = pagesize , bottomup = bottomup , pageCompression = pageCompression , <NEWLINE> <INDENT> encoding = encoding , invariant = invariant , verbosity = verbosity ) <NEWLINE> self . scale ( 2.0 * math . sqrt ( 2.0 ) , 2.0 * math . sqrt ( 2.0 ) ) <NEWLINE> self . setPageSize ( A1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def place ( self , x , y ) : <NEWLINE> <INDENT> self . y [ x ] = y self . y [ 0 ] = 0 <NEWLINE> self . row [ y ] = 1 self . row [ 0 ] = 1 <NEWLINE> self . up [ x - y ] = 1 self . up [ 0 ] = 1 <NEWLINE> self . down [ x + y ] = 1 self . down [ 0 ] = 1 <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> configdict = { } <NEWLINE> <INDENT> config = <STRING> <NEWLINE> with open ( config ) as config_file : <NEWLINE> <INDENT> for lines in config_file : <NEWLINE> <INDENT> if re . search ( <STRING> , lines ) : <NEWLINE> <INDENT> key = lines . strip ( <STRING> ) . strip ( ) . split ( <STRING> ) <NEWLINE> configdict [ key [ 0 ] ] = key [ 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> testmongo = CountMongo ( configdict ) <NEWLINE> testmongo . count ( ) <NEWLINE> <DEDENT>
class Ui_MainWindow ( QtGui . QWidget ) : <NEWLINE> <INDENT> def setupUi ( self , MainWindow ) : <NEWLINE> <INDENT> MainWindow . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> MainWindow . resize ( 500 , 273 ) <NEWLINE> MainWindow . setFixedSize ( 500 , 273 ) <NEWLINE> MainWindow . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , wbits = MAX_WBITS ) : <NEWLINE> <INDENT> if abs ( wbits ) > MAX_WBITS or abs ( wbits ) < 8 : <NEWLINE> <INDENT> raise ValueError , <STRING> <NEWLINE> <DEDENT> self . inflater = Inflater ( wbits < 0 ) <NEWLINE> self . unused_data = <STRING> <NEWLINE> self . _ended = False <NEWLINE> <DEDENT>
def sparse_softmax_cross_entropy ( logits , labels , weights = 1.0 , scope = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with ops . name_scope ( scope , <STRING> , <NEWLINE> <INDENT> [ logits , labels , weights ] ) as scope : <NEWLINE> labels = array_ops . reshape ( labels , shape = [ array_ops . shape ( labels ) [ 0 ] ] ) <NEWLINE> losses = nn . sparse_softmax_cross_entropy_with_logits ( labels = labels , <NEWLINE> <INDENT> logits = logits , <NEWLINE> name = <STRING> ) <NEWLINE> return compute_weighted_loss ( losses , weights , scope = scope ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from utils import * <NEWLINE> from web import * <NEWLINE> import web <NEWLINE> urls = ( <NEWLINE> <INDENT> <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> render = web . template . render ( <STRING> ) <NEWLINE> template = web . template . render ( <STRING> ) <NEWLINE> app = web . application ( urls , globals ( ) <NEWLINE>
def getNeighbors ( self , node ) : <NEWLINE> <INDENT> def filt ( ( nx , ny ) ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return ny >= 0 and nx >= 0 and self . sm [ ny ] [ nx ] != self . TILE_WALL <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return self . _filter_neighbours ( node , [ ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ] , filt ) <NEWLINE> <DEDENT>
def __init__ ( self , color , ( x , y ) , index ) : <NEWLINE> <INDENT> Piece . __init__ ( self , color , ( x , y ) , index ) <NEWLINE> self . points = 1 <NEWLINE> <DEDENT>
def pyrun ( src ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if PY3 : <NEWLINE> <INDENT> src = bytes ( src , <STRING> ) <NEWLINE> <DEDENT> with tempfile . NamedTemporaryFile ( <NEWLINE> <INDENT> prefix = TESTFILE_PREFIX , delete = False ) as f : <NEWLINE> _testfiles . append ( f . name ) <NEWLINE> f . write ( src ) <NEWLINE> f . flush ( ) <NEWLINE> subp = get_test_subprocess ( [ PYTHON , f . name ] , stdout = None , <NEWLINE> <INDENT> stderr = None ) <NEWLINE> wait_for_pid ( subp . pid ) <NEWLINE> return subp <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def indented_title ( self ) : <NEWLINE> <INDENT> indent = len ( self . real_path . split ( <STRING> ) - 1 <NEWLINE> if not indent : <NEWLINE> <INDENT> return self . title <NEWLINE> <DEDENT> return <STRING> % ( <STRING> * indent , self . title ) <NEWLINE> <DEDENT>
def run_check ( callback ) : <NEWLINE> <INDENT> instance = urllib2 . urlopen ( urllib2 . Request ( <STRING> ) ) . read ( ) <NEWLINE> if instance == <STRING> : <NEWLINE> <INDENT> callback ( <STRING> , elb_metrics ( <STRING> ) ) <NEWLINE> <DEDENT> for mountpoint , volume in get_ebs_volumes ( instance ) : <NEWLINE> <INDENT> callback ( <STRING> , ebs_metrics ( mountpoint , volume ) <NEWLINE> <DEDENT> <DEDENT>
def grad ( self , inp , grads ) : <NEWLINE> <INDENT> x , = inp <NEWLINE> gz , = grads <NEWLINE> return Rebroadcast ( * [ ( axis , x . type . broadcastable [ axis ] ) <NEWLINE> <DEDENT>
def keyGreen ( self ) : <NEWLINE> <INDENT> config . misc . window_animation_speed . save ( ) <NEWLINE> <INDENT> setAnimation_speed ( int ( config . misc . window_animation_speed . value ) ) <NEWLINE> <DEDENT> self . close ( ) <NEWLINE> <DEDENT>
def camera_capture ( message ) : <NEWLINE> <INDENT> delay = 0 <NEWLINE> body = message [ <STRING> ] . split ( <STRING> ) <NEWLINE> try : <NEWLINE> if body [ 3 ] . isdigit ( ) : <NEWLINE> <INDENT> delay = int ( body [ 3 ] ) <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> filename = timestamp + <STRING> <NEWLINE> time . sleep ( delay ) <NEWLINE> droid . cameraCapturePicture ( path_camera + filename ) <NEWLINE> <DEDENT>
class Ui_MainWindow ( object ) : <NEWLINE> <INDENT> def setupUi ( self , MainWindow ) : <NEWLINE> <INDENT> MainWindow . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> MainWindow . setEnabled ( True ) <NEWLINE> MainWindow . resize ( 792 , 347 ) <NEWLINE> MainWindow . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
def CheckLocation ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for url in ( config_lib . CONFIG [ <STRING> ] + <NEWLINE> <INDENT> config_lib . CONFIG [ <STRING> ] ) : <NEWLINE> if <STRING> in url or <STRING> in url : <NEWLINE> return <NEWLINE> <DEDENT> logging . error ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT>
def tempdir ( ** kwargs ) : <NEWLINE> <INDENT> tmpdir = tempfile . mkdtemp ( ** kwargs ) <NEWLINE> try : <NEWLINE> <INDENT> yield tmpdir <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> shutil . rmtree ( tmpdir ) <NEWLINE> <DEDENT> except OSError , e : <NEWLINE> <INDENT> LOG . debug ( _ ( <STRING> ) , str ( e ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def handle_dashboard_error ( view ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def wrapper ( request , course_id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> return view ( request , course_id = course_id ) <NEWLINE> <DEDENT> except DashboardError , error : <NEWLINE> <INDENT> return error . response ( ) <NEWLINE> <DEDENT> <DEDENT> return wrapper <NEWLINE> <DEDENT>
def seek ( self frame ) : <NEWLINE> <INDENT> if frame >= len ( self . _offset ) : <NEWLINE> <INDENT> raise EOFError ( <STRING> ) <NEWLINE> <DEDENT> self . frame = frame <NEWLINE> self . fp = self . __fp <NEWLINE> self . fp . seek ( self . _offset [ frame ] ) <NEWLINE> PcxImageFile . _open ( self ) <NEWLINE> <DEDENT>
def get_category ( self , catname ) : <NEWLINE> <INDENT> cat = category . Category ( self . site , catname ) <NEWLINE> items = [ ] <NEWLINE> for article in cat . getAllMembersGen ( namespaces = [ 0 ] ) : <NEWLINE> <INDENT> items . append ( article . title . lower ( ) ) <NEWLINE> if len ( items ) % 1000 == 0 : <NEWLINE> <INDENT> print <STRING> % ( len ( items ) , items [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> return items <NEWLINE> <DEDENT>
def notify_loop ( self , event_payload ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> sleep ( 60 ) <NEWLINE> LOGGER . debug ( str ( event_payload ) <NEWLINE> event_payload = [ ] <NEWLINE> <DEDENT> <DEDENT>
def get_help_text_stored_procedure ( stored_procedure , host , database ) : <NEWLINE> <INDENT> connection = pymssql . connect ( host = host , database = database , as_dict = True ) <NEWLINE> cursor = connection . cursor ( ) <NEWLINE> result = <STRING> <NEWLINE> cursor . execute ( <STRING> . format ( stored_procedure ) <NEWLINE> for row in cursor : <NEWLINE> <INDENT> result = result + row [ <STRING> ] <NEWLINE> <DEDENT> connection . close ( ) <NEWLINE> return result <NEWLINE> <DEDENT>
def clean ( self ) : <NEWLINE> <INDENT> if ( <STRING> in self . errors and <STRING> in self . data and <NEWLINE> <INDENT> 1 < len ( self . data [ <STRING> ] ) < PasswordMixin . min_length ) : <NEWLINE> msg = _ ( <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> ) % ( PasswordMixin . min_length , <NEWLINE> <INDENT> reverse ( <STRING> ) ) <NEWLINE> self . _errors [ <STRING> ] = ErrorList ( [ mark_safe ( msg ) ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if <STRING> in self . errors : <NEWLINE> <INDENT> return { } <NEWLINE> <DEDENT> return super ( AuthenticationForm , self ) . clean ( ) <NEWLINE> <DEDENT>
class AssertPhaseInstructionThatPassIffStdoutEqualsString ( AssertPhaseInstruction ) : <NEWLINE> <INDENT> def __init__ ( self , expected : str ) : <NEWLINE> <INDENT> self . expected = expected <NEWLINE> <DEDENT> def main ( self , environment : InstructionEnvironmentForPostSdsStep , <NEWLINE> <INDENT> os_services : OsServices ) -> pfh . PassOrFailOrHardError : <NEWLINE> actual_contents = environment . sds . result . stdout_file . read_text ( ) <NEWLINE> if actual_contents == self . expected : <NEWLINE> return pfh . new_pfh_pass ( ) <NEWLINE> else : <NEWLINE> err_msg = <STRING> . format ( self . expected , actual_contents ) <NEWLINE> return pfh . new_pfh_fail ( err_msg ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , parameters ) : <NEWLINE> <INDENT> command = parameters . command . finalize ( ) <NEWLINE> invokation = <STRING> % ( <STRING> if parameters . pileup_only else <STRING> <NEWLINE> <INDENT> parameters . nbatches ) <NEWLINE> <DEDENT> description = <STRING> % ( invokation , <NEWLINE> <INDENT> parameters . infile , <NEWLINE> parameters . outfile ) <NEWLINE> <DEDENT> CommandNode . __init__ ( self , <NEWLINE> <INDENT> description = description , <NEWLINE> command = command , <NEWLINE> threads = parameters . nbatches , <NEWLINE> dependencies = parameters . dependencies ) <NEWLINE> <DEDENT> <DEDENT>
def mjd ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> return int ( float ( self . start_time ) / 86400.0 + 0.3 ) <NEWLINE> <DEDENT> <DEDENT>
def impala_review_list_box ( context , addon , , reviews ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> c = dict ( context . items ( ) ) <NEWLINE> c . update ( addon = addon , reviews = reviews ) <NEWLINE> return c <NEWLINE> <DEDENT>
def templates_list ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return render ( <NEWLINE> <INDENT> node_templates = [ nt . dict for nt in api . get_node_templates ( ) ] ) <NEWLINE> <DEDENT> <DEDENT> except Exception , e : <NEWLINE> <INDENT> abort_and_log ( 500 , <STRING> , e ) <NEWLINE> <DEDENT> <DEDENT>
def read_file ( file_name , dir = os . path . dirname ( __file__ ) : <NEWLINE> <INDENT> file_path = os . path . join ( dir , file_name ) <NEWLINE> with open ( file_path ) as fd : <NEWLINE> <INDENT> return fd . read ( ) <NEWLINE> <DEDENT> <DEDENT>
def retranslateUi ( self , SvnNewProjectOptionsDialog ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> SvnNewProjectOptionsDialog . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> SvnNewProjectOptionsDialog . setWhatsThis ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def printxml ( tree ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( etree . tostring ( tree , pretty_print ( = True ) ) <NEWLINE> return <NEWLINE> <DEDENT>
def processHeader ( self , msg ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if msg . startswith ( <STRING> ) : <NEWLINE> self . contentlength = int ( msg [ len ( <STRING> ) : ] ) <NEWLINE> <DEDENT>
def dump ( record , fobj = sys . stdout ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for key , value in sorted ( record . items ( ) : <NEWLINE> <INDENT> if isinstance ( key , tuple ) : <NEWLINE> <INDENT> key = <STRING> . join ( key ) <NEWLINE> <DEDENT> fobj . write ( <STRING> % ( key , value ) ) <NEWLINE> <DEDENT> fobj . write ( <STRING> ) <NEWLINE> fobj . flush ( ) <NEWLINE> <DEDENT>
def test_FromHex ( self ) : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> epc = self . _giai96 . encode ( self . _companyPrefix , None , self . _itemRef , self . _filter , None ) <NEWLINE> hex = epc . toHex ( ) <NEWLINE> epc = epc . fromHex ( hex ) <NEWLINE> self . _checkFields ( epc ) <NEWLINE> print ( epc . toHex ( ) ) <NEWLINE> print ( epc . toBinary ( ) ) <NEWLINE> print ( <STRING> <NEWLINE> print ( <STRING> <NEWLINE> <DEDENT>
def user_import_form ( nodes = [ ] , products = [ ] ) : <NEWLINE> <INDENT> return pyforms . Form ( <NEWLINE> <INDENT> pyforms . Dropdown ( <STRING> , description = <STRING> , args = nodes , ** input_style ) , <NEWLINE> pyforms . Dropdown ( <STRING> , args = products , description = <STRING> , required = <STRING> , ** input_style ) , <NEWLINE> pyforms . File ( <STRING> , description = <STRING> , required = <STRING> , ** input_style ) , <NEWLINE> pyforms . Button ( <STRING> , type = <STRING> , html = <STRING> , ** button_style ) , <NEWLINE> title = <STRING> , <NEWLINE> action = <STRING> <NEWLINE> <DEDENT> <DEDENT>
def test_sauce ( self ) : <NEWLINE> <INDENT> el = self . driver . find_element_by_ios_uiautomation ( <STRING> ) <NEWLINE> el . is_displayed ( ) <NEWLINE> <INDENT> action = TouchAction ( self . driver ) <NEWLINE> <DEDENT> action . tap ( el ) . perform ( ) <NEWLINE> <DEDENT>
def copy ( self , source , destination , error_on_failure = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> res = self . _copy_on_client ( source , destination ) <NEWLINE> if error_on_failure and not res . is_success ( ) : <NEWLINE> <INDENT> error_message = <STRING> . format ( <NEWLINE> <INDENT> source , <NEWLINE> destination , <NEWLINE> res . raw_error <NEWLINE> res . raw_output , <NEWLINE> res . returncode , <NEWLINE> <DEDENT> ) <NEWLINE> raise RuntimeError ( error_message ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return res <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> _RTLD_GLOBAL = 0 <NEWLINE> try : <NEWLINE> <INDENT> from dl import RTLD_GLOBAL as _RTLD_GLOBAL <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> try : <NEWLINE> from DLFCN import RTLD_GLOBAL as _RTLD_GLOBAL <NEWLINE> except ImportError : <NEWLINE> pass <NEWLINE> <DEDENT> if _RTLD_GLOBAL != 0 : <NEWLINE> <INDENT> _dlopenflags = sys . getdlopenflags ( ) <NEWLINE> sys . setdlopenflags ( _dlopenflags | _RTLD_GLOBAL ) <NEWLINE> <DEDENT> from ieee802_11_swig import * <NEWLINE> if _RTLD_GLOBAL != 0 : <NEWLINE> <INDENT> sys . setdlopenflags ( _dlopenflags ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from sys import argv <NEWLINE> script , filename = argv <NEWLINE> txt = open ( filename ) <NEWLINE> print ( <STRING> % filename ) <NEWLINE> print ( txt . read ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> file_again = raw_input ( <STRING> ) <NEWLINE> txt_again = open ( file_again ) <NEWLINE> print ( txt_again . read ( ) ) <NEWLINE> txt . close ( ) <NEWLINE> txt_again . close ( ) <NEWLINE>
import urllib , urllib2 , sys , httplib <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> connection = httplib . HTTPConnection ( <STRING> ) <NEWLINE> <INDENT> body_content = <STRING> <NEWLINE> headers = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> <NEWLINE> } <NEWLINE> <DEDENT> <DEDENT> connection . request ( <STRING> , <STRING> , body = body_content , headers = headers ) <NEWLINE> <DEDENT> result = connection . getresponse ( ) <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> <DEDENT>
def userEntryChanged ( self , command ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> print ( command ) <NEWLINE> exec command <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( sys . exc_info ( ) ) <NEWLINE> print_tb ( sys . exc_info ( ) [ 2 ] ) <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> self . userEntry [ <STRING> ] = True <NEWLINE> <DEDENT> <DEDENT>
def retranslateUi ( self , Dialog ) : <NEWLINE> <INDENT> Dialog . setWindowTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label . setText ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def is_accession_for_server ( instance ) : <NEWLINE> <INDENT> from . server_defaults import ( <NEWLINE> <INDENT> ACCESSION_FACTORY , <NEWLINE> test_accession , <NEWLINE> , <NEWLINE> <DEDENT> ) <NEWLINE> if accession_re . match ( instance ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> request = get_current_request ( ) <NEWLINE> if request . registry [ ACCESSION_FACTORY ] is test_accession : <NEWLINE> <INDENT> if test_accession_re . match ( instance ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>
class AdjuntoForm ( forms . ModelForm ) : <NEWLINE> <INDENT> class Meta : <NEWLINE> model = Documentos <NEWLINE> exclude = ( <STRING> , <STRING> , <STRING> , ) <NEWLINE> <DEDENT>
def get_all_logged_in_users ( ) : <NEWLINE> <INDENT> uid_list = [ ] <NEWLINE> <INDENT> data = session . get_decoded ( ) <NEWLINE> uid_list . append ( data . get ( <STRING> , None ) ) <NEWLINE> <DEDENT> <DEDENT>
def accept_invitation ( self , invite_id , member_id , credentials , options ) : <NEWLINE> <INDENT> with MethodContext ( self , SA_LOG_PREFIX , <STRING> , <NEWLINE> <INDENT> { <STRING> : invite_id , <STRING> : member_id } , <NEWLINE> credentials , options , read_only = False ) as mc : <NEWLINE> if not mc . _error : <NEWLINE> mc . _result = self . _delegate . accept_invitation ( mc . _client_cert , <NEWLINE> <INDENT> invite_id , <NEWLINE> member_id , <NEWLINE> credentials , <NEWLINE> options , <NEWLINE> mc . _session ) <NEWLINE> <DEDENT> <DEDENT> return mc . _result <NEWLINE> <DEDENT>
def add_lines ( self , paragraphs ) : <NEWLINE> <INDENT> for paragraph in paragraphs : <NEWLINE> del self . buffer [ 0 ] <NEWLINE> <INDENT> self . buffer . append ( paragraph ) <NEWLINE> if self . offset > 0 : <NEWLINE> self . offset = self . offset + 1 <NEWLINE> if self . offset > self . scrollback - self . numlines : <NEWLINE> <DEDENT> self . offset = self . scrollback - self . numlines <NEWLINE> return self . render ( ) <NEWLINE> <DEDENT>
def nextprime ( number ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> potential = number <NEWLINE> j = 3 <NEWLINE> while j <= sqrt ( potential ) : <NEWLINE> <INDENT> if potential % j : <NEWLINE> j = j + 2 <NEWLINE> else : <NEWLINE> potential = potential + 2 <NEWLINE> j = 3 <NEWLINE> continue <NEWLINE> <DEDENT> return potential <NEWLINE> <DEDENT>
def saveCustomDefinitions ( self , fileobj ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for ctype , defns in ( <NEWLINE> <INDENT> ( <STRING> , self . def_imports ) , <NEWLINE> ( <STRING> , self . def_definitions ) , <NEWLINE> ( <STRING> , self . def_colors ) , <NEWLINE> ( <STRING> , self . def_colormaps ) ) : <NEWLINE> for val in defns : <NEWLINE> fileobj . write ( <NEWLINE> <INDENT> <STRING> % ( <NEWLINE> <INDENT> repr ( ctype ) , repr ( val [ 0 ] ) , repr ( val [ 1 ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
( <STRING> + str ( skipped ) + <STRING> + str ( inserted ) + <STRING> + str ( <NEWLINE> <INDENT> updated ) + <STRING> + str ( account_id ) + <STRING> <NEWLINE> <DEDENT> <DEDENT>
def editor_saved ( self , user , old_metadata , old_content ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> old_source_library_id = old_metadata . get ( <STRING> , [ ] ) <NEWLINE> if ( old_source_library_id != self . source_library_id or <NEWLINE> <INDENT> old_metadata . get ( <STRING> , ANY_CAPA_TYPE_VALUE ) != self . capa_type ) : <NEWLINE> try : <NEWLINE> self . refresh_children ( ) <NEWLINE> except ValueError : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>
def parse ( self , _in ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> xml . sax . parseString ( _in , self ) <NEWLINE> return self . env <NEWLINE> <DEDENT> <DEDENT>
from bs4 import BeautifulSoup <NEWLINE> from datetime import date <NEWLINE> import os . path as path <NEWLINE> import sys <NEWLINE> _SRC = path . join ( path . dirname ( path . abspath ( __file__ ) ) , <STRING> , <STRING> ) <NEWLINE> _COMPILE_JS = path . join ( <NEWLINE> <INDENT> _SRC , <STRING> , <STRING> , <STRING> ) <NEWLINE> <DEDENT> _POLYMERS = [ <STRING> % p for p in <STRING> , <STRING> , <STRING> ] <NEWLINE> _WEB_ANIMATIONS_BASE = <STRING> <NEWLINE> _WEB_ANIMATIONS_TARGET = <STRING> <NEWLINE> _COMPILED_RESOURCES_TEMPLATE = <STRING> . strip ( ) <NEWLINE>
def chunk ( sequence , size ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for ( _ , pairs ) in itertools . groupby ( enumerate ( sequence ) , lambda ( i , _ ) : i / size ) : <NEWLINE> <INDENT> yield ( v for ( _ , v ) in pairs ) <NEWLINE> <DEDENT> <DEDENT>
def newsletters ( self ) : <NEWLINE> <INDENT> newsletters = [ <STRING> ] <NEWLINE> for newsletter in [ <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> ] : <NEWLINE> if self . cleaned_data . get ( newsletter , False ) : <NEWLINE> newsletters . append ( newsletter [ 3 : ] . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT> return newsletters <NEWLINE> <DEDENT>
def isGod ( self , nickname , host ) : <NEWLINE> <INDENT> XMLHandler = serviceXML ( ) <NEWLINE> XMLParser = xml . sax . make_parser ( ) <NEWLINE> XMLParser . setContentHandler ( XMLHandler ) <NEWLINE> XMLParser . parse ( self . servicesFile ) <NEWLINE> for reg in XMLHandler . getGodList ( ) : <NEWLINE> if reg [ 0 ] == <STRING> : <NEWLINE> <INDENT> if re . search ( reg [ 1 ] , nickname ) != None : <NEWLINE> return True <NEWLINE> elif reg [ 0 ] == <STRING> : <NEWLINE> if re . search ( reg [ 1 ] , host ) != None : <NEWLINE> return True <NEWLINE> return False <NEWLINE> <DEDENT> <DEDENT>
def zip_files ( self ) : <NEWLINE> <INDENT> file = zipfile . ZipFile ( self . zipname , , <STRING> ) <NEWLINE> for filename in os . listdir ( self . temp_directory ) : <NEWLINE> <INDENT> file . write ( self . _full_filename ( filename ) , filename ) <NEWLINE> <DEDENT> shutil . rmtree ( self . temp_directory ) <NEWLINE> <DEDENT>
def _handleMuxers ( self ) : <NEWLINE> <INDENT> for muxerName , components in [ ( <STRING> , [ self . _audioEncoder ] ) , <NEWLINE> <INDENT> ( <STRING> , [ self . _videoEncoder ] ) , <NEWLINE> ( <STRING> , [ self . _audioEncoder , <NEWLINE> <INDENT> self . _videoEncoder ] ) ] : <NEWLINE> muxer = self . _getMuxer ( muxerName ) <NEWLINE> if muxer . feeders : <NEWLINE> self . _flowComponents . append ( muxer ) <NEWLINE> for component in components : <NEWLINE> component and component . link ( muxer ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
( <STRING> % ( debug_nb_sign , debug_nb_clusters , debug_nb_cmp_clusters , debug_nb_elements , debug_nb_cmp_elements ) , <NEWLINE> print ( <STRING> % ( debug_nb_cmp_max , ( ( debug_nb_cmp_elements / float ( debug_nb_cmp_max ) ) * 100 ) ) ) <NEWLINE>
def drawCloud ( tags : list , filename : str , fontname : str = <STRING> , size = ( 1920 , 1080 ) ) ) : <NEWLINE> <INDENT> pytagcloud . create_tag_image ( tags , filename , fontname = fontname , size = size ) <NEWLINE> webbrowser . open ( filename ) <NEWLINE> <DEDENT>
def get_any ( self , value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not isinstance ( value , ( list , tuple ) ) : <NEWLINE> <INDENT> raise ValueError , <STRING> <NEWLINE> <DEDENT> return self . operator ( <STRING> , value ) <NEWLINE> <DEDENT>
def create ( self , name , instance_dir = None , config = <STRING> , schema = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> params = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : name , <NEWLINE> <STRING> : config , <NEWLINE> <STRING> : schema , <NEWLINE> , <NEWLINE> <DEDENT> } <NEWLINE> if instance_dir is None : <NEWLINE> <INDENT> params . update ( instanceDir = name ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> params . update ( instanceDir = instance_dir ) <NEWLINE> <DEDENT> return self . _get_url ( self . url , params = params ) <NEWLINE> <DEDENT>
def CATEGORIES ( url , value ) : <NEWLINE> <INDENT> if ( dbg ) : print url <NEWLINE> data = getUrl ( url ) <NEWLINE> for ( href , title ) in re . findall ( <STRING> + value + <STRING> , data , re . S | re . I ) : <NEWLINE> <INDENT> if ( dbg ) : <NEWLINE> <INDENT> print href , title <NEWLINE> <DEDENT> addDir ( clean ( title ) , href , 1 , <STRING> , True ) <NEWLINE> <DEDENT> if forceViewMode : xbmc . executebuiltin ( <STRING> + viewMode + <STRING> ) <NEWLINE> <DEDENT>
def check_merkle_branch ( tip_hash , index , merkle_branch ) : <NEWLINE> <INDENT> return reduce ( lambda c , ( i , h ) : hash256 ( merkle_record_type . pack ( <NEWLINE> <INDENT> dict ( left = h , right = c ) if 2 ** i & index else <NEWLINE> dict ( left = c , right = h ) <NEWLINE> <DEDENT> ) ) , enumerate ( merkle_branch ) , tip_hash ) <NEWLINE> <DEDENT>
class GameFactory ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , game_type ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . result = False <NEWLINE> module_name = <STRING> % game_type <NEWLINE> exec <STRING> % ( game_type , module_name ) <NEWLINE> exec <STRING> % module_name <NEWLINE> <DEDENT> <DEDENT>
def is_move_valid ( self , player , move ) : <NEWLINE> <INDENT> if move_beside_valid_piece ( player , move ) : <NEWLINE> <INDENT> if check_line_end_in_same_color ( player , move ) <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>
from telemetry . core . backends import form_based_credentials_backend_unittest_base <NEWLINE> from telemetry . core . backends import facebook_credentials_backend <NEWLINE> class TestFacebookCredentialsBackend ( <NEWLINE> <INDENT> form_based_credentials_backend_unittest_base . <NEWLINE> FormBasedCredentialsBackendUnitTestBase ) : <NEWLINE> def setUp ( self ) : <NEWLINE> self . _credentials_type = <STRING> <NEWLINE> def testLoginUsingMock ( self ) : <NEWLINE> self . _LoginUsingMock ( <NEWLINE> <INDENT> facebook_credentials_backend . FacebookCredentialsBackend ( ) , <NEWLINE> <STRING> , <STRING> , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def custom_fetch ( self , inputs , fetch_layers ) : <NEWLINE> <INDENT> feed_dict = dict ( zip ( [ l . get_output ( ) for l in self . input_placeholder_layers ] , inputs ) <NEWLINE> feed_dict [ self . is_training ] = False <NEWLINE> return self . session . run ( fetch_layers , feed_dict = feed_dict ) <NEWLINE> <DEDENT>
from npieces import State <NEWLINE> def template ( problem ) <NEWLINE> <INDENT> <STRING> <NEWLINE> return State ( None ) <NEWLINE> <DEDENT>
from django . conf import settings <NEWLINE> try : <NEWLINE> <INDENT> from importlib import import_module <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> from django . utils . importlib import import_module <NEWLINE> <DEDENT> <STRING> <NEWLINE> backend_models = getattr ( settings , <STRING> , <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> exec <STRING> % backend_models <NEWLINE>
def get_arbiter_master_selected ( self ) : <NEWLINE> <INDENT> if self . dbg : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> return self . arbiter_selected <NEWLINE> <DEDENT>
def _async_render ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> return self . _template . async_render ( ) . lower ( ) == <STRING> <NEWLINE> <DEDENT> except TemplateError as ex : <NEWLINE> <INDENT> if ex . args and ex . args [ 0 ] . startswith ( <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> _LOGGER . warning ( <STRING> <NEWLINE> <INDENT> <STRING> , self . _name ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> _LOGGER . error ( <STRING> , self . _name , ex ) <NEWLINE> <DEDENT> <DEDENT>
def test_legacy_source_image ( self ) : <NEWLINE> <INDENT> for legacy , new in zip ( self . legacy_mapping_source_image , <NEWLINE> <INDENT> self . new_mapping_source_image ) : <NEWLINE> if new [ <STRING> ] == <STRING> : <NEWLINE> self . assertThat ( legacy , matchers . IsSubDictOf ( new . legacy ( ) ) ) <NEWLINE> else : <NEWLINE> self . assertRaises ( exception . InvalidBDMForLegacy , new . legacy ) <NEWLINE> <DEDENT> <DEDENT>
def get_summary_str ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> items = [ ] <NEWLINE> for item in [ <NEWLINE> <INDENT> self . job_log_dir , <NEWLINE> self . batch_sys_name , <NEWLINE> self . batch_sys_job_id , <NEWLINE> self . batch_sys_exit_polled , <NEWLINE> self . run_status , <NEWLINE> self . run_signal , <NEWLINE> self . time_submit_exit , <NEWLINE> self . time_run , <NEWLINE> self . time_run_exit ] : <NEWLINE> if item is None : <NEWLINE> items . append ( <STRING> ) <NEWLINE> else : <NEWLINE> items . append ( str ( item ) ) <NEWLINE> <DEDENT> return <STRING> . join ( items ) <NEWLINE> <DEDENT>
class Point : <NEWLINE> <INDENT> def __init__ ( self , ( vert , norm ) ) : <NEWLINE> <INDENT> assert ( isinstance ( vert , Vector ) ) <NEWLINE> assert ( isinstance ( norm , Vector ) ) <NEWLINE> self . vert = vert <NEWLINE> self . norm = norm <NEWLINE> <DEDENT> def __repr__ ( self ) : <NEWLINE> <INDENT> return <STRING> % ( repr ( self . vert ) , repr ( self . norm ) ) <NEWLINE> <DEDENT> <DEDENT>
print ( <STRING> ) , <STRING> . join ( fileNames ) ) <NEWLINE>
_LANGUAGES_NOT_IN_BUILD = [ ] <NEWLINE> def UpdateSettingsForCheckedInVersion ( env , <NEWLINE> <INDENT> version_major , <NEWLINE> version_minor , <NEWLINE> version_build , <NEWLINE> version_patch , <NEWLINE> oneclick_plugin_version ) : <NEWLINE> print <NEWLINE> print ( <STRING> ) <NEWLINE> env . SetProductVersion ( <NEWLINE> version_major , version_minor , version_build , version_patch ) <NEWLINE> print <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> + oneclick_plugin_version ) <NEWLINE> print ( <STRING> ) <NEWLINE> env . SetActiveXFilenames ( oneclick_plugin_version ) <NEWLINE> for language in _LANGUAGES_NOT_IN_BUILD : <NEWLINE> if language in env [ <STRING> ] : <NEWLINE> env [ <STRING> ] . remove ( language ) <NEWLINE> print ( <STRING> + language ) <NEWLINE> return _LANGUAGES_NOT_IN_BUILD <NEWLINE> <DEDENT>
from django . conf . urls import include , url <NEWLINE> from django . contrib import admin <NEWLINE> from django . contrib . staticfiles . urls import staticfiles_urlpatterns <NEWLINE> admin . autodiscover ( ) <NEWLINE> urlpatterns = [ <NEWLINE> <INDENT> url ( <STRING> , include ( <STRING> , namespace = <STRING> ) ) , <NEWLINE> url ( <STRING> , include ( admin . site . urls ) , <NEWLINE> <DEDENT> ] <NEWLINE> urlpatterns += staticfiles_urlpatterns ( ) <NEWLINE>
def draw_line ( self , gc , x1 , y1 , x2 , y2 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if debugPrint : <NEWLINE> <INDENT> print <STRING> . format ( x1 , y1 , x2 , y2 ) <NEWLINE> <DEDENT> if self . select_pen ( gc ) : <NEWLINE> <INDENT> self . emf . Polyline ( [ ( long ( x1 ) , long ( self . height - y1 ) ) , ( long ( x2 ) , long ( self . height - y2 ) ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if debugPrint : print <STRING> . format ( x1 , y1 , x2 , y2 ) <NEWLINE> <DEDENT> <DEDENT>
def install_examples ( request ) : <NEWLINE> <INDENT> response = { <STRING> : - 1 , <STRING> : <STRING> } <NEWLINE> if request . method == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> Command ( ) . handle ( user = request . user ) <NEWLINE> response [ <STRING> ] = 0 <NEWLINE> <DEDENT> except Exception , err : <NEWLINE> <INDENT> LOG . exception ( err ) <NEWLINE> response [ <STRING> ] = str ( err ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> response [ <STRING> ] = _ ( <STRING> ) <NEWLINE> <DEDENT> return JsonResponse ( response ) <NEWLINE> <DEDENT>
def render_template ( template_filename , output_filename , template_context ) : <NEWLINE> <INDENT> with open ( template_filename , <STRING> ) as f : <NEWLINE> <INDENT> template = jinja2 . Template ( f . read ( ) ) <NEWLINE> <DEDENT> print ( <STRING> % output_filename ) <NEWLINE> with open ( output_filename , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( template . render ( ** template_context ) <NEWLINE> <DEDENT> <DEDENT>
def communicate ( self , in_line ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> err = [ ] <NEWLINE> output = <STRING> <NEWLINE> logging . info ( <STRING> + in_line + <STRING> ) <NEWLINE> if in_line in self . source_hash : <NEWLINE> if self . verbosity > 0 : logging . info ( <STRING> + in_line + <STRING> ) <NEWLINE> output = self . target_list [ self . source_hash [ in_line ] ] <NEWLINE> else : <NEWLINE> if self . verbosity > 0 : logging . info ( <STRING> + in_line + <STRING> ) <NEWLINE> return output , <STRING> . join ( err ) <NEWLINE> <DEDENT>
def _get_hash_list ( self accounts_list ) : <NEWLINE> <INDENT> hash_list = [ ] <NEWLINE> for account in accounts_list : <NEWLINE> <INDENT> hash = hashlib . md5 ( ) <NEWLINE> hash . update ( six . text_type ( account ) . encode ( <STRING> ) ) <NEWLINE> temp_hash = hash . hexdigest ( ) <NEWLINE> hash_list . append ( temp_hash ) <NEWLINE> <DEDENT> return hash_list <NEWLINE> <DEDENT>
def get_seq ( pdb_file ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> parser = PDBParser ( ) <NEWLINE> structure = parser . get_structure ( pdb_file [ : - 4 ] , pdb_file ) <NEWLINE> resids = structure . get_residues ( ) <NEWLINE> residues = [ ] <NEWLINE> for r in resids : <NEWLINE> aa = r . get_resname ( ) <NEWLINE> if is_aa ( aa ) : <NEWLINE> <INDENT> residues . append ( aa ) <NEWLINE> <DEDENT> if len ( residues ) == 0 : <NEWLINE> print ( <STRING> ) <NEWLINE> raise NoProtError ( <STRING> ) <NEWLINE> return residues <NEWLINE> <DEDENT>
def _save ( self ) : <NEWLINE> <INDENT> pickle . dump ( <NEWLINE> <INDENT> self . __dict__ [ <STRING> ] <NEWLINE> open ( self . __dict__ [ <STRING> ] , <STRING> ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def main ( argv = None ) : <NEWLINE> <INDENT> if argv is None : <NEWLINE> argv = sys . argv <NEWLINE> [ Scans_filename_list , filenumber , outputpath ] = parse_options ( argv ) <NEWLINE> for eachFileName in Scans_filename_list : <NEWLINE> <INDENT> os . system ( <STRING> + eachFileName + <STRING> + outputpath + <STRING> + filenumber ) <NEWLINE> <DEDENT> <DEDENT>
def test_function_getter_uuid ( self ) : <NEWLINE> <INDENT> mesh = self . mesh_with_subdomains ( ) <NEWLINE> state = State ( mesh ) <NEWLINE> state . a = Constant ( 1.0 ) <NEWLINE> masked = MaskedState ( state , 2 ) <NEWLINE> uuid = masked . uuid ( <STRING> ) <NEWLINE> state . a = Constant ( 2.0 ) <NEWLINE> self . assertFalse ( uuid == masked . uuid ( <STRING> ) <NEWLINE> <DEDENT>
def test_do_delete_notifications ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( <NEWLINE> <INDENT> notificationmethods . NotificationMethodDispatcher , <NEWLINE> <STRING> , return_value = 200 ) : <NEWLINE> res = mock . Mock ( ) <NEWLINE> ( self . dispatcher_post . <NEWLINE> do_delete_notification_methods ( <NEWLINE> <INDENT> mock . Mock ( ) , res , <NEWLINE> id = <STRING> ) ) <NEWLINE> self . assertEqual ( getattr ( falcon , <STRING> ) , res . status ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def GetFatturatoFilter ( self ) : <NEWLINE> <INDENT> def cn ( x ) : <NEWLINE> <INDENT> return self . FindWindowByName ( x ) <NEWLINE> <DEDENT> fatcat , fatpro = self . dbfatcat , self . dbfatpro <NEWLINE> self . fatlastpdc = self . pdcid <NEWLINE> filtmov = [ ] <NEWLINE> for name , op in ( ( <STRING> , <STRING> ) , <NEWLINE> <INDENT> ( <STRING> , <STRING> ) ) : <NEWLINE> val = cn ( name ) . GetValue ( ) <NEWLINE> if val : <NEWLINE> filtmov . append ( <STRING> % ( op , val . Format ( <STRING> ) ) ) <NEWLINE> <DEDENT> return filtmov <NEWLINE> <DEDENT>
def testWhenXHasTwoLargerLargerBatchRankThanBatchRankArg ( self ) : <NEWLINE> <INDENT> batch_shape = [ 4 , 5 ] <NEWLINE> x = self . _rng . rand ( 2 , 3 , 4 , 5 , 6 ) <NEWLINE> for static_batch_shape in [ <NEWLINE> <INDENT> tf . TensorShape ( batch_shape ) , tf . TensorShape ( None ) ] : <NEWLINE> with self . test_session ( ) : <NEWLINE> mat = operator_pd . flip_vector_to_matrix ( <NEWLINE> <INDENT> x , batch_shape , static_batch_shape ) <NEWLINE> <DEDENT> mat_v = mat . eval ( ) <NEWLINE> self . assertAllEqual ( ( 4 , 5 , 6 , 2 * 3 ) , mat_v . shape ) <NEWLINE> <DEDENT> <DEDENT>
class Feature : <NEWLINE> <INDENT> def __init__ ( self , db , id , title , desc , display , level = 1 , <NEWLINE> <INDENT> parent = None , directory = None , attributes = 0 ) : <NEWLINE> self . id = id <NEWLINE> if parent : <NEWLINE> parent = parent . id <NEWLINE> add_data ( db , <STRING> , <NEWLINE> <INDENT> [ ( id , parent , title , desc , display , <NEWLINE> <INDENT> level , directory , attributes ) ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> def set_current ( self ) : <NEWLINE> <INDENT> global current_feature <NEWLINE> current_feature = self <NEWLINE> <DEDENT> <DEDENT>
( QtGui . QApplication . translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def update ( self ) : <NEWLINE> <INDENT> if self . _t >= self . _endTime : <NEWLINE> raise <STRING> <NEWLINE> self . _state = np . dot ( self . _ARcoefMatrix , self . _state ) + self . _forcing [ : , self . _forcingTimeIndex ] <NEWLINE> self . _forcingTimeIndex += 1 <NEWLINE> self . _t += self . _dt <NEWLINE> <DEDENT>
def test_count ( courseid ) : <NEWLINE> <INDENT> proxy , client , cle = login ( ) <NEWLINE> <INDENT> for i in range ( 6 ) : <NEWLINE> print ( i , proxy . count_users_bycourse ( client , cle , courseid , <STRING> , i ) ) <NEWLINE> logout ( proxy , client , cle ) <NEWLINE> <DEDENT> <DEDENT>
def test_file_only_at_dest ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) , <STRING> ) <NEWLINE> base_utils . merge_trees ( * self . paths ( <STRING> ) ) <NEWLINE> self . assertEqual ( False , os . path . exists ( self . src ( <STRING> ) ) ) <NEWLINE> self . assertFileContents ( <STRING> , <STRING> ) <NEWLINE> <DEDENT>
def test_nominated_review_time_set ( self ) : <NEWLINE> <INDENT> for status in REVIEW_ADDON_STATUSES : <NEWLINE> <INDENT> for process in [ <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ] : <NEWLINE> if ( status == amo . STATUS_UNREVIEWED and <NEWLINE> process == <STRING> ) : <NEWLINE> continue <NEWLINE> self . version . update ( reviewed = None ) <NEWLINE> self . setup_data ( status ) <NEWLINE> getattr ( self . helper . handler , process ) ( ) <NEWLINE> assert self . version . reviewed , ( <STRING> <NEWLINE> <INDENT> % ( status , process ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def retranslateUi ( self , Dialog ) : <NEWLINE> <INDENT> Dialog . setWindowTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . groupBox . setTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . labelSize1 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . groupBox_2 . setTitle ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . labelSize2 . setText ( _translate ( <STRING> , <STRING> , None ) ) <NEWLINE> self . label . setText ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def btle_slave ( self , mac_addr ) : <NEWLINE> <INDENT> a = list ( <STRING> . join ( <STRING> . split ( <STRING> ) ) . decode ( <STRING> ) ) <NEWLINE> <INDENT> return self . _device . ctrl_transfer ( VENDOR_OUT , UBERTOOTH_BTLE_PROMISC , 0 , 0 , struct . pack ( <STRING> , a [ 0 ] , a [ 1 ] , a [ 2 ] , a [ 3 ] , a [ 4 ] , a [ 5 ] ) ) <NEWLINE> <DEDENT> <DEDENT>
( <STRING> <NEWLINE> <DEDENT>
class CORSHTTPRequestHandler ( SimpleHTTPServer . SimpleHTTPRequestHandler ) : <NEWLINE> <INDENT> def send_head ( self ) : <NEWLINE> path = self . path <NEWLINE> print ( path ) <NEWLINE> ospath = os . path . abspath ( <STRING> ) <NEWLINE> if <STRING> in path : <NEWLINE> regex = re . compile ( <STRING> ) <NEWLINE> m = regex . match ( urllib2 . unquote ( path ) ) <NEWLINE> engine . say ( m . group ( 1 ) ) <NEWLINE> engine . runAndWait ( ) <NEWLINE> <DEDENT>
def _insert_menu ( self ) : <NEWLINE> <INDENT> manager = self . _window . get_ui_manager ( ) <NEWLINE> self . _action_group = gtk . ActionGroup ( <STRING> ) <NEWLINE> self . _action_group . add_actions ( [ ( <STRING> , <NEWLINE> <INDENT> None , <NEWLINE> _ ( <STRING> ) <NEWLINE> <STRING> , <NEWLINE> _ ( <STRING> ) , <NEWLINE> self . on_gpicker_open ) ] ) <NEWLINE> <DEDENT> manager . insert_action_group ( self . _action_group , - 1 ) <NEWLINE> self . _ui_id = manager . add_ui_from_string ( ui_str ) <NEWLINE> <DEDENT>
class MyApplication ( web . application ) : <NEWLINE> <INDENT> def run ( self , port = 8888 , * middleware ) : <NEWLINE> <INDENT> func = self . wsgifunc ( * middleware ) <NEWLINE> <INDENT> return web . httpserver . runsimple ( func , ( <STRING> , port ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class HTTPMethodNotAllowed ( HTTPClientError ) : <NEWLINE> <INDENT> status_code = 405 <NEWLINE> def __init__ ( self , method , allowed_methods , * , headers = None , reason = None , <NEWLINE> <INDENT> body = None , text = None , content_type = None ) : <NEWLINE> allow = <STRING> . join ( sorted ( allowed_methods ) ) <NEWLINE> super ( ) . __init__ ( headers = headers , reason = reason , <NEWLINE> <INDENT> body = body , text = text , content_type = content_type ) <NEWLINE> self . headers [ <STRING> ] = allow <NEWLINE> self . allowed_methods = allowed_methods <NEWLINE> self . method = method . upper ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def updateLineDataThread ( ) : <NEWLINE> <INDENT> global wasThreaded <NEWLINE> global gcIndex <NEWLINE> wasThreaded = True <NEWLINE> while True : <NEWLINE> if gcIndex > 60 * 1.7 : <NEWLINE> <INDENT> gcIndex = 0 <NEWLINE> gc . collect ( ) <NEWLINE> t1 = FuncThread ( updateLastSysDictList ) <NEWLINE> t1 . daemon = True <NEWLINE> t1 . start ( ) <NEWLINE> updateLastSysDictMemory ( ) <NEWLINE> updateLastSysDict ( ) <NEWLINE> changeGuiData ( ChangeGuiData ) <NEWLINE> time . sleep ( myInterval / 1000 / 2 ) <NEWLINE> gcIndex += 1 <NEWLINE> <DEDENT> <DEDENT>
def get_locally_available_covers ( self , album ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> all_paths = [ os . path . join ( album . path , f ) for f in os . listdir ( <NEWLINE> <INDENT> album . path ) ] <NEWLINE> <DEDENT> paths = [ ] <NEWLINE> for path in filter ( lambda p : p . lower ( ) . endswith ( self . _MIMES ) , <NEWLINE> <INDENT> all_paths ) : <NEWLINE> if not path . endswith ( self . _favorite ) : <NEWLINE> paths . append ( path ) <NEWLINE> <DEDENT> return paths <NEWLINE> <DEDENT>
class Renderer ( StdIOHandler ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def process ( self , in_file ) : <NEWLINE> <INDENT> for line in in_file . readlines ( ) : <NEWLINE> <INDENT> fname , rendered = self . render ( self . serializer . load ( line ) <NEWLINE> yield { <STRING> : fname , <STRING> : rendered } <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<STRING> <NEWLINE> from PIL import Image <NEWLINE> import os <NEWLINE> filelist = os . getcwd ( ) <NEWLINE> for r , d , f in os . walk ( filelist ) : <NEWLINE> <INDENT> for infile in f : <NEWLINE> outfile = os . path . splitext ( infile ) [ 0 ] + <STRING> <NEWLINE> if infile != outfile : <NEWLINE> <INDENT> try : <NEWLINE> <DEDENT> Image . open ( infile ) . save ( outfile ) <NEWLINE> print ( <STRING> % ( infile , outfile ) ) <NEWLINE> <INDENT> except IOError : <NEWLINE> <DEDENT> print ( <STRING> , infile ) <NEWLINE> <DEDENT>
class Product ( models . Model ) : <NEWLINE> <INDENT> productID = models . CharField ( , max_length = 200 ) <NEWLINE> en_name = models . CharField ( max_length = 800 ) <NEWLINE> ch_name = models . CharField ( max_length = 800 ) <NEWLINE> comment = models . CharField ( max_length = 500 ) <NEWLINE> ori_price = models . DecimalField ( max_digits = 7 , decimal_places = 2 ) <NEWLINE> retail_price = models . DecimalField ( max_digits = 7 , decimal_places = 2 ) <NEWLINE> category = models . CharField ( max_length = 200 ) <NEWLINE> attribute = models . CharField ( max_length = 500 ) <NEWLINE> image = models . ImageField ( ) <NEWLINE> <DEDENT>
def testDepthwiseConv2D ( self ) : <NEWLINE> <INDENT> for index , ( input_size , filter_size , _ , stride , <NEWLINE> <INDENT> padding ) in enumerate ( ConfigsToTest ( ) ) : <NEWLINE> print ( <STRING> , index , <STRING> ) <NEWLINE> if index == 2 : <NEWLINE> self . _VerifyValues ( input_size , <NEWLINE> <INDENT> filter_size , <NEWLINE> stride , <NEWLINE> padding , <NEWLINE> use_gpu = True ) <NEWLINE> self . _VerifyValues ( input_size , <NEWLINE> filter_size , <NEWLINE> stride , <NEWLINE> padding , <NEWLINE> use_gpu = False ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def remove_owner ( self ) : <NEWLINE> <INDENT> self . log ( <STRING> ) <NEWLINE> <INDENT> self . os_exec ( <STRING> + os . environ [ <STRING> ] ) <NEWLINE> self . os_exec ( <STRING> + os . environ [ <STRING> ] + <STRING> ) <NEWLINE> self . os_exec ( <STRING> + os . environ [ <STRING> ] ) <NEWLINE> self . log ( <STRING> ) <NEWLINE> self . os_exec ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def get_endpoint_data ( ) : <NEWLINE> <INDENT> return [ { <NEWLINE> <STRING> : { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : [ <NEWLINE> <INDENT> { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> ] , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>
( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
def build_type ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . _type is None : <NEWLINE> <INDENT> keystore_type = self . _build_type . lower ( ) <NEWLINE> if keystore_type not in ( <STRING> , <STRING> ) : <NEWLINE> <INDENT> raise ValueError ( <STRING> <NEWLINE> <INDENT> <STRING> . format ( self . _build_type ) ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> self . _type = keystore_type <NEWLINE> <DEDENT> <DEDENT> return self . _type <NEWLINE> <DEDENT>
class Plugin : <NEWLINE> <INDENT> <STRING> <NEWLINE> name = <STRING> <NEWLINE> def __init__ ( self , name ) : <NEWLINE> self . name = name <NEWLINE> <DEDENT>
( <STRING> % str ( args [ : - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
def parse_simple_decimal ( value , error = raise_exception ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> decoded_value = ( <NEWLINE> <INDENT> value . decode ( <STRING> , errors = <STRING> ) <NEWLINE> if six . PY2 and isinstance ( value , bytes ) <NEWLINE> else value ) <NEWLINE> <DEDENT> if not isinstance ( decoded_value , six . text_type ) or ( <NEWLINE> <INDENT> not _simple_decimal_rx . match ( decoded_value ) ) : <NEWLINE> if error is raise_exception : <NEWLINE> raise ValueError ( <STRING> % ( value , ) ) <NEWLINE> return error <NEWLINE> <DEDENT> return Decimal ( value ) <NEWLINE> <DEDENT>
def __getitem__ ( self , charNum ) : <NEWLINE> <INDENT> if charNum > self . lastChar or charNum < 0 : <NEWLINE> <INDENT> raise IndexError , <STRING> <NEWLINE> <DEDENT> index = charNum - self . firstChar <NEWLINE> if index < 0 : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> return self . glyphs [ index ] <NEWLINE> <DEDENT>
def write ( self , buf ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if debug_rw : <NEWLINE> <INDENT> print <STRING> + <STRING> . join ( <STRING> % v for v in buf ) <NEWLINE> <DEDENT> if ( self . dev == None ) : return self . notfound ( ) <NEWLINE> bmRequestTypeOut = usb . util . build_request_type ( usb . util . CTRL_OUT , usb . util . CTRL_TYPE_CLASS , usb . util . CTRL_RECIPIENT_INTERFACE ) <NEWLINE> self . dev . ctrl_transfer ( bmRequestTypeOut , <NEWLINE> <INDENT> 0x09 , <NEWLINE> ( 3 << 8 ) | report_id , <NEWLINE> 0 , <NEWLINE> buf ) <NEWLINE> <DEDENT> <DEDENT>
def add_domain ( domain , url , secure = False ) : <NEWLINE> <INDENT> if not ( url . startswith ( <STRING> ) <NEWLINE> <INDENT> or url . startswith ( <STRING> ) <NEWLINE> or url . startswith ( <STRING> ) ) : <NEWLINE> if secure : <NEWLINE> protocol = <STRING> <NEWLINE> else : <NEWLINE> protocol = <STRING> <NEWLINE> url = iri_to_uri ( <STRING> % ( protocol , domain , url ) ) <NEWLINE> <DEDENT> return url <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from . . protocol . rfc4511 import ModifyDNRequest , LDAPDN , RelativeLDAPDN , DeleteOldRDN , NewSuperior , ResultCode <NEWLINE> from . . operation . bind import referrals_to_list <NEWLINE> def modify_dn_operation ( dn , <NEWLINE> <INDENT> new_relative_dn , <NEWLINE> delete_old_rdn = True , <NEWLINE> new_superior = None ) : <NEWLINE> request = ModifyDNRequest ( ) <NEWLINE> request [ <STRING> ] = LDAPDN ( dn ) <NEWLINE> request [ <STRING> ] = RelativeLDAPDN ( new_relative_dn ) <NEWLINE> request [ <STRING> ] = DeleteOldRDN ( delete_old_rdn ) <NEWLINE> if new_superior : <NEWLINE> request [ <STRING> ] = NewSuperior ( new_superior ) <NEWLINE> return request <NEWLINE> <DEDENT>
def scrypt_mcf_check ( mcf , password ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not isinstance ( mcf , bytes ) : <NEWLINE> <INDENT> raise TypeError ( <STRING> ) <NEWLINE> <DEDENT> if mcf_mod . _scrypt_mcf_7_is_standard ( mcf ) and not _scrypt_ll : <NEWLINE> <INDENT> return _scrypt_str_chk ( mcf , password , len ( password ) == 0 <NEWLINE> <DEDENT> return mcf_mod . scrypt_mcf_check ( scrypt , mcf , password ) <NEWLINE> <DEDENT>
def gsm_dial ( class_ , number ) : <NEWLINE> <INDENT> class_ . call_type = <STRING> <NEWLINE> if class_ . alsacurrent == <STRING> : <NEWLINE> <INDENT> class_ . set_state_file ( <STRING> ) <NEWLINE> <DEDENT> elif class_ . alsacurrent == <STRING> : <NEWLINE> <INDENT> class_ . set_state_file ( <STRING> ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> name = class_ . gsm_wireless . Initiate ( number , dbus_interface = DIN_VOICE_CALL_INITIATOR , timeout = 200 ) <NEWLINE> class_ . call = object_by_url ( name ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> print ( <STRING> + str ( e ) ) <NEWLINE> class_ . set_state_file ( class_ . alsacurrent ) <NEWLINE> class_ . notify_callbacks ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def remove ( self , elem ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> self . last = self . last . prev <NEWLINE> self . last . hash = [ ] <NEWLINE> <DEDENT> <DEDENT>
import urllib , urllib2 , sys , httplib <NEWLINE> url = <STRING> <NEWLINE> HOST_IP = <STRING> <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> connection = httplib . HTTPConnection ( HOST_IP ) <NEWLINE> <INDENT> description_file = open ( <STRING> , <STRING> ) <NEWLINE> body_content = description_file . read ( ) <NEWLINE> headers = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> } <NEWLINE> connection . request ( <STRING> , url + <STRING> , body = body_content , headers = headers , ) <NEWLINE> result = connection . getresponse ( ) <NEWLINE> <INDENT> print ( result . read ( ) ) <NEWLINE> <DEDENT> <DEDENT>
( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
from __future__ import division <NEWLINE> import webapp2 , jinja2 , os , urllib , myFunctions <NEWLINE> from math import * <NEWLINE> from google . appengine . api import users <NEWLINE> from google . appengine . ext import ndb <NEWLINE> JINJA_ENVIRONMENT = jinja2 . Environment ( <NEWLINE> <INDENT> loader = jinja2 . FileSystemLoader ( os . path . dirname ( __file__ ) ) <NEWLINE> extensions = [ <STRING> ] ) <NEWLINE> <DEDENT> DEFAULT_NAMESPACE_NAME = <STRING> <NEWLINE>
def both_ends ( s ) : <NEWLINE> <INDENT> strng = <STRING> <NEWLINE> if len ( s ) > 2 : <NEWLINE> strng = s [ 0 ] + s [ 1 ] + s [ - 2 ] + s [ - 1 ] <NEWLINE> return strng <NEWLINE> <DEDENT>
def callback_context_switch_ftrace ( self , res , line ) : <NEWLINE> <INDENT> timestamp = int ( float ( res . group ( <STRING> ) ) * 1000.0 ) <NEWLINE> if self . reference_timestamp == 0 : <NEWLINE> self . reference_timestamp = timestamp <NEWLINE> timestamp = timestamp - self . reference_timestamp <NEWLINE> cpu_id = int ( res . group ( <STRING> ) ) <NEWLINE> name = res . group ( <STRING> ) . rstrip ( <STRING> ) <NEWLINE> tid = int ( res . group ( <STRING> ) ) <NEWLINE> self . callback_context_switch_post ( timestamp , cpu_id , tid , name , 0 , <STRING> , <STRING> ) <NEWLINE> <DEDENT>
def read_file ( file_name , string_escape = True ) : <NEWLINE> <INDENT> with open ( Fixtures . file ( file_name ) ) ) as f : <NEWLINE> <INDENT> contents = f . read ( ) <NEWLINE> if string_escape : <NEWLINE> <INDENT> contents = contents . decode ( <STRING> ) <NEWLINE> <DEDENT> return contents . decode ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def splitter ( seq , chnks ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if chnks > len ( seq ) : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> newseq = [ ] <NEWLINE> splitsize = 1.0 / chnks * len ( seq ) <NEWLINE> for i in range ( chnks ) : <NEWLINE> <INDENT> newseq . append ( seq [ int ( round ( i * splitsize ) ) : int ( round ( ( i + 1 ) * splitsize ) ) ) ] ) <NEWLINE> <DEDENT> return newseq <NEWLINE> <DEDENT>
def print_thousands ( s_before , l , s_after = <STRING> , overwrite = True ) : <NEWLINE> <INDENT> if overwrite : <NEWLINE> <INDENT> print ( <STRING> , <NEWLINE> <DEDENT> print ( s_before , comma_000 ( l ) , s_after , ) <NEWLINE> sys . stdout . flush ( ) <NEWLINE> <DEDENT>
def getDisplayedImage ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not self . _savedExpression or self . _savedExpression == <STRING> : <NEWLINE> <INDENT> self . _savedExpression = <STRING> <NEWLINE> image = self . image <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for f in vigra . ufunc . __all__ : <NEWLINE> <INDENT> exec <STRING> % f <NEWLINE> <DEDENT> for f in dir ( vigra . colors ) : <NEWLINE> <INDENT> if not f . startswith ( <STRING> ) : <NEWLINE> <INDENT> exec <STRING> % f <NEWLINE> <DEDENT> <DEDENT> x = self . image <NEWLINE> image = eval ( self . _savedExpression ) <NEWLINE> <DEDENT> return image , self . _normalized <NEWLINE> <DEDENT>
def connect ( self , other , mapping ) : <NEWLINE> <INDENT> other_inputs = other . inputs <NEWLINE> if mapping is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self == other : <NEWLINE> <INDENT> for k , v in mapping . items ( ) : <NEWLINE> <INDENT> if k == v : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> solar_map ( <NEWLINE> <INDENT> lambda ( my_name , other_name ) : self . _connect_single ( other_inputs , <NEWLINE> <INDENT> other_name , <NEWLINE> my_name ) , <NEWLINE> <DEDENT> mapping . iteritems ( ) , <NEWLINE> concurrency = 2 ) <NEWLINE> <DEDENT> <DEDENT>
def pick_square ( ( x , y , w , h ) , bw , bh ) : <NEWLINE> <INDENT> mod_w = w - bw <NEWLINE> mod_h = h - bh <NEWLINE> bx = rand ( ) % ( mod_w + 1 ) <NEWLINE> by = rand ( ) % ( mod_h + 1 ) <NEWLINE> return x + bx , y + by , bw , bh <NEWLINE> <DEDENT>
def create_dir ( directory ) : <NEWLINE> <INDENT> if not os . path . exists ( directory ) <NEWLINE> <INDENT> os . makedirs ( directory ) <NEWLINE> <DEDENT> <DEDENT>
def choose ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> total = 0 <NEWLINE> n = whrandom . randint ( 1 , self . count ) <NEWLINE> for symbol , freq in self . freqs . items ( ) : <NEWLINE> total = total + freq <NEWLINE> if n <= total : return symbol <NEWLINE> <DEDENT>
( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
1 import sys as s <NEWLINE> import subprocess as sb <NEWLINE> from time import time <NEWLINE> from parsingInfo import parseInfo <NEWLINE> from actions import userNodeSelectionAct , randomSubSamplingAct , parseList <NEWLINE> from featuresVector import featuresCreate <NEWLINE> from misc import mergeList <NEWLINE> from preformat import process <NEWLINE>
[ + autogen5 template + ] <NEWLINE> [ + CASE ( get <STRING> ) + ] <NEWLINE> [ + == <STRING> + ] [ + ( bsd ( get <STRING> ) ( get <STRING> ) <STRING> ) + ] <NEWLINE> [ + == <STRING> + ] [ + ( lgpl ( get <STRING> ) ( get <STRING> ) <STRING> ) + ] <NEWLINE> [ + == <STRING> + ] [ + ( gpl ( get <STRING> ) <STRING> ) + ] <NEWLINE> [ + ESAC + ] <NEWLINE> import sys <NEWLINE> try : <NEWLINE> <INDENT> import gtk <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> sys . exit ( <STRING> ) <NEWLINE> <DEDENT> UI_FILE = <STRING> <NEWLINE>
( <STRING> % ( datetime . datetime . now ( ) . strftime ( <STRING> ) , <NEWLINE> <INDENT> cur_follower_count , <NEWLINE> cur_following_count , <NEWLINE> str ( int ( cur_follower_count ) - int ( self . start_follower_count ) ) , <NEWLINE> self . like_counter , <NEWLINE> self . like_per_day , <NEWLINE> self . follow_counter , <NEWLINE> self . follow_per_day , <NEWLINE> self . unfollow_counter , <NEWLINE> self . unfollow_per_day , <NEWLINE> str ( datetime . datetime . now ( ) - self . bot_start ) <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def add_element ( self , parent , element_content ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ascending = lambda ( key , value ) : key . lower ( ) <NEWLINE> for key , value in sorted ( element_content . iteritems ( ) , key = ascending ) : <NEWLINE> <INDENT> if key is not None : <NEWLINE> <INDENT> key_pango = markup . convert_to_pango ( key ) <NEWLINE> <DEDENT> new_child = self . tree_store . append ( parent , [ key_pango ] ) <NEWLINE> if not value is None : <NEWLINE> <INDENT> self . add_element ( new_child , value ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def cmpmd5 ( self , filename , md5 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> ( size , ffmd5 ) = self . dirdic [ filename ] <NEWLINE> if ( md5 == ffmd5 ) : <NEWLINE> <INDENT> result = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = False <NEWLINE> <DEDENT> <DEDENT> except Exception , e : <NEWLINE> <INDENT> result = False ; <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT>
class TriggeredAlert ( models . Model ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> reporter = models . ForeignKey ( Reporter ) <NEWLINE> report = models . ForeignKey ( Report , related_name = <STRING> , null = True ) <NEWLINE> trigger = models . ForeignKey ( TriggeredText ) <NEWLINE> date = models . DateTimeField ( auto_now_add = True ) <NEWLINE> def __unicode__ ( self ) : <NEWLINE> return <STRING> % ( str ( self . id ) , str ( self . trigger ) ) <NEWLINE> def __int__ ( self ) : <NEWLINE> <INDENT> return self . id <NEWLINE> <DEDENT> class Meta : <NEWLINE> permissions = ( <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
from patron import test <NEWLINE> from lxml import etree <NEWLINE> from patron . compute import arch <NEWLINE> import patron . tests . unit . virt . libvirt . fakelibvirt as libvirt <NEWLINE> def get_vm_xml ( name = <STRING> , uuid = None , source_type = <STRING> , <NEWLINE> <INDENT> interface_type = <STRING> ) : <NEWLINE> uuid_tag = <STRING> <NEWLINE> if uuid : <NEWLINE> uuid_tag = <STRING> % ( uuid , ) <NEWLINE> return <STRING> % { <STRING> : name , <NEWLINE> <INDENT> <STRING> : uuid_tag , <NEWLINE> <STRING> : source_type , <NEWLINE> <STRING> : interface_type } <NEWLINE> <DEDENT> <DEDENT>
def testUpdateConfigSkipTryjob ( self ) : <NEWLINE> <INDENT> self . _MockTryserverJson ( { <STRING> : <STRING> } ) <NEWLINE> command = trybot_command . Trybot ( ) <NEWLINE> command . _InitializeBuilderNames ( <STRING> ) <NEWLINE> self . _ExpectProcesses ( ( ) ) <NEWLINE> cfg_filename = <STRING> <NEWLINE> cfg_data = ( <STRING> <NEWLINE> <DEDENT>
def _compute_percentage_satisfaction_issue ( self ) : <NEWLINE> <INDENT> project_issue = self . env [ <STRING> ] . search ( [ ( <STRING> , <STRING> , self . id ) ] ) <NEWLINE> activity = project_issue . rating_get_grades ( ) <NEWLINE> self . percentage_satisfaction_issue = activity [ <STRING> ] * 100 / sum ( activity . values ( ) ) ) if sum ( activity . values ( ) ) else - 1 <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import numpy as np <NEWLINE> import pickle <NEWLINE> def recode_wide ( file : str , outfile : str , <NEWLINE> <INDENT> anc_file : str , out_anc_file : str ) -> None : <NEWLINE> <STRING> <NEWLINE> data = np . genfromtxt ( file , dtype = <STRING> , delimiter = 1 ) <NEWLINE> with open ( outfile , <STRING> ) as f : <NEWLINE> pickle . dump ( data + 1 , f ) <NEWLINE> anc_data = np . genfromtxt ( anc_file , dtype = <STRING> ) <NEWLINE> with open ( out_anc_file , <STRING> ) as f : <NEWLINE> pickle . dump ( anc_data , f ) <NEWLINE> print ( <STRING> , out_anc_file ) <NEWLINE> <DEDENT>
def index ( ) : <NEWLINE> <INDENT> logging . info ( <STRING> ) <NEWLINE> <INDENT> return render_template ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class MockRecognizer ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . transcriptions = [ ] <NEWLINE> <DEDENT> def recognize_mycroft ( self , audio , key = None , <NEWLINE> <INDENT> language = None , show_all = False ) : <NEWLINE> if len ( self . transcriptions ) > 0 : <NEWLINE> return self . transcriptions . pop ( 0 ) <NEWLINE> else : <NEWLINE> raise speech_recognition . UnknownValueError ( ) <NEWLINE> <DEDENT> def set_transcriptions ( self , transcriptions ) : <NEWLINE> <INDENT> self . transcriptions = transcriptions <NEWLINE> <DEDENT> <DEDENT>
class SparseCoder ( BaseEstimator , SparseCodingMixin ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , dictionary , transform_algorithm = <STRING> , <NEWLINE> <INDENT> transform_n_nonzero_coefs = None , transform_alpha = None , <NEWLINE> split_sign = False , n_jobs = 1 ) : <NEWLINE> self . _set_sparse_coding_params ( dictionary . shape [ 0 ] , <NEWLINE> <INDENT> transform_algorithm , <NEWLINE> transform_n_nonzero_coefs , <NEWLINE> transform_alpha , split_sign , n_jobs ) <NEWLINE> self . components_ = dictionary <NEWLINE> <DEDENT> <DEDENT> def fit ( self , X , y = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self <NEWLINE> <DEDENT> <DEDENT>
def calculateSimilarItems ( prefs , n = 10 ) : <NEWLINE> <INDENT> result = { } <NEWLINE> itemPrefs = transformPrefs ( prefs ) <NEWLINE> c = 0 <NEWLINE> for item in itemPrefs : <NEWLINE> <INDENT> c += 1 <NEWLINE> if c % 100 == 0 : <NEWLINE> <INDENT> print <STRING> % ( c , len ( itemPrefs ) ) <NEWLINE> <DEDENT> scores = topMatches ( itemPrefs , item , n = n , similarity = sim_distance ) <NEWLINE> result [ item ] = scores <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT>
def retranslateUi ( self , RenameDocumentDialog ) : <NEWLINE> <INDENT> _translate = QtCore . QCoreApplication . translate <NEWLINE> RenameDocumentDialog . setWindowTitle ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . label . setText ( _translate ( <STRING> , <STRING> ) ) <NEWLINE> self . label_8 . setText ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def _build_storage_path ( self ) : <NEWLINE> <INDENT> self . assign_id ( ) <NEWLINE> path_segments = [ <STRING> , strict_unicode ( self . contribution . event_new . id ) , <STRING> , <NEWLINE> <INDENT> <STRING> . format ( self . id , strict_unicode ( self . contribution . id ) ] <NEWLINE> <DEDENT> path = posixpath . join ( * ( path_segments + [ self . filename ] ) ) <NEWLINE> return Config . getInstance ( ) . getAttachmentStorage ( ) , path <NEWLINE> <DEDENT>
def __div__ ( self , other ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> div = self . todegrees ( ) / other . todegrees ( ) <NEWLINE> divint = int ( round ( div ) <NEWLINE> if other * divint == self : <NEWLINE> <INDENT> return divint <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return div <NEWLINE> <DEDENT> <DEDENT>
class SomeClass ( object ) : <NEWLINE> <INDENT> def __init__ ( self , data ) <NEWLINE> <INDENT> self . data = data <NEWLINE> <DEDENT> <DEDENT>
def read ( data , namespace ) : <NEWLINE> <INDENT> assert data <NEWLINE> if isinstance ( data , dict ) : <NEWLINE> <INDENT> return OrderedDict ( ( k , read ( v , namespace ) ) for ( k , v ) in data . items ( ) } <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return to_function ( data ) <NEWLINE> <DEDENT> <DEDENT>
class ScalingTransformation : <NEWLINE> <INDENT> def __init__ ( self , scaling ) : <NEWLINE> <INDENT> scaling = float ( scaling ) <NEWLINE> if scaling > 0 : <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> return x / scaling <NEWLINE> def finv ( y ) : <NEWLINE> return y * scaling <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> self . __call__ = f <NEWLINE> self . inverse = finv <NEWLINE> <DEDENT> <DEDENT>
def _click_to_show_instructions_fired ( self ) : <NEWLINE> <INDENT> m = information ( None , <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <DEDENT> <DEDENT>
def _dcommit_calls_bypassed ( cls ) : <NEWLINE> <INDENT> return [ <NEWLINE> <INDENT> ( ( [ <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> ] , ) , <STRING> ) , <NEWLINE> <DEDENT> ( ( [ <STRING> , <STRING> , <STRING> ] , ) , <NEWLINE> <INDENT> <STRING> ) , <NEWLINE> <DEDENT> ( ( [ <STRING> , <STRING> , <STRING> ] , ) , <STRING> ) , <NEWLINE> ( ( <STRING> , <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def packet_header ( packet ) : <NEWLINE> <INDENT> caplen = wirelen = len ( packet ) <NEWLINE> t = time . time ( ) <NEWLINE> sec = int ( t ) <NEWLINE> usec = int ( round ( ( t - sec ) * 1000000 ) <NEWLINE> return struct . pack ( <STRING> , sec , usec , caplen , wirelen ) <NEWLINE> <DEDENT>
def _resolve_check ( domain , request ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> res = socket . gethostbyname ( domain ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> e_msg = ( <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> % ( domain , e . __str__ ( ) ) ) <NEWLINE> <DEDENT> handle_exception ( Exception ( e_msg ) , request ) <NEWLINE> <DEDENT> <DEDENT>
def trim_release_list ( value ) : <NEWLINE> <INDENT> return sorted ( <NEWLINE> <INDENT> value , <NEWLINE> key = lambda ( id , count ) : count , <NEWLINE> reverse = True , <NEWLINE> <DEDENT> ) [ : 5 ] <NEWLINE> <DEDENT>
( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def get_creator ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . D . has_key ( <STRING> ) : <NEWLINE> <INDENT> return self . D [ <STRING> ] <NEWLINE> <INDENT> else : <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT> <DEDENT>
def downgrade ( migrate_engine ) : <NEWLINE> <INDENT> meta = MetaData ( ) <NEWLINE> meta . bind = migrate_engine <NEWLINE> transfers = Table ( <STRING> , <NEWLINE> <INDENT> meta , <NEWLINE> autoload = True ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> transfers . drop ( ) <NEWLINE> <DEDENT> except Exception : <NEWLINE> <INDENT> LOG . error ( _ ( <STRING> ) <NEWLINE> raise <NEWLINE> <DEDENT> <DEDENT>
def run ( self , options = None ) : <NEWLINE> <INDENT> self . verbosity = options [ <STRING> ] <NEWLINE> messages = [ ] <NEWLINE> for ( name , method ) in inspect . getmembers ( self , <NEWLINE> <INDENT> predicate = inspect . ismethod ) : <NEWLINE> if name . startswith ( <STRING> ) : <NEWLINE> messages += method ( ) <NEWLINE> <DEDENT> return messages <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> input = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <DEDENT> ] <NEWLINE> output = SHORT + <STRING> <NEWLINE> defsoutput = TOOLBOXDIR + LONG + <STRING> <NEWLINE> scanner = MyScanner ( input , output , defsoutput ) <NEWLINE> scanner . scan ( ) <NEWLINE> scanner . gentypetest ( SHORT + <STRING> ) <NEWLINE> scanner . close ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> execfile ( defsoutput , { } , { } ) <NEWLINE> print ( <STRING> ) <NEWLINE> exec <STRING> + SHORT + <STRING> <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
def join ( self , arg ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = <STRING> <NEWLINE> try : <NEWLINE> <INDENT> ret = self . sep . join ( arg ) <NEWLINE> <DEDENT> except TypeError , e : <NEWLINE> <INDENT> ret = self . sep . join ( [ str ( item ) for item in arg ] ) <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT>
def usage ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . format ( argv [ 0 ] ) ) ) <NEWLINE> <DEDENT>
if ( ( not os . path . isdir ( item [ <STRING> ] ) ) ) and ( self . conf ( <STRING> ) in item [ <STRING> ] ) ) : <NEWLINE>
def broadcast ( self , content = <STRING> ) : <NEWLINE> <INDENT> broadcast_msg = <STRING> % content <NEWLINE> try : <NEWLINE> <INDENT> self . send_json ( broadcast_msg . encode ( <STRING> ) ) <NEWLINE> return True <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT>
def lasers ( fname ) : <NEWLINE> <INDENT> room = open ( fname ) . readlines ( ) <NEWLINE> x , y , dx , dy = find_emitter ( room ) <NEWLINE> while True : <NEWLINE> <INDENT> x += dx <NEWLINE> y += dy <NEWLINE> char = room [ y ] [ x ] <NEWLINE> passage = { <STRING> : ( dx , dy ) , <NEWLINE> <INDENT> <STRING> : ( dy , dx ) , <NEWLINE> <STRING> : ( - dy , - dx ) } <NEWLINE> dx , dy = passage [ char ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return char == <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class MidiTimeCirc ( DelayCirc ) : <NEWLINE> <INDENT> def split ( self ) : <NEWLINE> <INDENT> if ( len ( self . list ) > 0 ) : <NEWLINE> <INDENT> split = max ( self . list ) - min ( self . list ) <NEWLINE> <INDENT> return abs ( split ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
( <STRING> % count <NEWLINE> print ( image ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def warn_missing ( element ) : <NEWLINE> <INDENT> if element . tag not in action : print <STRING> % element . tag <NEWLINE> pass <NEWLINE> <DEDENT>
def module_load ( m ) : <NEWLINE> <INDENT> minst = None <NEWLINE> exec <STRING> % ( { <STRING> : m } ) <NEWLINE> return minst <NEWLINE> <DEDENT>
def change_display_name ( step , display_name ) : <NEWLINE> <INDENT> world . edit_component_and_select_settings ( ) <NEWLINE> index = world . get_setting_entry_index ( DISPLAY_NAME ) <NEWLINE> world . set_field_value ( index display_name ) <NEWLINE> world . save_component ( ) <NEWLINE> <DEDENT>
def EndMapping ( self , top_value , mapping ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not hasattr ( mapping . value , <STRING> ) : <NEWLINE> <INDENT> raise validation . ValidationError ( <STRING> ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> mapping . value . CheckInitialized ( ) <NEWLINE> <DEDENT> except validation . ValidationError : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> error_str = str ( e ) <NEWLINE> <DEDENT> except Exception : <NEWLINE> <INDENT> error_str = <STRING> <NEWLINE> <DEDENT> raise validation . ValidationError ( error_str , e ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import re <NEWLINE> from socket import socket <NEWLINE> import cPickle <NEWLINE> import struct <NEWLINE> from shinken . basemodule import BaseModule <NEWLINE> from shinken . log import logger <NEWLINE> from shinken . misc . perfdata import PerfDatas <NEWLINE> properties = { <NEWLINE> <INDENT> <STRING> : [ <STRING> ] , <NEWLINE> <STRING> : <STRING> , <NEWLINE> , <NEWLINE> <STRING> : False , <NEWLINE> <DEDENT> } <NEWLINE>
class DiffKind : <NEWLINE> <INDENT> def __init__ ( self , a , b ) : <NEWLINE> self . a = a <NEWLINE> self . b = b <NEWLINE> self . d_tag = <STRING> <NEWLINE> def get_atom_kinds ( self ) : <NEWLINE> return [ self ] <NEWLINE> def get_id_name ( self ) : <NEWLINE> return self . a . get_id_name ( ) + <STRING> + self . b . get_id_name ( ) + <STRING> <NEWLINE> <DEDENT>
def start ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> while self . running and not self . pipe . closed : <NEWLINE> <INDENT> command = self . pipe . recv ( ) <NEWLINE> self . handle_command ( command ) <NEWLINE> while self . running and ( self . _waiting_for_frame <NEWLINE> <INDENT> or self . _waiting_for_read_ahead ) : <NEWLINE> time . sleep ( 1 / self . poll_frequency ) <NEWLINE> if self . _waiting_for_frame : <NEWLINE> self . try_getting_frame ( ) <NEWLINE> if self . _waiting_for_read_ahead : <NEWLINE> self . try_reading_ahead ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except ( KeyboardInterrupt , SystemExit ) : <NEWLINE> <INDENT> self . abort_iteration ( ) <NEWLINE> <DEDENT> <DEDENT>
def text_to_button ( msg , color , buttonx , buttony , buttonwidth , buttonheight ) : <NEWLINE> <INDENT> text = font . render ( msg . zfill ( 2 ) , True , rCBack ) <NEWLINE> text_rect = text . get_rect ( ) <NEWLINE> text_rect . center = ( ( buttonx + ( buttonwidth / 2 ) ) , buttony + ( buttonheight / 2 ) <NEWLINE> screen . blit ( text , text_rect ) <NEWLINE> <DEDENT>
class GitRevision ( Revision ) : <NEWLINE> <INDENT> def __init__ ( self , project_name , revision , branch , author , <NEWLINE> <INDENT> comments , files , change_ts , <NEWLINE> codebase = None , revision_link = None , repository = None ) : <NEWLINE> self . project = project_name <NEWLINE> self . revision = revision <NEWLINE> self . author = author <NEWLINE> self . branch = branch <NEWLINE> self . comments = comments <NEWLINE> self . files = files <NEWLINE> self . change_ts = change_ts <NEWLINE> if revision_link : <NEWLINE> self . revlink = revision_link <NEWLINE> if repository : <NEWLINE> self . repository = repository <NEWLINE> if codebase : <NEWLINE> self . codebase = codebase <NEWLINE> <DEDENT> <DEDENT>
class _AssertRaisesBaseContext ( object ) : <NEWLINE> <INDENT> def __init__ ( self , expected , test_case , callable_obj = None , <NEWLINE> <INDENT> expected_regex = None ) : <NEWLINE> self . expected = expected <NEWLINE> self . failureException = test_case . failureException <NEWLINE> self . obj_name = None <NEWLINE> if isinstance ( expected_regex , basestring ) : <NEWLINE> expected_regex = re . compile ( expected_regex ) <NEWLINE> self . expected_regex = expected_regex <NEWLINE> <DEDENT> <DEDENT>
def testAlias ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> sheet = self . doc . addObject ( <STRING> , <STRING> ) <NEWLINE> sheet . setAlias ( <STRING> , <STRING> ) <NEWLINE> self . assertEqual ( sheet . getAlias ( <STRING> ) , <STRING> ) <NEWLINE> sheet . set ( <STRING> , <STRING> ) <NEWLINE> self . doc . recompute ( ) <NEWLINE> self . assertEqual ( sheet . get ( <STRING> ) , 4711 ) <NEWLINE> self . assertEqual ( sheet . get ( <STRING> ) , sheet . get ( <STRING> ) ) ) <NEWLINE> <DEDENT>
def parse_exif_time ( filename ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> basename = os . path . basename ( filename ) <NEWLINE> <INDENT> if basename . lower ( ) . endswith ( <STRING> ) or basename . lower ( ) . endswith ( <STRING> ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> from . import mav_position <NEWLINE> return mav_position . exif_timestamp ( filename ) <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> <INDENT> print ( <STRING> % e ) <NEWLINE> return 0 <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <DEDENT> <DEDENT>
def ShowOption ( self , e ) : <NEWLINE> <INDENT> chgopt = ChangeOptions ( None , title = <STRING> ) <NEWLINE> <INDENT> chgopt . ShowModal ( ) <NEWLINE> chgopt . Destroy ( ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT>
def put_plugin ( self , psa_id , name = None , new_url = None , token = None ) : <NEWLINE> <INDENT> url = self . base_url + <STRING> + psa_id + <STRING> <NEWLINE> <INDENT> params = { } <NEWLINE> if token : <NEWLINE> <INDENT> params [ <STRING> ] = token <NEWLINE> <DEDENT> <DEDENT> if name : <NEWLINE> <INDENT> params [ <STRING> ] = name <NEWLINE> <DEDENT> if new_url : <NEWLINE> <INDENT> params [ <STRING> ] = new_url <NEWLINE> <DEDENT> return put ( url , params = params ) <NEWLINE> <DEDENT>
def _get_datafile ( self , handle ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> datafile = None <NEWLINE> datafiletype = None <NEWLINE> for dfiletype in ( persistence . pddatafile , persistence . npdatafile , <NEWLINE> <INDENT> persistence . pydatafile ) : <NEWLINE> dfile = os . path . join ( self . _backend . get_location ( ) , <NEWLINE> <INDENT> handle , dfiletype ) <NEWLINE> if os . path . exists ( dfile ) : <NEWLINE> datafile = dfile <NEWLINE> datafiletype = dfiletype <NEWLINE> <DEDENT> <DEDENT> return ( datafile , datafiletype ) <NEWLINE> <DEDENT>
def makeSafeFilename ( inputFilename ) : <NEWLINE> <INDENT> try : <NEWLINE> safechars = string . letters + string . digits + <STRING> <NEWLINE> return filter ( lambda c : c in safechars , inputFilename ) . replace ( <STRING> , <STRING> ) <NEWLINE> except : <NEWLINE> return <STRING> <NEWLINE> pass <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from funcparserlib . parser import skip , finished <NEWLINE> import modparc <NEWLINE> from modparc . syntax import tokenize <NEWLINE> def verify_parsed_result ( source_code , parser , <NEWLINE> <INDENT> subelement_type , subelement_code ) : <NEWLINE> <STRING> <NEWLINE> tokens = tokenize ( source_code ) <NEWLINE> parsed_element = ( parser + skip ( finished ) ) . parse ( tokens ) <NEWLINE> subelements = parsed_element . search ( subelement_type ) <NEWLINE> assert len ( subelements ) == len ( subelement_code ) <NEWLINE> for ( i , parsed_subelements ) in enumerate ( subelements ) : <NEWLINE> assert parsed_subelements . code ( ) == subelement_code [ i ] <NEWLINE> <DEDENT>
def is_on_firewall ( self , mac ) : <NEWLINE> <INDENT> r = False <NEWLINE> for m in self . list ( ) : <NEWLINE> <INDENT> if m == mac : <NEWLINE> r = True <NEWLINE> break <NEWLINE> else : <NEWLINE> r = False <NEWLINE> <DEDENT> return r <NEWLINE> <DEDENT>
def any ( iterable ) <NEWLINE> <INDENT> for element in iterable : <NEWLINE> <INDENT> if element : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>
def show_html ( self ) : <NEWLINE> <INDENT> for obj in self . ui_objects : <NEWLINE> <INDENT> print ( obj . get_html ( ) <NEWLINE> <DEDENT> <DEDENT>
def karatsubaMultiplication ( a , b ) : <NEWLINE> <INDENT> if ( a < 10 ) or ( b < 10 ) <NEWLINE> <INDENT> return a * b <NEWLINE> <DEDENT> low1 <NEWLINE> z0 = karatsubaMultiplication ( low1 , low2 ) <NEWLINE> z1 = karatsubaMultiplication ( low1 + high1 , low2 + high2 ) <NEWLINE> z2 = karatsubaMultiplication ( high1 , high2 ) <NEWLINE> return <NEWLINE> <DEDENT>
def rtype_setitem ( ( r_lst , r_int ) , hop ) : <NEWLINE> <INDENT> if hop . has_implicit_exception ( IndexError ) : <NEWLINE> <INDENT> spec = dum_checkidx <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> spec = dum_nocheck <NEWLINE> <DEDENT> v_func = hop . inputconst ( Void , spec ) <NEWLINE> v_lst , v_index , v_item = hop . inputargs ( r_lst , Signed , r_lst . item_repr ) <NEWLINE> if hop . args_s [ 1 ] . nonneg : <NEWLINE> <INDENT> llfn = ll_setitem_nonneg <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> llfn = ll_setitem <NEWLINE> <DEDENT> hop . exception_is_here ( ) <NEWLINE> return hop . gendirectcall ( llfn , v_func , v_lst , v_index , v_item ) <NEWLINE> <DEDENT>
( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , screen , ( posX , posY ) ) : <NEWLINE> <INDENT> super ( tickBox , self ) . __init__ ( screen , ( posX , posY ) ) <NEWLINE> self . box = pygame . image . load ( <STRING> ) <NEWLINE> self . boxTicked = pygame . image . load ( <STRING> ) <NEWLINE> self . box . convert_alpha ( ) <NEWLINE> self . boxTicked . convert_alpha ( ) <NEWLINE> return <NEWLINE> <DEDENT>
def collect_tax ( self , sender , amount ) : <NEWLINE> <INDENT> self . send_message ( sender , messages . Inform ( <NEWLINE> <INDENT> messages . MetaInfo ( self , sender ) , <NEWLINE> <STRING> % ( amount , sender . get_id ( ) ) <NEWLINE> <DEDENT> ) <NEWLINE> self . capital += amount <NEWLINE> if not sender in self . _taxes : <NEWLINE> <INDENT> self . _taxes [ sender ] = [ ] <NEWLINE> <DEDENT> self . _taxes [ sender ] . append ( amount ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import pytest <NEWLINE> from flask import url_for <NEWLINE> from { { cookiecutter . app_name } } . user . models import User <NEWLINE> from . factories import UserFactory <NEWLINE>
class DispersiveDecay ( VNATimeResolvedDispersiveMeasurement1D ) : <NEWLINE> <INDENT> def __init__ ( self , name , sample_name , vna_name , ro_awg , q_awg , <NEWLINE> <INDENT> q_lo_name , line_attenuation_db = 60 ) : <NEWLINE> super ( ) . __init__ ( name , sample_name , vna_name , ro_awg , q_awg , <NEWLINE> <INDENT> q_lo_name , line_attenuation_db ) <NEWLINE> self . _measurement_result = DispersiveDecayResult ( name , <NEWLINE> sample_name ) <NEWLINE> self . _sequence_generator = PulseBuilder . build_dispersive_decay_sequences <NEWLINE> self . _swept_parameter_name = <STRING> <NEWLINE> <DEDENT> <DEDENT> def set_swept_parameters ( self , readout_delays ) : <NEWLINE> <INDENT> super ( ) . set_swept_parameters ( self . _swept_parameter_name , readout_delays ) <NEWLINE> <DEDENT> <DEDENT>
def removeCoverageFromPreviousRun ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for f in ( os . path . join ( os . environ [ <STRING> ] , <STRING> ) , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> try : <NEWLINE> os . unlink ( f ) <NEWLINE> except OSError : <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT>
def register_xf86_keys ( keybinder ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> inhibit_power_button ( ) <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> <INDENT> notify ( <STRING> % ( e . __class__ . __name__ , str ( e ) ) , timeout = 5000 ) <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> <DEDENT> keybinder . bind_key ( 0 , <STRING> , power_button ) <NEWLINE> <DEDENT>
def xml_add_text_tags ( doc , root_node , tags ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for pair in tags : <NEWLINE> <INDENT> name , value = pair <NEWLINE> channelTag = doc . createElement ( name ) <NEWLINE> channelTag . appendChild ( doc . createTextNode ( unicode ( value ) ) <NEWLINE> root_node . appendChild ( channelTag ) <NEWLINE> <DEDENT> <DEDENT>
class FileParseError ( ParsecError ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , reason , index = None , line = None , lines = None , <NEWLINE> <INDENT> error_name = <STRING> ) : <NEWLINE> self . msg = error_name + <STRING> + reason <NEWLINE> if index : <NEWLINE> self . msg += <STRING> + str ( index + 1 ) + <STRING> <NEWLINE> if line : <NEWLINE> self . msg += <STRING> + line . strip ( ) <NEWLINE> if lines : <NEWLINE> self . msg += <STRING> + <STRING> . join ( lines ) <NEWLINE> self . msg += <STRING> + error_name <NEWLINE> if index : <NEWLINE> self . msg += <STRING> <NEWLINE> <DEDENT> <DEDENT>
class GetterBy ( list ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , tups ) : super ( GetterBy , self ) . __init__ ( tups ) <NEWLINE> def __getitem__ ( self , ( key , value ) ) : return next ( x for x in self if getattr ( x , key ) == value ) <NEWLINE> def __contains__ ( self , ( key , value ) ) : return any ( getattr ( x , key ) == value for x in self ) <NEWLINE> <DEDENT>
def is_int ( x ) : <NEWLINE> <INDENT> if x == int ( x ) : <NEWLINE> <INDENT> return True <NEWLINE> else : <NEWLINE> return False <NEWLINE> <DEDENT> <DEDENT>
def test_top ( self ) : <NEWLINE> <INDENT> msgs = ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> tb = gr . top_block ( ) <NEWLINE> src = demo_msg_src ( msgs ) <NEWLINE> sink = demo_msg_sink ( len ( msgs ) <NEWLINE> tb . connect ( src , sink ) <NEWLINE> tb . run ( ) <NEWLINE> self . assertItemsEqual ( sink . msgs ( ) , msgs ) <NEWLINE> <DEDENT>
def test_sigchain_fileobj ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . set_gpg_profile ( ) <NEWLINE> self . sigchain_fileobj_check_list ( self . sigchain_fileobj_get ( 1 ) <NEWLINE> self . sigchain_fileobj_check_list ( self . sigchain_fileobj_get ( None ) ) <NEWLINE> <DEDENT>
def updateBounds ( bounds , ( x , y ) , min = min , max = max ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> xMin , yMin , xMax , yMax = bounds <NEWLINE> return min ( xMin , x ) , min ( yMin , y ) , max ( xMax , x ) , max ( yMax , y ) <NEWLINE> <DEDENT>
def password_md5 ( s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> h = hashlib . md5 ( ) <NEWLINE> h . update ( s . encode ( <STRING> ) <NEWLINE> return h . hexdigest ( ) <NEWLINE> <DEDENT>
def testDepthwiseConv2DInputGradCompare ( self ) : <NEWLINE> <INDENT> for index , ( input_size , filter_size , output_size , stride , <NEWLINE> <INDENT> padding ) in enumerate ( ConfigsToTest ( ) ) : <NEWLINE> print ( <STRING> , index , <STRING> , <NEWLINE> input_size , <STRING> , filter_size , <STRING> , stride , <STRING> , <NEWLINE> padding ) <NEWLINE> self . _CompareBackpropInputFloat ( input_size , filter_size , output_size , <NEWLINE> <INDENT> stride , padding ) <NEWLINE> self . _CompareBackpropInputDouble ( input_size , filter_size , output_size , <NEWLINE> <INDENT> stride , padding ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def polyfunc2d ( ( x , y ) , a , b , c , d , e , f ) : <NEWLINE> <INDENT> u = a + b * x + c * y + d * ( x ** 2 ) + e * x * y + f * ( y ** 2 ) <NEWLINE> return u <NEWLINE> <DEDENT>
class TipoTaxonAdmin ( admin . ModelAdmin ) : <NEWLINE> <INDENT> list_display = ( <STRING> , <STRING> , <STRING> , <STRING> , ) <NEWLINE> list_editable = ( <STRING> , ) <NEWLINE> def formfield_for_foreignkey ( self , db_field , request , ** kwargs ) : <NEWLINE> <INDENT> if db_field . name == <STRING> : <NEWLINE> <INDENT> kwargs [ <STRING> ] = User . objects . filter ( id = request . user . id ) <NEWLINE> <DEDENT> return super ( TipoTaxonAdmin , self ) . formfield_for_foreignkey ( db_field , request , ** kwargs ) <NEWLINE> <DEDENT> class Media : <NEWLINE> js = ( <STRING> , <STRING> ) <NEWLINE> <DEDENT>
def _get_node_and_metadata_for_path ( self , path ) : <NEWLINE> <INDENT> d = self . _get_root ( path ) <NEWLINE> def _got_root ( ( root , path ) ) : <NEWLINE> <INDENT> if path : <NEWLINE> <INDENT> return root . get_child_and_metadata_at_path ( path ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( root , { } ) <NEWLINE> <DEDENT> <DEDENT> d . addCallback ( _got_root ) <NEWLINE> return d <NEWLINE> <DEDENT>
def reset ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> _lock . writeLock ( ) . lock ( ) <NEWLINE> _cache . clear ( ) <NEWLINE> <DEDENT> final : <NEWLINE> <INDENT> _lock . writeLock ( ) . unlock ( ) <NEWLINE> <DEDENT> <DEDENT>
def setup ( topdir ) : <NEWLINE> <INDENT> srcdir = os . path . join ( topdir , <STRING> ) <NEWLINE> os . chdir ( srcdir ) <NEWLINE> utils . configure ( <STRING> % topdir ) <NEWLINE> utils . make ( <STRING> % utils . count_cpus ( ) <NEWLINE> utils . make ( <STRING> ) <NEWLINE> os . chdir ( topdir ) <NEWLINE> <DEDENT>
def user_dict ( user ) : <NEWLINE> <INDENT> groups = [ group . pk for group in user . groups . all ( ) ] <NEWLINE> data = { <NEWLINE> <INDENT> <STRING> : user . pk , <NEWLINE> <STRING> : user . username , <NEWLINE> <STRING> : user . first_name <NEWLINE> <STRING> : user . last_name , <NEWLINE> <STRING> : groups or None <NEWLINE> <DEDENT> } <NEWLINE> return data <NEWLINE> <DEDENT>
def _doCommand ( self , valueStr ) : <NEWLINE> <INDENT> valueInt = self . scale . get ( ) <NEWLINE> colors = self [ <STRING> ] <NEWLINE> thresholds = self [ <STRING> ] <NEWLINE> color = colors [ - 1 ] <NEWLINE> for index in range ( len ( colors ) - 1 ) : <NEWLINE> <INDENT> if valueInt <= thresholds [ index ] : <NEWLINE> color = colors [ index ] <NEWLINE> break <NEWLINE> <DEDENT> self . indicator . configure ( background = color ) <NEWLINE> self . value . configure ( text = valueStr ) <NEWLINE> <DEDENT>
def getmodinfo ( self , mname ) : <NEWLINE> <INDENT> self . info += <STRING> + mname + <STRING> + self . show_config ( self . modl [ mname ] . conf ) <NEWLINE> for proc in self . lproc : <NEWLINE> <INDENT> if proc . mod . name == mname : <NEWLINE> <INDENT> self . info += <STRING> + self . show_arg ( proc . args ) <NEWLINE> <INDENT> self . info += <STRING> + self . show_res ( proc . res ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
class SnapTransfer ( action . Action ) : <NEWLINE> <INDENT> def __init__ ( self , init , driver , <NEWLINE> <INDENT> snap_position ) : <NEWLINE> super ( SnapTransfer , self ) . __init__ ( init ) <NEWLINE> self . driver = driver ( self . src_cloud , <NEWLINE> <INDENT> self . dst_cloud , <NEWLINE> self . cfg ) <NEWLINE> self . snap_position = snap_position <NEWLINE> <DEDENT> <DEDENT> def run ( self , volume , snapshot_info , ** kwargs ) : <NEWLINE> <INDENT> self . driver . transfer ( volume , snapshot_info , self . snap_position ) <NEWLINE> return { } <NEWLINE> <DEDENT> <DEDENT>
def create_user_rss ( user_id , ** kwargs ) <NEWLINE> <INDENT> user = User . query . filter_by ( id = user_id ) . first ( ) <NEWLINE> UserHandler ( ) . create_rss ( user ) <NEWLINE> user . save ( ) <NEWLINE> return <NEWLINE> <DEDENT>
def EndLoadScreen ( ) : <NEWLINE> <INDENT> LoadScreen . SetVisible ( WINDOW_VISIBLE ) <NEWLINE> LoadScreen . Unload ( ) <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> <DEDENT>
def write_file ( self , result ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for row in result . results : <NEWLINE> <INDENT> filename = row [ <STRING> ] <NEWLINE> with open ( filename , <STRING> ) as in_fd : <NEWLINE> <INDENT> with self . session . GetRenderer ( ) . open ( <NEWLINE> <INDENT> directory = self . dump_dir , <NEWLINE> filename = filename , mode = <STRING> ) as out_fd : <NEWLINE> while 1 : <NEWLINE> data = in_fd . read ( 1024 * 1024 ) <NEWLINE> if not data : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> out_fd . write ( data ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
class TestTimeLog ( unittest . TestCase ) : <NEWLINE> <INDENT> def test_duplication ( self ) : <NEWLINE> <INDENT> ts = frappe . get_doc ( frappe . copy_doc ( test_records [ 0 ] ) <NEWLINE> self . assertRaises ( OverlapError , ts . insert ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , ft232h ) : <NEWLINE> <INDENT> self . ft232h = ft232h <NEWLINE> self . count = 0 <NEWLINE> print ( <STRING> ) <NEWLINE> super ( I2CScanner , self ) . __init__ ( ) <NEWLINE> <INDENT> def __del__ ( self ) : <NEWLINE> <INDENT> self . wait ( ) <NEWLINE> <DEDENT> def close ( self ) : <NEWLINE> <INDENT> self . terminate ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def assign_role ( chat_id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> curr_game = get_curr_game ( chat_id ) <NEWLINE> num_player = curr_game . num_player <NEWLINE> numSpies = identityDictRS [ num_player ] [ 1 ] <NEWLINE> numResistance = identityDictRS [ num_player ] [ 0 ] <NEWLINE> player_list = get_curr_player_list ( chat_id ) <NEWLINE> count = 0 <NEWLINE> for player in player_list : <NEWLINE> <INDENT> indicator = randint ( 0 , 1 ) <NEWLINE> if indicator == 1 and count < numSpies : <NEWLINE> <INDENT> player . role = <STRING> <NEWLINE> count = count + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> player . role = the resistance <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <DEDENT>
def process_metrics_event ( session , ref , snapshot ) : <NEWLINE> <INDENT> vm_ref = vm_of_metrics ( session , ref ) <NEWLINE> if vm_ref == None : <NEWLINE> return <NEWLINE> if session . xenapi . VM . get_power_state ( vm_ref ) < > <STRING> : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> other = { } <NEWLINE> try : <NEWLINE> <INDENT> other = session . xenapi . VM_guest_metrics . get_other ( ref ) <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> print ( repr ( e ) ) <NEWLINE> <DEDENT> if <STRING> in other . keys ( ) : <NEWLINE> <INDENT> seen_possible_boot ( session , vm_ref ) <NEWLINE> <DEDENT> <DEDENT>
def get_size ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return format_size ( self . file_data . size ) <NEWLINE> <DEDENT> except ( OSError , IOError ) : <NEWLINE> <INDENT> logging . error ( <STRING> % repr ( { <NEWLINE> <INDENT> <STRING> : self . file_data . path , <NEWLINE> <STRING> : <STRING> % ( type ( self ) . _meta . app_label , type ( self ) . _meta . module_name ) <NEWLINE> <STRING> : self . pk , <NEWLINE> <DEDENT> } ) ) <NEWLINE> return None <NEWLINE> <DEDENT> <DEDENT>
def get_plugins ( self ptype ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ptype not in PLUGIN_TYPES : <NEWLINE> <INDENT> raise errors . CreatorError ( <STRING> % ptype ) <NEWLINE> <DEDENT> plugins_dir = self . _build_plugin_dir_list ( self . plugin_dir , ptype ) <NEWLINE> self . append_dirs ( plugins_dir ) <NEWLINE> return pluginbase . get_plugins ( ptype ) <NEWLINE> <DEDENT>
from rest_framework import serializers <NEWLINE> from contrib . drf_introspection . serializers import StrictSerializerMixin <NEWLINE> from . models import Label , Arch , SigKey <NEWLINE> class LabelSerializer ( StrictSerializerMixin , <NEWLINE> <INDENT> serializers . HyperlinkedModelSerializer ) : <NEWLINE> <STRING> <NEWLINE> class Meta : <NEWLINE> model = Label <NEWLINE> fields = ( <STRING> , <STRING> , <STRING> ) <NEWLINE> <DEDENT>
class Object ( object ) : <NEWLINE> <INDENT> def __init__ ( self , name , sprite , ( x , y ) , scale , rot ) : <NEWLINE> <INDENT> self . name = name <NEWLINE> self . sprite = sprite <NEWLINE> self . x = y <NEWLINE> self . y = x <NEWLINE> self . scale = scale <NEWLINE> self . rot = rot <NEWLINE> <DEDENT> <STRING> <NEWLINE> def doesPointIntersect ( self , point , threshold ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
def entry_error ( cfg , entry ) : <NEWLINE> <INDENT> if ( cfg . entry_error_busy == True ) : <NEWLINE> return <NEWLINE> cfg . entry_error_busy = True <NEWLINE> thread_messageBox = thread_gfunc ( cfg , False , True , entry_error_t , cfg , entry ) <NEWLINE> thread_messageBox . start ( ) <NEWLINE> <DEDENT>
def __init__ ( self , ( client , address ) ) : <NEWLINE> <INDENT> threading . Thread . __init__ ( self ) <NEWLINE> self . client = client <NEWLINE> self . address = address <NEWLINE> self . size = 1024 <NEWLINE> <DEDENT>
def test_getargspec_sublistofone ( self ) : <NEWLINE> <INDENT> def sublistOfOne ( ( foo , ) ) : return 1 <NEWLINE> self . assertArgSpecEquals ( sublistOfOne , [ [ <STRING> ] ] ) <NEWLINE> def fakeSublistOfOne ( ( foo ) ) : return 1 <NEWLINE> self . assertArgSpecEquals ( fakeSublistOfOne , [ <STRING> ] ) <NEWLINE> <DEDENT>
import requests <NEWLINE> from oauth10a import signing_requests <NEWLINE> user_authorization_url = None <NEWLINE> access_token_url = None <NEWLINE> def obtain_request_token ( request_token_url , consumer_key , secret_key , <NEWLINE> <INDENT> callback_url = <STRING> , http_method = <STRING> , <NEWLINE> ** additional_params ) : <NEWLINE> <STRING> <NEWLINE> auth = signing_requests . HMACSHA1Auth ( <NEWLINE> consumer_key , secret_key , callback_url ) <NEWLINE> if http_method == <STRING> : <NEWLINE> return requests . post ( request_token_url , auth = auth ) <NEWLINE> elif http_method == <STRING> : <NEWLINE> return requests . get ( request_token_url , auth = auth ) <NEWLINE> <DEDENT>
class CdblibShelf ( ShelfWithHooks ) : <NEWLINE> <INDENT> def __init__ ( self , filename , flag , key_type = <STRING> , dump_method = None , <NEWLINE> <INDENT> cached = True , writeback = False ) : <NEWLINE> if flag == <STRING> : <NEWLINE> Shelf . __init__ ( self , CDBReader ( filename ) , - 1 , writeback ) <NEWLINE> elif flag == <STRING> : <NEWLINE> Shelf . __init__ ( self , CDBWriter ( filename ) , - 1 , writeback ) <NEWLINE> self . _setup_methods ( cached , key_type , dump_method ) <NEWLINE> <DEDENT> def close ( self ) : <NEWLINE> <INDENT> self . dict . close ( ) <NEWLINE> <DEDENT> <DEDENT>
def undef_macro ( self , macro_name , line_num , filename ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if macro_name not in self . macros : <NEWLINE> <INDENT> print ( <STRING> % ( macro_name , filename , line_num ) ) <NEWLINE> return <NEWLINE> <DEDENT> if self . debug : print <STRING> % ( macro_name , filename , line_num ) <NEWLINE> del self . macros [ macro_name ] <NEWLINE> <DEDENT>
def dispatch_simplify_path ( self , planner , ( request_id , request ) ) : <NEWLINE> <INDENT> thread = threading . Thread ( target = self . simplify_path_wrapper , args = ( planner , request_id , request , self . handle_simplify_path_response ) ) <NEWLINE> thread . start ( ) <NEWLINE> <DEDENT>
def ReadFromFile ( filename ) : <NEWLINE> <INDENT> with open ( filename , <STRING> ) as f : <NEWLINE> return f . read ( ) <NEWLINE> <DEDENT>
def get ( self ) : <NEWLINE> <INDENT> self . _entry = SSCAPI . ssc_module_entry ( self . _idx ) <NEWLINE> if ( self . _entry is None ) : <NEWLINE> self . reset ( ) <NEWLINE> return False <NEWLINE> else : <NEWLINE> self . _idx += 1 <NEWLINE> return True <NEWLINE> <DEDENT>
def test_get_datapath_retry_out_by_default_time ( self ) : <NEWLINE> <INDENT> cfg . CONF . set_override ( <STRING> , 3 , group = <STRING> ) <NEWLINE> with mock . patch . object ( self . mod_agent . ryu_api , <STRING> , <NEWLINE> <INDENT> return_value = None ) as mock_get_datapath : <NEWLINE> with testtools . ExpectedException ( SystemExit ) : <NEWLINE> self . ovs . datapath_id = <STRING> <NEWLINE> self . ovs . get_datapath ( retry_max = 3 ) <NEWLINE> <DEDENT> self . assertEqual ( mock_get_datapath . call_count , 3 ) <NEWLINE> <DEDENT>
def permute ( variable , output_order = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> input_dimensions = variable . dimensions <NEWLINE> dimensions = filter ( lambda ( x ) : x in input_dimensions , <NEWLINE> <INDENT> output_order ) <NEWLINE> <DEDENT> mapping = map ( lambda ( x ) : dimensions . index ( x ) , <NEWLINE> <INDENT> input_dimensions ) <NEWLINE> <DEDENT> if mapping : <NEWLINE> <INDENT> return np . transpose ( variable [ : ] , mapping ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return variable [ : ] <NEWLINE> <DEDENT> <DEDENT>
class MainHandler ( tornado . web . RequestHandler ) : <NEWLINE> <INDENT> def get ( self ) : <NEWLINE> sesiones = [ ] <NEWLINE> for key , val in csv . reader ( open ( <STRING> ) ) : <NEWLINE> <INDENT> sesiones . append ( [ key , val ] ) <NEWLINE> if len ( sesiones ) > 0 : <NEWLINE> <DEDENT> self . render ( <STRING> , title = <STRING> , datos = sesiones ) <NEWLINE> else : <NEWLINE> self . write ( <STRING> ) <NEWLINE> <DEDENT>
def height_vertical_coord ( cube , field ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( field . reference_vertical_coord_type == field . int_mdi or <NEWLINE> <INDENT> field . reference_vertical_coord == field . float32_mdi ) : <NEWLINE> height_coord = DimCoord ( field . vertical_coord , <NEWLINE> <INDENT> standard_name = <STRING> , units = <STRING> , <NEWLINE> attributes = { <STRING> : <STRING> } ) <NEWLINE> cube . add_aux_coord ( height_coord ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> raise TranslationError ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def redistribute ( winner , looser , depth ) : <NEWLINE> <INDENT> cdef unsigned int i <NEWLINE> for i in range ( depth + 1 ) : <NEWLINE> <INDENT> winner . append ( looser [ 0 ] ) <NEWLINE> winner . append ( winner [ 0 ] ) <NEWLINE> del winner [ 0 ] <NEWLINE> del looser [ 0 ] <NEWLINE> <DEDENT> <DEDENT>
def collideswordlow ( self , player ) : <NEWLINE> <INDENT> for i in self . gameobjects : <NEWLINE> if i != None : <NEWLINE> id = i . collidewithswordlow ( self , player ) <NEWLINE> return i <NEWLINE> return None <NEWLINE> <DEDENT>
class CreateAndUpdateVolume ( cinder_utils . CinderBasic ) : <NEWLINE> <INDENT> def run ( self , size , image = None , create_volume_kwargs = None , <NEWLINE> <INDENT> update_volume_kwargs = None ) : <NEWLINE> <STRING> <NEWLINE> create_volume_kwargs = create_volume_kwargs or { } <NEWLINE> update_volume_kwargs = update_volume_kwargs or { } <NEWLINE> if image : <NEWLINE> create_volume_kwargs [ <STRING> ] = image <NEWLINE> if update_volume_kwargs . pop ( <STRING> , False ) : <NEWLINE> update_volume_kwargs [ <STRING> ] = self . generate_random_name ( ) <NEWLINE> volume = self . cinder . create_volume ( size , ** create_volume_kwargs ) <NEWLINE> self . cinder . update_volume ( volume , ** update_volume_kwargs ) <NEWLINE> <DEDENT> <DEDENT>
def get_template_names ( self ) : <NEWLINE> <INDENT> return ( <STRING> <NEWLINE> <INDENT> . format ( self . template_name_suffix ) <NEWLINE> <DEDENT> <DEDENT>
def new_workunit ( self , name , labels = None , cmd = <STRING> , log_config = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> parent = self . _threadlocal . current_workunit <NEWLINE> with self . new_workunit_under_parent ( name , parent = parent , labels = labels , cmd = cmd , <NEWLINE> <INDENT> log_config = log_config ) as workunit : <NEWLINE> self . _threadlocal . current_workunit = workunit <NEWLINE> try : <NEWLINE> yield workunit <NEWLINE> finally : <NEWLINE> self . _threadlocal . current_workunit = parent <NEWLINE> <DEDENT> <DEDENT>
def retranslateUi ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . aboutLabel . setText ( _translate ( <STRING> , self . workflowProvider . aboutHTML , None ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> self . aboutLabel . setText ( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT> <DEDENT>
def co_findloadednames ( co ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> names = { } <NEWLINE> names . update ( co_code_findloadednames ( co ) ) <NEWLINE> for c in co . co_consts : <NEWLINE> if isinstance ( c , type ( co ) ) : <NEWLINE> <INDENT> names . update ( co_findloadednames ( c ) ) <NEWLINE> <DEDENT> return names <NEWLINE> <DEDENT>
def advanced_cnlgb ( self ) : <NEWLINE> <INDENT> zz = [ ] <NEWLINE> p = get_CNL_sentence_authors ( self ) <NEWLINE> if not p : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> zz . extend ( p ) <NEWLINE> <INDENT> <STRING> <NEWLINE> rt = get_RT_sentence ( self ) <NEWLINE> if not rt : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> zz . extend ( rt ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return zz <NEWLINE> <DEDENT>
def createList ( data ) : <NEWLINE> <INDENT> size = len ( data ) <NEWLINE> if size == 0 : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> head = ListNode ( data [ 0 ] ) <NEWLINE> p = head <NEWLINE> for i in range ( 1 , size ) : <NEWLINE> q = ListNode ( data [ i ] ) <NEWLINE> <INDENT> p . next = q <NEWLINE> p = q <NEWLINE> <DEDENT> p . next = None <NEWLINE> return head <NEWLINE> <DEDENT>
def buildQueues ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> self . buildImageList ( ) <NEWLINE> self . sortImages ( ) <NEWLINE> pools = list ( ) <NEWLINE> for tier in self . tiers : <NEWLINE> <INDENT> pool = Queue . Queue ( ) <NEWLINE> for image in tier : <NEWLINE> <INDENT> pool . put ( image ) <NEWLINE> <DEDENT> pools . append ( pool ) <NEWLINE> <DEDENT> return pools <NEWLINE> <DEDENT> <DEDENT>
def parse_cpath ( path ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if path . startswith ( <STRING> ) and path . endswith ( <STRING> ) and ( <STRING> not in path ) : <NEWLINE> return path <NEWLINE> elif path . startswith ( <STRING> ) or path . endswith ( <STRING> ) or ( <STRING> in path ) : <NEWLINE> raise ParseError ( <STRING> , path ) <NEWLINE> else : <NEWLINE> return <STRING> + path . replace ( <STRING> , <STRING> ) + <STRING> <NEWLINE> <DEDENT>
class CategoryAdmin ( admin . ModelAdmin ) : <NEWLINE> <INDENT> search_fields = [ <STRING> , <STRING> ] <NEWLINE> list_display = [ <STRING> , <STRING> ] <NEWLINE> <INDENT> ordering = ( <STRING> , ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> response = <STRING> <NEWLINE> if not response : <NEWLINE> <INDENT> d = Dialog ( <STRING> ) <NEWLINE> response = d . yesno ( <STRING> , <STRING> ) <NEWLINE> if response : <NEWLINE> <DEDENT> d . infobox ( <STRING> ) <NEWLINE> system ( <STRING> ) <NEWLINE> system ( <STRING> ) <NEWLINE> system ( <STRING> ) <NEWLINE> d . infobox ( <STRING> ) <NEWLINE> system ( <STRING> ) <NEWLINE> <DEDENT>
def sync_user_email_addresses ( user ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> from . models import EmailAddress <NEWLINE> email = user_email ( user ) <NEWLINE> if email and not EmailAddress . objects . filter ( user = user , <NEWLINE> <INDENT> email__iexact = email ) . exists ( ) : <NEWLINE> if app_settings . UNIQUE_EMAIL and EmailAddress . objects . filter ( email__iexact = email ) . exists ( ) : <NEWLINE> return <NEWLINE> EmailAddress . objects . create ( user = user , <NEWLINE> email = email , <NEWLINE> primary = False , <NEWLINE> verified = False ) <NEWLINE> <DEDENT> <DEDENT>
def get_size_t ( self , i ) : <NEWLINE> <INDENT> if ( i < 0 or i >= self . _nobjects ) <NEWLINE> <INDENT> raise Exception ( <STRING> % ( i , self . _path ) ) <NEWLINE> <DEDENT> self . _fp . seek ( self . _hsize + i * self . _rlength ) <NEWLINE> vec = self . _fp . read ( self . _rlength ) <NEWLINE> return list ( unpack ( <STRING> % self . _vdim , vec ) ) <NEWLINE> <DEDENT>
def _start_cli ( self , ** kw ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> _ ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def attach ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . dc . setup ( ) <NEWLINE> meta_node = get_meta_node ( ) <NEWLINE> unalloc_nodes = [ i if self . nodes [ i ] . status ( ) == NULL_NODE for i in range ( self . dc . block_num ] <NEWLINE> self . free_list = deque ( unalloc_nodes ) <NEWLINE> <DEDENT>
( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>
def wait_for_tool_in_spindle ( self , expected_tool , timeout = 10.0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> start_time = time . time ( ) <NEWLINE> while ( time . time ( ) - start_time ) < timeout : <NEWLINE> <INDENT> time . sleep ( 0.1 ) <NEWLINE> <INDENT> self . status . poll ( ) <NEWLINE> <DEDENT> if self . status . tool_in_spindle == expected_tool : <NEWLINE> print ( <STRING> % ( expected_tool , time . time ( ) - start_time ) ) <NEWLINE> return <NEWLINE> <DEDENT> raise LinuxCNC_Exception ( <STRING> % ( self . status . tool_in_spindle , expected_tool ) ) <NEWLINE> <DEDENT>
import hashlib <NEWLINE> import os <NEWLINE> def CallAndRecordIfStale ( <NEWLINE> <INDENT> function , record_path = None , input_paths = None , input_strings = None , <NEWLINE> force = False ) : <NEWLINE> <STRING> <NEWLINE> if not input_paths : <NEWLINE> input_paths = [ ] <NEWLINE> if not input_strings : <NEWLINE> input_strings = [ ] <NEWLINE> md5_checker = _Md5Checker ( <NEWLINE> <INDENT> record_path = record_path , <NEWLINE> input_paths = input_paths , <NEWLINE> input_strings = input_strings ) <NEWLINE> if force or md5_checker . IsStale ( ) : <NEWLINE> <DEDENT> function ( ) <NEWLINE> md5_checker . Write ( ) <NEWLINE> <DEDENT>
def readSection ( self , section ) : <NEWLINE> <INDENT> self . sectionData [ self . sections [ section ] = np . genfromtxt ( self . datafile , <NEWLINE> <INDENT> delimiter = <STRING> , <NEWLINE> skip_header = ( int ( self . sectionBegin [ section ] ) - 1 ) , <NEWLINE> skip_footer = ( self . fileLen - int ( self . sectionEnd [ section ] ) ) , <NEWLINE> filling_values = 0 , <NEWLINE> invalid_raise = False , <NEWLINE> unpack = True <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT>
def __setattr__ ( self k , v ) : <NEWLINE> <INDENT> done , v = DummySettingsManager . __setattr__ ( self , k , v ) <NEWLINE> if done : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if k in self . _save : <NEWLINE> <INDENT> print ( <STRING> . format ( k ) ) <NEWLINE> self . _save [ k ] = v <NEWLINE> self . dump ( False ) <NEWLINE> <DEDENT> <DEDENT>
if friend [ <STRING> ] not in shortest_paths_from ) <NEWLINE>
< % if ( isPaymentPackage ) { % > from django . views . generic import RedirectView , View <NEWLINE> import oscar <NEWLINE> from oscar . core . loading import get_class , get_model <NEWLINE> PaymentDetailsView = get_class ( <STRING> , <STRING> ) <NEWLINE> CheckoutSessionMixin = get_class ( <STRING> , <STRING> ) <NEWLINE>
def from_html ( self , html ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> soup = BeautifulSoup . BeautifulSoup ( html , <NEWLINE> <INDENT> convertEntities = BeautifulSoup . BeautifulSoup . XHTML_ENTITIES ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> raise self . ParseError , <STRING> <NEWLINE> <DEDENT> return self . from_soup ( soup ) <NEWLINE> <DEDENT>
def _ForwardStageFull ( self , ctr , in_a , in_b , in_c , in_rhs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . tmp [ ctr ] = in_c [ ctr [ 0 , 0 , - 1 ] ] / self . bet [ ctr ] <NEWLINE> self . bet [ ctr ] = in_b [ ctr ] - in_a [ ctr ] * self . tmp [ ctr ] <NEWLINE> self . y [ ctr ] = ( in_rhs [ ctr ] - <NEWLINE> <INDENT> in_a [ ctr ] * self . y [ ctr [ 0 , 0 , - 1 ] ] / self . bet [ ctr ] <NEWLINE> <DEDENT> <DEDENT>
def putline ( self , line ) : <NEWLINE> <INDENT> if self . debugging > 1 : print <STRING> , repr ( line ) <NEWLINE> line += CRLF <NEWLINE> bytes = len ( line ) <NEWLINE> while bytes > 0 : <NEWLINE> <INDENT> sent = self . sslobj . write ( line ) <NEWLINE> if sent == bytes : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> line = line [ sent : ] <NEWLINE> bytes = bytes - sent <NEWLINE> <DEDENT> <DEDENT>
def printVariant ( self , delim , ** kwargs ) : <NEWLINE> <INDENT> onlyThisVariant = kwargs . get ( <STRING> , False ) <NEWLINE> if not onlyThisVariant : <NEWLINE> <INDENT> super ( vepcolocatedvariant , self ) . printVariant ( delim , ** kwargs ) <NEWLINE> <DEDENT> print ( <STRING> , <NEWLINE> if self . ID : <NEWLINE> <INDENT> print ( <STRING> , ) <NEWLINE> print ( self . ID + delim , ) <NEWLINE> <DEDENT> if self . phenotypeOrDisease : <NEWLINE> <INDENT> print ( <STRING> + self . phenotypeOrDisease + delim , ) <NEWLINE> <DEDENT> if self . somatic : <NEWLINE> <INDENT> print ( <STRING> + self . somatic ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def db4_file_classes_request ( filepath , path_to_db4 ) : <NEWLINE> <INDENT> mydb = bsddb . btopen ( path_to_db4 + <STRING> , <STRING> ) <NEWLINE> mykeys = mydb . keys ( ) <NEWLINE> respond = [ ] <NEWLINE> for key , val in mydb . iteritems ( ) : <NEWLINE> s_key = key . rsplit ( <STRING> ) <NEWLINE> s_val = val . rsplit ( <STRING> ) <NEWLINE> if s_key [ 2 ] . find ( filepath ) >= 0 : <NEWLINE> <INDENT> respond . append ( { <STRING> : s_key [ 0 ] , <STRING> : <STRING> , <STRING> : <STRING> } ) <NEWLINE> <DEDENT> return respond <NEWLINE> <DEDENT>
def __init__ ( self , data , tag ) : <NEWLINE> <INDENT> self . _data = data <NEWLINE> self . _lrtype = parseTypeTag ( tag ) <NEWLINE> def __lrtype__ ( self ) : <NEWLINE> return self . _lrtype <NEWLINE> <DEDENT>
def run ( ) : <NEWLINE> <INDENT> params = plugintools . get_params ( ) <NEWLINE> if params . get ( <STRING> ) is None : <NEWLINE> <INDENT> xbmc . Player ( ) . play ( entryurl ) <NEWLINE> while xbmc . Player ( ) . isPlaying ( ) : <NEWLINE> <INDENT> time . sleep ( 1 ) <NEWLINE> <DEDENT> main_list ( params ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> action = params . get ( <STRING> ) <NEWLINE> exec action + <STRING> <NEWLINE> <DEDENT> plugintools . close_item_list ( ) <NEWLINE> <DEDENT>
def test_set_power_state_reboot ( self , run_method_mock ) : <NEWLINE> <INDENT> with task_manager . acquire ( self . context , self . node . uuid , <NEWLINE> <INDENT> shared = False ) as task : <NEWLINE> task . driver . power . set_power_state ( task , states . REBOOT ) <NEWLINE> run_method_mock . assert_any_call ( task . node , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ) <NEWLINE> run_method_mock . assert_any_call ( task . node , <NEWLINE> <STRING> , <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def save_shp ( self , shape_file , user ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> shp = shape_file [ <STRING> ] <NEWLINE> shx = shape_file [ <STRING> ] <NEWLINE> dbf = shape_file [ <STRING> ] <NEWLINE> prj = shape_file [ <STRING> ] <NEWLINE> file_saved = ShapeFile . objects . create ( shp = shp , shx = shx , <NEWLINE> <INDENT> dbf = dbf , prj = prj , <NEWLINE> owner = user ) <NEWLINE> <DEDENT> return file_saved <NEWLINE> <DEDENT> <DEDENT>
def PrintSummary ( self , trace_tag ) : <NEWLINE> <INDENT> if self . page_failures : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for measurement_units_type , values in sorted ( <NEWLINE> <INDENT> self . results_summary . iteritems ( ) ) : <NEWLINE> measurement , units , data_type = measurement_units_type <NEWLINE> if <STRING> in measurement : <NEWLINE> measurement , trace = measurement . split ( <STRING> , 1 ) <NEWLINE> trace += ( trace_tag or <STRING> ) <NEWLINE> else : <NEWLINE> trace = measurement + ( trace_tag or <STRING> ) <NEWLINE> PrintPerfResult ( measurement , trace , values , units , data_type ) <NEWLINE> <DEDENT> <DEDENT>
def test_unassigned ( function , * args ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> function ( * args ) <NEWLINE> <DEDENT> except UnboundLocalError , n : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Fail ( <STRING> % function . func_name ) <NEWLINE> <DEDENT> <DEDENT>
def off ( ) : <NEWLINE> <INDENT> led = Pin ( args . sensor , <STRING> ) <NEWLINE> print ( <STRING> % args . sensor ) <NEWLINE> led . off ( ) <NEWLINE> pin_status = subprocess . check_output ( [ <STRING> , <STRING> + pin_kernel + <STRING> ] ) <NEWLINE> <INDENT> if pin_status . strip ( ) != <STRING> : <NEWLINE> <INDENT> print ( <STRING> % pin_status . strip ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> % pin_status . strip ( ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def __onKeyClick ( self , evt ) : <NEWLINE> <INDENT> button = ( evt . GetEventObject ( ) ) . Label <NEWLINE> passwd = self . focus . GetValue ( ) <NEWLINE> if button == <STRING> : <NEWLINE> <INDENT> if len ( passwd ) > 0 : <NEWLINE> passwd = passwd [ : - 1 ] <NEWLINE> self . focus . SetValue ( passwd ) <NEWLINE> <DEDENT> elif button == <STRING> : <NEWLINE> <INDENT> self . Close ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> passwd += button <NEWLINE> self . focus . SetValue ( passwd ) <NEWLINE> <DEDENT> <DEDENT>
def on_key_pressed ( widget , event ) : <NEWLINE> <INDENT> if ( event . state & gtk . gdk . CONTROL_MASK and <NEWLINE> <INDENT> event . keyval == gtk . gdk . keyval_from_name ( <STRING> ) ) : <NEWLINE> if widget . view == <STRING> : <NEWLINE> widget . set_view ( <STRING> ) <NEWLINE> else : <NEWLINE> widget . set_view ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def test_ensure_gateways_present_is_executed_once ( self ) : <NEWLINE> <INDENT> with patch . object ( <NEWLINE> <INDENT> objects . Cluster . get_network_manager ( self . cluster ) , <NEWLINE> <STRING> ) as ensure_mock : <NEWLINE> for n in range ( 2 ) : <NEWLINE> resp = self . env . create_node_group ( name = <STRING> . format ( n ) ) <NEWLINE> self . assertEquals ( resp . status_code , 201 ) <NEWLINE> self . assertEqual ( <NEWLINE> <INDENT> ensure_mock . call_count , 1 , <NEWLINE> <STRING> <NEWLINE> <STRING> . format ( ensure_mock . call_count , <NEWLINE> <INDENT> resp . json_body [ <STRING> ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def callback ( ) : <NEWLINE> <INDENT> if p . input ( <STRING> ) : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
def test_parsePlaylistFeed ( self ) : <NEWLINE> <INDENT> self . _mockFeedCall ( <STRING> , <STRING> ) <NEWLINE> plEntries = list ( yt . iPlaylistEntries ( self . account . username ) <NEWLINE> self . assertEqual ( len ( plEntries ) , 13 ) <NEWLINE> pls = map ( yt . entry2group , plEntries ) <NEWLINE> extId , name = pls [ 0 ] <NEWLINE> self . assertEqual ( name , <STRING> ) <NEWLINE> self . assertEqual ( extId , <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> self . cliMock . verify ( ) <NEWLINE> <DEDENT>
class Ui_sign_inDialog ( object ) : <NEWLINE> <INDENT> def setupUi ( self , sign_inDialog ) : <NEWLINE> <INDENT> sign_inDialog . setObjectName ( <STRING> ) <NEWLINE> sign_inDialog . setWindowModality ( QtCore . Qt . ApplicationModal ) <NEWLINE> sign_inDialog . resize ( 400 , 300 ) <NEWLINE> sizePolicy = QtWidgets . QSizePolicy ( QtWidgets . QSizePolicy . Fixed , QtWidgets . QSizePolicy . Fixed ) <NEWLINE> sizePolicy . setHorizontalStretch ( 0 ) <NEWLINE> sizePolicy . setVerticalStretch ( 0 ) <NEWLINE> sizePolicy . setHeightForWidth ( sign_inDialog . sizePolicy ( ) . hasHeightForWidth ( ) ) <NEWLINE> sign_inDialog . setSizePolicy ( sizePolicy ) <NEWLINE> sign_inDialog . setStyleSheet ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
def _stop ( self , signame : str ) : <NEWLINE> <INDENT> print ( <STRING> . format ( signame ) <NEWLINE> self . _loop . stop ( ) <NEWLINE> <DEDENT>
def on_config_sensors ( self , client , userdata , msg ) : <NEWLINE> <INDENT> self . logger . info ( <STRING> ) <NEWLINE> with self . config_sensors_lock : <NEWLINE> <INDENT> self . sensors . update ( json . loads ( msg . payload ) ) <NEWLINE> <DEDENT> if not self . config_sensors_received . is_set ( ) <NEWLINE> <INDENT> self . logger . info ( <STRING> ) <NEWLINE> self . config_sensors_received . set ( ) <NEWLINE> client . subscribe ( <STRING> . format ( module_id = self . module_id ) ) <NEWLINE> <DEDENT> if self . config_channels_received . is_set ( ) : <NEWLINE> <INDENT> self . update_sensors ( ) <NEWLINE> <DEDENT> <DEDENT>
def c_code_cache_version ( self ) : <NEWLINE> <INDENT> version = [ ] <NEWLINE> for t , ( c , v ) in sorted ( iteritems ( self . c_code_and_version ) , <NEWLINE> <INDENT> key = lambda pair : str ( pair [ 0 ] ) ) : <NEWLINE> if not v : <NEWLINE> warnings . warn ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> % t , <NEWLINE> stacklevel = 2 ) <NEWLINE> return ( ) <NEWLINE> version . append ( ( str ( t ) , v ) ) <NEWLINE> <DEDENT> return tuple ( version ) <NEWLINE> <DEDENT>
def load_tests ( loader , tests , ignore ) : <NEWLINE> <INDENT> tests . addTests ( doctest . DocTestSuite ( cloudtracker ) ) <NEWLINE> <INDENT> return tests <NEWLINE> <DEDENT> <DEDENT>
def packRequest_pty_req ( term , ( rows , cols , xpixel , ypixel ) , modes ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> termPacked = common . NS ( term ) <NEWLINE> winSizePacked = struct . pack ( <STRING> , cols , rows , xpixel , ypixel ) <NEWLINE> modesPacked = common . NS ( modes ) <NEWLINE> return termPacked + winSizePacked + modesPacked <NEWLINE> <DEDENT>
def _irfft_wrapper ( ifft_fn , fft_rank , default_name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def _irfft ( input_tensor , fft_length = None , name = None ) : <NEWLINE> <INDENT> with _ops . name_scope ( name , default_name , <NEWLINE> <INDENT> [ input_tensor , fft_length ] ) as name : <NEWLINE> input_tensor = _ops . convert_to_tensor ( input_tensor , _dtypes . complex64 ) <NEWLINE> if fft_length is None : <NEWLINE> fft_length = _infer_fft_length_for_irfft ( input_tensor , fft_rank ) <NEWLINE> else : <NEWLINE> fft_length = _ops . convert_to_tensor ( fft_length , _dtypes . int32 ) <NEWLINE> return ifft_fn ( input_tensor , fft_length , name ) <NEWLINE> <DEDENT> <DEDENT> _irfft . __doc__ = ifft_fn . __doc__ <NEWLINE> return _irfft <NEWLINE> <DEDENT>
def checkparam1_retained ( self ) : <NEWLINE> <INDENT> if hasattr ( self , <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> , self . param1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if hasattr ( interpreter , <STRING> ) : <NEWLINE> print ( <STRING> , self is interpreter . this ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import gi <NEWLINE> from gi . repository import Gtk , GdkPixbuf , Gdk , GObject , Gio , GdkX11 <NEWLINE> try : <NEWLINE> <INDENT> import os <NEWLINE> import commands <NEWLINE> import sys <NEWLINE> import string <NEWLINE> import gettext <NEWLINE> import apt_pkg <NEWLINE> from subprocess import Popen <NEWLINE> import tempfile <NEWLINE> import locale <NEWLINE> <DEDENT> except Exception , detail : <NEWLINE> <INDENT> print ( detail ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> APP = <STRING> <NEWLINE> LOCALE_DIR = <STRING> <NEWLINE> locale . bindtextdomain ( APP , LOCALE_DIR ) <NEWLINE> gettext . bindtextdomain ( APP , LOCALE_DIR ) <NEWLINE> gettext . textdomain ( APP ) <NEWLINE> _ = gettext . gettext <NEWLINE>
def test_unexpected_kw_arg ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> msgs = [ <NEWLINE> <INDENT> ( <STRING> , <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> <DEDENT> ( <STRING> , <NEWLINE> <INDENT> ( <STRING> , <STRING> ) ) , <NEWLINE> <DEDENT> <DEDENT> ] <NEWLINE> for msg , groups in msgs : <NEWLINE> <INDENT> func , kw_arg = groups <NEWLINE> named_groups = { <STRING> : kw_arg , <STRING> : func } <NEWLINE> results = ( groups , named_groups ) <NEWLINE> self . re_matches ( msg , re . UNEXPECTED_KEYWORDARG_RE , results ) <NEWLINE> <DEDENT> <DEDENT>
def crawl_imdb_title ( settings , db , requests_session , imdb_id , public_domain = 0 , replace_existing = False ) : <NEWLINE> <INDENT> imdb_id = int ( imdb_id ) <NEWLINE> dbc = db . execute ( <STRING> , { <NEWLINE> <STRING> : imdb_id <NEWLINE> <DEDENT>
from __future__ import division <NEWLINE> from sympy import * i <NEWLINE> import itertools <NEWLINE>
def OnText ( self , event ) : <NEWLINE> <INDENT> id = self . number . GetValue ( ) <NEWLINE> if len ( id ) == 13 : <NEWLINE> self . OnTextEnter ( event ) <NEWLINE> <DEDENT>
def test_assess_metadata_valid_url ( self ) : <NEWLINE> <INDENT> with extended_bootstrap_cxt ( <STRING> ) : <NEWLINE> <INDENT> with patch ( <STRING> , autospec = True ) : <NEWLINE> <INDENT> args = parse_args ( [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> args . temp_env_name = <STRING> <NEWLINE> bs_manager = BootstrapManager . from_args ( args ) <NEWLINE> with patch . object ( <NEWLINE> <INDENT> bs_manager . client , <STRING> , <NEWLINE> return_value = { <STRING> : <NEWLINE> <INDENT> { <STRING> : <STRING> } } ) : <NEWLINE> with self . assertRaises ( JujuAssertionError ) : <NEWLINE> <DEDENT> assess_metadata ( bs_manager , None ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def __call__ ( self ) : <NEWLINE> <INDENT> from pybtex . exceptions import PybtexError <NEWLINE> import pybtex . io <NEWLINE> try : <NEWLINE> <INDENT> self . main ( ) <NEWLINE> <DEDENT> except PybtexError , error : <NEWLINE> <INDENT> errors . print_error ( error ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
def lineno ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not _state : <NEWLINE> <INDENT> raise RuntimeError , <STRING> <NEWLINE> <DEDENT> return _state . lineno ( ) <NEWLINE> <DEDENT>
def verify_created ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> LOGGER . info ( <STRING> <NEWLINE> <INDENT> % { <STRING> : datetime . datetime . now ( ) } ) <NEWLINE> <DEDENT> result = 0 <NEWLINE> for step in [ self . compare_checks , <NEWLINE> <INDENT> self . compare_alarms , <NEWLINE> self . checks_without_alarms , <NEWLINE> self . excluded_checks ] : <NEWLINE> step_result = step ( ) <NEWLINE> if step_result is not None : <NEWLINE> result += step_result <NEWLINE> <DEDENT> if result > 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> LOGGER . info ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def get_xclip_action_list ( self , xclip , full_action_list ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> result = None <NEWLINE> split_list = full_action_list . split ( <STRING> ) <NEWLINE> if xclip . is_playing : <NEWLINE> <INDENT> result = split_list [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( split_list ) == 2 : <NEWLINE> if split_list [ 1 ] . strip ( ) == <STRING> : <NEWLINE> <INDENT> result = split_list [ 0 ] <NEWLINE> else : <NEWLINE> result = split_list [ 1 ] <NEWLINE> <DEDENT> <DEDENT> if self . _is_debugging : <NEWLINE> <INDENT> self . log_message ( <STRING> + str ( result ) ) <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT>
<INDENT> print ( <STRING> ) , url ) <NEWLINE>
def GetClines ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> demedClines = [ ] <NEWLINE> demedClines . append ( self . __GetDemedCline ( ) ) <NEWLINE> demedClines = filter ( None , demedClines ) <NEWLINE> if len ( demedClines ) == 0 : print <STRING> <NEWLINE> return demedClines <NEWLINE> <DEDENT>
def test_shapes ( ) : <NEWLINE> <INDENT> for ip in [ KroghInterpolator , BarycentricInterpolator , pchip , <NEWLINE> <INDENT> Akima1DInterpolator ] : <NEWLINE> for s1 in SHAPES : <NEWLINE> for s2 in SHAPES : <NEWLINE> <INDENT> for axis in range ( - len ( s2 ) , len ( s2 ) ) : <NEWLINE> <INDENT> yield check_shape , ip , s1 , s2 , None , axis <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def generateRandomKey ( keysize ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if keysize not in ( 16 , 24 , 32 ) : <NEWLINE> <INDENT> emsg = <STRING> <NEWLINE> raise ValueError , emsg % keysize <NEWLINE> <DEDENT> return os . urandom ( keysize ) <NEWLINE> <DEDENT>
def emcCoolantMistOff ( self ) : <NEWLINE> <INDENT> if debug ( ) : print <STRING> <NEWLINE> self . hal [ <STRING> ] = 0 <NEWLINE> self . io . coolant . mist = 0 <NEWLINE> self . io . status = emctask . RCS_STATUS . RCS_DONE <NEWLINE> return 0 <NEWLINE> <DEDENT>
class MyHTMLParser ( HTMLParser ) : <NEWLINE> <INDENT> def handle_starttag ( self , tag , attrs ) : <NEWLINE> <INDENT> for attr in attrs : <NEWLINE> <DEDENT> boo . append ( attr [ 1 ] . split ( <STRING> ) [ 1 ] ) <NEWLINE> <DEDENT>
def GetDependencies ( self , required_namespaces ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if isinstance ( required_namespaces , str ) : <NEWLINE> <INDENT> required_namespaces = [ required_namespaces ] <NEWLINE> <DEDENT> deps_sources = [ ] <NEWLINE> for namespace in required_namespaces : <NEWLINE> <INDENT> for source in DepsTree . _ResolveDependencies ( <NEWLINE> <INDENT> namespace , [ ] , self . _provides_map , [ ] ) : <NEWLINE> if source not in deps_sources : <NEWLINE> deps_sources . append ( source ) <NEWLINE> <DEDENT> <DEDENT> return deps_sources <NEWLINE> <DEDENT>
def format_flags ( flags ) : <NEWLINE> <INDENT> names = [ ] <NEWLINE> for flag , name in [ ( PAI_CONTIGUOUS , <STRING> ) , <NEWLINE> <INDENT> ( PAI_FORTRAN , <STRING> ) , <NEWLINE> ( PAI_ALIGNED , <STRING> ) , <NEWLINE> ( PAI_NOTSWAPPED , <STRING> ) , <NEWLINE> ( PAI_WRITEABLE , <STRING> ) , <NEWLINE> ( PAI_ARR_HAS_DESCR , <STRING> ) ] : <NEWLINE> if flag & flags : <NEWLINE> names . append ( name ) <NEWLINE> <DEDENT> return <STRING> . join ( names ) <NEWLINE> <DEDENT>
def get_points_stored_ASCII ( self , i , j , k ) : <NEWLINE> <INDENT> commtxt = <STRING> <NEWLINE> commtxt = commtxt + str ( i ) <NEWLINE> commtxt = commtxt <STRING> + str ( j ) <NEWLINE> commtxt = commtxt <STRING> + str ( k ) <NEWLINE> result = self . ask ( commtxt ) <NEWLINE> return result <NEWLINE> <DEDENT>
def close_request ( self , request ) : <NEWLINE> <INDENT> if self . serverAdapter : <NEWLINE> <INDENT> self . serverAdapter . _clearClientObjects ( request . getpeername ( ) <NEWLINE> <DEDENT> SimpleXMLRPCServer . close_request ( self , request ) <NEWLINE> <DEDENT>
def size ( myStack ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> while ( not isinstance ( myStack , noneNode ) : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> myStack = myStack . next <NEWLINE> <DEDENT> <DEDENT>
import os <NEWLINE> import sys <NEWLINE> from ctk_cli import CLIArgumentParser <NEWLINE> sys . path . append ( os . path . join ( os . environ [ <STRING> ] , <NEWLINE> <INDENT> <STRING> ) ) <NEWLINE> <DEDENT> sys . path . append ( os . path . join ( os . environ [ <STRING> ] , <STRING> ) <NEWLINE> sys . path . append ( os . environ [ <STRING> ] , <STRING> ) <NEWLINE> import itk <NEWLINE> from itk import TubeTKITK as itktube <NEWLINE>
def host_passes ( self , host_state , filter_properties ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> instance_type = filter_properties . get ( <STRING> ) <NEWLINE> if not self . _satisfies_extra_specs ( host_state , <NEWLINE> <INDENT> instance_type ) : <NEWLINE> LOG . debug ( _ ( <STRING> <NEWLINE> <INDENT> <STRING> ) , { <STRING> : host_state } ) <NEWLINE> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT>
def getLdap ( uid , field ) : <NEWLINE> <INDENT> try : <NEWLINE> l = ldap . initialize ( <STRING> ) <NEWLINE> l . simple_bind_s ( ) <NEWLINE> result = l . search_s ( <STRING> , ldap . SCOPE_SUBTREE , <STRING> . format ( uid ) , attrlist = [ str ( field ) ] ) <NEWLINE> l . unbind ( ) <NEWLINE> if len ( result ) == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> return result [ 0 ] [ 1 ] . itervalues ( ) . next ( ) <NEWLINE> <DEDENT> except ldap . LDAPError , e : <NEWLINE> return <STRING> % e <NEWLINE> except Exception as e : <NEWLINE> print ( e ) <NEWLINE> <DEDENT>
def cleanup_address ( s , assume_capitol_zipcode = True ) : <NEWLINE> <INDENT> if re . match ( <STRING> , s ) : <NEWLINE> s = string . replace ( s , <STRING> , <STRING> , 1 ) <NEWLINE> if not assume_capitol_zipcode : <NEWLINE> return s <NEWLINE> elif re . match ( <STRING> , s ) and not re . match ( <STRING> , s ) : <NEWLINE> return string . replace ( s , <STRING> , <STRING> ) <NEWLINE> elif re . match ( <STRING> , s ) : <NEWLINE> return s <NEWLINE> else : <NEWLINE> return string . replace ( s , <STRING> , <STRING> ) <NEWLINE> <DEDENT>
def __init__ ( self ) : <NEWLINE> <INDENT> self . selectedPkgs = [ ] <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
def getUrlsForSearch ( self , searchid , limit = None ) : <NEWLINE> <INDENT> urls = [ ] <NEWLINE> try : <NEWLINE> <INDENT> if limit : <NEWLINE> <INDENT> urlsearch = UrlSearch . selectBy ( searchid = searchid ) . limit ( limit ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> urlsearch = UrlSearch . selectBy ( searchid = searchid ) <NEWLINE> <DEDENT> for u in urlsearch : <NEWLINE> try : <NEWLINE> <DEDENT> urls . append ( Url . get ( u . urlid ) ) <NEWLINE> except SQLObjectNotFound : <NEWLINE> raise DbError ( <STRING> % u . urlid ) <NEWLINE> <INDENT> return urls <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> raise DbError ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def valid ( self ) : <NEWLINE> <INDENT> if self . name is not None and self . backing_device is not None <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
def maplayer_attributes ( request , layername ) : <NEWLINE> <INDENT> layer = Layer . objects . get ( typename = layername ) <NEWLINE> return HttpResponse ( <NEWLINE> <INDENT> json . dumps ( <NEWLINE> <INDENT> layer . attribute_config ( ) , <NEWLINE> <DEDENT> content_type = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
( set ( _value ) - set ( rule . get ( <STRING> , [ ] ) ) != 0 : <NEWLINE> <INDENT> return False , ERROR_IN_CODE , ERROR_IN_MSG % <STRING> . join ( map ( str , rule . get ( <STRING> , [ ] ) ) ) <NEWLINE> <DEDENT> _callback = rule . get ( <STRING> ) <NEWLINE> if _callback and callable ( _callback ) : <NEWLINE> <INDENT> _status , _code , _msg = _callback ( _value ) <NEWLINE> if not _status : <NEWLINE> <INDENT> return False , _code , _msg <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from django . conf . urls . defaults import * <NEWLINE> import settings <NEWLINE> urlpatterns = patterns ( <STRING> , <NEWLINE> <INDENT> ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> ) <NEWLINE> if settings . DEBUG : <NEWLINE> <INDENT> urlpatterns += patterns ( <STRING> , ( <STRING> + settings . MEDIA_URL + <STRING> , <NEWLINE> <INDENT> <STRING> , { <STRING> : settings . MEDIA_ROOT } ) <NEWLINE> <DEDENT> <DEDENT>
def pavnosig ( power , nspec , nsim = 1.0e9 , verbose = False ) : <NEWLINE> <INDENT> if power * nspec > 30000 : <NEWLINE> if verbose : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return 0.0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fn = pavnosigfun ( power , nspec , nsim , verbose ) <NEWLINE> if verbose : <NEWLINE> <INDENT> print ( <STRING> % fn ) <NEWLINE> <DEDENT> return fn <NEWLINE> <DEDENT> <DEDENT>
( _translate ( <STRING> , <STRING> <NEWLINE> <DEDENT>
def invalidate ( self ) : <NEWLINE> <INDENT> for a in ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> if a in self . __dict__ : <NEWLINE> delattr ( self , a ) <NEWLINE> <DEDENT> self . _lastnormaltime = 0 <NEWLINE> self . _dirty = False <NEWLINE> <DEDENT>
import eventlet <NEWLINE> import logging <NEWLINE> def sentry_logger ( conf , name , log_to_console , log_route , fmt , logger , <NEWLINE> <INDENT> adapted_logger ) : <NEWLINE> sentry_dsn = conf . get ( <STRING> , None ) <NEWLINE> sentry_log_level = getattr ( logging , <NEWLINE> <INDENT> conf . get ( <STRING> , <NEWLINE> <INDENT> <STRING> ) . upper ( ) , <NEWLINE> <DEDENT> logging . ERROR ) <NEWLINE> if sentry_dsn : <NEWLINE> raven_logging = eventlet . import_patched ( <STRING> ) <NEWLINE> sentry = raven_logging . SentryHandler ( sentry_dsn ) <NEWLINE> sentry . setLevel ( sentry_log_level ) <NEWLINE> logger . addHandler ( sentry ) <NEWLINE> <DEDENT> <DEDENT>
def _prepare_leapin_solvatecap ( self , model ) : <NEWLINE> <INDENT> output = <STRING> <NEWLINE> for solvatecap in self . _solvatecaps : <NEWLINE> <INDENT> output += <STRING> . format ( <NEWLINE> <INDENT> model = solvatecap [ <STRING> ] , <NEWLINE> wat_model = solvatecap [ <STRING> ] , <NEWLINE> solcap_center = solvatecap [ <STRING> ] <NEWLINE> solcap_closeness = solvatecap [ <STRING> ] <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> return output <NEWLINE> <DEDENT>
def flatten ( aList ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> flatlist = [ ] <NEWLINE> for element in aList : <NEWLINE> <INDENT> if type ( element ) is list : <NEWLINE> <INDENT> flatlist . extend ( flatten ( element ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flatlist . append ( element ) <NEWLINE> <DEDENT> <DEDENT> return flatlist <NEWLINE> <DEDENT>
class NLG ( self ) : <NEWLINE> <INDENT> def acknowledge ( self ) : <NEWLINE> <INDENT> simple_acknoledgement = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <DEDENT> ] <NEWLINE> <INDENT> ret_phrase = random . choice ( simple_acknoledgement ) <NEWLINE> <DEDENT> return ret_phrase <NEWLINE> <DEDENT> <DEDENT>
class UptonUpdateNoNonceHandler ( webapp2 . RequestHandler ) : <NEWLINE> <INDENT> def get ( self ) : <NEWLINE> template = templates . GetTemplate ( <STRING> ) <NEWLINE> self . response . write ( template . render ( ) ) <NEWLINE> <DEDENT>
def __init__ ( self , which_pin , d = False ) : <NEWLINE> <INDENT> global ser <NEWLINE> <INDENT> self . _d = d <NEWLINE> self . _pin_no = which_pin <NEWLINE> <DEDENT> self . _dinput_value = False <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> languages = sorted ( [ s . split ( os . path . sep ) [ - 2 ] for s in glob . glob ( <STRING> ) ] ) <NEWLINE> for my_variants in ( [ ] , [ <STRING> ] , [ <STRING> ] , <NEWLINE> <INDENT> [ <STRING> , <STRING> ] , <NEWLINE> [ <STRING> ] , <NEWLINE> [ <STRING> , <STRING> ] ) : <NEWLINE> my_variants . sort ( ) <NEWLINE> for lang in languages : <NEWLINE> gen_templated_js ( lang , my_variants ) <NEWLINE> create_var_file ( my_variants , languages ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , defaulttracker = <STRING> ) : <NEWLINE> <INDENT> super ( TorrentMaker self ) . __init__ ( ) <NEWLINE> self . defaulttracker = defaulttracker <NEWLINE> <DEDENT>
def test_get_group_permissions ( self ) : <NEWLINE> <INDENT> group = Group . objects . create ( name = <STRING> ) <NEWLINE> self . user3 . groups . add ( group ) <NEWLINE> self . assertEqual ( self . user3 . get_group_permissions ( TestObj ( ) ) ) , set ( [ <STRING> ] ) ) <NEWLINE> <DEDENT>
def get_tgi_result ( command ) : <NEWLINE> <INDENT> myHeaders = { <STRING> : <STRING> } <NEWLINE> if options . debug : print <STRING> . format ( NETIO_URL , s_username , command ) <NEWLINE> try : <NEWLINE> <INDENT> r = requests . get ( NETIO_URL + <STRING> + s_username + <STRING> + s_password + <STRING> + command , headers = myHeaders ) <NEWLINE> return r . content . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> . format ( options . hostname ) ) <NEWLINE> exit ( 2 ) <NEWLINE> <DEDENT> <DEDENT>
def get_in_prompt ( self , continued = False ) : <NEWLINE> <INDENT> next_line_number = self . get_last_line_number ( ) + 1 <NEWLINE> if continued : <NEWLINE> <INDENT> return <STRING> * len ( <STRING> . format ( next_line_number ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> . format ( next_line_number , * self . incolors ) <NEWLINE> <DEDENT> <DEDENT>
class Command ( BaseCommand ) : <NEWLINE> <INDENT> help = <STRING> <NEWLINE> def handle ( self , * args , ** options ) : <NEWLINE> <INDENT> self . stdout . write ( <STRING> ) <NEWLINE> prob_entries = Entries . objects . all ( ) <NEWLINE> for entry in prob_entries : <NEWLINE> <DEDENT> entry . is_active = False <NEWLINE> entry . save ( ) <NEWLINE> <DEDENT>
def _parse_api_name ( self api_names ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> short_api_name = [ ] <NEWLINE> for api in api_names : <NEWLINE> <INDENT> if api . endswith ( <STRING> ) : <NEWLINE> <INDENT> short_api_name . append ( api [ 3 : - 3 ] ) <NEWLINE> <DEDENT> <DEDENT> short_api_name . sort ( ) <NEWLINE> return short_api_name <NEWLINE> <DEDENT>
def SetHideEscapeParam ( self , value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . HideEscapeChars = value <NEWLINE> Pattern = re . compile ( <STRING> ) <NEWLINE> Param = <STRING> + str ( value ) <NEWLINE> for line in fileinput . input ( CONFIG_FILENAME , inplace = 1 ) : <NEWLINE> <INDENT> line = Pattern . sub ( Param , line ) <NEWLINE> if <STRING> in line : <NEWLINE> line = line . replace ( <STRING> , <STRING> ) <NEWLINE> print ( line ) <NEWLINE> else : <NEWLINE> print ( line ) <NEWLINE> <DEDENT> fileinput . close ( ) <NEWLINE> <DEDENT>
def this_characteristic_nothere ( true_or_false , dict_defined , system , os_string , filter_name ) : <NEWLINE> <INDENT> counter = 0 <NEWLINE> if true_or_false : <NEWLINE> <INDENT> for os in dict_defined : <NEWLINE> <INDENT> if os . lower ( ) in os_string : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> <DEDENT> if counter == 0 : <NEWLINE> <INDENT> if debug : print <STRING> % ( system , filter_name ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT>
def r_phpbb3 ( mydata ) : <NEWLINE> <INDENT> results = re . search ( <STRING> , mydata , re . M | re . I ) <NEWLINE> if results : <NEWLINE> <INDENT> if args . quietmode : print results . group ( ) <NEWLINE> else : outputhandler . write ( str ( results . group ( ) . rstrip ( <STRING> ) ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def get_participants ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> log . debug ( <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> return instance ( ) . ordered_bus_names [ : ] <NEWLINE> <DEDENT> except IndexError , err : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> <DEDENT>
def definir_centro ( self , ( x , y ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . centro_x = x <NEWLINE> self . centro_y = y <NEWLINE> <DEDENT>
print ( <STRING> , Tabla , ) <NEWLINE> for j in range ( 1 , 13 ) : <NEWLINE> print ( <STRING> % ( Tabla , j , Tabla + j ) ) <NEWLINE>
def concat_pcr ( index_type ) : <NEWLINE> <INDENT> if re . match ( <STRING> , index_type ) or re . match ( <STRING> , index_type ) <NEWLINE> <INDENT> return <STRING> . join ( [ PCR_fwd_D5 , PCR_rev_D7 ] ) <NEWLINE> <DEDENT> elif re . match ( <STRING> , index_type ) : <NEWLINE> <INDENT> return <STRING> . join ( [ PCR_fwd_A5 , PCR_rev_A7 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT>
( <STRING> <NEWLINE> <DEDENT> <DEDENT>
def list_instance_notes ( self ) : <NEWLINE> <INDENT> instance_notes = [ ] <NEWLINE> for vs in self . _conn . Msvm_VirtualSystemSettingData ( <NEWLINE> <INDENT> [ <STRING> , <STRING> ] , <NEWLINE> VirtualSystemType = self . _VIRTUAL_SYSTEM_TYPE_REALIZED ) : <NEWLINE> if vs . Notes is not None : <NEWLINE> instance_notes . append ( <NEWLINE> <INDENT> ( vs . ElementName , [ v for v in vs . Notes if v ] ) ) <NEWLINE> <DEDENT> <DEDENT> return instance_notes <NEWLINE> <DEDENT>
def rescued_header ( self ) : <NEWLINE> <INDENT> return { <NEWLINE> <INDENT> <STRING> : self . rescue_tag , <NEWLINE> <STRING> : <STRING> , <NEWLINE> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> } <NEWLINE> <DEDENT> <DEDENT>
class WHTMLHeader ( WTemplated ) : <NEWLINE> <INDENT> def __init__ ( self tpl_name = None ) : <NEWLINE> <INDENT> WTemplated . __init__ ( self ) <NEWLINE> <DEDENT> <DEDENT>
class TextTag ( Tag ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __str__ ( self ) : <NEWLINE> <INDENT> if self . name in [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if self . name in [ <STRING> , <STRING> ] : <NEWLINE> return <STRING> <NEWLINE> data = decode_unicode ( self . innerHTML ( ) ) <NEWLINE> data = re . sub ( <STRING> , <STRING> , data ) <NEWLINE> data = re . sub ( <STRING> , <STRING> , data ) <NEWLINE> data = unquote ( data ) <NEWLINE> return data + <STRING> <NEWLINE> <DEDENT> <DEDENT>
def _accuracy_at_threshold ( labels , predictions , weights , threshold , name = None ) : <NEWLINE> <INDENT> with ops . name_scope ( <NEWLINE> <INDENT> name , <STRING> % threshold , <NEWLINE> ( predictions , labels , weights , threshold ) ) as scope : <NEWLINE> threshold_predictions = math_ops . to_float ( <NEWLINE> <INDENT> math_ops . greater_equal ( predictions , threshold ) ) <NEWLINE> return metrics_lib . accuracy ( <NEWLINE> labels = labels , predictions = threshold_predictions , weights = weights , <NEWLINE> name = scope ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class FeedURLField ( forms . URLField ) : <NEWLINE> <INDENT> def __init__ ( self , max_length = None , min_length = None , verify_exists = False , <NEWLINE> <INDENT> validator_user_agent = validators . URL_VALIDATOR_USER_AGENT , * args , ** kwargs ) : <NEWLINE> forms . CharField . __init__ ( self , max_length , min_length , * args , <NEWLINE> <INDENT> ** kwargs ) <NEWLINE> self . validators . append ( FeedURLValidator ( verify_exists = verify_exists , validator_user_agent = validator_user_agent ) ) <NEWLINE> <DEDENT> <DEDENT> def to_python ( self , value ) : <NEWLINE> <INDENT> value = super ( FeedURLField , self ) . to_python ( value ) <NEWLINE> return value . strip ( ) <NEWLINE> <DEDENT> <DEDENT>
def winner ( sprites , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for sq in [ ( 0 , 1 , 2 ) , ( 3 , 4 , 5 ) , ( 6 , 7 , 8 ) , ( 0 , 3 , 6 ) , <NEWLINE> <INDENT> ( 1 , 4 , 7 ) , ( 2 , 5 , 8 ) , ( 0 , 4 , 8 ) , ( 2 , 4 , 6 ) ] : <NEWLINE> if sum ( 1 for s in sq if sprites [ s ] . costumeNumber == n ) == 3 : <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT>
def find_sample ( reponse ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for stage in reponse . response_stages [ : : - 1 ] : <NEWLINE> <INDENT> if ( stage . decimation_input_sample_rate is not None and <NEWLINE> <INDENT> stage . decimation_factor is not None ) : <NEWLINE> sampling_rate = ( stage . decimation_input_sample_rate / <NEWLINE> <INDENT> stage . decimation_factor ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> msg = ( <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> raise Exception ( msg ) <NEWLINE> <DEDENT> return sampling_rate <NEWLINE> <DEDENT>
def should_nuke_file ( self , pretty , file , mgs ) : <NEWLINE> <INDENT> if self . libtool_file . match ( mgs ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if pretty == <STRING> : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if pretty . startswith ( <STRING> ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if ( pretty . startswith ( <STRING> ) or <NEWLINE> <INDENT> pretty . startswith ( <STRING> ) ) : <NEWLINE> if <STRING> not in pretty : <NEWLINE> return True <NEWLINE> if pretty . endswith ( <STRING> ) and os . path . islink ( file ) : <NEWLINE> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
def show_packer ( filename ) : <NEWLINE> <INDENT> peid = pecore . check_peid ( filename ) <NEWLINE> if peid != None : <NEWLINE> <INDENT> len_peid = len ( peid ) <NEWLINE> <INDENT> file2 = open ( <STRING> , <STRING> ) <NEWLINE> file2 . write ( <STRING> + str ( len_peid ) + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * 60 ) <NEWLINE> <INDENT> file2 . write ( <STRING> * 60 ) <NEWLINE> <DEDENT> for i in range ( 0 , len_peid ) : <NEWLINE> <INDENT> file2 . write ( <STRING> . ljust ( 18 ) + peid [ i ] [ 0 ] ) <NEWLINE> <INDENT> file2 . close ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
class altitudeMode ( enumeration ) : <NEWLINE> <INDENT> error = InvalidAltitudeMode <NEWLINE> valuelist = [ <NEWLINE> <STRING> , <STRING> , <STRING> <NEWLINE> <DEDENT>
def get_drum_rack_to_operate_on ( self , track ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> dr = None <NEWLINE> for device in track . devices : <NEWLINE> <INDENT> if device . can_have_drum_pads : <NEWLINE> dr = device <NEWLINE> break <NEWLINE> <DEDENT> if self . _is_debugging : <NEWLINE> <INDENT> debug_string = <STRING> <NEWLINE> if dr : <NEWLINE> debug_string = dr . name <NEWLINE> self . log_message ( <STRING> + str ( debug_string ) ) <NEWLINE> <DEDENT> return dr <NEWLINE> <DEDENT>
def test_stringify_files_creates_correct_body_content ( self ) : <NEWLINE> <INDENT> fake_file = Mock ( ) <NEWLINE> fake_file . read . return_value = <STRING> <NEWLINE> request = { <STRING> : { <STRING> : fake_file } , <NEWLINE> <INDENT> <STRING> : { <STRING> : <STRING> } } <NEWLINE> <DEDENT> with patch ( <STRING> , <NEWLINE> <INDENT> return_value = <STRING> ) : <NEWLINE> resp = bravado . fido_client . stringify_body ( request ) <NEWLINE> expected_contents = ( <NEWLINE> <STRING> + <NEWLINE> <STRING> ) <NEWLINE> self . assertEqual ( <STRING> , <NEWLINE> <INDENT> request [ <STRING> ] [ <STRING> ] ) <NEWLINE> self . assertEqual ( expected_contents , resp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class IAuthorizer ( Interface ) <NEWLINE> <INDENT> def getChallenge ( peer ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> def decode ( response ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> <DEDENT>
def SetBlock ( self , x , z , y , newType , newMeta ) <NEWLINE> <INDENT> offset = self . _GetOffset ( x , z , y ) <NEWLINE> self . _blocks [ offset ] = ( newType & 0xff ) <NEWLINE> return newType <NEWLINE> <DEDENT>
class Ufunc ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , nin , nout , identity , docstring , typereso , <NEWLINE> <INDENT> * type_descriptions ) : <NEWLINE> self . nin = nin <NEWLINE> self . nout = nout <NEWLINE> if identity is None : <NEWLINE> identity = None_ <NEWLINE> self . identity = identity <NEWLINE> self . docstring = docstring <NEWLINE> self . typereso = typereso <NEWLINE> self . type_descriptions = [ ] <NEWLINE> for td in type_descriptions : <NEWLINE> self . type_descriptions . extend ( td ) <NEWLINE> for td in self . type_descriptions : <NEWLINE> td . finish_signature ( self . nin , self . nout ) <NEWLINE> <DEDENT> <DEDENT>
def retranslateUi ( self , MetadataBulkDialog ) : <NEWLINE> <INDENT> MetadataBulkDialog . setWindowTitle ( _ ( <STRING> ) ) <NEWLINE> self . label_2 . setText ( _ ( <STRING> ) ) <NEWLINE> self . auto_author_sort . setToolTip ( _ ( <STRING> <NEWLINE> <DEDENT>
def _getresp ( self ) : <NEWLINE> <INDENT> resp , o = self . _getline ( ) <NEWLINE> if self . _debugging > 1 : <NEWLINE> <INDENT> print <STRING> , repr ( resp ) <NEWLINE> <DEDENT> c = resp [ : 1 ] <NEWLINE> if c != <STRING> : <NEWLINE> <INDENT> raise error_proto ( resp ) <NEWLINE> <DEDENT> return resp <NEWLINE> <DEDENT>
def includeme ( config ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> settings = config . get_settings ( ) <NEWLINE> config . include ( <STRING> ) <NEWLINE> session_factory = get_session_factory ( get_engine ( settings ) <NEWLINE> config . registry [ <STRING> ] = session_factory <NEWLINE> config . add_request_method ( <NEWLINE> <INDENT> lambda r : get_tm_session ( session_factory , r . tm ) , <NEWLINE> <STRING> , <NEWLINE> reify = True <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
from distutils . core import setup <NEWLINE> import py2exe <NEWLINE> setup ( windows = [ <STRING> ] ) <NEWLINE> data_files = [ <STRING> ] <NEWLINE> options = { <STRING> : { <NEWLINE> <STRING> : 2 , <NEWLINE> <STRING> : 2 , <NEWLINE>
import os , stat , errno <NEWLINE> try : <NEWLINE> <INDENT> import _find_fuse_parts <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> import fuse <NEWLINE> from fuse import Fuse <NEWLINE> from sinastorage . bucket import SCSBucket <NEWLINE> import sinastorage <NEWLINE> import datetime <NEWLINE> import calendar <NEWLINE> import tempfile <NEWLINE> if not hasattr ( fuse , <STRING> ) : <NEWLINE> <INDENT> raise RuntimeError , <STRING> <NEWLINE> <DEDENT> fuse . fuse_python_api = ( 0 , 2 ) <NEWLINE> scs_accesskey = <STRING> <NEWLINE> scs_secretkey = <STRING> <NEWLINE> scs_bucket = <STRING> <NEWLINE> sinastorage . setDefaultAppInfo ( scs_accesskey , scs_secretkey ) <NEWLINE> s = SCSBucket ( scs_bucket , secure = False ) <NEWLINE>
def machine_leaves ( ) : <NEWLINE> <INDENT> for x in machines . keys ( ) : <NEWLINE> if x not in current : <NEWLINE> <INDENT> string = <STRING> % ( x , machines [ x ] ) <NEWLINE> logger . info ( string ) <NEWLINE> event_triggerer ( <STRING> , x , machines [ x ] ) <NEWLINE> del machines [ x ] <NEWLINE> <DEDENT> <DEDENT>
def as_sql ( self , connection , lookup , template_params , * args ) : <NEWLINE> <INDENT> if lookup . lhs . output_field . geography and not self . geography : <NEWLINE> <INDENT> raise ValueError ( <STRING> <NEWLINE> <INDENT> <STRING> % ( self . func or self . op , ) ) ) <NEWLINE> <DEDENT> <DEDENT> template_params = self . check_raster ( lookup , template_params ) <NEWLINE> return super ( ) . as_sql ( connection , lookup , template_params , * args ) <NEWLINE> <DEDENT>
def testingDecorators ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> nonNegative ( 3 , 6 , - 2 , 5 ) <NEWLINE> <DEDENT> except LessThanZero : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> setA = set ( allCaps ( <STRING> , <STRING> , <STRING> ) ) <NEWLINE> setB = set ( <STRING> , <STRING> , <STRING> ) <NEWLINE> <INDENT> if ( setA == setB ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class StatReloaderLoop ( ReloaderLoop ) : <NEWLINE> <INDENT> name = <STRING> <NEWLINE> def run ( self ) : <NEWLINE> <INDENT> mtimes = { } <NEWLINE> while 1 : <NEWLINE> <INDENT> for filename in chain ( _iter_module_files ( ) , <NEWLINE> <INDENT> self . extra_files ) : <NEWLINE> try : <NEWLINE> mtime = os . stat ( filename ) . st_mtime <NEWLINE> except OSError : <NEWLINE> continue <NEWLINE> old_time = mtimes . get ( filename ) <NEWLINE> if old_time is None : <NEWLINE> mtimes [ filename ] = mtime <NEWLINE> continue <NEWLINE> elif mtime > old_time : <NEWLINE> self . trigger_reload ( filename ) <NEWLINE> <DEDENT> self . _sleep ( self . interval ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def read_INI_file ( ini_file , default_params ) : <NEWLINE> <INDENT> params = default_params <NEWLINE> try : <NEWLINE> <INDENT> input = open ( ini_file ) <NEWLINE> for line in input : <NEWLINE> <INDENT> match = re . match ( <STRING> , line ) <NEWLINE> if not match : continue <NEWLINE> keyword = match . group ( 1 ) <NEWLINE> value = match . group ( 2 ) <NEWLINE> if keyword == <STRING> : <NEWLINE> <INDENT> params [ <STRING> ] = safe_int ( value , 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except IOError , e : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> return params <NEWLINE> <DEDENT>
def nesting_order ( ( point , is_start , payload ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return point , is_start , ( payload . sort_order if is_start else <NEWLINE> <INDENT> - payload . sort_order ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> global Alive <NEWLINE> Alive = 1 <NEWLINE> thread . start_new_thread ( webshow , ( ) ) <NEWLINE> sleep ( 0.5 ) <NEWLINE> thread . start_new_thread ( gettext , ( ) ) <NEWLINE> while Alive : <NEWLINE> sleep ( 0.2 ) <NEWLINE> <INDENT> clip_id = os . popen ( <STRING> ) <NEWLINE> pid = clip_id . readline ( ) . strip ( <STRING> ) <NEWLINE> if int ( pid ) >= 1 : <NEWLINE> <INDENT> os . system ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def show_help ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> from denim . environment import get_environments <NEWLINE> import denim <NEWLINE> print ( <STRING> % { <NEWLINE> <INDENT> <STRING> : <STRING> . join ( get_environments ( ) ) , <NEWLINE> <STRING> : denim . __version__ , <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>
def residual ( self , level ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> lhs = np . dot ( ( self . grids [ level ] . T - self . grids [ level ] . S ) , self . grids [ level ] . phi ) <NEWLINE> r = self . grids [ level ] . q - lhs <NEWLINE> self . grids [ level + 1 ] . q = copy . deepcopy ( self . restrict ( r ) ) <NEWLINE> <DEDENT> <DEDENT>
def _test_SUNW_ldynsym_section_generic ( self , testfile , reference_data ) : <NEWLINE> <INDENT> with open ( os . path . join ( <STRING> , <STRING> , <NEWLINE> <INDENT> testfile ) , <STRING> ) as f : <NEWLINE> elf = ELFFile ( f ) <NEWLINE> ldynsym_section = elf . get_section_by_name ( <STRING> ) <NEWLINE> self . assertIsNotNone ( ldynsym_section ) <NEWLINE> for symbol , ref_symbol_name in zip ( <NEWLINE> ldynsym_section . iter_symbols ( ) , reference_data ) : <NEWLINE> self . assertEqual ( symbol . name , ref_symbol_name ) <NEWLINE> <DEDENT> <DEDENT>
def make_new_dir ( name_str ) : <NEWLINE> <INDENT> file_list = os . listdir ( ) <NEWLINE> for file_str in file_list : <NEWLINE> <INDENT> if file_str == name_str : <NEWLINE> <INDENT> if os . path . isdir ( file_str ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if find_dir ( name_str ) == 0 : <NEWLINE> else : <NEWLINE> <INDENT> os . mkdir ( os . path . normpath ( name_str ) ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT>
def do_start ( self ) : <NEWLINE> <INDENT> print ( Options . options ) <NEWLINE> try : <NEWLINE> Options . options . dband <NEWLINE> except AttributeError : <NEWLINE> raise ValueError ( <STRING> ) <NEWLINE> self . taskinfo = Queue ( ) <NEWLINE> old_start ( self ) <NEWLINE> process_colors ( self ) <NEWLINE> <DEDENT>
def create_zip_file ( source_dir , outfile ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> with zipfile . ZipFile ( outfile , <STRING> , <NEWLINE> <INDENT> compression = zipfile . ZIP_DEFLATED ) as z : <NEWLINE> for root , _ , filenames in os . walk ( source_dir ) : <NEWLINE> for filename in filenames : <NEWLINE> full_name = os . path . join ( root , filename ) <NEWLINE> archive_name = os . path . relpath ( full_name , source_dir ) <NEWLINE> z . write ( full_name , archive_name ) <NEWLINE> <DEDENT> <DEDENT>
def cml2_add_default_caps ( config ) : <NEWLINE> <INDENT> for c in config . containers : <NEWLINE> create_default_capabilities ( c ) <NEWLINE> <DEDENT>
def quads ( self , ( s , p , o ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for graph in self . graphs : <NEWLINE> <INDENT> for s1 , p1 , o1 in graph . triples ( ( s , p , o ) ) : <NEWLINE> <INDENT> yield ( s1 , p1 , o1 , graph ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def __init__ ( self , region ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> super ( AwsPlacementGroup , self ) . __init__ ( ) <NEWLINE> self . name = ( <NEWLINE> <INDENT> <STRING> % ( FLAGS . run_uri , str ( uuid . uuid4 ( ) [ - 12 : ] ) ) <NEWLINE> <DEDENT> self . region = region <NEWLINE> <DEDENT>
class mav_Command ( Command ) : <NEWLINE> <INDENT> def create_from ( self , argarray , execLib ) : <NEWLINE> self . lib = execLib <NEWLINE> <INDENT> self . v0 = argarray [ 0 ] <NEWLINE> self . v1 = argarray [ 1 ] <NEWLINE> return <NEWLINE> <DEDENT> def execute ( self ) : <NEWLINE> <INDENT> self . lib . lib_mav ( self . v0 , self . v1 ) <NEWLINE> return <NEWLINE> <DEDENT> def toCommands ( self ) : <NEWLINE> <INDENT> out = <STRING> <NEWLINE> out += <STRING> + str ( self . v0 ) + <STRING> + str ( self . v1 ) + <STRING> <NEWLINE> return out <NEWLINE> <DEDENT> <DEDENT>
def test_clean_not_exists ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for main , args in [ <NEWLINE> <INDENT> ( tools_main , [ <STRING> , <STRING> , <STRING> , <STRING> ] ) , <NEWLINE> ( cache_main , [ <STRING> , <STRING> , <STRING> ] ) , <NEWLINE> ] : <NEWLINE> with self . subTest ( main = main , args = args ) : <NEWLINE> with logging_reduced ( <STRING> ) : <NEWLINE> <INDENT> self . _system ( main , args ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_cookie_string ( cls , url , user_agent = None , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> tokens , user_agent = cls . get_tokens ( url , user_agent = user_agent ) <NEWLINE> return <STRING> . join ( <STRING> . join ( pair ) for pair in tokens . items ( ) , user_agent <NEWLINE> <DEDENT>
def rosterBoxChange ( self , event ) : <NEWLINE> <INDENT> entry = self . box . getSelectedItem ( ) <NEWLINE> <INDENT> if isinstance ( entry , jmri . jmrit . roster . RosterEntry ) : <NEWLINE> theDccAddress = entry . getDccAddress ( ) <NEWLINE> self . address . text = theDccAddress <NEWLINE> else : <NEWLINE> <INDENT> self . address . text = <STRING> <NEWLINE> theDccAddress = 3 <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <DEDENT>
def test_output_dtype_correct ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> inp_dtype_tuple = input_dtypes [ functions [ self . func ] ] <NEWLINE> output_dtype_tuple = output_dtypes [ functions [ self . func ] ] <NEWLINE> for input_dtype , output_dtype in zip ( inp_dtype_tuple [ 0 ] , <NEWLINE> <INDENT> output_dtype_tuple ) : <NEWLINE> for test_shape , s , kwargs in self . test_data : <NEWLINE> s = None <NEWLINE> FFTW_object = self . validate_pyfftw_object ( inp_dtype_tuple [ 1 ] , <NEWLINE> test_shape , input_dtype , s , kwargs ) <NEWLINE> self . assertTrue ( <NEWLINE> FFTW_object . output_array . dtype . char == <NEWLINE> np . dtype ( output_dtype ) . char ) <NEWLINE> <DEDENT> <DEDENT>
def verify_rtslib ( ) : <NEWLINE> <INDENT> for member in [ <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> ] : <NEWLINE> if not hasattr ( rtslib_fb , member ) : <NEWLINE> raise RtstoolImportError ( _ ( <STRING> <NEWLINE> <INDENT> <STRING> ) % <NEWLINE> member ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def test_report_state ( self ) : <NEWLINE> <INDENT> with mock . patch . object ( self . agent . state_rpc , <NEWLINE> <INDENT> <STRING> ) as report_st : <NEWLINE> self . agent . _report_state ( ) <NEWLINE> report_st . assert_called_with ( self . agent . context , <NEWLINE> <INDENT> self . agent . agent_state ) <NEWLINE> self . assertNotIn ( <STRING> , self . agent . agent_state ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def load_variables ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( not os . environ . get ( <STRING> ) or <NEWLINE> <INDENT> not os . environ . get ( <STRING> ) or <NEWLINE> not os . environ . get ( <STRING> ) ) : <NEWLINE> print ( <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> sys . exit ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> global token <NEWLINE> global user <NEWLINE> global base_url <NEWLINE> token = os . environ [ <STRING> ] <NEWLINE> user = os . environ [ <STRING> ] <NEWLINE> base_url = ( <STRING> + os . environ [ <STRING> ] + <STRING> <NEWLINE> <INDENT> <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class SecureSession ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> json ( ) <NEWLINE> <INDENT> base64 . b64encode ( hmac . new ( tob ( key ) , msg ) . digest ( ) ) ) : <NEWLINE> <INDENT> return pickle . loads ( base64 . b64decode ( msg ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_objects_data ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> filtered_objects = [ item for item in self . objects <NEWLINE> <INDENT> if ( not self . is_subdir ( item ) and <NEWLINE> <INDENT> not self . is_placeholder ( item ) ] <NEWLINE> <DEDENT> <DEDENT> return filtered_objects <NEWLINE> <DEDENT>
import os <NEWLINE> import argparse <NEWLINE> import boto . iam <NEWLINE> import boto . ec2 <NEWLINE> import boto . ec2 . elb <NEWLINE> import boto . cloudformation <NEWLINE> import boto . utils <NEWLINE> import boto . rds2 <NEWLINE> import json <NEWLINE> import base64 <NEWLINE> import yaml <NEWLINE> import requests <NEWLINE> import hashlib <NEWLINE> from requests . auth import HTTPBasicAuth <NEWLINE> from pprint import pprint <NEWLINE> import string <NEWLINE> BASE_LIST = string . digits + string . letters <NEWLINE> BASE_DICT = dict ( ( c , i ) for i , c in enumerate ( BASE_LIST ) <NEWLINE>
def get ( self , workflow_id , email_id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . workflow_id = workflow_id <NEWLINE> self . email_id = email_id <NEWLINE> return self . _mc_client . _get ( url = self . _build_path ( workflow_id , <STRING> , email_id ) <NEWLINE> <DEDENT>
class Command ( BaseCommand ) : <NEWLINE> <INDENT> help = <STRING> <NEWLINE> def create_user ( <NEWLINE> <INDENT> self , name , username , password ) : <NEWLINE> new_user = ( <NEWLINE> self . User . objects . create_superuser ( <NEWLINE> <INDENT> username , password ) ) <NEWLINE> try : <NEWLINE> <DEDENT> Profile . objects . create ( <NEWLINE> <INDENT> user = new_user , <NEWLINE> name = name , <NEWLINE> slug = slugify ( name ) ) <NEWLINE> except Exception as e : <NEWLINE> <DEDENT> raise CommandError ( <NEWLINE> <INDENT> <STRING> <NEWLINE> . format ( <STRING> . join ( e . messages ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class Application ( tornado . web . Application ) : <NEWLINE> <INDENT> def __init__ ( self , handlers = None , default_host = <STRING> , transforms = None , <NEWLINE> <INDENT> ** configs ) : <NEWLINE> if handlers is None : <NEWLINE> handlers = pages <NEWLINE> if not configs : <NEWLINE> configs = config <NEWLINE> tornado . web . Application . __init__ ( self , handlers , default_host , <NEWLINE> <INDENT> transforms , ** configs ) <NEWLINE> self . db = engine . connect ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def __repr__ ( self ) : <NEWLINE> <INDENT> rtlst = [ ] <NEWLINE> for net , msk , gw , iface , addr in self . routes : <NEWLINE> rtlst . append ( ( ltoa ( net ) , <NEWLINE> <INDENT> ltoa ( msk ) , <NEWLINE> gw , <NEWLINE> ( iface . name if not isinstance ( iface , basestring ) else iface ) , <NEWLINE> addr ) ) <NEWLINE> <DEDENT> return pretty_routes ( rtlst , <NEWLINE> <INDENT> [ ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) ] ) <NEWLINE> <DEDENT> <DEDENT>
def someFunctionWithUnqualifiedExecAndCallback ( ) : <NEWLINE> <INDENT> exec <STRING> <NEWLINE> def callback ( ) : <NEWLINE> <INDENT> return nested <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( user_url ) : <NEWLINE> <INDENT> super ( User , self ) __init_ ( ) <NEWLINE> self . user = user_url <NEWLINE> <DEDENT>
class BatchTransformAlgorithmSetSid ( TradingAlgorithm ) : <NEWLINE> <INDENT> def initialize ( self , sids = None ) : <NEWLINE> <INDENT> self . history = [ ] <NEWLINE> self . batch_transform = return_price ( <NEWLINE> <INDENT> refresh_period = 1 , <NEWLINE> window_length = 10 , <NEWLINE> clean_nans = False , <NEWLINE> sids = sids , <NEWLINE> compute_only_full = False <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> def handle_data ( self , data ) : <NEWLINE> <INDENT> self . history . append ( <NEWLINE> <INDENT> deepcopy ( self . batch_transform . handle_data ( data ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def getExceptionCheckProfile ( self , detachThread , methodReturn = <STRING> ) : <NEWLINE> <INDENT> if configGiws ( ) . getThrowsException ( ) : <NEWLINE> <INDENT> str = <STRING> <NEWLINE> <INDENT> if methodReturn != <STRING> : <NEWLINE> <INDENT> str += <STRING> % ( methodReturn ) <NEWLINE> <DEDENT> str += <STRING> % ( detachThread , configGiws ( ) . getExceptionFileName ( ) ) <NEWLINE> return str <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT>
def addListener ( self , listener , iface = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( isinstance ( listener , ILinkActivatedListener ) and <NEWLINE> <INDENT> ( iface is None or issubclass ( iface , ILinkActivatedListener ) ) ) : <NEWLINE> self . _listeners . add ( listener ) <NEWLINE> super ( ActiveLink , self ) . registerListener ( LinkActivatedEvent , <NEWLINE> <INDENT> listener , _LINK_FOLLOWED_METHOD ) <NEWLINE> if len ( self . _listeners ) == 1 : <NEWLINE> <DEDENT> self . requestRepaint ( ) <NEWLINE> <DEDENT> super ( ActiveLink , self ) . addListener ( listener , iface ) <NEWLINE> <DEDENT>
def decodeData ( self , data ) : <NEWLINE> <INDENT> self . log . debug ( <STRING> ) <NEWLINE> d = subprocess . Popen ( [ <STRING> , <STRING> , <STRING> ] , stdin = subprocess . PIPE , stdout = subprocess . PIPE , stderr = subprocess . PIPE , shell = False ) <NEWLINE> if d is not None : <NEWLINE> r = d . communicate ( data ) <NEWLINE> d . wait ( ) <NEWLINE> return r [ 0 ] <NEWLINE> <DEDENT>
def test_with_short_args ( self ) : <NEWLINE> <INDENT> with self . _args_test ( [ 0 , 1 , 2 ] , [ 0 , 1 ] , <NEWLINE> <INDENT> i = [ 0 , 1 , 2 ] , i2 = [ 0 , 1 , 4 ] ) as dummy : <NEWLINE> for i in range ( 2 ) : <NEWLINE> dummy . do_step ( 1 , i , i * i , i = i , i2 = i * i ) <NEWLINE> <DEDENT> <DEDENT>
def get_counts ( fn_in , gtf , out ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if fn_in . endswith ( <STRING> ) or fn_in . endswith ( <STRING> ) : <NEWLINE> <INDENT> cmd = <STRING> <NEWLINE> <DEDENT> elif fn_in . startswith ( <STRING> ) : <NEWLINE> <INDENT> cmd = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> raise ValueError ( <STRING> % fn_in ) <NEWLINE> logger . info ( cmd . format ( ** locals ( ) ) ) <NEWLINE> if not os . path . exists ( out ) : <NEWLINE> <INDENT> do . run ( cmd . format ( ** locals ( ) ) , log_stdout = True ) <NEWLINE> <DEDENT> return out <NEWLINE> <DEDENT>
def test_database_outage ( self , mock_lms_request ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . fake_lms_response . status_code = status . HTTP_200_OK <NEWLINE> mock_lms_request . return_value = self . fake_lms_response <NEWLINE> self . _assert_health ( <NEWLINE> <INDENT> status . HTTP_503_SERVICE_UNAVAILABLE , <NEWLINE> Status . UNAVAILABLE , <NEWLINE> Status . UNAVAILABLE , <NEWLINE> , <NEWLINE> Status . OK <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> provider = AtramhasisProvider ( { <STRING> : <STRING> } , base_url = <STRING> , scheme_id = <STRING> ) <NEWLINE> keyword = <STRING> <NEWLINE> results = provider . find ( <NEWLINE> { <NEWLINE> <INDENT> <STRING> : keyword , <NEWLINE> <STRING> : <STRING> <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>
class METHOD ( CIMElement ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , name , parameters = [ ] , return_type = None , <NEWLINE> <INDENT> class_origin = None , propagated = None , qualifiers = [ ] ) : <NEWLINE> Element . __init__ ( self , <STRING> ) <NEWLINE> self . setName ( name ) <NEWLINE> self . setOptionalAttribute ( <STRING> , return_type ) <NEWLINE> self . setOptionalAttribute ( <STRING> , class_origin ) <NEWLINE> if propagated is not None : <NEWLINE> self . setAttribute ( <STRING> , str ( propagated ) . lower ( ) ) <NEWLINE> self . appendChildren ( qualifiers + parameters ) <NEWLINE> <DEDENT> <DEDENT>
def set ( self , property , value ) : <NEWLINE> <INDENT> cmd = <STRING> + property + <STRING> + str ( value ) + <STRING> <NEWLINE> print ( cmd ) <NEWLINE> exec cmd <NEWLINE> <DEDENT>
def _get_entry ( self , request ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> url = request . get_full_url ( ) <NEWLINE> try : <NEWLINE> <INDENT> with contextlib . closing ( self . db . cursor ( ) ) as c : <NEWLINE> <INDENT> for row in c . execute ( <STRING> , <NEWLINE> <INDENT> ( url , ) ) : <NEWLINE> if row . matches_request ( request ) : <NEWLINE> return row <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except sqlite3 . Error as e : <NEWLINE> <INDENT> self . _die ( <STRING> , e ) <NEWLINE> <DEDENT> return None <NEWLINE> <DEDENT>
def OnSave ( self , event ) : <NEWLINE> <INDENT> file_choices = <STRING> <NEWLINE> <INDENT> dlg = wx . FileDialog ( <NEWLINE> self , <NEWLINE> message = <STRING> , <NEWLINE> <INDENT> defaultDir = os . getcwd ( ) , <NEWLINE> defaultFile = <STRING> , <NEWLINE> wildcard = file_choices , <NEWLINE> style = wx . SAVE ) <NEWLINE> <DEDENT> if dlg . ShowModal ( ) == wx . ID_OK : <NEWLINE> <INDENT> path = dlg . GetPath ( ) <NEWLINE> self . canvas . print_figure ( path , dpi = self . dpi ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def _trovePreparingChroot ( self , ( jobId , troveTuple ) , host , path ) : <NEWLINE> <INDENT> if not self . _watchTrove ( jobId , troveTuple ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if host == <STRING> : <NEWLINE> <INDENT> msg = <STRING> % path <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> msg = <STRING> % ( host , path ) <NEWLINE> <DEDENT> self . _msg ( <STRING> % ( jobId , troveTuple [ 0 ] , msg ) ) <NEWLINE> <DEDENT>
def test_wrappers ( self ) : <NEWLINE> <INDENT> self . o . ind = 4 <NEWLINE> self . n . ind = 5 <NEWLINE> self . assertEqual ( 6 . __index__ ( ) , 6 ) <NEWLINE> self . assertEqual ( - 7 L . __index__ ( ) , - 7 ) <NEWLINE> self . assertEqual ( self . o . __index__ ( ) , 4 ) <NEWLINE> self . assertEqual ( self . n . __index__ ( ) , 5 ) <NEWLINE> <DEDENT>
def _read ( self , input ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> out = <STRING> <NEWLINE> try : <NEWLINE> <INDENT> out = os . read ( input , 0x400 ) <NEWLINE> if self . verbose and str ( out ) . strip ( ) : <NEWLINE> <INDENT> print ( <STRING> , out . strip ( ) ) <NEWLINE> <DEDENT> <DEDENT> except Exception , e : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> return out <NEWLINE> <DEDENT>
def getResult ( endpoint , parameters = None ) : <NEWLINE> <INDENT> if parameters : <NEWLINE> <INDENT> parameter_string = urllib . urlencode ( parameters ) <NEWLINE> path = <STRING> . join ( [ endpoint + <STRING> , parameter_string ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> path = endpoint <NEWLINE> <DEDENT> endpoint_result = session . get ( urljoin ( baseurl , path ) ) <NEWLINE> if debug : print <STRING> + json . dumps ( endpoint_result . json ( ) , indent = 2 ) + <STRING> <NEWLINE> return endpoint_result . json ( ) <NEWLINE> <DEDENT>
def djpoi ( bot , trigger ) : <NEWLINE> <INDENT> x = requests . get ( <STRING> ) . json ( ) <NEWLINE> if not x [ <STRING> ] [ <STRING> ] : <NEWLINE> <INDENT> bot . say ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bot . say ( <STRING> . format ( x [ <STRING> ] [ <STRING> ] [ <STRING> ] , x [ <STRING> ] [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT>
self . mc = memcache . Client ( [ <STRING> ] ] ) <NEWLINE>
def makeDraggable ( self , draggable ) : <NEWLINE> <INDENT> if draggable instanceof HasDragHandle : <NEWLINE> <INDENT> makeDraggable ( draggable , ( ( HasDragHandle ) draggable ) . getDragHandle ( ) ) <NEWLINE> else : <NEWLINE> makeDraggable ( draggable , draggable ) <NEWLINE> <DEDENT> <DEDENT>
def validar ( request ) : <NEWLINE> <INDENT> if request . method == <STRING> : <NEWLINE> <INDENT> form = PessoaForm ( request . POST ) <NEWLINE> if form . is_valid ( ) : <NEWLINE> <INDENT> form . save ( ) <NEWLINE> pessoas = Pessoa . objects . all ( ) . order_by ( <STRING> ) <NEWLINE> return render ( request , <STRING> , { <STRING> : form , <STRING> : pessoas } ) <NEWLINE> <DEDENT> else : <NEWLINE> return render ( request , <STRING> , { <STRING> : form } ) <NEWLINE> <DEDENT> <DEDENT>
def agenda ( request ) : <NEWLINE> <INDENT> entry_list = Entry . objects . filter ( publish = True ) . order_by ( <STRING> ) <NEWLINE> context = { <NEWLINE> <INDENT> <STRING> entry_list <NEWLINE> <DEDENT> } <NEWLINE> return render ( request , <STRING> , context ) <NEWLINE> <DEDENT>
def _remove ( self , f ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> import send2trash <NEWLINE> logging . info ( <STRING> . format ( f ) ) ) <NEWLINE> send2trash . send2trash ( f ) <NEWLINE> <DEDENT> except ImportError : <NEWLINE> <INDENT> import os <NEWLINE> logging . warn ( <STRING> . format ( f ) ) <NEWLINE> os . remove ( f ) <NEWLINE> <DEDENT> <DEDENT>
def read ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ( data , address ) = self . socket . recvfrom ( 65535 ) <NEWLINE> <DEDENT> except socket . error , e : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . socket . close ( ) <NEWLINE> <DEDENT> except socket . error : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> self . feedback . closed ( e . args [ 0 ] ) <NEWLINE> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( data ) == 0 : <NEWLINE> <INDENT> self . feedback . closed ( ) <NEWLINE> return False <NEWLINE> <DEDENT> self . feedback . registerIncomingData ( data ) <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT>
<STRING> <NEWLINE> N , M = raw_input ( ) . split ( ) <NEWLINE> N , M = int ( N ) , int ( M ) <NEWLINE> while ( 1 ) : <NEWLINE> i0 = 0 <NEWLINE> while ( i0 < 2 ** ( M * N ) ) : <NEWLINE> <INDENT> bit = [ 0 ] * M * N <NEWLINE> t_bit = bin ( i0 ) <NEWLINE> lt_bit = len ( t_bit ) <NEWLINE> for j0 in range ( lt_bit - 2 ) : <NEWLINE> <INDENT> bit [ j0 ] = int ( t_bit [ j0 + 2 ] ) <NEWLINE> <DEDENT> i0 += 1 <NEWLINE> print ( bit ) <NEWLINE> <DEDENT> <STRING> <NEWLINE>
def set_page_size ( self , ( width , height ) ) : <NEWLINE> <INDENT> self . page_width = width <NEWLINE> self . page_height = height <NEWLINE> <DEDENT>
def test_execute_no_jobexit_stat ( self ) : <NEWLINE> <INDENT> orchestrator = mock . Mock ( ) <NEWLINE> command = post_exec . LsfPostExecCommand ( orchestrator = orchestrator ) <NEWLINE> parsed_arguments = mock . Mock ( ) <NEWLINE> exit_process = mock . Mock ( ) <NEWLINE> exit_process . side_effect = RuntimeError <NEWLINE> with mock . patch ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> new = exit_process ) : <NEWLINE> with self . assertRaises ( RuntimeError ) : <NEWLINE> command . _execute ( parsed_arguments ) <NEWLINE> <DEDENT> self . assertFalse ( orchestrator . create_token . called ) <NEWLINE> exit_process . assert_called_once_with ( exit_codes . EXECUTE_ERROR ) <NEWLINE> <DEDENT>
def Espera ( self ) : <NEWLINE> <INDENT> while not self . terminar : <NEWLINE> time . sleep ( 1 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> module = AnsibleModule ( <NEWLINE> <INDENT> argument_spec = dict ( <NEWLINE> <INDENT> domain = dict ( ) , <NEWLINE> default_root = dict ( ) , <NEWLINE> plugins = dict ( ) , <NEWLINE> cert_key_size = dict ( ) <NEWLINE> valid_min = dict ( ) , <NEWLINE> reuse_key = dict ( ) , <NEWLINE> account_key_public_exponent = dict ( ) <NEWLINE> account_key_size = dict ( ) , <NEWLINE> tos_SHA256 = dict ( ) , <NEWLINE> email = dict ( ) , <NEWLINE> user_agent = dict ( ) , <NEWLINE> server = dict ( ) , <NEWLINE> revoke = dict ( ) <NEWLINE> <DEDENT> ) <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT>
def testlibbind_ns_msg_count ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for message in self . queries + self . responses : <NEWLINE> <INDENT> msg = libbind . ns_msg ( message [ <STRING> ] ) <NEWLINE> for section in self . sections : <NEWLINE> sectionVal = getattr ( libbind , section ) <NEWLINE> self . assertEquals ( libbind . ns_msg_count ( msg , sectionVal ) , message [ <STRING> ] [ section ] ) <NEWLINE> <DEDENT> <DEDENT>
def test_lc_numeric_localeconv ( self ) : <NEWLINE> <INDENT> tested = False <NEWLINE> for loc in candidate_locales : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> setlocale ( LC_NUMERIC , loc ) <NEWLINE> setlocale ( LC_CTYPE , loc ) <NEWLINE> <DEDENT> except Error : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> formatting = localeconv ( ) <NEWLINE> for lc in ( <STRING> , <NEWLINE> <INDENT> <STRING> ) : <NEWLINE> if self . numeric_tester ( <STRING> , formatting [ lc ] , lc , loc ) : <NEWLINE> tested = True <NEWLINE> <DEDENT> <DEDENT> if not tested : <NEWLINE> <INDENT> self . skipTest ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def AddSourceToRegistry ( appName , msgDLL = None , eventLogType = <STRING> , eventLogFlags = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if msgDLL is None : <NEWLINE> <INDENT> msgDLL = win32evtlog . __file__ <NEWLINE> <DEDENT> hkey = win32api . RegCreateKey ( win32con . HKEY_LOCAL_MACHINE , <STRING> % ( eventLogType , appName ) ) <NEWLINE> win32api . RegSetValueEx ( hkey , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <DEDENT> if eventLogFlags is None : <NEWLINE> <INDENT> eventLogFlags = win32evtlog . EVENTLOG_ERROR_TYPE | win32evtlog . EVENTLOG_WARNING_TYPE | win32evtlog . EVENTLOG_INFORMATION_TYPE <NEWLINE> <DEDENT> win32api . RegSetValueEx ( hkey , <NEWLINE> win32api . RegCloseKey ( hkey ) <NEWLINE> <DEDENT>
( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT>
def correlation ( X , Y , condition = None , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return covariance ( X , Y , condition , ** kwargs ) / ( std ( X , condition , ** kwargs ) <NEWLINE> <INDENT> * std ( Y , condition , ** kwargs ) <NEWLINE> <DEDENT> <DEDENT>
def _is_secure ( self , request ) : <NEWLINE> <INDENT> if request . is_secure ( ) : <NEWLINE> return True <NEWLINE> if <STRING> in request . META : <NEWLINE> <INDENT> return request . META [ <STRING> ] == <STRING> <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT>
def _process_associate_metering_label ( self , router ) : <NEWLINE> <INDENT> self . _update_router ( router ) <NEWLINE> rm = self . routers . get ( router [ <STRING> ] ) <NEWLINE> ext_dev , ext_snat_dev = self . get_external_device_names ( rm ) <NEWLINE> for ( im , dev ) in [ ( rm . iptables_manager , ext_dev ) , <NEWLINE> <INDENT> ( rm . snat_iptables_manager , ext_snat_dev ) ] : <NEWLINE> if im : <NEWLINE> self . _process_ns_specific_metering_label ( router , dev , im ) <NEWLINE> <DEDENT> <DEDENT>
def local_ultra_fast_sigmoid ( node ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ( isinstance ( node . op , tensor . Elemwise ) and <NEWLINE> <INDENT> node . op . scalar_op == scalar_sigmoid ) : <NEWLINE> out = ultra_fast_sigmoid ( node . inputs [ 0 ] ) <NEWLINE> def values_eq_approx_remove_low_prec ( a , b ) : <NEWLINE> return tensor . TensorType . values_eq_approx ( a , b , atol = 0.02 ) <NEWLINE> out . values_eq_approx = values_eq_approx_remove_low_prec <NEWLINE> return [ out ] <NEWLINE> <DEDENT> <DEDENT>
def draw_arrow ( ax , t , r ) : <NEWLINE> <INDENT> ax . annotate ( <STRING> , xy = ( 0.5 , 0.5 + r ) , xytext = ( 0.5 , 0.5 ) , size = 30 , <NEWLINE> <INDENT> arrowprops = dict ( arrowstyle = t , <NEWLINE> <INDENT> fc = <STRING> , ec = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def next ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> row = [ ] <NEWLINE> while self . stop_sign not in self . buffer : <NEWLINE> <INDENT> bulk = self . read_bulk ( ) <NEWLINE> if bulk == <STRING> : <NEWLINE> <INDENT> raise StopIteration <NEWLINE> <DEDENT> self . buffer += bulk <NEWLINE> <DEDENT> left = <STRING> <NEWLINE> while left != self . stop_sign : <NEWLINE> <INDENT> left = self . buffer . popleft ( ) <NEWLINE> row . append ( left ) <NEWLINE> <DEDENT> return ( <STRING> . join ( row ) <NEWLINE> <DEDENT>
def _buildMpxNamesToApiEnumNames ( dummyClasses = None , dummyNodes = None ) : <NEWLINE> <INDENT> import pymel . api as api <NEWLINE> mpxNamesToEnumNames = { } <NEWLINE> with _DummyPluginNodesMaker ( dummyClasses = dummyClasses , <NEWLINE> <INDENT> alreadyCreated = dummyNodes ) as nodeMaker : <NEWLINE> for mpxCls , mayaNode in nodeMaker . nodes . iteritems ( ) : <NEWLINE> mobj = api . toMObject ( mayaNode ) <NEWLINE> mpxNamesToEnumNames [ mpxCls . __name__ ] = mobj . apiTypeStr ( ) <NEWLINE> <DEDENT> return mpxNamesToEnumNames <NEWLINE> <DEDENT>
( re . sub ( <STRING> , <STRING> , template_args [ <STRING> ] ) , <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> <DEDENT>
def run_server ( ) : <NEWLINE> <INDENT> app_logged = TransLogger ( app ) <NEWLINE> cherrypy . tree . graft ( app_logged , <STRING> ) <NEWLINE> cherrypy . config . update ( { <NEWLINE> <INDENT> <STRING> : True , <NEWLINE> <STRING> : True <NEWLINE> <STRING> : PORT , <NEWLINE> <STRING> : <STRING> <NEWLINE> <DEDENT> } ) <NEWLINE> cherrypy . engine . start ( ) <NEWLINE> cherrypy . engine . block ( ) <NEWLINE> <DEDENT>
def on_touch_down ( self , touch ) : <NEWLINE> <INDENT> ret = super ( Inspector , self ) . on_touch_down ( touch ) <NEWLINE> if ( ( <STRING> not in touch . profile or touch . button == <STRING> ) <NEWLINE> <INDENT> and not ret and self . inspect_enabled ) : <NEWLINE> self . highlight_at ( * touch . pos ) <NEWLINE> if touch . is_double_tap : <NEWLINE> self . inspect_enabled = False <NEWLINE> self . show_widget_info ( ) <NEWLINE> ret = True <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT>
def _find_starts ( self , linespec ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> linespec += <STRING> <NEWLINE> start_points = [ ] <NEWLINE> for item in self . _indent_list : <NEWLINE> <INDENT> match = re . search ( linespec , item [ 1 ] ) <NEWLINE> if match : <NEWLINE> <INDENT> entry = ( item , self . _indent_list . index ( item ) <NEWLINE> start_points . append ( entry ) <NEWLINE> <DEDENT> <DEDENT> return start_points <NEWLINE> <DEDENT>
class QueueItemSubtitle ( ShowQueueItem ) : <NEWLINE> <INDENT> def __init__ ( self , show = None ) : <NEWLINE> <INDENT> ShowQueueItem . __init__ ( self , ShowQueueActions . SUBTITLE , show ) <NEWLINE> <DEDENT> def run ( self ) : <NEWLINE> <INDENT> super ( QueueItemSubtitle , self ) . run ( ) <NEWLINE> logger . log ( <STRING> . format ( self . show . name ) <NEWLINE> self . show . download_subtitles ( ) <NEWLINE> super ( QueueItemSubtitle , self ) . finish ( ) <NEWLINE> self . finish ( ) <NEWLINE> <DEDENT> <DEDENT>
class HolonomicLinkage ( Linkage ) : <NEWLINE> <INDENT> holonomic = True <NEWLINE> def __init__ ( self , part1 , part2 , position , euler_angles , static_matrix1 , static_matrix2 , <NEWLINE> <INDENT> static_behavior_occurence_matrix , static_behavior_nonlinear_eq_indices , <NEWLINE> static_behavior_linear_eq , static_behavior_nonlinear_eq , <NEWLINE> kinematic_matrix , static_require_kinematic = False , name = <STRING> ) : <NEWLINE> Linkage . __init__ ( self , part1 , part2 , position , euler_angles , static_matrix1 , static_matrix2 , <NEWLINE> <INDENT> static_behavior_occurence_matrix , static_behavior_nonlinear_eq_indices , <NEWLINE> static_behavior_linear_eq , static_behavior_nonlinear_eq , <NEWLINE> static_require_kinematic , name ) <NEWLINE> self . kinematic_matrix = kinematic_matrix <NEWLINE> self . n_kinematic_unknowns = kinematic_matrix . shape [ 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def stopConnecting ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . state != <STRING> : <NEWLINE> <INDENT> raise error . NotConnectingError , <STRING> <NEWLINE> <DEDENT> self . state = <STRING> <NEWLINE> self . transport . failIfNotConnected ( error . UserError ( ) ) <NEWLINE> del self . transport <NEWLINE> <DEDENT>
def test_parse_2 ( self ) : <NEWLINE> <INDENT> off_mont = [ [ [ 128 , 62 , 100 ] , 1000 ] ] <NEWLINE> self . chapter_n . update ( off_mont ) <NEWLINE> <INDENT> size , notes_parsed = self . chapter_n . parse ( self . chapter_n . content ) <NEWLINE> <DEDENT> <DEDENT>
from pyspark import SparkContext <NEWLINE> from pyspark . mllib . feature import HashingTF , IDF <NEWLINE> sc = SparkContext ( appName = <STRING> ) <NEWLINE> path = <STRING> <NEWLINE> rdd = sc . wholeTextFiles ( <STRING> ) . map ( lambda ( name , text ) : text . split ( ) ) <NEWLINE> tf = HashingTF ( ) <NEWLINE> tfVectors = tf . transform ( rdd ) . cache ( ) <NEWLINE> idf = IDF ( ) <NEWLINE> IDFModel = idf . fit ( tfVectors ) <NEWLINE> tfIdfVectors = IDFModel . transform ( tfVectors ) <NEWLINE> tfIdfVectors . saveAsTextFile ( path ) <NEWLINE>
def __init__ ( self , numColumns ) : <NEWLINE> <INDENT> self . SetColumnCount ( numColumns ) <NEWLINE> list = self . GetListCtrl ( ) <NEWLINE> if not list : <NEWLINE> <INDENT> raise ValueError , <STRING> <NEWLINE> <DEDENT> list . Bind ( wx . EVT_LIST_COL_CLICK , self . __OnColClick , list ) <NEWLINE> <DEDENT>
def interpreter ( self ) : <NEWLINE> <INDENT> if not self . __check_session ( ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> interp = None <NEWLINE> for segment in self . elf . iter_segments ( ) : <NEWLINE> <INDENT> if segment [ <STRING> ] == <STRING> : <NEWLINE> <INDENT> interp = segment <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if interp : <NEWLINE> <INDENT> self . log ( <STRING> , <STRING> . format ( interp . get_interp_name ( ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . log ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def pairing_done ( self , data ) : <NEWLINE> <INDENT> if data is not None : <NEWLINE> <INDENT> self . cfg [ <STRING> ] = [ data [ <STRING> ] , data [ <STRING> ] , data [ <STRING> ] <NEWLINE> self . cfg [ <STRING> ] = 2 <NEWLINE> self . handler . win . wallet . get_keystore ( ) . cfg = self . cfg <NEWLINE> self . handler . win . wallet . save_keystore ( ) <NEWLINE> <DEDENT> self . pin = <STRING> <NEWLINE> self . accept ( ) <NEWLINE> <DEDENT>
def UpdateImage ( self , delay , event = None ) : <NEWLINE> <INDENT> global dev , status , calImage , calimgI , ImageFinal , label <NEWLINE> <INDENT> self . iteration += 1 <NEWLINE> self . image = self . get_image ( dev ) <NEWLINE> <DEDENT> ImageFinal = self . image <NEWLINE> <INDENT> label . configure ( image = ImageFinal , text = <STRING> % self . iteration ) <NEWLINE> self . after ( delay , self . UpdateImage , 1 ) <NEWLINE> <DEDENT> <DEDENT>
class Solution ( object ) : <NEWLINE> <INDENT> def reverseList ( self , head ) : <NEWLINE> <STRING> <NEWLINE> back = head <NEWLINE> curr = None <NEWLINE> if back : <NEWLINE> <INDENT> curr = head . next <NEWLINE> back . next = None <NEWLINE> <DEDENT> while curr : <NEWLINE> <INDENT> forw = curr . next <NEWLINE> curr . next = back <NEWLINE> back = curr <NEWLINE> curr = forw <NEWLINE> <DEDENT> return back <NEWLINE> <DEDENT>
def __init__ ( self , * args , ** kw ) <NEWLINE> <INDENT> self . already = False <NEWLINE> Fuse . __init__ ( self , * args , ** kw ) <NEWLINE> <DEDENT>
def _create_connection ( ( host , port ) , connect_timeout ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if sys . version_info < ( 2 , 6 ) : <NEWLINE> <INDENT> ( family , _ ) = _convert_host_to_ip ( host ) <NEWLINE> connect_socket = socket . socket ( family , socket . SOCK_STREAM ) <NEWLINE> connect_socket . settimeout ( connect_timeout ) <NEWLINE> connect_socket . connect ( ( host , port ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> connect_socket = socket . create_connection ( ( host , port ) , connect_timeout ) <NEWLINE> <DEDENT> return connect_socket <NEWLINE> <DEDENT>
def test_marvin_function_exception ( self ) : <NEWLINE> <INDENT> from headjack . archiver import marvin <NEWLINE> try : <NEWLINE> <INDENT> this = marvin ( <NEWLINE> <INDENT> log = log , <NEWLINE> settings = settings , <NEWLINE> fakeKey = <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> this . get ( ) <NEWLINE> assert False <NEWLINE> <DEDENT> except Exception , e : <NEWLINE> <INDENT> assert True <NEWLINE> print ( str ( e ) ) <NEWLINE> <DEDENT> <DEDENT>
def convert ( color , converter ) : <NEWLINE> <INDENT> if isinstance ( color , gtk . gdk . Color ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif type ( color ) == type ( 0 ) or type ( color ) == type ( 0 l ) : <NEWLINE> <INDENT> color = int2gdk ( color ) <NEWLINE> <DEDENT> elif type ( color ) == type ( <STRING> ) : <NEWLINE> <INDENT> color = str2gdk ( color ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise TypeError ( <STRING> % type ( color ) ) <NEWLINE> <DEDENT> return converter ( color ) <NEWLINE> <DEDENT>
def __parse_addrs ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . __src = dotted_to_int ( self . src ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> try : <NEWLINE> self . __src = dotted_to_int ( socket . gethostbyname ( self . src ) ) <NEWLINE> except ValueError : <NEWLINE> raise ValueError , <STRING> <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> self . __dst = dotted_to_int ( self . dst ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> try : <NEWLINE> self . __dst = dotted_to_int ( socket . gethostbyname ( self . dst ) ) <NEWLINE> except ValueError : <NEWLINE> raise ValueError , <STRING> <NEWLINE> <DEDENT> <DEDENT>
class Ui_Dialog ( object ) : <NEWLINE> <INDENT> def setupUi ( self , Dialog ) : <NEWLINE> <INDENT> Dialog . setObjectName ( _fromUtf8 ( <STRING> ) ) <NEWLINE> Dialog . resize ( 936 , 610 ) <NEWLINE> icon = QtGui . QIcon ( ) <NEWLINE> icon . addPixmap ( QtGui . QPixmap ( _fromUtf8 ( <STRING> ) ) , QtGui . QIcon . Normal , QtGui . QIcon . Off ) <NEWLINE> Dialog . setWindowIcon ( icon ) <NEWLINE> Dialog . setStyleSheet ( _fromUtf8 ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
def _extend_network_qos_queue ( self , context , network ) : <NEWLINE> <INDENT> if self . _check_view_auth ( context , { <STRING> : None } , <NEWLINE> <INDENT> ext_qos . qos_queue_get ) : <NEWLINE> filters = { <STRING> : [ network [ <STRING> ] ] } <NEWLINE> fields = [ <STRING> ] <NEWLINE> network [ ext_qos . QUEUE ] = None <NEWLINE> queue_id = self . _get_network_queue_bindings ( <NEWLINE> context , filters , fields ) <NEWLINE> if queue_id : <NEWLINE> network [ ext_qos . QUEUE ] = queue_id [ 0 ] [ <STRING> ] <NEWLINE> <DEDENT> return network <NEWLINE> <DEDENT>
def _reselect_row ( model , _ , iter_ , ( selection , selected_rows , ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if model . get_value ( iter_ , 0 ) in selected_rows : <NEWLINE> <INDENT> selection . select_iter ( iter_ ) <NEWLINE> <DEDENT> <DEDENT>
def update_screen_rgbabits ( self , ( x , y ) , ( w , h ) , data ) : <NEWLINE> <INDENT> ( x0 , y0 ) = self . screenpos <NEWLINE> self . screen . blit_rgba ( x - x0 , y - y0 , w , h , data ) <NEWLINE> <DEDENT>
def CalcAndSetPosition ( self ) : <NEWLINE> <INDENT> parentSize = self . GetParent ( ) . GetSize ( ) <NEWLINE> mySize = self . GetSize ( ) <NEWLINE> <INDENT> maxXCoord = parentSize . width - mySize . width <NEWLINE> xCoord = maxXCoord * self . xrel <NEWLINE> maxYCoord = parentSize . height - mySize . height <NEWLINE> yCoord = maxYCoord * self . yrel <NEWLINE> position = wx . Point ( xCoord , yCoord ) <NEWLINE> position = self . GetParent ( ) . ClientToScreen ( position ) <NEWLINE> self . SetPosition ( position ) <NEWLINE> <DEDENT> <DEDENT>
def get_hash ( self ) : <NEWLINE> <INDENT> return reduce ( lambda a , ( ik , v ) , hc = self . kcase : <NEWLINE> <INDENT> a . update ( { hc [ ik ] : v } ) or a , self . data . items ( ) , { } ) <NEWLINE> <DEDENT> <DEDENT>
def __init__ ( self , persistent_filepath = None , write_when_destructed = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . persistent_filepath = persistent_filepath <NEWLINE> self . write_when_destructed = write_when_destructed <NEWLINE> self . _is_dirty = False <NEWLINE> self . _cache = { } <NEWLINE> if ( self . persistent_filepath is not None <NEWLINE> <INDENT> and osp . exists ( self . persistent_filepath ) <NEWLINE> and os . stat ( self . persistent_filepath ) . st_size > 0 ) : <NEWLINE> with open ( self . persistent_filepath , <STRING> ) as fp : <NEWLINE> self . _cache = pickle . load ( fp ) <NEWLINE> <DEDENT> <DEDENT>
def test_broken_connection ( self , mock_ver ) : <NEWLINE> <INDENT> for ( error , domain ) in ( <NEWLINE> <INDENT> ( fakelibvirt . VIR_ERR_SYSTEM_ERROR , <NEWLINE> <INDENT> fakelibvirt . VIR_FROM_REMOTE ) , <NEWLINE> <DEDENT> ( fakelibvirt . VIR_ERR_SYSTEM_ERROR , <NEWLINE> <INDENT> fakelibvirt . VIR_FROM_RPC ) , <NEWLINE> <DEDENT> ( fakelibvirt . VIR_ERR_INTERNAL_ERROR , <NEWLINE> <INDENT> fakelibvirt . VIR_FROM_RPC ) ) : <NEWLINE> conn = self . host . _connect ( <STRING> , False ) <NEWLINE> mock_ver . side_effect = fakelibvirt . make_libvirtError ( <NEWLINE> <DEDENT> fakelibvirt . libvirtError , <NEWLINE> <STRING> , <NEWLINE> error_code = error , <NEWLINE> error_domain = domain ) <NEWLINE> self . assertFalse ( self . host . _test_connection ( conn ) ) <NEWLINE> <DEDENT> <DEDENT>
def getSubscribed ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if ALLVERBOSE or VERBOSE : print <STRING> <NEWLINE> d = self . server . protocol . lsub ( <STRING> , <STRING> ) <NEWLINE> d . addCallback ( self . __getSubscribed_cb ) <NEWLINE> return d <NEWLINE> <DEDENT>
class CreateContactView ( CreateView ) : <NEWLINE> <INDENT> model = Contact <NEWLINE> template_name = <STRING> <NEWLINE> form_class = forms . ContactForm <NEWLINE> def get_success_url ( self ) : <NEWLINE> <INDENT> return reverse ( <STRING> ) <NEWLINE> <DEDENT> def get_context_data ( self , ** kwargs ) : <NEWLINE> context = super ( CreateContactView , self ) . get_context_data ( ** kwargs ) <NEWLINE> context [ <STRING> ] = reverse ( <STRING> ) <NEWLINE> return context <NEWLINE> <DEDENT>
def readJobInfo ( jobtext ) : <NEWLINE> <INDENT> job = Job ( ) <NEWLINE> lines = jobtext . split ( <STRING> ) <NEWLINE> for line in lines : <NEWLINE> <INDENT> pair = line . split ( <STRING> ) <NEWLINE> if len ( pair ) > 1 : <NEWLINE> <INDENT> key , value = pair <NEWLINE> exec <STRING> + key . strip ( ) + <STRING> + <STRING> + value . strip ( ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> return job ; <NEWLINE> <DEDENT>
def textPosition ( self , pos ) : <NEWLINE> <INDENT> if type ( pos ) not in [ tuple , list ] or len ( pos ) != 2 : <NEWLINE> <INDENT> raise AttributeError , <STRING> <STRING> <NEWLINE> <DEDENT> self . setTextPosition ( pos [ 0 ] , pos [ 1 ] ) <NEWLINE> <DEDENT>
def __init__ ( self ) : <NEWLINE> <INDENT> self . __client = config . api_client <NEWLINE> self . __base = defaults . get ( <STRING> , <STRING> . format ( HOST_IP , HOST_PORT ) ) <NEWLINE> self . __obm_options = { <NEWLINE> <INDENT> <STRING> : defaults . get ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def merge ( self , nuevaTabla ) : <NEWLINE> <INDENT> error = None <NEWLINE> for i in nuevaTabla . lista : <NEWLINE> <INDENT> if self . isMember ( i . id , 0 ) : <NEWLINE> error = ( i . lineno , i . colno , i . id ) <NEWLINE> else : <NEWLINE> self . insert ( i ) <NEWLINE> <DEDENT> return error <NEWLINE> <DEDENT>
def pretty_wait_print ( ) : <NEWLINE> <INDENT> SECS_4_3 = int ( ( 4.0 / 3 ) / WAIT_TIME ) <NEWLINE> SECS_1_3 = int ( ( 1.0 / 3 ) / WAIT_TIME ) <NEWLINE> print ( <STRING> , <NEWLINE> print ( <STRING> % serial_port , ) <NEWLINE> for i in range ( pretty_wait_print . count - SECS_1_3 , 0 , - SECS_1_3 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> sys . stdout . flush ( ) <NEWLINE> pretty_wait_print . count = ( pretty_wait_print . count + 1 ) % ( SECS_4_3 - 1 ) <NEWLINE> <DEDENT>
def assign_molweight ( atom_id ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> MOLWEIGHTS = { <NEWLINE> <INDENT> <STRING> : 0.0 , <STRING> : 1.00794 , <STRING> : 12.0107 , <STRING> : 14.0067 , <NEWLINE> <STRING> : 15.9994 , <STRING> : 30.973761 , <STRING> : 32.065 } <NEWLINE> for char in atom_id : <NEWLINE> if char in MOLWEIGHTS . keys ( ) : <NEWLINE> atom_name = char <NEWLINE> break <NEWLINE> <DEDENT> if atom_name in MOLWEIGHTS . keys ( ) : <NEWLINE> <INDENT> molweight = MOLWEIGHTS [ atom_name ] <NEWLINE> return molweight <NEWLINE> <DEDENT> else : raise PyRyStructureError ( <STRING> + atom_name ) <NEWLINE> <DEDENT>
def test_builds ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> try : <NEWLINE> <INDENT> b = travis . Build ( - 1 ) <NEWLINE> <DEDENT> except Exception as ex : <NEWLINE> <INDENT> self . assertEqual ( <STRING> , type ( ex ) . __name__ ) <NEWLINE> <DEDENT> b = travis . Build ( self . valid_build_id ) <NEWLINE> self . assertIsInstance ( b , travis . Build ) <NEWLINE> <INDENT> for job in b . matrix : <NEWLINE> <INDENT> self . assertIsInstance ( job , travis . Job ) <NEWLINE> <DEDENT> self . assertEqual ( b . jobs , 2 ) <NEWLINE> <DEDENT> <DEDENT>
def getScalars ( self input ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return numpy . array ( self . getEncodedValues ( input ) ) <NEWLINE> <DEDENT>
csvpath = <STRING> % ( path , yesterday ( ) , ConfigSectionMap ( <STRING> ) [ <STRING> ] ) ) <NEWLINE>
def nextButtonCallBack ( self , button , * args ) : <NEWLINE> <INDENT> self . vBoxMain . get_children ( ) [ self . currentIndexExercise ] . hide ( ) <NEWLINE> <INDENT> self . currentIndexExercise = self . currentIndexExercise + 1 <NEWLINE> self . vBoxMain . get_children ( ) [ self . currentIndexExercise ] . show_all ( ) <NEWLINE> self . manageBackNextButtons ( ) <NEWLINE> <DEDENT> <DEDENT>
def calcHash ( listEntry ) : <NEWLINE> <INDENT> for el in listEntry : <NEWLINE> if len ( listEntry [ el ] ) == 0 : <NEWLINE> <INDENT> f = file ( el , <STRING> ) <NEWLINE> hash = hashlib . sha1 ( f . read ( ) ) . hexdigest ( ) <NEWLINE> listEntry [ el ] = hash <NEWLINE> <DEDENT> <DEDENT>
def test_dense_sparse ( ) : <NEWLINE> <INDENT> for test_func in ( _test_ridge_loo , <NEWLINE> <INDENT> _test_ridge_cv , <NEWLINE> _test_ridge_diabetes , <NEWLINE> _test_multi_ridge_diabetes , <NEWLINE> _test_ridge_classifiers , <NEWLINE> _test_tolerance ) : <NEWLINE> ret_dense = test_func ( DENSE_FILTER ) <NEWLINE> ret_sparse = test_func ( SPARSE_FILTER ) <NEWLINE> if ret_dense is not None and ret_sparse is not None : <NEWLINE> assert_array_almost_equal ( ret_dense , ret_sparse , decimal = 3 ) <NEWLINE> <DEDENT> <DEDENT>
def variableName ( name ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <INDENT> return name . isidentifier ( ) <NEWLINE> <DEDENT> <DEDENT>
from sqlalchemy . ext . declarative import declarative_base <NEWLINE> from sqlalchemy . orm import scoped_session , sessionmaker <NEWLINE> from zope . sqlalchemy import ZopeTransactionExtension <NEWLINE> DBSession = scoped_session ( sessionmaker ( extension = ZopeTransactionExtension ( ) ) <NEWLINE> Base = declarative_base ( ) <NEWLINE>
def on_key_press ( key , modifiers ) : <NEWLINE> <INDENT> if board . is_won ( ) : <NEWLINE> exit ( ) <NEWLINE> if key == pyglet . window . key . RIGHT : <NEWLINE> <INDENT> board . advance_right ( ) <NEWLINE> <DEDENT> elif key == pyglet . window . key . LEFT : <NEWLINE> <INDENT> board . advance_left ( ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> print ( <STRING> ) <NEWLINE> def my_long_function_name ( long_variable_one = <STRING> , long_variable_two = True , <NEWLINE> <INDENT> long_variable_three = 123 ) : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> def another_long_function ( <NEWLINE> <INDENT> long_variable_one = <STRING> , long_variable_two = True , <NEWLINE> long_variable_three = 123 ) : <NEWLINE> if long_variable_two : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> foo = another_long_function ( <NEWLINE> <INDENT> long_variable_one = <STRING> , long_variable_two = False , <NEWLINE> long_variable_three = 100 ) <NEWLINE> <DEDENT>
def _GenerateBenchmarkDocumentation ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> benchmark_docs = [ ] <NEWLINE> for benchmark_module in ( benchmarks . BENCHMARKS + <NEWLINE> <INDENT> windows_benchmarks . BENCHMARKS ) : <NEWLINE> benchmark_info = benchmark_module . BENCHMARK_INFO <NEWLINE> vm_count = benchmark_info . get ( <STRING> ) or <STRING> <NEWLINE> scratch_disk_str = <STRING> <NEWLINE> if benchmark_info . get ( <STRING> ) : <NEWLINE> scratch_disk_str = <STRING> <NEWLINE> name = benchmark_info [ <STRING> ] <NEWLINE> if benchmark_module in windows_benchmarks . BENCHMARKS : <NEWLINE> name += <STRING> <NEWLINE> benchmark_docs . append ( <STRING> % <NEWLINE> ( name , <NEWLINE> benchmark_info [ <STRING> ] , <NEWLINE> vm_count , <NEWLINE> scratch_disk_str ) ) <NEWLINE> <DEDENT> return <STRING> . join ( benchmark_docs ) <NEWLINE> <DEDENT>
class QConfigurationPathEdit ( QConfigurationLineEditButton ) : <NEWLINE> <INDENT> def __init__ ( self , key , field , callback_f , <NEWLINE> <INDENT> button_cls = QDirectoryChooserToolButton , parent = None ) : <NEWLINE> QConfigurationLineEditButton . __init__ ( self , key , field , callback_f , <NEWLINE> <INDENT> None , parent ) <NEWLINE> button = button_cls ( self , self . line_edit ) <NEWLINE> self . add_button ( button ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys , os <NEWLINE> current = os . path . dirname ( __file__ ) <NEWLINE> sys . path . insert ( 0 , os . path . normpath ( os . path . join ( current , <STRING> ) ) ) ) <NEWLINE> from service import main <NEWLINE> if not os . path . exists ( <STRING> ) : <NEWLINE> <INDENT> os . mkdir ( <STRING> ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
def is_horizontal_line ( ( x1 , y1 ) , ( x2 , y2 ) ) : <NEWLINE> <INDENT> dx = abs ( x2 - x1 ) <NEWLINE> dy = abs ( y2 - y1 ) <NEWLINE> return dx > dy <NEWLINE> <DEDENT>
def lil_eye ( ( r , c ) , k = 0 , dtype = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> warn ( <STRING> <STRING> , DeprecationWarning ) <NEWLINE> return eye ( r , c , k , dtype = dtype , format = <STRING> ) <NEWLINE> <DEDENT>
def hscaleRbOD_adj_value_changed ( self , slider ) : <NEWLINE> <INDENT> self . RbParameters [ <STRING> ] . set_clim ( 0 , slider . get_value ( ) <NEWLINE> self . RbParameters [ <STRING> ] . draw_idle ( ) <NEWLINE> <DEDENT>
def psi ( self , F ) : <NEWLINE> <INDENT> temp1 = - self . a * ( self . mu - F ) <NEWLINE> temp2 = self . a ** 2 * ( 1 / self . gamma + 1 / self . gx ) / 2 <NEWLINE> return ( 1 / self . a ) * ( 1 - np . exp ( temp1 + temp2 ) - self . c <NEWLINE> <DEDENT>
( <STRING> % ( module_name , module_version , <NEWLINE> <INDENT> len ( module_exports ) , len ( module_forwards ) ) ; <NEWLINE> <DEDENT> return True ; <NEWLINE> <DEDENT> finally : <NEWLINE> <INDENT> file_handle . close ( ) ; <NEWLINE> <DEDENT> <DEDENT>
def setBuildMode ( self , Id , Status ) : <NEWLINE> <INDENT> Response = self . PUT ( self . SatAPILocation + <STRING> + str ( Id ) , <NEWLINE> <INDENT> json . dumps ( { <STRING> : { <STRING> : Status } } ) ) <NEWLINE> return Response <NEWLINE> <DEDENT> <DEDENT>
